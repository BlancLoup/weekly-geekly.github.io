<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create a platformer in 30 minutes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! Today we will write a platformer using C ++, Box2D and SFML, as well as a 2D map editor for the Tiled Map Editor games. 



 Here is the result...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create a platformer in 30 minutes</h1><div class="post__text post__text-html js-mediator-article">  Hello!  Today we will write a platformer using C ++, Box2D and SFML, as well as a 2D map editor for the <a href="http://habrahabr.ru/post/148653/">Tiled Map Editor</a> games. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/601/b21/f51/601b21f51d4be0d9d0f022c0d30a43ae.png" alt="image"><br><br>  Here is the result (the map was created 5 minutes + while shooting the game was slowed down + the screen was not so stretched - Bandicam defect): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/0NUAUMjQigI%3Ffeature%3Doembed&amp;xid=25657,15700022,15700186,15700191,15700253&amp;usg=ALkJrhj63EXyEIy2yZRbAmqW7_LfU4Tr7Q" frameborder="0" allowfullscreen=""></iframe><br><br>  Sources and exe - at the bottom of the article. <br><a name="habracut"></a><br><h4>  What where When? </h4><br><h5>  Box2d </h5><br>  We will use this library to simulate physics in a platform (collision with blocks, gravity).  It might not have been worth using this library for blocks alone, but you can't forbid living beautifully;) <br>  Why choose Box2D?  Because it is the most common and free physical library. <br><br><h5>  SFML </h5><br>  Why SFML?  At first, I wanted to use the SDL library, but it is very limited in capabilities as compared to SFML, I would have to add a lot myself.  Thanks to the SFML author for the time saved! <br>  We use it to draw graphics. <br><br><h5>  Tiled map editor </h5><br>  What does the Tiled Map Editor do here? <br>  Have you ever tried to create maps for games?  I bet that your first card was something like that. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre><code class="bash hljs">1111111 1000001 1001001 1000011 1000111 1111111</code> </pre> <br></div></div><br><br>  This is a rather ineffective solution!  It is much better to write something like a map editor, but in hindsight we understand that this is not done in 5 minutes, and the above ‚Äúmap‚Äù is completely. <br><br>  Tiled Map Editor is one such map editor.  It is good because the map created in this editor (consists of objects, tiles, their layers) can be saved in an XML-like .tmx file and then read it using a special C ++ library.  But first things first. <br><br><h4>  Creating a map </h4><br>  We download TME from the official <a href="http://www.mapeditor.org/">site</a> <br>  Create a new map "File-&gt; Create ..." <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dab/377/6e7/dab3776e7a9c854bff8a878991fff56a.png" alt="image"><br><br>  The orientation should be orthogonal (if you are not doing an isometric platform), and the format of the XML layer, we will read this format <br>  By the way, neither the format of the layer, nor the size of the tiles can be changed in the created map. <br><br><h5>  Tiles </h5><br>  Then go to ‚ÄúMap-&gt; New Tile Set ...‚Äù, load our tileset: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3bf/459/069/3bf4590693648204410863d265811961.png" alt="image"><br><br>  You end up with something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e91/926/20c/e9192620c22ea1b81890d5b07beb7ba9.png" alt="image"><br><br>  What is the meaning of layers of tiles? <br>  Almost every game has multi-layered cards.  The first layer is earth (ice, black soil, etc), the second layer is buildings (barracks, fort, etc, the background is transparent), the third is trees (spruce, fir, etc, the background is also transparent).  That is, the first layer is drawn first, a second layer is laid over it, and then the third one. <br><br>  The process of creating layers is captured in the following 4 screenshots: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/538/068/9c4/5380689c446222a47247643a8eb84ac9.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/434/709/919/4347099196bdc1027eac74c06c448146.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/9b5/6e1/24f/9b56e124fe8ec32ecb9b5eb12f1e8e3e.png" alt="image"><br><br>  List of layers: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dad/944/7cf/dad9447cfadacdc58f961053156fb844.png" alt="image"><br><br><h5>  Objects </h5><br>  What is an object in TME? <br>  The object has its own name, type, and parameters with values. <br>  This panel is responsible for the objects. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8e3/3ea/7a0/8e33ea7a0a01a43830698c18a4d30efe.png" alt="image"><br><br>  You can easily find out what each button does, yourself. <br>  Now try to create an object. <br>  Delete the ‚ÄúKolobosha‚Äù layer, instead create a layer of objects, for example, with the same name ‚ÄúKolobosha‚Äù.  Select "Insert Tile Object" from the panel for objects (or you can select any shape - Shape), click on the Kolo≈°i Tile and just put the object in some place. <br>  Then we right-click on the object and click on "Object properties ...".  Change the name of the object to Kolobosha. <br><br>  Then save the card. <br><br>  In general, there is nothing daunting in the map editors.  It's time to move on to read the card. <br><br><h4>  Card reading </h4><br>  An excellent <a href="http://www.grinninglizard.com/tinyxml/">TinyXML</a> library has <a href="http://www.grinninglizard.com/tinyxml/">been</a> created for reading XML files. Download its sources. <br><br>  Create a Visual Studio project.  Connect the TinyXML files (or just push all these files into the project, except for xmltest.cpp :)) <br>  Now we include the SFML libs and libs in ‚ÄúProject-&gt; Properties‚Äù.  If you do not know how to do this - welcome to Google <br><br>  Create Level.h for maps <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> LEVEL_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LEVEL_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> comment(lib,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Box2D.lib"</span></span></span><span class="hljs-meta">) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> comment(lib,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sfml-graphics.lib"</span></span></span><span class="hljs-meta">) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> comment(lib,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sfml-window.lib"</span></span></span><span class="hljs-meta">) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> comment(lib,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sfml-system.lib"</span></span></span><span class="hljs-meta">) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;SFML/Graphics.hpp&gt;</span></span></span></span></code> </pre><br>  This is the beginning of the file. <br><br>  Next comes the structure of the object. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Object</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertyInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertyFloat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertyString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> type; sf::Rect&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; rect; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; properties; sf::Sprite sprite; };</code> </pre><br>  Let's sort it out. <br>  As already mentioned, in TME each object can have parameters.  The parameters are taken from the XML file, are recorded in the properties, and then they can be obtained from any of the first three functions.  name - the name of the object, type - its type, rect - a rectangle describing the object.  Finally, sprite ‚Äî a sprite (image) ‚Äîthe part of the tileset taken for the object.  Sprite may not be. <br><br>  Now comes the structure of the layer - it is very simple <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Layer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> opacity; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;sf::Sprite&gt; tiles; };</code> </pre><br><br>  There is transparency in the layer (yes, yes, we can make translucent layers!) And a list of tiles. <br><br>  Next is the Level class: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Level</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadFromFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filename)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Object&gt; GetObjects(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sf::RenderWindow &amp;window)</span></span></span></span>; sf::<span class="hljs-function"><span class="hljs-function">Vector2i </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTileSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, height, tileWidth, tileHeight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstTileID; sf::Rect&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; drawingBounds; sf::Texture tilesetImage; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Object&gt; objects; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Layer&gt; layers; }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br>  <b>LoadFromFile</b> loads the map from the specified file.  This is the heart of the Level class. <br>  <b>GetObject</b> returns the first object with the specified name, <b>GetObjects</b> returns a list of objects with the specified name.  Actually, in an amicable way, I should have used the type of the object, but it was more convenient for me to catch blocks and the player through the name, since in the editor the name is shown on top of the object, but the type is not. <br>  <b>Draw</b> draws all tiles (not objects!), Taking an instance of RenderWindow. <br><br>  Now create Level.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"level.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "tinyxml.h"</span></span></span></span></code> </pre><br><br>  First we process the structure of the objects. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Object::GetPropertyInt(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> atoi(properties[name].c_str()); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Object::GetPropertyFloat(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strtod(properties[name].c_str(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Object::GetPropertyString(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> properties[name]; }</code> </pre><br><br>  For the Layer implementation is not needed, go to Level: <br><br><div class="spoiler">  <b class="spoiler_title">bool Level :: LoadFromFile (std :: string filename)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Level::LoadFromFile(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> filename) { <span class="hljs-function"><span class="hljs-function">TiXmlDocument </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">levelFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename.c_str())</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  XML- if(!levelFile.LoadFile()) { std::cout &lt;&lt; "Loading level \"" &lt;&lt; filename &lt;&lt; "\" failed." &lt;&lt; std::endl; return false; } //    map TiXmlElement *map; map = levelFile.FirstChildElement("map"); //  : &lt;map version="1.0" orientation="orthogonal" // width="10" height="10" tilewidth="34" tileheight="34"&gt; width = atoi(map-&gt;Attribute("width")); height = atoi(map-&gt;Attribute("height")); tileWidth = atoi(map-&gt;Attribute("tilewidth")); tileHeight = atoi(map-&gt;Attribute("tileheight")); //        TiXmlElement *tilesetElement; tilesetElement = map-&gt;FirstChildElement("tileset"); firstTileID = atoi(tilesetElement-&gt;Attribute("firstgid")); // source -      image TiXmlElement *image; image = tilesetElement-&gt;FirstChildElement("image"); std::string imagepath = image-&gt;Attribute("source"); //    sf::Image img; if(!img.loadFromFile(imagepath)) { std::cout &lt;&lt; "Failed to load tile sheet." &lt;&lt; std::endl; return false; } //     (109, 159, 185) // -       ,     ,  16-  //  "6d9fb9"    img.createMaskFromColor(sf::Color(109, 159, 185)); //     tilesetImage.loadFromImage(img); //   tilesetImage.setSmooth(false); //       int columns = tilesetImage.getSize().x / tileWidth; int rows = tilesetImage.getSize().y / tileHeight; //     (TextureRect) std::vector&lt;sf::Rect&lt;int&gt;&gt; subRects; for(int y = 0; y &lt; rows; y++) for(int x = 0; x &lt; columns; x++) { sf::Rect&lt;int&gt; rect; rect.top = y * tileHeight; rect.height = tileHeight; rect.left = x * tileWidth; rect.width = tileWidth; subRects.push_back(rect); } //    TiXmlElement *layerElement; layerElement = map-&gt;FirstChildElement("layer"); while(layerElement) { Layer layer; //   opacity,    ,     if (layerElement-&gt;Attribute("opacity") != NULL) { float opacity = strtod(layerElement-&gt;Attribute("opacity"), NULL); layer.opacity = 255 * opacity; } else { layer.opacity = 255; } //  &lt;data&gt; TiXmlElement *layerDataElement; layerDataElement = layerElement-&gt;FirstChildElement("data"); if(layerDataElement == NULL) { std::cout &lt;&lt; "Bad map. No layer information found." &lt;&lt; std::endl; } //  &lt;tile&gt; -     TiXmlElement *tileElement; tileElement = layerDataElement-&gt;FirstChildElement("tile"); if(tileElement == NULL) { std::cout &lt;&lt; "Bad map. No tile information found." &lt;&lt; std::endl; return false; } int x = 0; int y = 0; while(tileElement) { int tileGID = atoi(tileElement-&gt;Attribute("gid")); int subRectToUse = tileGID - firstTileID; //  TextureRect   if (subRectToUse &gt;= 0) { sf::Sprite sprite; sprite.setTexture(tilesetImage); sprite.setTextureRect(subRects[subRectToUse]); sprite.setPosition(x * tileWidth, y * tileHeight); sprite.setColor(sf::Color(255, 255, 255, layer.opacity)); layer.tiles.push_back(sprite); } tileElement = tileElement-&gt;NextSiblingElement("tile"); x++; if (x &gt;= width) { x = 0; y++; if(y &gt;= height) y = 0; } } layers.push_back(layer); layerElement = layerElement-&gt;NextSiblingElement("layer"); } //    TiXmlElement *objectGroupElement; //     if (map-&gt;FirstChildElement("objectgroup") != NULL) { objectGroupElement = map-&gt;FirstChildElement("objectgroup"); while (objectGroupElement) { //  &lt;object&gt; TiXmlElement *objectElement; objectElement = objectGroupElement-&gt;FirstChildElement("object"); while(objectElement) { //    - , , , etc std::string objectType; if (objectElement-&gt;Attribute("type") != NULL) { objectType = objectElement-&gt;Attribute("type"); } std::string objectName; if (objectElement-&gt;Attribute("name") != NULL) { objectName = objectElement-&gt;Attribute("name"); } int x = atoi(objectElement-&gt;Attribute("x")); int y = atoi(objectElement-&gt;Attribute("y")); int width, height; sf::Sprite sprite; sprite.setTexture(tilesetImage); sprite.setTextureRect(sf::Rect&lt;int&gt;(0,0,0,0)); sprite.setPosition(x, y); if (objectElement-&gt;Attribute("width") != NULL) { width = atoi(objectElement-&gt;Attribute("width")); height = atoi(objectElement-&gt;Attribute("height")); } else { width = subRects[atoi(objectElement-&gt;Attribute("gid")) - firstTileID].width; height = subRects[atoi(objectElement-&gt;Attribute("gid")) - firstTileID].height; sprite.setTextureRect(subRects[atoi(objectElement-&gt;Attribute("gid")) - firstTileID]); } //   Object object; object.name = objectName; object.type = objectType; object.sprite = sprite; sf::Rect &lt;int&gt; objectRect; objectRect.top = y; objectRect.left = x; objectRect.height = height; objectRect.width = width; object.rect = objectRect; // ""  TiXmlElement *properties; properties = objectElement-&gt;FirstChildElement("properties"); if (properties != NULL) { TiXmlElement *prop; prop = properties-&gt;FirstChildElement("property"); if (prop != NULL) { while(prop) { std::string propertyName = prop-&gt;Attribute("name"); std::string propertyValue = prop-&gt;Attribute("value"); object.properties[propertyName] = propertyValue; prop = prop-&gt;NextSiblingElement("property"); } } } //     objects.push_back(object); objectElement = objectElement-&gt;NextSiblingElement("object"); } objectGroupElement = objectGroupElement-&gt;NextSiblingElement("objectgroup"); } } else { std::cout &lt;&lt; "No object layers found..." &lt;&lt; std::endl; } return true; }</span></span></code> </pre><br></div></div><br><br>  The remaining Level functions: <br><br><pre> <code class="cpp hljs">Object Level::GetObject(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name) { <span class="hljs-comment"><span class="hljs-comment">//       for (int i = 0; i &lt; objects.size(); i++) if (objects[i].name == name) return objects[i]; } std::vector&lt;Object&gt; Level::GetObjects(std::string name) { //      std::vector&lt;Object&gt; vec; for(int i = 0; i &lt; objects.size(); i++) if(objects[i].name == name) vec.push_back(objects[i]); return vec; } sf::Vector2i Level::GetTileSize() { return sf::Vector2i(tileWidth, tileHeight); } void Level::Draw(sf::RenderWindow &amp;window) { //    (  !) for(int layer = 0; layer &lt; layers.size(); layer++) for(int tile = 0; tile &lt; layers[layer].tiles.size(); tile++) window.draw(layers[layer].tiles[tile]); }</span></span></code> </pre><br><br>  With Level.h over! <br><br>  Test it. <br>  Create main.cpp and write: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"level.h"</span></span></span><span class="hljs-meta"> int main() { Level level; level.LoadFromFile(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"test.tmx"</span></span></span><span class="hljs-meta">); sf::RenderWindow window; window.create(sf::VideoMode(800, 600), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Level.h test"</span></span></span><span class="hljs-meta">); while(window.isOpen()) { sf::Event event; while(window.pollEvent(event)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(event.type == sf::Event::Closed) window.close(); } window.clear(); level.Draw(window); window.display(); } return 0; }</span></span></code> </pre><br><br>  The card can look like anything! <br><br>  You can play with objects: <br><br><img src="http://s6.hostingkartinok.com/uploads/images/2013/10/e99cc289b5fb814eb7c509ed69cef81c.png" alt="image"><br><br>  main.cpp <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"level.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { Level level; level.LoadFromFile("test.tmx"); Object kolobosha = level.GetObject("Kolobosha"); std::cout &lt;&lt; kolobosha.name &lt;&lt; std::endl; std::cout &lt;&lt; kolobosha.type &lt;&lt; std::endl; std::cout &lt;&lt; kolobosha.GetPropertyInt("health") &lt;&lt; std::endl; std::cout &lt;&lt; kolobosha.GetPropertyString("mood") &lt;&lt; std::endl; sf::RenderWindow window; window.create(sf::VideoMode(800, 600), "Kolobosha adventures"); while(window.isOpen()) { sf::Event event; while(window.pollEvent(event)) { if(event.type == sf::Event::Closed) window.close(); } window.clear(); level.Draw(window); window.display(); } return 0; }</span></span></span></span></code> </pre><br><br>  Result: <br><br><img src="http://s3.hostingkartinok.com/uploads/images/2013/10/65774b5a0cc0887d293dd29f9eea7677.png" alt="image"><br><br>  When you play around with objects, it's time for Box2D: <br><br><h4>  Boxes-boxes </h4><br>  We want to create a <s>3D action</s> platform <s>game</s> , the essence is ... <br>  On the map there are objects - with the names player - player, enemy - enemy, block - block, money - coins. <br>  We load the player, make him obey the keystrokes and force of Newton. <br>  Enemies go back and forth, pushing a player too close and die if the player jumps on them <br>  The blocks are fixed "in the air" as static objects, the player can jump on them <br>  Coins give nothing, just disappear when confronted with a player <br><br>  Open main.h, erase what was written there, and write: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"level.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Box2D\Box2D.h&gt; #include &lt;iostream&gt; #include &lt;random&gt; Object player; b2Body* playerBody; std::vector&lt;Object&gt; coin; std::vector&lt;b2Body*&gt; coinBody; std::vector&lt;Object&gt; enemy; std::vector&lt;b2Body*&gt; enemyBody;</span></span></span></span></code> </pre><br><br>  Here we have level.h and Box2D.h.  iostream is needed for output to the console, random is for generating the direction of the enemy's movement. <br>  Next come the player and the vectors, each enemy, coin, player relies on his Object and b2Body (body in Box2D). <br><br>  Attention - the blocks do not rely on this, since they interact with the player only at the level of Box2D physics, and not in the game logic. <br><br>  Further: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ srand(time(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)); Level lvl; lvl.LoadFromFile(<span class="hljs-string"><span class="hljs-string">"platformer.tmx"</span></span>); <span class="hljs-function"><span class="hljs-function">b2Vec2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gravity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">b2World </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">world</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gravity)</span></span></span></span>; sf::Vector2i tileSize = lvl.GetTileSize();</code> </pre><br>  srand (time (NULL)) is needed for randomness. <br><br>  We load the map, create b2World, passing it gravity.  By the way, gravity can come from any direction, and gravity from (0.10) acts more strongly (0.1).  Then we take the tile size we need. <br><br>  Next, create body blocks: <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Object&gt; block = lvl.GetObjects(<span class="hljs-string"><span class="hljs-string">"block"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; block.size(); i++) { b2BodyDef bodyDef; bodyDef.type = b2_staticBody; bodyDef.position.Set(block[i].rect.left + tileSize.x / <span class="hljs-number"><span class="hljs-number">2</span></span> * (block[i].rect.width / tileSize.x - <span class="hljs-number"><span class="hljs-number">1</span></span>), block[i].rect.top + tileSize.y / <span class="hljs-number"><span class="hljs-number">2</span></span> * (block[i].rect.height / tileSize.y - <span class="hljs-number"><span class="hljs-number">1</span></span>)); b2Body* body = world.CreateBody(&amp;bodyDef); b2PolygonShape shape; shape.SetAsBox(block[i].rect.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, block[i].rect.height / <span class="hljs-number"><span class="hljs-number">2</span></span>); body-&gt;CreateFixture(&amp;shape,<span class="hljs-number"><span class="hljs-number">1.0f</span></span>); }</code> </pre><br><br><pre> <code class="cpp hljs">bodyDef.type = b2_staticBody;</code> </pre><br><br>  The blocks are static bodies, they have no mass and hang in the air: <br><br><pre> <code class="cpp hljs">bodyDef.position.Set(block[i].rect.left + tileSize.x / <span class="hljs-number"><span class="hljs-number">2</span></span> * (block[i].rect.width / tileSize.x - <span class="hljs-number"><span class="hljs-number">1</span></span>), block[i].rect.top + tileSize.y / <span class="hljs-number"><span class="hljs-number">2</span></span> * (block[i].rect.height / tileSize.y - <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><br><br>  Here we set the position of the blocks.  The fact is that if you simply specify a position the same as the object, an insidious <a href="http://www.gamedev.ru/code/forum/%3Fid%3D182066">error</a> will be waiting for us. <br><br><pre> <code class="cpp hljs">b2Body* body = world.CreateBody(&amp;bodyDef);</code> </pre><br><br>  Create a block body in the world.  Further, we do not work with the body (in the sense that we do not store it anywhere): <br><br><pre> <code class="cpp hljs">b2PolygonShape shape; shape.SetAsBox(block[i].rect.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, block[i].rect.height / <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br><br>  Each body has several shape - shapes.  I will not analyze this topic in detail, since the blocks (and the rest of the bodies) lack just one rectangle. <br><br><pre> <code class="cpp hljs">body-&gt;CreateFixture(&amp;shape,<span class="hljs-number"><span class="hljs-number">1.0f</span></span>);</code> </pre><br><br>  We associate the figure with the body. <br><br>  Then we do the same with enemies, coins, and player, with minor differences: <br><br><pre> <code class="cpp hljs"> coin = lvl.GetObjects(<span class="hljs-string"><span class="hljs-string">"coin"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; coin.size(); i++) { b2BodyDef bodyDef; bodyDef.type = b2_dynamicBody; bodyDef.position.Set(coin[i].rect.left + tileSize.x / <span class="hljs-number"><span class="hljs-number">2</span></span> * (coin[i].rect.width / tileSize.x - <span class="hljs-number"><span class="hljs-number">1</span></span>), coin[i].rect.top + tileSize.y / <span class="hljs-number"><span class="hljs-number">2</span></span> * (coin[i].rect.height / tileSize.y - <span class="hljs-number"><span class="hljs-number">1</span></span>)); bodyDef.fixedRotation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; b2Body* body = world.CreateBody(&amp;bodyDef); b2PolygonShape shape; shape.SetAsBox(coin[i].rect.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, coin[i].rect.height / <span class="hljs-number"><span class="hljs-number">2</span></span>); body-&gt;CreateFixture(&amp;shape,<span class="hljs-number"><span class="hljs-number">1.0f</span></span>); coinBody.push_back(body); } enemy = lvl.GetObjects(<span class="hljs-string"><span class="hljs-string">"enemy"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; enemy.size(); i++) { b2BodyDef bodyDef; bodyDef.type = b2_dynamicBody; bodyDef.position.Set(enemy[i].rect.left + tileSize.x / <span class="hljs-number"><span class="hljs-number">2</span></span> * (enemy[i].rect.width / tileSize.x - <span class="hljs-number"><span class="hljs-number">1</span></span>), enemy[i].rect.top + tileSize.y / <span class="hljs-number"><span class="hljs-number">2</span></span> * (enemy[i].rect.height / tileSize.y - <span class="hljs-number"><span class="hljs-number">1</span></span>)); bodyDef.fixedRotation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; b2Body* body = world.CreateBody(&amp;bodyDef); b2PolygonShape shape; shape.SetAsBox(enemy[i].rect.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, enemy[i].rect.height / <span class="hljs-number"><span class="hljs-number">2</span></span>); body-&gt;CreateFixture(&amp;shape,<span class="hljs-number"><span class="hljs-number">1.0f</span></span>); enemyBody.push_back(body); } player = lvl.GetObject(<span class="hljs-string"><span class="hljs-string">"player"</span></span>); b2BodyDef bodyDef; bodyDef.type = b2_dynamicBody; bodyDef.position.Set(player.rect.left, player.rect.top); bodyDef.fixedRotation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; playerBody = world.CreateBody(&amp;bodyDef); b2PolygonShape shape; shape.SetAsBox(player.rect.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, player.rect.height / <span class="hljs-number"><span class="hljs-number">2</span></span>); b2FixtureDef fixtureDef; fixtureDef.shape = &amp;shape; fixtureDef.density = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; fixtureDef.friction = <span class="hljs-number"><span class="hljs-number">0.3f</span></span>; playerBody-&gt;CreateFixture(&amp;fixtureDef);</code> </pre><br><br><pre> <code class="cpp hljs">bodyDef.fixedRotation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br><br>  Means that the body can not rotate. <br><br>  All bodies are created, it remains to initialize the graphics! <br><br><pre> <code class="cpp hljs"> sf::<span class="hljs-function"><span class="hljs-function">Vector2i </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">screenSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">800</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">600</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; sf::RenderWindow window; window.create(sf::VideoMode(screenSize.x, screenSize.y), <span class="hljs-string"><span class="hljs-string">"Game"</span></span>);</code> </pre><br><br>  Well-understood code creates a window with the specified size and title: <br><br><pre> <code class="cpp hljs"> sf::View view; view.reset(sf::FloatRect(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, screenSize.x, screenSize.y)); view.setViewport(sf::FloatRect(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">2.0f</span></span>));</code> </pre><br><br>  Here we create a view (View) for the window. <br><br>  Why is this necessary?  In order to give the game a pixel style, we multiply the screen size by 2 using sf :: View and all the pictures are drawn 2 times higher and wider. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(window.isOpen()) { sf::Event evt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(window.pollEvent(evt)) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(evt.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sf::Event::Closed: window.close(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br><br>  The window closes by pressing the red cross.  This code was previously: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sf::Event::KeyPressed: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(evt.key.code == sf::Keyboard::W) playerBody-&gt;SetLinearVelocity(b2Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-15.0f</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(evt.key.code == sf::Keyboard::D) playerBody-&gt;SetLinearVelocity(b2Vec2(<span class="hljs-number"><span class="hljs-number">5.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(evt.key.code == sf::Keyboard::A) playerBody-&gt;SetLinearVelocity(b2Vec2(<span class="hljs-number"><span class="hljs-number">-5.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br><br>  It's more interesting here!  We add speed to the player by pressing the WAD keys: <br><br><pre> <code class="cpp hljs">world.Step(<span class="hljs-number"><span class="hljs-number">1.0f</span></span> / <span class="hljs-number"><span class="hljs-number">60.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br><br>  Here we are updating the physical world of Box2D.  The first argument takes the world update rate (once every 1/60 seconds), as well as the number of velocityIterations and positionIterations.  The higher the value of the last two arguments, the more realistic is the physics of the game.  Since we do not have any complex shapes, as in AngryBirds, but only rectangles, we need only once. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(b2ContactEdge* ce = playerBody-&gt;GetContactList(); ce; ce = ce-&gt;next) { b2Contact* c = ce-&gt;contact;</code> </pre><br><br>  Here we handle the collision of a player with other bodies: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; coinBody.size(); i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(c-&gt;GetFixtureA() == coinBody[i]-&gt;GetFixtureList()) { coinBody[i]-&gt;DestroyFixture(coinBody[i]-&gt;GetFixtureList()); coin.erase(coin.begin() + i); coinBody.erase(coinBody.begin() + i); }</code> </pre><br><br>  Handling collision with coins. <br>  If a coin collides with a player, it is simply destroyed and erased from the vectors: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; enemyBody.size(); i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(c-&gt;GetFixtureA() == enemyBody[i]-&gt;GetFixtureList()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(playerBody-&gt;GetPosition().y &lt; enemyBody[i]-&gt;GetPosition().y) { playerBody-&gt;SetLinearVelocity(b2Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-10.0f</span></span>)); enemyBody[i]-&gt;DestroyFixture(enemyBody[i]-&gt;GetFixtureList()); enemy.erase(enemy.begin() + i); enemyBody.erase(enemyBody.begin() + i); }</code> </pre><br><br>  If an enemy collides with a player, it is checked whether the enemy player is higher or not.  If the player is higher than the enemy, he is erased, and the player jumps up. <br><br>  If not, then the player rebounds from the enemy: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tmp = (playerBody-&gt;GetPosition().x &lt; enemyBody[i]-&gt;GetPosition().x) ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; playerBody-&gt;SetLinearVelocity(b2Vec2(<span class="hljs-number"><span class="hljs-number">10.0f</span></span> * tmp, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); } } }</code> </pre><br><br>  The player moves to the right or left according to his current position relative to the enemy. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; enemyBody.size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(enemyBody[i]-&gt;GetLinearVelocity() == b2Vec2_zero) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tmp = (rand() % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span>) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">-1</span></span>; enemyBody[i]-&gt;SetLinearVelocity(b2Vec2(<span class="hljs-number"><span class="hljs-number">5.0f</span></span> * tmp, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); } }</code> </pre><br><br>  If the enemy's speed is 0, then he is given a speed again - he moves either to the right or to the left.  Visually, it looks like a jerk movement. <br><br><pre> <code class="cpp hljs"> b2Vec2 pos = playerBody-&gt;GetPosition(); view.setCenter(pos.x + screenSize.x / <span class="hljs-number"><span class="hljs-number">4</span></span>, pos.y + screenSize.y / <span class="hljs-number"><span class="hljs-number">4</span></span>); window.setView(view);</code> </pre><br><br>  Work with graphics.  Take the position of the player, change the center of the view and use our view. <br><br><pre> <code class="cpp hljs"> player.sprite.setPosition(pos.x, pos.y); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; coin.size(); i++) coin[i].sprite.setPosition(coinBody[i]-&gt;GetPosition().x, coinBody[i]-&gt;GetPosition().y); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; enemy.size(); i++) enemy[i].sprite.setPosition(enemyBody[i]-&gt;GetPosition().x, enemyBody[i]-&gt;GetPosition().y);</code> </pre><br><br>  Set the sprites of the player, coins and enemies positions obtained from b2Body: <br><br><pre> <code class="cpp hljs"> window.clear(); lvl.Draw(window); window.draw(player.sprite); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; coin.size(); i++) window.draw(coin[i].sprite); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; enemy.size(); i++) window.draw(enemy[i].sprite); window.display();</code> </pre><br><br>  We clear the windows, draw tiles of the map, then the player, coins and enemies, and then present the window. <br><br><pre> <code class="cpp hljs"> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  Done! <br><br>  Sample map: <br><br><img src="http://s6.hostingkartinok.com/uploads/images/2013/10/a348a0abc8945f94fa4cb205342b074e.png" alt="image"><br><br><h4>  Sources </h4><br><img src="http://static.pmmlabs.ru/images/github-logo.png" alt="image"><br>  <a href="https://github.com/Izaron/Platformer">https://github.com/Izaron/Platformer</a> <br><br><h4>  Thanks </h4><br>  To the author of this <a href="http://en.sfml-dev.org/forums/index.php%3Ftopic%3D3023.0">topic</a> <br>  SFML Authors <br>  Box2D authors <br>  To authors <a href="http://www.grinninglizard.com/tinyxml/">TinyXml</a> </div><p>Source: <a href="https://habr.com/ru/post/199064/">https://habr.com/ru/post/199064/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../199050/index.html">Groovy vs Java for JavaFX</a></li>
<li><a href="../199052/index.html">45% of web resources of the largest Russian companies contain critical vulnerabilities</a></li>
<li><a href="../199056/index.html">Why Open Data is a culture of working with information on the example of Roszdravnadzor</a></li>
<li><a href="../199060/index.html">Visualization of a two-dimensional gaussian on a plane</a></li>
<li><a href="../199062/index.html">pdoTools - a set of quick snippets and a library</a></li>
<li><a href="../199066/index.html">The Taming of Mary-301MTM</a></li>
<li><a href="../199068/index.html">PoolCoin - new cryptocurrency</a></li>
<li><a href="../199070/index.html">ICANN helped to combat child porn in Russia</a></li>
<li><a href="../199078/index.html">Hackers on the screen - 2</a></li>
<li><a href="../199080/index.html">Returns for Windows 8 on Lenovo Notebook Notebook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>