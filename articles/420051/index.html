<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[DotNetBook] Span, Memory and ReadOnlyMemory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With this article, I continue to publish a whole series of articles, the result of which will be a book on the work of the .NET CLR, and .NET as a who...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[DotNetBook] Span, Memory and ReadOnlyMemory</h1><div class="post__text post__text-html js-mediator-article"><p><img width="350" src="https://habrastorage.org/webt/34/ua/e6/34uae6usmglyw10vxga3sgfgh8c.jpeg" align="left">  With this article, I continue to publish a whole series of articles, the result of which will be a book on the work of the .NET CLR, and .NET as a whole.  For links - welcome under cat. </p><br><h2 id="memorylttgt-i-readonlymemorylttgt">  Memory &lt;T&gt; and ReadOnlyMemory &lt;T&gt; </h2><br><p> There are two visual differences between <code>Memory&lt;T&gt;</code> and <code>Span&lt;T&gt;</code> .  First, the <code>Memory&lt;T&gt;</code> does not contain a <code>ref</code> constraint in the type header.  That is, in other words, the <code>Memory&lt;T&gt;</code> has the right to be not only on the stack, being either a local variable or a parameter of the method or its return value, but also on the heap, referring from there to some data in the memory.  However, this small difference creates a huge difference in the behavior and capabilities of <code>Memory&lt;T&gt;</code> in comparison with <code>Span&lt;T&gt;</code> .  Unlike <code>Span&lt;T&gt;</code> , which is a <em>means of using a</em> kind of data buffer for some methods, the <code>Memory&lt;T&gt;</code> used to <em>store</em> information about the buffer, and not to work with it. </p><br><blockquote>  This article is the second of a cycle about Span &lt;T&gt; and Memory &lt;T&gt;.  It is an introductory one for Memory &lt;T&gt; in the sense that I decided to paint a common terminology here, but I decided to put together examples of sharing in a separate article <br><ul><li>  <a href="https://habr.com/post/418911/">Span &lt;T&gt;: a new .NET data type</a> </li><li>  <a href="https://habr.com/post/420051/">Span &lt;T&gt; Memory &lt;T&gt; and ReadOnlyMemory &lt;T&gt;</a> (this article) </li><li>  Practice using Span &lt;T&gt; and Memory &lt;T&gt; </li></ul><br></blockquote><br><blockquote><h3>  Note </h3><br>  The chapter published on Habr√© is not updated and it is possible that it is already somewhat outdated.  So, please ask for a more recent text to the original: <br><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="https://github.com/sidristij/dotnetbook/">GitHub, table of contents</a> </li><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="">GitHub, chapter</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.2 of the book, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote><a name="habracut"></a><br><p>  Hence the difference in the API: </p><br><ul><li>  <code>Memory&lt;T&gt;</code> does not contain data access methods that it manages.  Instead, it has the <code>Span</code> property and the <code>Slice</code> method, which return the workhorse ‚Äî an instance of the <code>Span</code> type. </li><li>  <code>Memory&lt;T&gt;</code> additionally contains the <code>Pin()</code> method, intended for scenarios where the stored buffer needs to be passed in <code>unsafe</code> code.  When it is called for cases when the memory was allocated in .NET, the buffer will be pinned and will not move when the GC is triggered, returning to the user an instance of the <code>MemoryHandle</code> structure encapsulating the concept of the <code>GCHandle</code> life <code>GCHandle</code> that fixed the buffer in memory: </li></ul><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> unsafe struct MemoryHandle : IDisposable { private <span class="hljs-type"><span class="hljs-type">void</span></span>* _pointer; private GCHandle _handle; private IPinnable _pinnable; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///  MemoryHandle    /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> MemoryHandle(<span class="hljs-type"><span class="hljs-type">void</span></span>* pointer, GCHandle handle = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, IPinnable pinnable = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { _pointer = pointer; _handle = handle; _pinnable = pinnable; } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///     ,   ,       /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; [CLSCompliant(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span>* Pointer =&gt; _pointer; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///  _handle  _pinnable,      /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Dispose() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_handle.IsAllocated) { _handle.Free(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_pinnable != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { _pinnable.Unpin(); _pinnable = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } _pointer = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> </pre> <br><p>  However, for a start I suggest to get acquainted with the whole set of classes.  And as the first of them, let's take a look at the <code>Memory&lt;T&gt;</code> structure itself (not all members of the type are shown, but the ones that seem most important): </p><br><pre> <code class="hljs cs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Memory&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> _object; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _index, _length; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Memory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T[] array</span></span></span><span class="hljs-function">)</span></span> { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Memory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T[] array, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span> { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Memory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MemoryManager&lt;T&gt; manager, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span> { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Memory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MemoryManager&lt;T&gt; manager, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Length =&gt; _length &amp; RemoveFlagsBitMask; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsEmpty =&gt; (_length &amp; RemoveFlagsBitMask) == <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Memory&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Slice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Memory&lt;T&gt; destination</span></span></span><span class="hljs-function">)</span></span> =&gt; Span.CopyTo(destination.Span); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryCopyTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Memory&lt;T&gt; destination</span></span></span><span class="hljs-function">)</span></span> =&gt; Span.TryCopyTo(destination.Span); }</code> </pre> <br><p>  In addition to specifying the structure fields, I decided to additionally indicate that there are two more <code>internal</code> type constructors that work on the basis of another entity, the <code>MemoryManager</code> , which will be discussed a little further and which is not something that you may have just thought: memory manager in the classic sense.  However, like <code>Span</code> , <code>Memory</code> also contains a reference to the object that will be used for navigation, as well as the offset and size of the internal buffer.  Also, in addition, it is worth noting that <code>Memory</code> can be created by the <code>new</code> operator only on the basis of an array plus extension methods ‚Äî on the basis of a string, an array, and an <code>ArraySegment</code> .  Those.  its creation based on unmanaged memory is not implied.  However, as we can see, there is some internal method for creating this structure based on a <code>MemoryManager</code> : </p><br><p>  <strong><a href="">MemoryManager.cs</a> file</strong> </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> abstract <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MemoryManager</span></span></span><span class="hljs-class">&lt;T&gt; :</span></span> IMemoryOwner&lt;T&gt;, IPinnable { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> abstract MemoryHandle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elementIndex = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> abstract </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unpin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Memory&lt;T&gt; Memory =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Memory&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, GetSpan().Length); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> abstract Span&lt;T&gt; GetSpan(); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Memory&lt;T&gt; CreateMemory(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Memory&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, length); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Memory&lt;T&gt; CreateMemory(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> start, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Memory&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, start, length); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IDisposable.Dispose() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> abstract </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> disposing)</span></span></span></span>; }</code> </pre> <br><blockquote>  I will allow myself to somewhat argue with the terminology that was introduced in the CLR command, calling the type the name MemoryManager.  When I saw it, I first decided that it would be something like a memory management, but manual, different from LOH / SOH.  But he was very disappointed to see the reality.  Perhaps, it was worthwhile to call it by anaolgy with the interface: MemoryOwner. <br></blockquote><p>  Which encapsulates in itself the concept of the owner of a section of memory.  In other words, if <code>Span</code> is a means of working with memory, <code>Memory</code> is a means of storing information about a specific area, then <code>MemoryManager</code> is a means of controlling its life, its owner.  For example, you can take the type <code>NativeMemoryManager&lt;T&gt;</code> , which, although written for tests, does not badly reflect the essence of the concept of "ownership": </p><br><p>  <strong><a href="">NativeMemoryManager.cs</a> file</strong> </p><br><pre> <code class="hljs cpp">internal sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeMemoryManager</span></span></span><span class="hljs-class"> :</span></span> MemoryManager&lt;byte&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _length; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IntPtr _ptr; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _retainedCount; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _disposed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NativeMemoryManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ _length = length; _ptr = Marshal.AllocHGlobal(length); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unpin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ lock (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_retainedCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { _retainedCount--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_retainedCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_disposed) { Marshal.FreeHGlobal(_ptr); _ptr = IntPtr.Zero; } } } } } <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  That is, in other words, the class provides the possibility of nested calls to the <code>Pin()</code> method, thereby counting the resulting links from the <code>unsafe</code> world. </p><br><p>  Another entity closely associated with <code>Memory</code> is <code>MemoryPool</code> , which provides for the pooling of MemoryManager instances (and in fact, <code>IMemoryOwner</code> ): </p><br><p>  <strong><a href="">MemoryPool.cs</a> file</strong> </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> abstract <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MemoryPool</span></span></span><span class="hljs-class">&lt;T&gt; :</span></span> IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> MemoryPool&lt;T&gt; Shared =&gt; s_shared; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> abstract IMemoryOwner&lt;T&gt; Rent(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minBufferSize = <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br><p>  Which is intended for issuing buffers of the required size for temporary use.  Rented instances that implement the <code>IMemoryOwner&lt;T&gt;</code> interface have a <code>Dispose()</code> method that returns the rented array back to the pool of arrays.  And by default you can use a common buffer pool, which is built on the basis of <code>ArrayMemoryPool</code> : </p><br><p>  <strong><a href="">ArrayMemoryPool.cs</a> file</strong> </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayMemoryPool</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MemoryPool</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> int MaximumBufferSize = int.MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> int MaxBufferSize =&gt; MaximumBufferSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> IMemoryOwner&lt;T&gt; Rent(int minimumBufferSize = -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minimumBufferSize == -<span class="hljs-number"><span class="hljs-number">1</span></span>) minimumBufferSize = <span class="hljs-number"><span class="hljs-number">1</span></span> + (<span class="hljs-number"><span class="hljs-number">4095</span></span> / Unsafe.SizeOf&lt;T&gt;()); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((uint)minimumBufferSize) &gt; MaximumBufferSize) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.minimumBufferSize); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new ArrayMemoryPoolBuffer(minimumBufferSize); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> void Dispose(bool disposing) { } }</code> </pre> <br><p>  And on the basis of what he saw, the following picture of the world emerges: </p><br><ul><li>  The <code>Span</code> data type must be used in method parameters if you mean either reading data ( <code>ReadOnlySpan</code> ) or writing ( <code>Span</code> ).  But not the task of keeping it in the class field for future use. </li><li>  If you need to keep a reference to the data buffer from the class field, you must use <code>Memory&lt;T&gt;</code> or <code>ReadOnlyMemory&lt;T&gt;</code> - depending on the purpose. </li><li>  <code>MemoryManager&lt;T&gt;</code> is the owner of the data buffer (you can not use it: if necessary).  Necessary when, for example, it becomes necessary to count the calls of <code>Pin()</code> .  Or when you need to have knowledge of how to free memory </li><li>  If <code>Memory</code> built around an unmanaged memory, <code>Pin()</code> do nothing.  However, this unifies working with different types of buffers: both in the case of managed and unmanaged code, the interaction interface will be the same. </li><li>  Each type has public constructors.  And this means that you can use <code>Span</code> directly or receive an instance of it from <code>Memory</code> .  You can create a <code>Memory</code> yourself either separately or organize an <code>IMemoryOwner</code> type for it that will own the memory location that <code>Memory</code> will refer to.  A special case can be any type based on <code>MemoryManager</code> : some local ownership of a section of memory (for example, with reference counting from the <code>unsafe</code> world).  If you need to pull such buffers (frequent traffic of buffers of approximately equal size is expected), you can use the <code>MemoryPool</code> type. </li><li>  If it is implied that you need to work with <code>unsafe</code> code, transferring a certain data buffer there, you should use the <code>Memory</code> type: it has a <code>Pin</code> method that automates fixing the buffer in the .NET heap if it was created there. </li><li>  If you have some traffic buffers (for example, you solve the problem of parsing program text or some DSL), you should use the <code>MemoryPool</code> type, which can be organized in a very correct way, issuing buffers of suitable size from the pool (for example, a little more if you don‚Äôt find a suitable , but with the <code>originalMemory.Slice(requiredSize)</code> so as not to fragment the pool) </li></ul><br><blockquote><h3>  Link to the whole book </h3><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="https://github.com/sidristij/dotnetbook/">GitHub</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.0 books, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/420051/">https://habr.com/ru/post/420051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420035/index.html">GUI on Golang: GTK + 3</a></li>
<li><a href="../420037/index.html">Stream with several cameras made from scrap materials</a></li>
<li><a href="../420041/index.html">War of TypeScript or Conquest of Enum</a></li>
<li><a href="../420045/index.html">Bunker for the date: how I was allowed to walk on the data center RUVDS on the territory of the space plant</a></li>
<li><a href="../420049/index.html">The book "The Man Talking. Evolution and language "</a></li>
<li><a href="../420053/index.html">Veeam Academy for C # Developers: New Season</a></li>
<li><a href="../420055/index.html">Theory and practice of backups with Borg</a></li>
<li><a href="../420057/index.html">8 rules of a successful freelancer</a></li>
<li><a href="../420059/index.html">Now I am a team leader, but why is it so bad for me? Practical advice</a></li>
<li><a href="../420061/index.html">Evaluate processes in a development team based on objective data.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>