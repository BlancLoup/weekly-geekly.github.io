<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>On the topic of the day: a cross-platform client for Telegram on .NET Core and Avalonia</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will explain how to implement a cross-platform application on .NET Core and Avalonia. The subject of the Telegram is very popular la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>On the topic of the day: a cross-platform client for Telegram on .NET Core and Avalonia</h1><div class="post__text post__text-html js-mediator-article"><p>  In this article I will explain how to implement a cross-platform application on .NET Core and Avalonia.  The subject of the Telegram is very popular lately - the more interesting it will be to make the client application for it. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/624/384/1d5/6243841d58f195e9285b7d27dd5c8740.png" alt="Egram"></p><br><p>  The article touches on quite basic concepts of development on Avalonia.  However, we will not write "Hello, World".  Instead, it is proposed to consider the real application.  We will study both the general architecture of the application and individual components. </p><br><p>  In order not to overuse the reader‚Äôs attention, in some cases it will be necessary to deliberately omit some details, simplifying the description and implementation.  The real code can always be <a href="">viewed on GitHub</a> . </p><br><p>  The text of the article is educational in nature, but the project itself is quite real.  The aim of the project is to create a client, designed to be used as a working tool.  A lot of ideas are borrowed from other instant messengers and shifted to the Telegram model. </p><a name="habracut"></a><br><p>  The project is under development and is currently not suitable for everyday use.  This article, the author, including, expects to attract like-minded people to the development. </p><br><h2 id="vvedenie">  Introduction </h2><br><p>  At the core of our application will be the Avalonia framework.  We will actively use the MVVM and Rx.NET pattern.  XAML is used as a markup language for building the user interface.  For communication with the Telegram API, the <a href="https://github.com/tdlib/td/">library</a> will use <a href="https://github.com/tdlib/td/">TDLib</a> and automatically generated <a href="https://github.com/egramtel/tdsharp">bindings for .NET</a> . </p><br><p>  Reactive programming will be widely used in development.  In general, the application follows the approach adopted in modern UI frameworks.  If you are familiar with WPF, it will be relatively easy for you to switch to Avalonia.  Getting to know things like React.js doesn't hurt either. </p><br><p><img src="https://habrastorage.org/webt/e8/rx/ah/e8rxahz93hmvdnt2c-ma9vth0te.png" alt="Avalonia"></p><br><p>  Avalonia hides from the developer implementation details specific to a single platform.  The programmer usually deals with top-level components.  So, for example, in order to create a new application, you need to put the Avalonia, Avalonia.Desktop packages and write the following lines in the Main function: </p><br><pre><code class="cs hljs">AppBuilder .Configure(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> App()) .UsePlatformDetect() .UseReactiveUI() .Start&lt;MainWindow&gt;(() =&gt; context);</code> </pre> <br><p>  This is a typical Builder, familiar to everyone who dealt with .NET Core and ASP.NET Core.  The key line is UsePlatformDetect.  Avalonia takes over the definition of the environment in which the program is running and configures the backend for drawing the UI.  App and MainWindow here are classes inherited from Avalonia. Application and Avalonia. Window respectively, their purpose should be approximately clear from the names, we will return to them later. </p><br><p>  If you use the <a href="https://github.com/AvaloniaUI/AvaloniaVS">extension for VisualStudio</a> , it will provide a template that will contain the implementation of these classes.  Let's use the extension, and create a project.  We will find that the project will contain the following files: </p><br><pre> <code class="plaintext hljs">./App.xaml ./App.xaml.cs ./MainWindow.xaml ./MainWindow.xaml.cs</code> </pre> <br><p>  As you can see, these are the same App and MainWindow classes, mentioned earlier, and supplemented with XAML files.  Each of these classes will contain a call: AvaloniaXamlLoader.Load (this).  We will not go into details now, we will say only that this method loads the XAML file of the same name and converts it into .NET objects, ‚Äúfilling‚Äù the target object passed as an argument. </p><br><p>  If there is a need to understand the details of the XAML, they can be obtained from other sources - any book on WPF will do.  For simple cases, this is not necessary, it will be enough to learn how to work with the components that Avalonia provides out of the box. </p><br><p>  Similarly, controls are implemented in Avalonia (i.e.), i.e.  XAML files are inherently needed for a declarative description of a certain hierarchy, which is then converted into ordinary objects in the application's memory.  An example of such a hierarchy: a button attached to a form, which, in turn, is located inside the window. </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Window</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Panel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag">&gt;</span></span>Foo Bar<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Panel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Window</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Avalonia contains a predefined set of controls, such as TextBlock, Button, and Image.  For their composition into more complex structures, control containers are used: Grid, Panel, ListBox, etc.  All these controls work in the same way as they are implemented in WPF, that is, despite the small amount of documentation available, it is almost always possible to refer to materials for WPF. </p><br><h2 id="realizaciya-mvvm">  MVVM implementation </h2><br><p>  We will try to separate the internal state of the application and its display.  The state will be stored in a certain hierarchy of objects (View Model).  The view will respond to changes to the View Model and rebuild the UI.  And the View Model, in turn, will be able to change under the influence of two factors: user or external events.  Clicking a button is an example of a custom event from View, but a new message in the chat is an external event. </p><br><p>  In Avalonii, the View Model is inextricably linked with the term Data Context or simply ‚Äúcontext‚Äù.  I will use all the terms interchangeably. </p><br><p><img src="https://habrastorage.org/webt/-a/zu/rw/-azurwiz1kbinug5v8zprdwfwy8.png" alt="MVVM"></p><br><p>  The View Model hierarchy will often be similar to the View structure, at least as a first approximation.  View we fully give up control of Avalonia, i.e.  The logic of our application will control the state, and reacting to these changes and redrawing the interface is already the responsibility of the framework. </p><br><p>  The top-level structure of the View Model looks like this (pseudocode): </p><br><pre> <code class="plaintext hljs">App { ... Index # int ... Auth { ... Phone # string Password # string } Main { Nav { ... Contacts # ReactiveList&lt;Contact&gt; } Chat { ... Messages # ReactiveList&lt;Message&gt; } } }</code> </pre> <br><p>  The parent context manages the life cycle of the child contexts, and its responsibilities include creating and releasing nested contexts.  The root DataContext is passed to the Builder when the MainWindow object is created (see above), later it will control the entire View Model hierarchy. </p><br><p>  View establishes a context for nested controls through a binding mechanism (Binding).  In practice, this is needed to set values ‚Äã‚Äãfor properties of objects, and subscribe to their changes. </p><br><p>  Notice how the bindings are used to set: </p><br><ol><li>  SelectedIndex properties of the Carousel control (determines which page the application displays - authorization form or chat) </li><li>  Text properties for TextBox (links the value in the model with the text of the phone number and password entry form) </li><li>  All nested contexts </li></ol><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Window</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">DataContext</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding App}"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Carousel</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SelectedIndex</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding Index}"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Panel</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">DataContext</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding Auth}"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBox</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding Phone, Mode=TwoWay}"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBox</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding Password, Mode=TwoWay}"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Panel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">DataContext</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding Main}"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Panel</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">DataContext</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding Nav}"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ListBox</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Items</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding Contacts}"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Panel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Panel</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">DataContext</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding Chat}"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ListBox</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Items</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding Messages}"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Panel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Carousel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Window</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  In this example, the AppContext contains two child contexts: MainContext and AuthContext.  AppContext manages the life cycle of nested contexts: it is responsible for their initialization and release. </p><br><p>  In practice, it looks like this: after starting the application, AppContext checks if the user is authorized, and if not, initializes the child AuthContext.  An application GUI responds to the creation of an AuthContext by showing an authorization form.  The user enters the credentials, is authorized, the AppContext is signed to the authorization event, he releases the AuthContext and at the same moment the MainContext is initialized.  SelectedIndex switches from 0 to 1 to remove the login form and show the chat. </p><br><p>  MainContext, in turn, contains two more contexts: ChatContext and NavigationContext.  The navigation context will be created during the initialization of MainContext, since  at this time we already know that the user is authorized, and we have the opportunity to upload contacts. </p><br><p>  Everything is a little more interesting with ChatContext: its creation (and at the same time the release of the previous context) occurs at the moment when the user selects a chat in the navigation menu.  ChatContext itself will be subscribed to external events, such as: adding, editing and deleting messages.  The display, accordingly, will react by drawing messages, or by deleting them.  In this case, the context should subscribe to events only for the selected chat, since  We are not interested in the events of another chat.  The chat context also responds to user events, such as entering a new message. </p><br><p><img src="https://habrastorage.org/webt/uz/5q/hp/uz5qhpn8ky5jilwuebzanue3enq.png" alt="State"></p><br><p>  Nested models usually do not contain references to the parent context, but they have the ability to interact with external components in order to receive events from them or make calls (as an example, a wrapper over TDLib). </p><br><h2 id="asinhronnost">  Asynchrony </h2><br><p>  As with most GUI frameworks, Avalonia allows you to perform actions on user interface elements only from a UI stream.  On this thread, it is desirable to perform a minimum of work so that the application remains responsive.  With the advent of async / await, delegating work to other threads has become much easier.  The RX.NET approach is very similar to async / await, but it also makes it easy to work with a series of events. </p><br><p>  The application makes extensive use of Observable features to ensure asynchrony.  Consider an example - loading user contacts.  After downloading the application, the user should see a list of their contacts.  In our case, the contact itself is the name of the user and his photo. </p><br><p>  The download itself is a typical request for data over the network, i.e.  such an action is best performed outside the UI flow.  A simple solution would be to use async / await: the main thread initiates the download, and when it completes, it receives a notification and shows the contacts.  Even at boot time, you can show the progress bar, so that the user knows that some work is happening in the background. </p><br><p><img src="https://habrastorage.org/webt/r0/uh/xt/r0uhxterwnscokgvkek_szcosps.png" alt="Loaders"></p><br><p>  It would seem that with this approach there are no problems.  But, upon closer inspection, it will be possible to see that only 10% of the time (approximate figures) the application fulfilled the request for a list of contacts, the remaining 90% of the time interval was occupied by loading and decoding images.  All this time, the user was waiting.  Is there a better approach?  Why do not we show the list of contacts immediately after the first request, and the image is loaded with the "second wave"? </p><br><p>  This task, in principle, is solved by means of TPL, but the use of Rx.NET is better placed on such a scenario.  The idea is very simple: we delegate data loading to another class in the same way, but this time we expect Observable instead of Task in response.  This will allow us to subscribe to a series of events, instead of one: the first event will be the uploaded list of contacts, and each subsequent one will carry some Update (uploaded photo, for example). </p><br><p>  Consider the loading of contacts by example.  The context task includes a subscription to the result of executing LoadContacts.  Note the call to the ObserveOn method ‚Äî this is the instruction for Rx.NET to execute the code passed to the Subscribe on the Avalonia scheduler thread.  Without this instruction, we do not have the right to modify the Contacts property, since  the code will run on a thread other than the UI thread. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// NavContext.cs class NavContext : ReactiveObject { private ReactiveList&lt;Contact&gt; _contacts; public ReactiveList&lt;Contact&gt; Contacts { get =&gt; _contacts; set =&gt; this.RaiseAndSetIfChanged(ref _contacts, value); } public NavContext(ContactLoader contactLoader) { contactLoader.LoadContacts() .ObserveOn(AvaloniaScheduler.Instance) .Subscribe(x =&gt; { Contacts = new ReactiveList(x.Contacts); x.Updates .ObserveOn(AvaloniaScheduler.Instance) .Subscribe(u =&gt; { u.Contact.Avatar = u.Avatar; }); }); } }</span></span></code> </pre><br><p>  ContactLoader is responsible for performing the network request.  As soon as the request is executed, another Observable is created, which is responsible for delivering updates to subscribers.  Immediately after that, we will be ready to give up the list of contacts, without waiting for the photo to load.  Updates will be delivered as they are downloaded. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// ContactLoader.cs class ContactLoader { IObservable&lt;Load&gt; LoadContacts() { return Observable.Create(async observer =&gt; { var contacts = await GetContactsAsync(); // networking var updates = Observable.Create(async o =&gt; { foreach (var contact in contacts) { // load avatar from remote server // ... var avatar = await GetAvatarAsync(); // networking o.OnNext(new Update(avatar)); } o.OnComplete(); }); observer.OnNext(new Load(contacts, updates)); observer.OnComplete(); }) } }</span></span></code> </pre><br><p>  The sequence of events can be controlled: combine, filter, transform, etc.  This is very convenient with a large number of sources of events and the events themselves.  Rx.NET allows you to work effectively with Observable. </p><br><p>  A small example: if you cache photos on a disk, the download will speed up significantly, however, such acceleration can lead to the problem of a large number of updates in a short period of time, which will complicate the work of the scheduler and may lead to loss of responsiveness of the application.  To avoid this, we will use buffering: we will process all updates that happened within a hundred milliseconds at a time, and for one we will filter entries that do not contain a photo (for any reason). </p><br><pre> <code class="cs hljs">x.Updates .Where(u =&gt; u.Avatar != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) .Buffer(TimeSpan.FromMilliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>)) .ObserveOn(AvaloniaScheduler.Instance) .Subscribe(list =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list) { u.Contact.Avatar = u.Avatar; } });</code> </pre> <br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  It is impossible for one article to tell in detail about each technology used.  I tried to choose the most interesting, and set out in a condensed form.  Also, many components of the application itself were not affected, but all components are similar, and are based on the same principles.  For further study I recommend to visit the following links: </p><br><p><img src="https://habrastorage.org/webt/mi/zh/qk/mizhqkxbxgp7ymhghxctppsrecg.png" alt="Digital resistance"></p><br><ul><li>  <a href="https://egram.tel/">Project website</a> </li><li>  <a href="">Project code</a> </li><li>  <a href="https://github.com/tdlib/td">TDLib (Telegram library for client applications)</a> </li><li>  <a href="https://github.com/egramtel/tdsharp">.NET Core Binding for TDLib</a> </li><li>  <a href="http://avaloniaui.net/">Avalonia</a> </li><li>  <a href="http://www.introtorx.com/">A good place to start learning Rx.NET</a> </li><li>  <a href="https://reactiveui.net/">ReactiveUI</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/354646/">https://habr.com/ru/post/354646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354632/index.html">Installing and configuring OpenVPN server using docker-compose</a></li>
<li><a href="../354636/index.html">Visualization in CAD: why we wrote another 3D engine and how it works</a></li>
<li><a href="../354638/index.html">FIDO2 - Passwords must die</a></li>
<li><a href="../354640/index.html">The history of moving the system administrator in Germany. Part Two: Moving and First Steps</a></li>
<li><a href="../354642/index.html">Conclusion of the Telegram channel on your website</a></li>
<li><a href="../354648/index.html">Software creation of a type library</a></li>
<li><a href="../354650/index.html">Snake layout and "quantum" particles in Android applications (Part 2)</a></li>
<li><a href="../354652/index.html">Developing mobile games is no longer a Padawan, not yet a master</a></li>
<li><a href="../354654/index.html">Positive Hack Days CTF 2018 task seekers: mnogorock, sincity, wowsuchchain, event0</a></li>
<li><a href="../354662/index.html">Management of machine learning projects with high cost of error. Lecture in Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>