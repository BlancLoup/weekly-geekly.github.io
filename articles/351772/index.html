<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Minifikation programming language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once I took part in a demo contest (programs that generate an audio-visual series, the main feature of which is an extremely small size - dozens or ev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Minifikation programming language</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/fk/fa/xr/fkfaxrhgdymfpygnkkxtpdqek-e.png"></p><br><p>  Once I took part in a demo contest (programs that generate an audio-visual series, the main feature of which is an extremely small size - dozens or even kibibyte units). </p><br><p>  In the course of a general discussion, someone suggested a non-standard demo idea for the world: to write a program in a scripting language.  The fact is that all demos are compressed by the packer to reduce the size (and unpacked when executed).  And the text is compressed much better than the binary code.  If the interpreter is of very small size, this can be a significant advantage. </p><br><p>  Because of my experience in the frontend, I immediately had the idea to additionally minify the code - to remove spaces and optional elements, to reduce the length of identifiers.  After all, compression saves all the information, and many syntax elements are not necessary. </p><br><p>  But even so, most of the existing languages ‚Äã‚Äãare not designed for this optimization - obviously, they have many elements that are necessary for an individual to understand, and not a machine.  And what if you develop a language specifically designed for minification? </p><br><p>  In the end, I did not participate in that competition.  However, this idea did not leave me.  After all, it can be useful for more practical purposes than a demo - in the world of frontend the volume of client scripts is still extremely important, if you can reduce it, this decision may be justified, at least in some cases. </p><br><p>  I decided to conduct an experiment - to make a prototype of the language and see what came of it. </p><a name="habracut"></a><br><h3 id="klyuchevye-osobennosti">  Key features </h3><br><p>  I put the following key features into my language: dynamic typing, functional paradigm, no separators, and classes of identifiers. </p><br><p>  I chose dynamic typing, because for static it is required to describe types, which takes precious space. </p><br><p>  Functional paradigm - because it is more expressive (allows a smaller amount of code to express more algorithms). </p><br><p>  I‚Äôll dwell on the other two. </p><br><h4 id="otsutstvie-razdeliteley">  No separators </h4><br><p>  Consider the following code: </p><br><pre><code class="hljs lisp">add(<span class="hljs-number"><span class="hljs-number">2</span></span>, multiple(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>))</code> </pre> <br><p>  The number of arguments each function expects (the arity of the function) is known in advance.  Brackets and commas are only needed for readability.  Remove them: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> multiple <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p>  You can do the same with operators, simply considering them as functions: </p><br><pre> <code class="hljs markdown"><span class="hljs-bullet"><span class="hljs-bullet">+ </span></span>2 * 2 2</code> </pre> <br><p>  At the same time, operators do not need to have priority - the procedure is defined by the order of recording, since to call a function, you first need to calculate all its parameters.  So the expression above will return the value 6. And to get 8, you will need to write the code like this: </p><br><pre> <code class="hljs markdown"><span class="hljs-bullet"><span class="hljs-bullet">* </span></span>2 + 2 2</code> </pre> <br><h4 id="klassy-identifikatorov">  ID Classes </h4><br><p>  Since my operators are normal functions, I decided to extend this and simply allow any punctuation characters to be used in identifiers. </p><br><p>  And then I got the idea to divide all identifiers into two classes: alphabetic and punctuation. </p><br><p>  The fact is that in any language, identifiers must be separated by something - either by other elements of the syntax, or by whitespace.  Otherwise there will be an ambiguity: <code>xy</code> is an identifier <code>xy</code> or two identifiers <code>x</code> and <code>y</code> ? </p><br><p>  However, having two non-intersecting classes of identifiers, I can relax this requirement: identifiers of different classes can be written together, there will be no ambiguity. </p><br><p>  Moreover, it is not for nothing that my first grade is only alphabetic - the numbers do not include it.  This allows you to write numbers together with any class of identifiers. </p><br><p>  For example, take the following expression: </p><br><pre> <code class="hljs lisp">foo($(<span class="hljs-number"><span class="hljs-number">5</span></span>))</code> </pre> <br><p>  In my language it can be written as follows: </p><br><pre> <code class="hljs pgsql">foo<span class="hljs-meta"><span class="hljs-meta">$5</span></span></code> </pre> <br><h3 id="reshenie-problem">  Problem solving </h3><br><p>  During the development of the language, several interesting problems arose, which I did not expect, but still managed to solve: calling functions without arguments and building the code structure (AST). </p><br><h4 id="vyzov-funkciy-bez-argumentov">  Calling functions without arguments </h4><br><p>  Since I do not have a special syntax for calling a function, as in other languages, functions without arguments must be called by simply specifying their name: </p><br><pre> <code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">answer</span></span></span></span>() <span class="hljs-number"><span class="hljs-number">42</span></span> ; answer</code> </pre> <br><p>  So it worked, but only at the same level of nesting.  What if such a function returns another one the same? </p><br><pre> <code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">answer</span></span></span></span>() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>() <span class="hljs-number"><span class="hljs-number">42</span></span> ; ; answer</code> </pre> <br><p>  Then the result is a closure, not an internal value.  And how to cause this closure?  After all, we have already indicated his name. </p><br><p>  I had to use the approach from the Clojure language - trampoline: any values ‚Äã‚Äãafter their calculation fall into a special cycle, which cyclically causes closures that do not require arguments, until the result is something else.  Thus the result of the second example above will also be 42, as in the first. </p><br><h4 id="postroenie-struktury-koda">  Building a code structure </h4><br><p>  To be able to carry out the minification, it is necessary to be able to determine the structure of the code without executing it. </p><br><p>  And when we know the number of arguments of all functions, it is easy.  For example, the code: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> multiple <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p>  It has the following structure: </p><br><p><img src="https://habrastorage.org/webt/kv/ls/ir/kvlsirzh0x9nmvk2_zrsl78kw-a.png"></p><br><p>  However, as soon as I begin to return the closure, ambiguity appears: </p><br><pre> <code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(xy) + xy ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increase</span></span></span></span>(x) + x <span class="hljs-number"><span class="hljs-number">1</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> == n <span class="hljs-number"><span class="hljs-number">2</span></span> add increase ; foo x ...</code> </pre> <br><p>  How many arguments should I pass to the result of the <code>foo</code> function call?  This can only be determined during the execution of the code, but not at the stage of its analysis.  And this makes the implementation of minification impossible. </p><br><p>  To solve this problem, I extended the typing to semi-static: types need to be specified only for functions, while the role of the type is to indicate only the required number of arguments both for the function itself and for its result, if that is the closure. </p><br><pre> <code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_adder</span></span></span></span>(bias):<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(xy) + bias + xy ; ; make_adder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p>  The definition of the <code>make_adder</code> function explicitly states that its result is a closure and expects two parameters.  Therefore, it is easy to build the structure of the last call: </p><br><p><img src="https://habrastorage.org/webt/8x/nq/io/8xnqio3hscusrxmrubxkkohyudw.png"></p><br><h3 id="obschie-vozmozhnosti">  General features </h3><br><p>  The language has the following types: <code>nil</code> , floating-point numbers, lists, hash tables, and closures.  Strings are based on lists.  Logical values ‚Äã‚Äãare missing - certain values ‚Äã‚Äãof other types are considered false, and all others are considered true. </p><br><p>  The language has a set of built-in functions: basic math functions and operations (including for bit arithmetic), functions for working with lists and hash tables, basic input-output. </p><br><p>  The language supports modularity through dynamic loading of source code files.  Caching is supported, the <code>vendor</code> directory and the search in paths specified through a special environment variable. </p><br><p>  The language has a small standard library containing a module for working with lists in a functional style and a module for unit testing. </p><br><h3 id="benchmark">  Benchmark </h3><br><p>  To assess the possibilities of minification, I decided to compare my language with JavaScript.  For this, I wrote the same program on both. </p><br><p>  I chose the Virtual DOM tree comparison algorithm as the task.  Based on these articles: </p><br><ol><li>  <a href="https://medium.com/%40deathmood/how-to-write-your-own-virtual-dom-ee74acc13060">How to write your own Virtual DOM.</a> </li><li>  <a href="https://medium.com/%40deathmood/write-your-virtual-dom-2-props-events-a957608f5c76">Write your Virtual DOM 2: Props &amp; Events.</a> </li></ol><br><p>  However, when comparing them, the real DOM immediately changes, but I just generated a list of the required changes, indicating the node address to which they relate. </p><br><div class="spoiler">  <b class="spoiler_title">JavaScript version</b> <div class="spoiler_text"><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type, properties, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...children</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'type'</span></span>: type, <span class="hljs-string"><span class="hljs-string">'properties'</span></span>: properties || {}, <span class="hljs-string"><span class="hljs-string">'children'</span></span>: children, } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_difference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path, action, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...parameters</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'path'</span></span>: path, <span class="hljs-string"><span class="hljs-string">'action'</span></span>: action, <span class="hljs-string"><span class="hljs-string">'parameters'</span></span>: parameters, } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_different</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node_1, node_2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> node_1 !== <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> node_2 || (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> node_1 === <span class="hljs-string"><span class="hljs-string">'object'</span></span> ? node_1[<span class="hljs-string"><span class="hljs-string">'type'</span></span>] !== node_2[<span class="hljs-string"><span class="hljs-string">'type'</span></span>] : node_1 !== node_2) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_property</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path, name, old_value, new_value)</span></span></span><span class="hljs-function"> </span></span>{ let difference <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!new_value) { difference = make_difference(path, <span class="hljs-string"><span class="hljs-string">'remove_property'</span></span>, name) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!old_value || new_value !== old_value) { difference = make_difference(path, <span class="hljs-string"><span class="hljs-string">'set_property'</span></span>, name, new_value) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> difference } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_properties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path, old_properties, new_properties)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> properties = Object.assign({}, old_properties, new_properties) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.keys(properties) .map(name =&gt; compare_property(path, name, old_properties[name], new_properties[name])) .filter(difference =&gt; difference) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_nodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(old_node, new_node, index=0, path=[])</span></span></span><span class="hljs-function"> </span></span>{ let differences = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!old_node) { differences.push(make_difference(path, <span class="hljs-string"><span class="hljs-string">'create'</span></span>, new_node)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!new_node) { differences.push(make_difference(path, <span class="hljs-string"><span class="hljs-string">'remove'</span></span>, index)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_different(old_node, new_node)) { differences.push(make_difference(path, <span class="hljs-string"><span class="hljs-string">'replace'</span></span>, index, new_node)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (old_node[<span class="hljs-string"><span class="hljs-string">'type'</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child_path = [...path, old_node[<span class="hljs-string"><span class="hljs-string">'type'</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> properties_differences = compare_properties(child_path, old_node[<span class="hljs-string"><span class="hljs-string">'properties'</span></span>], new_node[<span class="hljs-string"><span class="hljs-string">'properties'</span></span>]) differences.push(...properties_differences) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> maximal_children_length = Math.max(old_node[<span class="hljs-string"><span class="hljs-string">'children'</span></span>].length, new_node[<span class="hljs-string"><span class="hljs-string">'children'</span></span>].length) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; maximal_children_length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child_differences = compare_nodes(old_node[<span class="hljs-string"><span class="hljs-string">'children'</span></span>][i], new_node[<span class="hljs-string"><span class="hljs-string">'children'</span></span>][i], i, child_path) differences.push(...child_differences) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> differences } module[<span class="hljs-string"><span class="hljs-string">'exports'</span></span>] = { <span class="hljs-string"><span class="hljs-string">'make_node'</span></span>: make_node, <span class="hljs-string"><span class="hljs-string">'compare_nodes'</span></span>: compare_nodes, }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Version in my language</b> <div class="spoiler_text"><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> map:<span class="hljs-number"><span class="hljs-number">2</span></span> load <span class="hljs-string"><span class="hljs-string">"std/list/map"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> filter:<span class="hljs-number"><span class="hljs-number">2</span></span> load <span class="hljs-string"><span class="hljs-string">"std/list/filter"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zip_longest:<span class="hljs-number"><span class="hljs-number">3</span></span> load <span class="hljs-string"><span class="hljs-string">"std/list/zip_longest"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> reduce:<span class="hljs-number"><span class="hljs-number">3</span></span> load <span class="hljs-string"><span class="hljs-string">"std/list/reduce"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_node</span></span></span></span>(kind properties children) #<span class="hljs-string"><span class="hljs-string">"type"</span></span> kind #<span class="hljs-string"><span class="hljs-string">"properties"</span></span> properties #<span class="hljs-string"><span class="hljs-string">"children"</span></span> children {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_difference</span></span></span></span>(path action parameters) #<span class="hljs-string"><span class="hljs-string">"path"</span></span> path #<span class="hljs-string"><span class="hljs-string">"action"</span></span> action #<span class="hljs-string"><span class="hljs-string">"parameters"</span></span> parameters {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_different</span></span></span></span>(node_i node_ii) || != <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_i</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_ii</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> == <span class="hljs-string"><span class="hljs-string">"hash"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_i</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>() != .<span class="hljs-string"><span class="hljs-string">"type"</span></span>node_i .<span class="hljs-string"><span class="hljs-string">"type"</span></span>node_ii; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>() != node_i node_ii; ; ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_property</span></span></span></span>(path name old_value new_value) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !new_value <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>() make_difference path <span class="hljs-string"><span class="hljs-string">"remove_property"</span></span> ,name[]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> || !old_value != new_value old_value <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>() make_difference path <span class="hljs-string"><span class="hljs-string">"set_property"</span></span> ,name,new_value[]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>() nil; ; ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_properties</span></span></span></span>(path old_properties new_properties) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> properties + old_properties new_properties; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> differences map keys properties <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(name) compare_property path name .name old_properties .name new_properties ;; filter differences <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(difference) difference ; ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_nodes</span></span></span></span>(old_node new_node index path) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !old_node <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>() , make_difference path <span class="hljs-string"><span class="hljs-string">"create"</span></span> ,new_node[] []; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !new_node <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>() , make_difference path <span class="hljs-string"><span class="hljs-string">"remove"</span></span> ,index[] []; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_different old_node new_node <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>() , make_difference path <span class="hljs-string"><span class="hljs-string">"replace"</span></span> ,index,new_node[] []; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> == <span class="hljs-string"><span class="hljs-string">"hash"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">old_node</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> child_path + path , .<span class="hljs-string"><span class="hljs-string">"type"</span></span>old_node []; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> properties_differences compare_properties child_path .<span class="hljs-string"><span class="hljs-string">"properties"</span></span>old_node .<span class="hljs-string"><span class="hljs-string">"properties"</span></span>new_node ; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> children_pairs zip_longest .<span class="hljs-string"><span class="hljs-string">"children"</span></span>old_node .<span class="hljs-string"><span class="hljs-string">"children"</span></span>new_node <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(node_i node_ii) ,node_i,node_ii[] ; ; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> children_differences <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result reduce {} children_pairs <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(result children_pair) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index ?? .<span class="hljs-string"><span class="hljs-string">"index"</span></span>result <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> differences compare_nodes .<span class="hljs-number"><span class="hljs-number">0</span></span> children_pair .<span class="hljs-number"><span class="hljs-number">1</span></span> children_pair index child_path ; #<span class="hljs-string"><span class="hljs-string">"differences"</span></span> + ?? .<span class="hljs-string"><span class="hljs-string">"differences"</span></span>result [] differences #<span class="hljs-string"><span class="hljs-string">"index"</span></span> ++ index {}; ; ?? .<span class="hljs-string"><span class="hljs-string">"differences"</span></span>result [] ; + properties_differences children_differences ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>() []; ; ; ; ; #<span class="hljs-string"><span class="hljs-string">"make_node"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(kind properties children) make_node kind properties children ; #<span class="hljs-string"><span class="hljs-string">"compare_nodes"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(old_node new_node index path) compare_nodes old_node new_node index path ; {}</code> </pre> </div></div><br><p>  I minified the JavaScript version using the <a href="https://developers.google.com/closure/compiler/">Google Closure Compiler</a> ( <a href="https://github.com/google/closure-compiler-js">JavaScript version</a> ), the version in my language - manually. </p><br><p>  Results: </p><br><table><thead><tr><th>  Parameter </th><th>  Javascript </th><th>  My language </th></tr></thead><tbody><tr><td>  Volume of the full version </td><td>  2398 B </td><td>  2827 B </td></tr><tr><td>  The volume of the minified version </td><td>  <strong>794 B</strong> </td><td>  <strong>872 B</strong> </td></tr><tr><td>  Volume savings </td><td>  66.89% </td><td>  69.16% </td></tr></tbody></table><br><h3 id="itogi">  Results </h3><br><p>  In order for my idea to make sense, it was necessary to exceed JavaScript in compression several times (after all, a place for the interpreter itself is needed).  And the result was even greater. </p><br><p>  Thus the experiment ended in failure.  The ideas that I laid the foundation for the language did not bring the expected benefits. </p><br><h3 id="repozitoriy">  Repository </h3><br><p>  The interpreter source code (implemented in Python), the standard library and examples, as well as the documentation are available <a href="https://github.com/thewizardplusplus/micro">in the repository</a> under the MIT license. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/351772/">https://habr.com/ru/post/351772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351762/index.html">Conference DEFCON 21. "As my Botnet earned millions of dollars in car sales and defeated Russian hackers"</a></li>
<li><a href="../351764/index.html">Data center with interesting physical protection</a></li>
<li><a href="../351766/index.html">T-commerce: how online sales work with Telegram</a></li>
<li><a href="../351768/index.html">How we changed paid Slack to open-source Rocket.Chat</a></li>
<li><a href="../351770/index.html">Gartner released a new quadrant of monitoring solutions for 2018 (and at the same time missed 2017)</a></li>
<li><a href="../351774/index.html">Operating systems from scratch; level 1 (upper half)</a></li>
<li><a href="../351782/index.html">Ping-Pong algorithm or criticism of the Reverse Polish Notation</a></li>
<li><a href="../351784/index.html">15 ways to turn brainstorming into a ‚Äúfire‚Äù result</a></li>
<li><a href="../351790/index.html">Benefits, risks and secrets of in-app advertising</a></li>
<li><a href="../351792/index.html">Profile of non-ideal customer. What clients to refuse and why it is vital</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>