<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Grid control ... continued 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first post we have broken the grid functionality into several classes. Let's quickly describe them again: 


- Lines - represents a set of colu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Grid control ... continued 1</h1><div class="post__text post__text-html js-mediator-article">  In the first <a href="http://habrahabr.ru/post/203968/">post</a> we have broken the grid functionality into several classes.  Let's quickly describe them again: <br><ul><li>  Lines - represents a set of columns or lines. </li><li>  Range - describes any collection of cells. </li><li>  Layout - allows you to place data inside the cell. </li><li>  Model - defines the data access interface for View and Controller. </li><li>  View - shows information in the cell. </li><li>  Controller - allows the user to change data. </li><li>  CacheCell - caches data for a visible cell. </li><li>  CacheGrid - caches data for the visible part of the grid. </li><li>  GridWindow is a special control. </li></ul><br>  We also described models and view for text data (ModelText, ModelTextCallback. ViewText).  Let's try to create a grid and attach text data to it.  New functionality that is needed for the standard grid will be added in the form of special Model / View / Controller. <br><a name="habracut"></a><br>  For brevity, I will omit pointers, shared_ptr, etc. in the code.  So let's go ... <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Application app; <span class="hljs-comment"><span class="hljs-comment">//   GridWindow grid_window("Demo"); //    ModelTextCallback m; m.getCallback = [](CellID cell)-&gt;String { return String.Format("Item[%d, %d]", cell.row, cell.column); }; //   ,     grid_window.AddData(RangeAll(), ViewText(m), LayoutAll()); //      grid_window.SetRows(10); grid_window.SetColumns(10); //   grid_window.Show(100, 100, 300, 300); app.run(); }</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/d9e/554/49e/d9e55449ed5ce2b9da344137b614ee19.png"><br><br>  Not bad, I just want to somehow isolate the cells: draw either through the stripes or the grid.  Let's implement one, and then another option.  Hope the code speaks for itself. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewOddRowBackground</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> View { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DrawContext&amp; dc, Rect rect, CellID cell)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ,    if (cell.row%2 == 0) dc.FillRect(rect, ColorRGB(200, 200, 255)); } }; void plugOddRowBackgroud(Grid&amp; grid) { grid.AddData(RangeAll(), ViewOddRowBackground(), LayoutAll(Transparent)); }</span></span></code> </pre>  Notice, we passed the parameter Transparent in LayoutAll, it says that this layout will not modify the rectangle of the cell.  Remember that by default, LayoutAll "takes" the entire free area of ‚Äã‚Äãthe cell and zeros it.  In Transparent mode, it will not do this and the next ViewText will get the same original rectangle. <br>  It remains to add a call to the new function in main <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">GridWindow </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grid_window</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Demo"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; plugOddRowBackgroud(grid_window.GetGrid());</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/3dd/6e0/841/3dd6e0841ac0a9ebc2f8af3e67396357.png"><br><br>  Now we implement the grid. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewCellBounds</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> View { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DrawContext&amp; dc, Rect rect, CellID cell)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     dc.Line(rect.BottomLeft(), rect.BottomRight()); //       dc.Line(rect.TopRight(), rect.BottomRight()); } }; void plugCellBounds(Grid&amp; grid) { grid.AddData(RangeAll(), ViewCellBounds(), LayoutAll(Transparent)); } ... GridWindow grid_window("Demo"); plugCellBounds(grid_window.GetGrid());</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/ac0/f77/50d/ac0f7750da661523cfd0ec903c1935a0.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The next common place for all grids is the notion of selected cells.  Previous views did not store any data, so we did not create models for them.  Here the situation is a bit more complicated.  What should be included in the ModelSelection?  First, a set of selected cells, and, secondly, the coordinates of the active cell (this is the cell that is usually marked with a frame, and using the keyboard we work with this cell).  Write the code: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelSelection</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">Range </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSelectedRange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_selected_range; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetSelectedRange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Range new_selected_range)</span></span></span><span class="hljs-function"> </span></span>{ m_selected_range = new_selected_range; changed.invoke(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-function">CellID </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetActiveCell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_active_cell; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetActiveCell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CellID new_active_cell)</span></span></span><span class="hljs-function"> </span></span>{ m_active_cell = new_active_cell; changed.invoke(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Range m_selected_range; CellID m_active_cell; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewSelection</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> View { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ViewSelection(ModelSelection selection) : m_selection(selection) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DrawContext&amp; dc, Rect rect, CellID cell)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    -&gt;   if (m_selection.GetActiveCell() == cell) dc.DrawFrame(rect); //    -&gt;   //       if (m_selection.GetSelectedRange().HasCell(cell)) { dc.FillRect(rect, ColorSelectedBackground); dc.SetTextColor(ColorSelectedText); } } private: ModelSelection m_selection; }; ModelSelection plugSelection(Grid&amp; grid) { ModelSelection selection; grid.AddData(RangeAll(), ViewSelection(selection), LayoutAll(Transparent)); return selection; } ... GridWindow grid_window("Demo"); plugCellBounds(grid_window.GetGrid()); plugSelection(grid_window.GetGrid());</span></span></code> </pre><br>  I omit the implementation of the controller to save space.  Believe me, everything is also simple there: by pressing the left mouse button, we change the active cell to the one under the arm.  When moving the mouse and releasing the left key, we create a special Range, which describes a rectangular block of cells from the active (where we pressed the button) to the current one.  We set this Range in selection.  You also need to consider the state of the Shift and Ctrl keys, but these are details.  As a result, we get the following picture. <br><img src="https://habrastorage.org/getpro/habr/post_images/127/b6e/fe2/127b6efe268e34bb7828419742cff594.png"><br><br>  To enable the user to change the size of rows and columns, we need to implement a special controller that, by pressing the mouse button near the edge of the cell, will remember the position of the mouse, and when the mouse is pressed, it will change the width of the column by the difference between the initial and the current ones.  I hope the idea is clear.  It is worth noting that our controllers ‚Äúlive‚Äù in views (views), so we need to create a dummy View, which draws nothing, but only defines a rectangle in which the controller will be activated. <br><br>  Quite often, grids have a title ‚Äî the part of the grid that always remains at the top of the window.  Sometimes there is a similar construction on the left (usually they write the line number there).  When scrolling these areas remain in place.  Let's see how the headline might look like: <br><img src="https://habrastorage.org/getpro/habr/post_images/710/692/905/710692905bc03b1e0ba67d230889d472.png"><br>  Very similar to a grid consisting of one line and the same number of columns as the original grid.  Then we can say that the title is a grid, the columns of which are synchronized with the columns of the original grid (in fact, the same grid Lines instance is used in two grids).  This grid is located at the top of the window and scrolls horizontally only.  A similar statement can be said about the left fixed part, only there the lines are synchronized.  Thus, in our GridWindow class, live four CacheGrid instead of one. <br><img src="https://habrastorage.org/getpro/habr/post_images/901/4e1/3f1/9014e13f146f8b6407fde1165360897e.png"><br>  Let's go even further and say that fixed areas can be from any side. <br><img src="https://habrastorage.org/getpro/habr/post_images/808/240/35d/80824035d02a1b82d4b03c887c4d088a.png"><br>  So, the GridWindow class has become more complicated - instead of one CacheGrid, we have nine of them.  The functions of drawing, scrolling, handling mouse events should also become more complicated.  I propose here to stop and take a close look at the last drawing.  From a distance, it looks like an area divided into nine sub-areas in three lines and three columns.  It looks like a grid with three rows and columns, in the cells of which other grids are displayed.  By definition, our View is so universal that it can display any entity.  So let's create a View, which displays a grid in the cell.  For our case with nine grids, we get about the following classes: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelGrid</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ModelGrid(); <span class="hljs-function"><span class="hljs-function">CacheGrid </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetGrid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CellID cell)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_grids[cell.row][cell.column]; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: CacheGrid m_grids[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">3</span></span>]; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewGrid</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> View { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ViewGrid(ModelGrid model) :m_model(model) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DrawContext&amp; dc, Rect rect, CellID cell)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ CacheGrid cacheGrid = m_model.GetGrid(cell); cacheGrid.Draw(dc); } };</code> </pre>  In the ModelGrid constructor, nine CacheGrid objects are created and the rows and columns are synchronized.  It is also not difficult to implement the controller.  If we add a ViewGrid to our old GridWindow class, which had only one CacheGrid object, then we do not need to create a new type of GridWindow.  The only difference is that we need to pass the position of the scrollbars to subgroups: the angle grids will ignore the scrolling position (Top / Left, Top / Right, Botton / Right, Bottom / Left), the Top and Bottom grids will scroll horizontally, the Left and Right will be scrolled horizontally .  Well, the central Client grid will be scrolled on all sides.  At the same time, the code for rendering and interaction with the mouse will remain the same. <br><br>  Here we will stop again and see what kind of maneuver we have just made?  In the beginning, we had a statement - a grid is a set of cells, and a cell is a place where anything is displayed.  Now it turns out that a cell can display anything, including a grid.  The chain is closed - the grid draws cells, the cells draw a grid.  This raises the philosophical question of chicken and egg.  What comes first?  A grid that consists of cells, or a cell that can represent anything, including a grid.  It seems that the concept of a cell is more universal.  Remember the CellCache class from the first article - the first thing the three &lt;Range, View, Layout&gt; triples were filtered by Range, that is, in fact, the cell should then store not triples, but &lt;View, Layout&gt; twos - which describe what and where in the cell paint.  CellCache is able to draw itself and handle mouse events (transferring them to the necessary controller), while the Grid is not mentioned anywhere. <br><br>  But what if we create a window class that will not draw a CacheGrid, but a CacheCell?  Then we‚Äôll get not a grid window class, but a more versatile control, in which we simply, in the form of &lt;View, Layout&gt; twos, ask what and where to draw.  For example, the combination {&lt;ViewCheck, LayoutLeft&gt;, &lt;ViewText, LayoutAll&gt;} gives us the standard control of the checkbox.  Other combinations will give other types of controls, and different Layouts give us the opportunity to have Views in any configuration.  For example checkbox to the right of the text, below, above - as you like. <br><br>  Let's call this window the ItemWindow (a cell is a concept closely related to the grid, item is more neutral).  I have a hierarchy of three classes: <br><ol><li>  ItemWindow is a universal control that contains one instance of CacheCell.  In fact, the whole window is a single cell. </li><li>  ListWindow is the heir of ItemWindow.  Adds a ViewGrid to the CacheCell instance, which will draw one grid in the cell.  This option is good for simple lists without fixed areas (title, etc.) </li><li>  GridWindow is a heir of ListWindow.  Makes a grid, declared in ListWindow, with three rows and columns.  It sets another ViewGrid on this grid, which draws nine sub-grids.  This is a control for those who need headlines. </li></ol><br><br>  As a rule, when developing a library of visual components, they first define simple types of windows, then move to more complex (item based).  At this point, the basic concepts of the window are already fixed and do not take into account the specifics of item-based windows.  Therefore, they come up with some other abstractions that are not related to the basic concepts of the window.  As a result, it is impossible to organically use simple and complex controls together.  We went from a complex control and we ended up with simple windows.  But their structure is a bit more complicated than in ordinary window frameworks.  But we get universality - Views and Layouts are used in both simple (ItemWindow) and more complex controls.  It turns out once implementing ViewCheck, we can use it as a simple control and as a sub-element of the grid. <br><br>  The article turned out to be rather long and complicated, so for now I‚Äôll finish it.  If something seems incomprehensible or incorrect to you, please write comments, I will edit the article.  Thus, the article for all will be easier and more understandable. <br><br>  In the next article I will describe how you can make an introspection for our window.  Any tool capable of sending messages to the window and interpreting a sequence of bytes will be able to ‚Äúcommunicate‚Äù with the grid.  This will allow us to make a binding to the grid on python and do automatic testing of our control.  I will also tell you how all sorts of ‚Äúsweets‚Äù from devexpress are implemented in my scheme.  As I said, a working prototype of this architecture already exists, so it will not be difficult to implement it in open source. </div><p>Source: <a href="https://habr.com/ru/post/204374/">https://habr.com/ru/post/204374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../204362/index.html">Microsoft warns of operating CVE-2013-5065 ITW</a></li>
<li><a href="../204364/index.html">Thinkspace: Zuckerberg Factory</a></li>
<li><a href="../204368/index.html">Tube Linux-like terminal in Windows</a></li>
<li><a href="../204370/index.html">LTE in Moscow</a></li>
<li><a href="../204372/index.html">Yandex Linguistics API for .NET</a></li>
<li><a href="../204376/index.html">Heavy lonely indie burden</a></li>
<li><a href="../204380/index.html">Finding periodic solutions of a class of non-autonomous systems of differential equations</a></li>
<li><a href="../204384/index.html">Chips for Android</a></li>
<li><a href="../204390/index.html">Akenori 1080 X Review: How to Turn the Recorder into an Integrated Security System</a></li>
<li><a href="../204392/index.html">MongoDB Is Web Scale</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>