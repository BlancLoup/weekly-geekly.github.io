<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Silent algorithms: model ‚Äúmake, write, (assign to another)‚Äù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Following the advice of a habrapublic, I try a new version of the translation of the term " lock-free " 

 Last time, we saw an ‚Äúunconcerned‚Äù algorith...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Silent algorithms: model ‚Äúmake, write, (assign to another)‚Äù</h1><div class="post__text post__text-html js-mediator-article"> <i>Following the advice of a habrapublic, I try a new version of the translation of the term " <b>lock-free</b> "</i> <br><br>  <a href="http://habrahabr.ru/blogs/system_programming/118515/">Last time,</a> we saw an ‚Äúunconcerned‚Äù algorithm where the capture was implemented so that the stream accessing the captured data does not wait for their release, but is sent in a ‚Äúworkaround‚Äù (calculates the required result without using the cache services).  In his next post, Raymond explains how this algorithm can be improved in the event that there is no ‚Äúworkaround‚Äù.  The algorithm, however, remains inconspicuous: each stream continues to work, without waiting for the release of the captured data. <br><br>  In the common variable, two service bits are now needed: in addition to the capture flag, as in the previous example, the ‚Äúnew job is assigned‚Äù flag;  and if the work assigned is complex, then besides the flag, it will also need to be stored somewhere else and its parameters.  For example, a pointer to an (memory-aligned) object with parameters can be stored in a common variable, and two named flags can be stored in the free low-order bits of the pointer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Before performing an action on an object, we first capture it by setting the corresponding flag atomically.  If it turns out that the object has already been captured, we will entrust the execution of our action to the seizing thread by setting the second flag. <br><br>  If the object was able to be captured, then after the completion of work with it, we remove the capture flag and at the same time check whether we have been assigned a new job.  (Ie if there were no appeals to the object during the time we kept it captured.) If there is work, then we will do it;  and so on, until one day when unlocking the object of deferred work will not be.  We have no right to leave the object in the state ‚Äúnot captured, but there is work‚Äù. <br><a name="habracut"></a><br>  The resulting model ‚Äúmake, write, (instruct another)‚Äù is woven from a multitude of cycles in case of all sorts of failures.  Every atomic operation is a cycle;  execution of deferred work is carried out in a cycle;  and each time a call from <code>InterlockedCompareExchange</code> reveals a rewrite of the data used, you need to roll back all the work done and perform it from the beginning.  The model is very complicated.  Raymond describes it as follows: ‚ÄúIn the whole world, perhaps, only five will be able to implement it correctly, and I don‚Äôt belong to these five.‚Äù Nevertheless, he gives an example of an object called GroupWait, which supports two operations: <ul><li>  AddWait: Add a new handle to the list. </li><li>  SignalAll: Install all events in the list, automatically deleting each event simultaneously with its installation.  For the event to be set the next time you call SignalAll, you need to add it to the list again. </li></ul>  Implemented an object simply as a list of handles.  It is clear that it could be implemented without a sophisticated, tacky model: for example, using <a href="http://msdn.microsoft.com/en-us/library/ms684121.aspx">atomic list functions</a> implemented since Windows XP.  The task was chosen only to accompany the verbal description with an approximate code.  Do not take GroupWait as a sample implementation of a stream-safe list. <br><br>  So, we use the lower two bits of the pointer to store two flags: a capture flag indicating that some thread is performing a list operation;  and a work flag indicating that the user requested the setting of events at the time the list was captured. <br><br><pre> // WARNING!  IF YOU USE THIS CODE YOU ARE AN IDIOT - READ THE TEXT ABOVE

 struct NODE;
 NODE * Node (LONG_PTR key) {return reinterpret_cast &lt;NODE *&gt; (key);  }

 enum {
  Locked = 1,
  Signalled = 2,
 };

 struct NODE {
  NODE * pnNext;
  HANDLE hEvent;

  LONG_PTR Key () {return reinterpret_cast &lt;LONG_PTR&gt; (this);  }
  NODE * Ptr () {return Node (Key () &amp; ~ (Locked | Signalled));  }
 };

 #define NODE_INVALID Node (-1)

 class GroupWait {
 public:
  GroupWait (): m_pnRoot (NULL) {}
  ~ GroupWait ();
  BOOL AddWait (HANDLE hEvent);
  void SignalAll ();
 private:
  NODE * m_pnRoot;
 };
</pre><br>  Since we combine in one value a pointer to a list item and a pair of flags, for convenience it is worth defining methods that convert the used types into one another: <code>Node</code> returns a pointer, <code>Key</code> is a numeric value, and <code>Ptr</code> is a usable pointer (without flags in the lower bits) . <br><br>  We will display our values ‚Äã‚Äãas bit fields of the form <code>p|S|L</code> : p is a pointer to the next element of the list;  S - work flag;  and L is the capture flag.  The set flag S means that you need to process all the elements of the list, starting <i>from the next</i> - imagine it indicated not inside the element, but on the outgoing arrow. <br><br>  For example: <br><pre>    m_pnRoot
   + -------- + - + - +
   |  * | 0 | 1 |
   + --- | ---- + - + - +
       |
       v
   + -------- + - + - + --------- +
 A |  * | 1 |? |  hEvent1 |
   + --- | ---- + - + - + --------- +
       |
       v
   + -------- + - + - + --------- +
 B |  * |? |? |  hEvent2 |
   + --- | ---- + - + - + --------- +
       |
       v
   + -------- + - + - + --------- +
 C |  NULL |? |? |  hEvent3 |
   + -------- + - + - + --------- +
</pre><br>  A GroupWait object containing three handles is shown.  The reset flag S in the head of the list means that no one required to set the event hEvent1.  In contrast, the set flag S in the element A means that you need to bypass all the elements after A and set the corresponding events - namely, hEvent2 and hEvent3.  In particular, the value of the flag S in elements B and C does not matter;  these elements will be processed anyway, because that is required by the S flag in the element A. Thus, the value of the S flag in the last element of the list never really matters. <br><br>  The L flag is used only in the head of the list;  in all other elements it does not matter. <br><br>  So the preparations are complete;  Add a new handle to the list. <br><br><pre> BOOL GroupWait :: AddWait (HANDLE hEvent)
 {
  NODE * pnInsert = new (nothrow) NODE;
  if (pnInsert == NULL) return FALSE;
  pnInsert-&gt; hEvent = hEvent;

  NODE * pn;
  NODE * pnNew;
  do {
   pn = InterlockedReadAcquire (&amp; m_pnRoot, NODE_INVALID);
   pnInsert-&gt; pnNext = pn;
   pnNew = Node (pnInsert-&gt; Key () | (pn-&gt; Key () &amp; Locked));
  } while (InterlockedCompareExchangeRelease (&amp; m_pnRoot, pnNew, pn)! = pn);
  return TRUE;
 }
</pre><br>  We add a new element to the top of the list, and make sure that the L flag from the old element is transferred to the new one: otherwise it may happen that another thread has already captured the list, and we inadvertently ‚Äúreleased‚Äù it.  The S flag in the added item is cleared: no one has yet requested to set a new event.  We add an element to the head of the list, we use the familiar model ‚Äúmake, write, (try again)‚Äù - checking that no one has changed the list behind our backs.  Please note that the ‚ÄúABA problem‚Äù does not arise: even if the unchanged value <code>m_pnRoot</code> points to another object, we still use only the pointer itself, and not the contents of the object. <br><br>  The simplicity of the AddWait method is unusual for the ‚Äúmake, write, (instruct another)‚Äù model: in case of failure, we have nothing to delegate - all the work consists of one record in memory.  Pay for this simplicity will be the other methods, which will have to provide for the processing of elements added to the list during the time it was captured. <br><br>  The SignalAll method is so complicated that it is better to read it in parts. <br><pre> void GroupWait :: SignalAll ()
 {
  NODE * pnCapture;
  NODE * pnNew;
  do {
   pnCapture = InterlockedReadAcquire (&amp; m_pnRoot, NODE_INVALID);

   if (pnCapture-&gt; Key () &amp; Locked) {
    pnNew = Node (pnCapture-&gt; Key () | Signaled);
   } else {
    pnNew = Node (Locked);
   }
  } while (InterlockedCompareExchangeAcquire (&amp; m_pnRoot,
                               pnNew, pnCapture)! = pnCapture);

  if (pnCapture-&gt; Key () &amp; Locked) return;

  ...
</pre><br>  If the list is captured, the only thing that is required of us is to set the S flag in his head. If the list is free, then we will try to capture it, and at the same time ‚Äústeal‚Äù all the elements of the list, writing down the ‚Äúcap‚Äù <code>NULL|0|1</code> instead of the head.  In both cases, the rewriting of the head of the list is carried out according to the model ‚Äúmake, write, (try again)‚Äù - we repeat the attempts until the recording fails. <br><br>  By setting the flag S, we reassigned our work to the thread that grabbed the list.  The set flag S in the head of the list means that it is necessary to process all elements of the list following the head ‚Äî that is  in general, all the elements of the list;  just what we need.  The thread that captures the list will check the flag when the list is released, and do the work for us. <br><br>  If the list was not captured, then we took it by our action.  ‚ÄúStolen‚Äù elements are not visible to other streams, so that a simultaneous call of SignalAll from different streams will not lead to multiple installation of events. <br><pre>  ...
  NODE * pnNext;
  NODE * pn;
  for (pn = pnCapture-&gt; Ptr (); pn; pn = pnNext) {
   SetEvent (pn-&gt; hEvent);
   pnNext = pn-&gt; pnNext-&gt; Ptr ();
   delete pn;
  }
  ...
</pre><br>  The bypass of the ‚Äústolen‚Äù list is implemented in a very straightforward manner, without any concern for flow-safety;  just take the item by item, set the event, and delete the item.  The only feature is calling <code>Ptr</code> to remove flags from the pointer to the next item. <br><br>  Now you need to unlock the list.  To start: <br><pre>  ...
  pnCapture = pnNew;
  ...
</pre><br>  At the beginning of the method, we wrote down <code>pnNew</code> in <code>m_pnRoot</code> , and if this value remained in the head of the list, it means that we got off easy: no one turned to the list for the time we were working with it. <br><pre>  ...
  for (;;) {
   pnNew = Node (pnCapture-&gt; Key () &amp; ~ Locked);
   if (InterlockedCompareExchangeRelease (&amp; m_pnRoot,
                       pnNew, pnCapture) == pnCapture) {
    return;
   }
  ...
</pre><br>  First, let's check if the list has changed: if not, it is enough just to unblock it - and that's it.  Otherwise, we start a new cycle: you need to perform all the pending work that has accumulated while the list has been captured. <br><pre>  ...
   pnCapture = InterlockedReadAcquire (&amp; m_pnRoot, NODE_INVALID);

   NODE * pnNew = Node (pnCapture-&gt; Key () &amp; ~ (Locked | Signaled));
   NODE ** ppn = &amp; pnNew;
   NODE * pn;
   NODE * pnNext;

   BOOL fSignalSeen = FALSE;
   for (pn = pnNew; pn-&gt; Ptr (); pn = pnNext) {
    pnNext = pn-&gt; Ptr () -&gt; pnNext;
    if (fSignalSeen) {
     SetEvent (pn-&gt; Ptr () -&gt; hEvent);
     delete pn-&gt; Ptr ();
    } else if (pn-&gt; Key () &amp; Signaled) {
     fSignalSeen = TRUE;
     (* ppn) = Node (Locked);  // steal, leaving captured
     SetEvent (pn-&gt; Ptr () -&gt; hEvent);
     delete pn-&gt; Ptr ();
    } else {
     ppn = &amp; pn-&gt; Ptr () -&gt; pnNext;
    }
   }
  } // try to unlock again
 } // end of function
</pre><br>  To perform a deferred job, we go around the list until we find the set bit S. In the first element, in which the bit S is set, we reset the outgoing pointer to ‚Äústeal‚Äù the rest of the list;  then, bypassing this remainder, we set each event, and delete the item.  As before, we ‚Äústeal‚Äù the list so that simultaneous calling from several threads does not lead to multiple installation of the event.  At the end, when the work is done, we again try to unlock the list - in the expectation that one day there will be no new work, and we will be able to right out of the function. <br><hr>  As you can see, the basic idea of ‚Äã‚Äãthe ‚Äúmake, write, (instruct another)‚Äù model is quite simple, but its implementation, taking into account all the subtleties, can cause a headache.  It is best to leave the implementation of such pieces to system programmers who have enough time, patience and ability to cope with all this.  For example, in an interview with <a href="http://channel9.msdn.com/shows/Going%2BDeep/Arun-Kishan-Farewell-to-the-Windows-Kernel-Dispatcher-Lock/">Arun Kishan: Inside Windows 7 ‚Äî Farewell to the Windows Kernel Dispatcher Lock</a> ‚Äî the architect who worked on the Windows kernel talks about using this particular model. </div><p>Source: <a href="https://habr.com/ru/post/118850/">https://habr.com/ru/post/118850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../118844/index.html">Anonymity is not, accept! (Russian subtitles)</a></li>
<li><a href="../118845/index.html">Difficult work vs routine work</a></li>
<li><a href="../118846/index.html">Verification of five open projects with general-purpose static analyzers</a></li>
<li><a href="../118847/index.html">Canobuvosti, 90th edition</a></li>
<li><a href="../118849/index.html">Oculographic studies: what the view does not tell</a></li>
<li><a href="../118851/index.html">History of e-books: Firstborn</a></li>
<li><a href="../118852/index.html">Happy Radio !!!</a></li>
<li><a href="../118853/index.html">Drop-down lists: ergonomics and design</a></li>
<li><a href="../118855/index.html">Master class "Evolution of creativity" from Adobe. Special discount for habrovchan 70%</a></li>
<li><a href="../118856/index.html">Qt Creator 2.2 Release</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>