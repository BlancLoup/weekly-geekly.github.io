<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview of the domestic single-board computer MB 77.07: From unpacking and firmware, to writing the first DSP program</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nowadays, the SBC (Single Board Computer) market has greatly expanded, and a huge number of single-board computers have appeared on a wide variety of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overview of the domestic single-board computer MB 77.07: From unpacking and firmware, to writing the first DSP program</h1><div class="post__text post__text-html js-mediator-article">  Nowadays, the SBC (Single Board Computer) market has greatly expanded, and a huge number of single-board computers have appeared on a wide variety of processors, from old and well-known to completely new and specialized ones.  Recently, Module MB 77.07 hit me ‚Äî a single-board computer from the STC ‚ÄúModule‚Äù on a domestic-made K1879HB1Y processor, about which once from Hubre people from <a href="http://habrahabr.ru/company/promwad/">Promwad</a> had already <a href="http://habrahabr.ru/post/217893/">left a small note</a> .  From the moment of that post they began to sell the fee to everyone and the software was posted on the company's official github - <a href="http://github.com/RC-MODULE">http://github.com/RC-MODULE</a> <br><br>  The article will describe hardware and software, from unpacking and flashing, to writing a simple example - an echo audio effect on the NeuroMatrix core embedded in the DSP processor used. <br><a name="habracut"></a><br><h1>  Equipment </h1><br>  The board comes in a color branded box.  Inside are: <br><br><ul><li>  MB fee 77.07 </li><li>  Ethernet patchcord </li><li>  5V / 2A power supply </li><li>  USB-UART for those who meet the embedded world for the first time </li></ul><br>  Here you can argue whether all this is necessary or would be enough for the usual OEM delivery in the form of an antistatic bag with a fee.  I think it will be useful for beginners to get a USB-UART right away, there will be less people willing to google, get the standard bad advice ‚Äúconnect to a COM port, nothing will happen‚Äù and burn the board on the very first day after purchase. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/123/2ea/620/1232ea62025b42b28f799188256cfb34.JPG"><br><br><img src="https://habrastorage.org/files/364/19b/53e/36419b53e09c4700a61d41c35969cec4.JPG"><br><br><img src="https://habrastorage.org/files/ae9/871/c0a/ae9871c0ace34b08a1455fe5d855f971.JPG"><br><br><img src="https://habrastorage.org/files/914/556/e91/914556e91e0b42afbf8b24d6ae2e12af.JPG"><br><br><h1>  Iron </h1><br>  Now it is worth considering the board itself.  The board is ARM1176, the same core is used in the Raspberry Pi.  You can run the distros sharpened under r-pi, of course, with the proviso that you need to slip the drivers for the local IP core used in the processor.  To facilitate this task, the processor developer, SEC Module, provides ready-made images of Debian Jessie and Raspbian Wheezy, packages are updated periodically. <br><br>  Next to K1879HB1Y itself, two 128MB DDR2 memory chips, 1GB NAND memory, 4-port USB hub, Ethernet PHY and piping are soldered. <br><br>  On the pins located on both sides of the board, various external interfaces are located: <br><br>  Right side: <br><br><ul><li>  JTAG </li><li>  2xUSB - pinout is exactly the same as on the motherboard, take out the slats from the boxes </li><li>  UART with boot console </li></ul><br>  Left side, long IDE-like connector: <br><br><ul><li>  8x GPIO </li><li>  1x <a href="http://en.wikipedia.org/wiki/Common_Interface">Transport Stream Interface</a> <a href="http://books.google.ru/books%3Fid%3DyWrWqcghf3AC%26pg%3DPA119%26lpg%3DPA119%26dq%3Dtransport%2Bstream%2Binterface%26source%3Dbl%26ots%3DGfNgHiidLS%26sig%3DsJREh2YvogfmYthvjZFxM3ZNkTs%26hl%3Dru%26sa%3DX%26ei%3DLbL5U_-nEsvMyAOHnoLIBQ%26ved%3D0CDUQ6AEwBg">(very detailed here)</a> </li><li>  1x I2C </li><li>  1x SPI </li><li>  1x I2S </li><li>  1x SPDIF </li><li>  1x External Interrupt </li><li>  1.5x UART - one UART is full, the second is only RX </li><li>  1x RESET </li><li>  5V </li><li>  3.3V - a dedicated channel of a switching power supply responsible for this channel, delivering 800mA, really knowing modern Chinese components, I would not hang more than 500mA here </li></ul><br>  Detailed pinout is available at the link: <a href="http://www.module.ru/mb7707/doc/MB77.07-X9-pinout.pdf">http://www.module.ru/mb7707/doc/MB77.07-X9-pinout.pdf</a> <br><br>  Consider the GPIO in more detail, since this is the very first place that you want to feel for yourself.  GPIO here are two different types.  The first type is those that are displayed on the comb, they are picked up by the gpio-pl061 driver (IP core <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.ddi0190b/index.html">ARM PrimeCell ‚Ñ¢ General Purpose Input / Output PL061</a> ).  These GPIOs can pull interrupts to the ARM core, which is sometimes useful.  In addition, if you do not need the Transport Stream, then its _D [0-7] pins can be multiplexed into GPIO, so you can get 16 controlled legs. <br><br>  The numbering of GPIO legs in sysfs is in the documents above by reference, and if you like, you can pull them through sysfs: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   sysfs,  ,    gpio cd /sys/class/gpio #  23-  echo 23 &gt; export #     out echo out &gt; gpio23/direction #    echo 1 &gt; gpio23/value</span></span></code> </pre> <br>  The second type of GPIO is more simplified, managed by another IP core, they cannot pull interrupts.  Two printed LEDs are installed on these GPIOs, one of them is registered through the LED framework of the Linux kernel as heartbeat and shows the Load Average.  It is useful when visually debugging to see if everything is stuck. <br><br>  A separate place on the board is occupied by two pins for the boot jumper. <br><br>  Downloading is done simply and securely: when there is no jumper, it is loaded from NAND memory, when the jumper is worn - the board is waiting for download via JTAG or EDCL.  The jumper position is read when the board resets.  It is worth telling about the last mode in more detail, since it is possible that you have not encountered it. <br><br><h2>  EDCL </h2><br>  EDCL or Ethernet Debug Communications Link is a hardware function, built-in Ethernet controller that allows you to write and read physical memory, sending well-formed Ethernet packets.  This feature was bundled with the IP Core of the used Ethernet controller - greth.  EDCL itself is quite convenient, but if you leave it enabled in production, you get a very big security hole (I wonder how many processors with the same Ethernet controller work with EDCL enabled in production?). <br><br>  On top of EDCL, there is a curious edcltool tool that gives the host the edua lua API.  This technology is used for anbrika and firmware boards.  Edcltool itself was originally designed for Linux, in contrast to the popular manufacturers of SoCs, providing you with some livesuit / phoenixsuit or rkbatch. <br><br>  There is a version for Windows, but it is experimental, assembled in haste through mingw and requires WinPCAP installation.  In addition, it works quite slowly. <br><br>  The Linux version is set as standard ./bootstrap &amp;&amp; ./configure --prefix = / usr &amp;&amp; make &amp;&amp; sudo make install and asks only lua5.1-dev or lua5.2-dev and libelf.  The latter is needed if you need to work with NeuroMatrix DSP, which will be discussed below. <br><br>  The edcltool itself executes edcl scripts, which are actually ordinary lua scripts that look very simple and readable.  For example, here is the script that runs the code on the bare ARM: <br><br><pre> <code class="lua hljs">fw = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"fw"</span></span>); edcl_init(); fw.run_code(<span class="hljs-string"><span class="hljs-string">"mboot-uemd.bin"</span></span>);</code> </pre><br>  Next, here is the mboot bootloader firmware: <br><br><pre> <code class="lua hljs">fw = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"fw"</span></span>); edcl_init(); fw.run_code(<span class="hljs-string"><span class="hljs-string">"mboot-uemd.bin"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">-- start in slave mode fw.write_bootloader("mboot-signed.bin")</span></span></code> </pre><br>  Creating a partition table in NAND, kernel record, dtb and root filesystem: <br><br><pre> <code class="lua hljs">fw = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"fw"</span></span>); edcl_init(); fw.run_code(<span class="hljs-string"><span class="hljs-string">"mboot-uemd.bin"</span></span>,<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">-- start in slave mode fw.write_bootloader("mboot-signed.bin") -- save signed loader in NAND -- all sizes are in bytes partition_table = { { "kernel", 4*1024*1024 }, { "rootfs", "-" }, } fw.partition(partition_table); -- prepare and erase all nand fw.mboot_cmd("parterase kernel y y") fw.mboot_cmd("parterase rootfs y y") fw.flash_part("kernel", "uImage", false); fw.flash_part("dtb", "mb77.07.dtb", false); fw.flash_part("rootfs", "filesystem.ubifs", false); fw.mboot_cmd("setenv bootargs console=ttyS0,38400n8 earlyprintk=serial ubi.mtd=4,2048 root=ubi0:rootfs rootfstype=ubifs"); fw.mboot_cmd("setenv bootfdt 1") fw.mboot_cmd("save");</span></span></code> </pre><br>  This is how the launch of the code on the bare NeuroMatrix (abbreviated NMC) looks like: <br><br><pre> <code class="lua hljs">nmc = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"easynmc"</span></span>); nmc.<span class="hljs-built_in"><span class="hljs-built_in">debug</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; edcl_init(); nmc.init_core(<span class="hljs-string"><span class="hljs-string">"ipl-K1879-nmc-debug.abs"</span></span>); entry = nmc.upload(<span class="hljs-string"><span class="hljs-string">"myfile.abs"</span></span>); nmc.run(entry); <span class="hljs-comment"><span class="hljs-comment">-- Warning: nmc stdio, arguments and return code are NOT yet supported -- when running nmc prog via edcltool. Use linux libeasynmc. -- Expect these implemented in future updates. Sorry.</span></span></code> </pre><br>  Running the scripts themselves is very simple: <br><br><pre> <code class="bash hljs">edcltool -f script.edcl -i _</code> </pre><br>  If you forget the interface name, edcltool will use eth0 (on Windows, the 0th interface).  The edcltool ‚Äìl command that lists the available interfaces may be useful, especially on Windows, where it may not be very clear in the control panel which interface is registered under which system number. <br><br>  In addition to the above, the bundle includes other scripts for DSP, in fact, you can not load Linux to develop DSP code.  For writing your scripts in the archive with edcltool is a file SCRIPTING.TXT, which describes in detail the functions available from the edcl environment. <br><br><h1>  Firmware </h1><br>  Now let's talk about the main thing that is required from the processor developer after its release - support for the firmware and their delivery set.  Each firmware from the official site contains a complete environment, including the bootloader, the kernel, the edcl script for the firmware, the win version just in case, and the README. <br><br>  Detailed instructions on the current set of firmware is in each archive, but it makes no sense to quote it, since everything boils down to one thing: <br><br><ul><li>  close jumper boot </li><li>  press reset on board </li><li>  run edcltool ‚Äìf eupgrade.edcl </li><li>  drink tea 7-10 minutes </li><li>  remove jumper and press reset </li></ul><br><h2>  Environment </h2><br>  For full-fledged work with the board, we will need an environment for building software for the board's processor and its DSP - the module provides already assembled toolchains for both Linux and Windows.  Installing them is quite simple, for example, suppose that toolchains are stored in a familiar place called ~ / x-tools.  Next, you need to put the downloaded toolchain from the Module there and do not forget to register the next bin in your PATH: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> PATH=<span class="hljs-variable"><span class="hljs-variable">$PATH</span></span>:~/x-tools/arm-module-linux-gnueabi/bin</code> </pre><br><h2>  Distributions </h2><br>  The processor manufacturer adheres to minimalism when building its distributions and, by default, Debian and Raspbian come in minimal configuration with network and ssh support.  X11 at 324MHz is somehow slow, plus the bootloader cannot draw anything on the screen.  The main method of communication with the board is its serial console, for the sake of which the UART was installed.  By default, the network is distributed by distributions from the manufacturer with the address of the board 192.168.0.7, root login, password 12345678. <br><br>  Manufacturer repositories are set as follows in sources.list: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># RC Module's repository with MB77.07 packages deb http://www.module.ru/mb7707/ stable updates</span></span></code> </pre><br><h1>  System loading </h1><br>  Now a little about how the system is loaded with NAND.  The first executes the IPL bootloader and checks the position of the boot jumper and: <br><br><ul><li>  waiting at the magic address 0x00100000 (the starting address of the first SRAM memory bank IM0) from the edcl / jtag 32-bit address where to jump if the jumper is installed </li><li>  loads the bootloader from NAND into IM0, checks md5 and starts its execution if the jumper is not installed </li></ul><br>  The first boot loader is mboot.  This is a u-boot fork, a bit refactored.  It works from SRAM memory, which is surprisingly a lot on the processor: 4 banks, under the names IM [0-3].  Each bank is 256 kilobytes.  As we found out, the purpose of each of the following: <br><br><ul><li>  IM0 is the memory from which the bootloader works, after loading it is not used and is idle, it can be used for its own selfish purposes. </li><li>  IM1, IM3 - NeuroMatrix's memory, from where it is supposed to run NMC code, NMC has priority when accessing it. </li><li>  IM2 - used by h264 decoder.  If the decoder is not used - you can use it for your needs. </li></ul><br>  By the way, the old version of mboot can be found in google, it lies on Sergey Mironov‚Äôs github account, a link to reduce search time: <a href="https://github.com/ierton/mboot">github.com/ierton/mboot</a> , you can also find overlay for Gentoo there, but it hasn‚Äôt been updated for quite a long time so it is unlikely that he will come in handy. <br><br>  The last thing to say about the bootloader is that apart from the pmgr command, there are a couple of update commands, fwupgrade and eupgrade, designed for flashing tftp images that can be larger than the size available on the DDR memory card, this also happens.  Otherwise, this is the usual u-boot, to which many are accustomed.  A network is available from the bootloader, working with NAND, SPI Flash (which, unfortunately, was not installed on MB77.07) and a bit of usb, without the support of file systems. <br><br>  Let's go back to the memory, in the address space immediately after IM0 comes IM1, and then immediately IM3, it is worth remembering when writing low-level code that works with SRAM, as well as writing such code, it‚Äôs worth remembering that there‚Äôs really a lot of SRAM memory on some The good old AT91RM9200 on the crystal memory was only 4K.  For this reason, the bootloader works here directly in SRAM, without SPL.  This approach is very useful, since, unlike DDR, that ARM, that NeuroMatrix access time will be only a couple of cycles.  In other words - the code from there will work very, very quickly.  Moreover, if the code for the NMC will work only from IM1 / IM3, without addressing DDR in any way, it will be possible to turn some very tough realtime part on the NMC. <br><br>  Next, it is worth considering NAND in more detail, it is divided into sections, the first to go boot, env and dtb.  They are rigidly clogged and cannot be resized.  In the first one there is a loader, in the second one its surroundings, in the third one a compiled Device Tree Blob.  The rest is broken interactively by the pmgr boot command, or automatically by flashing the image from the edcl script.  The boot loader sends the specified sections to the kernel by writing standard mtdparts to cmdline. <br><br>  With NAND, it was generally expected to see something stunned.  From my experience with linux-sunxi and linux-rockchip, NAND was both in terrible condition there.  Allwinner made NAND its own block device with a partially closed FTL (flash translation layer), with its own wear-leveling and other algorithms.  Rockchip generally provides NAND only in the form of a closed module rknand.ko, the source code of which is not provided even under the company's NDA, as I was told in # linux-rockhip @ freenode.  Here, NAND is an ordinary standalone mtd device, on top of which the already standard UBIFS is used, which is good news. <br><br>  Now about the download itself.  I think many would be interested to look at the dmesg: <br><div class="spoiler">  <b class="spoiler_title">System loading</b> <div class="spoiler_text"><pre> <code class="bash hljs">MBOOT (K1879 and friends): Version mboot-00063-g9302e24-dirty (Built Thu Aug 21 17:10:13 MSK 2014) OTP info: boot_source 2 jtag_stop 0 words_len 1024 Maximum bank size: 0x10000000 bytes Detected 134217728 bytes of EM0 memory MEMORY: 40000000 -&gt; 48000000 Memory layout 0x00100010 early 0x001001C8 text 0x0011E9BC data 0x00127D40 signature 0x00127D44 bss_start 0x00135EB4 stack_start 0x00137FF8^ stack_ptr 0x00138000 malloc 0x0017F000 env mnand_read_id: flash id 0xD3 mnand_read_id: flash ext_id 0x95 mnand_read_id: CS0 NAND 1GiB 3,3V 8-bit size(1024) writesize(2048) oobsize(64) erasesize(131072) mnand_read_id: flash id 0x00 mnand_read_id: WARNING: Unknown flash ID. Using default (0xF1) mnand_read_id: flash ext_id 0x00 mnand: Chip configurations differ, ignoring CS1 greth: Setting GRETH base addr to 0x20034000 greth: Found GRETH at 0x20034000, irq 255 greth: Resetting GRETH greth: greth: <span class="hljs-string"><span class="hljs-string">'phyaddr'</span></span> not <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>, fall back to built-in table greth: greth: using preset PHY addr: 1f greth: Resetting the PHY greth: write_mii: 0x20034010 &lt; 0xF809F801 [p:31 a:0 d:0xF809] greth: write_mii: 0x20034010 &lt; 0x0000F801 [p:31 a:0 d:0x0000] greth: 10/100 GRETH Ethermac at [0x20034000] irq 255. Running 10 Mbps half duplex PHY info not available greth: greth_init greth: greth_init: enabling receiver ETH new device: name GRETH_10/100 greth: GRETH: New MAC address: 02:00:f7:00:27:0f USB thresholds: <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 0x20 out 0x7e Is there an EDCL emergency? Nope edcl: Ethernet debug disabled by environment MTD Partition: boot @ 0x00000000 size 0x00040000 MTD Partition: env @ 0x00040000 size 0x00020000 MTD Partition: dtb @ 0x00060000 size 0x00020000 MTD Partition: kernel @ 0x00080000 size 0x00400000 MTD Partition: rootfs @ 0x00480000 size 0x3FB80000 Hit any key (<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 2 sec) to skip <span class="hljs-built_in"><span class="hljs-built_in">autoload</span></span>... Running <span class="hljs-built_in"><span class="hljs-built_in">autoload</span></span> <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> <span class="hljs-string"><span class="hljs-string">'tftp;bootm;'</span></span> TFTP Using GRETH_10/100 device TFTP params: server 192.168.0.1 our_ip 192.168.0.7 TFTP params: filename <span class="hljs-string"><span class="hljs-string">'uImage-3'</span></span> load_address 0x40100000 TFTP Loading: T <span class="hljs-comment"><span class="hljs-comment">################################################################# ################################################################# ################################################################# ################################################################# ################################################################# ################################################################# ################################################################# ################################ TFTP done Linux preparing to boot the kernel: machid 0xcd1 Using Flatterned Device Tree boot method IMG moving image: type 2 from 0x40100040 to 0x40008000 HINT: To optimize boot time adjust loadaddr to: 0x40007fc0 Linux entry 0x40008000 USB thresholds: in 0x20 out 0x7e Uncompressing Linux... done, booting the kernel. [ 0.000000] Booting Linux on physical CPU 0x0 [ 0.000000] Linux version 3.10.28-shadow1-00032-gb8b1a50 (necromant@sylwer) (gcc version 4.8.1 (crosstool-NG 1.19.0) ) #141 Thu Aug 21 14:23:26 MSK 2014 [ 0.000000] CPU: ARMv6-compatible processor [410fb767] revision 7 (ARMv7), cr=00c5387d [ 0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT nonaliasing instruction cache [ 0.000000] Machine: Module MB77.07, model: Module MB77.07 [ 0.000000] bootconsole [earlycon0] enabled [ 0.000000] Memory policy: ECC disabled, Data cache writeback [ 0.000000] On node 0 totalpages: 24128 [ 0.000000] free_area_init_node: node 0, pgdat c050df84, node_mem_map c0596000 [ 0.000000] Normal zone: 288 pages used for memmap [ 0.000000] Normal zone: 0 pages reserved [ 0.000000] Normal zone: 24128 pages, LIFO batch:3 [ 0.000000] pcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768 [ 0.000000] pcpu-alloc: [0] 0 [ 0.000000] Built 1 zonelists in Zone order, mobility grouping on. Total pages: 23840 [ 0.000000] Kernel command line: debug console=ttyS0,38400n8 earlyprintk=serial ubi.mtd=4,2048 root=ubi0:rootfs rootfstype=ubifs mtdparts=mnand:0x40000@0x0(boot),0x20000@0x40000(env),0x20000@0x60000(dtb),0x400000@0x80000(kernel),0x3FB8000) [ 0.000000] PID hash table entries: 512 (order: -1, 2048 bytes) [ 0.000000] Dentry cache hash table entries: 16384 (order: 4, 65536 bytes) [ 0.000000] Inode-cache hash table entries: 8192 (order: 3, 32768 bytes) [ 0.000000] Memory: 94MB 0MB = 94MB total [ 0.000000] Memory: 89208k/89208k available, 41864k reserved, 0K highmem [ 0.000000] Virtual kernel memory layout: [ 0.000000] vector : 0xffff0000 - 0xffff1000 ( 4 kB) [ 0.000000] fixmap : 0xfff00000 - 0xfffe0000 ( 896 kB) [ 0.000000] vmalloc : 0xc8800000 - 0xff000000 ( 872 MB) [ 0.000000] lowmem : 0xc0000000 - 0xc8000000 ( 128 MB) [ 0.000000] modules : 0xbf000000 - 0xc0000000 ( 16 MB) [ 0.000000] .text : 0xc0008000 - 0xc04af9cc (4767 kB) [ 0.000000] .init : 0xc04b0000 - 0xc04d31d4 ( 141 kB) [ 0.000000] .data : 0xc04d4000 - 0xc0515d50 ( 264 kB) [ 0.000000] .bss : 0xc0515d50 - 0xc0595990 ( 512 kB) [ 0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1 [ 0.000000] NR_IRQS:128 [ 0.000000] regs = 0xf8000000, irq_start = 0 [ 0.000000] VIC @f8000000: id 0x00041192, vendor 0x41 [ 0.000000] regs = 0xf8010000, irq_start = 32 [ 0.000000] VIC @f8010000: id 0x00041192, vendor 0x41 [ 0.000000] UEMD: Firing up timer system [ 0.000000] Clocksource: rate 54000000 mult 19418074 shift 20 [ 0.000000] Clockevent: rate 54000000 mult 231928233 shift 32 [ 0.000000] sched_clock: 32 bits at 100 Hz, resolution 10000000ns, wraps every 4294967286ms [ 0.000000] Console: colour dummy device 80x30 [ 0.020000] Calibrating delay loop... 215.04 BogoMIPS (lpj=1075200) [ 0.100000] pid_max: default: 32768 minimum: 301 [ 0.110000] Mount-cache hash table entries: 512 [ 0.120000] CPU: Testing write buffer coherency: ok [ 0.130000] Setting up static identity map for 0xc03417b8 - 0xc03417f0 [ 0.150000] devtmpfs: initialized [ 0.160000] NET: Registered protocol family 16 [ 0.170000] DMA: preallocated 256 KiB pool for atomic coherent allocations [ 0.240000] OTP ROM is not flashed [ 0.250000] msvdhd: configuring memory [ 0.260000] hw-breakpoint: found 6 breakpoint and 1 watchpoint registers. [ 0.270000] hw-breakpoint: maximum watchpoint size is 4 bytes. [ 0.410000] bio: create slab &lt;bio-0&gt; at 0 [ 0.430000] SCSI subsystem initialized [ 0.440000] ssp-pl022 2002e000.ssp: ARM PL022 driver, device ID: 0x00041022 [ 0.450000] ssp-pl022 2002e000.ssp: BUSNO: 0 [ 0.460000] pl022: mapped registers from 0x2002e000 to f802e000 [ 0.470000] ssp-pl022 2002e000.ssp: registered master spi0 [ 0.480000] spi spi0.0: allocated memory for controller's runtime state [ 0.490000] ssp-pl022 2002e000.ssp: SSP Target Frequency is: 25000000, Effective Frequency is 13500000 [ 0.500000] ssp-pl022 2002e000.ssp: SSP cpsdvsr = 2, scr = 1 [ 0.510000] spi spi0.0: 4 &lt;= n &lt;=8 bits per word [ 0.520000] spi spi0.0: DMA mode NOT set in controller state [ 0.530000] spi spi0.0: setup mode 1, 8 bits/w, 25000000 Hz max --&gt; 0 [ 0.540000] ssp-pl022 2002e000.ssp: registered child spi0.0 [ 0.550000] ssp-pl022 2002e000.ssp: probe succeeded [ 0.570000] usbcore: registered new interface driver usbfs [ 0.580000] usbcore: registered new interface driver hub [ 0.590000] usbcore: registered new device driver usb [ 0.600000] media: Linux media interface: v0.10 [ 0.610000] Linux video capture interface: v2.00 [ 0.620000] Advanced Linux Sound Architecture Driver Initialized. [ 0.630000] Switching to clocksource uemd_timer1 [ 0.730000] NET: Registered protocol family 2 [ 0.740000] TCP established hash table entries: 1024 (order: 1, 8192 bytes) [ 0.750000] TCP bind hash table entries: 1024 (order: 0, 4096 bytes) [ 0.760000] TCP: Hash tables configured (established 1024 bind 1024) [ 0.780000] TCP: reno registered [ 0.790000] UDP hash table entries: 256 (order: 0, 4096 bytes) [ 0.800000] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes) [ 0.810000] NET: Registered protocol family 1 [ 0.820000] RPC: Registered named UNIX socket transport module. [ 0.830000] RPC: Registered udp transport module. [ 0.840000] RPC: Registered tcp transport module. [ 0.850000] RPC: Registered tcp NFSv4.1 backchannel transport module. [ 0.930000] squashfs: version 4.0 (2009/01/31) Phillip Lougher [ 0.950000] NFS: Registering the id_resolver key type [ 0.960000] Key type id_resolver registered [ 0.970000] Key type id_legacy registered [ 0.980000] msgmni has been set to 174 [ 1.000000] alg: No test for stdrng (krng) [ 1.010000] io scheduler noop registered (default) [ 1.020000] fj_gpio: Added 32 gpio lines at base -981095888 [ 1.040000] module_vdu 80173000.vdu: found VDU device at 80173000, id &lt;ebebab01&gt; [ 1.070000] Console: switching to colour frame buffer device 90x36 [ 1.090000] fb0: Module VDU frame buffer device [ 1.140000] Serial: 8250/16550 driver, 3 ports, IRQ sharing disabled [ 1.150000] 2002b000.uart: ttyS0 at MMIO 0x2002b000 (irq = 7) is a 8250 [ 1.160000] console [ttyS0] enabled, bootconsole disabled [ 1.160000] console [ttyS0] enabled, bootconsole disabled [ 1.170000] 20022000.uart: ttyS1 at MMIO 0x20022000 (irq = 9) is a 8250 [ 1.180000] 2002c000.uart: ttyS2 at MMIO 0x2002c000 (irq = 8) is a 8250 [ 1.200000] [drm] Initialized drm 1.1.0 20060810 [ 1.240000] loop: module loaded [ 1.250000] msvdhd 80180000.video_decoder: found device at 0x80180000, id 0x0025300b [ 1.300000] EasyNMC Unified DSP Framework. (c) RC Module 2014 [ 1.310000] easynmc-nmc3: imem at phys 0x140000 virt 0xc8900000 size 0x80000 bytes [ 1.320000] easynmc-nmc3: HP IRQ 14 LP IRQ 15 [ 1.330000] easynmc: registering core K1879-nmc (nmc3) with id 0 [ 1.350000] flash ext_id 0x95 [ 1.360000] mnand CS0 Samsung size(1024) writesize(2048) oobsize(64) erasesize(131072) [ 1.370000] mnand: Bad chip id or no chip at CS1 [ 1.380000] mnand: Detected 1073741824 bytes of NAND [ 1.390000] 5 cmdlinepart partitions found on MTD device mnand [ 1.400000] Creating 5 MTD partitions on "mnand": [ 1.410000] 0x000000000000-0x000000040000 : "boot" [ 1.430000] 0x000000040000-0x000000060000 : "env" [ 1.450000] 0x000000060000-0x000000080000 : "dtb" [ 1.470000] 0x000000080000-0x000000480000 : "kernel" [ 1.510000] 0x000000480000-0x000040000000 : "rootfs" [ 6.500000] libphy: greth-mdio: probed [ 9.590000] ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver [ 9.600000] uemd-ehci 10040000.ehci: UEMD EHCI [ 9.610000] uemd-ehci 10040000.ehci: new USB bus registered, assigned bus number 1 [ 9.630000] uemd-ehci 10040000.ehci: irq 35, io mem 0x10040000 [ 9.660000] uemd-ehci 10040000.ehci: USB 2.0 started, EHCI 1.00 [ 9.680000] hub 1-0:1.0: USB hub found [ 9.690000] hub 1-0:1.0: 2 ports detected [ 9.700000] ohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver [ 9.710000] usbcore: registered new interface driver usb-storage [ 9.720000] usbcore: registered new interface driver usbserial [ 9.730000] mousedev: PS/2 mouse device common for all mice [ 9.740000] i2c /dev entries driver [ 9.770000] module_hdmi: module_hdmi: Device ID: 0x9132 [ 9.780000] usbcore: registered new interface driver i2c-tiny-usb [ 9.800000] ledtrig-cpu: registered to indicate activity on CPUs [ 9.850000] usbcore: registered new interface driver usbhid [ 9.860000] usbhid: USB HID core driver [ 9.900000] TCP: cubic registered [ 9.910000] Key type dns_resolver registered [ 9.920000] VFP support v0.3: implementor 41 architecture 1 part 20 variant b rev 5 [ 9.950000] UBI: attaching mtd4 to ubi0 [ 10.020000] usb 1-1: new high-speed USB device number 2 using uemd-ehci [ 10.180000] hub 1-1:1.0: USB hub found [ 10.190000] hub 1-1:1.0: 4 ports detected [ 25.560000] UBI: scanning is finished [ 25.640000] UBI: attached mtd4 (name "rootfs", size 1019 MiB) to ubi0 [ 25.650000] UBI: PEB size: 131072 bytes (128 KiB), LEB size: 126976 bytes [ 25.660000] UBI: min./max. I/O unit sizes: 2048/2048, sub-page size 2048 [ 25.670000] UBI: VID header offset: 2048 (aligned 2048), data offset: 4096 [ 25.680000] UBI: good PEBs: 8141, bad PEBs: 15, corrupted PEBs: 0 [ 25.690000] UBI: user volume: 1, internal volumes: 1, max. volumes count: 128 [ 25.700000] UBI: max/mean erase counter: 4/1, WL threshold: 4096, image sequence number: 23379108 [ 25.710000] UBI: available PEBs: 0, total reserved PEBs: 8141, PEBs reserved for bad PEB handling: 145 [ 25.720000] mvdu: will allocate buffers [ 25.730000] mvdu: did allocate buffers cc000000 [ 25.740000] UBI: background thread "ubi_bgt0d" started, PID 620 [ 25.750000] ALSA device list: [ 25.760000] #0: Module MB7707 [ 25.860000] UBIFS: recovery needed [ 26.940000] UBIFS: recovery deferred [ 26.950000] UBIFS: mounted UBI device 0, volume 0, name "rootfs", R/O mode [ 26.960000] UBIFS: LEB size: 126976 bytes (124 KiB), min./max. I/O unit sizes: 2048 bytes/2048 bytes [ 26.970000] UBIFS: FS size: 1013395456 bytes (966 MiB, 7981 LEBs), journal size 9023488 bytes (8 MiB, 72 LEBs) [ 26.980000] UBIFS: reserved for root: 0 bytes (0 KiB) [ 26.990000] UBIFS: media format: w4/r0 (latest is w4/r0), UUID D7B60B07-E5DE-408F-886D-5EACF67535FC, small LPT model [ 27.010000] VFS: Mounted root (ubifs filesystem) readonly on device 0:11. [ 27.020000] devtmpfs: mounted [ 27.030000] Freeing unused kernel memory: 140K (c04b0000 - c04d3000) Mount failed for selinuxfs on /sys/fs/selinux: No such file or directory INIT: version 2.88 booting [info] Using makefile-style concurrent boot in runlevel S. [info] Setting the system clock. head: cannot open '/etc/adjtime' for reading: No such file or directory hwclock: Cannot access the Hardware Clock via any known method. hwclock: Use the --debug option to see the details of our search for an access method. [....] Unable to set System Clock to: Thu Jan 1 00:00:33 UTC 1970 ... (warning). [....] Activating swap...done. [ 33.700000] UBIFS: completing deferred recovery [ 33.830000] UBIFS: background thread "ubifs_bgt0_0" started, PID 870 [ 33.850000] UBIFS: deferred recovery completed [....] Activating lvm and md swap...done. [....] Checking file systems...fsck from util-linux 2.20.1 done. [....] Cleaning up temporary files... /tmp. ok [....] Mounting local filesystems...done. [....] Activating swapfile swap...done. [....] Cleaning up temporary files.... ok [....] Setting kernel variables ...done. [....] Configuring network interfaces...done. [....] Cleaning up temporary files.... ok INIT: Entering runlevel: 2 [info] Using makefile-style concurrent boot in runlevel 2. [....] Starting OpenBSD Secure Shell server: sshd. ok Debian GNU/Linux jessie/sid shadow ttyS0 shadow login: root Password: Last login: Thu Jan 1 00:16:23 UTC 1970 from 192.168.0.1 on pts/0 Linux shadow 3.10.28-shadow1-00032-gb8b1a50 #141 Thu Aug 21 14:23:26 MSK 2014 armv6l The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. root@shadow:~# uname -a Linux shadow 3.10.28-shadow1-00032-gb8b1a50 #141 Thu Aug 21 14:23:26 MSK 2014 armv6l GNU/Linux root@shadow:~#</span></span></code> </pre><br></div></div><br>  The first thing that attracts attention is the line "EasyNMC DSP Framework ¬© RC Module 2014".  Further, the log is written, how many NMC cores are found, and based on this, we can assume that the drivers and utilities are sharpened to the fact that there will be many NMC cores.  In the processor on this board, the NMC core is only one. <br><br>  The next many would be interested to know how NMC interacts with Linux.  The developers had the following information: to NMC from ARM there are three interruptions.  Non-maskable NMI, HP (High Priority) and LP (Low Priority).  In the opposite direction as HP and LP.  To start the DSP core, you need to submit an initial reset and pull the NMI.  This starts the IPL code NeuroMatrix.  After the first run, the NMC is spinning in this initial code that handles the NMI interrupt.  This start code is used to restart the application.  It's pretty simple. <br><br><h1>  Time for DSP </h1><br>      DSP,     ,     .       nmc-utils,      : <br><br><ul><li> nmctl </li><li> nmrun </li><li> libeasynmc (  ) </li></ul><br>        IPL  NeuroMatrix,   libeasynmc-nmc (  nmc   ).        ,   Free Software Foundation   . <br><br><h2> nmctl </h2><br>   .   nmctl.     , , ,  ,      . <br><div class="spoiler"> <b class="spoiler_title">  nmctl</b> <div class="spoiler_text"> root@shadow:~# nmctl --help <br> nmctl ‚Äî The EasyNMC control utility <br> ¬© 2014 RC Module | Andrew 'Necromant' Andrianov &lt;andrew@ncrmnt.org&gt; <br> This is free software; see the source for copying conditions. There is NO <br> warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. <br> License: LGPLv2 <br> Usage: ./nmctl [options] [actions] ‚Äî operate on core 0 (default) <br> ./nmctl --core=n [options] ‚Äî operate on selected core <br> ./nmctl --core=all [options] ‚Äî operate all cores <br> Valid options are: <br> --core=id ‚Äî Select a core to operate on (--core=all selects all cores) <br> --list ‚Äî list available nmc cores in this system and their state <br> --help ‚Äî Show this help <br> --force ‚Äî Disable internal seatbelts (DANGEROUS!) <br> --nostdio ‚Äî Do not auto-attach stdio <br> --debug ‚Äî print lots of debugging info (nmctl) <br> --debug-lib ‚Äî print lots of debugging info (libeasynmc) <br> Valid actions are: <br> --boot ‚Äî Load initcode and boot a core (all cores) <br> --reset-stats ‚Äî Reset driver statistics for core (all cores) <br> --load=file.abs ‚Äî Load abs file to core internal memory <br> --start=file.abs ‚Äî Load abs file to core internal memory and start it <br> --irq=[nmi,lp,hp] ‚Äî Send an interrupt to NMC <br> --kill ‚Äî Abort nmc program execution <br> --mon ‚Äî Monitor IRQs from NMC <br> --dump-ldr-regs ‚Äî Dump init code memory registers <br><br> ProTIP(tm): You can supply init code file to use via NMC_STARTUPCODE env var <br> When no env is set nmctl will search a set of predefined paths <br></div></div><br>    ,      NMC  : <br><div class="spoiler"> <b class="spoiler_title">nmctl --list</b> <div class="spoiler_text"> root@shadow:~# ./nmctl --list <br> 0. name: K1879-nmc type: nmc3 (cold) <br> IRQs Recv: HP: 0 LP: 0 <br> IRQs Sent: NMI: 0 HP: 0 LP: 0 <br></div></div><br><h2> nmrun </h2><br>   nmrun. <br><div class="spoiler"> <b class="spoiler_title">  nmrun</b> <div class="spoiler_text"> root@shadow:~# ./nmrun --help <br> nmrun ‚Äî The EasyNMC app runner wrapper <br> ¬© 2014 RC Module | Andrew 'Necromant' Andrianov &lt;andrew@ncrmnt.org&gt; <br> This is free software; see the source for copying conditions. There is NO <br> warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. <br> License: LGPLv2 <br> Usage: ./nmrun [options] myapp.abs [arguments] ‚Äî operate on core 0 (default) <br> Valid options are: <br> --help ‚Äî Show this help <br> --core=id ‚Äî Select a core to operate on (Default ‚Äî use first usused core) <br> --force ‚Äî Disable internal seatbelts (DANGEROUS!) <br> --nostdio ‚Äî Do not auto-attach stdio <br> --nosigint ‚Äî Do not catch SIGINT <br> --detach ‚Äî Run app in background (do not attach console) <br> Debugging options: <br> --debug ‚Äî Print lots of debugging info (nmctl) <br> --debug-lib ‚Äî Print lots of debugging info (libeasynmc) <br></div></div><br>    DSP .   .abs   NMC  ,   printf  NMC   stdout  ,  ,     stdin ‚Äì  NMC.    ,   .abs    ‚Äì    NMC    argv. Return  main()   NMC  nmrun,           return .      DSP    command line ,       DSP.     ,      . <br><br>    : <br><br><pre> <code class="bash hljs">root@shadow:~<span class="hljs-comment"><span class="hljs-comment"># nmrun /usr/share/examples/easynmc-0.1/arguments.abs hello world Application now started, hit CTRL+C to stop it Hello world! I am the NMC blinking ledz! I have been given 3 arguments Argument 0 is nmrun Argument 1 is hello Argument 2 is world App terminated with result 3, exiting root@shadow:~# echo $? 3</span></span></code> </pre><br>   NMC      /dev/nmc0io  /dev/nmc0mem, : <br><br><ul><li> /dev/nmc0mem ‚Äì  NMC,    SRAM ‚Äì IM1 + IM3,     .   cat /dev/nmc0mem &gt; dump.bin     DSP </li><li> /dev/nmc0io ‚Äì   ,     stdio,         poll/epoll </li></ul><br>     ‚Äì ioctl,    ,   libeasynmc. <br><br>      ,       LGPLv2.   ,         API.  ,    API   node.js? ,  DSP  epoll/select    stdio,    NMC (,   NMI  )    poll/epoll. ,      libevent, libuv  .. <br><br><h2>  Action </h2><br> ,   ,        -  NMC. ,  MB77.07   Raspbian,  . <br><br>   nmc-utils. <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> github.com/RC-MODULE/nmc-utils.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> nmc-utils</code> </pre><br>        github: <br><br><ul><li>     libeasynmc,    ,     .   nmctl        libeasynmc     </li><li>  libeasynmc-nmc   NMC  ,       NMC  </li><li>  doc/         ,  .          nm*  </li><li>  ipl/    ,    NMC </li><li>  examples/     </li></ul><br> -    : <br><br><pre> <code class="bash hljs">GNU_TARGET_NAME=arm-module-linux-gnueabihf make</code> </pre><br>      (nmctl, mnrun) : <br><br><pre> <code class="bash hljs">GNU_TARGET_NAME=arm-module-linux-gnueabihf make STATIC=y</code> </pre><br>     NFS    - ,        : <br><br><pre> <code class="bash hljs">DESTDIR=/srv/rootfs/mb7707/ make install</code> </pre><br> ,  ,  .deb based ,    deb-: <br><br><pre> <code class="bash hljs">GNU_TARGET_NAME=arm-module-linux-gnueabihf ARCH=armhf make deb</code> </pre><br>   deb      dpkg-deb    deb-,     : armhf  Raspbian, armel  Debian.    : <br><br><ul><li> nmc-utils-abs-0.1-armhf.deb ‚Äî  ,   /usr/share/examples/easynmc-0.1 </li><li> nmc-utils-bin-0.1-armhf.deb ‚Äî nmctl, nmrun    libeasynmc.so </li><li> nmc-utils-dev-0.1-armhf.deb ‚Äî  , pkg-config .pc    </li><li> nmc-utils-doc-0.1-armhf.deb ‚Äî README    doc/ </li><li> nmc-utils-ipl-0.1-armhf.deb ‚Äî IPL,   /usr/share/easynmc-0.1/ipl/ </li></ul><br>      ,              . <br><br>      NMC        ,       NMC   .    pipeline: <br><pre> <code class="bash hljs">arecord | nmrun ./echo.abs | aplay</code> </pre><br>  arecord           DSP,         ,       aplay.        USB  ,    .     libeasynmc  ,   nmrun. <br><br>   ,           . stdin/stdout        ,     .     ,       ARM    ,       NMC , ,      ,        ARM.  ,    ,       SRAM .  ,     ,       stdio      libeasynmc. <br><br>    C/++  NeuroMatrix    ,    ,       DSP ,   .    ,    : <br><br><ul><li>   . sizeof(char) == 1, sizeof(short) == 1.    NMC   32-   .     NMC        </li><li>      ASCII    uint32_t[]       ,    </li><li> nmrun            stdin  stdout ( ) </li><li> NMC   MMU    . ,             </li><li>   NMC  -  ,        Linux.     ,       - ,    </li><li>      ( , )     NMC. API    nc_int_soc.h    </li><li>      </li><li>   NeuroMatrix      ,               </li><li>   ,     ,       NMC,            .    /dev/nmc    .        Samsung  /dev/exynos-mem </li><li> NeuroMatrix   RISC    . ,    C,      RISC ,       .    DSP          .        ,  .       ,      </li></ul><br>     C.      NMC 8-,         DSP   32-  . <br>   ,     hello world    : <br><br><ul><li> Makefile ‚Äì   </li><li> colorizer.mk ‚Äì   Makefile,     .     Windows/Linux/Mac,    .  Windows   cecho </li><li> easyconf.asm ‚Äì     io/args.    ,     argc/argv      stdio. </li><li> K1879.cfg ‚Äì    (  ) </li><li> main.c ‚Äì     main() </li></ul><br>  Makefile.  -    . ,     ‚Äì  EASYNMC_DIR,    libeasynmc-nmc   NMC   libeasynmc.     -  ,       libs. <br><br><div class="spoiler"> <b class="spoiler_title">Makefile</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># # This is a basic Makefile template for a Neuromatrix DSP project # to be run on Module MB77.07. To compile it you need: # * Latest NMSDK installed with utilities in your $PATH # * NEURO environment variable pointing to NMSDK directory # * Host GCC (Since nmcpp doesn't support generating deps, # we use gcc for that) # # For verbose build run 'make VERBOSE=y' # -include colorizer.mk -include *.dep .SUFFIXES: OBJECTS := \ main.o \ easyconf.o TARGET=helloworld # Set this to libeasynmc-nmc dir. Relative or absolute. # Make sure you build it prior to building the actual project. EASYNMC_DIR = ../../libeasynmc-nmc CROSS_COMPILE = NMCPP_FLAGS = -DNEURO -OPT2 -inline -I$(EASYNMC_DIR)/include ASM_FLAGS = -soc -Sc -Stmp -Xq -I$(EASYNMC_DIR)/include C2ASM_FLAGS = -soc -q #BIG FAT WARNING: easynmc.lib MUST go BEFORE libc #BIG FAT WARNING: Otherwise argc/argv won't work LIBS = easynmc.lib libc05.lib BUILDER_FLAGS = -cK1879.cfg -m -heap=0 -heap1=0 -heap2=0 -heap3=0 -stack=20000 \ -full_names IDIRS = -I. -I"$(NEURO)/include" LIBDIR = -l"$(NEURO)/lib" -l"$(EASYNMC_DIR)" .DEFAULT_GOAL=all all: $(TARGET).abs %.asmx: %.cpp $(SILENT_DEP)gcc -E -MM $(&lt;) -o$(@).dep $(SILENT_NMCPP)$(CROSS_COMPILE)nmcpp -Tp $(NMCPP_FLAGS) $(&lt;) -O$(@) $(IDIRS) %.asmx: %.c $(SILENT_DEP)gcc -E -MM $(&lt;) -o$(@).dep $(SILENT_NMCPP)$(CROSS_COMPILE)nmcpp -Tc99 $(NMCPP_FLAGS) $(&lt;) -O$(@) $(IDIRS) %.o: %.asmx $(SILENT_ASM)$(CROSS_COMPILE)asm $(C2ASM_FLAGS) $(&lt;) -o$(@) %.o: %.asm $(SILENT_DEP)gcc -E -MM -xassembler-with-cpp $(&lt;) -o$(@).dep $(SILENT_ASM)$(CROSS_COMPILE)nmcc $(ASM_FLAGS) $(&lt;) -o$(@) $(TARGET).lib: $(OBJECTS) -$(SILENT_LIBRARIAN)$(CROSS_COMPILE)libr -c $(@) $(^) &gt; /dev/null $(TARGET).abs: $(OBJECTS) -$(SILENT_LINKER)$(CROSS_COMPILE)linker $(BUILDER_FLAGS) -o$(@) $(^) $(LIBS) $(LIBDIR) $(TARGET).dump: $(TARGET).abs -$(SILENT_NMDUMP)$(CROSS_COMPILE)nmdump -f $(^) &gt; $(@) run: $(TARGET).abs edcltool -f run_nmc_code.edcl -i eth1 clean: -$(SILENT_CLEAN)rm -f *.asmx; rm -f *.o; rm -f $(TARGET).abs $(TARGET).dump *.dep \ *.ac *.map *~ *.abs *.lib</span></span></code> </pre><br></div></div><br>       easynmc.lib ‚Äì       stdin/stdout, argc/argv   ,     ,        C. <br><br>     ‚Äì mb7707brd.cfg,   NeuroMatrix    ,   gcc LD .         .          : <br><div class="spoiler"> <b class="spoiler_title">.cfg</b> <div class="spoiler_text"><pre> <code class="bash hljs">MEMORY { //-------------- NMC --------------------------------------- LOADERMEM: at 0x00000000, len = 0x00000200; IM1: at 0x00000200, len = 0x0000fe00; IM3: at 0x00010000, len = 0x00010000; //------------- ARM ---------------------------------------- INTERNAL_MEMORY0: at 0x00040000, len = 0x00010000; // 256K-IM0 ARM (ARM:0x00100000 0x0013ffff 0x4000(256kB)) INTERNAL_MEMORY2: at 0x20040000, len = 0x00010000; // 256K-IM2 ARM (ARM:0x80100000 0x8013ffff 0x4000(256kB)) //------------- DDR ---------------------------------------- EXTERNAL_MEMORY0: at 0x10000000, len = 0x10000000; // 16MB-EM0-DDR (ARM:0x40000000 0x7fffffff) EXTERNAL_MEMORY1: at 0x30000000, len = 0x10000000; // 16MB-EM1-DDR (ARM:0xc0000000 0xffffffff) } SEGMENTS { code : <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> IM3; data : <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> IM1; } SECTIONS { .text : <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> code; .init : <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> code; .fini : <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> code; .data : <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> code; .bss : <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> code; .stack : <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> code; .heap : <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> code; .heap1 : <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> code; .heap2 : <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> code; .heap3 : <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> code; }</code> </pre><br></div></div><br>    memory map ‚Äì     <a href="http://www.module.ru/mb7707/doc/K1879-memory-map.pdf">http://www.module.ru/mb7707/doc/K1879-memory-map.pdf</a> <br><br>    make      ‚Äì hello.abs  hello.dump. abs  ‚Äì ELF       NMC.      IM1  IM3,    Linux  ,         Linux,        edcl  ,         . dump ‚Äì   ,     ,     NMC. <br><br>  ,       ‚Äì easyconf.asm.    ,      .  easyconf   stdio  ,     : <br><div class="spoiler"> <b class="spoiler_title">.asm</b> <div class="spoiler_text"><pre> <code class="bash hljs">import from <span class="hljs-string"><span class="hljs-string">"easynmc/easynmc.mlb"</span></span>; /* Declare 2 circular buffers <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> stdio */ const EASYNMC_IOBUFLEN = 128; EASYNMC_CBUF(<span class="hljs-string"><span class="hljs-string">".easynmc_stdin"</span></span>, _easynmc_stdin_hdr, _easynmc_stdin_data, EASYNMC_IOBUFLEN); EASYNMC_CBUF(<span class="hljs-string"><span class="hljs-string">".easynmc_stdout"</span></span>, _easynmc_stdout_hdr, _easynmc_stdout_data, EASYNMC_IOBUFLEN); /* Reserve 128 32-bit words <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> arguments */ EASYNMC_ARGS(128);</code> </pre><br></div></div><br>      abs      ,  ,   stdio  128 ,    .  nmrun       ,  128  ‚Äì nmrun  . <br><br> ,  main.c,    : <br><div class="spoiler"> <b class="spoiler_title">main.c</b> <div class="spoiler_text"><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;math.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;stdio.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;stdlib.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;string.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;easynmc/easynmc.h&gt; int main(int argc, char** argv) { printf(<span class="hljs-comment"><span class="hljs-comment">"Hello world from NeuroMatrix! I am the NMC printf'ing to you!\n"</span></span>); return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br></div></div><br>     hello world,        .   ,     - 200,       1600 .         2048.      NMC     (   float'),      ,    . <br><br>  -   : <br><div class="spoiler"> <b class="spoiler_title">main.c</b> <div class="spoiler_text"><pre> <code class="hljs vbscript">#include &lt;math.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.h&gt; #include &lt;easynmc/easynmc.h&gt; #define SIZE <span class="hljs-number"><span class="hljs-number">2048</span></span> static unsigned <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> delaybuf[SIZE]; static unsigned <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> pos; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> main() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { unsigned <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> = getc(); unsigned <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> out = <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> + (delaybuf[pos] &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (out &gt;<span class="hljs-number"><span class="hljs-number">255</span></span>) out = <span class="hljs-number"><span class="hljs-number">255</span></span>; delaybuf[pos++] = <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>; pos &amp;= (SIZE <span class="hljs-number"><span class="hljs-number">-1</span></span>); putc(out); } }</code> </pre><br></div></div><br> ,  abs  .        ALSA  ‚Äì HDMI.    /   USB  .     ALSA,    ,   -L  arecord  aplay.      : <br><br><pre> <code class="bash hljs">arecord -D default:CARD=Device | nmrun echo.abs | aplay -D default:CARD=Device</code> </pre><br>      ,          DSP . <br><br><h1>  Conclusion </h1><br> ,    .   . MB77.07   , , ,      ARM.     : <br><br> +    ,   ,    IPL  DSP .  github   .         Freescale   Qualcomm (Code Aurora).         GPL source-drop     rar tar'  ftp ,    ‚Äì  . , ,      .git . <br><br> + DSP ,     .   ,       ,       K&amp;R.  ,  NMC        realtime ‚Äì       . <br><br> + .  ,  ,      Allwinner (libnand), Rockchip (rk_fb, rknand), Mediatek ( )      .      .      ,        mainline.     . <br><br> +  .   3.10 LTS,       LTS.  ,  linux-sunxi   ‚Äì 3.4,   upstream   . Rockchip      3.10.x        rk3288.       rk3188  ‚Äì   MMC . HardKernel ODROID   3.8.y linux-stable + ubuntu merge,         mainline. <br><br> + .     NAND  , MB77.07       EDCL.  ,      ,  ,      ,    ..     .   NAND      RK3188       . <br><br> + deb-,   .      ,    . <br><br> +  ,     ,     r-pi. <br><br> ‚Äî .  , ,   (pun intended) <br><br> ‚Äî  RTC.      ,   .       ntp. <br><br> ‚Äî . , 324MHz ARM1176    .   ,   ARM,   NMC       ,    ,    .           OpenSource      ,     . <br><br> ‚Äî  .          ,   .        ¬´¬ª       qiwi. <br><br><h1>  Links </h1><br><ul><li>     ¬´¬ª  github: <a href="http://github.com/RC-MODULE">github.com/RC-MODULE</a> </li><li>    . : <a href="http://www.module.ru/catalog/micro/micro_pc/">www.module.ru/catalog/micro/micro_pc</a> </li><li>    . : <a href="http://www.module.ru/catalog/micro/mikroshema_dekodera_cifrovogo_televizionnogo_signala_sbis_k1879hb1ya/">www.module.ru/catalog/micro/mikroshema_dekodera_cifrovogo_televizionnogo_signala_sbis_k1879hb1ya</a> </li><li>         ¬´¬ª: <a href="http://www.module.ru/mb7707/">www.module.ru/mb7707</a> </li><li> Github ierton   mboot: <a href="https://github.com/ierton">github.com/ierton</a> </li><li>   barebox ( ): <a href="https://github.com/frantony/barebox/tree/next.mb7707.20140416">github.com/frantony/barebox/tree/next.mb7707.20140416</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/234541/">https://habr.com/ru/post/234541/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../234523/index.html">Invented a cheap way of electrolysis of water</a></li>
<li><a href="../234525/index.html">10 answers to questions on working with the customer</a></li>
<li><a href="../234529/index.html">Epson Projector Networking</a></li>
<li><a href="../234533/index.html">Ice Bucket Challenge from Wargaming Team</a></li>
<li><a href="../234535/index.html">Organizer for students: history and plans</a></li>
<li><a href="../234543/index.html">Russian Railways and nuclear specialists will create a Synergy operating system based on Linux OS</a></li>
<li><a href="../234545/index.html">Pixi-editor - simple drawing on pixi.js</a></li>
<li><a href="../234547/index.html">Digest: ReactOS or how we about ... code this summer</a></li>
<li><a href="../234549/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ121 (August 18 - 24, 2014)</a></li>
<li><a href="../234551/index.html">oDesk (Upwork). My experience in a year and a half</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>