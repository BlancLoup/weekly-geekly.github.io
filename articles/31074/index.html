<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why Perl sucks?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perhaps "sucks" is too gross a word, but by analogy with 
 "Why C sucks" 
 and 
 "Why C ++ sucks" 
 This is probably the appropriate heading. 

 First...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why Perl sucks?</h1><div class="post__text post__text-html js-mediator-article">  Perhaps "sucks" is too gross a word, but by analogy with <br>  <a href="http://www.everything2.com/index.pl%3Fnode%3DWhy%2520C%2520sucks">"Why C sucks"</a> <br>  and <br>  <a href="http://www.everything2.com/index.pl%3Fnode%3DWhy%2520C%252B%252B%2520sucks">"Why C ++ sucks"</a> <br>  This is probably the appropriate heading. <br><br>  First, let me say that Perl is currently my favorite language. <br>  programming.  I love his power, I love his elegance, and, <br>  Most of all, I love its expressiveness.  However, Perl, <br>  certainly not without flaws. <br><br>  The tone of this article is not intended to be negative.  I think it will be useful for us to know. <br>  about the weak points of used programming languages, especially popular ones, <br>  so that we are sure that these weaknesses will not fall into other languages. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So here is my list of problems in Perl: <br><a name="habracut"></a><br><ol><li><h4>  No inheritance of objects. </h4><br><br>  Perl inheritance is implemented through an <a href="http://habrahabr.ru/users/isa/" class="user_link">ISA</a> array (pronounced as <br>  "Is a", as in "this is a problem"), which allows you to call <br>  methods from one package through a bless link to another package. <br>  For example, if SomeClass contains SomeOtherClass in its global <br>  <a href="http://habrahabr.ru/users/isa/" class="user_link">ISA</a> array, then you can call any SomeOtherClass method directly <br>  via bless link in SomeClass. <br><br>  Unfortunately, there is no real way to inherit objects from <br>  another class in Perl, you can inherit only their methods.  Usually <br>  the workaround used is from the constructor of the class that wants <br>  inherit, the constructor of the class that is inherited is called to <br>  get the object, add your own fields to the hash, and then <br>  Ove-bless-thread object into your class: <br><br><pre> package SomeClass;
 use SomeOtherClass;<font></font>
<font></font>
 @ISA = 'SomeOtherClass';<font></font>
<font></font>
 sub new {
	 my $ class = shift;<font></font>
<font></font>
	 # create a new SomeOtherClass object:
	 my $ self = $ class-&gt; SUPER :: new;<font></font>
<font></font>
	 # mess with it:
	 $ self -&gt; {'_ something'} = 1;
	 $ self -&gt; {'_ something_else'} = 2;<font></font>
<font></font>
	 # now bless it into SomeClass:
	 bless ($ self, $ class);
	 return $ self;
 }<font></font>
<font></font>
 one;
</pre><br><br>  The problem is that it violates the laws of encapsulation and <br>  abstraction: you need to know the details of the implementation of the object, <br>  which you inherit, and then you climb right inside and work with <br>  his fields directly.  You can declare global variables in one <br>  package, write procedures to manipulate these variables, then <br>  inherit these procedures ... but it's all wrong. <br><br>  Given the countless number of object-oriented modules on <br>  CPAN is easy to forget that Perl was originally designed as a pure <br>  structured programming language.  Such moments make it absolutely clear: <br>  OO in Perl is really nothing more than bless links and a little bit <br>  syntactic sugar. <br><br><h4>  Reference count. </h4><br><br>  Perl uses a reference counter for the garbage collector, an easy way <br>  memory management which guarantees timely release <br>  unused resources.  Every scalar, array, hash, something else has <br>  built-in reference counter, which starts from one.  Everytime, <br>  when a reference is created to this variable, the reference count <br>  increases.  When the link is deleted, the counter decreases.  At some <br>  the moment when the last link is deleted and the counter reaches zero, <br>  the memory used for this variable is released. <br>  The problem occurs when you have two variables referencing each other <br>  friend, like the parent hash and child hash, which both contain <br>  links to each other.  Since nobody's counter can be reduced <br>  until zero until the last link is destroyed, one cannot be <br>  released until the second is released, and as a result they both remain <br>  hang in the memory.  This is what is known as "circular links". <br>  (see additional information: <br>  <a href="http://www.perl.com/pub/a/2002/08/07/proxyobject.html">http://www.perl.com/pub/a/2002/08/07/proxyobject.html</a> <br>  ). <br><br>  This means that it is unexpectedly easy to fix Perl memory leaks. <br>  Many budding Perl hackers did this by chance.  They thought: <br>  "Ha, it would be useful for this object to contain a reference to the parent, <br>  and vice versa, ‚Äùand, voila, a memory leak. <br><br>  Perl is definitely not alone in using the reference count: VB it <br>  uses, Python still uses it, as does PHP. <br><br>  Probably the greatest problem with link counters is the extra <br>  load on the authors of XS-extensions.  Counters make them produce <br>  calls to SvREFCNT_inc () and SvREFCNT_dec () throughout the code, controlling what <br>  each SvREFCNT_inc () has a corresponding SvREFCNT_dec ().  what <br>  leads me to the next annoyance ... <br><br><h4>  Not an intuitive API. </h4><br><br>  The Perl C API is pretty curious.  First, there is no visible <br>  naming convention.  Some procedure names are written in mixed <br>  case, for example newSViv (), while others contain <br>  underscore, for example newRV_noinc ().  Many variable names and <br>  members of the structures have short, sometimes disorienting names, for example <br>  ‚ÄúCur‚Äù for length and ‚Äúlen‚Äù for size. <br><br>  The API is also awash with macros, many of which are not documented. <br>  in perlapi or any other man pages, for example HvKEYS (). <br><br>  And, to make life even more interesting, for functions that <br>  documented, often not told whether they will change the counters <br>  references of their arguments. <br><br><h4>  Non-intuitive array / list behavior in scalar context. </h4><br><br>  I really don't like writing code with extra brackets like: <br><br><pre> my ($ first_field) = split (/ \ t /, $ tab_delimited_fields); 
</pre><br><br>  to interfere with the list or array returned from some function, <br>  behave wrong. <br><br>  In Perl, arrays return their size when used in scalar <br>  context and lists (eg "(70, 80, 90)" in the program text) <br>  return your last item.  First, what for all <br>  introduced the difference between lists and arrays?  Secondly, when and why <br>  I may need to use the list in scalar context <br>  to get his last item? <br><br>  I think it would be much better if both the arrays and the lists worked <br>  in the same way and returned the first element in a scalar context, instead of <br>  length or last item.  Then it would be possible to write code like: <br><br><pre> my $ email_address = $ input = ~ / (\ S + \ @ \ S +) /; 
</pre><br><br>  and he would work. <br><br>  How, you ask, then get the size of the array?  Well, why not with <br>  using the length () function?  A lot of newbies suggest that this <br>  should work that way. <br><br><h4>  Formats. </h4><br><br>  Perl formats were supposedly ‚ÄúReport‚Äù part of <br>  "Practical Extraction and Report Language" - of course "Perl" is <br>  no longer an acronym, and when, honestly, you can remember that you <br>  used formats?  In fact, can you even remember how <br>  use them correctly? <br><br>  This large, completely ignored part of Perl sucks in various ways. <br>  reasons. <br><br>  First, the format definition syntax is awkward (how about 20 <br>  or so the characters "&lt;" one-by-one?), global (you <br>  it will take a large, dotted block somewhere - more likely <br>  just under your code) and completely different from the usual <br>  syntax of Perl (increasing the likelihood that you will forget it, especially <br>  since you never used it). <br><br>  Secondly, an attempt to do something full using formats <br>  leads to verbosity, often requires the use of the select () function and <br>  messing with $ ^ before calling write (), forcing you to use three <br>  expressions to achieve what one would be enough for.  (Four <br>  expressions if you count and restore select ().) <br><br>  Thirdly, all that formats can do is usually able to do and <br>  printf () with sprintf () ohm  Even when the format syntax is really <br>  more flexible than printf (), using several printf () s is usually <br>  allows you to solve a problem, and this is a shorter and cleaner way. <br>  Perhaps the worst part of all this is that write () is used <br>  to output non-existent formats instead of executing I / O as read (), <br>  its English opposite: <br><blockquote>  ‚ÄúNote that write is * not * the opposite of 'read'.  Unfortunately. " <br></blockquote><br>  from (perldoc -f write). <br><br><h4>  No constants or macros. </h4><br><br>  In fact, it should be two separate items, there is no Perl <br>  simple way to declare variables as constants or to define <br>  macros as an alternative to scattering magic numbers throughout <br>  code. <br><br>  Yes, Perl has the ‚Äúconstant‚Äù pragma that should do both, and <br>  another, but this is really just a hack;  agile but elegant hack <br>  nevertheless hack: <br><br><pre> use constant PORT =&gt; 80;
</pre><br><br>  PORT can now be used as an rvalue in assignments, as if <br>  it would be something like a constant, and any attempt to assign something in <br>  It will cause a fatal error.  But, you see, PORT is actually <br>  not a constant, it's just a function with a prototype "without arguments." <br>  You can still block it by redefining the function, or through <br>  ‚ÄúUse sub‚Äù, or directly through the symbol table. <br>  More importantly, one of the goals of constants is efficiency;  to make <br>  life is easier for the compiler eliminating the need to assign <br>  something in the variable.  Here, instead of a small win, perl, <br>  interpreter, gets an indecent performance hit. <br><br><h4>  No type information. </h4><br><br>  In Perl, scalars can contain either a value or a reference to a value. <br>  Unfortunately, Perl does not provide operators to find out what type <br>  "Value" contains a scalar, the operator is only to determine the type <br>  links.  This results in, for example, determining whether <br>  scalar number suitable for arithmetic calculations unexpectedly <br>  complicated.  Yes, I understand that we, Perl hackers, used to think that numbers <br>  and the strings are interchangeable, but the problem still arises, and is ridiculous <br>  seek help from regular expressions to determine: <br><br><pre> print "Not a number!"  unless ($ thing = ~ / ^ \ d + $ /); 
</pre><br><br>  Of course, this expression does not work very well, since numbers can <br>  contain other characters like "+", "-" or "."  to indicate the sign <br>  fractional part or exponent. <br><br>  Even functions from ctype.h would be more useful than nothing. <br><br>  This is even more annoying because Perl seems to have <br>  A pretty good guess is what type of value is in SV (S-shny typedef <br>  describing the value of the scalar) based on the value of the "flags" field, <br>  and can easily convert one into the other if necessary. <br><br><h4>  Autovivification. </h4><br><br>  The key / value pairs autovivify hashes (comment of the translator: I do not know how <br>  in one word translate autovivify, meaning - ‚Äúare created <br>  automatically, on the fly ") in Perl.  This means that you can specify <br>  A new key of the type ‚Äúautovived‚Äù and it will arise: <br><br><pre> my% hash = (key1 =&gt; 'value1', key2 =&gt; 'value2');<font></font>
<font></font>
 $ hash {autovived} = 1;
</pre><br><br>  It also means that you can be sealed in the name of the key, and he too <br>  will occur without any warning.  It is not big <br>  problem when you use hashes as dictionaries, because your keys <br>  often come from somewhere else, but when you use a hash like <br>  structure or object, this leads to problems: <br><br><pre> $ self = {
	 name =&gt; undef,
         age =&gt; undef<font></font>
<font></font>
 ...<font></font>
<font></font>
 sub name {
 	 my $ self = shift;<font></font>
<font></font>
 	 $ self -&gt; {Name} = shift if @_;<font></font>
<font></font>
 	 return $ self -&gt; {name};
 }
</pre><br><br>  When I use hashes as objects, I always define and initialize <br>  each hash element inside the constructor is something at least ‚Äúundef‚Äù. <br>  That only I would not give for the keyword "static", which would hurt <br>  New elements are added to the hash after initialization: <br><br><pre> static my $ self = {
 	 name =&gt; undef,
 	 age =&gt; undef<font></font>
<font></font>
 ...<font></font>
<font></font>
 $ self -&gt; {Name} = shift;  # fatal error
</pre><br><br><br><br>  Other, weaker stimuli that come to mind include <br>  no equivalent for chop () before the line, impossibility to apply <br>  -x chained file tests (you need to write "-e $ filename &amp;&amp; -T <br>  $ filename &amp;&amp; -w $ filename "instead of" -e -T -w $ filename "or" -eTw $ filename "), <br>  strange convention to call binmode (), unstable signals, <br>  misleading names like local (), and the lack of the sizeof () function. <br><br>  This 16-year-old language has been steadily swelling for some time.  Many his <br>  aspects become non-intuitive, ineffective, or simply ugly. <br>  Implementation is difficult to change, and adding new features <br>  without breaking old it becomes extremely difficult. <br><br>  Perl 6 is an attempt by the Perl community to fix many of these problems. <br>  The real object support will be added, the link count will go away, <br>  sigils ($, @,%) will be more intuitive, and many new features <br>  will be added. <br><br>  This top-down rewriting is still far from complete, but I, <br>  along with many others, eagerly waiting for him.  Up to this point, I think, I <br>  I will continue to use Perl 5 to do most of my work. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/31074/">https://habr.com/ru/post/31074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310730/index.html">We work in the cloud based on Hyper-V, part 1: familiarity with the control panel</a></li>
<li><a href="../310732/index.html">Looking for errors in Mono: hundreds of them</a></li>
<li><a href="../310734/index.html">Lecture by Jimmy Wales, founder of Wikipedia, in Yandex</a></li>
<li><a href="../310736/index.html">BGP protocol in Quagga</a></li>
<li><a href="../310738/index.html">Logging Git revision in Java using Maven</a></li>
<li><a href="../310740/index.html">How to rewrite the SDK in TypeScript, upgrade the platform and do not regret anything</a></li>
<li><a href="../310742/index.html">Getting started in STM32CubeMX. Part 1</a></li>
<li><a href="../310744/index.html">Techniques in Elixir for Beginners: Trial and Error (Translation)</a></li>
<li><a href="../310748/index.html">Y Combinator: female programmers answer sensitive questions</a></li>
<li><a href="../31075/index.html">The origins of social networks - the theory of six links</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>