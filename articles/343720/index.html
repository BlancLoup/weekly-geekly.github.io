<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Strong typing in non-strict tests</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For more than 10 years, _big__ of my work is pure JavaScript. But sometimes you have to deal with a little more typed languages. And each time after s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Strong typing in non-strict tests</h1><div class="post__text post__text-html js-mediator-article">  For more than 10 years, _big__ of my work is pure JavaScript.  But sometimes you have to deal with a little more typed languages.  And each time after such a contact, there remains a strange feeling of ‚Äúincomprehensibility‚Äù, so why can't it be done in the same way in js. <br><br>  Especially because you can.  And today we will try to add a bit of typing to the most chaotic javascript area ‚Äî mock-and in unit tests. <br><br>  <a href="https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a">Others</a> say that <a href="https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a">mocking is a coding smell</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/vq/_p/6s/vq_p6s9qywewol3zwksvkkx5uvg.jpeg" width="700"><br><a name="habracut"></a><br><h3>  "Not" right moki </h3><br>  What are the main arguments against mocks?  In short: <br><blockquote>  Mocking is required when our decomposition strategy has failed. <br>  - as Eric Elliot spoke from the link above. <br></blockquote><br>  And if in Russian - <br><br><ol><li>  Your hands are crooked </li><li>  Use DI! </li><li>  Moki - they are not honest </li></ol><br>  There is only one problem - nodejs <u>is an</u> IoC framework, and the current version of the modular system is DI.  In principle, this is why popular libraries for mocks - proxyquire, mockery and others, generally work in principle. <br><br>  That is, technically - mocking is not a coding smell. <br><br>  But there is another side to the question - the libraries themselves "smell" so much that they infect the rest of the code a little.  Proxyquire is just crooked, mockery is too slow, mocks in the jest are especially beautiful.  I gave some review of this in the May <a href="https://habrahabr.ru/post/329740/">article about rewiremock</a> . <br><br><h3>  "Right moki" </h3><br>  The "correctness" of the moka, that of the dough, is very easy to determine - it must correctly fall, and must fall in the right place.  If the curve is mock, the mock should fall, not expect (someFunction) .to.be.called ().  After all, sometimes you can guess for so long why the method is not called when everything should be fine. <br><br>  Proxyquire had a good command ‚Äî callThrough, which allows you to use the ‚Äúreal‚Äù file as the base.  But it wasn‚Äôt recommended to use it, because it‚Äôs difficult to control which exports were locked up and which were not.  The fact that it is difficult to control the file process entirely - even did not pay attention. <br><br>  Jest has a very convenient automatic mocks __mock__ system that allows you to transparently provide mocks for real files ... in a slightly difficult to control form.  Or all or nothing.  Well, no one controls these moki. <br><br>  The main problem of mocks is very easy to describe with one <a href="https://github.com/palantir/tslint/issues/1182">wildest tslint example</a> , the no-export-by-default rule: <br><br><pre><code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> app.ts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ActionPopover <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./action"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> action.ts <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActionMenu</span></span></span><span class="hljs-class"> { ... } // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">oops</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">we</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">just</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">renamed</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">from</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">popover</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">menu</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">but</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">our</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">consumer</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">had</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">no</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">idea</span></span></span><span class="hljs-class">!</span></span></code> </pre> <br>  In the case of mocks, it will be even more fun - the tests will remain green, since they will work with the mock, which both worked and works, but the real file - the real file can do anything - <b>for tests it does not exist</b> . <br><br><img src="https://habrastorage.org/webt/lf/-e/ms/lf-ems31ikzubu-ir2fclzemaxs.jpeg"><br><br>  This is the main problem, and the main coding smell from mocks.  Well, they do not add confidence in the future. <br><br><h3>  Type safety </h3><br>  I myself encountered such a situation a couple of times, and for the third I decided to just close it technically.  More specifically, <a href="https://github.com/theKashey/rewiremock">rewiremock</a> v3 supports static typing of mocks for Flow / JS and shallow export checking for regular JS. <br><br><div class="spoiler">  <b class="spoiler_title">TypeScript vs Flow?</b> <div class="spoiler_text">  It took me about a week to write 10 lines of TS / Flow that would do all the work, while I spent 90% of the time on Flow, and another week to write 10 more lines, while 90% of the time I spent on TS.  Friendship won. <br></div></div><br>  So - let's start with an example. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = proxyquire(<span class="hljs-string"><span class="hljs-string">'./foo'</span></span>, { <span class="hljs-string"><span class="hljs-string">'fs'</span></span>: { fileWroteSync } });</code> </pre><br>  Proxyquire does exactly what it says - overloading dependencies.  But it does not check what it is actually doing there - that fs will be requested, that the function is intercepted, that the operation is valid. <br><br>  The mockery is still worse, as the mocks are advertised and their use is slightly distributed in space. <br><br><pre> <code class="hljs javascript">mockery.registerMock(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>, fsMock); mockery.enable(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mocked = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(...)</code> </pre><br>  The rewiremock is no better at all.  Given that the base API roughly repeats the mockery interface. <br><br><pre> <code class="hljs pgsql">//  API -    . /   rewiremock(<span class="hljs-string"><span class="hljs-string">'./b.js'</span></span>).withDefault(overrideDefault).<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>({ helper:<span class="hljs-number"><span class="hljs-number">2</span></span>});</code> </pre><br>  This is the usual way to create mock.  Whether on the drum it has a default export for the file, and whether there is an export with the name helper, which is also a number.  As described above, the difference between the mock and the real file that it should replace, and there is a problem, and there is a main source of ‚Äúsmell‚Äù. <br><br>  There are two solutions to this situation: <br><br>  The first uses dynamic imports, which for TS / Flow return tized results of promises, information from which can be used in the future only through static typing.  The underlying code is only required to support the ability to set the name of the import mock.  Hi asynchrony :( <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  API -  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>,      name-resolution rewiremock(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./b.js'</span></span>)) .withDefault(overrideDefault) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>     .with({ helper: <span class="hljs-number"><span class="hljs-number">42</span></span> }) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> c     </code> </pre><br>  Moreover, all the necessary information is available for IntelliSence or another autocompiler.  Pure TypeScript in action (well, or Flow).  This not only makes moki ‚Äúbetter‚Äù, but also improves ‚Äúuser experience‚Äù when writing mocks.  IDE will help and prompt. <br><br>  The second option is simpler, but it can only work in runtime, including without any problems it can be ported to almost any other libraries, since the code there is just three lines. <br><br><pre> <code class="hljs delphi">rewiremock(<span class="hljs-string"><span class="hljs-string">'./b.js'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>(<span class="hljs-comment"><span class="hljs-comment">{ helper: 42 }</span></span>) .toMatchOrigin(); <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br>  In this case, before the operation of replacing a real file with a mock (somewhere deep in require), the actual file will actually be loaded, and its exports will be compared with this mock for the type names match. <br><br>  The main advantage of this option - it works synchronously - as a result, it is convenient to work with it, while the use of dynamic imports requires the use of asynchronous APIs, which is not very convenient :( <br><br>  PS: there is a problem with the ‚Äútyping‚Äù of the good old synchronous require, so you should not even try. <br><br>  I will be honest - the only thing that improves the typing of mocks is the time of writing mocks (if there is typing) and finding bugs (in both cases).  I was just wondering if it was possible to do this in principle, and I basically did it. <br><br><h3>  Jest </h3><br>  Jest is so good that he even has his own system of mocks, sealed in his sandbox for file execution (which is one of the main features). <br><br>  This system is two-faced, and consists of automok __mocks__, and manual mokov.  The first are beautiful, the second are terrible.  Well, in the guts of Jest everything is bad and not entirely logical - it replaces with itself the modular system node.js, babel and everything else, filling the whole space and destroying all the "standard" infrastructure.  For many, this is a fact - proxyquire with Jest does not work.  Nothing works with jest. <br><br>  But I would like to have typed mocks, and there is a solution. <br><br>  This is a small cli <a href="https://github.com/theKashey/jest-typed-mock">jest-typed-mock</a> utility that scans directories for mocks and checks for compliance with real files. <br><br>  Operating modes 4: <br><br><ul><li>  jest-typed-mock flow, for Flow </li><li>  jest-typed-mock typescript, for TS </li><li>  jest-typed-mock javascript, for "strict" checking of JS (compares the number of arguments in functions) </li><li>  jest-typed-mock exports, to check only names and types. </li></ul><br>  I ran it on a couple of examples, and was able to find various ‚Äúaccumulated‚Äù discrepancies in the mocks and reliats, which were on the way to ‚Äúgreen tests, but no prod‚Äù, but (thank God) have not yet reached.  Honestly, I would like to see such a system built into Jest by default. <br><br>  For reference: rewiremock is arrogant enough to move the jest and mock yourself.  For this you need to perform only two actions - <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span>    . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-string"><span class="hljs-string">""</span></span> rewiremock  jest-runtime rewiremock.overrideEntryPoint(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">2.</span></span>  <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>  <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> = rewiremock.requireActual;</code> </pre><br>  This completely kills the jest for those files that will be requested - no sandboxing, jest as a local variable, of course, no jest mocks, especially __mocks__ ... But the order for this came. <br><br><h3>  Conclusion </h3><br>  For almost a year now I've been trying to cut rewiremock.  It began as a replacement for proxyquire, continued as a replacement for mockery, and stomped somewhere further. <br><br>  Every time I drink coffee in the shade of eucalyptus, I think - what new feature to add, and why.  Then I understand that this is not possible ... and I want my own in a couple of months. <br>  So it was with the isolation modes, with the work under the webpack, jest, and now with the typing.  Well, if you want% username% something from a small library for mocks, you just know who to contact. <br><br>  <a href="https://github.com/theKashey/rewiremock">More on the link</a> . </div><p>Source: <a href="https://habr.com/ru/post/343720/">https://habr.com/ru/post/343720/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343706/index.html">I created an application that makes learning algorithms and data structures much more interesting.</a></li>
<li><a href="../343708/index.html">Code Textures</a></li>
<li><a href="../343714/index.html">Local automation of builds (Crashlytics + Slack + FastLane)</a></li>
<li><a href="../343716/index.html">Experiment to promote the game on Google Play. Part 1</a></li>
<li><a href="../343718/index.html">Sound settings in Ubuntu</a></li>
<li><a href="../343724/index.html">PLATO: the history of the world's first e-learning system</a></li>
<li><a href="../343726/index.html">Hinton's capsule nets</a></li>
<li><a href="../343728/index.html">Unity game, open source</a></li>
<li><a href="../343730/index.html">We write DSL in Koltin</a></li>
<li><a href="../343732/index.html">Corporate "stuffing" for small networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>