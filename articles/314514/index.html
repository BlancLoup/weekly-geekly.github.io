<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sudoku: so how many of them? Part 2/2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi Habr! This is the second part of the translation of an article about counting different sudoku. 



 In this part, we dive into the theory of group...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sudoku: so how many of them? Part 2/2</h1><div class="post__text post__text-html js-mediator-article">  Hi Habr!  This is the second part of the translation of an <a href="http://www.math.cornell.edu/~mec/Summer2009/Mahmood/Intro.html">article</a> about counting different sudoku. <br><br><img src="https://habrastorage.org/files/d90/893/9b0/d908939b06b7475a870dbb6759ef7a53.jpg"><br><br>  In this part, we dive into the theory of groups, starting from the very basics, but affecting only what we need to answer the question: how many really sudoku are there - without any repetitions in the form of turns, reflections, etc.  Those who are quite familiar with the theory of groups will probably find little of interesting things here.  For the rest, it is very useful to read.  Just in case: I do not consider myself a specialist in group theory; when translating an article, I myself essentially studied it almost from scratch.  That is, there may well be shoals - write me about them in PM.  On the other hand, for the majority of definitions, I climbed to Wikipedia, and I confirmed all the numerical results with my own written program.  So, in theory, the number of jambs should tend to zero.  But you never know. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As usual, my comments are in italics or hidden under spoilers.  Under the spoilers you can find the most interesting - pieces of code that verify all the numbers obtained in the narration. <br><a name="habracut"></a><br><h1>  Symmetry </h1><br>  So, in the previous part of the article, we considered that the number of different sudoku grids is equal to N = 6670903752021072936960‚âà6.671 √ó 10 <sup>21</sup> .  But quite often we can get one grid of sudoku from another, using simple transformations.  For example, if we have a correctly filled sudoku grid, then turning it 90 ¬∞, we get another grid that is different from the original, but still remains correct.  In fact, we can consider these grids as identical, because as a result of the transformation, our grid is still one of the Sudoku solutions.  Similarly, if we replace all 3-ki in the grid with 4-ki, and all 4-ki with 3-ki, then we will get another correct grid.  We could also take some kind of sudoku grid, swap the fifth and sixth lines, and in the end, still get the correct grid.  When we make such transformations, we retain such a grid property as its correctness ( <i>In the previous part of the article we did something very similar, but only with a part of the grid ‚Äî the first strip. Now we are playing with the entire 9 √ó 9 table. An important difference that now we consider only such transformations that can be applied to any grid (with preservation of correctness), i.e. the previously described operation of swapping the corners of a rectangle inside the grid by sudoku does not fit, since it applies to some grids, and to some - no.</i> ). <br><br>  Operations of this type are called symmetries.  The symmetry of an object is an operation that preserves some property of the object.  It is interesting to note that if we apply one symmetry to an object, and immediately after that another symmetry, then the final transformation will be another symmetry.  The operation that leaves the object unchanged is also one of the symmetries.  For any symmetry, there is another symmetry that rolls back all changes made first.  And finally, if we need to apply one symmetry, then the second, and then the third, then we can group either the first and second symmetry together, or the second and third - and eventually get the same transformation. <br><br>  All these properties tell us that a set of symmetries of an object form a <b>group</b> .  A group is a set of G, together with the operation ¬∑, for which the following properties are true: <br><br><ol><li>  If g and h are elements of G, then g ¬∑ h is also an element of G (Mathematicians say that G is <b>closed</b> with respect to the operation ¬∑). </li><li>  If g, h and k are elements of G, then g ¬∑ (h ¬∑ k) = (g ¬∑ h) ¬∑ k (This property of the group operation is called <b>associativity</b> ). </li><li>  There is an element e in G such that g ¬∑ e = e ¬∑ g = g for all g from G (This element e is called the <b>neutral element</b> of G, since it leaves each element of G unchanged with respect to the operation). </li><li>  For each element g of G, there is another element h of G such that g ¬∑ h = h ¬∑ g = e, where e is a neutral element (the element h is called the <b>inverse of</b> g, denoted as g <sup>-1</sup> ). </li></ol><br>  Note that in the definitions above, we use the multiplicative notation for the group operation.  We could use additive notation, in which case the inverse of g would be denoted by -g.  ( <i>Multiplicative notation is like our operation ‚Äúmultiply‚Äù, and additive operation ‚Äúadd‚Äù</i> ). <br><br>  <b>Exercise</b> Check that the set of integers Z with the operation of addition is a group.  For this you need to check the implementation of all four properties. <br><br>  The group of integers has another very interesting property: the order of addition of numbers is completely unimportant.  That is, for any two integers a and b, a + b is the same as b + a.  When a group operation satisfies this property (this property is called <b>commutativity</b> ), the group is called <b>abelian</b> . <br><br>  Let's look at an example of a symmetry group, for example, a square with numbered corners: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0a7/27e/8fe/0a727e8fec7047c290bd259f1836e04c.JPG"></div><br>  For this geometric object, there are eight transformations that preserve the fact that it is a square.  In other words, the square has eight symmetries.  All of them are different turns and reflections along with the operation of composition of transformations: <br><br><ol><li>  Rotate 0 degrees (neutral). </li><li>  Rotate clockwise 90 degrees. </li><li>  Rotate clockwise 180 degrees. </li><li>  Rotate clockwise 270 degrees. </li><li>  The reflection about the horizontal axis (which passes through the center of the square). </li><li>  The reflection about the vertical axis (which also passes through the center of the square). </li><li>  The reflection is diagonal from the lower left to the upper right. </li><li>  The reflection on the diagonal from the upper left corner to the lower right. </li></ol><br>  <b>Exercise</b> Select any two transformations from the list above and check that the application of one of them and then the other is also a transformation that is already in this list.  Can you find two such transformations that lead to different results depending on the order of their application? <br><br>  In contrast to the group of integers, the symmetry group of a square is non-Abelian. <br><br>  The symmetry group G of the correct Sudoku grid contains all the transformations of the square and, in addition, some other transformations such as moving blocks, rows and columns, as well as the composition of all these transformations.  Thus, the symmetry group is <b>generated by</b> the following types of transformations: <br><br><ol><li>  Reassign nine digits. </li><li>  Shuffle three stacks. </li><li>  Permutation of three lanes. </li><li>  Permutation of three columns in a stack. </li><li>  Permutations of three lines in a strip. </li><li>  Any reflections and turns (from the symmetry list of the square). </li></ol><br>  Important note: this is not a list of all G elements!  This is a list of different symmetries of the group, and combining them in all different ways we can get all the other elements of the group.  Both the specific transformations of all the types described above, and any composition that differs from these specific ‚Äúbasic‚Äù transformations, are all included in the symmetry group G. For example, one of the elements of G is the exchange of the first and second lines, a specific type conversion (5 ).  Let X be the set of all valid sudoku grids.  We know that this is a set of a finite number of elements.  From the fact that each element of G is some correspondence that maps one of the grids to another ( <i>in fact, it maps all grids to some others, that is, it is a certain permutation of all elements from X</i> ), we can conclude that G also includes only a finite number of symmetry elements. <br><br>  We call two Sudoku grids <b>equivalent</b> , if we can convert one of them to another using one or more symmetries from G. If none of the symmetry sequences converts one of the grids to another, then we call such grids <b>essentially different</b> . <br><br>  This relation is indeed an equivalence relation in the formal mathematical sense, since it satisfies the following three properties: <br><br><ol><li>  The grid A is equivalent to itself (this property is called <b>reflexivity</b> ). </li><li>  If A is equivalent to B, then B is equivalent to A (this property is called <b>symmetry</b> ). </li><li>  If A is equivalent to B, and B is equivalent to C, then A is equivalent to C (this property is called <b>transitivity</b> ). </li></ol><br>  For any valid Sudoku grid A, we can consider all grids equivalent to A as really exactly the same as A. If we group together all the grids that are equivalent to each other, then we actually divide the set of all grids into disjoint parts : in fact, X will be divided into such subsets that no two of them have common elements.  Mathematicians call such subsets <b>equivalence classes</b> .  Any two elements from the same equivalence class are equivalent to each other by some symmetry from G. The set of equivalence classes is denoted as X / G and is read as "X modulo G" or "X mod G" ( <i>also called mathematics X / G <b>factor set</b></i> ). <br><br>  In the previous part of the article we wondered about the number of different sudoku nets without any symmetries, and it would be interesting to find the number of significantly different nets.  According to the reasoning above, the total number of equivalence classes, or the number of elements in X / G, is nothing more than the number of essentially different sudoku nets.  Next, we look at the method that Ed Russell and Frazer Jarvis used in early 2006 to calculate this number. <br><br>  At first, we‚Äôll draw a little attention to the operation of reassigning numbers and consider only those symmetries that do something with the grid ‚Äî with the entire grid, with blocks or with individual cells.  Consider these symmetries - their types (2) - (6) in the list above - and their compositions.  These symmetries give us the group H, in which Russell and Jarvis counted exactly 3359232 different symmetries.  In other words, H is a group that is generated by symmetries of types (2) - (6). <br><br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text">  In any incomprehensible situation, start <s>to make meth</s> to write code.  And now it is completely incomprehensible where the number 3359232 comes from. Therefore, let's start writing code to check that the group H has exactly 3359232 different symmetries. <br><br>  We begin with a structure that describes the symmetry of a group.  By <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%259A%25D1%258D%25D0%25BB%25D0%25B8_(%25D1%2582%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B8%25D1%258F_%25D0%25B3%25D1%2580%25D1%2583%25D0%25BF%25D0%25BF)">the Cayley theorem</a> , every finite group is isomorphic to a subgroup of some symmetric group.  If we speak in an understandable language, then any finite group can be represented as some system of permutations.  So for the group H, we use a permutation of length 81 ‚Äî one permutation element per sudoku cell. <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYMMETRY</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> m[<span class="hljs-number"><span class="hljs-number">9</span></span>][<span class="hljs-number"><span class="hljs-number">9</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; j++) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%2d "</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)m[i][j] ); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"\n"</span></span> ); } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"\n"</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> SYMMETRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">E</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SYMMETRY re; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> t = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; j++) re.m[i][j] = t++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> SYMMETRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap_stacks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j )</span></span></span><span class="hljs-function"> </span></span>{ SYMMETRY re = SYMMETRY::E(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=<span class="hljs-number"><span class="hljs-number">0</span></span>; b&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; b++) swap( re.m[a][i*<span class="hljs-number"><span class="hljs-number">3</span></span>+b], re.m[a][j*<span class="hljs-number"><span class="hljs-number">3</span></span>+b] ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> SYMMETRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap_columns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j )</span></span></span><span class="hljs-function"> </span></span>{ SYMMETRY re = SYMMETRY::E(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; a++) swap( re.m[a][s*<span class="hljs-number"><span class="hljs-number">3</span></span>+i], re.m[a][s*<span class="hljs-number"><span class="hljs-number">3</span></span>+j] ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> SYMMETRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SYMMETRY re = SYMMETRY::E(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=<span class="hljs-number"><span class="hljs-number">0</span></span>; b&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>; b++) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tmp = re.m[a][b]; re.m[a][b] = re.m[<span class="hljs-number"><span class="hljs-number">8</span></span>-b][a]; re.m[<span class="hljs-number"><span class="hljs-number">8</span></span>-b][a] = re.m[<span class="hljs-number"><span class="hljs-number">8</span></span>-a][<span class="hljs-number"><span class="hljs-number">8</span></span>-b]; re.m[<span class="hljs-number"><span class="hljs-number">8</span></span>-a][<span class="hljs-number"><span class="hljs-number">8</span></span>-b] = re.m[b][<span class="hljs-number"><span class="hljs-number">8</span></span>-a]; re.m[b][<span class="hljs-number"><span class="hljs-number">8</span></span>-a] = tmp; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re; } <span class="hljs-function"><span class="hljs-function">SYMMETRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( SYMMETRY g )</span></span></span><span class="hljs-function"> </span></span>{ SYMMETRY re; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; j++) re.m[i][j] = gm[m[i][j]/<span class="hljs-number"><span class="hljs-number">9</span></span>][m[i][j]%<span class="hljs-number"><span class="hljs-number">9</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re; } <span class="hljs-function"><span class="hljs-function">SYMMETRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SYMMETRY re; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; j++) re.m[m[i][j]/<span class="hljs-number"><span class="hljs-number">9</span></span>][m[i][j]%<span class="hljs-number"><span class="hljs-number">9</span></span>] = i*<span class="hljs-number"><span class="hljs-number">9</span></span>+j; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re; } };</code> </pre> <br>  Those.  in each position of the 9x9 table, we store the position number to which the element will move at the current position after applying symmetry.  Please note - symmetry knows nothing about what numbers are in sudoku now.  The above code spells out the creation of symmetries such as the neutral element, rearrangement of the stacks, rearrangement of the columns, and rotation of 90 degrees. <br><br>  <b>Exercise</b> Show that all symmetries of types (2) - (6) can be obtained by composition of those symmetries that we implemented in the code. <br><br>  Next in the code is the implementation of the composition or multiplication of symmetries.  At the end, we added the implementation of finding the inverse element (we do not need it yet, but we will need it later). <br><br>  Now, based on the existing symmetries, let's generate the whole group H: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>== (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SYMMETRY &amp; A, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SYMMETRY &amp; B) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=<span class="hljs-number"><span class="hljs-number">0</span></span>; b&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; b++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Am[a][b] != Bm[a][b]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SYMMETRY &amp; A, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SYMMETRY &amp; B) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=<span class="hljs-number"><span class="hljs-number">0</span></span>; b&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; b++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Am[a][b] != Bm[a][b]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Am[a][b] &lt; Bm[a][b]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt; SYMMETRY &gt; Set; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt; SYMMETRY &gt; Q; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs_push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( SYMMETRY G )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Set.find( G ) != Set.end()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; Set.insert( G ); Q.push( G ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Set.size()%<span class="hljs-number"><span class="hljs-number">100000</span></span>==<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"G.sz=%d\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Set.size() ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_all_elements_of_group</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Q.push( SYMMETRY::E() ); Set.insert( SYMMETRY::E() ); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Q.size()&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) { SYMMETRY G = Q.front(); Q.pop(); bfs_push( G.multiply( SYMMETRY::rotate() ) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; j++) { bfs_push( G.multiply( SYMMETRY::swap_stacks(i,j) ) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; k++) bfs_push( G.multiply( SYMMETRY::swap_columns(k,i,j) ) ); } } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"sudoku group size %d\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Set.size() ); <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"sudoku group size %d\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Set.size() ); }</code> </pre> <br>  Operators for comparing and determining which element is less needed purely so that set can correctly perform its operations (otherwise it will even refuse to compile).  Next, we implement a bypass of the symmetry group H using a wide bypass (one could also use a depth to depth, but it eats up too much memory on the recursion stack). <br><br>  In more detail: first we put neutral symmetry in the Q queue.  After that, we extract and process symmetries until they are in the queue.  The processing goes like this: we just extract the symmetry from the queue and multiply it by all the ‚Äúbasic‚Äù symmetries available to us.  The Set set plays the role of an array of flags and stores all the symmetries obtained by the current moment.  If after multiplication we get a new symmetry - such that it is not in Set - then we memorize it in the Set and put Q at the end of the queue. If, after multiplication, we find that the new symmetry is already in Set, we don‚Äôt We do, as we have already processed this symmetry earlier. <br><br>  As a result, at the end of the execution of the algorithm, all symmetries from the group H will accumulate in Set (in general, strictly speaking, all permutations of a certain group P, which <i>is isomorphic to the</i> group H, will accumulate there, but we will not zadvodstvu about this now).  Running the code confirms that there are exactly 3359232 elements in H. <br><br>  By the way, in the SYMMETRY structure for each permutation element, it is not for nothing that the unsigned char type is chosen.  In the calculation process, we store millions of objects in the Set and in the Q queue (which weigh 80 bytes each), so you need to be prepared for the program to consume about 450MB of memory during the calculation and about 300MB at the end when the queue becomes empty . <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text">  By the way, how can one imagine in the form of a permutation group a group that is generated by symmetries of all types (1) - (6)?  Permutations - they are stupid, they do not look at what numbers are written in sudoku.  They stupidly mix elements without delving into the essence. <br><br>  In order to take into account symmetries of type (1), we transform the sudoku grid slightly.  Namely: translate it into 3D (no matter how strange it sounds).  Imagine a 9x9x9 cube, onto which our sudoku grid is projected from above.  That is, for each cell of Sudoku there is a column of 9 single cubes in a large cube.  Well, now for each column we do the following: if the number i is in the corresponding cell of the sudoku, then we paint the i-th (counting from above) cube of the column black and all the other cubes - white.  As a result, we get a cube, each of 729 cubes of which is painted in one of two colors (black or white), with exactly one cube painted in black in each column.  Well, now all symmetries of types (2) - (6) are mixing of the columns of a cube, while symmetries of type (1) are mixing of <i>horizontal layers of</i> this cube. <br><br>  Voila - we expressed the symmetry group generated by symmetries of types (1) - (6) through the subgroup of the permutation group of order 729. <br></div></div><br>  Now our notion of equivalence of two grids can be defined as follows: grid A is <b>equivalent to</b> grid B if we can convert grid A by symmetries from group H to some grid C, such that numbers can be reassigned to C so that we finally get grid B. say that A is <b>H-equivalent to</b> C, and C is equivalent to B by remap.  Note that H-equivalence and reassignment equivalence are really equivalence relations (they both satisfy three properties from the list above). <br><br>  We consider that H <b>acts</b> on the set of correct sudoku grids X as follows: each element h from H is a map of X to X, that is, translates each of the grids from X to another (possibly the same) grid from X. In other words, h gives us a way to transform any valid mesh into another valid mesh, and each element h from H gives us such a mapping. <br><br>  For any symmetry from h from H, we can consider those grids that h <b>leaves in place</b> up to reassignment.  We mean all such grids A, that if we apply the symmetry h to A and get the mesh B, then B will be equivalent to A by reassignment ( <i>Such objects are also called <b>fixed points</b> with respect to h</i> ).  So we take into account the fact that we did not take into account the reassignment in the symmetry group H. <br><br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text">  For a better understanding of the essence of the expression ‚Äúup to reassignment‚Äù, one should accept the fact that sometimes the set of objects on which we apply all symmetries can, after applying symmetries, be additionally <i>self-twisting</i> to some normal form. <br><br>  Another way to improve understanding is: instead of the set X of all sudoku grids, it is better to consider the set Y ‚Äî the set of all equivalence classes of X with respect to equivalence by redirection.  Those.  each element in Y is a set of 9!  sudoku grids that go into each other when reassigning numbers (in general, I imagine each of these elements as a transparent sphere in which 9 separate sudoku paper grids float).  And when we apply to element y from Y element h from H - we transform at once all the grids of sudoku inside y in accordance with the symmetry h.  And as a result we get a new set of grids y '(and the sets, as you know, are compared without taking into account the order of the elements in them). <br><br>  It should be noted that <i>self-twisting</i> does not contradict the Cayley theorem ‚Äî it is for the group itself, and not for the set that we are trying to act on with this group.  We can act as a group on very different sets: even on sets of one or two elements, even on another group.  The main thing is that the set on which we act satisfies a small <a href="http://neerc.ifmo.ru/wiki/index.php%3Ftitle%3D%25D0%2594%25D0%25B5%25D0%25B9%25D1%2581%25D1%2582%25D0%25B2%25D0%25B8%25D0%25B5_%25D0%25B3%25D1%2580%25D1%2583%25D0%25BF%25D0%25BF%25D1%258B_%25D0%25BD%25D0%25B0_%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5">list of properties</a> . <br></div></div><br>  In order to calculate the number of essentially different sudoku grids, we need a theorem from group theory, called Burnside Lemma. <br><br>  <b>Burnside Lemma</b> Let G be a finite group that acts on a set X. For each element g of G, let X <sup>g</sup> denote the set of elements of X that g leaves in place.  Then the number of elements in the set X / G is | X / G | = 1 / | G | Œ£ <sub>g in G</sub> | X <sup>g</sup> |, where | - |  - the number of elements in the set. <br><br>  <b>Exercise</b> Imagine a square in which each of the edges is painted in one of two colors - blue or green.  Two colorings are essentially the same if there is such a symmetry of the square, which translates the first of these colorings into the second.  Use the Burnside Lemma to determine the number of essentially different colorings.  (For each of the eight symmetries of a square, count the number of colorings that do not change when applying symmetry. To better understand what is happening, you can draw all 2 <sup>4</sup> = 16 colorings of a square and imagine how they transform into each other. Lemma Burnside tells us that to get an answer you need to add the number of unchanging colorings for each symmetry and then divide the resulting sum by the number of symmetries.) <br><br>  In our case, the finite group H acts on the set X of all possible sudoku correct grids.  For each h from H, we want to find the number of such elements of X that they do not change when h is used up to the reassignment of numbers.  Then we need to add all these numbers and divide them by the number of elements in H. And in the end we get the answer - the number of significantly different sudoku days.  That is, we need to take the arithmetic average of the number of unchanged grids (up to reassignment) for all elements of H. <br><br>  For example, the following correct sudoku grid is a fixed point to rotate 90 ¬∞ clockwise (again, up to reassign numbers): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/447/749/6a0/4477496a028e41d9988738b9fbc9d522.JPG"></div><br>  <b>Exercise</b> Determine how to reassign numbers in a rotated grid above so that it coincides with the original one.  Write down all the numbers from 1 to 9 and see where the number 1 goes, then where the number 2 goes, then 3, and so on.  In general, make sure that the grid is a fixed point for a given rotation symmetry. <br><br>  In order to apply the Burnside Lemma (to calculate the number of essentially different grids), we could calculate the number of fixed points for each of 3359232 elements of H. But it turns out that some of these 3359232 transformations have the same number of immutable grids!  Russell and Jarvis used the special GAP program and determined that all H elements fall into 275 symmetry classes such that any two symmetries from one class have the same number of unchanging grids, and each symmetry from H has as many fixed points as the element one of these classes ( <i>familiar process, isn't it?</i> ).  Therefore, we just need to count the number of fixed points for only one symmetry from each of the 275 classes.  Knowing how many symmetries are in each of the classes, we can then find out the mean, as in the Burnside Lemma. <br><br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text">  From the paragraph above it is not at all clear how Russell and Jarvis received 275 classes.  And in general, what kind of classes in general?  But, if you delve into their original article (and not the scientific publication that you are translating), you can understand that we are talking about <b>contingency classes</b> . <br><br>  Information from <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BB%25D0%25B0%25D1%2581%25D1%2581_%25D1%2581%25D0%25BE%25D0%25BF%25D1%2580%25D1%258F%25D0%25B6%25D1%2591%25D0%25BD%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">Wikipedia</a> : the elements g <sub>1</sub> and g <sub>2 of the</sub> group G are called <b>conjugate</b> if there exists an element h from G for which h ¬∑ g <sub>1</sub> ¬∑ h <sup>-1</sup> = g <sub>2</sub> . <br><br>  <b>Exercise</b> Show that the relation is a equivalence relation (three properties from the definition of equivalence in the text above will help you). <br><br>  <b>Exercise</b> Show that if two elements g <sub>1</sub> and g <sub>2 of a</sub> group G are conjugate (with h ¬∑ g <sub>1</sub> ¬∑ h <sup>-1</sup> = g <sub>2</sub> for some h from H), then they have the same number of fixed points.  Note: show that for any fixed point x from X for g <sub>1 the</sub> object y = x ¬∑ h <sup>-1</sup> (also from X) is the fixed point for g <sub>2</sub> , and for each fixed point y from X for g <sub>2 the</sub> object x = y ¬∑ H of X is a fixed point for g <sub>1</sub> .  As a result, a <b>bijection is</b> constructed between the fixed points of both symmetries. <br><br>  So, with the theory figured out, now we need to deal with the practice.  And with her not so simple.  We, in fact, need for each element g from H to iterate over another element h from H, and then build a connection between g and h ¬∑ g ¬∑ h <sup>-1</sup> .  And at the end, look at the connected components.  Only here the order of group H is under 3 million and we will build ties to the forehead until the end of the centuries (well, at least until the end of this year for sure).  Therefore, we will act smarter. <br><br>  To begin with, let us take not all symmetries as h, but only a very small subset of them.  For example, the set of symmetries, from which we in one of the past spoilers generate the group H. As a result, all elements of H will be grouped into partial equivalence classes, they will become much smaller, and we will already join them in an amicable way. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt; SYMMETRY, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt; classes; SYMMETRY cur_g; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt; SYMMETRY &gt; Set2; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dfs1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( SYMMETRY g, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; SYMMETRY &gt; &amp; ops )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Set2.find( g ) != Set2.end()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; Set2.insert( g ); classes[cur_g]++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)ops.size(); i++) dfs1( ops[i].multiply(g).multiply( ops[i].inverse() ), ops ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_conjugacy_classes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; SYMMETRY &gt; ops; ops.push_back( SYMMETRY::rotate() ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; j++) { ops.push_back( SYMMETRY::swap_stacks(i,j) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; k++) ops.push_back( SYMMETRY::swap_columns(k,i,j) ); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ind = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt; SYMMETRY &gt;::iterator it = Set.begin(); it != Set.end(); it++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Set2.find( *it ) == Set2.end()) { cur_g = *it; dfs1( *it, ops ); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"M[%d]=%d\n"</span></span>, ind, classes[cur_g] ); <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"M[%d]=%d\n"</span></span>, ind, classes[cur_g] ); ind++; } Set2.clear(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"number of classes after step 1 %d\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)classes.size() ); <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"number of classes after step 1 %d\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)classes.size() ); }</code> </pre><br>  The associative array classes stores a representative of each class, as well as the number of elements in each class.  Set2 is an array of flags, like Set, which we use for the needs of the current iteration, and at the very end we clear it.  The classes are generated as follows: first, all the ‚Äúbase‚Äù symmetries are added to the ops array, after which, starting from the element that has not yet been considered, we recursively walk along the conjugacy graph using depth traversal and construct the conjugacy class.  After that we take the next not yet considered symmetry, find the class for it, and so on. <br><br>  This code (together with the previous one) already consumes at the peak of the order of 900MB of memory, of which about 256MB falls on the recursion stack (it could again be implemented as a width walk, but in this case the depth walk was not so voracious from memory so bearable).  And ... as a result of execution we get the desired 275 classes. <br><br>  Luck?  We have not yet processed our result.  Actually, we don‚Äôt need to process anything and we really got the right partition into classes (this could have been proved before launch).  The arguments about the correctness of our algorithm are approximately as follows: <br><br>  Consider some conjugate symmetries g <sub>1</sub> and g <sub>2</sub> , then there is a symmetry h, for which g <sub>2</sub> = h ¬∑ g <sub>1</sub> ¬∑ h <sup>-1</sup> .  At the same time, h can be represented as a composition of symmetries, say h = a ¬∑ b ¬∑ c, where a, b, c are some kind of ‚Äúbase‚Äù symmetry.  Then g <sub>2</sub> = h ¬∑ g <sub>1</sub> ¬∑ h <sup>-1</sup> = (a ¬∑ b ¬∑ c) ¬∑ g <sub>1</sub> ¬∑ (a ¬∑ b ¬∑ c) <sup>-1</sup> = a ¬∑ b ¬∑ c ¬∑ g <sub>1</sub> ¬∑ c <sup>-1</sup> ¬∑ b <sup>-1</sup> ¬∑ A <sup>-1</sup> = (a ¬∑ (b ¬∑ (c ¬∑ g <sub>1</sub> ¬∑ c <sup>-1</sup> ) ¬∑ b <sup>-1</sup> ) ¬∑ a <sup>-1</sup> ).  That is, from the symmetry of g <sub>1,</sub> in our algorithm we would go to the symmetry p <sub>1</sub> = c ¬∑ g <sub>1</sub> ¬∑ c <sup>-1</sup> , from p <sub>1</sub> to p <sub>2</sub> = b ¬∑ g <sub>1</sub> ¬∑ b <sup>-1</sup> , and from p <sub>2</sub> - to a ¬∑ g <sub>1</sub> ¬∑ a <sup>-1</sup> = g <sub>2</sub> .  From here we get that the algorithm is correct. <br></div></div><br>  <b>Exercise</b> Consider the reflection of the grid sudoku relative to the horizontal axis passing through the center of the grid, I mean through the fifth row.  Note that the fifth line after the reflection will remain unchanged.  Can you reassign numbers in the reflected grid so that it coincides with the original?  And what about fixed points to reflect on the horizontal axis?  Is there a grid in general that does not change?  (Recall the fact that we are now considering some kind of correct Sudoku grid, and in the fifth line are all nine numbers). <br><br>  As can be seen from the exercise above, in H there are such symmetries for which there are no fixed points.  Russell and Jarvis were surprised to find that in fact, as many as 248 classes out of 275 contain symmetries for which there is not a single fixed point.  So they need only calculate the number of unchanged grids for symmetries from the 27 remaining classes and find how many symmetries are contained in each of these classes before using the Burnside Lemma.  They wrote a program that makes the last calculations and as a result got the number 5472730538‚âà5.473 √ó 10 <sup>9</sup> - the number of significantly different sudoku grids. <br><br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text">  We are approaching the most complex part of the code - the code for counting the number of fixed points for each of the 275 symmetry classes.  And the fact that we consider objects equivalent in reassignment of numbers ‚Äî a sort of generalized completely filled sudoku grid ‚Äî introduces much complexity.  There are 6670903752021072936960/9 in total!  = 18383222420692992 (this is the same number of all sudoku grids divided by the number of variants that are obtained by reassigning numbers).  Denote the set of such generalized grids as Y. <br><br>  So, the subtask for the solution: we need for some symmetry g to count the number of fixed points from the set Y (there are 275 such subtasks in total).  What happens to each fixed point when g is applied?  The numbers in the sudoku grid are swapped according to some permutation, then the numbers are reassigned, and after that we get the original grid.  And the fact that the numbers are somehow reassigned makes it difficult to build a search.  However, note that if some grid is a fixed point for any one reassignment, then for all other reassignments it is not a fixed point.  Therefore, we can sort out all possible reassignments, find the number of fixed points for each of them, and then add everything up. <br><br>  It turns out now we need to solve this sub-task: given the symmetry g and the reassignment of numbers h, we need to calculate for them the number of fixed points from Y. Now consider some fixed point y from Y, and specifically - the number p in some cell (i, j).  When applying g to y, (i, j) goes to a certain position (i ', j') = (i, j) ¬∑ g, in which, according to the reassignment h, will be the number q = p ¬∑ h.  Since the final grid is equal to the initial grid, the number q must be in the initial grid at position (i ', j'). <br><br>  That is, the following happens.  g is some permutation of the Sudoku grid cells, which can be divided into cycles. ,     90 ,       (1,1)-&gt;(1,9)-&gt;(9,9)-&gt;(9,1)-&gt;(1,1)  4. h ‚Äî    ,     9 .       . ,     2-&gt;3-&gt;2  2.  ,      (1,1)  2,   (1,9)    3,  (9,9) ‚Äî 2,   (9,1) ‚Äî 3.   . ,               ‚Äî                ,        ¬´ ¬ª. <br><br>      ,                  (   ,      ). <br><br>    ,           ,      (    -   ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MEGAGRID</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> T[<span class="hljs-number"><span class="hljs-number">9</span></span>][<span class="hljs-number"><span class="hljs-number">9</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> R[<span class="hljs-number"><span class="hljs-number">9</span></span>][<span class="hljs-number"><span class="hljs-number">10</span></span>], C[<span class="hljs-number"><span class="hljs-number">9</span></span>][<span class="hljs-number"><span class="hljs-number">10</span></span>], B[<span class="hljs-number"><span class="hljs-number">9</span></span>][<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> S[<span class="hljs-number"><span class="hljs-number">9</span></span>][<span class="hljs-number"><span class="hljs-number">9</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// symmetry permutation int s_cycle[9][9]; // length of cycle for every element int M[10]; // mapping permutation int m_cycle[10]; // length of cycle for every element void init( SYMMETRY sym ) { for (int a=0; a&lt;9; a++) for (int b=0; b&lt;9; b++) S[a][b] = sym.m[a][b]; memset( s_cycle, 0, sizeof( s_cycle ) ); for (int a=0; a&lt;9; a++) for (int b=0; b&lt;9; b++) if (s_cycle[a][b] == 0) { int cycle_len = 0; int i = a, j = b; while(1) { int tmp = S[i][j]; i = tmp/9; j = tmp%9; cycle_len++; if (i==a &amp;&amp; j==b) break; } while(1) { s_cycle[i][j] = cycle_len; int tmp = S[i][j]; i = tmp/9; j = tmp%9; if (i==a &amp;&amp; j==b) break; } } for (int a=1; a&lt;10; a++) M[a] = a; for (int a=1; a&lt;10; a++) m_cycle[a] = 1; } bool next_perm() { if (!next_permutation( M+1, M+10 )) return false; memset( m_cycle, 0, sizeof( m_cycle ) ); for (int a=1; a&lt;=9; a++) if (m_cycle[a] == 0) { int cycle_len = 0; int i = a; while(1) { i = M[i]; cycle_len++; if (i==a) break; } while(1) { m_cycle[i] = cycle_len; i = M[i]; if (i==a) break; } } return true; } void clear() { memset( T, 0, sizeof( T ) ); memset( R, 0, sizeof( R ) ); memset( C, 0, sizeof( C ) ); memset( B, 0, sizeof( B ) ); } } G;</span></span></code> </pre><br>  init()     ,      .  , init()     .  next_perm()              .  clear()      T,    . <br><br>       ,       : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MEGAGRID</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* old code */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_num</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n0=num, x0=x, y0=y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s_cycle[x][y] % m_cycle[num] != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> L = s_cycle[x][y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;L; a++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (R[x][num] || C[y][num] || B[(x/<span class="hljs-number"><span class="hljs-number">3</span></span>)*<span class="hljs-number"><span class="hljs-number">3</span></span>+(y/<span class="hljs-number"><span class="hljs-number">3</span></span>)][num]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) unset_num( n0, x0, y0, a ); <span class="hljs-comment"><span class="hljs-comment">// undo changes return false; } T[x][y] = num; R[x][num] = true; C[y][num] = true; B[(x/3)*3+(y/3)][num] = true; int tmp = S[x][y]; x = tmp/9; y = tmp%9; num = M[num]; } return true; } void unset_num( int num, int x, int y, int sz=0 ) { int L = s_cycle[x][y]; if (sz!=0) L = sz; for (int a=0; a&lt;L; a++) { T[x][y] = 0; R[x][num] = false; C[y][num] = false; B[(x/3)*3+(y/3)][num] = false; int tmp = S[x][y]; x = tmp/9; y = tmp%9; num = M[num]; } } } G;</span></span></code> </pre><br>  set_num()       ,    ‚Äî   . unset_num()   . ,  set_num()     unset_num()   ,  ¬´¬ª ,       ,      . <br><br>  ,        , ,  , ,            .  What kind?        .   ,    -  : ,   .     -     ,    ,       ‚Äî   ,   ,    .       :      -     <i></i>           ,           . <br><br>            : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MEGAGRID</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* old code */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_immovable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; a++) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> flag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=<span class="hljs-number"><span class="hljs-number">0</span></span>; b&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; b++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (S[a][b] != a*<span class="hljs-number"><span class="hljs-number">9</span></span>+b) flag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flag) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=<span class="hljs-number"><span class="hljs-number">0</span></span>; b&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; b++) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> flag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; a++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (S[a][b] != a*<span class="hljs-number"><span class="hljs-number">9</span></span>+b) flag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flag) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=<span class="hljs-number"><span class="hljs-number">0</span></span>; b&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; b++) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> flag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; j++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (S[a*<span class="hljs-number"><span class="hljs-number">3</span></span>+i][b*<span class="hljs-number"><span class="hljs-number">3</span></span>+j] != (a*<span class="hljs-number"><span class="hljs-number">3</span></span>+i)*<span class="hljs-number"><span class="hljs-number">9</span></span>+b*<span class="hljs-number"><span class="hljs-number">3</span></span>+j) flag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flag) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">has_bad_cycle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=<span class="hljs-number"><span class="hljs-number">0</span></span>; b&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; b++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = S[a][b]/<span class="hljs-number"><span class="hljs-number">9</span></span>, y = S[a][b]%<span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(x==a &amp;&amp; y==b)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==a || y==b || (x/<span class="hljs-number"><span class="hljs-number">3</span></span>)*<span class="hljs-number"><span class="hljs-number">3</span></span>+(y/<span class="hljs-number"><span class="hljs-number">3</span></span>)==(a/<span class="hljs-number"><span class="hljs-number">3</span></span>)*<span class="hljs-number"><span class="hljs-number">3</span></span>+(b/<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } G;</code> </pre><br>      ,  is_immovable() ,     ¬´¬ª    ,  has_bad_cycle() ‚Äî         . <br><br>  , ,  : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sudoku_count; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dfs2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// find next empty cell { y++; if (y==9) { y=0; x++; } if (x==9) // no empty cell { sudoku_count++; return; } if (GT[x][y]==0) break; } for (int a=1; a&lt;=9; a++) if (G.set_num( a, x, y )) { dfs2( x, y ); G.unset_num( a, x, y ); } } long long process_class( SYMMETRY s ) { if (s==SYMMETRY::E()) return 18383222420692992L; long long re = 0; G.init( s ); bool imm = G.is_immovable(); bool hbc = G.has_bad_cycle(); if (imm &amp;&amp; hbc) return re; if (hbc) G.next_perm(); int ind = 0; do { ind++; if (ind%1000==0) fprintf( stderr, "." ); G.clear(); bool flag = true; for (int a=1; a&lt;=9; a++) { int x = (a-1)/3, y = (a-1)%3; if (GT[x][y]&gt;0 &amp;&amp; GT[x][y]!=a) { flag = false; break; } if (GT[x][y]==0 &amp;&amp; !G.set_num( a, x, y )) { flag = false; break; } } if (flag) { sudoku_count = 0; dfs2( 0, 0 ); re += sudoku_count; } if (imm) break; } while (G.next_perm()); return re; } void process_all_classes() { long long answer = 0; long long sum = 0; int i = 0; for (map&lt; SYMMETRY, int &gt;::iterator it = classes.begin(); it != classes.end(); it++) { fprintf( stderr, "class %3d", i ); long long tmp = process_class( it-&gt;first ); printf( "class %3d %6d x %17lld\n", i, it-&gt;second, tmp ); fprintf( stderr, " %6d x %17lld\n", it-&gt;second, tmp ); i++; answer += tmp * it-&gt;second; sum += it-&gt;second; } printf( "total sum %lld\n", answer ); printf( "essentialy different sudoku grids %lld\n", answer/sum ); }</span></span></code> </pre><br>   process_class()      .         ‚Äî           .         .   ‚Äî    .  -  .            .         dfs2(). <br><br>               50 .   (    ,       0),   : <br><br><pre> <code class="cpp hljs">number of classes <span class="hljs-number"><span class="hljs-number">275</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> 0 1 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 18383222420692992 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 78 972 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 449445888 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 114 2916 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 155492352 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 120 1296 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 30258432 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 132 69984 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 13056 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 135 16 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 107495424 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 137 96 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 21233664 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 140 192 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 4204224 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 189 3888 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 27648 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 195 10368 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 1854 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 199 144 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 14837760 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 201 864 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 2085120 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 204 1728 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 294912 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 220 7776 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 13824 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 222 15552 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 1728 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 229 288 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 5184 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 231 1728 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 2592 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 234 3456 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 1296 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 244 93312 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 288 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 247 64 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 2508084 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 257 1152 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 6342480 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 262 15552 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 3456 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 264 31104 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 6480 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 265 2304 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 648 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 269 5184 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 323928 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 271 20736 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 288 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> 274 20736 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> 162 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">total</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sum</span></span></span><span class="hljs-class"> 18384171550626816 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">essentialy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">different</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sudoku</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">grids</span></span></span><span class="hljs-class"> 5472730538 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">total</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">time</span></span></span><span class="hljs-class"> 3013 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sec</span></span></span></span></code> </pre><br>    ,     .           <a href="http://www.afjarvis.staff.shef.ac.uk/sudoku/sudgroup.html"></a> . <br><br>       <a href="http://www.everfall.com/paste/id.php%3F4qjafkn6886t"></a> . <br></div></div><br><h1>  4x4 </h1><br>      2,     4√ó4,  ,    ,     ( <i>    </i> ). <br><br>  ,      4√ó4,   ‚Äî       9√ó9 ‚Äî       .        4!,      4!     . <br><br>    , 1  2       ,  3  4 ‚Äî    .    4! ,       3  4,        .   ,         ,   3  4   ,               .     ,  3      ,  4 ‚Äî  . <br><br>   1  3     , 2  4           .        ,          4!√ó2√ó2 .      ,  ,        ‚Äî     ,     ,  2      ,  4 ‚Äî  .        : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b05/bee/c66/b05beec668dd4c299596ecc9574a4090.JPG"></div><br>      2,      3,   (3,3)     1,  4. <br><br> <b></b> ,     (3,3)  1,          . <br><br>  ,   (3,3)    4.   ,  ,        ‚Äî        4,    (4,4)       1, 2  3.      ,      4!√ó2√ó2,    ,   3       (4,4) ( <i>     </i> ).  ,     4√ó4  4!√ó2√ó2√ó3=288. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e68/46c/876/e6846c87653d4160bcd083386d5175fc.JPG"></div><br> <b></b>      .   ,          ‚Äî       (  ?)     2  3. <br><br>  ,   ,          4√ó4. <br><br><h1>  Some more interesting facts. </h1><br> <b> </b>      .   ,     ,      ,         ,   .     3  17 ,  ,   .          3 ‚Äî  ( <i>  ,  <a href="http://www.sudokuwiki.org/Print_17_Clue_Proof"></a></i> ). <br><br> <b></b>      ,     ? <br><br>    (     ,     ):         ,     ? ,     n,    ,    n <sup>2</sup> -1  .      n   n <sup>2</sup> -2  ,    ,    ,        .  ,     3,     3 <sup>2</sup> -1=8  ,     .        ( <i>  ?</i> ). <br><br> ,    ,    :    n  ,        n <sup>2</sup> -1     .  ,      ,     n  n <sup>2</sup> -1  ,    . ,    A  B,   B    A.       . <br><br> <b></b>    2  2 <sup>2</sup> -1=3  .    . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/155/cb5/e26/155cb5e269ac4c2284a635deb610526a.JPG"></div><br>   4√ó4,   ()     ,           . <br><br> ,   ,           3,     ,     n ‚Äî    .         n  n+1 (  ), ,   ,   . ,      n    <b>NP-</b> .   NP-,       : <br><br><ol><li>        , ..   . </li><li>           ,         ,   (1). </li></ol><br>      NP-  ‚Äî   ,   ,      .  ,    ,          . <br><br><h1>  Instead of conclusion </h1><br>         ,    .      (   )     . ,  . <br><br>       <a href="http://www.math.cornell.edu/~mec/Summer2009/Mahmood/References.html"></a> . <br><br>  ,    . </div><p>Source: <a href="https://habr.com/ru/post/314514/">https://habr.com/ru/post/314514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314502/index.html">A brief history of the development of game engines</a></li>
<li><a href="../314506/index.html">ZFS on Linux: News from the Field 2017</a></li>
<li><a href="../314508/index.html">Synthesis of images using deep neural networks. Lecture in Yandex</a></li>
<li><a href="../314510/index.html">6 functional programming concepts. Use and examples of use</a></li>
<li><a href="../314512/index.html">Names of large numbers in idle games</a></li>
<li><a href="../314518/index.html">Working with the VKontakte C # API</a></li>
<li><a href="../314520/index.html">Measurement of resistance and inductance of a DC motor</a></li>
<li><a href="../314522/index.html">Auto-collection of data about database files and logical disks of the operating system in MS SQL Server</a></li>
<li><a href="../314524/index.html">.NET Tools. Interview with Sergey Shkredov (JetBrains), Pavel Avsenin and Alexander Zakharov (DevExpress)</a></li>
<li><a href="../314528/index.html">The power of ITIL and the problem with the guru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>