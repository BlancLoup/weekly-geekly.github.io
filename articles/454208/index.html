<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RISC-V from scratch</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, we explore various low-level concepts (compilation and layout, primitive runtime environments, assembler, and more) through the prism...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RISC-V from scratch</h1><div class="post__text post__text-html js-mediator-article">  In this article, we explore various low-level concepts (compilation and layout, primitive runtime environments, assembler, and more) through the prism of the RISC-V architecture and its ecosystem.  I myself am a web developer, at work I don‚Äôt do anything like that, but it‚Äôs very interesting to me, this is where the article was born!  Join me on this chaotic journey into the depths of low-level chaos. <br><br>  First, let's discuss a little RISC-V and the importance of this architecture, set up a chain of RISC-V tools and run a simple C program on the emulated RISC-V hardware. <br><a name="habracut"></a><br><h1>  Content </h1><br><ol><li>  <a href="https://habr.com/ru/post/454208/">What is RISC-V?</a> <br></li><li>  <a href="https://habr.com/ru/post/454208/">Customizing QEMU and RISC-V Tools</a> <br></li><li>  <a href="https://habr.com/ru/post/454208/">Hi, RISC-V!</a> <br></li><li>  <a href="https://habr.com/ru/post/454208/">Naive approach</a> <br></li><li>  <a href="https://habr.com/ru/post/454208/">Lifting the veil -v</a> <br></li><li>  <a href="https://habr.com/ru/post/454208/">Search our stack</a> <br></li><li>  <a href="https://habr.com/ru/post/454208/">Layout</a> <br></li><li>  <a href="https://habr.com/ru/post/454208/">Stop!</a>  <a href="https://habr.com/ru/post/454208/"><s>Hammertime!</s></a>  <a href="https://habr.com/ru/post/454208/">Runtime!</a> <br></li><li>  <a href="https://habr.com/ru/post/454208/">Debug but now for real</a> <br></li><li>  <a href="https://habr.com/ru/post/454208/">What's next?</a> <br></li><li>  <a href="https://habr.com/ru/post/454208/">Additionally</a> </li></ol><br><a name="1"></a><h1>  What is RISC-V? </h1><br>  RISC-V is a free command set architecture.  The project originated at the University of California at Berkeley in 2010.  An important role in its success was played by the openness of the code and freedom of use, which differed sharply from many other architectures.  Take ARM: to create a compatible processor, you have to pay an advance fee <a href="https://www.anandtech.com/show/7112/the-arm-diaries-part-1-how-arms-business-model-works/2">of $ 1 million to $ 10 million, and pay royalties of 0.5-2% from sales</a> .  The free and open model makes RISC-V an attractive option for many, including startups who can't pay a license for ARM or another processor, for academic researchers and (obviously) for the open source community. <br><br>  The rapid growth in popularity of RISC-V has not gone unnoticed.  ARM <a href="https://abopen.com/news/rattled-arm-launches-anti-risc-v-marketing-campaign/">launched a site</a> that tried (rather unsuccessfully) to highlight the perceived advantages of ARM over RISC-V (the site is already closed).  The project RISC-V is supported by <a href="https://riscv.org/members-at-a-glance/">many large companies</a> , including Google, Nvidia and Western Digital. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="2"></a><h1>  Customizing QEMU and RISC-V Tools </h1><br>  We will not be able to run the code on the RISC-V processor until we set up the environment.  Fortunately, this does not require a physical RISC-V processor; instead, take <a href="https://www.qemu.org/">qemu</a> .  To install, follow the <a href="https://www.qemu.org/download">instructions for your operating system</a> .  I have MacOS, so just enter one command: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># also available via MacPorts - `sudo port install qemu` brew install qemu</span></span></code> </pre> <br>  Conveniently, <code>qemu</code> comes with <a href="https://github.com/riscv/riscv-qemu/wiki">several ready-to-use machines</a> (see the <code>qemu-system-riscv32 -machine</code> ). <br><br>  Next, install <a href="http://openocd.org/">OpenOCD</a> for RISC-V and RISC-V tools. <br><br>  Download ready-made OpenISD RISC-V assemblies and RISC-V tools <a href="https://www.sifive.com/boards">here</a> . <br>  Extract files to any directory, I have it <code>~/usys/riscv</code> .  Memorize it for future reference. <br><br><pre> <code class="bash hljs">mkdir -p ~/usys/riscv <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/Downloads cp openocd-&lt;date&gt;-&lt;platform&gt;.tar.gz ~/usys/riscv cp riscv64-unknown-elf-gcc-&lt;date&gt;-&lt;platform&gt;.tar.gz ~/usys/riscv <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/usys/riscv tar -xvf openocd-&lt;date&gt;-&lt;platform&gt;.tar.gz tar -xvf riscv64-unknown-elf-gcc-&lt;date&gt;-&lt;platform&gt;.tar.gz</code> </pre> <br>  Set the <code>RISCV_OPENOCD_PATH</code> and <code>RISCV_PATH</code> environment variables so that other programs can find our tool chain.  It may look different depending on the OS and the shell: I added paths to the <code>~/.zshenv</code> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># I put these two exports directly in my ~/.zshenv file - you may have to do something else. export RISCV_OPENOCD_PATH="$HOME/usys/riscv/openocd-&lt;date&gt;-&lt;version&gt;" export RISCV_PATH="$HOME/usys/riscv/riscv64-unknown-elf-gcc-&lt;date&gt;-&lt;version&gt;" # Reload .zshenv with our new environment variables. Restarting your shell will have a similar effect. source ~/.zshenv</span></span></code> </pre> <br>  Create a symbolic link for this executable file in <code>/usr/local/bin</code> to run it at any time without specifying the full path to <code>~/usys/riscv/riscv64-unknown-elf-gcc-&lt;date&gt;-&lt;version&gt;/bin/riscv64-unknown-elf-gcc</code> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Symbolically link our gcc executable into /usr/local/bin. Repeat this process for any other executables you want to quickly access. ln -s ~/usys/riscv/riscv64-unknown-elf-gcc-8.2.0-&lt;date&gt;-&lt;version&gt;/bin/riscv64-unknown-elf-gcc /usr/local/bin</span></span></code> </pre> <br>  And voila, we have a working set of tools RISC-V!  All of our executable files, such as <code>riscv64-unknown-elf-gcc</code> , <code>riscv64-unknown-elf-gdb</code> , <code>riscv64-unknown-elf-ld</code> and others, are located in <code>~/usys/riscv/riscv64-unknown-elf-gcc-&lt;date&gt;-&lt;version&gt;/bin/</code> . <br><br><a name="3"></a><h1>  Hi, RISC-V! </h1><br>  <i>Update May 26, 2019:</i> <i><br><br></i>  <i>Unfortunately, because of a bug in RISC-V QEMU, the <a href="https://github.com/sifive/freedom-e-sdk">freedom-e-sdk</a> 'hello world' program in QEMU no longer works.</i>  <i>A patch has been released to resolve this issue, but for now you can skip this section.</i>  <i>This program will not be needed in further sections of the article.</i>  <i>I monitor the situation and update the article after fixing the bug.</i> <i><br><br></i>  <i>See <a href="https://github.com/sifive/freedom-e-sdk/issues/260">this comment</a> for more information.</i> <br><br>  After setting up the tools, let's run a simple RISC-V program.  Let's start with cloning the SiFive <a href="https://github.com/sifive/freedom-e-sdk">freedom-e-sdk</a> repository: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/wherever/you/want/to/<span class="hljs-built_in"><span class="hljs-built_in">clone</span></span>/this git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --recursive https://github.com/sifive/freedom<span class="hljs-_"><span class="hljs-_">-e</span></span>-sdk.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> freedom<span class="hljs-_"><span class="hljs-_">-e</span></span>-sdk</code> </pre> <br>  <a href="https://stackoverflow.com/a/12785204">By tradition</a> , let's start with the 'Hello, world' program from the <code>freedom-e-sdk</code> repository.  We use a ready-made <code>Makefile</code> , which they provide for compiling this program in debug mode: <br><br><pre> <code class="bash hljs">make PROGRAM=hello TARGET=sifive-hifive1 CONFIGURATION=debug software</code> </pre> <br>  And run in QEMU: <br><br><pre> <code class="bash hljs">qemu-system-riscv32 -nographic -machine sifive_e -kernel software/hello/debug/hello.elf Hello, World!</code> </pre> <br>  This is a great start.  You can run other examples from <code>freedom-e-sdk</code> .  After that, we will write and try to debug our own C program. <br><br><h1>  Naive approach </h1><br>  Let's start with a simple program that infinitely adds two numbers. <br><br><pre> <code class="cpp hljs">cat add.<span class="hljs-function"><span class="hljs-function">c </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = a + b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  We want to run this program, and first we need to compile it for the RISC-V processor. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># -O0 to disable all optimizations. Without this, GCC might optimize # away our infinite addition since the result 'c' is never used. # -g to tell GCC to preserve debug info in our executable. riscv64-unknown-elf-gcc add.c -O0 -g</span></span></code> </pre> <br>  This is where the <code>a.out</code> file is created, the default <code>gcc</code> name for executables.  Now run this file in <code>qemu</code> : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># -machine tells QEMU which among our list of available machines we want to # run our executable against. Run qemu-system-riscv64 -machine help to list # all available machines. # -m is the amount of memory to allocate to our virtual machine. # -gdb tcp::1234 tells QEMU to also start a GDB server on localhost:1234 where # TCP is the means of communication. # -kernel tells QEMU what we're looking to run, even if our executable isn't # exactly a "kernel". qemu-system-riscv64 -machine virt -m 128M -gdb tcp::1234 -kernel a.out</span></span></code> </pre> <br>  We chose the <code>virt</code> machine that <code>riscv-qemu</code> <a href="https://github.com/riscv/riscv-qemu/wiki">comes</a> <code>riscv-qemu</code> . <br><br>  Now, when our program runs inside QEMU with a GDB server on <code>localhost:1234</code> , connect to it with a RISC-V GDB client from a separate terminal: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># --tui gives us a (t)extual (ui) for our GDB session. # While we can start GDB without any arguments, specifying 'a.out' tells GDB # to load debug symbols from that file for the newly created session. riscv64-unknown-elf-gdb --tui a.out</span></span></code> </pre> <br>  And we are inside GDB! <br><br><pre>  This GDB was configured as "--host = x86_64-apple-darwin17.7.0 --target = riscv64-unknown-elf".  ‚îÇ
 Type "show configuration" for configuration details.  ‚îÇ
 For bug reporting instructions, please see: ‚îÇ
 &lt;http://www.gnu.org/software/gdb/bugs/&gt;.  ‚îÇ
 Find the GDB manual and other documentation online at: ‚îÇ
     &lt;http://www.gnu.org/software/gdb/documentation/&gt;.  ‚îÇ
                                                                                                       ‚îÇ
 For help, type "help".  ‚îÇ
 Type "apropos word" ... ‚îÇ
 Reading symbols from a.out ... ‚îÇ
 (gdb) </pre><br>  We can try to run the <code>run</code> or <code>start</code> commands for the <code>a.out</code> executable file in GDB, but at the moment it will not work for an obvious reason.  We compiled the program as <code>riscv64-unknown-elf-gcc</code> , so the host should work on the <code>riscv64</code> architecture. <br><br>  But there is a way out!  This situation is one of the main reasons for the existence of the client-server model of GDB.  We can take the executable file <code>riscv64-unknown-elf-gdb</code> and instead of launching it on the host, point it to some remote target (GDB server).  As you remember, we just ran <code>riscv-qemu</code> and told to start the GDB server on <code>localhost:1234</code> .  Just connect to this server: <br><br><pre>  (gdb) target remote: 1234
 Remote debugging using: 1234 </pre><br>  Now you can set some breakpoints: <br><br><pre> <code class="bash hljs">(gdb) b main Breakpoint 1 at 0x1018e: file add.c, line 2. (gdb) b 5 <span class="hljs-comment"><span class="hljs-comment"># this is the line within the forever-while loop. int c = a + b; Breakpoint 2 at 0x1019a: file add.c, line 5.</span></span></code> </pre> <br>  And finally, specify GDB <code>continue</code> (abbreviated <code>c</code> command) until we reach a breakpoint: <br><br><pre> <code class="bash hljs">(gdb) c Continuing.</code> </pre> <br>  You will quickly notice that the process does not end at all.  This is strange ... shouldn't we immediately reach breakpoint <code>b 5</code> ?  What happened? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a53/834/210/a538342106336ef7ed1b8f9e53a47f48.png"><br><br>  There are several problems here: <br><br><ol><li>  Text UI can not find the source.  The interface should display our code and any nearby breakpoints. <br></li><li>  GDB does not see the current execution line ( <code>L??</code> ) and displays the 0x0 counter ( <code>PC: 0x0</code> ). <br></li><li>  Some text in the input line, which in its full form looks like this: <code>0x0000000000000000 in ?? ()</code> <code>0x0000000000000000 in ?? ()</code> </li></ol><br>  Combined with the fact that we cannot reach a breakpoint, these indicators indicate: we did <i>something</i> wrong.  But what? <br><br><a name="5"></a><h1>  Lifting the veil -v </h1><br>  To understand what is happening, you need to take a step back and talk about how our simple C program under the hood actually works.  The <code>main</code> function performs simple addition, but what is it really?  Why should it be called <code>main</code> , not <code>origin</code> or <code>begin</code> ?  According to the convention, all executable files start to run from the <code>main</code> function, but what magic does this behavior provide? <br><br>  To answer these questions, let's repeat our GCC command with the <code>-v</code> flag to get a more detailed output of what is actually happening. <br><br><pre> <code class="bash hljs">riscv64-unknown-elf-gcc add.c -O0 -g -v</code> </pre> <br>  The issue is large, so we will not view the entire listing.  It is important to note that although GCC is formally a compiler, but by default it also does the layout (to limit only to compiling and building, you should specify the <code>-c</code> flag).  Why is it important?  Well, take a look at a fragment from the <code>gcc</code> detailed output: <br><br><pre>  # The actual `gcc -v` command outputs
 # long, so pretend these variables exist.
 # $ RV_GCC_BIN_PATH = / Users / twilcock / usys / riscv / riscv64-unknown-elf-gcc- &lt;date&gt; - &lt;version&gt; / bin /
 # $ RV_GCC_LIB_PATH = $ RV_GCC_BIN_PATH /../lib / gcc / riscv64-unknown-elf / 8.2.0<font></font>
<font></font>
 $ RV_GCC_BIN_PATH /../ libexec / gcc / riscv64-unknown-elf / 8.2.0 / collect2 \
   ... truncated ... 
   $ RV_GCC_LIB_PATH /../../../../ riscv64-unknown-elf / lib / rv64imafdc / lp64d / crt0.o \ 
   $ RV_GCC_LIB_PATH / riscv64-unknown-elf / 8.2.0 / rv64imafdc / lp64d / crtbegin.o \
   -lgcc - start-group -lc -lgloss - end-group-lgcc \ 
   $ RV_GCC_LIB_PATH / rv64imafdc / lp64d / crtend.o
   ... truncated ...
 COLLECT_GCC_OPTIONS = '- O0' '-g' '-v' '-march = rv64imafdc' '-mabi = lp64d' </pre><br>  I understand that even in abbreviated form is a lot, so let me explain.  In the first line, <code>gcc</code> runs the <code>collect2</code> program, <code>collect2</code> in the arguments <code>crt0.o</code> , <code>crtbegin.o</code> and <code>crtend.o</code> , the flags <code>-lgcc</code> and <code>--start-group</code> .  Description of collect2 can be read <a href="https://gcc.gnu.org/onlinedocs/gccint/Collect2.html">here</a> : briefly, collect2 organizes various initialization functions at startup, making the layout in one or more passes. <br><br>  Thus, GCC compiles several <code>crt</code> files with our code.  As you can guess, <code>crt</code> means 'C runtime'.  <a href="https://stackoverflow.com/a/27786892/2421349">It</a> describes in detail what each <code>crt</code> , but we are interested in <code>crt0</code> , which does one important thing: <br><br><blockquote>  <i>"It is expected that this object [crt0] contains the symbol <code>_start</code> , which indicates the initial load of the program."</i> </blockquote><br>  The essence of the ‚Äúinitial load‚Äù depends on the platform, but usually it includes important tasks, such as setting up a stack frame, passing command line arguments and calling <code>main</code> .  Yes, <i>finally</i> we have found the answer to the question: it is <code>_start</code> calls our main function! <br><br><a name="6"></a><h1>  Search our stack </h1><br>  We solved one riddle, but how does this bring us closer to the original goal of launching a simple C program in <code>gdb</code> ?  It remains to solve several problems: the first one is related to the way <code>crt0</code> sets up our stack. <br><br>  As we saw above, <code>gcc</code> <code>crt0</code> by default.  The default parameters are selected based on several factors: <br><br><ul><li>  <a href="https://wiki.osdev.org/Target_Triplet">Target triplet</a> corresponding to the structure of the <code>machine-vendor-operatingsystem</code> .  We have this <code>riscv64-unknown-elf</code> <br></li><li>  Target architecture, <code>rv64imafdc</code> <br></li><li>  Target ABI, <code>lp64d</code> </li></ul><br>  Normally everything works fine, but not for every RISC-V processor.  As mentioned earlier, one of the tasks of <code>crt0</code> is to configure the stack.  But he does not know where exactly should the stack be for our CPU ( <code>-machine</code> )?  He can not cope without our help. <br><br>  In the <code>qemu-system-riscv64 -machine virt -m 128M -gdb tcp::1234 -kernel a.out</code> we used the <code>virt</code> machine.  Fortunately, <code>qemu</code> makes it easy to reset machine information to a <code>dtb</code> dump (device tree blob). <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Go to the ~/usys/riscv folder we created before and create a new dir # for our machine information. cd ~/usys/riscv &amp;&amp; mkdir machines cd machines # Use qemu to dump info about the 'virt' machine in dtb (device tree blob) # format. # The data in this file represents hardware components of a given # machine / device / board. qemu-system-riscv64 -machine virt -machine dumpdtb=riscv64-virt.dtb</span></span></code> </pre> <br>  The dtb data is hard to read because it is basically a binary format, but there is a <code>dtc</code> command line utility (device tree compiler) that can convert the file to something more readable. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># I'm running MacOS, so I use Homebrew to install this. If you're # running another OS you may need to do something else. brew install dtc # Convert our .dtb into a human-readable .dts (device tree source) file. dtc -I dtb -O dts -o riscv64-virt.dts riscv64-virt.dtb</span></span></code> </pre> <br>  The output is <code>riscv64-virt.dts</code> , where we see a lot of interesting information about <code>virt</code> : the number of available processor cores, the memory location of various peripheral devices, such as the UART, the location of the built-in memory (RAM).  The stack should be in this memory, so look for it using <code>grep</code> : <br><br><pre> <code class="bash hljs">grep memory riscv64-virt.dts -A 3 memory@80000000 { device_type = <span class="hljs-string"><span class="hljs-string">"memory"</span></span>; reg = &lt;0x00 0x80000000 0x00 0x8000000&gt;; };</code> </pre> <br>  As you can see, this node has 'memory' specified as <code>device_type</code> .  Apparently, we found what we were looking for.  According to the values ‚Äã‚Äãinside <code>reg = &lt;...&gt; ;</code>  You can determine where the memory bank starts and what is its length. <br><br>  In <a href="https://www.devicetree.org/downloads/devicetree-specification-v0.1-20160524.pdf">the devicetree specification, we</a> see that the syntax <code>reg</code> is an arbitrary number of pairs <code>(base_address, length)</code> .  However, <code>reg</code> four values.  Strange, is it not enough for one memory bank two values? <br><br>  Again, from the devicetree specification (search for the <code>reg</code> property), we learn that the number of <code>&lt;u32&gt;</code> cells to specify the address and length is determined by the <code>#address-cells</code> and <code>#size-cells</code> properties in the parent node (or in the node itself).  These values ‚Äã‚Äãare not indicated in our memory node, and the parent memory node is simply the root of the file.  Let's look for these values ‚Äã‚Äãin it: <br><br><pre> <code class="plaintext hljs">head -n8 riscv64-virt.dts /dts-v1/; / { #address-cells = &lt;0x02&gt;; #size-cells = &lt;0x02&gt;; compatible = "riscv-virtio"; model = "riscv-virtio,qemu";</code> </pre> <br>  It turns out that both the address and the length require two 32-bit values.  This means that with <code>reg = &lt;0x00 0x80000000 0x00 0x8000000&gt;;</code>  our memory starts <code> 0x00 + 0x80000000 (0x80000000)</code> and occupies <code>0x00 + 0x8000000 (0x8000000)</code> bytes, that is, ends at <code>0x88000000</code> , which corresponds to 128 megabytes. <br><br><a name="7"></a><h1>  Layout </h1><br>  Using <code>qemu</code> and <code>dtc</code> we found the RAM addresses in the virt virtual machine.  We also know that <code>gcc</code> <code>crt0</code> by default without setting up the stack as we need.  But how to use this information to eventually run and debug the program? <br><br>  Since <code>crt0</code> does not suit us, there is one obvious option: to write your own code, and then link it with an object file, which turned out after compiling our simple program.  Our <code>crt0</code> needs to know where the top of the stack begins in order to properly initialize it.  We could hard-code the value <code>0x80000000</code> directly to <code>crt0</code> , but this is not a very suitable solution considering the changes that may be needed in the future.  What if we want to use another CPU in the emulator, such as <code>sifive_e</code> , with different characteristics? <br><br>  Fortunately, we are not the first to ask this question, and there is already a good solution.  The GNU <code>ld</code> linker <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/assignments.html">allows you to define a symbol</a> that is accessible from our <code>crt0</code> .  We can define a <code>__stack_top</code> symbol suitable for different processors. <br><br>  Instead of writing your own linker file from scratch, it makes sense to take the default script from <code>ld</code> and slightly modify it to support additional characters.  What is a linker script?  <a href="http/informatik/gcc_docs/ld_3.html">Here is a good description</a> : <br><br><blockquote>  <i>The main purpose of the linker script is to describe how the sections of the files in the input and output are mapped, and to manage the layout of the memory of the output file.</i> </blockquote><br>  Knowing this, let's copy the default <code>riscv64-unknown-elf-ld</code> linker script to a new file: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/usys/riscv <span class="hljs-comment"><span class="hljs-comment"># Make a new dir for custom linker scripts out RISC-V CPUs may require. mkdir ld &amp;&amp; cd ld # Copy the default linker script into riscv64-virt.ld riscv64-unknown-elf-ld --verbose &gt; riscv64-virt.ld</span></span></code> </pre> <br>  There is a <i>lot of</i> interesting information in this file, much more than we can discuss in this article.  Detailed issuance with the <code>--Verbose</code> key includes information about the <code>ld</code> version, supported architectures, and more.  This is all good to know, but in the linker script this syntax is not allowed, so open the text editor and remove everything unnecessary from the file. <br><br><pre>  vim riscv64-virt.ld<font></font>
<font></font>
 # Remove everything above and including the ============= line
 GNU ld (GNU Binutils) 2.32
   Supported emulations:
    elf64lriscv
    elf32lriscv
 using internal linker script:
 =================================================
 / * Script for -z combreloc: combine and sort reloc sections * /
 / * Copyright (C) 2014-2019 Free Software Foundation, Inc.
    Without modification,
    are not allowed
    notice this notice are preserved.  * /
 OUTPUT_FORMAT ("elf64-littleriscv", "elf64-littleriscv",
	       "elf64-littleriscv")
 ... rest of the linker script ... </pre><br>  After that, run the <a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_16.html">MEMORY</a> command to manually determine where <code>__stack_top</code> will be.  Find the line that starts with <code>OUTPUT_ARCH(riscv)</code> , it should be at the top of the file, and add the <code>MEMORY</code> command below it: <br><br><pre> <code class="plaintext hljs">OUTPUT_ARCH(riscv) /* &gt;&gt;&gt; Our addition. &lt;&lt;&lt; */ MEMORY { /* qemu-system-risc64 virt machine */ RAM (rwx) : ORIGIN = 0x80000000, LENGTH = 128M } /* &gt;&gt;&gt; End of our addition. &lt;&lt;&lt; */ ENTRY(_start)</code> </pre> <br>  We created a memory block called <code>RAM</code> , for which read ( <code>r</code> ), write ( <code>w</code> ), and storage of executable code ( <code>x</code> ) are valid. <br><br>  Great, we defined a memory layout that conforms to the specifications of our <code>virt</code> RISC-V machine.  Now you can use it.  We want to put our stack in memory. <br><br>  You need to define the symbol <code>__stack_top</code> .  Open your linker script ( <code>riscv64-virt.ld</code> ) in a text editor and add a few lines: <br><br><pre> <code class="plaintext hljs">SECTIONS { /* Read-only sections, merged into text segment: */ PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x10000)); . = SEGMENT_START("text-segment", 0x10000) + SIZEOF_HEADERS; /* &gt;&gt;&gt; Our addition. &lt;&lt;&lt; */ PROVIDE(__stack_top = ORIGIN(RAM) + LENGTH(RAM)); /* &gt;&gt;&gt; End of our addition. &lt;&lt;&lt; */ .interp : { *(.interp) } .note.gnu.build-id : { *(.note.gnu.build-id) }</code> </pre> <br>  As you can see, we define <code>__stack_top</code> using <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/assignments.html">the PROVIDE command</a> .  The symbol will be accessible from any program associated with this script (assuming that the program itself does not detect something with the name <code>__stack_top</code> ).  Set the <code>__stack_top</code> value to <code>ORIGIN(RAM)</code> .  We know that this value is <code>0x80000000</code> plus <code>LENGTH(RAM)</code> , which is 128 megabytes ( <code>0x8000000</code> bytes).  This means that our <code>__stack_top</code> set to <code>0x88000000</code> . <br><br>  For brevity, I will not give here the entire linker file, it can be viewed <a href="">here</a> . <br><br><a name="8"></a><h1>  Stop!  <s>Hammertime!</s>  Runtime! </h1><br>  Now we have everything we need to create our own C runtime. In fact, this is a fairly simple task, here is the entire <code>crt0.s</code> file: <br><br><pre> <code class="plaintext hljs">.section .init, "ax" .global _start _start: .cfi_startproc .cfi_undefined ra .option push .option norelax la gp, __global_pointer$ .option pop la sp, __stack_top add s0, sp, zero jal zero, main .cfi_endproc .end</code> </pre> <br>  Immediately draws a large number of lines that begin with a dot.  This is a file for the <code>as</code> assembler.  Lines with a dot are called <a href="https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_7.html">assembler directives</a> : they provide information for the assembler.  This is not executable code, like RISC-V assembler instructions such as <code>jal</code> and <code>add</code> . <br><br>  Run through the file line by line.  We will work with various standard RISC-V registers, so read <a href="">this table</a> , where all registers and their purpose are considered. <br><br><pre> <code class="plaintext hljs">.section .init, "ax"</code> </pre> <br>  As stated in <a href="https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_7.html">the GNU assembler manual 'as'</a> , this line tells the assembler to enter the following code into the <code>.init</code> section, which is selectable ( <code>a</code> ) and executable ( <code>x</code> ).  This section is another <a href="http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node3.html">common convention</a> for running code within the operating system.  We work on pure hardware without an OS, so in our case such instruction may not be completely necessary, but in any case it is a good practice. <br><br><pre> <code class="plaintext hljs">.global _start _start:</code> </pre> <br>  <code>.global</code> makes the next character available to <code>ld</code> .  Without this, the layout will not work, because the <code>ENTRY(_start)</code> in the linker script points to the <code>_start</code> symbol as an entry point to the executable file.  The next line tells the assembler that we are starting the definition of the <code>_start</code> character. <br><br><pre> <code class="plaintext hljs">_start: .cfi_startproc .cfi_undefined ra ...other stuff... .cfi_endproc</code> </pre> <br>  These <code>.cfi</code> directives <a href="https://stackoverflow.com/a/33732119/2421349">inform you</a> about the frame structure and how to handle it.  The <code>.cfi_startproc</code> and <code>.cfi_endproc</code> signal the beginning and end of a function, and <code>.cfi_undefined ra</code> informs the assembler that the <code>ra</code> register <a href="https://sourceware.org/binutils/docs/as/CFI-directives.html">should not be restored</a> to any value contained in it before starting <code>_start</code> . <br><br><pre> <code class="plaintext hljs">.option push .option norelax la gp, __global_pointer$ .option pop</code> </pre> <br>  These <code>.option</code> directives change the behavior of the assembler in accordance with the code when you need to apply a certain set of options.  <a href="https://embarc.org/man-pages/as/RISC_002dV_002dDirectives.html">Here is a</a> detailed description of why the use of <code>.option</code> in this segment is important: <br><br><blockquote>  <i>... since we, when possible, weaken (relax) the addressing of sequences to shorter sequences relative to the GP, the initial loading of the GP should not be weakened and should be given something like this:</i> <i><br><br></i> <pre> <code class="plaintext hljs">.option push .option norelax la gp, __global_pointer$ .option pop</code> </pre> <br>  so that after relaxation we get the following code: <br><br><pre> <code class="plaintext hljs">auipc gp, %pcrel_hi(__global_pointer$) addi gp, gp, %pcrel_lo(__global_pointer$)</code> </pre> <br>  instead of simple: <br><br><pre> <code class="plaintext hljs">addi gp, gp, 0</code> </pre> </blockquote><br>  And now the last part of our <code>crt0.s</code> : <br><br><pre> <code class="plaintext hljs">_start: ...other stuff... la sp, __stack_top add s0, sp, zero jal zero, main .cfi_endproc .end</code> </pre> <br>  Here we can finally use the symbol <code>__stack_top</code> , on the creation of which we have worked so much.  <a href="https://cseweb.ucsd.edu/classes/fa12/cse141/project/pseudo.html">The</a> <code>la</code> <a href="https://cseweb.ucsd.edu/classes/fa12/cse141/project/pseudo.html">pseudoinstruction</a> (load address) loads the <code>__stack_top</code> value into the <code>sp</code> register (stack pointer), setting it for use in the rest of the program. <br><br>  Then <code>add s0, sp, zero</code> adds the values ‚Äã‚Äãof the <code>sp</code> and <code>zero</code> registers (which is actually a <code>x0</code> register with a hard reference to 0) and places the result in the <code>s0</code> register.  This is a <a href="">special register</a> that is unusual in several respects.  First, it is a ‚Äúsave register‚Äù, that is, it is saved when function calls.  Secondly, <code>s0</code> sometimes acts as a frame pointer, which gives each function call a small stack space for storing parameters passed to this function.  How function calls work with the stack and frame pointers is a very interesting topic that you can easily devote to a separate article, but for now just know that in our runtime environment it is important to initialize the <code>s0</code> frame pointer. <br><br>  Next we see the instruction <code>jal zero, main</code> .  Here <code>jal</code> means jump and link.  The instruction expects operands in the form <code>jal rd (destination register), offset_address</code> .  Functionally, <code>jal</code> writes the value of the next instruction (the register <code>pc</code> plus four) to <code>rd</code> , and then sets the register <code>pc</code> to the current value <code>pc</code> plus the address of the offset with the <a href="https://en.wikipedia.org/wiki/Sign_extension">extension of the character</a> , effectively ‚Äúcalling‚Äù this address. <br><br>  As mentioned above, <code>x0</code> strictly bound to the literal value 0, and writing to it is useless.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, it may seem strange that we use a register as the destination register </font></font><code>zero</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which RISC-V assemblers interpret as a register </font></font><code>x0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. After all, this means an unconditional transition to </font></font><code>offset_address</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Why do so, because in other architectures there is an explicit unconditional branch instruction? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This weird pattern </font></font><code>jal zero, offset_address</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is actually a smart optimization. Support for each new instruction means an increase and, therefore, an increase in the cost of the processor. Therefore, the simpler the ISA, the better. Instead of polluting the instruction space with two instructions </font></font><code>jal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>unconditional jump</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the RISC-V architecture only supports </font></font><code>jal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and unconditional transitions are supported through </font></font><code>jal zero, main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are a lot of similar optimizations in RISC-V, most of which take the form of so-called </font></font><a href="https://cseweb.ucsd.edu/classes/fa12/cse141/project/pseudo.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pseudoinstructions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Assemblers know how to translate them into real hardware instructions. </font><font style="vertical-align: inherit;">For example, </font></font><code>j offset_address</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RISC-V assemblers translate the </font><font style="vertical-align: inherit;">pseudoinstruction of unconditional jump </font><font style="vertical-align: inherit;">to </font></font><code>jal zero, offset_address</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For a complete list of officially supported pseudoinstructions, see </font></font><a href="https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the RISC-V specification (version 2.2)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="plaintext hljs">_start: ...other stuff... jal zero, main .cfi_endproc .end</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our last line is an assembler directive </font></font><code>.end</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that simply marks the end of the file.</font></font><br><br><a name="9"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debug but now for real </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trying to debug a simple C program on a RISC-V processor, we solved a lot of problems. </font><font style="vertical-align: inherit;">First, using </font></font><code>qemu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>dtc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">found our memory in the virtual machine </font></font><code>virt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RISC-V. </font><font style="vertical-align: inherit;">Then we used this information to manually control the memory allocation in our version of the default linker script </font></font><code>riscv64-unknown-elf-ld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which allowed us to determine the exact character </font></font><code>__stack_top</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Then we used this symbol in our own version </font></font><code>crt0.s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which sets up our stack and global pointers, and finally called the function </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Now you can reach your goal and start debugging our simple program in GDB. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recall, here is the C program itself:</font></font><br><br><pre> <code class="cpp hljs">cat add.<span class="hljs-function"><span class="hljs-function">c </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = a + b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compiling and compiling: </font></font><br><br><pre> <code class="bash hljs">riscv64-unknown-elf-gcc -g -ffreestanding -O0 -Wl,--gc-sections -nostartfiles -nostdlib -nodefaultlibs -Wl,-T,riscv64-virt.ld crt0.s add.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we have indicated much more flags than the last time, so let's go through those that have not been described before. </font></font><br><br> <code>-ffreestanding</code> <a href="https://stackoverflow.com/questions/17692428/what-is-ffreestanding-option-in-gcc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">informs the compiler that the standard library may not exist</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so no need to make assumptions about its mandatory presence. This parameter is not required when running the application on your host (in the operating system), but in this case it is not so, therefore it is important to inform the compiler this information. </font></font><br><br> <code>-Wl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- A comma separated list of flags to pass to the linker ( </font></font><code>ld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Here it </font></font><code>--gc-sections</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">means ‚Äúgarbage collection sections‚Äù, and </font></font><code>ld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is instructed to remove unused sections after layout. Flags </font></font><code>-nostartfiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>-nostdlib</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>-nodefaultlibs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tell the linker not to handle standard system startup files (for example, default</font></font><code>crt0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), standard system stdlib implementations and standard system default link libraries. </font><font style="vertical-align: inherit;">We have our own script </font></font><code>crt0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and linker, so it is important to pass these flags so that the default values ‚Äã‚Äãdo not conflict with our custom settings. </font></font><br><br> <code>-T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indicates the path to our linker script, which in our case is simple </font></font><code>riscv64-virt.ld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Finally, we specify the files that we want to compile, build, and link: </font></font><code>crt0.s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>add.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As before, the result is a complete and ready-to-run file called </font></font><code>a.out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now run our pretty new executable file in </font></font><code>qemu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># -S freezes execution of our executable (-kernel) until we explicitly tell # it to start with a 'continue' or 'c' from our gdb client qemu-system-riscv64 -machine virt -m 128M -gdb tcp::1234 -S -kernel a.out</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now run </font></font><code>gdb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, do not forget to load the debug symbols for </font></font><code>a.out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, specifying it with the last argument:</font></font><br><br><pre> <code class="bash hljs">riscv64-unknown-elf-gdb --tui a.out GNU gdb (GDB) 8.2.90.20190228-git Copyright (C) 2019 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type <span class="hljs-string"><span class="hljs-string">"show copying"</span></span> and <span class="hljs-string"><span class="hljs-string">"show warranty"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> details. This GDB was configured as <span class="hljs-string"><span class="hljs-string">"--host=x86_64-apple-darwin17.7.0 --target=riscv64-unknown-elf"</span></span>. Type <span class="hljs-string"><span class="hljs-string">"show configuration"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> configuration details. For bug reporting instructions, please see: &lt;http://www.gnu.org/software/gdb/bugs/&gt;. Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/&gt;. For <span class="hljs-built_in"><span class="hljs-built_in">help</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">"help"</span></span>. Type <span class="hljs-string"><span class="hljs-string">"apropos word"</span></span> to search <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> commands related to <span class="hljs-string"><span class="hljs-string">"word"</span></span>... Reading symbols from a.out... (gdb)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we connect our client </font></font><code>gdb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the server </font></font><code>gdb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which we launched as part of the command </font></font><code>qemu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="bash hljs">(gdb) target remote :1234 ‚îÇ Remote debugging using :1234</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Set a breakpoint in main: </font></font><br><br><pre> <code class="bash hljs">(gdb) b main Breakpoint 1 at 0x8000001e: file add.c, line 2.</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And start the program: </font></font><br><br><pre> <code class="bash hljs">(gdb) c Continuing. Breakpoint 1, main () at add.c:2</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the above output, it is clear that we have successfully hit the breakpoint on line 2! </font><font style="vertical-align: inherit;">This can be seen in the text interface, finally we have the correct string </font></font><code>L</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the value </font></font><code>PC:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is equal </font></font><code>L2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and </font></font><code>PC:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>0x8000001e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If you did everything as in the article, the output will be something like this: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd8/aa9/78d/bd8aa978df4289f584b5c422cdb6e44c.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From now on, you can use it </font></font><code>gdb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as usual: </font></font><code>-s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to go to the next instruction, </font></font><code>info all-registers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to check the values ‚Äã‚Äãinside the registers as the program runs, etc. Experiment at your leisure ... of course we A lot of work for this!</font></font><br><br><a name="10"></a><h1>  What's next? </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Today we have achieved a lot and, I hope, we have learned a lot! I have never had a formal plan for this and subsequent articles, I just followed what was most interesting to me at every moment. Therefore, not sure what will happen next. I especially liked the deep immersion in the manual </font></font><code>jal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so maybe in the next article we take the knowledge gained here, but replace it with </font></font><code>add.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">some program in pure RISC-V assembler. If you have something specific that you would like to see or any questions, </font></font><a href="https://github.com/twilco/twilco.github.io/issues"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">open tickets</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thank you for reading! Hope to see you in the next article!</font></font><br><br><a name="11"></a><h1>  Additionally </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you liked the article and want to learn more, check out Matt Godbol‚Äôs presentation titled </font></font><a href="https://www.youtube.com/watch%3Fv%3DdOfucXtyEsU"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúBits between bits: how we get into main ()‚Äù</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from the CppCon2018 conference. </font><font style="vertical-align: inherit;">She approaches the topic a little differently than we are here. </font><font style="vertical-align: inherit;">Really good lecture, see for yourself!</font></font></div><p>Source: <a href="https://habr.com/ru/post/454208/">https://habr.com/ru/post/454208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454196/index.html">3D printing of electronics on the example of a drone: wires and boards are no longer needed</a></li>
<li><a href="../454198/index.html">Creation of multi-module Gradle project SpringBoot + Angular in IDEA</a></li>
<li><a href="../4542/index.html">Seven Tips for Choosing a Name for a Web 2.0 Startup</a></li>
<li><a href="../454204/index.html">Behavioral crawling - not a panacea?</a></li>
<li><a href="../454206/index.html">PHDays 9: AI CTF Parsing</a></li>
<li><a href="../454210/index.html">Forgotten enchantjs + new 1C-Bitrix = Game for customer motivation</a></li>
<li><a href="../454214/index.html">I hate almost all software.</a></li>
<li><a href="../454216/index.html">Found evidence that all changes are a mixture of order and chance</a></li>
<li><a href="../454220/index.html">Two-digit thermometer</a></li>
<li><a href="../454222/index.html">Upgrade the disk subsystem of the old server with a PCIe 1.0 bus - 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>