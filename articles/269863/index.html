<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Duke, take out the trash! - Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we continue the series of articles about garbage collectors shipped with the Oracle Java HotSpot VM virtual machine. We have already studied a b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Duke, take out the trash! - Part 3</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/ee0/313/224/ee03132241904dcca4dd321edabb5275.png" width="600" height="386" alt="Part 3 - CMS GC and G1 GC"></div><br>  Today we continue the series of articles about garbage collectors shipped with the Oracle Java HotSpot VM virtual machine.  We have already <a href="http://habrahabr.ru/post/269621/">studied a</a> bit of theory and <a href="http://habrahabr.ru/post/269707/">considered</a> how two basic collectors are dealt with a bunch of - Serial GC and Parallel GC.  And in this article we will focus on the CMS GC and G1 GC collectors, the primary task of which is to minimize pauses when restoring order in the memory of applications that operate with medium and large amounts of data, that is, for the most part in the memory of server applications. <br><br>  These two collectors are united by the common name <i>‚Äúmostly concurrent collectors‚Äù</i> , that is, <i>‚Äúmostly competitive collectors‚Äù</i> .  This is due to the fact that part of their work they perform in parallel with the main threads of the application, that is, at some points they compete with them for processor resources.  Of course, this does not pass without a trace, and as a result they exchange the improvement in part of the pauses for deterioration in part of the carrying capacity.  Although they do it in different ways.  Let's see how. <br><a name="habracut"></a><br><h1>  CMS GC </h1><br>  The CMS collector (decoded as Concurrent Mark Sweep) appeared in HotSpot VM at the same time as the Parallel GC as its alternative for use in applications that have access to several processor cores and are sensitive to <abbr title="stop the world, stop the application at the time of garbage collection">STW</abbr> pauses.  At that time, there was another alternative - Incremental GC, but it did not pass natural selection for lack of clear advantages.  And CMS survived.  And although the peak of its popularity, apparently, has already passed, it will be interesting to take a look at its internal structure, since some of the ideas embodied in it moved to a more modern G1 GC. <br><br>  Using the CMS GC is enabled with the <i>-XX: + UseConcMarkSweepGC option</i> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Work principles </h3><br>  We have already seen the words Mark and Sweep when considering serial and parallel collectors (if you have not met, then now is the time to <a href="http://habrahabr.ru/post/269707/">do it</a> ).  They marked two steps in the process of garbage collection in the older generation: marking the surviving objects and removing dead objects.  The CMS collector got its name due to the fact that it performs these steps in parallel with the operation of the main program. <br><br>  In this case, the CMS GC uses the same memory organization as the Serial / Parallel GC already reviewed: the Eden + Survivor 0 + Survivor 1 + Tenured regions and the same principles of small garbage collection.  Differences begin only when it comes to complete assembly.  In the case of CMS it is called the <i>older (major) assembly</i> , and not the full one, since it does not affect the objects of the younger generation.  As a result, the small and senior assemblies are always separated here.  One of the side effects of this separation is that all objects of the younger generation (even potentially dead) can play the role of roots in determining the status of objects in the older generation. <br><br>  An important difference from the CMS collector from those considered earlier is that it does not wait for Tenured to be filled in order to start the older assembly.  Instead, he works in the background constantly, trying to keep the Tenured in a compact state. <br><br>  Let's look at what the older garbage collection is when using the CMS GC. <br><br>  It begins by stopping the main application threads and marking all objects directly accessible from the roots.  After this, the application resumes its work, and the collector, in parallel with it, searches for all the living objects that are accessible by reference from those very marked root objects (this part it does in one or in several streams). <br><br>  Naturally, during such a search, the situation in the heap may change, and not all the information collected during the search for living objects is relevant.  Therefore, the collector once again suspends the application and scans the heap to search for living objects that have escaped from it during the first pass.  In this case, it is assumed that objects which, at the time of the completion of the compilation of the list, are no longer recorded, will be recorded into living objects.  These objects are called <i>floating garbage</i> , they will be removed during the next assembly. <br><br>  After the living objects are marked, the operation of the main threads of the application is resumed, and the collector clears the memory of dead objects in several parallel threads.  It should be borne in mind that after cleaning, the objects in the older generation are not packed, since it is very difficult to do this with the application running. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f9f/d54/9a2/f9fd549a2a104f1eb7acf5098dd0afe8.png" width="600" height="200" alt="Flows when running the CMS collector"></div><br>  The CMS builder is quite intelligent.  For example, he tries to distribute small and senior garbage collections in time so that they do not create long pauses in the application (additional details about this diversity in the <a href="https://habr.com/ru/post/269863/">comments</a> ).  To this end, he keeps statistics on past assemblies and plans subsequent ones based on it. <br><br>  Separately, you should consider the situation when the collector does not have time to clear the Tenured until the memory is completely finished.  In this case, the application stops working, and the entire assembly is performed in sequential mode.  This situation is called <i>concurrent mode failure</i> .  The builder informs us of these failures with the <i>-verbose: gc</i> or <i>-Xloggc: filename</i> options <i>enabled</i> . <br><br>  CMS has one interesting mode of operation, called Incremental Mode, or i-cms, which causes it to temporarily stop when working in parallel with the main application in order to free up processor resources for a short period (something like <abbr title="anti-lock system">ABS</abbr> in a car).  This can be useful on machines with a small number of cores.  But this mode is already marked as not recommended for use and may be disabled in future releases, so we will not analyze it in detail. <br><br><h3>  STW situations </h3><br>  From all of the above, it follows that with normal garbage collection, the CMS GC has the following situations leading to STW: <br><ul><li>  Small garbage collection.  This pause is no different from a similar pause in the Parallel GC. </li><li>  The initial phase of the search for living objects in the older assembly (the so-called <i>initial mark pause</i> ).  This pause is usually very short. </li><li>  The phase of the addition of a set of living objects in the older assembly (also known as <i>remark pause</i> ).  It is usually longer than the initial search phase. </li></ul><br>  In the event of a failure in the competitive mode, the pause may be delayed for a sufficiently long time. <br><br><h3>  Customization </h3><br>  Since the CMS memory approaches are similar to those used in Serial / Parallel GC, the same options for determining the size of the heap regions, as well as the automatic adjustment options for the required performance parameters are applicable to it. <br><br>  Usually, the CMS, based on the statistics collected by the application, determines when it should execute the older assembly, but it also has a threshold for the fullness of the Tenured region, upon reaching which the older assembly must necessarily be initiated.  This threshold can be set using the <i><nobr>-XX</nobr></i> option <i><nobr>: CMSInitiatingOccupancyFraction =?</nobr></i>  , the value is indicated as a percentage.  A value of -1 (sometimes set by default) indicates that the assembly is disabled by this condition. <br><br><h3>  Advantages and disadvantages </h3><br>  The advantage of this collector compared to the previously considered Serial / Parallel GC is its focus on minimizing downtime, which is a critical factor for many applications.  But to accomplish this task you have to sacrifice processor resources and often total bandwidth. <br><br>  Recall also that this collector does not compact objects in the older generation, which leads to Tenured fragmentation.  This fact, combined with the presence of floating debris, makes it necessary for the application (specifically, the older generation) to allocate more memory than other collectors would need (Oracle advises 20% more). <br><br>  Well, long pauses in case of potential failures of the competitive regime can be an unpleasant surprise.  Although they are not frequent, and if there is enough memory, CMS can avoid them completely. <br><br>  However, such a collector may be suitable for applications that use a large amount of long-lived data.  In this case, some of its shortcomings are leveled.  But in any case, it is not necessary to make a decision on its use until you have become acquainted with another Java HotSpot VM caster builder. <br><br><hr><br><h1><a name="G1"></a>  G1 GC </h1><br>  So we got to the last and probably most interesting for many garbage collector - G1 (which is short for Garbage First).  It is interesting, first of all, because it is not a clear continuation of the Serial / Parallel / CMS line, which adds parallelism to another phase of garbage collection, but uses an already significantly different approach to the task of cleaning up memory. <br><br>  G1 is the youngest member of the HotSpot virtual machine garbage collectors.  It was initially positioned as a collector for applications with large heaps (from 4 GB and above), for which it is important to keep the response time small and predictable, even if at the expense of reducing bandwidth.  In this field, he competed with the CMS GC, although not initially as successfully as we would like.  But it gradually corrected, improved, stabilized and finally reached such a level that Oracle speaks of it as a long-term replacement for CMS, and in the Open JDK they even <a href="http://openjdk.java.net/jeps/248">seriously consider</a> it for the role of the default collector for server configurations in version 9. <br><br>  All this is obviously worth it to deal with his device.  Let's not postpone. <br><br>  G1 is enabled with the Java option -XX: + UseG1GC. <br><br><h3>  Work principles </h3><br>  The first thing that catches your eye when considering the G1 is a change in the approach to organizing the heap.  Here, the memory is divided into many regions of the same size.  The size of these regions depends on the total heap size and is selected by default so that there are no more than 2048 of them, usually between 1 and 32 MB.  The only exceptions are the so-called <i>huge (humongous) regions</i> , which are created by combining ordinary regions to accommodate very large objects. <br><br>  The division of regions into Eden, Survivor and Tenured in this case is logical, regions of one generation are not obliged to go in succession and can even change their affiliation to one or another generation.  An example of dividing a heap into regions might look like this (the number of regions is greatly diminished): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/34d/781/181/34d781181f5e4481be98557899ae0cf2.png" width="460" height="90" alt="Regions of the collector G1 GC"></div><br>  Small assemblies are performed periodically to clean the younger generation and transfer objects to the Survivor regions, or raise them to the older generation with transfer to Tenured.  Several threads are working on transferring objects, and during this process, the main application stops working.  This is an approach already familiar to us from the collectors discussed earlier, but the difference is that cleaning is not performed on all generations, but only on parts of the regions that the collector can clean without exceeding the desired time.  At the same time, he chooses for cleaning those regions in which, in his opinion, the greatest amount of garbage has accumulated and the cleaning of which will bring the greatest result.  From here just name Garbage First - garbage first of all. <br><br>  And with the complete assembly (more precisely, here it is called <i>mixed (mixed)</i> ) everything is a bit more clever than in the previously discussed collectors.  In G1, there is a process called the <i>marking cycle</i> , which works in parallel with the main application and makes a list of living objects.  Except for the last point, this process looks familiar to us: <br><ol><li>  Initial mark.  Mark the roots (with the main application stopped) using information obtained from small assemblies. </li><li>  Concurrent marking.  Marking all living objects in a heap in several streams, in parallel with the operation of the main application. </li><li>  Remark.  Additional search of previously not taken into account living objects (with the main application stopped). </li><li>  Cleanup.  Clearing of auxiliary structures for keeping track of links to objects and searching for empty regions that can already be used to place new objects.  The first part of this step is performed when the main application is stopped. </li></ol><br>  It should be borne in mind that G1 uses the Snapshot-At-The-Beginning (SATB) algorithm to obtain a list of live objects, that is, all objects that were at the time the algorithm started working, plus all objects created during its implementation.  This, in particular, means that G1 admits the presence of floating debris, which we met when considering the CMS collector. <br><br>  After the end of the tagging cycle, G1 switches to performing mixed assemblies.  This means that with each assembly, a certain number of older regions are added to the set of younger generation regions to be cleaned.  The number of such assemblies and the number of cleaned regions of the older generation is selected based on the statistics of previous assemblies available to the collector so as not to go beyond the required assembly time.  Once the collector has cleared enough memory, it switches back to the small build mode. <br><br>  The next cycle of tagging and, as a result, the next mixed assemblies will be launched when the heap occupancy exceeds a certain threshold. <br><br>  The mixed garbage collection in the above heap example can go like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8ee/d12/62d/8eed1262d47a407a9f64f2df8635bdb6.png" width="460" height="200" alt="Mixed build in G1 GC"></div><br>  It may be that in the process of cleaning the memory in the heap there are no free regions to which the surviving objects could be copied.  This leads to the situation of <i>allocation (evacuation) failure</i> , the similarity of which we saw in the CMS.  In this case, the collector performs a full garbage collection throughout the heap when the main application threads are stopped. <br><br>  Based on the already mentioned statistics about previous builds, G1 can change the number of regions assigned to a certain generation in order to optimize future builds. <br><br><h3>  Giants </h3><br>  At the beginning of the G1 story, I mentioned the existence of vast regions in which so-called <i>humongous objects</i> are stored.  From the point of view of the JVM, any object larger than half of the region is considered huge and is treated in a special way: <br><ul><li>  It never moves between regions. </li><li>  It can be removed as part of a tagging cycle or full garbage collection. </li><li>  In the region, occupied by a huge object, no one else is hooked, even if there is space left in it. </li></ul><br>  In general, these points sometimes have far-reaching consequences.  Large objects, especially short-lived ones, can cause a lot of inconvenience to all types of assemblers, since they are not removed with small assemblies, but occupy precious space in older regions (remember the accelerated objects discussed in the previous chapter?) But G1 is more vulnerable to them the negative impact due to the fact that even an object of several megabytes (and in some cases 500 KB) is already enormous for it.  The <a href="http://habrahabr.ru/post/269707/">commentary</a> on the previous article gives an example of such a <a href="https://wiki.apache.org/solr/ShawnHeisey">problem with Solr</a> . <br><br>  In the continuation of this series of articles, we will see how to deal with this. <br><br><h3>  STW situations </h3><br>  If to summarize, then at G1 we get STW in the following cases: <br><ol><li>  The process of transferring objects between generations.  To minimize such pauses, G1 uses several threads. </li><li>  The short phase of the initial tagging of roots within the tagging cycle. </li><li>  A longer pause at the end of the remark phase and at the beginning of the cleanup phase of the tagging cycle. </li></ol><br><br><h3>  Customization </h3><br>  Since the main goal of the G1 collector is to minimize pauses in the operation of the main application, then the main option for setting it up can be considered to be already encountered by us <i><nobr>-XX: MaxGCPauseMillis =?</nobr></i>  that sets the maximum time for a one-time garbage collection acceptable to us.  Even if you are not going to set this property, at least check its default value.  Although the Oracle documentation states that the default build time is not limited, but in fact this is not always the case. <br><br>  Options <i><nobr>-XX: ParallelGCThreads =?</nobr></i>  and <i><nobr>-XX: ConcGCThreads =?</nobr></i>  specify the number of threads to be used for garbage collection and for executing a mark cycle, respectively. <br><br>  If you are not satisfied with the automatic selection of the size of the region, you can set it manually using the <i><nobr>-XX</nobr></i> option <i><nobr>: G1HeapRegionSize =?</nobr></i>  .  The value should be a power of two, if measured in megabytes.  For example, <i><nobr>-XX: G1HeapRegionSize = 16m</nobr></i> . <br><br>  If desired, you can change the heap full threshold, at which a mark cycle is initiated and the transition to the mixed assembly mode is initiated.  This is done with the <i><nobr>-XX</nobr></i> option <i><nobr>: InitiatingHeapOccupancyPercent =?</nobr></i>  that takes a percentage.  By default, this threshold is 45%. <br><br>  If you decide to go deeper into the G1 settings, you can turn on additional features with the <i><nobr>-XX</nobr></i> options <i><nobr>: + UnlockExperimentalVMOptions</nobr></i> and <i><nobr>-XX: + AggressiveOpts</nobr></i> and play with the experimental settings. <br><br><h3>  Advantages and disadvantages </h3><br><img src="https://habrastorage.org/files/e79/01f/3f5/e7901f3f5c034208a06145d1c2d1afbd.png" width="300" height="184" align="right" alt="G1 duke">  In general, it is believed that the G1 collector more accurately predicts the size of pauses than the CMS, and better distributes assemblies in time to prevent long application stops, especially for large heap sizes.  However, he is deprived of some other shortcomings of the CMS, for example, it does not fragment the memory. <br><br>  The price paid for the advantages of G1 are the processor resources, which it uses to perform a fairly large part of its work in parallel with the main program.  As a result, application bandwidth suffers.  The default target bandwidth for G1 is 90%.  For Parallel GC, for example, this value is 99%.  This, of course, does not mean that throughput with G1 will always be almost 10% less, but this feature should always be kept in mind. <br><br><br>  So we have disassembled the algorithms of all four garbage collectors in the HotSpot virtual machine.  In the next article we will try to figure out how this knowledge can be used to optimize the operation of applications. <br><br>  <i>Previously:</i> <br>  <a href="http://habrahabr.ru/post/269707/">‚Üê Part 2 - Serial GC and Parallel GC assemblers</a> <br>  <a href="http://habrahabr.ru/post/269621/">‚Üê Part 1 - Introduction</a> </div><p>Source: <a href="https://habr.com/ru/post/269863/">https://habr.com/ru/post/269863/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269851/index.html">Is multiprocessing possible in UEFI?</a></li>
<li><a href="../269853/index.html">Seven HTTP / 2 Implementation Tips</a></li>
<li><a href="../269857/index.html">News Digest for iOS Developers</a></li>
<li><a href="../269859/index.html">Meeting with Jon von Tachner in Moscow</a></li>
<li><a href="../269861/index.html">Top 10 Systems Scaling Errors</a></li>
<li><a href="../269865/index.html">Finding problems when connecting remote subscribers and VoIP-operators through 3CX Firewall Checker</a></li>
<li><a href="../269869/index.html">DBMS Linter Bastion Successfully Tested on ReactOS</a></li>
<li><a href="../269871/index.html">Simplify asynchronous JavaScript code using asynchronous functions from ES2016</a></li>
<li><a href="../269873/index.html">Digest: What we taught the search for this summer</a></li>
<li><a href="../269875/index.html">Sort without if</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>