<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Public Key Infrastructure: Certification Center based on the OpenSSL utility, SQLite3 and Tcl / Tk</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If one of the main objects of the public key infrastructure (PKI) are X509 certificates, then the central subject of the PKI is the Certification Auth...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Public Key Infrastructure: Certification Center based on the OpenSSL utility, SQLite3 and Tcl / Tk</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ls/ad/p3/lsadp3waqmp-clqe0rr1xwbd6ro.png" align="left" alt="image">  If one of the main objects of the public key infrastructure (PKI) are X509 certificates, then the central subject of the PKI is the Certification Authority (CA).  It is CAs that issue certificates, terminate their validity (certificate revocation), confirm their validity.  On the <a href="https://habrahabr.ru/">Habrahabr</a> pages you can find various publications on the issue of issuing digital certificates using <a href="https://www.openssl.org/">OpenSSL</a> . <a name="habracut"></a>  These articles mainly cover the use <a href="https://habrahabr.ru/post/192446/">of the openssl utility</a> , describe its command-line interface and work with files that store everything: keys, requests, certificates, including the root one, etc.  But if you develop a full-scale certifying center (CA) based on OpenSSL, then it is natural to want to get rid of this variety of files and go to work with databases, and also have a graphical interface for issuing and managing certificates.  And if you remember the Federal Law of April 6, 2011.  No. 63- ‚ÄúOn electronic signature‚Äù, it is necessary for the TC to comply with the requirements of this law, as well as the ‚ÄúRequirements for the form of a qualified certificate of an electronic signature verification key‚Äù approved by order of the Federal Security Service of Russia No. 795 of December 27, 2011. <br>  Ordinary citizens have the impression that the CA is something huge (as is the Center, almost like the Flight Control Center). <br><img src="https://habrastorage.org/webt/b5/3v/g7/b53vg7cflxhkndwjyavz3ppfcuy.png" align="right" alt="image">  From the point of view of responsibility, the TC is exactly that.  After all, certificates issued by CA, in fact, today are equated in the passport. <br>  From a programmer point of view, it's not so scary.  Thus was born the project CAFL63 certification center.  The implementation of the CAFL63 project is based on three ‚Äúwhales‚Äù, namely OpenSSL, <a href="https://ru.wikipedia.org/wiki/SQLite">SQLite3</a> and <a href="https://habrahabr.ru/post/343930/">Tcl / Tk</a> . <br>  So, what is the Certification Authority today?  First of all, it is the Registration Center, where representatives of legal entities, individuals, and individual entrepreneurs come for certificates with a package of necessary documents, in particular, the identity and credentials of the applicant.  They can come with <a href="https://habr.com/post/412993/">ready-made applications</a> in electronic form.  In the CR, they check documents, the request (the filled-in data, the correctness of the electronic signature, etc.), and, if everything went well, accept the request, approve it and send it to the Certification Authority (CA).  But this is the ideal.  In practice, everything looks different. <br>  Citizens, organizations need a certificate (for access to the <a href="https://geektimes.ru/post/280268/">portal of</a> state services, for tax reporting, to participate in the auction), but they do not know what it is and what to do with it.  They are sincerely convinced that in CA receive an electronic signature like facsimile.  But these are problems of enlightenment.  Therefore, applicants come to the CR TC, submit documents.  Together with a staff member of the CR, they go to a separate workplace and <a href="https://habr.com/post/412993/">prepare a</a> certificate <a href="https://habr.com/post/412993/">request</a> . <br><br><img src="https://habrastorage.org/webt/-i/ni/fr/-inifrinlnabszqrmm9w11vpz98.png"><br><br>  A prepared request on electronic media, as already mentioned, is submitted to the CR.  What should the applicant remember?  The first and most important thing is to pick up the carrier with the created private key! <br>  The approved request on electronic media is transmitted to the CA where the certificate will be issued on its basis. <br>  This is a schematic diagram of the TC.  Details will become clear below.  One note, in order to facilitate the demonstration of the request preparation utility, the CR and the CA are combined into one demonstration complex.  But there are no problems with the separation of the functional.  The easiest of them is to have a copy of CAFL63 at each workplace and use only the required functionality. <br>  When the project was in full swing, the <a href="http://users.skynet.be/ballet/joris/SimpleCA/">SimpleCA</a> project <a href="http://users.skynet.be/ballet/joris/SimpleCA/">came across</a> .  The study of this project was very helpful in the final implementation of CAFL63. <br>  The distribution kit for the Win32 / Win64, Linux_x86 / Linux_x86_64 platforms, in addition to the CAFL63 source code, includes the README.txt file.  After downloading the distribution package, you should carefully read the README.txt file. <br>  So, run the CAFL63 utility and the start page appears on the screen: <br><img src="https://habrastorage.org/webt/ej/d4/6z/ejd46z3sdsymivi7ougryho9q-g.png"><br>  We start the work by pressing the ‚ÄúCreate DB‚Äù button.  The CA database is created by means of the <a href="https://ru.wikipedia.org/wiki/SQLite">SQLite3</a> cross-platform database management system.  DB CA contains several tables.  The main table mainDB contains only one record in which the root certificate is stored, the private key is encrypted with the password, and the CA settings.  There are two tables related to certificate requests: current reqDB requests and the reqDBArc query archive.  Three tables are created for certificates: a table of certDBNew new certificates, a certDB certificate archive table and a certDBRev certificate revocation table: <br><pre><code class="sql hljs">. . . certdb eval {<span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> certDB( ckaID <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> , nick <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, sernum <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, certPEM <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, subject <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, notAfter <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, notBefore <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, dateRevoke <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, state <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> )} certdb eval {<span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> certDBRev( ckaID <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> )} certdb eval {<span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> certDBNew( ckaID <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> )} certdb eval {<span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reqDB (ckaID <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, nick <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, sernum <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, subject <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, datereq <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">status</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, reqpem <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, pkcs7 <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>)} certdb eval {<span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reqDBAr (ckaID <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, nick <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, sernum <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, subject <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, datereq <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">status</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, reqpem <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, pkcs7 <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>)} certdb eval {<span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> crlDB(<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> autoincrement, signtype <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, issuer <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, publishdate <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, nextdate <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, crlpem <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>)} . . .</code> </pre> <br>  All request and certificate tables use <a href="https://habrahabr.ru/post/316328/">the hash value</a> (sha1) of the public key as the primary key.  For convenience, the hash value from the public key value will be called CKAID (PKCS # 11 terminology).  This turned out to be very convenient, for example, when searching for a certificate on request or vice versa.  There is another crlDB table in the database that stores lists of revoked certificates. <br>  The value of the public key is stored both in the request and in the certificate.  Therefore, before putting them into the database, it is necessary to extract the public key from them and calculate the CKAID.  To retrieve the value of the public key, it is convenient to use the pki package (package require pki), which contains tools for working with certificates and requests.  However, this package is not designed to work with Russian cryptography.  In this regard, on the basis of parse_cert and parse_csr procedures included in the pki package, write the procedures parce_cert_gost and parse_csr_gost: <br><pre> <code class="plaintext hljs">... ## Convert Pubkey type to string set pubkey_type [::pki::_oid_number_to_name $pubkey_type] # Parse public key, based on type switch -- $pubkey_type { "rsaEncryption" { set pubkey [binary format B* $pubkey] binary scan $pubkey H* ret(pubkey) ::asn::asnGetSequence pubkey pubkey_parts ::asn::asnGetBigInteger pubkey_parts ret(n) ::asn::asnGetBigInteger pubkey_parts ret(e) set ret(n) [::math::bignum::tostr $ret(n)] set ret(e) [::math::bignum::tostr $ret(e)] set ret(l) [expr {int([::pki::_bits $ret(n)] / 8.0000 + 0.5) * 8}] set ret(type) rsa } "1.2.643.2.2.19" - "1.2.643.7.1.1.1.1" - "1.2.643.7.1.1.1.2" { # gost2001, gost2012-256,gost2012-512 set pubkey [binary format B* $pubkey] binary scan $pubkey H* ret(pubkey) set ret(type) $pubkey_type ::asn::asnGetSequence pubkey_algoid pubalgost #OID -  ::asn::asnGetObjectIdentifier pubalgost oid1 #OID -   ::asn::asnGetObjectIdentifier pubalgost oid2 } default { error "Unknown algorithm" } } ...</code> </pre> <br>  Unlike native procedures, they allow working with objects not only in the PEM format, but also in the DER format.  To work with the lists of revoked CRL certificates, the parse_crl procedure was written.  All these procedures can be found in the source code. <br>  Also in the pki package there are no Russian oids, for example, an INN, SNILS, etc.  This problem is easily solved by adding Russian oids to the array :: pki :: oids: <br><pre> <code class="plaintext hljs">. . . set ::pki::oids(1.2.643.100.1) "OGRN" set ::pki::oids(1.2.643.3.141.1.1) "OGRNIP" set ::pki::oids(1.2.643.3.131.1.1) "INN" set ::pki::oids(1.2.643.100.5) "SNILS" #  set ::pki::oids(1.2.643.2.2.3) "  34.10-2001" set ::pki::oids(1.2.643.7.1.1.3.2) "  34.10-2012-256" set ::pki::oids(1.2.643.7.1.1.3.3) "  34.10-2012-512" . . .</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Having functions parse_cert_gost and parse_csr_gost, the CKAID values ‚Äã‚Äã(primary key for the database) are calculated as follows: <br><pre> <code class="plaintext hljs">. . . array set b [parse_csr_gost $req] set pem $b(pem) set subject $b(subject) set pubkey $b(pubkey) set key1 [binary format H* $pubkey] set ckaID [::sha1::sha1 $key1] . . .</code> </pre> <br>  So, press the button "Create DB": <br><img src="https://habrastorage.org/webt/fj/uh/3q/fjuh3qvrwugzxspgjchbonu9is0.png"><br>  Creating a CA begins with the selection of a directory in which we will store the database and set a password for access to the CA's private key.  The CAFL63 utility closely monitors the length of the password: <br><img src="https://habrastorage.org/webt/dw/eb/hf/dwebhfn5hqfjh8bv3jge5jxllx8.png"><br>  The password is stored in the database CA as a hash: <br><pre> <code class="plaintext hljs">. . . set hash256 [::sha2::sha256 $wizData(capassword)] . . .</code> </pre> <br>  After pressing the ‚ÄúNext‚Äù key, the process of forming the self-signed root certificate of the CA being deployed begins.  At the first step of this process, the type and parameters of the key pair are selected: <br><img src="https://habrastorage.org/webt/zr/e4/ag/zre4agh8ilw-tvjiy354y_o337c.png"><br>  Having decided on the key pair for the root certificate of the certifying center being created, we proceed to filling out the form with information about the owner (the first screenshot is omitted). <br>  Note that the CAFL63 utility has a certain ‚Äúintelligence‚Äù and therefore controls not only the availability of data in the fields, but also the correctness (red highlighting is incorrect) of filling in such fields as TIN, OGRN, SNILS, OGRNP, ‚Äã‚Äãe-mail address, etc .: <br><img src="https://habrastorage.org/webt/4o/pt/vr/4optvrvc8o6gfd413eh5ggshby4.png"><br>  After filling in the fields with information about the CA owner, you will be asked to decide on the system settings of the CA: <br><img src="https://habrastorage.org/webt/it/wq/nc/itwqnccdburbtmsdybckzdqf1u8.png"><br>  If you are not going to work with Russian cryptography, you can use regular OpenSSL.  To work with Russian cryptography, you must select the appropriate version, a modification of OpenSSL.  Read more in README.txt in the downloaded distribution.  Since it is planned to issue qualified certificates, it is also necessary to provide information on certification of the CA itself and the SKPI used by it (see ‚ÄúRequirements for the form of a qualified certificate of the electronic signature verification key‚Äù, approved by order of the Federal Security Service of Russia of 27.12.2011 No. 795). <br>  After all the fields are filled in correctly, you will be asked once again to check their accuracy and click the ‚ÄúFinish‚Äù button: <br><img src="https://habrastorage.org/webt/zo/pd/xf/zopdxfb8rtzcvoei5xuvpt7udqe.png"><br>  After clicking the ‚ÄúFinish‚Äù button, the CA database will be created, in which the CA root certificate, private key, system settings will be saved, and the start page of the CAFL63 utility will reappear on the screen.  Now, when we have created a newly created CA database, we press the "Open DB" button, select the database directory, go to the CA main working window and click the "View CA CA" button, make sure that the root certificate we created : <br><img src="https://habrastorage.org/webt/w3/qh/bx/w3qhbxnxzgu2gs_p0rlk0zpdi6g.png"><br>  As a next step, we prepare application templates / profiles for legal entities, individuals, individual entrepreneurs ( <b><i>Tools-&gt; Settings-&gt; Types of Certificates-&gt; New</i></b> ): <br><img src="https://habrastorage.org/webt/np/th/gp/npthgpo6g7ojlqapo_q1nd-vxts.png"><br>  After specifying the name of a new profile, you will be asked to determine its composition: <br><img src="https://habrastorage.org/webt/bf/yc/g_/bfycg_oxromnvlpisghe64bbuwe.png"><br>  The composition of the profile determines the distinguished name (distinguished / unique name of the certificate holder).  Each profile has its composition with the required (required) or not fields / oid-s.  The composition of the profile for legal entities, individuals, individual entrepreneurs is determined by the requirements of FZ-63 and the ‚ÄúRequirements for the form of a qualified electronic signature verification key certificate‚Äù of the FSB of Russia. <br>  After the preparation of profiles, the TC is ready to receive applicants and applications from them.  As noted above, the applicant can come either with a finished application for a certificate or without it. <br>  If the applicant came with a finished application, then after checking his documents, the application is imported into the CA database.  To do this, on the main working window, select the ‚ÄúRequests for certificates‚Äù tab, click the ‚ÄúImport request / CSR‚Äù button and select the file with the request.  After that, a window will appear with information from the request: <br><img src="https://habrastorage.org/webt/pd/5e/0j/pd5e0j71rr7impjascnjq8lsnws.png"><br>  After reviewing the request and making sure that it is filled in correctly, you can click the ‚ÄúImport‚Äù button to enter it into the database.  Immediately, we note that when trying to re-submit a request to the CA database, a message will be displayed: <br><img src="https://habrastorage.org/webt/ih/dy/q_/ihdyq_rplawbuh56jkw2czs8cto.png"><br>  Requests to the CA database are marked (column ‚ÄúType‚Äù) either as ‚ÄúLocale‚Äù, created in the registration center, or as ‚ÄúImport‚Äù, created by the applicant himself, and the time of receipt of the application to the CA is recorded.  This can be useful when analyzing conflict situations.  Therefore, when importing a certificate request, you should indicate who created the request (see screenshot). <br>  The imported application is located in the database of the CA and is displayed on the main window on the ‚ÄúRequests for Certificates‚Äù tab.  Received requests are in the ‚Äúreview‚Äù stage (the ‚ÄúStatus‚Äù column of the ‚ÄúCertificate Requests‚Äù tab and the ‚ÄúRequest Archive‚Äù tab).  For each new request, a decision must be made (a drop-down menu when you right-click on the selected request): <br><img src="https://habrastorage.org/webt/lo/re/of/loreoftotutxheoyl1khmlhdqqq.png"><br>  Each request must be either denied or approved: <br><img src="https://habrastorage.org/webt/hx/al/pt/hxalptjfajymsui_5xmtpxqnemc.png"><br>  If the request is rejected, it is moved from the table of current requests reqDB to the table of requests archive reqDBArc and, accordingly, disappears on the tab ‚ÄúRequests for certificates‚Äù and appears on the tab ‚ÄúArchive of Requests‚Äù. <br>  The approved application remains in the reqDB table and on the ‚ÄúRequests for Certificates‚Äù tab until the certificate is issued, and then it is also archived. <br>  Before issuing a certificate, it is necessary, along with the applicant, to clarify for what purposes (for example, to access the Government services <a href="https://geektimes.ru/post/280268/">portal</a> ) the certificate will be used ( <b><i>Tools-&gt; Settings-&gt; Types of Certificates -&gt; Personal Face -&gt; Edit -&gt; Key Usage</i></b> ): <br><img src="https://habrastorage.org/webt/db/-i/os/db-iosyzs3xw2g-rh3sx_jeqxh4.png"><br>  To issue a certificate, select the approved application on the ‚ÄúRequests for Certificates‚Äù tab, right-click and in the drop-down menu when you select ‚ÄúIssue certificate‚Äù.  In the appeared widget it will be necessary to select a profile to which the request / certificate profile should correspond: <br><br><img src="https://habrastorage.org/webt/tl/b6/x0/tlb6x0l6lk9i8c01qnyvqma-4si.png"><br><br>  Note that in the process of issuing a certificate, you can clarify the values ‚Äã‚Äãof a field: <br><img src="https://habrastorage.org/webt/ys/zu/1p/yszu1pjuyu5nfhpsg_lak9dvqda.png"><br><br>  The procedure for issuing a certificate itself (the menu item ‚ÄúIssue a certificate‚Äù) differs little from the procedure for creating a root certificate or issuing a certificate: <br><img src="https://habrastorage.org/webt/k6/2e/us/k62eushimzzwin4y-fpmgh3afoe.png"><br>  The issued certificate will immediately appear on the Certificates tab.  At the same time, the certificate itself enters the certDBNew database of the CA database and remains there until it is published.  A certificate is considered published after it is exported to a SQL-dump of new certificates, which is transferred to a public service.  Publishing a certificate causes it to be moved from the certDBNew table to the certDB table. <br>  If you right-click on the selected line in the Certificates tab, a menu with functions will appear: <br><img src="https://habrastorage.org/webt/kh/ep/qp/khepqp1swgn82wechv_ieqg_zfq.png"><br>  These functions allow you to view both the certificate itself and the request on the basis of which it was issued.  You can also export the certificate to a file or to the applicant's flash drive.  The most important function here is the certificate revocation function!  There is also such an exotic function as exporting a certificate to a secure container PKCS # 12.  It is used when the applicant wants such a container.  For such applicants, the function of generating a request with preservation of the private key in the file is specially provided (the button ‚ÄúCreate a request / CSR‚Äù on the tab ‚ÄúRequests for certificates‚Äù). <br>  So, TC started his life, issued the first certificate.  One of the tasks of the CA is the organization of free access to the issued certificates.  The publication of certificates usually goes through Web-services.  There is such a service and CAFL63: <br><img src="https://habrastorage.org/webt/xt/a7/6w/xta76wp2bsjapckltfuqkl0pr2y.png"><br>  To publish certificates and certificate revocation lists on a public service, the TC pre-uploads certificates or files ( <b><i>Certificates-&gt; Export Certificates</i></b> ), or SQL-dumps the entire certificate table, from which you can create a database of certificates and upload them to it. SQL-dump of new certificates from which they will be added to the public service database: <br><img src="https://habrastorage.org/webt/he/_d/1n/he_d1nxytwkmjwe-skvpzlzadig.png"><br>  The last screenshot was made on the Windows platform and clearly demonstrates the cross-platform database of the CA: it was simply copied from the Linux platform. <br>  The core function of a CA is to publish a list of revoked certificates, in the same way as the Ministry of Internal Affairs does regarding invalid passports.  The certificate can be revoked at the request of the owner.  The main reason for revocation is the loss of the private key or loss of trust in it. <br>  To revoke a certificate, just select it in the Certificates tab, right-click and select the Certificate Revocation menu item: <br><img src="https://habrastorage.org/webt/ai/7p/hk/ai7phklvqrbu1a0z7yl-xi-5xxw.png"><br>  The revocation procedure is no different from the procedure for approving a request or issuing a certificate.  The revoked certificate enters the cerDBRev table of the CA database and appears in the "Revoked Certificates" tab. <br>  It remains to consider the last function of the CA - issue CRL - list of revoked certificates.  The CRL list is formed on the ‚ÄúRevoked Certificates‚Äù tab when you click the ‚ÄúCreate COC / CRL‚Äù button.  All that is required from the administrator is to enter the password of the CA and confirm its intention to release the CRL: <br><img src="https://habrastorage.org/webt/w3/ls/ym/w3lsymkh2ylhp0tqoyx3ejlbxya.png"><br>  The released CRL enters the crlDB database table and is displayed on the CRL / SOS tab.  To parse the CRL before it is placed in the database, the parse_crl procedure was written: <br><pre> <code class="plaintext hljs">proc parse_crl {crl} { array set ret [list] if { [string range $crl 0 9 ] == "-----BEGIN" } { array set parsed_crl [::pki::_parse_pem $crl "-----BEGIN X509 CRL-----" "-----END X509 CRL-----"] set crl $parsed_crl(data) } ::asn::asnGetSequence crl crl_seq ::asn::asnGetSequence crl_seq crl_base ::asn::asnGetSequence crl_base crl_full ::asn::asnGetObjectIdentifier crl_full ret(signtype) #puts "KEY_TYPE=$ret(signtype)" ::::asn::asnGetSequence crl_base crl_issue set ret(issue) [::pki::x509::_dn_to_string $crl_issue] #puts "ISSUE=$ret(issue)" ::asn::asnGetUTCTime crl_base ret(publishDate) ::asn::asnGetUTCTime crl_base ret(nextDate) #puts "publishDate=$ret(publishDate)" return [array get ret] }</code> </pre> <br>  To view the CRL or export it for publication on a public service, you must always select the desired line, right-click and select the menu item: <br><img src="https://habrastorage.org/webt/np/c7/f2/npc7f2i1qb_rvyreerzj6wrbjgc.png"><br>  That's all. </div><p>Source: <a href="https://habr.com/ru/post/352790/">https://habr.com/ru/post/352790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352776/index.html">What's new in LLVM</a></li>
<li><a href="../352778/index.html">Does the manager need to be able to program</a></li>
<li><a href="../352782/index.html">Debugging multithreaded programs based on FreeRTOS</a></li>
<li><a href="../352784/index.html">ESET: Turla Mosquito backdoor used in Eastern Europe</a></li>
<li><a href="../352786/index.html">How to use Azure for free (life hacking for students)</a></li>
<li><a href="../352792/index.html">Conference DEFCON 22. ‚ÄúTraveling on the dark side of the Internet. Introduction to Tor, Darknet and Bitcoin ¬ª</a></li>
<li><a href="../352794/index.html">Generative adversarial networks</a></li>
<li><a href="../352798/index.html">Reality of reuse</a></li>
<li><a href="../352800/index.html">Release Rust 1.25</a></li>
<li><a href="../352802/index.html">Intel Summer School 0x7E2 - there is a reason to learn</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>