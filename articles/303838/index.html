<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Search for connections in social networks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! In this post we want to share our solution to the problem of predicting hidden connections in the Beeline corporate social network ‚ÄúBeehive‚Äù...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Search for connections in social networks</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  In this post we want to share our solution to the problem of predicting hidden connections in the Beeline corporate social network ‚ÄúBeehive‚Äù.  We solved this task in the framework of the <a href="http://www.forbes.ru/sp/microsoft/">Microsoft</a> virtual hackathon.  I must say that before this hackathon, our team already had successful experience in solving such tasks on the hackathon from <a href="http://snahackathon.org/">Odnoklassniki</a> and we really wanted to try out our developments on new data.  In the article we will tell about the main approaches that are used in solving such problems and share the details of our solution. <br><a name="habracut"></a><br><h2>  Task setting and baseline data </h2><br>  Development of a high-quality algorithm for recommending friends is one of the top priorities for almost any social network because  This functionality is a powerful tool to engage and retain users. <br><br>  In the English literature there are quite a lot of publications on this topic, and the task itself even has a special abbreviation PYMK (People You May Know). <br><br>  The Beeline company in the framework of the <a href="http://www.forbes.ru/sp/microsoft/">virtual hackathon from Microsoft</a> provided the graph of the corporate social network "Beehive".  5% of the edges in the graph was artificially hidden.  The task was to find the hidden edges of the original graph. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img width="600" src="https://habrastorage.org/files/e27/a52/544/e27a525448d04203b7b774f0e8930fef.png"></div><br><br>  In addition to having a connection between social network users, for each pair, information was also provided on the companies in which the users work, information on the number of sent and received messages, the duration of calls and the number of sent and received documents. <br><br>  The problem of searching for edges is formulated as a binary classification problem, and the measure <a href="https://en.wikipedia.org/wiki/F1_score">F1</a> was proposed as an acceptance metric.  In some such tasks, the quality metric is considered separately for each user and the average is evaluated.  In this task, the quality was evaluated globally for all edges. <br><br><h2>  Training and test </h2><br>  In the general case, to search for hidden edges in a graph, it is necessary to iterate all possible pairs of vertices and for each pair to obtain an estimate of the probability of a link. <br><br>  For large graphs, this approach will require a lot of computational resources.  Therefore, in practice, many candidates in social graphs are limited only to pairs that have at least one friend in common.  As a rule, such a restriction allows to significantly reduce the amount of computation and speed up the work of the algorithm without a significant loss in quality. <br><br>  Each pair of candidates is described by a feature vector and a binary answer: ‚Äú1‚Äù if there is an edge or ‚Äú0‚Äù if there is no edge.  On the obtained set {feature vector, answer}, a model is taught that predicts the probability of the presence of an edge for a pair of candidates. <br><br>  Since  if the graph in this problem is not directed, then the feature vector should not depend on the rearrangement of candidates in the pair.  This property allows for training to take into account a couple of candidates only once and to reduce the size of the training sample by half. <br><br>  To answer the question of exactly which edges are hidden in the original graph, the probability estimate at the output of the model must be turned into a binary answer, choosing the appropriate threshold value. <br><br>  To assess the quality and selection of model parameters, we removed 5% of randomly selected edges from the provided graph.  The remaining graph was used to search for candidates, generate traits and train the model.  Hidden edges used for the selection of the threshold and the final quality assessment. <br><br>  The following describes the main approaches for generating features in the PYMK task. <br><br><h2>  Counters </h2><br>  For each user, we consider statistics: the distribution of friends by geography, community, age or sex.  Using these statisticians, we obtain an estimate of the similarity of the candidates to each other, for example, using a scalar product. <br><br><h4>  Similarity sets and common friends </h4><br>  <b><a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D1%258D%25D1%2584%25D1%2584%25D0%25B8%25D1%2586%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582_%25D0%2596%25D0%25B0%25D0%25BA%25D0%25BA%25D0%25B0%25D1%2580%25D0%25B0">Jacquard</a> Coefficient</b> - allows you to evaluate the similarity of the two sets.  As sets there can be friends as well, for example, and communities of candidates. <br><div style="text-align:center;"><img width="380" src="https://habrastorage.org/files/c90/50c/cbe/c9050ccbe44342e99518fe5c287b9de9.png"></div><br><br>  <b>The <a href="http://www.hpl.hp.com/research/idl/papers/web10/fnn2.pdf">Adamik / Adar</a> coefficient</b> is essentially a weighted sum of the mutual friends of the two candidates. <br><div style="text-align:center;"><img width="420" src="https://habrastorage.org/files/9c6/811/915/9c6811915a3e4dd4aeb5eac07b41c7d0.png"></div><br>  The weight in this amount depends on the number of friends of the mutual friend.  The less friends a mutual friend has, the greater his contribution to the resulting amount.  By the way, we actively used this idea in our decision. <br><br><h4>  Latent factors </h4><br>  These features are the result of matrix expansions.  Moreover, expansions can be applied both to the matrix of relations between users, and to the community matrix ‚Äî the user, or geography ‚Äî the user and the like.  The resulting decomposition of a vector with latent signs can be used to assess the similarity of objects to each other, for example, using a <a href="https://en.wikipedia.org/wiki/Cosine_similarity">cosine</a> distance <a href="https://en.wikipedia.org/wiki/Cosine_similarity">measure</a> . <br><br>  Perhaps the most common algorithm for matrix decomposition is <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BD%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">SVD</a> .  You can also use <a href="http://wanlab.poly.edu/recsys12/recsys/p83.pdf">ALS</a> and the community search algorithm in <a href="https://cs.stanford.edu/people/jure/pubs/bigclam-wsdm13.pdf">BigCLAM</a> graphs, <a href="https://cs.stanford.edu/people/jure/pubs/bigclam-wsdm13.pdf">which is</a> popular in recommender systems. <br><br><h4>  Signs on graphs </h4><br>  This group of signs is calculated taking into account the structure of the graph.  As a rule, to save time, not the entire graph is used in calculations, but some of it, for example, a subgraph of common friends of depth 2. <br><br>  One of the popular signs is <a href="https://en.wikipedia.org/wiki/Hitting_time">Hitting Time</a> - the average number of steps required to pass a route from one candidate to another, taking into account the weights of the ribs.  The path is laid in such a way that the next vertex is chosen randomly with a probability depending on the values ‚Äã‚Äãof the attributes of the edges emanating from the current node. <br><br><h2>  Decision </h2><br>  In solving this problem, we actively used the idea of ‚Äã‚Äãthe Adamyk / Adar coefficient that not all friends are equally useful.  We experimented with the discounting function - we tried fractional degrees instead of the logarithm, and we also experimented with weighing common friends on various utility attributes. <br><br>  Since  we worked on the task in parallel, then we got two independent solutions, which were later combined for the final submission. <br><br>  The first solution is based on the Adamik / Adar idea and is an empirical formula that takes into account both the number of friends of a common friend and the flow of messages between candidates through mutual friends. <br><div style="text-align:center;"><img width="250" src="https://habrastorage.org/files/a19/c8c/e5f/a19c8ce5fb8342939e31d6fe7a9d7a02.png"></div><br>  n is the number of mutual friends; <br>  xi - the number of friends in a common friend; <br>  yi is the sum of incoming and outgoing messages between candidates through their mutual friend <br><br>  In the second solution, we generated 32 signs and trained on them the log model.  regression and random forest. <br><br>  The models from the first and second solutions were combined using another logistic regression. <br><br>  The table describes the main features that were used in the second solution. <br><table><tbody><tr><th>  sign </th><th>  description </th></tr><tr><td>  <nobr>weighted_commom</nobr> </td><td>  Analogue of the Adamik / Adar coefficient, but instead of the logarithm a third degree root was used </td></tr><tr><td>  <nobr>conductivity_common</nobr> </td><td>  We weigh mutual friends with the conductivity of messages.  The smaller the ratio of outgoing and incoming messages / calls / documents of a common friend, the higher its weight when summing up </td></tr><tr><td>  flow_common </td><td>  We evaluate the permeability of messages / calls / documents between candidates through a mutual friend.  The higher the permeability, the greater the weight in the summation </td></tr><tr><td>  friends_jaccard </td><td>  Jacquard coefficient for friends of candidates </td></tr><tr><td>  friend_company </td><td>  Similarity based on the share of friends of the user from the candidate‚Äôs company </td></tr><tr><td>  company_jaccard </td><td>  We evaluate the friendliness of candidate companies using the Jacquard coefficient (equal to one if the candidates are from the same company) </td></tr></tbody></table><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/files/1f6/29d/9f4/1f629d9f4a2d450baa32abd008653363.png"></div><br>  The table below shows the quality ratings of both the individual and the resulting models. <br><table><tbody><tr><th>  Model </th><th>  F1 </th><th>  Accuracy </th><th>  Completeness </th></tr><tr><td>  Empirical formula </td><td>  0.064 </td><td>  0.059 </td><td>  0.069 </td></tr><tr><td>  Log regression </td><td>  0.060 </td><td>  0.057 </td><td>  0.065 </td></tr><tr><td>  Random forest </td><td>  0.065 </td><td>  0.070 </td><td>  0.062 </td></tr><tr><td>  Log regression + Random Forest </td><td>  0.066 </td><td>  0.070 </td><td>  0.063 </td></tr><tr><td>  Log regression + Random Forest + Empirical formula </td><td>  0.067 </td><td>  0.063 </td><td>  0.071 </td></tr></tbody></table><br><h2>  Threshold selection </h2><br>  So, the model is trained.  The next step is to select a threshold to optimize the acceptance metric. <br><br>  In this problem, we optimized the <a href="https://en.wikipedia.org/wiki/F1_score">F1</a> metric. <br><div style="text-align:center;"><img width="300" src="https://habrastorage.org/files/c9a/43f/860/c9a43f8604574ac096410a8f0047231a.png"></div><br>  This metric is equally sensitive to both accuracy and completeness and is the harmonic average of these values. <br><br>  Since  the dependence of the F1 metric on the threshold is a convex function, then the search for the maximum is not difficult. <br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/files/e57/a80/3a8/e57a803a86c440dc834c333619c7b64c.png"></div><br>  In this problem, we used the binary search algorithm to select the optimal threshold value. <br><br><h2>  Technology </h2><br>  The source graph was defined as a list of edges with the identification of users and the corresponding attributes.  A total of 5.5 million links were represented in the training sample.  The source data is provided in the form of a text file in the csv format and occupy 163Mb on the hard disk. <br><br>  As part of the hackathon, we were provided with Azure cloud service resources under the <a href="https://www.microsoft.com/rus/microsoft4you/documents/bizspark/">Microsoft BizSpark</a> program, in which we created a virtual machine for our calculations.  The server price per hour was $ 0.2 and did not depend on the intensity of the calculations.  The budget allocated by the organizers was enough to solve this problem. <br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/files/3b9/faf/fd9/3b9faffd956d474990b45db72fe4e4a4.png"></div><br>  We implemented the search algorithm for common friends on Spark, the results of intermediate calculations were cached to disk in parquet format, which significantly reduced the time for reading data.  The running time of the search algorithm for common friends in a virtual machine was 8 hours.  Candidates with a list of common friends in the parquet format occupy 2.1GB. <br><br>  The algorithm for learning and selecting model parameters is implemented in python using the <a href="http://scikit-learn.org/">scikit-learn</a> package.  The processes of generating features, learning the model and selecting the threshold on a virtual server took about 3 hours in total. <br><br>  In conclusion, I would like to thank <a href="https://www.linkedin.com/in/%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25BD-%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B3%25D0%25B8%25D0%25BD-41735678">Ivan Bragin</a> for his active participation in solving the problem and his creativity in choosing the empirical formula. </div><p>Source: <a href="https://habr.com/ru/post/303838/">https://habr.com/ru/post/303838/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../303828/index.html">The most popular models of refurbished servers</a></li>
<li><a href="../303830/index.html">How I accelerated strstr</a></li>
<li><a href="../303832/index.html">Interview with Google Programmer Martin Horner about TensorFlow</a></li>
<li><a href="../303834/index.html">Simple graphics using D3.js</a></li>
<li><a href="../303836/index.html">What is space time really?</a></li>
<li><a href="../303840/index.html">Java library for the efficient transfer of CSS and JavaScript</a></li>
<li><a href="../303842/index.html">Neural network as a predictor for PNG image coding</a></li>
<li><a href="../303844/index.html">NetApp ONTAP & ESXi 6.x tuning</a></li>
<li><a href="../303850/index.html">Roskomnadzor blocked web services Amazon S3</a></li>
<li><a href="../303852/index.html">ALM Advisor - an online ALM-tool for assessing a planned or existing working environment.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>