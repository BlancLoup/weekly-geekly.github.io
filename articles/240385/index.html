<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Thread-safe events in C # or John Skeet vs. Jeffrey Richter</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I was preparing for an interview on C # and, among other things, I found a question similar to the following: 
 "How to organize a thread-safe event c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Thread-safe events in C # or John Skeet vs. Jeffrey Richter</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/37c/e2d/f27/37ce2df27c80407f9884af50d1cd63c2.jpg"><br><br>  I was preparing for an interview on C # and, among other things, I found a question similar to the following: <br><blockquote>  "How to organize a thread-safe event call in C #, taking into account the fact that a large number of threads constantly subscribe to the event and unsubscribe from it?" </blockquote><br><br>  The question is quite specific and clearly posed, so I didn‚Äôt even doubt that the answer to it can be given also clearly and unequivocally.  But I was very wrong.  It turned out that this is an extremely popular, hackneyed, but still open topic.  And I also noticed a not very pleasant feature - in Russian-speaking resources very little attention is paid to this issue (and Habr is no exception), so I decided to collect all the information I found and digested on this issue. <br>  We will also reach John Skeet and Jeffrey Richter, they, in fact, played a key role in my general understanding of the problem of how events work in a multi-threaded environment. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A particularly attentive reader will be able to find two xkcd-style comics in the article. <br>  (Be careful, inside there are two pictures of about 300-400 kb each) <br><a name="habracut"></a><br><br>  I duplicate the question you need to answer: <br><br><blockquote>  "How to organize a thread-safe event call in C #, taking into account the fact that a large number of threads constantly subscribe to the event and unsubscribe from it?" </blockquote><br><br>  I had an assumption that some of the questions relied on the book <b>CLR via C #</b> , especially since my favorite <b>C # 5.0 in a Nutshell</b> did not address this question at all, so let's start with Jeffrey Richter (CLR via C #). <br><br><h2>  Jeffrey Richter's Way </h2><br>  A short excerpt from written: <br><br>  For a long time, the recommended method for triggering events was approximately the following construction: <br><br>  <i>Option 1:</i> <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action MyLittleEvent; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMyLittleEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (MyLittleEvent != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) MyLittleEvent(); }</code> </pre> <br><br>  The problem with this approach is that in the <code>OnMyLittleEvent</code> method <code>OnMyLittleEvent</code> one thread can see that our <code>MyLittleEvent</code> event <code>MyLittleEvent</code> not <code>null</code> , and another thread immediately after this check, but before calling the event, can remove its delegate from the list of subscribers, and thus make our event is <code>MyLittleEvent null</code> , which will <code>NullReferenceException</code> at the place where the event was <code>NullReferenceException</code> . <br><br>  Here is a small xkcd-style comic that clearly illustrates this situation (two threads work in parallel, time goes from top to bottom): <br><div class="spoiler">  <b class="spoiler_title">Expand</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/3d0/03d/1c7/3d003d1c72a640c38457a00ab05d1ed1.png"><br></div></div><br><br>  In general, everything is logical, we have the usual <a href="http://en.wikipedia.org/wiki/Race_condition">race condition</a> (hereinafter, race condition).  And this is how Richter solves this problem (and this option is most common): <br><br>  Let's add a local variable to our event call method, into which we will copy our event at the time of ‚Äúcalling‚Äù to the method.  Since delegates are immutable objects (hereinafter referred to as immutable), we will have a ‚Äúfrozen‚Äù copy of an event that no one else can unsubscribe from.  When you unsubscribe from an event, a new delegate object is created that replaces the object in the <code>MyLittleEvent</code> field, while we still have a local reference to the <i>old</i> delegate object. <br><br>  <i>Option 2:</i> <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMyLittleEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Action tempAction = MyLittleEvent; <span class="hljs-comment"><span class="hljs-comment">// ""      //   tempAction     ,      null     if (tempAction != null) tempAction (); }</span></span></code> </pre><br><br>  Further, Richter describes that the JIT compiler may well simply omit the creation of a local variable for the sake of optimization, and make the first of the second option, that is, skip the ‚Äúfreezing‚Äù of the event.  As a result, it is recommended to do copying through <code>Volatile.Read(ref MyLittleEvent)</code> , that is: <br><br>  <i>Option 3:</i> <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMyLittleEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      Action tempAction = Volatile.Read(ref MyLittleEvent); if (tempAction != null) tempAction (); }</span></span></code> </pre><br><br>  You can talk about <code>Volatile</code> separately for a long time, but in general it ‚Äújust allows you to get rid of unwanted JIT compiler optimization‚Äù.  On this occasion, there will be more clarifications and details, but for now we will dwell on the general idea of ‚Äã‚Äãthe current decision of Jeffrey Richter: <br><br><blockquote>  To ensure a thread-safe event call, you need to ‚Äúfreeze‚Äù the current list of subscribers by copying the event into a local variable, and then, if the resulting list is not empty, call all handlers from the frozen list.  Thus we get rid of possible <code>NullReferenceException.</code> <br></blockquote><br><br>  I was immediately embarrassed by the fact that <i>we are triggering events on already unsubscribing objects / threads</i> .  It is unlikely that someone unsubscribed just like that - it is likely that someone did it during the general ‚Äúcleaning‚Äù of traces - along with closing the write / read streams (for example, the logger who was supposed to write data to the file), closing the connections etc., that is, the internal state of the subscriber object at the time its handler is called may not be suitable for further work. <br>  For example, imagine that our subscriber implements the <code>IDisposable</code> method, and follows a convention that determines that when trying to call any method on an object freed (hereinafter - disposed), it should throw an <code>ObjectDisposedException</code> .  Let's also agree that we unsubscribe from all events in the <code>Dispose</code> method. <br>  And now imagine such a scenario - we call the <code>Dispose</code> method on this object exactly after the moment when another thread ‚Äúfroze‚Äù its list of subscribers.  The thread successfully calls the handler for the unsubscribing object, and during the attempt to process the event, the object sooner or later realizes that it has already been released, and throws an <code>ObjectDisposedException</code> .  Most likely, this exception is not caught in the handler itself, because it is logical to assume: ‚ÄúIf our subscriber unsubscribed and was released, then his handler will never be called.‚Äù  There will either crash the application, or the leak of uncontrolled resuses, or the event call will be interrupted when <code>ObjectDisposedException</code> first appears (if we catch an exception when calling), but the event will not get to the normal "live" handlers. <br><br>  Let's go back to the comics.  The story is the same - two streams, time goes from the top down.  This is what actually happens: <br><div class="spoiler">  <b class="spoiler_title">Expand</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/1c8/84b/c5a/1c884bc5a121422bb54c31097ddcb118.png"><br></div></div><br><br>  This situation, in my opinion, is much more serious than a possible <code>NullReferenceException</code> when invoking an event. <br>  Interestingly, there are tips for implementing a thread-safe event call on the side of the Observed Object, and tips for implementing thread-safe Handlers are not. <br><br><h3>  What StackOverflow Says </h3><br>  On SO, you can find a <a href="http://stackoverflow.com/questions/786383/c-sharp-events-and-thread-safety">detailed ‚Äúarticle‚Äù</a> (yes, this question draws on a whole small article) on this issue. <br><br>  In general, my point of view is divided there, but this comrade adds: <br><br><blockquote>  It seems to me that all this hype with local variables is nothing more than <a href="http://en.wikipedia.org/wiki/Cargo_cult_programming">Cargo Cult Programming</a> .  A large number of people solve the problem of thread-safe events in this way, while for <b>full</b> thread safety, much more needs to be done.  I can say with confidence that those people who do not add such checks to their code can do without them.  This problem simply does not exist in a single-threaded environment, and given that in the online examples with code you can rarely find the keyword <code>volatile</code> , this additional check may well be meaningless.  If our task is to track a <code>NullReferenceException</code> , is it not possible to do without checking for <code>null</code> at all by assigning an empty <code>delegate { }</code> our event during the initialization of the class object? <br></blockquote><br><br>  This brings us to another solution. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action MyLittleEvent = <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> {};</code> </pre><br><br>  <code>MyLittleEvent</code> will never be <code>null</code> , and you can simply not do an extra check.  In a multithreaded environment, you only need to synchronize the addition and removal of event subscribers, but you can call it without fear of getting a <code>NullReferenceException</code> : <br><br>  <i>Option 4:</i> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action MyLittleEvent = <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMyLittleEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,   MyLittleEvent(); }</span></span></code> </pre><br><br>  The only disadvantage of this approach <i>compared with the previous one</i> is a small overhead on the challenge of an empty event (the overhead projector turned out to be approximately <i>5 nanoseconds</i> per challenge).  You might also think that in the case of a large number of different classes with different events, these empty ‚Äúgags‚Äù for events will take up a lot of space in RAM, but according to John Skit, in <a href="http://stackoverflow.com/a/703033/2614361">response to SO</a> , starting with version C # 3.0, the compiler uses the same the same empty delegate object for all gags.  <i>From myself I‚Äôll add that when checking the resulting IL code this statement is not confirmed, empty delegates are created bit by bit on the event (checked using LINQPad and ILSpy).</i>  In a pinch, you can make a static field common to a project with an empty delegate that can be accessed from all program sections. <br><br><h2>  The Way of John Skit </h2><br><br>  Since we got to John Skit, it is worth noting his implementation of thread-safe events, which he described in <b>C # in Depth</b> in the <b>Delegates and Events</b> section ( <a href="http://csharpindepth.com/Articles/Chapter2/Events.aspx">online article</a> and <a href="http://habrahabr.ru/post/198694/">translation of</a> Comrade <a href="https://habrahabr.ru/users/klotos/" class="user_link">Klotos</a> ) <br><br>  The bottom line is to close <code>add</code> , <code>remove</code> and local ‚Äúfreeze‚Äù in <code>lock</code> , which will get rid of possible uncertainties while simultaneously subscribing to the event of several threads: <br><br><div class="spoiler">  <b class="spoiler_title">Some code</b> <div class="spoiler_text"><pre> <code class="cs hljs">SomeEventHandler someEvent; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> someEventLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> SomeEventHandler SomeEvent { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (someEventLock) { someEvent += <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (someEventLock) { someEvent -= <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSomeEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EventArgs e</span></span></span><span class="hljs-function">)</span></span> { SomeEventHandler handler; <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (someEventLock) { handler = someEvent; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { handler (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, e); } }</code> </pre><br></div></div><br><br>  Despite the fact that this method is considered obsolete (the internal implementation of events starting from C # 4.0 looks completely different, see the list of sources at the end of the article), it clearly shows that you can‚Äôt just wrap an event call, a subscription and a reply in <code>lock</code> , because this is very likely to result in a deadlock (hereafter, deadlock).  In <code>lock</code> only copying to a local variable is found; the event itself is called outside this structure. <br><br>  But this does not completely solve the problem of calling handlers for already unsubscribing events. <br><br>  Let's return to the question on SO.  Daniel, in response to all <i>our</i> ways of preventing a <code>NullReferenceException</code> gives a very interesting thought: <br><br><blockquote>  Yes, I really figured out this advice about trying to prevent a <code>NullReferenceException</code> at all costs.  I say that in our particular case, a <code>NullReferenceException</code> can occur only if another thread unsubscribes from the event.  And he does this only to <b>never receive events again</b> , which we, in fact, <b>do not achieve</b> when using checks of local variables.  Where we <b>hide the</b> race condition we can <b>open</b> it and correct the consequences.  <code>NullReferenceException</code> allows <code>NullReferenceException</code> to determine the moment of mishandling your event.  In general, I argue that this <i>copying and verification technique</i> is a simple Cargo-cult programming that adds confusion and noise to your code, but does not solve the problem of multi-threaded events at all. <br></blockquote><br><br>  Among others, John Skit answered the question, and this is what he writes. <br><br><h2>  John Skeet vs. Jeffrey Richter </h2><br><br><blockquote>  The JIT compiler does not have the right to optimize the local reference to the delegate, because there is a condition.  This information was ‚Äúthrown in‚Äù some time ago, but this is not true (I clarified this question whether Joe Duffy or Vance Morrison).  Without the <code>volatile</code> , the possibility simply arises that the local reference to the delegate will be a bit outdated, but in general this is all.  This will not result in a <code>NullReferenceException</code> . <br><br>  And yes, we definitely have a race condition, you are right.  But it will always be present.  Suppose we remove the check for <code>null</code> and just write <br><pre> <code class="cs hljs">MyLittleEvent();</code> </pre><br>  Now imagine that our list of subscribers consists of 1000 delegates.  It is possible that we will start to raise an event before one of the subscribers unsubscribes from it.  In this case, it will still be called, since it will remain in the old list (do not forget that delegates are immutable).  <b>As I understand it, it is completely inevitable.</b> <br>  Using empty <code>delegate {};</code>  it saves us from having to check the event for <code>null</code> , but this will not save us from the next race condition.  Moreover, this method does not guarantee that we will use the most recent version of the event. <br></blockquote><br><br>  Now it should be noted that this answer was written in the 2009th year, and CLR via C # 4th edition - in 2012. So who will you believe in the end? <br>  In fact, I did not understand why Richter described the case of copying to a local variable through <code>Volatile.Read</code> , since he further <i>confirms the</i> words of Skit: <br><blockquote>  Although it is recommended to use the version with <code>Volatile.Read</code> as the best and technically correct, you can get by with <i>Option 2</i> , since the JIT compiler knows that it can accidentally mess up by optimizing the local variable <code>tempAction</code> .  <i>Theoretically</i> , in the future this may change, therefore it is recommended to use <i>Option 3</i> .  <i>But in fact,</i> Microsoft is unlikely to make such changes, because it can break a huge number of ready-made programs. <br></blockquote><br><br>  Everything becomes completely confusing - both options are equivalent, but the one with <code>Volatile.Read</code> more equivalent.  And no option will save from the race condition when calling unsubscribing handlers. <br><br>  Maybe there is no thread safe way to trigger events at all?  Why <code>NullReferenceException</code> it <code>NullReferenceException</code> so much time and effort to prevent an unlikely <code>NullReferenceException</code> , but not to prevent an equally probable call to the unsubscribing handler?  That I did not understand.  But in the process of searching for answers, I understood a lot of other things, and here is a small result. <br><br><h2>  What we have in the end </h2><br><br><ul><li>  The most popular method is <b>not thread</b> - <b>safe</b> because of the possibility of the delegate becoming <code>null</code> after checking for inequality.  There is a danger of <code>NullReferenceException</code> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action MyLittleEvent; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMyLittleEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (MyLittleEvent != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  NullReferenceException MyLittleEvent(); }</span></span></code> </pre><br></li><li>  The methods of Skit and Richter help to avoid the occurrence of a <code>NullReferenceException</code> , but <b>are not thread-safe</b> , since the probability remains to call the already unsubscribing handlers. <br><div class="spoiler">  <b class="spoiler_title">Skete method</b> <div class="spoiler_text"><pre> <code class="cs hljs">SomeEventHandler someEvent; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> someEventLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> SomeEventHandler SomeEvent { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (someEventLock) { someEvent += <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (someEventLock) { someEvent -= <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSomeEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EventArgs e</span></span></span><span class="hljs-function">)</span></span> { SomeEventHandler handler; <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (someEventLock) { handler = someEvent; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { handler (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, e); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Richter Method</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMyLittleEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      Action tempAction = Volatile.Read(ref MyLittleEvent); if (tempAction != null) tempAction (); }</span></span></code> </pre><br></div></div><br></li><li>  Empty <code>delegate {};</code> method <code>delegate {};</code>  allows you to get rid of <code>NullReferenceException</code> due to the fact that the event never goes to <code>null</code> , but is <b>not thread-safe</b> because the likelihood of invoking unsubscribing handlers remains.  Moreover, without the <code>volatile</code> , we have the opportunity to get not the latest version of the delegate when invoking an event. <br></li><li>  You cannot simply wrap an add, delete, and raise event in a <code>lock</code> , since this will create a deadlock hazard.  Technically, it can save unsubscribing handlers from being called, but we cannot be sure about what actions the subscriber object did before unsubscribing from an event, so we can still run into a ‚Äúdamaged‚Äù object (see the example with <code>ObjectDisposedException</code> ).  This method is also <b>not thread safe</b> . <br></li><li>  An attempt to catch the unsubscribing delegates after the local ‚Äúfreezing‚Äù of the event is meaningless - with a large number of subscribers, the probability of calling the unsubscribing handlers (after the start of the event call) is even higher than with the local ‚Äúfreezing‚Äù. <br></li></ul><br><br>  Technically, none of the options presented <b>is a thread</b> - <b>safe</b> way to <i>trigger an</i> event.  Moreover, adding a delegate verification method using local delegate copies <b>creates a false sense of security</b> .  The only way to completely secure yourself is to force <b>event handlers</b> to check if they have already unsubscribed from a specific event.  Unfortunately, unlike the common practice of preventing <code>NullReferenceException</code> when <code>NullReferenceException</code> events, there are no prescriptions about handlers.  If you make a separate library, then most often you cannot influence its users in any way - you cannot force customers to assume that their handlers will not be called after the formal reply from the event. <br><br>  After realizing all these problems, I had mixed feelings about the internal implementation of delegates in C #.  On the one hand, since they are immutable, there is no chance to get an <code>InvalidOperationException</code> as in the case of <code>InvalidOperationException</code> changing collection through <code>foreach</code> , but on the other, there is no way to check if someone has unsubscribed from the event <b>during a call</b> or not.  The only thing that can be done by the event holder is to protect against a <code>NullReferenceException</code> and hope that the subscribers will not spoil anything.  As a result, the question can be answered as follows: <br><br><blockquote>  It is impossible to provide a thread-safe event call in a multi-threaded environment, since there always remains the probability of calling the handlers of already unsubscribing subscribers.  This uncertainty contradicts the definition of the term ‚Äúthread safety‚Äù, in particular clause <blockquote>  It is guaranteed that it can be used simultaneously. </blockquote><br></blockquote><br><br><h3>  Additional reading </h3><br>  Of course, I could not just copy / translate everything I found.  Therefore, I will leave a list of sources that have been directly or indirectly used. <br><br><ul><li>  <a href="http://www.amazon.com/CLR-via-Edition-Developer-Reference/dp/0735667454">CLR via C # (Jeffrey Richter)</a> </li><li>  <a href="http://stackoverflow.com/questions/786383/c-sharp-events-and-thread-safety">A question on SO, in which John Skit talks about the inevitability of a race condition.</a>  <a href="http://stackoverflow.com/questions/786383/c-sharp-events-and-thread-safety">Still there are results of comparative tests at the time of the event call</a> </li><li>  <a href="http://www.codeproject.com/Articles/37474/Threadsafe-Events">A small article that clearly and weightedly explains the shortcomings of various methods of triggering events (outdated)</a> </li><li>  <a href="http://csharpindepth.com/Articles/Chapter2/Events.aspx">C # in Depth - Delegates and Events (Jon Skeet)</a> </li><li>  <a href="http://blogs.msdn.com/b/ericlippert/archive/2009/04/29/events-and-races.aspx">Useful article with the statement that ensuring thread safety is the work of handlers.</a> </li><li>  <a href="http://geekswithblogs.net/BlackRabbitCoder/archive/2011/12/01/c.net-fundamentals-safely-and-efficiently-raising-events.aspx">Another comparative analysis of the time of event calls using different approaches</a> </li><li>  <a href="http://stackoverflow.com/questions/170907/is-there-a-downside-to-adding-an-anonymous-empty-delegate-on-event-declaration">Details on empty delegates</a> </li><li>  <a href="http://www.albahari.com/threading/part4.aspx">A little bit about Memory Barrier and Volatile (Joe Albahari)</a> </li><li>  <a href="http://stackoverflow.com/questions/24677773/variable-freshness-guarantee-in-net-volatile-vs-volatile-read">More about volatile</a> </li><li>  <a href="http://stackoverflow.com/questions/2192124/reference-assignment-is-atomic-so-why-is-interlocked-exchangeref-object-object">On atomicity of operations with reference types</a> </li><li>  <a href="http://stackoverflow.com/questions/3668953/raise-event-thread-safely-best-practice">Extension methods for pseudo-thread-safe event firing</a> </li><li>  <a href="http://shop.oreilly.com/product/0636920023951.do">C # 5.0 in a Nutshell (for now, a favorite book on C #, highly recommended)</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/240385/">https://habr.com/ru/post/240385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240373/index.html">New course from the School of Interface Development. In Yekaterinburg and everywhere</a></li>
<li><a href="../240375/index.html">Objects in javascript and create js component. Part 1</a></li>
<li><a href="../240377/index.html">Vulnerability of zero day in Microsoft Windows (the patch will be available today)</a></li>
<li><a href="../240379/index.html">Dear bytes of the past millennium</a></li>
<li><a href="../240383/index.html">Firefox 33 release</a></li>
<li><a href="../240387/index.html">Create a testing department</a></li>
<li><a href="../240389/index.html">Check your hoster for Shellshock vulnerability (part 2)</a></li>
<li><a href="../240393/index.html">How to create special offers (offers) that will increase user engagement?</a></li>
<li><a href="../240399/index.html">From freelancer to entrepreneur - one step</a></li>
<li><a href="../240403/index.html">Hunting for Java-developers: how to grow professionally and become a desired goal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>