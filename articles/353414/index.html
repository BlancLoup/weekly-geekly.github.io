<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Analysis of the main concepts of concurrency</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All coffee! 

 Tomorrow, we have a smoothly launched almost anniversary stream Java Developer course - already the sixth in a row since April last yea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Analysis of the main concepts of concurrency</h1><div class="post__text post__text-html js-mediator-article">  All coffee! <br><br>  Tomorrow, we have a smoothly launched almost anniversary stream <a href="https://otus.pw/GkqO/">Java Developer</a> course - already the sixth in a row since April last year.  And this means that we have again picked up, translated the most interesting material that we share with you. <br><br>  Go! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This memo will help Java developers working with multithreaded programs understand the basic concepts of concurrency and how to use them.  You will learn about key aspects of the Java language with links to the standard library. <br><br>  <b>SECTION 1</b> <br><br>  <b>Introduction</b> <br><br>  Since its inception, Java has supported key concepts of concurrency, such as threads and locks.  This memo will help Java developers working with multithreaded programs understand the basic concepts of concurrency and how to use them. <br><br>  <b>SECTION 2</b> <br><br>  <b>Concepts</b> <br><br><table><tbody><tr><th>  <b>Concept</b> </th><th>  <b>Description</b> </th></tr><tr><td>  <nobr>Atomicity</nobr> </td><td>  An atomic operation is an operation that is performed completely or not at all, partial execution is impossible. </td></tr><tr><td>  Visibility </td><td>  Conditions under which one thread sees changes made by another thread </td></tr></tbody></table><br>  <i>Table 1: Concurrency Concepts</i> <br><br><img src="https://habrastorage.org/webt/6k/ia/tz/6kiatzehfeziuhf24ee0usgien0.jpeg"><a name="habracut"></a><br><br>  <b>Race condition</b> <br><br>  A race condition occurs when the same resource is used by several threads simultaneously, and depending on the order of actions of each thread there can be several possible results.  The code below is not thread-safe, and the <code>value</code> variable can be initialized more than once, since a <code>check-then-act</code> (check for <code>null</code> and then initialization) that lazily initializes the field is not <b>atomic</b> : <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lazy</span></span></span><span class="hljs-class"> &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> T value; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) value = initialize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } }</code> </pre> <br>  <b>Data Race</b> <br><br>  Data race occurs when two or more threads try to access the same non-final variable without synchronization.  Lack of synchronization can lead to changes that will <b>not be visible to</b> other threads, because of this, it is possible to read obsolete data, which, in turn, leads to infinite loops, corrupted data structures or inaccurate calculations.  This code can lead to an infinite loop, because the read stream may never notice the changes made by the rewriting streams: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Waiter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> shouldFinish; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ shouldFinish = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> iteration = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!shouldFinish) { iteration++; } System.out.println(<span class="hljs-string"><span class="hljs-string">"Finished after: "</span></span> + iteration); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataRace</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ Waiter waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Waiter(); Thread waiterThread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(waiter); waiterThread.start(); waiter.finish(); waiterThread.join(); } }</code> </pre><br>  <b>SECTION 3</b> <br><br>  <b>Java Memory Model: the happens-before relationship</b> <br><br>  The Java memory model is defined in terms of actions such as reading / writing fields and synchronization in the monitor.  Actions are ordered using an happens-before relationship (performed before), which can be used to explain when a thread sees the result of actions from another thread, and what a correctly synchronized program is. <br><br>  <b>RELATIONSHIPS HAPPENS-BEFORE HAVE THE FOLLOWING PROPERTIES:</b> <br><br><ul><li>  Calling Thread # start occurs before any action in this thread. </li><li>  The return of the monitor occurs before any subsequent capture of the same monitor. </li><li>  Writing to a volatile variable occurs before any subsequent reading of the volatile variable. </li><li>  Writing to the final variable occurs before the object link is published. </li><li>  All actions in the thread are performed before returning from Thread # join in this thread. </li></ul><br>  In Image 1, <code>Action X</code> occurs before <code>Action Y</code> , so in <code>Thread 2</code> all operations to the right of <code>Action Y</code> will see all operations to the left of <code>Action X</code> in <code>Thread 1</code> . <br><br><img src="https://habrastorage.org/webt/as/dd/eo/asddeodtvvf8ae75_ros5o6y3m0.png"><br>  <i>Image 1: The example happens-before</i> <i><br></i> <br><br>  <b>SECTION 4</b> <br><br>  <b>Standard sync features</b> <br><br>  <b>Keyword <code>synchronized</code></b> <br><br>  The <code>synchronized</code> used to prevent simultaneous execution by different threads of the same block of code.  It ensures that if you get a lock (by entering a synchronized block), the data on which this lock is imposed is processed in exclusive mode, so the operation can be considered atomic.  In addition, it ensures that other threads see the result of the operation after they get the same lock. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AtomicOperation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> counter0; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> counter1; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { counter0++; counter1++; } } }</code> </pre> <br>  The <i>synchronized keyword</i> can also be expanded at the method level. <br><br><table><tbody><tr><th>  <b><nobr>METHOD TYPE</nobr></b> </th><th>  <b>REFERENCE, USED AS A MONITOR</b> </th></tr><tr><td>  static </td><td>  reference to the Class object &lt;?&gt; </td></tr><tr><td>  non-static </td><td>  this-link </td></tr></tbody></table><br>  <i>Table 2: Monitors that are used when the entire method is synchronized</i> <br><br>  The reentrant lock, so if the thread already contains a lock, it can successfully get it again. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reentrantcy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ doFirst(); doSecond(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"First operation is successful."</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSecond</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Second operation is successful."</span></span>); } }</code> </pre> <br>  The level of rivalry affects how the monitor is captured: <br><br><table><tbody><tr><th>  <b><nobr>condition</nobr></b> </th><th>  <b>Description</b> </th></tr><tr><td>  init </td><td>  Just created, while no one was captured. </td></tr><tr><td>  biased </td><td>  There is no struggle, and the code protected by blocking is executed by only one thread.  Cheapest to capture. </td></tr><tr><td>  thin </td><td>  The monitor is captured by multiple threads without a fight.  For blocking, a relatively cheap CAS is used. </td></tr><tr><td>  fat </td><td>  There is a struggle.  The JVM queries the OS mutexes and allows the OS scheduler to handle parking threads and wake ups. </td></tr></tbody></table><br>  <i>Table 3: Monitor Status</i> <br><br> <b><code>wait/notify</code></b> <br> <br>  The <code>wait/notify/notifyAll</code> are declared in the <code>Object</code> class.  <code>wait</code> used to force the thread to go to the <code>WAITING</code> or <code>TIMED_WAITING</code> (if the time-out value is transmitted).  To wake the thread, you can do any of these actions: <br><br><ul><li>  Another thread calls notify, which wakes up an arbitrary thread waiting on the monitor. </li><li>  Another thread calls notifyAll, which wakes up all threads waiting on the monitor. </li><li>  Called Thread # interrupt.  In this case, an InterruptedException is thrown. </li></ul><br>  The most common example is the conditional loop: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionLoop</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> condition; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForCondition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!condition) { wait(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfyCondition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ condition = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; notifyAll(); } }</code> </pre> <br><ul><li>  Keep in mind that in order to use <code>wait/notify/notifyAll</code> for an object, you must first impose a lock on this object. </li><li>  Always wait inside a loop that checks the condition you are expecting.  This concerns a synchronization problem if another thread satisfies the condition before waiting.  In addition, it protects your code from side wakeups, which can (and will) occur. </li><li>  Always check that you meet the wait condition before calling notify / notifyAll.  Failure to comply with this requirement will result in a notification, but the thread cannot avoid the wait loop. </li></ul><br>  <b>Volatile keyword</b> <br><br>  <code>volatile</code> solves the <b>visibility</b> problem and makes the value change <b>atomic</b> , because here the relationship happens-before: writing to a volatile variable happens before any subsequent reading of the volatile variable.  Thus, it guarantees that the next reading of the field will show the value that was specified by the most recent entry. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VolatileFlag</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> shouldStop; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!shouldStop) { <span class="hljs-comment"><span class="hljs-comment">//do smth } System.out.println("Stopped."); } void stop() { shouldStop = true; } public static void main(String[] args) throws InterruptedException { VolatileFlag flag = new VolatileFlag(); Thread thread = new Thread(flag); thread.start(); flag.stop(); thread.join(); } }</span></span></code> </pre> <br>  <b>Atomicity</b> <br><br>  The <code>java.util.concurrent.atomic</code> package contains a set of classes that support composite atomic actions on a single value without locks, like <code>volatile</code> . <br><br>  Using the classes AtomicXXX, you can implement the atomic <code>check-then-act</code> operation: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CheckThenAct</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> AtomicReference&lt;String&gt; value = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AtomicReference&lt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value.compareAndSet(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Initialized value"</span></span>)) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Initialized only once."</span></span>); } } }</code> </pre> <br>  Both <code>AtomicInteger</code> and <code>AtomicLong</code> have an atomic increment / decrement operation: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Increment</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> AtomicInteger state = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AtomicInteger(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">advance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oldState = state.getAndIncrement(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Advanced: '"</span></span> + oldState + <span class="hljs-string"><span class="hljs-string">"' -&gt; '"</span></span> + (oldState + <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-string"><span class="hljs-string">"'."</span></span>); } }</code> </pre> <br>  If you need a counter and you do not need to get its value atomically, consider using <code>LongAdder</code> instead of <code>AtomicLong/AtomicInteger</code> .  <code>LongAdder</code> processes the value in several cells and increases their number, if needed, and, therefore, it works better with high competition. <br><br> <b><code>ThreadLocal</code></b> <br> <br>  One way to store data in the stream and make the lock optional is to use the <code>ThreadLocal</code> store.  Conceptually, <code>ThreadLocal</code> acts as if each thread has its own version of the variable.  <code>ThreadLocal</code> commonly used to capture the values ‚Äã‚Äãof each thread, such as the ‚Äúcurrent transaction,‚Äù or other resources.  In addition, they are used to maintain stream counters, statistics, or identifier generators. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransactionManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ThreadLocal&lt;Transaction&gt; currentTransaction = ThreadLocal.withInitial(NullTransaction::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-function"><span class="hljs-function">Transaction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">currentTransaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Transaction current = currentTransaction.get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.isNull()) { current = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TransactionImpl(); currentTransaction.set(current); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } }</code> </pre> <br>  <b>SECTION 5</b> <br><br>  <b>Secure publication</b> <br><br>  The publication of the object makes its link available outside the current scope (for example, returning a link from the getter).  Ensuring the secure publication of an object (only when it is fully created) may require synchronization.  Publication security can be achieved using: <br><br><ul><li>  Static initializers  Only one thread can initialize static variables, since the class is initialized under exclusive locking. </li></ul><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticInitializer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       public static final Year year = Year.of(2017); public static final Set&lt;String&gt; keywords; //        static { //    Set&lt;String&gt; keywordsSet = new HashSet&lt;&gt;(); //   keywordsSet.add("java"); keywordsSet.add("concurrency"); //    keywords = Collections.unmodifiableSet(keywordsSet); } }</span></span></code> </pre> <br><ul><li>  Volatile-field.  A read thread will always read the last value, because writing to a volatile variable occurs before any subsequent read. </li></ul><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Volatile</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> String state; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = state; } <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre> <br><ul><li>  Atomicity.  For example, <code>AtomicInteger</code> stores the value in a volatile-field, so the rule for volatile-variables is also applicable here. </li></ul><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Atomics</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> AtomicInteger state = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AtomicInteger(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initializeState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.compareAndSet(<span class="hljs-number"><span class="hljs-number">0</span></span>, state); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state.get(); } }</code> </pre> <br><ul><li>  Final fields. </li></ul><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Final</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String state; Final(String state) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = state; } <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre><br>  Ensure that this link does not evaporate during creation. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThisEscapes</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; ThisEscapes(String name) { Cache.putIntoCache(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cache</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;String, ThisEscapes&gt; CACHE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentHashMap&lt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putIntoCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ThisEscapes thisEscapes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 'this'   ,    . CACHE.putIfAbsent(thisEscapes.getName(), thisEscapes); } }</span></span></code> </pre> <br><ul><li>  Correctly synchronized fields. </li></ul><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Synchronization</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String state; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) state = <span class="hljs-string"><span class="hljs-string">"Initial"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre> <br>  <b>SECTION 6</b> <br><br>  <b>Immutable objects</b> <br><br>  One of the most remarkable properties of immutable objects is <b>thread safety</b> , so synchronization is not needed for them.  Requirements for a fixed object: <br><br><ul><li>  All fields are final fields. </li><li>  All fields must be either changeable or immutable objects, but not go beyond the object, therefore the state of the object can not be changed after creation. </li><li>  This link does not disappear during creation. </li><li>  A class is a final-class; therefore, overriding its behavior in subclasses is impossible. </li></ul><br>  An example of an immutable object: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   final -   public final class Artist { //  ,  final private final String name; //   , final  private final List&lt;Track&gt; tracks; public Artist(String name, List&lt;Track&gt; tracks) { this.name = name; //   List&lt;Track&gt; copy = new ArrayList&lt;&gt;(tracks); //      this.tracks = Collections.unmodifiableList(copy); // 'this'       } // Getters, equals, hashCode, toString } //  final -   public final class Track { // ,  final private final String title; public Track(String title) { this.title = title; } // Getters, equals, hashCode, toString }</span></span></code> </pre> <br>  <b>SECTION 7</b> <br><br>  <b>Streams</b> <br><br>  The <code>java.lang.Thread</code> class is used to represent an application or a JVM stream.  The code is always executed in the context of some Thread class (you can use <code>Thread#currentThread()).</code> to get the current thread <code>Thread#currentThread()).</code> <br><br><table><tbody><tr><th>  <b><nobr>condition</nobr></b> </th><th>  <b>Description</b> </th></tr><tr><td>  NEW </td><td>  It did not start. </td></tr><tr><td>  <nobr>RUNNABLE</nobr> </td><td>  Started and running. </td></tr><tr><td>  BLOCKED </td><td>  Waiting on the monitor - he is trying to get a lock and enter the critical section. </td></tr><tr><td>  WAITING </td><td>  Waiting to perform a specific action by another thread (notify / notifyAll, LockSupport # unpark). </td></tr><tr><td>  <nobr>TIMED_WAITING</nobr> </td><td>  Same as WAITING, but with a timeout. </td></tr><tr><td>  TERMINATED </td><td>  Stopped </td></tr></tbody></table><br>  <i>Table 4: Thread States</i> <br><br><table><tbody><tr><th>  <b><nobr>Stream method</nobr></b> </th><th>  <b>Description</b> </th></tr><tr><td>  start </td><td>  Runs an instance of the Thread class and executes the run () method. </td></tr><tr><td>  join </td><td>  Blocks until the end of the stream. </td></tr><tr><td>  interrupt </td><td>  Stops the thread.  If a thread is blocked in a method that responds to interrupts, InterruptedException will be thrown in another thread, otherwise the interrupt status will be set. </td></tr><tr><td>  stop, suspend, resume, destroy </td><td>  All of these methods are outdated.  They perform dangerous operations depending on the state of the stream in question.  Instead, use Thread # interrupt () or the volatile flag to tell the thread what to do. </td></tr></tbody></table><br>  <i>Table 5: Thread coordination methods Thread coordination methods</i> <br><br>  <b>How to handle InterruptedException?</b> <br><br><ul><li>  Clear all resources and terminate the thread if possible at the current level. </li><li>  Declare the current method to throw an InterruptedException. </li><li>  If the method does not throw an InterruptedException exception, the interrupted flag must be restored to true by calling Thread.currentThread (). Interrupt () and an exception should be thrown that is more appropriate at this level.  It is very important to return a true flag in order to allow interrupts to be processed at a higher level. </li></ul><br>  <b>Handling unexpected exceptions</b> <br><br>  <code>UncaughtExceptionHandler</code> may be reported in <code>UncaughtExceptionHandler</code> , which will receive notification of any uncaught exception for which the stream is interrupted. <br><br><pre> <code class="java hljs">Thread thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(runnable); thread.setUncaughtExceptionHandler((failedThread, exception) -&gt; { logger.error(<span class="hljs-string"><span class="hljs-string">"Caught unexpected exception in thread '{}'."</span></span>, failedThread.getName(), exception); }); thread.start();</code> </pre> <br>  <b>SECTION 8</b> <br><br>  <b>Vitality (Liveness)</b> <br><br> <b><code>Deadlock</code></b> <br> <br>  <code>Deadlock</code> , or deadlock, occurs when there are several threads and each is waiting for a resource belonging to another thread, so that a loop is formed from the resources and the threads that are waiting for them.  The most obvious type of resource is an object monitor, but any resource that causes a lock (for example, <code>wait/notify</code> ) is also appropriate. <br><br>  An example of a potential deadlock: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Account</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> amount; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.amount += amount; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.amount &lt; amount) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.amount -= amount; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferWithDeadlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount, Account first, Account second)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (first) { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (second) { first.minus(amount); second.plus(amount); } } } }</code> </pre> <br>  Mutual locking occurs if at the same time: <br><br><ul><li>  One thread is trying to transfer data from one account to another and has already imposed a lock on the first account. </li><li>  Another thread is trying to transfer data from the second account to the first one, and has already imposed a lock on the second account. </li></ul><br>  Ways to prevent deadlock: <br><br><ul><li>  Locking Order ‚Äî Always apply locks in the same order. </li></ul><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Account</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> amount; <span class="hljs-comment"><span class="hljs-comment">//    static void transferWithLockOrdering(long amount, Account first, Account second){ boolean lockOnFirstAccountFirst = first.id &lt; second.id; Account firstLock = lockOnFirstAccountFirst ? first : second; Account secondLock = lockOnFirstAccountFirst ? second : first; synchronized (firstLock) { synchronized (secondLock) { first.minus(amount); second.plus(amount); } } } }</span></span></code> </pre> <br><ul><li>  Locking with time-out - do not block indefinitely when blocking, it is better to remove all locks as soon as possible and try again. </li></ul><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Account</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> amount; <span class="hljs-comment"><span class="hljs-comment">//    static void transferWithTimeout( long amount, Account first, Account second, int retries, long timeoutMillis ) throws InterruptedException { for (int attempt = 0; attempt &lt; retries; attempt++) { if (first.lock.tryLock(timeoutMillis, TimeUnit.MILLISECONDS)) { try { if (second.lock.tryLock(timeoutMillis, TimeUnit.MILLISECONDS)) { try { first.minus(amount); second.plus(amount); } finally { second.lock.unlock(); } } } finally { first.lock.unlock(); } } } } }</span></span></code> </pre> <br>  The JVM is able to detect the interlocking of monitors and output information about them in the dumps of the streams. <br><br>  <b>Livelock and stream starvation</b> <br><br>  Livelock occurs when threads spend all their time negotiating access to a resource, or they discover and avoid a deadlock so that the thread does not actually move forward.  Fasting occurs when the streams keep blocking for long periods, so some streams ‚Äústarve‚Äù without progress. <br><br>  <b>SECTION 9</b> <br><br> <b><code>java.util.concurrent</code></b> <br> <br>  <b>Thread pools</b> <br><br>  The main interface for thread pools is <code>ExecutorService.java.util.concurrent</code> also provides a static factory Executors, which contains factory methods for creating a thread pool with the most common configurations. <br><br><table><tbody><tr><th>  <b>Method</b> </th><th>  <b>Description</b> </th></tr><tr><td>  newSingleThreadExecutor </td><td>  Returns an ExecutorService with only one thread. </td></tr><tr><td>  newFixedThreadPool </td><td>  Returns an ExecutorService with a fixed number of threads. </td></tr><tr><td>  newCachedThreadPool </td><td>  Returns an ExecutorService with a pool of threads of various sizes. </td></tr><tr><td>  <nobr>newSingleThreadScheduledExecutor</nobr> </td><td>  Returns a single thread ScheduledExecutorService. </td></tr><tr><td>  newScheduledThreadPool </td><td>  Returns a ScheduledExecutorService with the main set of threads. </td></tr><tr><td>  newWorkStealingPool </td><td>  Returns the task stealing ExecutorService. </td></tr></tbody></table><br>  <i>Table 6: Static Factory Methods</i> <br><br>  When determining the size of thread pools, it is often useful to determine the size of the number of logical cores in the machine on which the application is running.  You can get this value in Java by calling <code>Runtime.getRuntime().AvailableProcessors()</code> . <br><br><table><tbody><tr><th>  <b>Implementation</b> </th><th>  <b>Description</b> </th></tr><tr><td>  ThreadPoolExecutor </td><td>  Default implementation with resizable thread pool, one working queue, and custom policies for rejected tasks (via RejectedExecutionHandler) and thread creation (via ThreadFactory). </td></tr><tr><td>  <nobr>ScheduledThreadPoolExecutor</nobr> </td><td>  The ThreadPoolExecutor extension that provides the ability to schedule periodic tasks. </td></tr><tr><td>  ForkJoinPool </td><td>  Task pool stealing tasks: all threads in the pool are trying to find and start either the assigned tasks, or tasks created by other active tasks. </td></tr></tbody></table><br>  <i>Table 7: Thread Pool Implementations</i> <br><br>  Tasks are sent using <code>ExecutorService#submit</code> , <code>ExecutorService#invokeAll</code> or <code>ExecutorService#invokeAny</code> , which have several overloads for different types of tasks. <br><br><table><tbody><tr><th>  <b><nobr>Interface</nobr></b> </th><th>  <b>Description</b> </th></tr><tr><td>  Runnable </td><td>  Represents a task with no return value. </td></tr><tr><td>  Callable </td><td>  Represents a calculation with a return value.  It also throws the original Exeption, so no wrapper is required for the checked exception. </td></tr></tbody></table><br>  <i>Table 8: Task Functional Interfaces</i> <br><br> <b><code>Future</code></b> <br> <br>  <code>Future</code> is an abstraction for asynchronous computing.  It represents the result of the calculation, which may be available at some point: either the calculated value or the exception.  Most <code>ExecutorService</code> methods use <code>Future</code> as the return type.  It provides methods for examining the current state of the future or blocks until the result is available. <br><br><pre> <code class="java hljs">ExecutorService executorService = Executors.newSingleThreadExecutor(); Future&lt;String&gt; future = executorService.submit(() -&gt; <span class="hljs-string"><span class="hljs-string">"result"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { String result = future.get(<span class="hljs-number"><span class="hljs-number">1L</span></span>, TimeUnit.SECONDS); System.out.println(<span class="hljs-string"><span class="hljs-string">"Result is '"</span></span> + result + <span class="hljs-string"><span class="hljs-string">"'."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { Thread.currentThread().interrupt(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(e); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ExecutionException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(e.getCause()); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (TimeoutException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(e); } <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> future.isDone();</code> </pre> <br>  <b>Locks</b> <br><br> <b><code>Lock</code></b> <br> <br>  The <code>java.util.concurrent.locks</code> package has a standard <code>Lock</code> interface.  The implementation of <code>ReentrantLock</code> duplicates the synchronized keyword functionality, but also provides additional functions, such as getting information about the state of the lock, non-blocking <code>tryLock()</code> and interruptable locking.  An example of using an explicit ReentrantLock instance: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Lock lock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReentrantLock(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ lock.lock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++value; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { lock.unlock(); } } }</code> </pre> <br>  <b>ReadWriteLock</b> <br><br>  <code>java.util.concurrent.locks</code>    ReadWriteLock (  ReentrantReadWriteLock),        ,      ,     . <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Statistic</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ReadWriteLock lock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReentrantReadWriteLock(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ lock.writeLock().lock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { value++; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { lock.writeLock().unlock(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">current</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ lock.readLock().lock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { lock.readLock().unlock(); } } }</code> </pre> <br> <b><code>CountDownLatch</code></b> <br> <br> <code>CountDownLatch</code>  .    <code>await()</code> ,  ,     0.   (   )   <code>countDown()</code> ,   .   ,     0.      ,      . <br><br> <b><code>CompletableFuture</code></b> <br> <br> <code>CompletableFuture</code>      .     Future,      ‚Äî ,        ,   ,     .     ( <code>CompletableFuture#supplyAsync/runAsync</code> ),       (  <code>*async</code> )    ,     (      <code>ForkJoinPool#commonPool</code> ). <br><br> ,   <code>CompletableFuture</code>  ,  ,     <code>*async</code> ,     . <br><br>    <code>future</code> ,    <code>CompletableFuture#allOf</code> ,   <code>future</code> ,   ,   <code>future</code>  ,  <code>CompletableFuture#anyOf</code> ,   ,     - <code>future</code> . <br><br><pre> <code class="java hljs">ExecutorService executor0 = Executors.newWorkStealingPool(); ExecutorService executor1 = Executors.newWorkStealingPool(); <span class="hljs-comment"><span class="hljs-comment">//,   future  CompletableFuture&lt;String&gt; waitingForAll = CompletableFuture .allOf( CompletableFuture.supplyAsync(() -&gt; "first"), CompletableFuture.supplyAsync(() -&gt; "second", executor1) ) .thenApply(ignored -&gt; " is completed."); CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; "Concurrency Refcard", executor0) //    .thenApply(result -&gt; "Java " + result) //   .thenApplyAsync(result -&gt; "Dzone " + result, executor1) //,     future  .thenCombine(waitingForAll, (first, second) -&gt; first + second) //  ForkJoinPool#commonPool   .thenAcceptAsync(result -&gt; { System.out.println("Result is '" + result + "'."); }) //  .whenComplete((ignored, exception) -&gt; { if (exception != null) exception.printStackTrace(); }); //   - ,     . future.join(); future //    (  ). .thenRun(() -&gt; System.out.println("Current thread is '" + Thread.currentThread().getName() + "'.")) //  ForkJoinPool#commonPool   .thenRunAsync(() -&gt; System.out.println("Current thread is '" + Thread.currentThread().getName() + "'."));</span></span></code> </pre> <br> <b> </b> <br><br>       ‚Äî    <code>Collections#synchronized*</code> .        , <code>java.util.concurrent</code>    ,     . <br><br>  Lists <br><br><table><tbody><tr><th> <b></b> </th><th>  <b>Description</b> </th></tr><tr><td> <nobr>CopyOnWriteArrayList</nobr> </td><td>     ,            (   ,    ).            . </td></tr></tbody></table><br> <i> 9:   <code>java.util.concurrent</code></i> <br><br><table><tbody><tr><th> <b><nobr></nobr></b> </th><th>  <b>Description</b> </th></tr><tr><td> <nobr>ConcurrentHashMap</nobr> </td><td>      -.  ,  ,        .         CAS- (  ),        (     ). </td></tr><tr><td> <nobr>ConcurrentSkipListMap</nobr> </td><td>       Map,  TreeMap.       TreeMap,             ,          . </td></tr></tbody></table><br> <i> 10:    <code>java.util.concurrent</code></i> <br><br>  The sets <br><br><table><tbody><tr><th> <b><nobr></nobr></b> </th><th>  <b>Description</b> </th></tr><tr><td> <nobr>CopyOnWriteArraySet</nobr> </td><td>  CopyOnWriteArrayList,    copy-on-write    Set. </td></tr><tr><td> <nobr>ConcurrentSkipListSet</nobr> </td><td>  ConcurrentSkipListMap,    Set. </td></tr></tbody></table><br> <i> 11:   <code>java.util.concurrent</code></i> <br><br>          Map: <br><br><pre> <code class="java hljs">Set&lt;T&gt; concurrentSet = Collections.newSetFromMap(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentHashMap&lt;T, Boolean&gt;());</code> </pre> <br> <b></b> <br><br>       ¬´¬ª  ¬´¬ª.                 ¬´ ,  ¬ª (FIFO).  <code>BlockingQueue</code>  <code>Queue</code> ,     ,   ,      (   )   (     ).    <code>BlockingQueue</code>  ,    ,       ,    -   . <br><br><table><tbody><tr><th> <b></b> </th><th>  <b>Description</b> </th></tr><tr><td> <nobr>ConcurrentLinkedQueue</nobr> </td><td>   ,   . </td></tr><tr><td> LinkedBlockingQueue </td><td>    ,   . </td></tr><tr><td> <nobr>PriorityBlockingQueue</nobr> </td><td>   ,   .      ,    Comparator,    (  FIFO). </td></tr><tr><td> DelayQueue </td><td>    ,      .      ,           . </td></tr><tr><td> SynchronousQueue </td><td>  -,        ,    .    ,       .      . </td></tr></tbody></table><br> <i> 12:   <code>java.util.concurrent</code></i> <br><br> THE END <br><br>      . <br><br>  Thank. </div><p>Source: <a href="https://habr.com/ru/post/353414/">https://habr.com/ru/post/353414/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353404/index.html">The book "C ++ 17 STL. Standard Template Library ¬ª</a></li>
<li><a href="../353406/index.html">How I pumped the skills of personal effectiveness</a></li>
<li><a href="../353408/index.html">Scientific programming: part 1</a></li>
<li><a href="../353410/index.html">Device and mechanism of work of Prometheus Operator in Kubernetes</a></li>
<li><a href="../353412/index.html">What is frozen on feature freeze</a></li>
<li><a href="../353416/index.html">NumPy in Python. Part 2</a></li>
<li><a href="../353418/index.html">Improving performance through access control</a></li>
<li><a href="../353422/index.html">Three-dimensional engine on Excel formulas for dummies</a></li>
<li><a href="../353424/index.html">Aircraft control system simulation</a></li>
<li><a href="../353426/index.html">How to upload custom log to Splunk + logs for Fortinet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>