<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write the simplest service to steal an Android communicator</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. Some time ago I started learning programming for Android. Having read various subject literature, as is usually the case, I decided to test my ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write the simplest service to steal an Android communicator</h1><div class="post__text post__text-html js-mediator-article"> Hello.  Some time ago I started learning programming for Android.  Having read various subject literature, as is usually the case, I decided to test my strength in this field.  The idea of ‚Äã‚Äãwriting this particular service originated back in 2009, when an advertisement on RU.TV was full of phrases like ‚ÄúFind out the location of the subscriber‚Äù, ‚ÄúIntercept SMS‚Äù, etc.  You do not need to have a degree to understand that all this is the usual "divorce for money."  In addition, the attentive viewer will pay attention to the word "game", supposedly casually dropped in the text.  Realizing that this kind of service is possible, I decided to try to write a program that would intercept incoming / outgoing SMS, the list of calls and determine the location.  But positioning it as an SMS interceptor, within the framework of current legislation, was, to put it mildly, illegal.  In this connection, the idea was abandoned, and I switched to other projects until now. <br><br><a name="habracut"></a>  The reason for which I once again took up this project was the theft by hackers this summer of my new HTC Desire Z running Android.  Of course, my SIM card was thrown away and with it the last hook and the opportunity to find my phone disappeared.  It was then that I regretted that the previously conceived project was not implemented, and in an instant the idea was ripe, what kind of benefits could be derived from it within the framework of the law. <br><br>  So, everything is in order.  To implement the task was selected programming language Java.  I will not go into details of the reasons for choosing a language, but I will try to highlight the specific moments in programming for Android.  In this article I will discuss the algorithms for working with incoming and outgoing SMS. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, the work of the system is divided into the client part (the one that is installed on the protected phone) part and the server part (some Internet service to which data is transmitted from all the phones on which the tracking program is installed).  Let's look at what the client side should do: <br><br>  Since the program must constantly monitor for incoming or outgoing SMS, it should automatically start when the phone is restarted and remain relatively invisible to the communicator user.  The task of enabling tracking functions after restarting can be solved by the receiver declared in the manifest: <br><br> <code>&lt;receiver android:name=".onBootReceiver" android:enabled="true" android:exported="false"&gt; <br> &lt;intent-filter&gt; <br> &lt;action android:name="android.intent.action.BOOT_COMPLETED"/&gt; <br> &lt;/intent-filter&gt; <br></code> <br><br><br>  It runs two services running in the background - AlarmedService and GPS: <br><br> <code><br> public class onBootReceiver extends BroadcastReceiver { <br> @Override <br> public void onReceive(Context context, Intent intent) <br> { <br> if ("android.intent.action.BOOT_COMPLETED".equals(intent.getAction())) <br> { <br> //  Alarm <br> Intent serviceLauncher = new Intent(context, AlarmedService.class); <br> context.startService(serviceLauncher); <br> //  GPS <br> if (Consts.STARTUP_GPS_SERVICE) context.startService(new Intent(context, GPS.class)); <br> } <br> } <br> } <br></code> <br><br>  Since in this article I plan to consider only the work of the SMS interceptor, I will explain the purpose of the first Alarmed Service. <br><br> <code>private void startService() <br> { <br> //   <br> Intent intent = new Intent(this, ResendData.class); <br> PendingIntent pendingIntent = PendingIntent.getBroadcast(this, REQUEST_CODE, intent, 0); <br> alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE); <br> alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + FIRST_RUN, INTERVAL, pendingIntent); <br> //   <br> Intent intent2 = new Intent(this, OutgoingSMS.class); <br> PendingIntent pendingIntent2 = PendingIntent.getBroadcast(this, REQUEST_CODE, intent2, 0); <br> alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + Consts.FIRST_RUN_500ms , Consts.INTERVAL_1sec , pendingIntent2); <br> } <br></code> <br><br>  This is a service called by the AlarmManager, which with some frequency repeats the launch of functions, namely, re-sending SMS not previously sent to the server (due to the absence of the Internet, for example) and checking for new outgoing SMS.  Looking ahead, I will explain that the processing of incoming SMS is implemented somewhat differently, and more precisely, through the receiver of broadcast intentions BroadcastReciever and works much more efficiently than in the case of outgoing.  And all this is only because I did not manage to find the necessary receiver for outgoing SMS in the developer‚Äôs manual for Android (perhaps, by the way, it isn‚Äôt). <br><br>  New outgoing SMS, if any, are stored in a database table for sending to the server.  Why is the table being used and not being transmitted directly?  It's simple - there are no guarantees that this data transfer will succeed at the first attempt, because the phone may not have access to the Internet at this moment. <br><br>  Here is a snippet of handling new outgoing SMS: <br><br> <code>public class OutgoingSMS extends BroadcastReceiver { <br> @Override <br> public void onReceive(Context context, Intent intent) <br> { <br> Utils UN=new Utils(context); <br> Integer lastid=UN.GetLastID(context); <br> Cursor unsent=UN.GetSentSMS(context, lastid); <br> if (unsent.moveToFirst()){ <br> do <br> { <br> if (unsent.getInt(0)&gt;lastid) lastid=unsent.getInt(0); <br> SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss"); <br> Date date=new Date(unsent.getLong(5)); <br> String _date=sdf.format(date); <br> UN.PutSMS(context, unsent.getString(3), _date, unsent.getString(12), 1); <br> } <br> while (unsent.moveToNext()); <br> UN.SetLastID(context, lastid); <br> } <br> unsent.close(); <br> UN.DBClose(); <br> } <br> } <br></code> <br><br>  And this is the handler for re-sending previously unsent data to the server: <br><br> <code>public class ResendData extends BroadcastReceiver { <br> @Override <br> public void onReceive(Context context, Intent intent) <br> { <br> Utils UT=new Utils(context); <br> UT.ResendSMS(context); <br> UT.ResendGPS(context); <br> UT.ResendContacts(context); <br> UT.DBClose(); <br> } <br> } <br></code> <br><br>  With incoming SMS, everything is simpler - in this case, an event occurs that is processed by the receiver of broadcasting intentions, into the body of which we place the code we need: <br><br> <code>public class SmsBroadcastReceiver extends BroadcastReceiver { <br> @Override <br> public void onReceive(Context ctx, Intent intent) { <br> //   <br> Bundle bundle = intent.getExtras(); <br> ProSperoService.messages=(Object[]) bundle.get("pdus"); <br> //  <br> Intent serviceLauncher = new Intent(ctx, ProSperoService.class); <br> ctx.startService(serviceLauncher); <br> } <br> } <br></code> <br><br>  In this code, we receive incoming SMS from pdus and start the ProSperoService service, which assembles SMS and queues to be sent to the server.  What is the layout for?  I will explain.  According to the standard, the length of SMS messages in Russian (in simple terms) is significantly limited.  And long SMS are broken into several short, which are then collected by the software of the phone into one original SMS.  By the way, if the text of such SMS exceeds the length of 5 short SMS, then it is already sent as MMS, and, accordingly, it will not be intercepted by the code below. <br><br> <code><br> private void IncomingSMSBackup(){ <br> Date date = new Date(); <br> SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss"); <br> String _date=sdf.format(date); <br> Utils PS=new Utils(this); <br> SmsMessage smsMessage[] = new SmsMessage[messages.length]; <br> //   <br> String smsmsg=""; <br> for (int n = 0; n &lt; messages.length; n++) <br> { <br> smsMessage[n] = SmsMessage.createFromPdu((byte[]) messages[n]); <br> //  <br> smsmsg=smsmsg+smsMessage[n].getMessageBody().toString(); <br> } <br> <br> //,      <br> <br> //String mess=smsMessage[n].getMessageBody(); <br> String mess=smsMessage[0].getMessageBody(); <br> //     GPS <br> int fnd=mess.indexOf(Consts.START_GPS_SERVICE); <br> if (fnd!=-1) <br> { <br> getBaseContext().startService(new Intent(getBaseContext(), GPS.class)); <br> } <br> //     GPS <br> fnd=mess.indexOf(Consts.STOP_GPS_SERVICE); <br> if (fnd!=-1) <br> { <br> getBaseContext().stopService(new Intent(getBaseContext(), GPS.class)); <br> } <br> //   IMEI <br> fnd=mess.indexOf(Consts.GET_IMEI); <br> if (fnd!=-1) <br> { <br> //   <br> String SENT = "SMS_SENT"; <br> String DELIVERED = "SMS_DELIVERED"; <br> <br> PendingIntent sentPI = PendingIntent.getBroadcast(this, 0, <br> new Intent(SENT), 0); <br> <br> PendingIntent deliveredPI = PendingIntent.getBroadcast(this, 0, <br> new Intent(DELIVERED), 0); <br> SmsManager smsManager = SmsManager.getDefault(); <br> smsManager.sendTextMessage(smsMessage[0].getOriginatingAddress(), null, "IMEI: "+PS.IMEI, sentPI, deliveredPI); <br> //  .    <br> } <br> <br> //     <br> fnd=mess.indexOf(Consts.GET_CONTACTS); <br> if (fnd!=-1) <br> { <br> PS.PutContacts(getBaseContext(), PS.GetContactsRequest(getBaseContext())); <br> } <br> //PS.PutSMS(this, smsMessage[n].getOriginatingAddress(),_date,smsMessage[n].getMessageBody().toString(),0); <br> PS.PutSMS(this, smsMessage[0].getOriginatingAddress(),_date,smsmsg,0); <br> //} <br> //    <br> URL url = null; <br> HttpURLConnection urlConnection = null; <br> try <br> { <br> url = new URL(Consts.SERVER_URL); <br> } <br> catch (MalformedURLException e) <br> { <br> e.printStackTrace(); <br> } <br> Cursor cur=PS.GetSMS(this); <br> String request=""; <br> if (cur.moveToFirst()) { <br> do <br> { <br> try <br> { <br> request = //       <br> String hash=//  -     <br> request=request+"&amp;hash="+hash; <br> //Toast.makeText(getBaseContext(), request, Toast.LENGTH_LONG).show(); <br> } <br> catch (UnsupportedEncodingException e) <br> { <br> e.printStackTrace(); <br> } <br> if (PS.SendRequestToServer(url, urlConnection, request)) <br> { <br> PS.KillSMSByID(cur.getInt(0)); <br> } <br> } <br> while (cur.moveToNext()); <br> } <br> cur.close(); <br> PS.DBClose(); <br> } <br></code> <br><br>  This code checks the contents of the incoming SMS for the presence of service commands (of course, we program the commands ourselves).  The meaning of these commands is that as soon as the phone receives an SMS, the text of which will contain a sequence of service symbols, for example ":-)", the program will perform some prescribed actions.  This can be the transfer of a list of contacts, the inclusion of a tracking system via GPS, etc. After the checks, a request is sent that is sent to the server and it is placed in the send queue.  After successful sending, the data from the database table is deleted. <br><br>  In conclusion, I will give the contents of the AndroidManifest.xml file (unfortunately, how the habr code is not completely correct, so I‚Äôm giving it in plain text): <br><br>  &lt;? xml version = "1.0" encoding = "utf-8"?&gt; <br>  &lt;manifest xmlns: android = " <a href="http://schemas.android.com/apk/res/android">schemas.android.com/apk/res/android</a> " <br>  package = "com.sandman.prospero" <br>  android: versionCode = "1" <br>  android: versionName = "1.0"&gt; <br>  &lt;application android: icon = "@ drawable / icon" android: label = "@ string / app_name"&gt; <br>  &lt;activity android: name = ". ProSperoActivity" <br>  android: label = "@ string / app_name"&gt; <br>  &lt;intent-filter&gt; <br>  &lt;action android: name = "android.intent.action.MAIN" /&gt; <br>  &lt;category android: name = "android.intent.category.LAUNCHER" /&gt; <br>  &lt;/ intent-filter&gt; <br><br>  &lt;service android: name = ". ProSperoService" android: exported = "false"&gt; <br>  &lt;service android: name = ". GPS" android: exported = "false"&gt; <br>  &lt;service android: enabled = "true" android: name = ". AlarmedService" /&gt; <br>  &lt;receiver android: name = ". SmsBroadcastReceiver"&gt; <br>  &lt;intent-filter&gt; <br>  &lt;action android: name = "android.provider.Telephony.SMS_RECEIVED" /&gt; <br>  &lt;/ intent-filter&gt; <br><br>  &lt;receiver android: name = ". ResendData" android: process = ": remote" /&gt; <br>  &lt;receiver android: name = ". OutgoingSMS" android: process = ": remote" /&gt; <br>  &lt;receiver android: name = ". onBootReceiver" android: enabled = "true" android: exported = "false"&gt; <br>  &lt;intent-filter&gt; <br>  &lt;action android: name = "android.intent.action.BOOT_COMPLETED" /&gt; <br>  &lt;/ intent-filter&gt; <br><br><br>  // read sms <br>  &lt;uses-permission android: name = "android.permission.READ_SMS" /&gt; <br>  // send sms <br>  &lt;uses-permission android: name = "android.permission.SEND_SMS" /&gt; <br>  // Internet access <br>  &lt;uses-permission android: name = "android.permission.INTERNET" /&gt; <br>  // reading the list of contacts <br>  &lt;uses-permission android: name = "android.permission.READ_CONTACTS" /&gt; <br>  // receive sms <br>  &lt;uses-permission android: name = "android.permission.RECEIVE_SMS" /&gt; <br>  // no hibernation <br>  &lt;uses-permission android: name = "android.permission.WAKE_LOCK" /&gt; <br>  // getting information about the completion of the phone boot process <br>  &lt;uses-permission android: name = "android.permission.RECEIVE_BOOT_COMPLETED" /&gt; <br>  // use GPS <br>  &lt;uses-permission android: name = "android.permission.ACCESS_FINE_LOCATION" /&gt; <br>  &lt;uses-sdk android: minSdkVersion = "3" /&gt; <br><br><br>  Please note that it is necessary to declare all services and receivers of broadcast intentions, as well as specify all permissions necessary for the program to work correctly. <br><br>  The convenience of the program lies in the fact that it is able to uniquely identify the communicator, and therefore transfer data to its true owner even when the SIM card is replaced, since  The identifier is the IMEI of the device. <br><br>  Actually, the work of the service can be viewed on the website <a href="http://prospero.pro/">prospero.pro</a> </div><p>Source: <a href="https://habr.com/ru/post/128844/">https://habr.com/ru/post/128844/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../128835/index.html">Hyperlinks in ExtJS 2.x / 3.x. To help the young fighter</a></li>
<li><a href="../128836/index.html">Qt and SQLite and in general, DB programming in Qt</a></li>
<li><a href="../128840/index.html">Fitting room on the basis of augmented reality VIPodium</a></li>
<li><a href="../128841/index.html">Diablo 3 beta test launched</a></li>
<li><a href="../128843/index.html">HTC Rhyme: stylish and elegant</a></li>
<li><a href="../128846/index.html">Developing Mobile Applications with Adobe Flash + AIR: Feature Overview</a></li>
<li><a href="../128847/index.html">How to effectively import big data</a></li>
<li><a href="../128848/index.html">Kerning.js</a></li>
<li><a href="../128849/index.html">Archos 101 and 3G modem</a></li>
<li><a href="../128852/index.html">Google‚Äôs +1 button will appear on AdWords banners</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>