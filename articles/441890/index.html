<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Everything you need to know about the iOS App Extensions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="App Extensions appeared in iOS 8 and made the system more flexible, powerful and accessible to users. Applications can be displayed as a widget in the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Everything you need to know about the iOS App Extensions</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/2n/jy/99/2njy99obhw-o7fthqzpd0f5ncxm.png"><br><br>  App Extensions appeared in iOS 8 and made the system more flexible, powerful and accessible to users.  Applications can be displayed as a widget in the Notification Center, offer your own filters for photos in Photos, display a new system keyboard and much more.  At the same time, user data and system security has been preserved.  On the features of the App Extensions and will be discussed below. <br><a name="habracut"></a><br>  Apple has always sought to carefully isolate applications from each other.  This is the best way to keep users safe and secure.  Each application is given a separate place in the file system with limited access.  Appearance of App Extensions allowed to interact with the application without launching it or showing it on the screen.  Thus, part of its functionality will be available to users when they interact with other applications or the system. <br><br>  App Extensions are executable files that run independently of the application containing them - <b>Containing App</b> .  By themselves, they cannot be published to the App Store, only with the Containing App.  All App Extensions perform one specific task and are tied to only one iOS area, depending on their type.  For example: Custom Keyboard Extensions are designed to replace the standard keyboard, and Photo Editing Extensions - to edit photos in Photos.  In total there are <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/index.html">25 types of</a> App Extensions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  App Extension Life Cycle </h1><br>  The application that the user uses to run the App Extension is called the <b>Host App</b> .  The Host App launches the App Extension life cycle by sending it a request in response to a user action: <br><br><img src="https://habrastorage.org/webt/jp/kl/vj/jpklvjv3yd2-5e3q_ownsx4d9my.png"><br><br><ul><li>  The user selects the App Extension through the Host App. <br></li><li>  The Host App sends an App Extension request. <br></li><li>  iOS launches the App Extension in the context of the Host App and establishes a communication channel between them. <br></li><li>  The user performs an action in the App Extension. <br></li><li>  App Extension completes the request from the Host App by executing the task, or starts a background process to execute it;  upon completion of the task, the result can be returned to the Host App. <br></li><li>  As soon as the App Extension executes its code, the system terminates this App Extension. <br></li></ul><br>  For example, when sharing a photo from Photos using the Facebook Share Extension, Facebook is the Containing App, and Photos is the Host App.  In this case, Photos starts the Facebook Share Extension life cycle when the user selects it in the Share menu: <br><br><img src="https://habrastorage.org/webt/65/11/9a/65119akk96p0z1dqrmltolv73ss.png"><br><br><h1>  Interaction with App Extension </h1><br><img src="https://habrastorage.org/webt/o_/wn/mg/o_wnmgqodkshdtrb7vgnakhymse.png"><br><br><ul><li>  <b>Containing App - Host App</b> <br>  Do not interact with each other. <br></li><li>  <b>App Extension - Host App</b> <br>  Interact with the use of <a href="https://en.wikipedia.org/wiki/Inter-process_communication">IPC</a> . <br></li><li>  <b>App Extension - Containing App</b> <br>  Indirect interaction  <b>App Groups</b> are used for data exchange, and <b>Embedded Frameworks is</b> used for shared code.  You can launch the Containing App from the App Extension using <b>URL Schemes</b> . <br></li></ul><br><h2>  Common code: dynamic frameworks </h2><br>  If the Containing App and the App Extension use the same code, it should be placed in a dynamic framework. <br><br>  For example, a Photo Editing Extension may be associated with a custom photo editing application, using some filters from the Containing App.  A good solution would be to create a dynamic framework for these filters. <br><br>  To do this, add a new <b>Target</b> and select the <b>Cocoa Touch Framework</b> : <br><br><img src="https://habrastorage.org/webt/4o/-i/65/4o-i65s30q1srdwldrhhrj8sfuw.png"><br><br>  Specify the name (for example, <b>ImageFilters</b> ), and in the navigator panel you can see a new folder with the name of the created framework: <br><br><img src="https://habrastorage.org/webt/k5/ih/nn/k5ihnnf83plqtwrwqquhe3pxzuq.png" align="left" width="270" height="377">  You need to make sure that the framework does not use APIs that are not available for App Extensions: <br><br><ul><li>  Shared from UIApplication. <br></li><li>  API marked with inaccessible macros. <br></li><li>  Camera and microphone (except iMessage Extension). <br></li><li>  Perform lengthy background tasks (features of this restriction vary depending on the type of App Extension). <br></li><li>  Retrieving data using AirDrop. <br></li></ul><br>  Using any of this list in App Extensions will cause it to be rejected when published to the App Store. <br><br>  In the settings of the framework in <b>General,</b> you must tick the <b>‚ÄúAllow app extension API only‚Äù</b> : <br><br><img src="https://habrastorage.org/webt/6v/bz/ky/6vbzkycc0py7axwtcx2nji1oevk.png"><br><br>  In the framework code, all classes, methods, and properties used in the Containing App and App Extensions should be <code>public</code> .  Wherever you need to use the framework, we <code>import</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ImageFilters</code> </pre> <br><h2>  Data Exchange: App Groups </h2><br>  Containing App and App Extension have their own limited portions of the file system, and only they have access to them.  For the Containing App and App Extension to have a common container with read and write access, you need to create an App Group for them. <br><br>  App Group is created in the <b>Apple Developer Portal</b> : <br><br><img src="https://habrastorage.org/webt/sw/ax/od/swaxodkpniu6gd_qdce6kh7bjj8.png"><br><br>  In the upper right corner, click "+", in the window that appears, enter the necessary data: <br><br><img src="https://habrastorage.org/webt/db/bt/m8/dbbtm8iuqbihyixcsz7n79hm95e.png"><br><br>  Further <b>Continue -&gt; Register -&gt; Done</b> . <br><br>  In the settings of the Containing App, go to the <b>Capabilities</b> tab, activate App Groups and select the created group: <br><br><img src="https://habrastorage.org/webt/cr/tu/_r/crtu_rzlbyzuhb67tp9yqxv4s0k.png"><br><br>  Similarly for App Extension: <br><br><img src="https://habrastorage.org/webt/cy/nd/pm/cyndpm2qzr49uk-lye8ahysbdkc.png"><br><br>  Now the Containing App and App Extension share a common container.  Next, let's talk about how to read and write to it. <br><br><h3>  UserDefaults </h3><br>  To exchange a small amount of data, it is convenient to use <code>UserDefaults</code> , you just need to specify the name of the App Group: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sharedDefaults = <span class="hljs-type"><span class="hljs-type">UserDefaults</span></span>(suiteName: <span class="hljs-string"><span class="hljs-string">"group.com.maxial.onemoreapp"</span></span>)</code> </pre> <br><h3>  NSFileCoordinator and NSFilePresenter </h3><br>  For big data, the <code>NSFileCoordinator</code> is better suited, thanks to which you can ensure consistency of reading and writing.  This will avoid data corruption, as there is a possibility that several processes can access them simultaneously. <br><br>  The URL of the shared container is obtained as follows: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sharedUrl = <span class="hljs-type"><span class="hljs-type">FileManager</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.containerURL(forSecurityApplicationGroupIdentifier: <span class="hljs-string"><span class="hljs-string">"group.com.maxial.onemoreapp"</span></span>)</code> </pre> <br>  Record: <br><br><pre> <code class="swift hljs">fileCoordinator.coordinate(writingItemAt: sharedUrl, options: [], error: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] newUrl <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-type"><span class="hljs-type">NSKeyedArchiver</span></span>.archivedData(withRootObject: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.object, requiringSecureCoding: <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> data.write(to: newUrl, options: .atomic) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error) } }</code> </pre> <br>  Reading: <br><br><pre> <code class="swift hljs">fileCoordinator.coordinate(readingItemAt: sharedUrl, options: [], error: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { newUrl <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-type"><span class="hljs-type">Data</span></span>(contentsOf: newUrl) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-type"><span class="hljs-type">NSKeyedUnarchiver</span></span>.unarchivedObject(ofClass: <span class="hljs-type"><span class="hljs-type">NSString</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: data) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">String?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.object = object } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error) } }</code> </pre> <br>  It is worth considering that the <code>NSFileCoordinator</code> works synchronously.  While some file will be occupied by some process, others will have to wait for its release. <br><br>  If you want the App Extension to know when the Containing App changes the state of the data, <code>NSFilePresenter</code> used.  This is a protocol whose implementation may look like this: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodayViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSFilePresenter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presentedItemURL: <span class="hljs-type"><span class="hljs-type">URL?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sharedUrl = <span class="hljs-type"><span class="hljs-type">FileManager</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.containerURL(forSecurityApplicationGroupIdentifier: <span class="hljs-string"><span class="hljs-string">"group.com.maxial.onemoreapp"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sharedUrl?.appendingPathComponent(<span class="hljs-string"><span class="hljs-string">"Items"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presentedItemOperationQueue: <span class="hljs-type"><span class="hljs-type">OperationQueue</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .main } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">presentedItemDidChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { } }</code> </pre> <br>  The <b><code>presentedItemOperationQueue</code></b> property returns a queue that is used for callbacks when files change.  The <b><code>presentedItemDidChange()</code></b> method will be called when a process, in this case the Containing App, changes the content of the data.  If changes were made directly using low-level write calls, then <b><code>presentedItemDidChange()</code></b> not called.  Only changes using <code>NSFileCoordinator</code> taken into account. <br><br>  When initializing an <code>NSFileCoordinator</code> object, <code>NSFileCoordinator</code> recommended to pass an <code>NSFilePresenter</code> object, especially if it starts any file operation: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fileCoordinator = <span class="hljs-type"><span class="hljs-type">NSFileCoordinator</span></span>(filePresenter: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre> <br>  Otherwise, the <code>NSFilePresenter</code> object will receive notifications about these operations, which can lead to a deadlock when working in the same thread. <br><br>  To start tracking the status of the data, call the <b><code>addFilePresenter(_:)</code></b> method with the corresponding object: <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">NSFileCoordinator</span></span>.addFilePresenter(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre> <br>  Any <code>NSFileCoordinator</code> objects created later will automatically be aware of this <code>NSFilePresenter</code> object and will be notified of changes occurring in its directory. <br><br>  To stop tracking the status of data, use <b><code>removeFilePresenter(_:)</code></b> : <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">NSFileCoordinator</span></span>.removeFilePresenter(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre> <br><h3>  Core data </h3><br>  To share data, you can use SQLite and, accordingly, Core Data.  They know how to manage processes that work with shared data.  To configure Core Data for sharing for the Containing App and the App Extension, create a subclass of <code>NSPersistentContainer</code> and override the <b><code>defaultDirectoryURL</code></b> method, which should return the address of the data store: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SharedPersistentContainer</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSPersistentContainer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">defaultDirectoryURL</span></span></span><span class="hljs-class">() -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> storeURL = <span class="hljs-type"><span class="hljs-type">FileManager</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.containerURL(forSecurityApplicationGroupIdentifier: <span class="hljs-string"><span class="hljs-string">"group.com.maxial.onemoreapp"</span></span>) storeURL = storeURL?.appendingPathComponent(<span class="hljs-string"><span class="hljs-string">"OneMoreApp.sqlite"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> storeURL! } }</code> </pre> <br>  In <code>AppDelegate</code> change the <b><code>persistentContainer</code></b> property.  It is automatically created if you tick the <b>Use Core Data</b> box while creating the project.  Now we will return an object of the <code>SharedPersistentContainer</code> class: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> persistentContainer: <span class="hljs-type"><span class="hljs-type">NSPersistentContainer</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-type"><span class="hljs-type">SharedPersistentContainer</span></span>(name: <span class="hljs-string"><span class="hljs-string">"OneMoreApp"</span></span>) container.loadPersistentStores(completionHandler: { (storeDescription, error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">NSError?</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Unresolved error \(error), \(error.userInfo)"</span></span>) } }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container }()</code> </pre> <br>  It only remains to add <b>.xcdatamodeld</b> to the App Extension.  Select the .xcdatamodeld file in the navigator panel.  In the <b>File Inspector,</b> in the <b>Target Membership</b> section, tick the App Extension box: <br><br><img src="https://habrastorage.org/webt/71/mb/t8/71mbt8ggk9msftndb3q2f0obvvu.png" width="270" height="386"><br><br>  Thus, the Containing App and the App Extension will be able to read and write data in one storage and use the same model. <br><br><h2>  Run the Containing App from the App Extension </h2><br>  When the Host App sends an App Extension request, it provides an <b><code>extensionContext</code></b> .  This object has an <b><code>open(_:completionHandler:)</code></b> method, with which you can open the Containing App.  However, this method is not available for all App Extension types.  In iOS, it is supported by the Today Extension and iMessage Extension.  iMessage Extension can only use it to open the Containing App.  If Today Extension opens another application with it, additional verification may be required to be sent to the App Store. <br><br>  To open an application from App Extension, you need to determine the URL Scheme in the Containing App: <br><br><img src="https://habrastorage.org/webt/vh/zy/hi/vhzyhilxsny61ctuynhqhzfwvos.png"><br><br>  Next, call the <b><code>open(_:completionHandler:)</code></b> method <b><code>open(_:completionHandler:)</code></b> with this schema from the App Extension: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = <span class="hljs-type"><span class="hljs-type">URL</span></span>(string: <span class="hljs-string"><span class="hljs-string">"OneMoreAppUrl://"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } extensionContext?.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(url, completionHandler: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>  For those types of App Extensions that the <b><code>open(_:completionHandler:)</code></b> method call <b><code>open(_:completionHandler:)</code></b> not available, there is also a way.  But there is a possibility that the application may be rejected when checking in the App Store.  The essence of the method is to <code>UIResponder</code> through the chain of <code>UIResponder</code> objects until there is a <code>UIApplication</code> , which will accept the <b><code>openURL</code></b> call: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = <span class="hljs-type"><span class="hljs-type">URL</span></span>(string: <span class="hljs-string"><span class="hljs-string">"OneMoreAppUrl://"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> selectorOpenURL = sel_registerName(<span class="hljs-string"><span class="hljs-string">"openURL:"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> responder: <span class="hljs-type"><span class="hljs-type">UIResponder?</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> responder != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> responder?.responds(to: selectorOpenURL) == <span class="hljs-literal"><span class="hljs-literal">true</span></span> { responder?.perform(selectorOpenURL, with: url) } responder = responder?.next }</code> </pre> <br><h1>  Future App Extensions </h1><br>  App Extensions have brought a lot of new in iOS development.  Gradually, more types of App Extensions appear, their capabilities are developing.  For example, with the release of iOS 12 SDK, you can now interact with the content area in notifications, which was not enough for so long. <br><br>  Thus, Apple continues to develop this tool, which inspires optimism about its future future. <br><br>  <b>Useful links:</b> <br><br>  <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/index.html">Official documentation</a> <br>  <a href="https://www.atomicbird.com/blog/sharing-with-app-extensions">Sharing data between iOS apps and app extensions</a> <br>  <a href="https://www.atomicbird.com/blog/ios-app-extension-tips">iOS 8 App Extension Development Tips</a> </div><p>Source: <a href="https://habr.com/ru/post/441890/">https://habr.com/ru/post/441890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441876/index.html">The prototype of the Russian robosobaki moves at a speed of 6.5 km / h</a></li>
<li><a href="../441878/index.html">You as you like, and I did</a></li>
<li><a href="../441880/index.html">Russia is not ready for unmanned vehicles</a></li>
<li><a href="../441882/index.html">VMware NSX for the smallest. Part 3. Configuring DHCP</a></li>
<li><a href="../441886/index.html">Over the past 12 years, I have never shown a summary</a></li>
<li><a href="../441892/index.html">Creating a Dataflow template for streaming data from Pub / Sub to BigQuery based on GCP using Apache Beam SDK and Python</a></li>
<li><a href="../441898/index.html">Sketch + Node.js: generate icons for multiple platforms and brands</a></li>
<li><a href="../441900/index.html">Satya Nadella spoke about cooperation with the Pentagon</a></li>
<li><a href="../441902/index.html">How technology creates new realities</a></li>
<li><a href="../441904/index.html">Installing IPS-display in Thinkpad T430S</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>