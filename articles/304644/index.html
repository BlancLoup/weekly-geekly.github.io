<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SO_TIMESTAMPING in pictures. Reception package</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It happens that an application needs to know the exact time of receiving or sending a network packet. For example, to synchronize clocks (see PTP , NT...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SO_TIMESTAMPING in pictures. Reception package</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/files/e6b/5e2/f5d/e6b5e2f5d4b84af0b87b4ff827c5a26c.png"><br><p>  It happens that an application needs to know the exact time of receiving or sending a network packet.  For example, to synchronize clocks (see <a href="https://habrahabr.ru/post/163253/">PTP</a> , <a href="https://ru.wikipedia.org/wiki/NTP">NTP</a> ) or to test network delays (see RFC2544). </p><br><p>  A naive solution is to remember the time in the application immediately after receiving a packet from the kernel (or before sending it to the kernel): </p><br><pre><code class="hljs lisp">recv(<span class="hljs-name"><span class="hljs-name">sock</span></span>, buffer, length, flags)<span class="hljs-comment"><span class="hljs-comment">; clock_gettime(CLOCK_REALTIME, timespec);</span></span></code> </pre> <br><p>  It is clear that the time thus obtained may differ markedly from the time when the packet was received by the network device.  For more accurate time, support from the operating system, driver, and / or network device is needed. </p><br><p>  Starting from version 2.6.30, Linux supports the SO_TIMESTAMPING socket option.  It allows a custom socket to receive timestamps for sent and received packets.  Time stamps can be removed by the kernel itself, the driver, or the network device (see the <a href="http://linuxptp.sourceforge.net/">list of supporting devices and drivers</a> ).  You can read about how it is and how to use it in <a href="https://github.com/torvalds/linux/blob/master/Documentation/networking/timestamping.txt">Documentation / networking / timestamping.txt.</a> </p><br><p>  In this article, I will discuss how packets are delivered from a network device to a user, when time stamps are removed, how they are delivered to the user, and how accurate they are.  The examples of kernel code are taken from version 4.1. </p><a name="habracut"></a><br><h2>  Initial knowledge </h2><br><h3>  struct sk_buff </h3><br><p>  All network packets in the kernel are represented by a <code>struct sk_buff</code> structure, which is declared in the <a href="">include / linux / skbuff.h file</a> .  Consider some of her fields: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sk_buff</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  ,    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ktime_t</span></span> tstamp; <span class="hljs-comment"><span class="hljs-comment">/*   ,       */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sock</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sk</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   ,         */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">net_device</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* L3  */</span></span> __be16 protocol; <span class="hljs-comment"><span class="hljs-comment">/*    head */</span></span> __u16 transport_header; __u16 network_header; __u16 mac_header; <span class="hljs-comment"><span class="hljs-comment">/* sk_buff_data_t -    ,    head * tail -     * end -        */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sk_buff_data_t</span></span> tail; <span class="hljs-keyword"><span class="hljs-keyword">sk_buff_data_t</span></span> end; <span class="hljs-comment"><span class="hljs-comment">/* head -        * data -    . .   *      , *         . * (:  IP     TCP/UDP, *  Ethernet -  IP ) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *head, *data; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">atomic_t</span></span> users; };</code> </pre> <br><p>  Instances of this structure, I will briefly call <code>skb</code> . </p><br><p>  Together with each <code>struct sk_buff</code> , a buffer is allocated for headers with useful data (the same one to which <code>skb-&gt;head</code> , <code>skb-&gt;tail</code> is pointed) and the following structure immediately following them <code>struct skb_shared_info</code> .  (see <a href="">include / linux / skbuff.h</a> ). </p><br><img src="https://habrastorage.org/files/4aa/4ee/3c3/4aa4ee3c336a4842875b3324e2a99bb0.png"><br><p>  And several different skb can refer to one buffer and the corresponding <code>struct skb_shared_info</code> .  This is convenient for delivering one skb to several users who are allowed to change the <code>struct sk_buff</code> fields, but not the data in the buffer. </p><br><p>  The most interesting fields for us are <code>struct skb_shared_info</code> : </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skb_shared_hwtstamps</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ktime_t</span></span> hwtstamp; }; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skb_shared_info</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> __u8 tx_flags; <span class="hljs-comment"><span class="hljs-comment">/*    ,    */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skb_shared_hwtstamps</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hwtstamps</span></span></span><span class="hljs-class">;</span></span> };</code> </pre> <br><p>  The macro <code>skb_shinfo(skb)</code> is used to access <code>hwtstamps</code> and the <code>skb_hwtstamps(skb)</code> function is <code>skb_hwtstamps(skb)</code> to access the <code>hwtstamps</code> field.  (see <a href="">include / linux / skbuff.h</a> ) </p><br><h3>  struct net_device and struct sock </h3><br><ul><li>  `struct net_device` is allocated for each network device registered on the system.  It stores device configuration, statistics, and a bunch of other data.  In addition, when registering a device, the driver writes pointers to its structure to its functions, which are then called by the kernel.  (see <a href="">include / linux / netdevice.h</a> ) <br></li><li>  `struct sock` is allocated for each user-created socket and initialized by the address family specified by it (AF_INET, AF_PACKET ...).  Pointers to functions that implement system calls, queues are stored here. <br>  accepted by the socket, but not yet delivered to the user skb, flags, and more.  (see <a href="">include / net / sock.h</a> ). <br></li></ul><br><p>  We will not consider these structures in detail.  Now it‚Äôs enough to understand that the first one allows the kernel to communicate with the device, and the second with the user socket.  For a received packet: <code>skb-&gt;dev</code> indicates the device with which it was received;  <code>skb-&gt;sk</code> to the socket to which it will be delivered.  For the sender - the opposite. </p><br><h3>  SOFTIRQ </h3><br><p>  When the processor receives an interrupt, it calls the appropriate handler.  Handler execution occurs in the context of an interrupt ‚Äî for the processor serving the interrupt, <s>almost</s> all interrupts are disabled.  That is, the interrupt handler will not be interrupted until it completes itself.  The smaller the processor is in the interrupt context, the sooner it will be able to service new interrupts and respond to events from other devices. </p><br><p>  Although the interrupt handler may require a lot of CPU time, usually most of its work can wait.  That is why the actions of the interrupt handler can be divided into the upper (Top Half) and lower (Bottom Half) halves.  Top Half in the context of an interrupt performs urgent actions and plans to perform Bottom Half.  Bottom Half will be started by the kernel later outside the context of the interrupt and may be interrupted while running other interrupts. </p><br><p>  SOFTIRQ - The kernel mechanism for scheduling a deferred function call.  Often used to implement Bottom Half.  In total, there are ten different SOFTIRQs in the v4.1 kernel (see the <a href="">list</a> ), the handlers for which are defined when the kernel is compiled.  During its execution, the handler can only be interrupted by a hardware interrupt.  For each processor, its own mask is scheduled SOFTIRQ, that is, the handler will be called on the same processor from which it was scheduled.  (Actually, you can contrive and point out on which particular processor to schedule the SOFTIRQ.) The same SOFTIRQ can be scheduled and <br>  performed independently on two different processors.  When sending and receiving packets, two of them are used: NET_RX_SOFTIRQ with the net_rx_action handler and NET_TX_SOFTIRQ with the net_tx_action handler.  (see <a href="">net_rx_action</a> and <a href="">net_tx_action</a> ) </p><br><p>  To execute scheduled SOFTIRQ, the <code>do_softirq()</code> function is <code>do_softirq()</code> (see <a href="">kernel / softirq.c</a> ).  It calls SOFTIRQ handlers in turn, starting at the highest priority (the lower number is the higher priority).  It is called after each hardware interrupt handler.  In addition, the kernel process ksoftirqd spins on each processor, which periodically (as often - depending on the CPU load) causes <code>do_softirq()</code> . </p><br><h2>  Reception package </h2><br><p>  To communicate with network devices, Linux uses a mixture of interruptions and polling.  (see <a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/napi">NAPI</a> ) </p><br><p>  Here's what it looks like: </p><br><h3>  Top half </h3><br><img src="https://habrastorage.org/files/56e/fb1/a2d/56efb1a2d49d44a58bea0046a9d54a9f.png"><br><ol><li>  When a packet is received, the device sends an interrupt to one of the processors. </li><li>  The handler is called in the driver code.  The task of the handler is to inform the kernel about the presence of packages in its device, for this it calls the function `napi_schedule ()`, which: <br><ul><li>  add device to poll_list` <a href="https://habr.com/ru/company/metrotek/blog/304644/"><sup>*</sup></a> </li><li>  plans to perform NET_RX_SOFTIRQ </li></ul><br>  Note that the first operation is the addition of an element to the doubly linked list, and the second is setting the bit in the SOFTIRQ mask to be very fast.  Since the kernel is already aware that the device has packages, most likely the driver will want to temporarily disable interrupts on it. </li><li>  Exit the interrupt handler, immediately followed by a call to `do_softirq ()`. </li></ol><br><p>  <i><code>poll_list</code> <sup>*</sup> is a list created by the kernel for each processor core (as one of the fields of the <code>struct softnet_data</code> ).</i>  <i>It stores the devices from which NET_RX_SOFTIRQ will receive packets.</i> </p><br><h3>  Bottom half </h3><br><img src="https://habrastorage.org/files/9d9/b5a/58a/9d9b5a58aee04dd19fff0864af3d09b8.png"><br><p>  A call to <code>do_softirq()</code> occurred.  After executing the higher priority SOFTIRQ, the handler NET_RX_SOFTIRQ - <code>net_rx_action()</code> will be called. </p><br><p>  This function traverses the poll_list and for each dev device, while there are packages on it, it calls the virtual function napi-&gt; poll (see <a href="">include / linux / netdevice.h</a> .), Which: </p><br><ol><li>  Receives a packet from the Device, and forms skb </li><li>  Calling `netif_receive_skb (skb)` sends them to the kernel one at a time </li><li>  If there are no more packets on the device, enables an interrupt for it and reports the kernel with the function `napi_complete ()` </li></ol><br><p>  It should be noted that <code>net_rx_action()</code> allows processing no more than <code>netdev_budget</code> (exported to <code>/proc/sys/net/core/netdev_budget</code> ) packets at a time and limits its execution time to 2 / HZ seconds (on x86, the default is HZ = 1000, i.e. time limit = 2ms). </p><br><h4>  netif_receive_skb () </h4><br><p>  <code>netif_receive_skb()</code> is the function from which the packet gets from the driver to the kernel.  (In fact, it simply serves as a wrapper for other functions that do all the work.) Let's see what the kernel does with the resulting skb: </p><br><pre> <code class="hljs rust">#define net_timestamp_check(COND, SKB) \ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (static_key_false(&amp;netstamp_needed)) { \ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((COND) &amp;&amp; !(SKB)-&gt;tstamp.tv64) \ __net_timestamp(SKB); \ } \ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> int netif_receive_skb_internal(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sk_buff</span></span></span></span> *skb) { net_timestamp_check(netdev_tstamp_prequeue, skb); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __netif_receive_skb(skb); }</code> </pre> <br><p>  We see that the first thing after receiving a packet, the function calls the <code>net_timestamp_check</code> macro.  Now in order: </p><br><ul><li>  `static_key_false (&amp; netstamp_needed)` - check whether someone asked users to remove the timestamp immediately after receiving the package by the kernel.  It is implemented using static keys, this mechanism allows you to effectively enable / disable rarely used kernel functions (see <a href="https://raw.githubusercontent.com/torvalds/linux/master/Documentation/static-keys.txt">Documentation / static-keys.txt</a> ).  We will not consider it in detail. </li><li>  `netdev_tstamp_prequeue` is a variable exported to` / proc / sys / net / core / netdev_tstamp_prequeue`.  The default is 1. If you set it to 0, the timestamp will be taken off in the `__netif_receive_skb_core ()` function (We‚Äôll return to it.) </li><li>  The macro __net_timestamp (skb) `writes the current time to` skb-&gt; tstamp`. </li></ul><br><p>  Usually the packet is processed by the processor on which the SOFTIRQ was scheduled, and this is the processor on which the interrupt arrived.  Some network cards send only one interrupt to only one processor, not allowing parallelization of packet processing on multiprocessor systems.  To solve this problem, Receive Packet Steering (RPS) was invented. </p><br><p>  If RPS is enabled in the kernel, <code>netif_receive_skb_internal()</code> can put a packet in a queue (backlog) of another processor and schedule NET_RX_SOFTIRQ on it.  After some time, another processor will start processing this packet with the function <code>__netif_receive_skb()</code> , which calls <code>__netif_receive_skb_core()</code> .  Remember the <code>netdev_tstamp_prequeue</code> variable?  In the case of RPS, it allows you to choose when to remove a timestamp: before sending a packet to another queue or after retrieving it from there. </p><br><p>  RPS is configured via <code>/sys/class/net/&lt;interface&gt;/queues/</code> .  For more information, see the <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/network-rps.html">documentation on redhat.com</a> . </p><br><h4>  __netif_receive_skb_core () </h4><br><p>  First of all, this function removes the timestamp if it has not been removed in <code>netif_receive_skb_internal()</code> : </p><br><pre> <code class="hljs lisp"> net_timestamp_check(!netdev_tstamp_prequeue, skb)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Now we have skb, which contains: </p><br><ul><li>  data pointer `skb-&gt; data` </li><li>  in `skb-&gt; tstamp` the time the kernel gets the package </li><li>  in `skb_hwtstamps (skb)` the time when the network device received the packet </li></ul><br><p>  It remains to deliver it to all recipients. </p><br><p>  Depending on the required L3 protocol and device, recipients can be registered in several places: </p><br><ul><li>  `ptype_all` - list of those who want to receive all packages from all devices.  This is usually the AF_PACKET socket of some `tcpdump`. </li><li>  `ptype_base [PTYPE_HASH_SIZE]` is a hash table with L3 protocol numbers as keys. <br>  Here, those who want to receive packets of only a certain L3 protocol from all devices are registered. <br>  For example, for all AF_INET sockets, there is one handler listed here - the function `ip_recv`. </li><li>  `skb-&gt; dev-&gt; ptype_all` is the same list as` ptype_all`.  In which those are recorded <br>  who wants to get all the packages from the `skb-&gt; dev` device. </li><li>  `skb-&gt; dev-&gt; ptype_specific` - this list contains those who want to receive packets of a specific protocol <br>  from the device `skb-&gt; dev`. </li></ul><br><p>  Frequent users of all 4 lists - AF_PACKET sockets, each of them with a <code>bind</code> system call registers a handler in the corresponding list.  (The handler is called <a href=""><code>packet_rcv</code></a> ) In fact, there are still a lot of recipients, but we will limit ourselves only to those that deliver the packet to the sockets in user space. </p><br><p>  UDP or TCP packet will be accepted by the <code>ip_recv</code> function.  Through this feature, packets get into the TCP / IP stack processing.  Processing includes checksum checks, passing through iptables tables, searching for a receiving socket by ip address and port number, deleting L2, L3, L4 snoops (which should not get into userspace). </p><br><p>  When it became clear which socket should receive this skb, the skb is placed in the socket receive queue.  When the user calls recvmsg on this socket, the packet data (those that come after the tcp / udp header) will be copied to the specified user buffer in userspace, and both timestamps will be in the control message (see <code>man 3 cmsg</code> and <code>man 2 recvmsg</code> ) in <code>struct timespec</code> format.  (See <a href="https://github.com/torvalds/linux/blob/master/Documentation/networking/timestamping.txt">Documentation / networking / timestamping.txt</a> .) </p><br><p>  Time stamps are put in the control message by the function <code>__sock_recv_timestamp</code> .  (see <a href="">net / socket.c</a> ). </p><br><p>  An important difference: <code>ip_recv</code> registered as a handler only once in ptype_base no matter how many AF_INET sockets you create, and <code>packet_rcv</code> registered for each AF_PACKET socket once in any of the lists. </p><br><h2>  Delay Testing </h2><br><p>  We have seen that timestamps are removed twice for received packets: a network card (T <sub>hard</sub> ), the kernel immediately upon receipt (T <sub>soft</sub> ).  Summing up, let's see what causes the delays between them and the moment the packet is delivered to the user (T <sub>user</sub> ): </p><br><ul><li>  T <sub>soft</sub> - T <sub>hard</sub> = [wait NET_RX_SOFTIRQ] + [kernel processing of other packages (including packages from other devices)] <br><br>  If the NET_RX_SOFTIRQ call failed to process our packet (netdev_budget or time limit 2 / HZ was exceeded), the kernel will allow other processes to run until the hardware interrupt or ksoftirqd calls `do_softirq ()` again.  Also do not forget that there are other SOFTIRQ, the implementation of which also takes time. <br><br>  Even with the execution of NET_RX_SOFTIRQ, some packages will be processed before ours. <br></li><li>  T <sub>user</sub> - T <sub>soft</sub> = [delivery to other sockets] + [delivery to our socket] 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Depending on what these sockets are, delivery may take different times. <br></li></ul><br><p>  In order to estimate roughly how great these delays are and how predictable they are, we use the <a href="https://github.com/gnull/tstest">rxtest</a> program.  This program: </p><br><ol><li>  creates socket (packet or UDP) </li><li>  sets up software and hardware timestamps for received packets via SO_TIMESTAMPING </li><li>  accepts a specified number of packets from the socket along with temporary labels </li><li>  considers for delays the mean value and standard deviation </li></ol><br><p>  The test was conducted on a Core i7 with Linux 4.0 with an <a href="http://www.intel.com/content/www/us/en/embedded/products/networking/82599-10-gbe-controller-brief.html">Intel 82599ES</a> network card running the <a href="http://lxr.free-electrons.com/source/drivers/net/ethernet/intel/ixgbe/%3Fv%3D4.0">ixgbe driver</a> . </p><br><p>  In my case, the network card has its own hardware clock and removes timestamps on them.  And there is no guarantee that this clock is somehow synchronized with the core jiffies.  To fix this, run the <code>phc2sys</code> program from <a href="http://linuxptp.sourceforge.net/">linuxptp</a> : </p><br><pre> <code class="hljs objectivec"> <span class="hljs-meta"><span class="hljs-meta">#     eth5 phc2sys -s CLOCK_REALTIME -c eth5 -m</span></span></code> </pre> <br><p>  It needs to be kept open throughout the test.  It will be engaged in adjusting the clock of the network card under the system time and display the current time difference.  In my case, the absolute value of the discrepancy did not exceed 10 ns. </p><br><p>  In addition to setting the SO_TIMESTAMPING settings on the socket, we need to ask the network card to remember the timestamps.  Let's use for this the <code>hwstamp_ctl</code> utility from the same <code>linuxptp</code> . </p><br><pre> <code class="hljs matlab"> hwstamp_ctl -<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> eth5 -r <span class="hljs-number"><span class="hljs-number">13</span></span></code> </pre> <br><p>  This will cause the network card to remove timestamps for all PTP Sync packets.  Why choose Sync PTP?  Because our network card does not know how to remove timestamps for all packages.  She definitely needs to specify some type of PTP protocol packet.  (This is due to the fact that support for hardware timestamps in Linux was introduced for the operation of the PTP protocol, which allows time synchronization to nanosecond accuracy.) </p><br><p>  Start rxtest: </p><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">rxtest</span></span> packet eth5 <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br><p>  Meanwhile, the helmet from the other end of the cable is 10 PTP Sync packets per second.  (I took examples of PTP packets from <a href="https://wiki.wireshark.org/Protocols/ptp">https://wiki.wireshark.org/Protocols/ptp</a> and sent them using tcpreplay.) </p><br><p>  The output of rxtest: </p><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hard-</span></span>&gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">soft</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">delay</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">packets</span></span> 1000: 18<span class="hljs-selector-class"><span class="hljs-selector-class">.1603</span></span> +<span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.18737</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">microseconds</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">soft-</span></span>&gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">user</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">delay</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">packets</span></span> 1000: 5<span class="hljs-selector-class"><span class="hljs-selector-class">.54756</span></span> +<span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.88607</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">microseconds</span></span></code> </pre> <br><p>  At the same time, the ip-address was not assigned to the tested network interface and our packets did not get to be processed by IP protocol.  This can explain a very small delay T <sub>user</sub> - T <sub>soft</sub> . </p><br><p>  Adequate research of delays and their dependence on various parameters (netdev_budget, frequency of received packets, CPU load, kernel configuration, number and type of open sockets) would be enough for a whole article.  The purpose of this article is to <s>pour water over to</s> consider the mechanism of package delivery and what causes delays. </p><br><p>  That's all.  I will be glad to any feedback and criticism. </p><br><h2>  Links </h2><br><ul><li>  <a href="http://shop.oreilly.com/product/9780596002558.do">Christian Benvenuti.</a>  <a href="http://shop.oreilly.com/product/9780596002558.do">Understanding Linux Network Internals</a> </li><li>  <a href="http://free-electrons.com/doc/books/ldd3.pdf">Jonathan Corbet, Alessandro Rubini, Greg Kroah-Hartman.</a>  <a href="http://free-electrons.com/doc/books/ldd3.pdf">Linux device drivers</a> </li><li>  <a href="http://lxr.free-electrons.com/">http://lxr.free-electrons.com/</a> </li><li><p>  <a href="http://www.linuxfoundation.org/collaborate/workgroups/networking">http://www.linuxfoundation.org/collaborate/workgroups/networking</a> </p><br></li><li>  <a href="http://lxr.free-electrons.com/source/Documentation/networking/timestamping.txt">Documentation / networking / timestamping.txt</a> - <code>SO_TIMESTAMPING</code> documentation </li><li>  <a href="http://lxr.free-electrons.com/source/Documentation/networking/timestamping/">Documentation / networking / timestamping /</a> - examples of programs with <code>SO_TIMESTAMPING</code> </li><li>  <a href="http://linuxptp.sourceforge.net/">http://linuxptp.sourceforge.net/</a> - set of programs for time synchronization via PTP, uses <code>SO_TIMESTAMPING</code> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/304644/">https://habr.com/ru/post/304644/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304634/index.html">HTML :: Phl module for processing HTML documents containing Perl code instructions</a></li>
<li><a href="../304636/index.html">How I changed the main domain in Google Apps</a></li>
<li><a href="../304638/index.html">"Confrontation" through the eyes of a defender: A story about PHDays CTF from a competitor</a></li>
<li><a href="../304640/index.html">Instant Run: how does it work?</a></li>
<li><a href="../304642/index.html">A little bit about improving database performance: Practical advice</a></li>
<li><a href="../304646/index.html">One unobvious vulnerability of some VKontakte groups</a></li>
<li><a href="../304650/index.html">We build payment acceptance into a mobile application, or why you can forget about PCI DSS and PA DSS</a></li>
<li><a href="../304652/index.html">Friday format: IaaS and science - how it works</a></li>
<li><a href="../304654/index.html">‚ÄúRide the IaaS Wave‚Äù: How and by whom is the virtual infrastructure used?</a></li>
<li><a href="../304656/index.html">IaaS and Science: How it works. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>