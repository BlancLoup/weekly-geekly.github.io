<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We rewrite the home project on microservices (Java, Spring Boot, Gradle)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 





 In recent years, the topic of microservices has become very popular. I didn‚Äôt get into projects with microservices, so I naturally...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We rewrite the home project on microservices (Java, Spring Boot, Gradle)</h1><div class="post__text post__text-html js-mediator-article"><h2 id="vvedenie">  Introduction </h2><br><p><img src="https://habrastorage.org/web/43c/80b/fcf/43c80bfcfe934dcb86473243041bdea9.png" alt="Image"></p><br><p>  In recent years, the topic of microservices has become very popular.  I didn‚Äôt get into projects with microservices, so I naturally wanted to know more about this concept of architecture. </p><br><p>  Previously, I had a home project (although rather even its prototype), which was decided to be rewritten into microservices.  The project was an attempt to make an educational Java game.  That is, the player has a field, in this field he can control some unit with the help of a code.  Writes the code, sends it to the server, there it runs and returns the result that is displayed to the user. </p><br><p>  All this was implemented as a prototype - there were users, one lesson and one task for it, the ability to send code that was compiled and executed.  Some frontend, but in the article about him will not be.  Technologies - Spring Boot, Spring Data, Gradle. </p><br><p>  The article will be implemented the same prototype, but on microservices.  Implementation will be the easiest way (more precisely, the simplest one I know).  The implementation will be available to anyone familiar with Spring. </p><a name="habracut"></a><br><p> In the process of studying the information, I found a good <a href="https://habrahabr.ru/post/280786/">article</a> , where a certain small monolith on microservices was similarly broken.  But there everything was done on the basis of Spring Cloud, which is definitely more correct, but I wanted to write a bicycle first, so that in practice I could understand from what problems these solutions are curing.  From this article I used only <code>Zuul</code> . </p><br><h2 id="mikroservisy">  Microservices </h2><br><p>  About what microservices have been written many times, for example <a href="https://habrahabr.ru/post/249183/">here</a> .  In short: instead of one big application, we have many small ones, which have a very narrow area of ‚Äã‚Äãresponsibility and communicate with each other. </p><br><p>  The first stage, it is necessary to break the logic into a number of microservices: </p><br><ul><li>  <code>user-service</code> : service with users (creation, viewing, authorization is possible) </li><li>  <code>lesson-service</code> : service with lessons (creating, viewing lessons and tasks) </li><li>  <code>result-service</code> : service with answers (sending completed tasks, storing results) </li><li>  <code>task-executor-service</code> : code execution service (compilation and execution of tasks) </li></ul><br><p>  At this stage, the idea appears that with all this zoo you need to somehow communicate the frontend and individual microservices.  It seems inconvenient if everyone knows each other's APIs and addresses. <br>  From here, another service appears - <code>gateway-service</code> - a common entry point. </p><br><p>  The project outline will look like this: </p><br><p><img src="https://habrastorage.org/web/0bb/f05/528/0bbf0552807643b68ef8852fa2e28fe6.png" alt="diagram"></p><br><h2 id="gateway-service">  Gateway service </h2><br><p>  As I walk along the simplest path, the first thought was to simply make the controller for each microservice, which would redirect all requests to the correct addresses using <code>RestTemplate</code> .  But, a little googling, I found <a href="https://github.com/Netflix/zuul/wiki">Zuul</a> .  It has integration with Spring Boot and the configuration is very simple. </p><br><p>  The build.gradle service looks like this: </p><br><pre> <code class="hljs cs">plugins { id <span class="hljs-string"><span class="hljs-string">'java'</span></span> id <span class="hljs-string"><span class="hljs-string">'war'</span></span> } apply plugin: <span class="hljs-string"><span class="hljs-string">'spring-boot'</span></span> springBoot { mainClass <span class="hljs-string"><span class="hljs-string">'gateway.App'</span></span> } dependencies { compile(<span class="hljs-string"><span class="hljs-string">'org.springframework.cloud:spring-cloud-starter-zuul:1.2.0.RELEASE'</span></span>) compile(<span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-web'</span></span>) }</code> </pre> <br><p>  And the whole microservice code consists of one class, App.java: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableZuulProxy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(App.class, args); } }</code> </pre> <br><p>  This includes ZuulProxy.  Routing is described in the config, I have this <code>application.properties</code> : </p><br><pre> <code class="hljs ruby">zuul.routes.lesson-service.url=<span class="hljs-symbol"><span class="hljs-symbol">http:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/localhost:8081 zuul.routes.user-service.url=http:/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/localhost:8082 zuul.routes.task-executor-service.url=http:/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/localhost:8083 zuul.routes.result-service.url=http:/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/localhost:8084 zuul.prefix=/services</span></span></code> </pre> <br><p>  Thus, requests for <code>/services/lesson-service/...</code> will be sent to <code>http://localhost:8081/...</code> etc.  It turns out very convenient and simple solution for the entry point. <br>  Zuul has many other different filter type features, but we don‚Äôt need anything else from it. </p><br><p>  Frontend, as it seems to me, in our case should be given to the client from here.  We put everything that is needed in the <code>gateway-service/src/main/webapp/...</code> and that's it. </p><br><h2 id="ostalnye-servisy">  Other services </h2><br><p>  The remaining services will be very similar to each other and their implementation is not much different from the usual approach.  But there are a few points: </p><br><ol><li>  Database. </li><li>  Interaction between microservices. </li></ol><br><h3 id="bazy-dannyh">  Database </h3><br><p>  Each microservice can now decide for itself how to store data.  The traditional advantage of microservices is the freedom to choose technologies independently of other parts of the application. </p><br><p>  It is possible for everyone to use a new type of database.  But I just had three <code>MySQL</code> databases instead of one for <code>user-service</code> , <code>lesson-service</code> and <code>answer-service</code> .  A <code>task-executor-service</code> must store some task code into which user code is inserted to perform the task.  It will be stored without a database, just as files. </p><br><p>  At the moment of splitting the scheme into three bases, I had a question: how are foreign keys, data integrity at the database level and so on.  As it turned out nothing.  More precisely - all at the level of business logic. </p><br><h3 id="vzaimodeystvie-mezhdu-mikroservisami">  Interaction between microservices </h3><br><p>  At the moment when we begin to implement the first microservice, the question arises how to request data from another.  It is clear that such functionality is needed in all services, which means you need something like a library. </p><br><p>  Create a new module in the project, call it <code>service-client</code> .  In it there will be, first, classes for interaction with services, secondly, general classes for data transfer.  That is, each service has its own <code>Entity</code> , corresponding to the internal logic or database schema, but they should only give out copies of objects from the common library. </p><br><p>  For client classes, we write the abstract Client class: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Client</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RestTemplate rest; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String serviceFullPath; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String GATEWAY_PATH = <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/services"</span></span>; Client(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String servicePath) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RestTemplate(Collections.singletonList(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MappingJackson2HttpMessageConverter())); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serviceFullPath = GATEWAY_PATH + servicePath; } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &lt;T extends Result&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class&lt;T&gt; type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rest.getForObject(serviceFullPath + path, type); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &lt;T extends Result, E&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> E object, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class&lt;T&gt; type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rest.postForObject(serviceFullPath + path, object, type); } }</code> </pre> <br><p>  <code>GATEWAY_PATH</code> - better to set from the config or something else, and not hardcodes in this class. <br>  And an example of the inheritance of this class for <code>lesson-service</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskClient</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Client</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String SERVICE_PATH = <span class="hljs-string"><span class="hljs-string">"/lesson-service/task/"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TaskClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(SERVICE_PATH); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(id.toString(), TaskResult.class).getData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Task&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(<span class="hljs-string"><span class="hljs-string">""</span></span>, TaskListResult.class).getData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Task&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getListByLesson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long lessonId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(<span class="hljs-string"><span class="hljs-string">"/getByLesson/"</span></span> + lessonId, TaskListResult.class).getData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TaskCreation taskCreation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> post( <span class="hljs-string"><span class="hljs-string">"/add"</span></span>, taskCreation, TaskResult.class).getData(); } }</code> </pre> <br><p>  There may be a question, what is the <code>Result</code> and why we return the result from <code>getData()</code> for it.  Each controller returns not just a certain requested object in json, but also additional meta-information, which can be useful later, so I didn‚Äôt remove it when rewriting into microservices.  That is, an object of the <code>Result&lt;T&gt;</code> class is returned, where <code>T</code> is the requested object itself: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String message; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T data; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Result&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">success</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Result&lt;&gt;(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, data); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Result&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String message)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Result&lt;&gt;(message, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Result&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Supplier&lt;T&gt; function )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> T result = function.get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result.success(result); } }</code> </pre> <br><p>  There is no <code>getData()</code> method, although it is previously used in the code.  All this thanks to the <code>@Data</code> annotation from <a href="https://projectlombok.org/">lombok</a> , which I actively used.  <code>Result</code> convenient because further you can easily add some meta-information (for example, the execution time of the request), and somehow use it. </p><br><p>  Now, to use the code we have written in other modules, it is enough to add a dependency ( <code>compile project(':service-client')</code> to the dependencies block) and create such a bin.  Here is the <code>result-service</code> configuration: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span>(scanBasePackages = <span class="hljs-string"><span class="hljs-string">"result"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@EnableJpaRepositories</span></span>(<span class="hljs-string"><span class="hljs-string">"result.repository"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(App.class, args); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> UserClient </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UserClient(); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TaskClient </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTaskClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskClient(); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ExecutorClient </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTaskExecutor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExecutorClient(); } }</code> </pre> <br><p>  Its controller is: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResultController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ResultService service; <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(value = <span class="hljs-string"><span class="hljs-string">"/submit"</span></span>, method = RequestMethod.POST) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Result&lt;TaskResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">submit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestBody </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SubmitRequest submit)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> run(() -&gt; service.submit(submit)); } <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(value = <span class="hljs-string"><span class="hljs-string">"/getByTask/{id}"</span></span>, method = RequestMethod.GET) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Result&lt;List&lt;AnswerEntity&gt;&gt; getByTask(<span class="hljs-meta"><span class="hljs-meta">@PathVariable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Long id) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> run(() -&gt; service.getByTask(id)); } }</code> </pre> <br><p>  It is seen that everywhere the controller returns a <code>Result&lt;T&gt;</code> .  And a fragment of the service: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResultService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> AnswerRepository answerRepository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TaskClient taskClient; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ExecutorClient executorClient; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TaskResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">submit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SubmitRequest submit)</span></span></span><span class="hljs-function"> </span></span>{ val task = taskClient.get(submit.getTaskId()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Invalid task id"</span></span>); val result = executorClient.submit(submit); val answerEntity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnswerEntity(); answerEntity.setAnswer(submit.getCode()); answerEntity.setTaskId(task.getId()); answerEntity.setUserId(<span class="hljs-number"><span class="hljs-number">1L</span></span>); answerEntity.setCorrect(result.getStatus() == TaskResult.Status.SUCCESS); answerRepository.save(answerEntity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } ...</code> </pre> <br><p>  <code>answerEntity.setUserId(1L)</code> - for now, it‚Äôs just a constant, for now it‚Äôs totally incomprehensible how to do authorization. </p><br><p>  In general, the main part was done, we model all other services according to the model and everything should work.  But it remains to deal with users and their authorization.  This turned out to be the most difficult part for me. </p><br><h2 id="avtorizaciya">  Authorization </h2><br><p>  Previously, before breaking down into microservices, authorization was standard - by username and password, the user was authorized within the application context. </p><br><p>  Now the task is expanding, and each of the services must understand whether the user on whom the request came to the service is authorized.  And this is despite the fact that requests come not only directly from the user, but also from other services. </p><br><p>  The initial search led me to various articles showing how to fumble sessions using <code>Redis</code> , but what I read seemed too complicated for a hello-world home project.  After a while, returning to the question, I already found information about <code>JWT</code> - JSON Web Token.  By the way, repeating the search attempts while writing this article, I immediately ran across JWT. </p><br><p>  The idea is simple - instead of cookies, which usually hold authorization, the authorizing service will issue a certain token, which includes user data, issuing time and other information you need.  Then, for any access to the services, the client must pass this token in the header (or in some other way as convenient).  Each service can decipher it and understand what kind of user it is, and it does not need to go into the database and all that. </p><br><p>  This raises many problems, such as how to revoke a token.  There are ideas with several tokens (long and short, the second is used for normal requests, the first for receiving a new token of the second type and just the first can be withdrawn and to check it you need to go into the database). </p><br><p>  Many articles have been written on this topic, for example <a href="https://habrahabr.ru/post/267349/">this one</a> , and there are already ready-made libraries for use. </p><br><p>  But we have a hello-world project, so we do not need a serious and very correct authorization, but we need something that can be quickly implemented, but that nonetheless will work quite well. </p><br><p>  So, having read the Internet a little, for example <a href="https://habrahabr.ru/post/278411/">this</a> article, we decide that there will be only one token and it will be issued by the <code>user-service</code> .  Add dependencies: </p><br><pre> <code class="hljs lisp">compile('org.springframework.boot<span class="hljs-symbol"><span class="hljs-symbol">:spring-boot-starter-security</span></span>') compile('io.jsonwebtoken<span class="hljs-symbol"><span class="hljs-symbol">:jjwt</span></span>:<span class="hljs-number"><span class="hljs-number">0.7</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>')</code> </pre> <br><p>  The second is needed just to generate the token itself.  We generate the token as follows for the request with the correct login and password: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> UserEntity user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;String, Object&gt; tokenData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); tokenData.put(TokenData.ID.getValue(), user.getId()); tokenData.put(TokenData.LOGIN.getValue(), user.getLogin()); tokenData.put(TokenData.GROUP.getValue(), user.getGroup()); tokenData.put(TokenData.CREATE_DATE.getValue(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date().getTime()); Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DATE, tokenDaysAlive); tokenData.put(TokenData.EXPIRATION_DATE.getValue(), calendar.getTime()); JwtBuilder jwtBuilder = Jwts.builder(); jwtBuilder.setExpiration(calendar.getTime()); jwtBuilder.setClaims(tokenData); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jwtBuilder.signWith(SignatureAlgorithm.HS512, key).compact(); }</code> </pre> <br><p>  <code>key</code> here is the secret key of the token that all services must know to decode the token.  I did not like the fact that you need to write it to the config of each service, but other options are more complicated. </p><br><p>  Next, we need to write a filter that with each request will check the token and authorize if everything is ok.  But the filter will no longer be in the <code>user-service</code> , but in the <code>service-client</code> , since  This is a common code for all services. </p><br><p>  Filter itself: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TokenAuthenticationFilter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericFilterBean</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TokenService tokenService; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenAuthenticationFilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TokenService tokenService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tokenService = tokenService; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doFilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, ServletException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String token = ((HttpServletRequest) request).getHeader(TokenData.TOKEN.getValue()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { chain.doFilter(request, response); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TokenAuthentication authentication = tokenService.parseAndCheckToken(token); SecurityContextHolder.getContext().setAuthentication(authentication); chain.doFilter(request, response); } }</code> </pre> <br><p>  If the token is not sent, we do nothing, otherwise we try to authorize the client.  Verification of authorization is no longer carried out by us, but later in another (standard) filter from spring security.  <code>TokenService</code> , where a direct token check occurs: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TokenService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String key; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.key = key; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TokenAuthentication </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseAndCheckToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String token)</span></span></span><span class="hljs-function"> </span></span>{ DefaultClaims claims; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { claims = (DefaultClaims) Jwts.parser().setSigningKey(key).parse(token).getBody(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AuthenticationServiceException(<span class="hljs-string"><span class="hljs-string">"Token corrupted"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (claims.get(TokenData.EXPIRATION_DATE.getValue(), Long.class) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AuthenticationServiceException(<span class="hljs-string"><span class="hljs-string">"Invalid token"</span></span>); } Date expiredDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(claims.get(TokenData.EXPIRATION_DATE.getValue(), Long.class)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!expiredDate.after(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date())) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AuthenticationServiceException(<span class="hljs-string"><span class="hljs-string">"Token expired date error"</span></span>); } Long id = claims.get(TokenData.ID.getValue(), Number.class).longValue(); String login = claims.get(TokenData.LOGIN.getValue(), String.class); String group = claims.get(TokenData.GROUP.getValue(), String.class); TokenUser user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TokenUser(id, login, group); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TokenAuthentication(token, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, user); } }</code> </pre> <br><p>  <code>TokenData</code> is an enum for convenience, from which you can take string representations of fields.  There are also two classes - <code>TokenUser</code> (this is a class with three fields) and <code>TokenAuthentication</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TokenAuthentication</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Authentication</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String token; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Collection&lt;? extends GrantedAuthority&gt; authorities; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isAuthenticated; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TokenUser principal; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenAuthentication</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String token, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isAuthenticated, TokenUser principal)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token = token; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.authorities = Collections.singletonList(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleGrantedAuthority(principal.getGroup())); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isAuthenticated = isAuthenticated; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.principal = principal; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> authorities; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCredentials</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDetails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (principal != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> principal.getLogin(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPrincipal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> principal; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAuthenticated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isAuthenticated; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAuthenticated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isAuthenticated)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IllegalArgumentException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isAuthenticated = isAuthenticated; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> token; } }</code> </pre> <br><p>  The <code>user-service</code> config will now look like this: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableJpaRepositories</span></span>(<span class="hljs-string"><span class="hljs-string">"user.repository"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@ComponentScan</span></span>(value = <span class="hljs-string"><span class="hljs-string">"user"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@EnableWebSecurity</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableGlobalMethodSecurity</span></span>(securedEnabled = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, prePostEnabled=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSecurityConfigurerAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${token.key}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String tokenKey; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(App.class, args); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BCryptPasswordEncoder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bCryptPasswordEncoder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BCryptPasswordEncoder(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpSecurity http)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ http .headers().frameOptions().sameOrigin() .and() .csrf() .disable() .addFilterAfter(tokenAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>(name = <span class="hljs-string"><span class="hljs-string">"tokenAuthenticationFilter"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TokenAuthenticationFilter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tokenAuthenticationFilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TokenAuthenticationFilter(tokenService()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>(name = <span class="hljs-string"><span class="hljs-string">"tokenService"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TokenService </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tokenService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TokenService tokenService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TokenService(); tokenService.setKey(tokenKey); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenService; } }</code> </pre> <br><p>  The key here is <code>.addFilterAfter(tokenAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)</code> , register the filter and specify when it should be run.  I like to restrict access to resources not in the config, but in annotations over the controller methods, for example <code>@Secured("ROLE_ADMIN")</code> . </p><br><p>  The appearance of the token makes it necessary to receive it not only from the client, but also from other services, respectively, you need to be able to send it further.  To do this, I simply accept the tokens from the headers in the controllers, where it is needed, and pass it to the methods of the service client.  That is, the <code>Client</code> class gets two get and post methods, for the case with and without a token, an example: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &lt;T extends Result&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class&lt;T&gt; type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rest.getForObject(serviceFullPath + path, type); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &lt;T extends Result&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class&lt;T&gt; type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String token)</span></span></span><span class="hljs-function"> </span></span>{ HttpHeaders headers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpHeaders(); headers.set(TokenData.TOKEN.getValue(), token); HttpEntity entity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpEntity(headers); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rest.exchange(serviceFullPath + path, HttpMethod.GET, entity, type).getBody(); }</code> </pre> <br><p>  Concrete client classes change accordingly.  And in the controller we get a token using annotations, for example: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PreAuthorize</span></span>(<span class="hljs-string"><span class="hljs-string">"isAuthenticated()"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(value = <span class="hljs-string"><span class="hljs-string">"/submit"</span></span>, method = RequestMethod.POST) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Result&lt;TaskResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">submit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestBody </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SubmitRequest submit, @RequestHeader(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"token"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String token)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> run(() -&gt; service.submit(submit, token)); }</code> </pre> <br><p>  Although this is a simple solution, it seems inconvenient - constant fussing with the token, its reception, transfer to the methods.  It would seem to me more correct to make all the same automatic. </p><br><p>  When authorizing by a token, remembering it (this is almost done already, you can look at the <code>TokenAuthentication</code> class), and when using the Client classes, automatically retrieve the token, if it exists, and transfer it to the next service. </p><br><p>  In addition, it may be necessary to distinguish requests directly from the client and requests from another service.  I think, in this case, the service to which the request came from the user can regenerate the token by inserting a flag into it and then use it to access other services. </p><br><h2 id="zapusk">  Launch </h2><br><p>  There is not a single finished product that allows you to deploy and manage microservices, monitor their condition and so on, but it seems to me that this already goes beyond the limits of hello-world.  To get started, I just run the <code>bootRun</code> for each service and enjoy the result. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  In general, it was an interesting and rewarding experience (writing bicycles is always interesting), but if I wanted to develop my project further, I would roll back all the changes and continue working on the classic monolith, because  on the scale of such a small project, the complexity of managing this all has greatly increased, and there are few advantages. </p><br><p>  As many people have already said in various articles, the choice of such an architecture is not appropriate everywhere and should be taken sensibly.  Or purely for the sake of self-study to write such bikes, as described above. </p><br><p>  Hope the article was helpful. </p><br><p>  ‚Üí Full source code of the project can be found <a href="https://github.com/z17/GamePro100">here</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/332482/">https://habr.com/ru/post/332482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332470/index.html">It's about time: a secure corporate instant messenger from a Russian integrator will be shown in Digital October</a></li>
<li><a href="../332472/index.html">Analysis of the backdoor group TeleBots</a></li>
<li><a href="../332474/index.html">Backup scripts to the Google Cloud Platform (GCP) cloud in five minutes</a></li>
<li><a href="../332476/index.html">We design storage for video surveillance</a></li>
<li><a href="../332478/index.html">Try to work less to fit your culture</a></li>
<li><a href="../332484/index.html">Growing up on Python problems</a></li>
<li><a href="../332486/index.html">Programming and martial art: what is common?</a></li>
<li><a href="../332488/index.html">New pack of Otus coding Owl stickers</a></li>
<li><a href="../332490/index.html">The main problem of CG in Russia and the first step towards its solution</a></li>
<li><a href="../332492/index.html">PHDays HackBattle: breaking one by one</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>