<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Nearly 2018, and we love callbacks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If at first the idea does not seem absurd, it is hopeless. 
 - Albert Einstein 

 We collected for you the most popular topics from the Node.js discus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Nearly 2018, and we love callbacks</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  If at first the idea does not seem absurd, it is hopeless. <br>  - Albert Einstein </blockquote><p>  We collected for you the most popular topics from the Node.js discussions on Habr√© and asked recognized experts to talk about them: non-commercial Node-hacker Mathias Madsen and author of many books and courses on Node, Azat Mardan. </p><br><p>  Here is the exact list of topics: </p><br><ol><li>  Node.js streams and methods for parallelizing calculations; </li><li>  Asynchrony in Node.js; </li><li>  Debugging and logging in Node.js; </li><li>  Performance monitoring issues in production; </li><li><p>  Tools for monitoring nodes. </p><br><p><img src="https://habrastorage.org/webt/vm/l3/sk/vml3skpluo_juiv-dekm1alipwg.jpeg" width="200" align="left">  <strong>Azat Mardan</strong> - Tech Fellow, manager of <a href="https://www.capitalone.com/">Capital One</a> , and a JavaScript / Node.js expert with several online courses at <a href="https://www.udemy.com/user/azatmardanov/">Udemy</a> and <a href="https://node.university/courses">Node University</a> , and the author of 14 books on the same topics, including ‚Äú <a href="https://www.manning.com/books/react-quickly">React Quickly</a> ‚Äù(Manning, 2017),‚Äú <a href="http://www.apress.com/us/book/9781484217504">Full Stack JavaScript</a> ‚Äù(Apress, 2015),‚Äú <a href="http://www.apress.com/us/book/9781430265955">Practical Node.js</a> ‚Äù(Apress, 2014) and‚Äú <a href="http://www.apress.com/us/book/9781484200384">Pro Express.js</a> ‚Äù(Apress, 2014). </p><br></li></ol><br><p><br clear="all"><img src="https://habrastorage.org/webt/6e/gh/mc/6eghmcgufmhb50t8dugw1n_qv7s.png"><br><br clear="all"></p><a name="habracut"></a><br><p>  In his spare time, Azat writes about technology on <a href="http://webapplog.com/">Webapplog.com</a> , speaks at conferences and contributes to open-source.  Before becoming an expert at Node.js, Azat completed a master's degree in information systems, and worked in US federal government agencies, small startups, and large corporations with various technologies, such as Java, SQL, PHP, Ruby, etc. </p><br><p>  Azat is passionate about technology and finance, as well as new, stunning, ways of learning and empowering people. <br><br clear="all"></p><br><p><img src="https://habrastorage.org/webt/cm/ve/vo/cmvevo6kxj8nzlvcfcwhcunmzje.jpeg" width="200" align="left">  <strong>Mathias Buus Madsen</strong> is a non-commercial Node.js hacker based in Copenhagen, Denmark.  He works full-time with open source and in the Dat project ( <a href="http://dat-data.com/"></a>  <a href="http://dat-data.com/">http://dat-data.com</a> ), creating open source tools that allow scientists to share datasets.  Currently it supports more than 400 modules per npm, which in itself is impressive. <br><br clear="all">  We remind you that you can meet them live at the conference <a href="https://holyjs-moscow.ru/">HolyJS 2017 Moscow</a> . </p><br><p>  The appearance of server-side JavaScript on the stage for a long time divided the programming community into those who accepted it, and all the rest ... You and I are not used to holivar, especially when it comes to something obvious, such as the idea that websites are well written in PHP (hmm ..., or in Perl? or in Python? .. however, it does not matter, post something about Node.js), it will be much more interesting for us to discuss, not on what to write, but as of this, the only right well-suited language / stack get decent results.  Moreover, Node is developing, the community is expanding, versions are appearing, the server engine is only being improved, and the arrival of a bright tomorrow (amid gray yesterday) is at least not far off!  Let's see what the experts say ... </p><br><h1 id="azat">  Azat </h1><br><p>  (I am answering questions on the state of affairs at the end of 2017, which means Node 8, npm 5, and so on; today something has changed compared to the early days of Node, but something has remained more or less the same). </p><br><h2 id="1-potoki-v-nodejs-i-sposoby-rasparallelivaniya-vychisleniy">  1. Streams in Node.js and methods for parallelizing calculations </h2><br><p> As many know, Node is single threaded;  in this and strengths and weaknesses Node.  Strong because it's easier to implement <a href="https://node.university/courses/you-dont-know-node/lectures/1590280">asynchronous non-blocking code</a> that allows your systems to perform more I / O operations, which usually means handling more traffic.  Weak due to the fact that you can write code that will be <a href="https://node.university/courses/you-dont-know-node/lectures/1590277">blocked</a> .  You will help the initiation of multiple threads.  There is a cluster module at the core of the language, but most Node developers use <code>pm2</code> .  It supports development ( <code>pm2-dev</code> ) and containers ( <code>pm2-docker</code> ).  To get started with pm2, just install it using npm and run it in the background: </p><br><pre> <code class="hljs pgsql">npm i -g pm2 pm2 <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.js -i <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  If <code>pm2</code> does not fit all your requirements, and you still need to work at a lower level, you can use <code>cluster</code> .  In new versions of Node (current version 8) it has load balancing, as in <code>pm2</code> .  As a result, several of your processes will be able to listen on the same port, and will be able to interact with each other and with the main process.  You should use <code>fork()</code> with <code>cluster</code> .  Here is a good example: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cluster = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'cluster'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numCPUs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'os'</span></span>).cpus().length <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cluster.isMaster) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numCPUs; i++) { cluster.fork() } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cluster.isWorker) { <span class="hljs-comment"><span class="hljs-comment">// your server code })</span></span></code> </pre> <br><p>  Finally, there are two methods for manually creating processes in addition to <code>fork()</code> : <code>spawn()</code> and <code>exec()</code> .  The first is for lengthy processes, streaming, and large amounts of data, while the second is suitable for small data output. </p><br><h2 id="2-asinhronnoe-programmirovanie-v-nodejs">  2. Asynchronous programming in Node.js </h2><br><p>  Yes, Node has async / await functions.  I still like callbacks, but asynchronous functions are great.  They are easy to understand even for beginners.  The async code function is shorter than the promise code.  Take a look at this Mocha test with two nested async database calls.  He is short and cute: </p><br><pre> <code class="hljs lisp">describe('#find()', () =&gt; { it('responds with matching records', async () =&gt; { const users = await db.users.find({ type: 'User' }) expect(<span class="hljs-name"><span class="hljs-name">users</span></span>).to.have.length(<span class="hljs-number"><span class="hljs-number">3</span></span>) for (<span class="hljs-name"><span class="hljs-name">let</span></span> user of users) { const comments = await db.comments.find({ user: user.id }) expect(<span class="hljs-name"><span class="hljs-name">comments</span></span>).to.be.ok } }) })</code> </pre> <br><p>  By the way, you can use the <code>function() {}</code> syntax, not just the syntax with arrows: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {<span class="hljs-attr"><span class="hljs-attr">response</span></span>: res} = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> axios. get(<span class="hljs-string"><span class="hljs-string">'https://webapplog.com/api/cupcakes'</span></span>) }</code> </pre> <br><p>  Another bonus of the async functions is that <em>they are compatible with promises</em> .  Yes that's right.  You can use them together, for example, create an async function, then use the <code>then</code> , or use a promise-based library (for example, axios from my example), or a function created by <code>util.promisify()</code> (new Node 8 method!) As the async function . </p><br><h2 id="3-otladka-v-nodejs">  3. Debugging in Node.js </h2><br><p>  The debugger in Node has improved significantly in comparison with what it was before.  I remember the days when I worked at Storify (the company - one of the very first Node users), I just placed <code>console.log</code> all over the code.  Today you can debug in VS Code.  This is a terrific editor.  I use it every day. </p><br><p>  Further, there is a <a href="https://github.com/node-inspector/node-inspector">Node Inspector</a> , which, in fact, Chrome DevTools for programs on Node.js.  Google Chrome V8 Inspector appeared in Node v8, integrated into Node, and all you need to do to get started with the GUI debugger is to simply write: </p><br><pre> <code class="hljs pgsql">node <span class="hljs-comment"><span class="hljs-comment">--inspect index.js</span></span></code> </pre> <br><p>  then open <code>¬ßchrome://inspect/#devices</code> in the Chrome browser.  In version 7, you need to copy the URL and open it in the Chrome browser.  The URL will contain the line <code>chrome-devtools://</code> at the beginning.  Just remember that your script on Node should work long enough for the debugger from DevTools to connect to the program, or you will have to set brepppoites in the debugger or in the code. </p><br><p>  Node is built on Chrome V8 and uses Chrome DevTools for debugging, not just because there is a nice GUI, but also to ensure reliable functions in the future. </p><br><h2 id="4-problemy-proizvoditelnosti-nodejs">  4. Node.js performance issues </h2><br><p>  Most of the problems with the production of Node are associated with either memory leaks, or with the network, or with I / O problems.  Stress testing helps you understand how your application and system work under real load conditions.  A good tool is <a href="https://artillery.io/">artillery</a> .  Some memory leak issues can be fixed or mitigated by modifying the code slightly and using the latest version of Node, which comes with the new JIT JavaScript compiler called Turbofan.  Read this great post <a href="https://medium.com/the-node-js-collection/get-ready-a-new-v8-is-%2520coming-node-js-performance-is-change-46a63d6da4de">GET READY: NEW V8 COMES, THE PRODUCTIVITY OF NODE.JS CHANGES</a> about optimization, as well as the technician, and the code that would be worth it to either avoid or adopt. </p><br><h2 id="5-horoshie-instrumenty-dlya-monitoringa-nodejs">  5. Good Node.js monitoring tools </h2><br><p>  First, make sure the Node code is ready for use.  In 2018, this will mean the use of containers, clouds and automation methods.  You might want to see my <a href="http://node.university/p/node-in-production">Node in Production</a> course for more details. </p><br><p>  The node should scale both vertically (see point 1) and horizontally.  This, of course, makes it difficult to monitor and collect logs.  You will need to collect metrics and magazines. </p><br><p>  Create a simple dashboard yourself, and you will see the statistics and metrics that form the individual Node servers and processes ... or use an open-sourced dashboard, say, <a href="https://github.com/capitalone/Hygieia">Hygieia</a> , created in Capital One (in case: I work in Capital One). </p><br><p>  Winston and bunyan are good tools for working with logs.  You can send logs to any place, say, to a third-party SaaS, for example Loggly, Splunk or Papertail (we used it in Storify).  If you want to keep all your data, expand Elastic Search with Kibana, and send your journals there.  This is what we did in DocuSign when we could not use a third-party service for security and privacy reasons.  We developed our own solution based on Winston, Elastic and Kibana. </p><br><p>  A few more tools and services to consider (not all are free), especially for production monitoring: this is <a href="https://nodesource.com/products/nsolid">N | Solid</a> , <a href="https://github.com/newrelic/node-newrelic">NewRelic</a> and <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch.html">AWS CloudWatch</a> . </p><br><h2 id="zavershenie">  Completion </h2><br><p>  Node is growing at a crazy pace.  Even without new versions, this is already an amazing technology.  It is fast, reliable, and, most importantly, brings the joy of carefree coding to developers.  When moving to the Node stack, I saw a lot of happy Java and C # developers. </p><br><h1 id="matias">  Matthias </h1><br><h2 id="delaem-neskolko-del-parallelno">  We do several things in parallel </h2><br><p>  Node.js is single-threaded in its design.  This is actually a useful feature, because it means that it will be easier to deal with things like race conditions from memory than with languages ‚Äã‚Äãlike Java, where your program‚Äôs execution may be interrupted at any time. </p><br><p>  It can allow itself to be single-threaded, since all I / O operations are performed asynchronously and, therefore, do not block program execution.  Moreover, although JavaScript in Node has one execution thread for a program, it itself uses several more threads to cope with helping with background I / O tasks and other service tasks. </p><br><p>  This approach has only one drawback.  Sometimes you need to run code that consumes only the processing power of the processor.  Since no I / O operations are being performed at this time, your Node.js program is blocked until this code is completed.  If we are talking about a processor-intensive operation (for example, cryptography), this can have a negative effect, since your Node program cannot do anything until the operation is completed - you probably want to avoid this. </p><br><p>  There are several ways to achieve this.  One of these approaches (which I often use) is to write a native module (as a rule, all my processor-intensive operations still require the use of a native module) and use a really nice <a href="">worker api</a> .  With this API, your (in the past, synchronous) operation will be able to use a callback, or return a promise, and your task, created using C ++ and Worker API, will work in another system thread of execution. </p><br><p>  Another approach would be to split the program into small parts and simultaneously launch them as a set of processes.  In essence, this means remaking your program into a small distributed system.  In this way, you can use many processor cores in a completely native way. </p><br><p>  In any case, when you start implementing parallel execution of the Node code, you get a much more asynchronous code.  Managing asynchronous code in Node is one of those things that seem very difficult at first, but become much easier to understand as your experience grows.  In the current version of Node, you can use features like async / await to make your asynchronous code look synchronous if you also use promise.  One complication arising from this is that since you are forced to use try-catch syntax, you will have to understand including.  and with more serious bugs, because try-catch in JavaScript also intercepts situations that in other languages ‚Äã‚Äãwould lead to compilation errors (for example, typos in the code, etc.).  In other words, the search for bugs will become more complex, since you will receive in the error handling code both syntax errors and errors during program execution. </p><br><p>  As a result, personally, I most often use callbacks for asynchronous programming, along with a pack of auxiliary libraries, such as the <a href="https://github.com/sorribas/after-all">after-all</a> module, etc. </p><br><h2 id="otladka-i-monitoring">  Debugging and monitoring </h2><br><p>  One of the features I like about Node is the number of excellent tools that help you debug and monitor the behavior of the application (and I myself wrote a lot of them).  When we work with Node, we work with JavaScript code that will run on V8.  In turn, the V8 has a rich API functionality that allows you to squeeze out excellent performance from it.  This allows you to track down the actual cause of the problems (the very ‚Äúbottleneck‚Äù) in your application without any guessing. <br>  I especially love the 0x module ( <a href="https://github.com/davidmarkclements/0x">https://github.com/davidmarkclements/0x</a> ) written by David Mark Clement and his friends.  This module easily turns the benchmark into a real flamegraph.  Just run your benchmark with 0x instead of node (plus create a flamegraph, and then open it in the browser): </p><br><pre> <code class="hljs perl">0x -o <span class="hljs-keyword"><span class="hljs-keyword">my</span></span>-benchmark.js</code> </pre> <br><p>  This graph will clearly tell which JavaScript function uses the most CPU time during program execution.  This approach gives a visual representation of what to pay the most attention to when optimizing. </p><br><p>  Another module that I often use for ops tasks is my own module called <a href="https://github.com/mafintosh/respawn">respawn</a> .  It simply helps you to start the process, and then restart it if the process crashes. </p><br><p>  There is a nice cli-wrapper called <a href="https://github.com/mafintosh/lil-pids">lil-pids to respawn</a> .  lil-pids does not have an interface, and only requires a file called ./services: you simply specify in it all the commands that you would like to see running on your system, lil-pids looks after them, and tries to achieve with the help of the respawn module, so that they all run. </p><br><p>  Finally, another problem that I most often have to solve in Node when using production code is random memory leaks.  Even though JavaScript has its own garbage collector, we often allow memory leaks, say, adding items to the list, and forgetting to remove them from there, etc.  Sometimes we do not allow memory leaks, but we implement algorithms that consume so much memory that at some point the system is forced to stop the program program.  To determine if there is a memory leak, I often use a Thomas Watson module called <a href="https://github.com/watson/memory-usage">memory-usage</a> .  The only thing he does is giving you an endless stream of data about how much memory your program uses over time.  If you draw a graph of this value, you will see when a memory leak begins. </p><br><p>  Whatever the well-known proverb says, there is a better option than ‚Äúto see once‚Äù - in our case, ‚Äúsee and hear reports, and then ask questions and talk on the sidelines.‚Äù  We invite you to the conference <a href="https://holyjs-moscow.ru/">HolyJS 2017 Moscow</a> ! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/341070/">https://habr.com/ru/post/341070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341058/index.html">JAVA 9. What's new?</a></li>
<li><a href="../341060/index.html">UX design: 50 things you probably forgot to do</a></li>
<li><a href="../341064/index.html">We optimize PropertyDrawer under Unity3d</a></li>
<li><a href="../341066/index.html">Cocos2d-x - Event Manager</a></li>
<li><a href="../341068/index.html">Service alert a million users with RabbitMQ</a></li>
<li><a href="../341072/index.html">We work with Bitcoin on Elixir</a></li>
<li><a href="../341074/index.html">Translation and dubbing of a movie at home - Indie Game: The Movie Special Edition</a></li>
<li><a href="../341076/index.html">Ember.js: a great framework for web applications</a></li>
<li><a href="../341080/index.html">How to render frame Unreal Engine</a></li>
<li><a href="../341084/index.html">Implementing HFT robots on CEPappliance devices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>