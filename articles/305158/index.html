<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Typing with pleasure</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I explore the human and machine aspects of typing delays (typing or ‚Äúinput lag‚Äù) and present experimental data on latency when workin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Typing with pleasure</h1><div class="post__text post__text-html js-mediator-article">  In this article, I explore the human and machine aspects of typing delays (typing or ‚Äúinput lag‚Äù) and present experimental data on latency when working with popular text and code editors. <br><br>  More recently, <a href="https://en.wikipedia.org/wiki/Latency_(engineering)">Delay</a> has become a hot topic in the computer world - now there are low-latency keyboards, 144 Hz monitors, special technologies that reduce latency (such as <a href="https://en.wikipedia.org/wiki/FreeSync">FreeSync</a> or <a href="https://en.wikipedia.org/wiki/G-Sync">G-Sync</a> ), <a href="http://forums.blurbusters.com/">communities</a> interested in this and so on and so forth.  Of course, part of this fashion was created by marketing, but the truth is that a small delay has become possible and desirable. <br><br>  Obviously, gamers are the first to benefit from such improvements.  In some areas, such as <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B8%25D1%2580%25D1%2582%25D1%2583%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2580%25D0%25B5%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">virtual reality</a> , latency is a decisive factor, even when it comes to one millisecond.  But what about programmers?  Do we need to ‚Äúprint with pleasure‚Äù in order to ‚Äúdevelop with pleasure‚Äù?  Let's figure it out. <br><a name="habracut"></a><br>  <strong>Content:</strong> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. <a href="https://habr.com/ru/post/305158/">Human side</a> <br>  1.1.  <a href="https://habr.com/ru/post/305158/">Feedback</a> <br>  1.2.  <a href="https://habr.com/ru/post/305158/">Motor skill</a> <br>  1.3.  <a href="https://habr.com/ru/post/305158/">Internal model</a> <br>  1.4.  <a href="https://habr.com/ru/post/305158/">Multisensory integration</a> <br>  1.5.  <a href="https://habr.com/ru/post/305158/">Effects</a> <br>  2. <a href="https://habr.com/ru/post/305158/">Machine side</a> <br>  2.1.  <a href="https://habr.com/ru/post/305158/">Input delay</a> <br>  2.2.  <a href="https://habr.com/ru/post/305158/">Processing delay</a> <br>  2.3.  <a href="https://habr.com/ru/post/305158/">Output delay</a> <br>  2.4.  <a href="https://habr.com/ru/post/305158/">Full delay</a> <br>  3. <a href="https://habr.com/ru/post/305158/">Comparative tests of editors</a> <br>  3.1.  <a href="https://habr.com/ru/post/305158/">Configuration</a> <br>  3.2.  <a href="https://habr.com/ru/post/305158/">Methodology</a> <br>  3.3.  <a href="https://habr.com/ru/post/305158/">Windows</a> <br>  3.4.  <a href="https://habr.com/ru/post/305158/">Linux</a> <br>  3.5.  <a href="https://habr.com/ru/post/305158/">Virtualbox</a> <br>  4. <a href="https://habr.com/ru/post/305158/">Conclusions</a> <br>  5. <a href="https://habr.com/ru/post/305158/">References</a> <br><br><a name="humanside"></a><h1>  1. Human side </h1><br>  The delay in typing is the time interval between pressing a key and the corresponding screen refresh.  It sounds simple, but make no mistake: its impact on the keyboard input process is rather complicated, since such typing is an amazing manifestation of coordinated actions of our body and nervous system (at least from a technical point of view). <br><br>  Let's start with the basics - is it worth it at all to worry about the delay?  We do not have any hurry, we can just print what is required, and check the result later.  A few seconds does not solve anything, right?  Not really. <br><br><a name="feedback"></a><h2>  1.1.  Feedback </h2><br>  A person does not ‚Äújust type‚Äù what he wants;  we need <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%2580%25D0%25B0%25D1%2582%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B2%25D1%258F%25D0%25B7%25D1%258C_(%25D1%2582%25D0%25B5%25D1%2585%25D0%25BD%25D0%25B8%25D0%25BA%25D0%25B0)">feedback</a> to fulfill this task, since our feelings form the so-called  <a href="http://www.controleng.com/single-article/open-vs-closed-loop-control/f8d8023a15738d0fcfe78d6a2d71dd60.html">closed loop control</a> with our movements.  A visual image is not only the result of input;  It is <em>an integral part of the</em> process. <br><br>  The more complete feedback we have when working with the keyboard (typing), the better.  In principle, you can print with your eyes closed.  We can continue typing, even if we plug our ears, relying only on the tactile sensations of the fingers.  However, if we block this last feedback channel, then keyboard input will become impossible.  Since the visual form of the sensation is <a href="https://en.wikipedia.org/wiki/Multisensory_integration">dominant</a> (information from other senses usually adapts to the vision) and is the only way to obtain reliable data on input errors, visual feedback is of great importance. <br><br>  Reducing the delay leads to a ‚Äúshortening‚Äù of the feedback loop, making the input easier, with greater speed and accuracy.  So far so good, but where is the reasonable border?  In the end, a <a href="https://en.wikipedia.org/wiki/Mental_chronometry">person reacts</a> incredibly slowly - ‚Äúthe way there and back‚Äù from feelings to consciousness and then back to the muscles takes about 200 ms!  Undoubtedly, the reaction can be trained, and it is different in people, but some relatively small delay, like, for example, 100 ms, seems to be a good option, isn't it?  Not at all. <br><br><a name="skill"></a><h2>  1.2.  Motor skill </h2><br>  Remember your first attempts to use a computer keyboard.  Most likely, it took you minutes to press the proper key and then check the result on the screen;  this process required all your concentration.  However, months and years have flown by, you are now typing amazingly quickly and semi-automatically on the keyboard - you are no longer thinking about any specific keys and, perhaps, don't even look at the keyboard at all ( <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BB%25D0%25B5%25D0%25BF%25D0%25BE%25D0%25B9_%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25BF%25D0%25B5%25D1%2587%25D0%25B0%25D1%2582%25D0%25B8">‚Äúblind</a> typing <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BB%25D0%25B5%25D0%25BF%25D0%25BE%25D0%25B9_%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25BF%25D0%25B5%25D1%2587%25D0%25B0%25D1%2582%25D0%25B8">‚Äù</a> ).  Practice affects.  This process is called <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D1%2582%25D0%25BE%25D1%2580%25D0%25B8%25D0%25BA%25D0%25B0">‚Äúthe acquisition of motor skills‚Äù</a> (or the <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D1%2582%25D0%25BE%25D1%2580%25D0%25B8%25D0%25BA%25D0%25B0">acquisition of motor skills</a> ( <a href="https://en.wikipedia.org/wiki/Motor_learning">motor learning</a> )).  When the skill reaches the <a href="https://en.wikipedia.org/wiki/Motor_skill">autonomous phase</a> , the task can be performed ‚Äúautomatically‚Äù without attracting any attention to its implementation. <br><br>  Formally speaking, typing (typing on a keyboard) is a <a href="https://en.wikipedia.org/wiki/Motor_control">process of driving control</a> carried out <a href="https://en.wikipedia.org/wiki/Motor_system">by a</a> person‚Äôs <a href="https://en.wikipedia.org/wiki/Motor_system">motor system</a> .  Since typing (typing on the keyboard) is <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">fine motor skills</a> (coordinated movements of small muscles occur), it is highly <a href="https://en.wikipedia.org/wiki/Motor_control">dependent on feedback</a> .  However, this feedback is processed at the subconscious level, so we will not necessarily be aware of the delay, while experiencing a serious negative impact.  The reaction time of a person is important only for correcting errors. <br><br>  But even semi-automatic processes are limited by <a href="http://users.df.uba.ar/acha/Lab1/time_delay.pdf">visual delay</a> (pdf-file), and any feedback is good only if we can use it.  <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D1%2580%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0">The human vision system</a> takes about 40 ms to process the input.  This value also depends on many factors, on a particular person and can be improved by training.  We conclude: a delay of less than 20 ms would be acceptable, right?  Not really. <br><br><a name="internal"></a><h2>  1.3.  Internal model </h2><br>  First of all, let us clarify that any ‚Äúexternal‚Äù delay is added to the visual delay, and not superimposed on it, i.e.  any delay matters.  But one can argue that a value of about 20 ms is still <em>relatively</em> small.  Good, but a person‚Äôs motor system knows a few dexterity tricks to react faster. <br><br>  To counteract the input delays in sensory organs and the nervous system, the human movement control system uses a special nervous process known as the <a href="https://en.wikipedia.org/wiki/Internal_model_%2528motor_control%2529">internal model</a> .  This process can <em>imitate the</em> response (reaction) of the controlled system even before receiving feedback signals - the use of <a href="https://en.wikipedia.org/wiki/Internal_model_(motor_control)">advanced</a> process <a href="https://en.wikipedia.org/wiki/Internal_model_(motor_control)">modeling</a> .  Additional <a href="https://en.wikipedia.org/wiki/Internal_model_(motor_control)">inverse model is</a> designed to predict the response (reaction) of the controlled system based on the current feedback. <br><br>  The delay does not affect the feedback loop directly; it affects, rather, the internal model of the printing process.  The direct and inverse models <a href="https://en.wikipedia.org/wiki/Internal_model_(motor_control)">are used in combination</a> with some internal feedback circuits, forming a <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B0%25D0%25BC%25D0%25B8%25D0%25BA%25D0%25B0">nonlinear system</a> .  As a result, even small delays in feedback signals can lead to significant disruptions when typing on the keyboard (typing). <br><br>  Separate from the internal model, there is another process that is adversely affected by visual delay ‚Äî <a href="https://en.wikipedia.org/wiki/Multisensory_integration">multisensory integration</a> . <br><br><a name="multi"></a><h2>  1.4.  Multisensory integration </h2><br>  The visual image is not the only type of feedback when typing on the keyboard: we can also hear sounds when pressing keys, feel pressure on our fingers, perceive the position of our hands and fingers (so-called <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BE%25D1%2586%25D0%25B5%25D0%25BF%25D1%2586%25D0%25B8%25D1%258F">proprioception</a> ). <br><br>  Each of these sensations is processed separately, and the nervous system determines whether or not to use these or other groups of signals.  This task is known as the <a href="https://en.wikipedia.org/wiki/Binding_problem">problem of binding</a> and is already a challenge in itself (see, for example, <a href="https://en.wikipedia.org/wiki/Multisensory_integration">multi-sensory illusions</a> ).  When the brain receives exposure from most senses immediately, and the image arrives with some additional delay, this complicates the situation even more. <br><br>  The nervous system may somewhat <a href="http://prism.bham.ac.uk/pdf_files/Miall_Jackson_EBR_2006.pdf">adapt</a> (pdf-file) to the constant delay of visual feedback (although not ideal), but any irregularities in the delay time (so-called jitter) create additional problems due to their inherent unpredictability. <br><br>  There are several illustrative examples from other areas where the delay of the feedback signals can cause worse consequences than its absence, to the point where the initial activity becomes impossible at all: if you play on a MIDI keyboard through a computer, then the <a href="https://en.wikipedia.org/wiki/Latency_%2528audio%2529">delays are</a> 20-30 ms is enough to violate your actions (one <a href="http://lsbaudio.com/publications/AES_Latency.pdf">article</a> (pdf-file) states that sound delay is important even for 1 ms);  another good example is the so-called.  <a href="http://arxiv.org/vc/arxiv/papers/1202/1202.6106v1.pdf">SpeechJammer</a> (pdf-file) (‚Äúchattering fighter‚Äù), which uses a feedback sound delay of approx.  200 ms, temporarily disrupting a person‚Äôs ability to speak. <br><br><a name="effects"></a><h2>  1.5.  Effects </h2><br>  Put together the key points: <br><br>  ‚Ä¢ Typing (typing on the keyboard) is a complex semi-automatic process that requires years to master. <br>  ‚Ä¢ In principle, the printing process can be influenced by millisecond delays in visual feedback. <br>  ‚Ä¢ It is not necessary for consciousness to perceive the presence of a delay, so that, nevertheless, it negatively affects you. <br>  ‚Ä¢ People vary greatly in susceptibility and tolerance to delay. <br><br>  But how exactly does the delay affect the typing process (typing on the keyboard)?  There are several possible effects: <br><br>  ‚Ä¢ Printing slows down. <br>  ‚Ä¢ The number of errors and their edits increases. <br>  ‚Ä¢ Eyes get tired more (because the vision system is overloaded). <br>  ‚Ä¢ Muscles get tired more (as movement control becomes less certain). <br>  ‚Ä¢ The process requires more informed attention. <br><br>  The exact effect of the delay depends on many factors, such as the specific distribution of the delay, the hardware used (keyboard, monitor), the content of the editor (text or code), the main activity (insertion / editing), the printing method (regular / blind printing), the specifics your vision and your motor skills, personal preferences, etc. <br><br>  Needless to say, the possible impact of the delay is hardly pleasant.  The good news is that it works in both directions, i.e., by reducing the visual delay, we can, in general, improve many aspects (here we are talking not only about the printing speed itself) <br><br>  The results obtained are generally consistent with available research data.  If there is a desire to get acquainted with this subject more deeply, then one can look at some books and scientific articles containing data on the effect of delay and on the role of visual feedback on the printing process, for example: <br><br>  ‚Ä¢ <a href="https://books.google.com/books/about/Cognitive_Aspects_of_Skilled_Typewriting.html%3Fid%3DifxTAAAAMAAJ%26redir_esc%3Dy">Cognitive aspects of professional typing</a> <br>  ‚Ä¢ <a href="http://www.psy.vanderbilt.edu/faculty/logan/SnyderLoganYamaguchi2015.pdf">The role of visual feedback from the screen and hands in professional typing</a> (pdf-file) <br><br>  In particular, it is worth quoting the following ( <a href="https://books.google.com/books/about/Handbook_of_Human_Computer_Interaction.html%3Fid%3DWuQbERgXR10C%26redir_esc%3Dy">source</a> ): <br><br><blockquote>  Delaying visual feedback on a computer display has an important impact on the operator's behavior and on his job satisfaction. </blockquote><br>  Let's now look at the side of the car to find out how we can improve the situation with a delay. <br><br><a name="mside"></a><h1>  2. Machine side </h1><br>  What happens between the moment a key is pressed and the moment a character appears on the screen?  It turns out that there are so many different things, and everything takes time.  Is it possible to simply buy a top-end computer in order to ensure quiet typing?  This will help, but only to some extent, since many parts of this process are independent of the central and / or graphics processor.  Take both <a href="https://en.wikipedia.org/wiki/Red_pill_and_blue_pill">pills</a> and I will show you how deep the rabbit hole goes (for even what follows is only part of the whole truth). <br><br>  The delay in printing can be divided into the following components: <br><br>  ‚Ä¢ Input delay (keyboard) <br>  ‚Ä¢ Delay processing (software) <br>  ‚Ä¢ Output Delay (Monitor) <br><br>  Consider each component more carefully. <br><br><a name="ilag"></a><h2>  2.1.  Input delay </h2><br>  First, let's figure out how a regular non-gaming USB keyboard handles our input.  Such keyboards are used most widely now both on desktop computers and on laptops. <br><br>  <strong>Keyboard scan</strong> <br><br>  A regular keyboard contains more than 100 keys, which is quite a lot.  To minimize the number of wires and inputs of the <a href="https://en.wikipedia.org/wiki/Computer_keyboard">control processor</a> , the key switches are usually connected in a <a href="https://en.wikipedia.org/wiki/Keyboard_matrix_circuit">matrix circuit</a> , i.e.  "Rows" and "columns" of wires intersect.  Due to this, the number of wires and inputs can be reduced from ‚Äúx * y‚Äù to ‚Äúx + y‚Äù (for example, from 121 to 22).  The consequence of this approach is that the control processor cannot read the state of all keys at the same time - it must periodically <a href="https://en.wikipedia.org/wiki/File:FunctionalCircuitDiagramOfKeyboardNumPadScanningProcedure-small.gif">scan</a> them with a constant frequency, which leads to some delay.  The typical scan rate of the array is 1,000 Hz, so the maximum delay associated with scanning is 1 ms (the average is 0.5 ms). <br><br>  <strong>Contact Bounce</strong> <br><br>  Regardless of the <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D1%2585%25D0%25BD%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D0%25B8_%25D0%25BA%25D0%25BB%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25B0%25D1%2582%25D1%2583%25D1%2580">type of keyboard, the</a> key switches are mechanically imperfect and subject to <a href="https://en.wikipedia.org/wiki/Switch">contact bounce</a> ‚Äî instead of ‚Äúpure‚Äù operation, the switch quickly goes from the ‚Äúon‚Äù state to the ‚Äúoff‚Äù state and back several times before it stops.  Chatter duration depends on switching technology;  for example, for <a href="http://cherrycorp.com/product/mx-series/">Cherry MX</a> devices, as stated, it is less than 5 ms.  Although the exact probability distribution is unknown, but based on the relevant <a href="http://www.ganssle.com/debouncing.htm">empirical data</a> , it is possible to take a bounce duration of about 1.5 ms. <br><br>  <strong>Eliminate contact bounce</strong> <br><br>  Since the <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D1%2581%25D0%25BA%25D1%2580%25D0%25B5%25D1%2582%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">polling</a> frequency is quite high and because of this the bounce can be interpreted as a few keystrokes, the keyboard control processor performs the so-called.  <a href="https://en.wikipedia.org/wiki/Keyboard_technology">eliminating contact bounce</a> , averaging signals over a time interval sufficient to obtain a reliable result.  This filtering introduces an additional delay, depending on the firmware of the microcontroller.  Since manufacturers, in general, do not report the characteristics of their microprograms, then we consider a typical deblocking <a href="https://google.com/">algorithm</a> and assume that filtering adds approx.  7 ms delay;  so  The maximum "time to eliminate bounce" is approx.  12 ms and average approx.  8.5 ms <br><br>  <strong>USB survey</strong> <br><br>  Since <a href="https://ru.wikipedia.org/wiki/USB">USB</a> is a bus controlled by the host computer, the keyboard must wait for a request from that computer to send the registered keystroke data (the keyboard control processor places the collected events in the output buffer).  Although USB devices request the required polling rate during initialization (up to 1,000 Hz), operating systems typically use 125 Hz for both low-speed and full-speed (USB1.x) devices;  therefore, the maximum delay associated with polling is 8 ms (the average is 4 ms).  It should be remembered that often you can <a href="https://blog.codinghorror.com/mouse-dpi-and-usb-polling-rate/">increase the</a> frequency of polling manually. <br><br>  <strong>USB conversion</strong> <br><br>  Some time is also required for data conversion.  For both low-speed and full-speed devices, the shortest conversion time is 1 ms.  In high-speed devices (USB2) this time is much less - approx.  0.001 ms (by the way, there is an excellent article <a href="https://pavelfatin.com/typing-with-pleasure/doc.utwente.nl/56344/1/Korver03adequacy.pdf">on the suitability of USB for real-time systems</a> (pdf-file)).  To minimize data conversion time, it is recommended not to connect broadband USB devices (such as, for example, drives, sound cards, webcams) to the same USB controller / hub to which your keyboard is connected. <br><br>  So, let's collect the delay values ‚Äã‚Äãfor a typical keyboard: <br><table><tbody><tr><th>  A source </th><th>  Min., Ms </th><th>  Max. Ms </th><th>  The average </th></tr><tr><td>  Matrix scan </td><td>  0 </td><td>  one </td><td>  0.5 </td></tr><tr><td>  Eliminate contact bounce </td><td>  7 </td><td>  12 </td><td>  8.5 </td></tr><tr><td>  USB survey </td><td>  0 </td><td>  eight </td><td>  four </td></tr><tr><td>  USB conversion </td><td>  one </td><td>  one </td><td>  one </td></tr><tr><td>  Total </td><td>  eight </td><td>  22 </td><td>  four </td></tr></tbody></table><br>  These results, in general, correspond to some <a href="http://forums.blurbusters.com/viewtopic.php%3Ff%3D10%26p%3D13479">experimental results</a> on measuring the delay caused by the keyboard. <br><br>  Is it possible to do better?  Of course, easy!  Use a professional keyboard: <br><br>  ‚Ä¢ switches with a short bounce time (some are even <a href="https://www.reddit.com/r/MechanicalKeyboards/comments/2n9c07/actual_inside_look_of_the_optical_switches_on_the/">optical</a> ) <br>  ‚Ä¢ high scanning frequency of the matrix <br>  ‚Ä¢ adaptive debounce algorithm <br>  ‚Ä¢ customizable firmware <br>  ‚Ä¢ USB2 for quick polling and low latency conversion <br><br>  All this can significantly reduce both the maximum and the average value of the keyboard delay.  For example, when I purchased the <a href="https://www.kinesis-ergo.com/shop/advantage-for-pc-mac/">Kinesis Advantage</a> keyboard, I immediately sensed the difference from my previous ‚Äúregular‚Äù keyboard. <br><br>  Gaming keyboards go even further - if you are a supporter of an uncompromising solution, then you should consider something like <a href="http://www.cherry.de/cid/RealKey_Technology.htm">Cherry's RealKey technology</a> , in which the key reading goes through <a href="https://en.wikipedia.org/wiki/Analog_signal">analog</a> inputs (and not digital);  the delay is almost zero. <br><br><a name="plag"></a><h2>  2.2.  Processing delay </h2><br>  Processing delay is the delay between receiving an input signal from the keyboard and generating an image of the entered character in a video frame.  Simply put, this is a delay inside the computer itself. <br><br>  It should be remembered that the processing delay is not determined only by the performance - theoretically, it is possible to have a system delivering 300 FPS, with a ‚Äúdelay‚Äù of 5 seconds after entering.  In particular, palletizing and buffering are often an attempt to achieve higher performance due to latency. <br><br>  While conceptually there are many different sources of processing delay, in practice they are so closely related to the use of an editor that all parts are usually measured together (for experimental data, see the next chapter). <br><br>  <strong>operating system</strong> <br><br>  After the USB <a href="https://ru.wikipedia.org/wiki/HBA">host</a> (‚ÄúUSB port‚Äù of the computer) receives data from the keyboard, it initiates a hardware <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D1%2580%25D1%258B%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">interrupt</a> so that the software driver in the operating system can read the received data through <a href="https://ru.wikipedia.org/wiki/USB-%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D1%2580%25D0%25BE%25D0%25BB%25D0%25BB%25D0%25B5%25D1%2580">the host controller interface</a> (usually via <a href="https://ru.wikipedia.org/wiki/PCI">PCI</a> or <a href="https://ru.wikipedia.org/wiki/PCI_Express">PCIe</a> ).  This data is then processed by <a href="https://en.wikipedia.org/wiki/Human_interface_device">the human-machine interface</a> (HID) <a href="https://en.wikipedia.org/wiki/Human_interface_device">subsystem</a> in the OS, which ultimately results in placing the key pressed event (of the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms646280%2528v%3Dvs.85%2529.aspx">WM_KEYDOWN</a> type) into the <a href="https://en.wikipedia.org/wiki/Message_queue">message queue of the</a> operating system.  After this, the event is sent <a href="https://en.wikipedia.org/wiki/Event_loop">by the event loop</a> to the window of the active application. <br><br>  All these actions require some time, but it is negligible for our purpose (typing on the keyboard).  What is important here is that the main operating systems (namely, Windows, Mac, and Linux-based OS) are not <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D1%2580%25D0%25B5%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25B2%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25B8">real-time systems</a> , so there is no guarantee for the delay value.  Both hardware processes (network I / O, storage I / O, etc.) and software <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE%25D0%25B7%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">multitasking</a> can increase processing time unpredictably (and indefinitely). <br><br>  By the way, since GUI applications can impose severe restrictions on system latency, there have been many successful attempts to <a href="http://www.makeuseof.com/tag/increase-linux-systems-responsiveness-ulatencyd/">optimize Linux kernel planning</a> specifically for the case of ‚Äúdesktop‚Äù use (in particular, through the <a href="https://packages.debian.org/jessie/ulatencyd">ulatencyd</a> dynamic optimization system). <br><br>  For simplicity, suppose that our computer does not have a significant load on keyboard input;  then this kind of delay will be less than 1 ms. <br><br>  <strong>Virtual machine</strong> <br><br>  If the text editor / IDE runs on top of the <a href="https://en.wikipedia.org/wiki/Virtual_machine">process virtual machine</a> (like the Java <a href="https://ru.wikipedia.org/wiki/Java_Virtual_Machine">JVM</a> or the .NET Framework <a href="https://ru.wikipedia.org/wiki/Common_Language_Runtime">CLR</a> ), additional delays may occur because their runtime is also not a <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D1%258B%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25B2_%25D1%2580%25D0%25B5%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25BC_%25D0%25B2%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25B8">real-time</a> system (except for special implementations, such as <a href="https://ru.wikipedia.org/wiki/RTSJ">Real time Java</a> ). <br><br>  Performance by itself does not usually create a problem, but when the <a href="https://ru.wikipedia.org/wiki/JIT-%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25B8%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F">JIT compiler</a> or <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B1%25D0%25BE%25D1%2580%25D0%25BA%25D0%25B0_%25D0%25BC%25D1%2583%25D1%2581%25D0%25BE%25D1%2580%25D0%25B0">garbage collector is</a> turned on, you can expect some ‚Äúlag‚Äù.  <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25B8%25D0%25B6%25D0%25BE%25D0%25BA_JavaScript">JavaScript engines</a> and the <a href="https://ru.wikipedia.org/wiki/Emacs_Lisp">Emacs Lisp</a> interpreter also generate this type of delay. <br><br>  The main virtual machines have improved significantly over many years, however, some preliminary <a href="http://www.azulsystems.com/press-2014/azul-systems-launches-readynow-solving-javas-warm-up-problem">‚Äúwarm-up‚Äù</a> could still be useful to ensure a stable delay. <br><br>  <strong>Editor</strong> <br><br>  This part is the most significant.  The editor used can make a major contribution to the delay in typing.  Unlike the delays created by the hardware, the maximum delay in the editor is practically unlimited (you can easily stumble upon for 1-2 seconds). <br><br>  Since the editor <a href="https://en.wikipedia.org/wiki/CPU-bound">is mainly tied to the central processor</a> , it is possible to reduce the delay of the editor using a more powerful machine (it also helps a good <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BE%25D1%2580">graphics processor</a> ).  But hope only for power is not entirely justified - it often goes where it is most needed (for example, when you start a development server or process some data in the background).  Also keep in mind that even a first-class laptop can be much more sluggish in <a href="https://en.wikipedia.org/wiki/Power_management">power saving</a> mode (on battery), so this approach is only partially effective.  In addition, it is quite expensive, as you know. <br><br>  There is a better way - in principle, we don‚Äôt need a supercomputer for quiet typing - all we have to do is implement the use of the editor, bearing in mind our goal.  Typing in the editor is a relatively simple process, so even computers on a <a href="https://ru.wikipedia.org/wiki/80286">286</a> processor provided fairly quick entry.  It is quite possible to achieve near-zero printing latency even in a sophisticated modern IDE, which is exactly what zero-delay printing is aimed at in IntelliJ IDEA.  For technical details, see my article <a href="https://pavelfatin.com/low-latency-painting-in-awt-and-swing">on low-latency rendering in AWT and Swing</a> (although the Java platform is being considered, key ideas can be extended to most modern operating systems and frameworks for building graphical user interfaces). <br><br>  Editors / IDEs vary greatly in typing delay.  The following chapter contains a large amount of empirical information on the topic. <br><br>  <strong>Rendering pipeline</strong> <br><br>  The central and graphic processor work in parallel and interact through the <a href="https://www.chromium.org/developers/design-documents/gpu-command-buffer">command buffer</a> , supplemented by the video driver buffer.  Most rendering commands are asynchronous.  Therefore, they have the full right not to run as soon as the rendering method works.  The drawing commands are accumulated in the video driver buffer, then they are packaged and sent to the graphics processor's command buffer (an attempt is made to get a higher frame rate due to the delay).  The resulting delay, depending on the combination of hardware / operating system / software interface of the application / video driver, can vary from insignificant to very substantial. <br><br>  A typical desktop application runs on top of frameworks for building graphical user interfaces, so it is isolated from the <a href="https://en.wikipedia.org/wiki/Graphics_pipeline">underlying rendering pipeline</a> and, thus, from rendering synchronization (rendering).  This is usually acceptable, because  many desktop applications are not sensitive to latency.  However, some actions are extremely sensitive to it (such as typing in an IDE), which is why editors can explicitly ‚Äúpush‚Äù commands in the buffer and forcefully render a frame to reduce latency.  As an example, see the <a href="https://www.opengl.org/wiki/Synchronization">synchronization</a> job <a href="https://www.opengl.org/wiki/Synchronization">in OpenGL</a> .  You can also watch a demonstration material about <a href="https://pavelfatin.com/low-latency-painting-in-awt-and-swing/">‚Äúpushing through‚Äù the conveyor</a> . <br><br>  <strong>Double buffering</strong> <br><br>  In order not to show a partially drawn frame and to present the whole image on the screen at once, many applications turn to the so-called.  <a href="https://en.wikipedia.org/wiki/Multiple_buffering">double buffering</a> - the image is initially prepared in an off-screen ‚Äúsecondary buffer‚Äù, and when all graphic operations are completed, the updated image area is transferred to the <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D0%25B4%25D1%2580%25D0%25BE%25D0%25B2%25D1%258B%25D0%25B9_%25D0%25B1%25D1%2583%25D1%2584%25D0%25B5%25D1%2580">frame buffer</a> by <a href="https://en.wikipedia.org/wiki/Bit_blit">bit-wise copying</a> or by <a href="https://en.wikipedia.org/wiki/Multiple_buffering">switching the page</a> .  Many frameworks (like <a href="https://ru.wikipedia.org/wiki/Swing">Swing</a> ) do double buffering by default. <br><br>  Needless to say, this extra step leads to an additional delay.  The Java <a href="https://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">documentation</a> says: ‚ÄúIf your performance metric is simply the speed at which double buffering or page switching occurs compared to direct rendering, then you may be disappointed.  It may turn out that the values ‚Äã‚Äãof direct rendering will be much higher than those of double buffering, and these, in turn, will be much higher than the page switching. ‚Äù <br><br>  Sometimes double buffering is absolutely necessary; in other cases it is not actually required;  therefore, editors should use double buffering cautiously to avoid excessive visual delay.  For more information, see the sample <a href="https://pavelfatin.com/low-latency-painting-in-awt-and-swing/">buffering costs</a> . <br><br>  <strong>Window manager</strong> <br><br>  Modern applications rarely work in full screen mode;  Most <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B0_%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2587%25D0%25B5%25D0%25B3%25D0%25BE_%25D1%2581%25D1%2582%25D0%25BE%25D0%25BB%25D0%25B0">desktop environments</a> show each program in a separate window.  This task is performed by the so-called.  <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25BD%25D0%25B5%25D0%25B4%25D0%25B6%25D0%25B5%25D1%2580_%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BD">window managers</a> , which can be divided into several classes depending on how the windows are drawn and updated. <br><br> <a href="https://en.wikipedia.org/wiki/Stacking_window_manager">  </a>     ,     ,  .           (    ),     ,        .    : Classic theme  Windows, <a href="https://ru.wikipedia.org/wiki/Openbox">Openbox</a>  Linux. <br><br> <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25BE%25D0%25B7%25D0%25B8%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25B5%25D0%25B4%25D0%25B6%25D0%25B5%25D1%2580_%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BD">  </a>                  ,  ( )   .        .   : <a href="https://ru.wikipedia.org/wiki/Windows_Aero">Aero</a>  Windows, <a href="https://en.wikipedia.org/wiki/Compiz"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compiz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Linux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relevant empirical data is provided in the next chapter. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertical sync </font></font></strong> <br><br> <a href="https://en.wikipedia.org/wiki/Screen_tearing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertical sync</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or V-Sync is a method to prevent the </font></font><a href="https://en.wikipedia.org/wiki/Screen_tearing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">image</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from </font><a href="https://en.wikipedia.org/wiki/Screen_tearing"><font style="vertical-align: inherit;">breaking on the screen</font></a><font style="vertical-align: inherit;"> , i.e. this state, when the display shows information from several frames in one screen image. The arising distortions are most noticeable on horizontally moving objects with sharp vertical edges (that is, not during printing).</font></font><br><br> V-Sync                 ( , V-Sync   ).            <em> </em> .     17 ,  ‚Äî  8  (   60 ). ,       , -          4 ,       (    ).     ,  ,  17 . <br><br>        ,    V-Sync. V-Sync  Windows   Aero,    Classic theme. V-Sync  Linux, , ,   ,      . <br><br>    V-Sync    ,    ,     - .         (. ). <br><br>     <em></em>  (,     /           V-Sync): <br><br><table><tbody><tr><th>  A source </th><th> .,  </th><th> .,  </th><th> ,  </th></tr><tr><td>  operating system </td><td>  0 </td><td> ‚àû </td><td>  ? </td></tr><tr><td>   </td><td>  0 </td><td> ‚àû </td><td>  ? </td></tr><tr><td>  Editor </td><td>  0 </td><td> ‚àû </td><td>  ? </td></tr><tr><td>   </td><td>  0 </td><td>  ? </td><td>  ? </td></tr><tr><td>   </td><td>  0 </td><td>  ? </td><td>  ? </td></tr><tr><td>   </td><td>  0 </td><td>  ? </td><td>  ? </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vertical sync </font></font></td><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  Total </td><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚àû </font></font></td><td>  ? </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These delays are much less predictable than delays caused by hardware, and they are very sensitive to computer configuration. </font><font style="vertical-align: inherit;">In principle, the total processing delay can be either 0-1 ms, or 10 s. </font><font style="vertical-align: inherit;">That is why theoretical reflections are not enough here and some exact figures are needed - see the extensive empirical data in the next chapter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How can I improve the situation with delayed processing? </font><font style="vertical-align: inherit;">There are several ways: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Low latency editor / IDE </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Powerful computer hardware (central and graphics processors) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Stacking window manager (Classic Windows theme, Openbox, etc.). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Lack of vertical synchronization. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviously, the editor is of the greatest importance.</font></font><br><br><a name="olag"></a><h2>  2.3.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Output delay </font></font></h2><br> ,    <a href="https://ru.wikipedia.org/wiki/%25D0%2596%25D0%25B8%25D0%25B4%25D0%25BA%25D0%25BE%25D0%25BA%25D1%2580%25D0%25B8%25D1%2581%25D1%2582%25D0%25B0%25D0%25BB%25D0%25BB%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B4%25D0%25B8%25D1%2581%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25B9"> </a>   . <br><br> <strong> </strong> <br><br>      <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B8%25D0%25B4%25D0%25B5%25D0%25BE%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C"> </a>    (  <a href="https://ru.wikipedia.org/wiki/SMA"> </a> ).        ;   <a href="https://en.wikipedia.org/wiki/Video_display_controller"></a>  ,    (  VGA, DVI, HDMI, DisplayPort  ..),          .      ,  <a href="https://en.wikipedia.org/wiki/Refresh_rate"> </a> ,    -  60 .   ,   ,   ,   17 ,   ‚Äî  8  (       ,     ,     ). <br><br> <strong> </strong> <br><br>    <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2582%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25BE-%25D0%25BB%25D1%2583%25D1%2587%25D0%25B5%25D0%25B2%25D1%258B%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B8%25D0%25B1%25D0%25BE%25D1%2580%25D1%258B">-</a> ,       (    ¬´¬ª ‚Äî <a href="https://en.wikipedia.org/wiki/Cathode_ray_tube"> </a> ), -       .         ,   ,    - ¬´¬ª  (    ,    ).     <a href="https://en.wikipedia.org/wiki/Display_lag"> </a> ( ¬´  ¬ª).        ,        .      , ..         (.  <a href="http://www.prad.de/en/monitore/specials/inputlag/inputlag.html"> Prad   </a> ,  ,    <em></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Although in the worst case the delay can be 2-3 frames (i.e. up to 50 ms at a refresh rate of 60 Hz), the input lag is mainly in high definition television and not in computer monitors; therefore, it can be assumed that this delay is close to zero for typical monitors. Nevertheless, it is a good idea to turn off all the ‚Äúimage correctors‚Äù on your monitor (oddly enough, </font></font><a href="http://www.bit-tech.net/hardware/monitors/2009/02/06/the-dark-side-of-overdrive/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and overdrive too</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Response pixel</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixels </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%2596%25D0%25B8%25D0%25B4%25D0%25BA%25D0%25BE%25D0%25BA%25D1%2580%25D0%25B8%25D1%2581%25D1%2582%25D0%25B0%25D0%25BB%25D0%25BB%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B4%25D0%25B8%25D1%2581%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25B9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LCD display</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> may not respond to changes in the control voltage immediately. The time interval required to change a pixel on the display is called the </font></font><a href="https://en.wikipedia.org/wiki/Response_time_%2528technology%2529"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel response time.</font></font></a> .   ,  ,   - (TN, IPS, VA  ..). -   ,    ,   <a href="https://en.wikipedia.org/wiki/Thin-film-transistor_liquid-crystal_display">TN</a> - (     )        4 . <br><br> ,     <em></em>  : <br><table><tbody><tr><th>  A source </th><th> .,  </th><th> ,  </th><th> ,  </th></tr><tr><td>   </td><td>  0 </td><td>  17 </td><td>  eight </td></tr><tr><td>   </td><td>  0 </td><td>  ? </td><td>  0 </td></tr><tr><td>   </td><td>  ? </td><td>  ? </td><td>  four </td></tr><tr><td>  Total </td><td>  ? </td><td>  ? </td><td>  12 </td></tr></tbody></table><br>     ?     : <br><br> ‚Ä¢  ,         . <br> ‚Ä¢     144  (,   ,  3,5 ). <br> ‚Ä¢    ,   <a href="http://www.vesa.org/news/vesa-adds-adaptive-sync-to-popular-displayport-video-standard/">Adaptive-Sync</a> , <a href="https://en.wikipedia.org/wiki/FreeSync">FreeSync</a>  <a href="https://en.wikipedia.org/wiki/G-Sync">G-Sync</a>     ( 240 )   . <br><br>          . 1-2 . <br><br><a name="flag"></a><h2>  2.4.   </h2><br>  <em></em>      : <br><table><tbody><tr><th>  A source </th><th> ,  </th><th> ,  </th></tr><tr><td>  entrance </td><td>  14 </td><td>  one </td></tr><tr><td>  Treatment </td><td>  ? </td><td>  0 </td></tr><tr><td>  Output </td><td>  12 </td><td>  2 </td></tr><tr><td>  Total </td><td>  ? </td><td>  3 </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A typical kit consists of a regular non-game keyboard and a standard LCD monitor. The ideal configuration involves a keyboard and monitor (gaming), having a low latency. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The input and output delay components are strictly determined by periodic hardware processes that can be estimated with high accuracy. These delays do not depend on the performance of the central and graphics processors and have predictable upper bounds. The typical average delay of the keyboard and monitor together is about 26 ms, which is not much in itself, but if you add it to the processing delay, the editor delay will be more noticeable. Even the I / O delay in itself already exceeds the threshold of human perception.</font></font><br><br>       / ,   ,     ,            .    ;     ,    .         0-1 . <br><br>          ,     ,      . <br><br><a name="ctest"></a><h1> 3.    </h1><br>      ,   <a href="https://pavelfatin.com/typometer">¬´Typometer¬ª</a> ‚Äî          ( <a href="https://github.com/pavelfatin/typometer"></a> ). <br><br> Typometer         ,          .  ,       (..  ,  ,   , ,      ).    ,    ,  ,    ,  ,    . <br><br><a name="config"></a><h2>  3.1.  Configuration </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the hardware and software configuration used for testing: </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hardware:</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ CPU: Intel Core i5 </font></font><a href="http://ark.intel.com/products/64903"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3427U</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , 1.8 / 2.8 GHz, 3MB cache </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Graphics: Intel </font></font><a href="https://ru.wikipedia.org/wiki/Ivy_Bridge"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HD 4000</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (driver v10.18.10.3958) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Memory : 4 GB DDR3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Display: 1920 x 1080, 32 bits, 59.94 Hz </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Software:</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ </font></font><a href="https://ru.wikipedia.org/wiki/Windows_7"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft Windows 7</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HP x64 SP1 6.1.7601 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ </font></font><a href="http://lubuntu.net/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lubuntu Linux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.10 Desktop amd64 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ </font></font><a href="https://www.virtualbox.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VirtualBox</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.0.10 on Windows (default settings, full screen mode) </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editors:</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ </font></font><a href="https://atom.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ </font></font><a href="https://eclipse.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eclipse</font></font></a> 4.5.1 <br> ‚Ä¢ <a href="https://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 <br> ‚Ä¢ <a href="https://wiki.gnome.org/Apps/Gedit">Gedit</a> 3.10.4 <br> ‚Ä¢ <a href="http://www.vim.org/">GVim</a> 7.4.712 <br> ‚Ä¢ <a href="https://www.jetbrains.com/idea/">IntelliJ Idea</a> CE 15.0 <br> ‚Ä¢ <a href="https://netbeans.org/">Netbeans</a> 8.1 <br> ‚Ä¢ <a href="https://www.sublimetext.com/">Sublime Text</a> 3083 <br><br>  , ,                    ,     .       ,          (  ,     );     . <br><br>     ,  ,  ,  . , Notepad () ‚Äî <em>  </em> ,            . <br><br>        <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BC%25D1%2583%25D0%25BB%25D1%258F%25D1%2582%25D0%25BE%25D1%2580_%25D1%2582%25D0%25B5%25D1%2580%25D0%25BC%25D0%25B8%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25B0"></a> ,         . ,      <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D0%25BE%25D0%25B2%25D1%258B%25D0%25B9_%25D0%25B2%25D0%25B8%25D0%25B4%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25B6%25D0%25B8%25D0%25BC">  </a> ‚Äî  <a href="https://en.wikipedia.org/wiki/Win32_console"> Windows</a> ,   <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B8%25D1%2580%25D1%2582%25D1%2583%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2581%25D0%25BE%25D0%25BB%25D1%258C">  Linux</a> ( Alt+Fn)     . <br><br>     <a href="https://www.r-project.org/">R</a> .      <a href="http://ggplot2.org/">ggplot2</a> . <br><br><a name="method"></a><h2>  3.2.  Methodology </h2><br>  All editors / IDEs worked with default settings, application windows were maximized. <br><br>  The editor worked either with an empty text file or with an XML file (more precisely, with a <a href="">Maven schema</a> ).  XML was chosen because it is highlighted in all editors and does not depend on other project files. <br><br>  Typometer used the following parameters: <br><br>  ‚Ä¢ Number of characters: 200 <br>  ‚Ä¢ Delay: 150 ms <br>  ‚Ä¢ Access: native <br>  ‚Ä¢ Mode: synchronous <br><br>  The delay of 150 ms was chosen because it represents the average time interval between keystrokes with my own fairly fast typing (the minimum interval is 40 ms).  The exact value does not play a big role, because  Typometer in synchronous mode waits for the symbol to appear before pausing and typing the next one. <br><br>  A classic window manager was used in Windows, because, as mentioned above, compositing implemented in Aero increases rendering delay and forcibly turns on vertical synchronization (tests showed that Aero theme really makes all editors less susceptible).  Here is a comparison of GVim tests (one of the fastest editors in general) in the Classic theme and in Aero (dotted lines at 16.68 and 33.37 ms): <br><br>  The impact of Windows Aero on drawing latency (GVim) <br><img src="https://habrastorage.org/getpro/habr/post_images/bab/de1/dbf/babde1dbf308d991dd1c8b622e6d79da.png"><br><br>  You can see that Aero introduces at least one frame delay (approx. 16.7 ms for a refresh rate of 60 Hz) and leads to time sampling.  This hides the internal performance of the editor and distorts the benchmarking process.  As I indicated earlier, the video signal delays created by vertical synchronization are slightly less than the delays in the frame buffer, but the average difference is only 4 ms, and the maximum added delay is still 17 ms (for 60 Hz).  Since the effect is quite substantial, <a href="https://google.com/">people often find an</a> added delay ‚Äúto the naked eye‚Äù in tests for the human response time. <br><br>  The graph also shows that Typometer has a very good delay measurement accuracy - the lower values ‚Äã‚Äãare so close to the theoretical 16.68335 that it looks almost like the result of a mathematical calculation. <br><br>  As for Linux, preference was given to Lubuntu instead of Ubuntu for the same reason - Compiz gives an additional delay in drawing the application.  Here is a graph (with median lines): <br><br>  The effect of Linux Compiz on drawing latency (GVim) <br><img src="https://habrastorage.org/getpro/habr/post_images/131/a0c/e53/131a0ce533b574049d79521eb684aff6.png"><br><br>  The average delay introduced is approx.  8 ms, which is better than Aero;  there is also no discretization caused by synchronization (but there is an increase in jitter).  Since V-Sync is not used, video delays are at the level of delays in the frame buffer.  It is preferable to use a stack window manager (such as Openbox) to get a higher measurement accuracy. <br><br>  Given that the measured delays of the fastest applications, such as the Notepad, are below 1 ms <em>and</em> stable, it seems reasonable to assume that the measuring tool provides sufficient accuracy and reproducibility.  Since the relationship between the frame buffer and the output video signal is deterministic, the results can be viewed as representative. <br><br>  Despite the rich variety of observed dependencies, the following typical time series can be distinguished: <br><br>  Typical editor delay time series <br><img src="https://habrastorage.org/getpro/habr/post_images/9a5/786/e62/9a5786e621ae716bb5d19c10cdb5921f.png"><br><br>  Simple editors exhibit very stable latency values, although the average value may be relatively large. <br><br>  Complex editors (and editors running on top of a virtual machine / interpreter) in addition to higher average latency often tend to have higher delay variability (jitter). <br><br>  Intermediate behavior is also common, when intervals of a stable delay value are periodically interrupted by random outliers.  Sometimes the delay tends to show a linear dependence on the editor's algorithms for horizontal character positioning. <br><br><a name="windows"></a><h2>  3.3.  Windows </h2><br>  As an introduction to the delay analysis methodology, I recommend reviewing a large discussion of <a href="https://news.ycombinator.com/item%3Fid%3D10485804">how not to measure the delay</a> , which explains why average values ‚Äã‚Äãare better than median as a measure of delay, and why maximum values ‚Äã‚Äãare very important. <br><br>  <strong>Text file</strong> <br><br>  Let's look at the summary table (sorted by the average value of the delay).  RMS here means the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BD%25D0%25B5%25D0%25BA%25D0%25B2%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B0%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25BE%25D1%2582%25D0%25BA%25D0%25BB%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">standard deviation</a> used as a measure of <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B6%25D0%25B8%25D1%2582%25D1%2582%25D0%25B5%25D1%2580">jitter</a> .  Consider that the ‚Äúideal‚Äù situation is presented here - a simple empty file without highlighting the code.  Any other configuration would by definition show higher delays. <br><br>  Editor delay in Windows (text file): <br><table><tbody><tr><th>  Editor </th><th>  Min., Ms </th><th>  Max. Ms </th><th>  Average, ms </th><th>  RMS, ms </th></tr><tr><td>  Gvim </td><td>  0.2 </td><td>  1.2 </td><td>  0.9 </td><td>  0.2 </td></tr><tr><td>  IDEA (zero delay) </td><td>  0.1 </td><td>  21.2 </td><td>  2.9 </td><td>  2.7 </td></tr><tr><td>  Notepad ++ </td><td>  0.1 </td><td>  5.9 </td><td>  4.3 </td><td>  0.8 </td></tr><tr><td>  Emacs </td><td>  4.2 </td><td>  19.2 </td><td>  5.3 </td><td>  1.1 </td></tr><tr><td>  Sublime text </td><td>  6.2 </td><td>  35.2 </td><td>  8.2 </td><td>  2.0 </td></tr><tr><td>  Eclipse </td><td>  0.1 </td><td>  20.8 </td><td>  10.1 </td><td>  1.6 </td></tr><tr><td>  Netbeans </td><td>  7.3 </td><td>  31.6 </td><td>  11.8 </td><td>  3.9 </td></tr><tr><td>  IDEA </td><td>  0.1 </td><td>  83.7 </td><td>  24.7 </td><td>  12.0 </td></tr><tr><td>  Atom </td><td>  29.2 </td><td>  85,5 </td><td>  49.4 </td><td>  7.2 </td></tr></tbody></table><br>  The final table gives us the opportunity to estimate the <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2580%25D0%25B0%25D1%2581%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">distribution of the</a> delay only approximately, therefore it is useful to supplement it with a corresponding more detailed graphic.  Traditional <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B8%25D1%2581%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0">histograms are</a> not very convenient for comparing multiple data sets.  <a href="https://ru.wikipedia.org/wiki/%25D0%25AF%25D1%2589%25D0%25B8%25D0%25BA_%25D1%2581_%25D1%2583%25D1%2581%25D0%25B0%25D0%25BC%25D0%25B8">The span diagrams</a> (‚Äúmustache boxes‚Äù) are too coarse.  <a href="https://en.wikipedia.org/wiki/Violin_plot">The violin charts are</a> better, but they look rather strange for people who are not professionally involved in statistics. <br><br>  There is a more convenient way, which also looks better - you can graphically plot the values ‚Äã‚Äãon the horizontal axis with some added random vertical shift to show the distribution (there is <a href="http://zevross.com/blog/2014/05/05/unhide-hidden-data-using-jitter-in-the-r-package-ggplot2/">additional information</a> about this approach).  The resulting diagram is simple and descriptive and allows you to compare different data sets: <br><br>  Editor delay in Windows (text file) <br><img src="https://habrastorage.org/getpro/habr/post_images/044/2b5/5f3/0442b55f335e5d06b4513a37ae1aa3ea.png"><br><br>  Obviously, the editors are not created equal (at least, by delay). <br><br>  First, the average latency varies significantly ‚Äî simpler editors tend to have lower latency.  The winner is GVim, but IDEA with zero delay enabled is very close to GVim.  All JVM-based editors (including IDEA in default mode) are at the bottom, which is quite predictable, second only to Atom, since  Chrome's work was even more lethargic. <br><br>  Another noticeable difference is jitter - ‚Äúlight‚Äù editors exhibit a very stable delay, while complex ones, on the contrary, have a much wider range of meanings.  IDEA in default mode shows the largest delay spread with a high maximum value. <br><br>  The histogram below shows the detailed impact of the zero delay mode in IntelliJ IDEA: <br><br>  Effect of Zero Delay on Windows (text file) <br><img src="https://habrastorage.org/getpro/habr/post_images/56c/67c/0f5/56c67c0f56493bd54ecf9243aed75785.png"><br><br>  The zero delay mode has a positive effect, reducing the average delay and eliminating jitter (but not completely). <br><br>  <strong>Xml file</strong> <br><br>  It is clear that the previous set is too ‚Äúartificial‚Äù;  In the end, to edit an empty file without any syntax highlighting, you can simply take Notepad.  For something more serious use another editor.  Run the input in a relatively large XML file to see how the values ‚Äã‚Äãchange: <br><br>  Effect of content type on editor latency (Windows) <br><img src="https://habrastorage.org/getpro/habr/post_images/629/dd3/115/629dd3115c9621a6f1ce0430fa2ea61d.png"><br><br>  Wow!  The difference is quite noticeable and at the same time unusual.  Some editors - GVim and IDEA in zero delay mode - well, simply, ‚Äúcool guys‚Äù, they are ‚Äúon the drum‚Äù.  However, with most editors the delay has increased evenly.  The average delay in IDEA slightly <em>decreased</em> (which is somewhat strange), but the maximum one increased.  The most dramatic change occurred in Emacs, the delay of which simply took off into the sky. <br><br>  <strong>Energy saving</strong> <br><br>  Now disconnect from the mains and we will work from batteries in power saving mode. <br><br>  Editor delay in Windows (XML file, power saving): <br><table><tbody><tr><th>  Editor </th><th>  Min., Ms </th><th>  Max. Ms </th><th>  Average, ms </th><th>  RMS, ms </th></tr><tr><td>  Gvim </td><td>  0.6 </td><td>  2.9 </td><td>  1.4 </td><td>  0.2 </td></tr><tr><td>  IDEA (zero delay) </td><td>  1.5 </td><td>  58.7 </td><td>  4.3 </td><td>  7.4 </td></tr><tr><td>  Notepad ++ </td><td>  4.8 </td><td>  26.1 </td><td>  9.8 </td><td>  1,3 </td></tr><tr><td>  Sublime text </td><td>  10.4 </td><td>  19.3 </td><td>  12.6 </td><td>  0.7 </td></tr><tr><td>  Eclipse </td><td>  13.9 </td><td>  60.4 </td><td>  19.0 </td><td>  5.0 </td></tr><tr><td>  IDEA </td><td>  13.6 </td><td>  239.3 </td><td>  45.5 </td><td>  39.6 </td></tr><tr><td>  Emacs </td><td>  46.1 </td><td>  77.4 </td><td>  50.5 </td><td>  4.3 </td></tr><tr><td>  Netbeans </td><td>  11.9 </td><td>  138.1 </td><td>  59.0 </td><td>  21.2 </td></tr><tr><td>  Atom </td><td>  48.9 </td><td>  104.0 </td><td>  60.4 </td><td>  7.0 </td></tr></tbody></table><br>  Let's take a closer look at how this has affected the delays: <br><br>  Impact of power saving mode on editor delay (Windows, XML file) <br><img src="https://habrastorage.org/getpro/habr/post_images/13f/bc9/6b9/13fbc96b9b1a17d2422f807a62441a47.png"><br><br>  Most editors did not notice this, but there are a couple of notable exceptions: IDEA and Netbeans.  For IDEA, the maximum delay went up to 240 ms, which, quite obviously, is above the ‚Äútangible‚Äù threshold. <br><br>  Here it is shown how the zero delay mode affects in these conditions: <br><br>  Effect of Zero Delay on Windows (XML file, power saving) <br><img src="https://habrastorage.org/getpro/habr/post_images/7fd/f54/dd3/7fdf54dd3bf8d8e1e3fd93d5bf7b7d7e.png"><br><br>  And again, although it does not eliminate jitter completely, the impact is significant. <br><br><a name="linux"></a><h2>  3.4.  Linux </h2><br>  We continue our observations in Linux, skipping for simplicity synthetic test with an empty file. <br><br>  Linux editor delay (XML file): <br><table><tbody><tr><th>  Editor </th><th>  Min., Ms </th><th>  Max. Ms </th><th>  Average, ms </th><th>  RMS, ms </th></tr><tr><td>  IDEA (zero delay) </td><td>  0.8 </td><td>  3.9 </td><td>  1.7 </td><td>  0.5 </td></tr><tr><td>  Gvim </td><td>  1.7 </td><td>  8.4 </td><td>  4.5 </td><td>  1.4 </td></tr><tr><td>  Gedit </td><td>  5.0 </td><td>  24.2 </td><td>  12.4 </td><td>  3.0 </td></tr><tr><td>  Emacs </td><td>  7.5 </td><td>  46.3 </td><td>  20.3 </td><td>  4.1 </td></tr><tr><td>  Sublime text </td><td>  9.4 </td><td>  35.4 </td><td>  23.1 </td><td>  5.2 </td></tr><tr><td>  Netbeans </td><td>  8.4 </td><td>  92.7 </td><td>  24.5 </td><td>  12.9 </td></tr><tr><td>  Atom </td><td>  16.0 </td><td>  59.6 </td><td>  32.5 </td><td>  8.4 </td></tr><tr><td>  Eclipse </td><td>  23.6 </td><td>  87.1 </td><td>  46.5 </td><td>  14.0 </td></tr><tr><td>  IDEA </td><td>  10.1 </td><td>  198.0 </td><td>  69.2 </td><td>  27.1 </td></tr></tbody></table><br>  Additional Delay Distribution Chart: <br><br>  Delay Editor in Linux (XML file) <br><img src="https://habrastorage.org/getpro/habr/post_images/211/c96/7dd/211c967dd19c6b59ce79b8b45fb0fdba.png"><br><br>  Comparison with previous results in Windows: <br><br>  Impact of OS on editor latency (XML file) <br><img src="https://habrastorage.org/getpro/habr/post_images/97d/eff/7de/97deff7deb69e6e67705765b8b8557b7.png"><br><br>  A common feature is that Linux jitter is noticeably higher for most editors (with the exception of the zero-delay mode in IDEA, where jitter has actually decreased). <br><br>  Emacs and Atom benefit in Linux - their average latency is noticeably less here. <br><br>  In GVim, Sublime Text, Eclipse and IDEA (in the default mode), on the contrary, the delay in Linux has increased significantly.  The most severe impact experienced IDEA - the maximum delay reached 200 ms even in normal power mode.  The reaction time of Eclipse was also hard hit. <br><br>  Printing in IDEA in the zero-delay mode is, of course, the winner (here IDEA has bypassed even GVim). <br><br>  Effect of Zero Delay on Linux (XML file) <br><img src="https://habrastorage.org/getpro/habr/post_images/778/96e/230/77896e2305c3774694210b1ac68e45a2.png"><br><br>  Linux's zero latency mode demonstrates low and extremely stable latency. <br><br><a name="virtualbox"></a><h2>  3.5.  Virtualbox </h2><br>  Now suppose, for example, that we use Windows, primarily for games, and work on a Linux virtual machine (really, why not?).  How will the editor's delays change in this usage situation?  We'll see. <br><br>  Editor delay in Linux (VirtualBox, XML file): <br><table><tbody><tr><th>  Editor </th><th>  Min., Ms </th><th>  Max. Ms </th><th>  Average, ms </th><th>  RMS, ms </th></tr><tr><td>  IDEA (zero delay) </td><td>  4.2 </td><td>  29.7 </td><td>  12.4 </td><td>  4.9 </td></tr><tr><td>  Gvim </td><td>  6.0 </td><td>  26.0 </td><td>  18.3 </td><td>  4.1 </td></tr><tr><td>  Gedit </td><td>  19.5 </td><td>  47.6 </td><td>  30.1 </td><td>  4.8 </td></tr><tr><td>  Emacs </td><td>  27.6 </td><td>  68.3 </td><td>  33.8 </td><td>  7.4 </td></tr><tr><td>  Sublime text </td><td>  31.5 </td><td>  58.2 </td><td>  46.1 </td><td>  5.2 </td></tr><tr><td>  Netbeans </td><td>  12.6 </td><td>  159.9 </td><td>  46.7 </td><td>  19.5 </td></tr><tr><td>  Atom </td><td>  29.1 </td><td>  89.4 </td><td>  62.6 </td><td>  10.2 </td></tr><tr><td>  Eclipse </td><td>  45.3 </td><td>  131.4 </td><td>  79.4 </td><td>  13.7 </td></tr><tr><td>  IDEA </td><td>  29.2 </td><td>  347.8 </td><td>  87.5 </td><td>  42.0 </td></tr></tbody></table><br>  Here is a comparison with the previous "natural" results: <br><br>  The effect of virtualization on editor latency (Linux, XML file) <br><img src="https://habrastorage.org/getpro/habr/post_images/131/6c3/5de/1316c35de95117a2c51e8e9f8dbcb586.png"><br><br>  In addition to delay sampling (either caused by vertical sync or another type of discrete buffer synchronization), we can see a constant increase in latency for all editors.  Distributions do not change much, which is easily explained (basic algorithms are preserved during visualization).  The maximum delay in IDEA increased to 350 ms. <br><br>  <strong>Energy saving</strong> <br><br>  To get the full picture, switch to batteries.  The power saving mode together with VirtualBox is probably the most intense combination to delay the editor. <br><br>  Delay editor in Linux (VirtualBox, XML file, power saving): <table><tbody><tr><th>  Editor </th><th>  Min., Ms </th><th>  Max. Ms </th><th>  Average, ms </th><th>  RMS, ms </th></tr><tr><td>  IDEA (zero delay) </td><td>  4.3 </td><td>  69,6 </td><td>  11.9 </td><td>  8.9 </td></tr><tr><td>  Gvim </td><td>  5.0 </td><td>  35.8 </td><td>  19.0 </td><td>  3.8 </td></tr><tr><td>  Gedit </td><td>  13.4 </td><td>  49.3 </td><td>  23.9 </td><td>  6.0 </td></tr><tr><td>  Emacs </td><td>  19.6 </td><td>  79.5 </td><td>  44.7 </td><td>  6.9 </td></tr><tr><td>  Sublime text </td><td>  38.1 </td><td>  65.0 </td><td>  52.1 </td><td>  7.3 </td></tr><tr><td>  Atom </td><td>  70.2 </td><td>  152.2 </td><td>  90.0 </td><td>  13.7 </td></tr><tr><td>  Netbeans </td><td>  35.7 </td><td>  344.7 </td><td>  119.1 </td><td>  43.3 </td></tr><tr><td>  Eclipse </td><td>  99.3 </td><td>  269.6 </td><td>  133.6 </td><td>  36.2 </td></tr><tr><td>  IDEA </td><td>  119.4 </td><td>  544.6 </td><td>  198,8 </td><td>  63.1 </td></tr></tbody></table><br>  Y-yes, such delays are just ridiculous!  Maximum delay now exceeds half a second !!! <br><br>  For clarity, let's compare these data with the results under ideal conditions: <br><br>  Impact of configuration on editor latency <br><img src="https://habrastorage.org/getpro/habr/post_images/c54/623/584/c54623584a30da4a62a26a6fbffecdb3.png"><br><br>  Clearly, configuration plays an important role in the resulting editor latency.  However, the editors react in different ways - the work of some can be seriously degraded, while for others it does not affect much. <br><br>  The best resistance was demonstrated by IntelliJ IDEA with the zero delay mode enabled.  Let's see how it looks in the most difficult situation: <br><br>  Effect of Zero Delay Mode in VirtualBox (Linux, XML file, power saving) <br><img src="https://habrastorage.org/getpro/habr/post_images/d7b/9de/c0a/d7b9dec0a9e1060cde1cf0f823649973.png"><br><br>  Interestingly, in the zero delay mode, IntelliJ IDEA surpasses all other editors (and, by the way, console editors too). <br><br><a name="conclusion"></a><h1>  4. Conclusions </h1><br>  Of course, <em>what</em> you type is much more important than <em>how</em> you type.  However, visual feedback with low latency can often make this process more efficient and more enjoyable. <br><br>  ‚Ä¢ Use a responsive editor. <br>  ‚Ä¢ Use the keyboard with low latency. <br>  ‚Ä¢ Turn off all ‚Äúimage enhancers‚Äù on your monitor. <br>  ‚Ä¢ Enable the stack window manager in your OS. <br><br>  Print with pleasure! <br><br><a name="ref"></a><h1>  5. References </h1><br>  See also: <br><br>  ‚Ä¢ <a href="https://pavelfatin.com/typometer/">Typometer</a> is a tool for measuring and analyzing visual delay in text / code editors. <br>  ‚Ä¢ <a href="https://pavelfatin.com/low-latency-painting-in-awt-and-swing/">The process of drawing with low latency in AWT and Swing</a> - a detailed analysis of the sources of delay in the AWT and Swing architectures, methods for significantly reducing the drawing delay. </div><p>Source: <a href="https://habr.com/ru/post/305158/">https://habr.com/ru/post/305158/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305126/index.html">Is it going Running? Going upstairs? Intel Edison knows the answer.</a></li>
<li><a href="../305128/index.html">Accelerate stencil computing: building and running YASK on Intel processors</a></li>
<li><a href="../305144/index.html">Double speed and half memory: PHP 7 optimization</a></li>
<li><a href="../305154/index.html">As we began to sell more, despite the crisis</a></li>
<li><a href="../305156/index.html">Deform: simple database as a service</a></li>
<li><a href="../305166/index.html">IT outsourcing should not hinder innovation - it's time to rethink</a></li>
<li><a href="../305168/index.html">What is OT?</a></li>
<li><a href="../305172/index.html">Social media in 2017. What to expect?</a></li>
<li><a href="../305182/index.html">Visualization of financial data. Mitap Ministry of Finance with developers, journalists and designers</a></li>
<li><a href="../305184/index.html">How to set up a network bridge (br0) on Ubuntu Linux 14.04 and 16.04 LTS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>