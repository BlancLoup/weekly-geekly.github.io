<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimize the launch time of iOS applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúIn the maps we have such a scenario: on the go, get the phone, launch the application, quickly determine where I am, navigate the compass, where to g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimize the launch time of iOS applications</h1><div class="post__text post__text-html js-mediator-article">  <i>‚ÄúIn the maps we have such a scenario: on the go, get the phone, launch the application, quickly determine where I am, navigate the compass, where to go, and remove the phone.</i> <i><br><br></i>  <i>There are many similar scenarios when an application is opened for a short time.</i>  <i>Therefore, it is very important for us that the application runs quickly.</i>  <i>We recently did a lot of work on optimizing launch times.</i>  <i>I want to share this experience with you now. ‚Äù</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/REaGfwq3Q5Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>The basis of this material was the presentation of Nikolai Lihogrud, the head of mobile development of Yandex.Maps for iOS, at the <a href="https://mobiusconf.com/">Mobius 2017</a> conference.</i> <br><br>  <a href="https://habrahabr.ru/users/likhogrud/" class="user_link">likhogrud</a> has already <a href="https://habrahabr.ru/company/yandex/blog/335768/"><b>written a post</b></a> on this topic on the Yandex blog, but we could not help but release one of the best conference reports.  Here there is a video, text under the cut, and the <a href="http://assets.contentful.com/2grufn031spf/4ARX9W15p6Ygsgm2cus48q/911f9b35b26a7bcc451569022764038c/___________________.__._-______________________________________________________iOS-______________________.pdf">presentation,</a> see how you prefer. <br><a name="habracut"></a><br><h2>  Why reduce startup time? </h2><br>  Steve Jobs said that the most valuable human resource is his time.  You may have heard the story of how Steve made the launch of the Macintosh operating system speed up by half a minute, arguing that speeding up by just 10 seconds would save 300 million user hours per year.  Steve considered running an application a very important aspect of performance. <br><br>  It is obvious that from two applications with the same set of functions, the user will select the one that quickly starts.  If there is no alternative, and the application runs for a long time, the user will be annoyed, he will rarely return to your application, write bad reviews.  And vice versa, if the application starts quickly, then everything will be great. <br><br>  Do not forget about the launch time limit of 20 seconds, beyond which the system interrupts the loading of your application.  On weak devices, it is enough to really exceed these 20 seconds. <br><br>  Why is it that the optimization of launch time is most actively spoken over the past six months or a year, and in parallel with the time when we were engaged in optimizing the launch time of our application, several teams did the same in their projects?  More and more frameworks that we love and use are being rewritten to Swift.  And Swift cannot be compiled into a static library.  Therefore, the number of dynamic libraries in our application is growing, as well as time. <br><br>  Everything is so bad that Apple devoted a launch time to a separate article on the last WWDC ( <a href="https://developer.apple.com/videos/play/wwdc2016/406">WWDC 2016: Optimizing App Startup Time</a> ), where it revealed the details of how the dynamic downloads work. <br>  Chika told how it can be profiled and what can be done with the launch time. <br><br>  What we need to know to effectively run our startup optimization <br>  go application? <br><br><ul><li>  That there is a start time, and it needs to be measured; </li><li>  How to optimize the application loading stage that occurs before the Main function is called, that is, before our code starts to run; </li><li>  How to activate the start time after this point; </li><li>  How not to spoil the result with subsequent updates. </li></ul><br><h2>  Start time measurements </h2><br>  To begin with, there is a start time and how to measure it.  Startup time is the time from the user clicking on the application icon to the moment when the application is ready for use. <br><br>  In the simplest case, we can assume that the application is ready for use upon completion of the DidFinishLaunching function, that is, when the main interface of the application is loaded.  However, if your application needs to go somewhere at the start for the data, interact with the databases, update the UI, this also has to be taken into account.  Therefore, what is considered the end of the launch - a personal matter of each developer. <br><br>  We decided on the fact that there is a launch time, we begin to measure it.  We find that time is very jumps.  In the case of Yandex.Map it jumps twice. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/1b8/9f1/51a/1b89f151aca34dabaa309a8c09d4e452.png"></div><br><br>  Here you need to introduce the concept of cold and warm start.  Cold start is when the application has long since completed its work and has been removed from the operating system cache.  A cold start always occurs after restarting the application and, in principle, WWDC recommends that it be modeled in its tests.  Warm start is when the application has been completed recently. <br><br>  Where does this difference come from? <br><br>  The launch consists of two major steps: <br><br><ul><li>  preparing an image of the application; <br></li><li>  running our code when the main function starts. <br></li></ul><br>  When preparing an application image, the system should: <br><br><ul><li>  load all dynamic libraries, for each dynamic library check its digital signature, display its virtual address space; <br></li><li>  since the library can be located anywhere in memory, you need to correct pointers, substitute addresses of unknown characters in other libraries; <br></li><li>  create an Objective-C context, i.e.  register C-classes, selectors, categories, unique selectors, plus other work is done there; <br></li><li>  initialize the classes, execute the + load call and the C ++ global variable constructor. <br></li></ul><br>  In the case of a cold start, this pre-main can be an order of magnitude longer than in the case of a warm start. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/f88/bb0/230/f88bb02303f54beba97c89b6de18a724.png"></div><br><br>  And just due to this, we have such a big difference between a cold and a warm start. <br><br>  Especially greatly increases the load time of dynamic libraries in the case of Swift-a.  Therefore, today we will spend a lot of time optimizing this stage. <br><br>  Thus, when you measure the launch of your application, you must take into account not only the segment where your code works, but also pre-main, when the system builds the web application, and also consider the cold start. <br><br><h2>  Measuring pre-main </h2><br>  Measuring pre-main is not a trivial task, since our code does not work there.  Fortunately, in the latest iOS (9 and 10), Apple added the DYLD_PRINT_STATISTICS environment variable, which, when turned on, displays the statistics of the bootloader operation on the console. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/555/ce2/aa4/555ce2aa4ae24fed9ea7038190c58cb1.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/244/e54/72f/244e5472f8de4fd3b5392ae5d6c10e3f.png"></div><br><br>  The total time is displayed pre-main and then step by step: <br><br><ul><li>  load time of dynamic libraries; <br></li><li>  rebase / binding time - i.e.  edits to pointers and binding; <br></li><li>  creation time of ObjC context; <br></li><li>  initialization time - where + load and global variables. <br></li></ul><br><h2>  Measuring after-main </h2><br>  We have a handy tool for measuring pre-main, now we need to measure after-main correctly. <br><br>  A common mistake is to measure only didFinishLaunching.  But before didFinishLaunching, the initialization of UIApplication, UIApplicationDelegate takes place, you can have complex constructors there, and this should also be taken into account.  Therefore, time must be measured from the beginning of main. <br><br>  If you don‚Äôt have a main.swift file in your project, you‚Äôll have to add it and put a start-up meter on the first line, and then explicitly call UIApplicationMain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/e1f/ebf/564/e1febf5644144c88b974e30f84431aec.png"></div><br>  So, we learned how to measure the full time correctly.  However, even in the same situation, the launch time can jump much, and you can‚Äôt manage it at all, because the device can do something in the background.  Horse racing can reach 20%. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/bc1/0ad/a98/bc10ada98987497a9f2999d22c0b1eff.png"></div><br>  In the case when we are trying to improve our application on a pretty penny, this is unacceptable.  You have to do a lot of starts to get rid of the noise.  I would like to automate all this, because it is expensive to do manually, especially if you have many devices. <br>  Fortunately, the libimobiledevice utility solves this problem.  It communicates with the device directly through the same protocols as xcode and iTunes, and it does not require a jailbreak.  The utility allows you to do everything we need. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/8b4/5bd/dc7/8b45bddc702b40ecba9c1cf59c7aa5ec.png"></div><br>  First, it allows you to get a list of connected devices and their UID.  Secondly, install the application on a specific device, start the application and reboot the device.  It is important for us to measure the cold start. <br><br>  Most importantly, in the launch of the application, you can pass an environment variable (we need to pass the variable DYLD_PRINT_STATISTICS to measure pre-main). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/3f0/7a3/95d/3f07a395dfa440d79b26e523a0e04d6b.png"></div><br><h2>  Build for tests </h2><br>  We will analyze how to use all this.  Need to prepare an assembly for the tests.  This should be a release configuration with optimizations enabled so that: <br><br><ul><li>  asserts are turned off, <br></li><li>  included optimizations (otherwise the library libswiftSwiftOnoneSupport.dylib will be added, which affects the launch time). <br></li></ul><br>  And you need to do an automatic termination of the application after it is loaded, if DYLD_PRINT_STATISTICS is specified in the environment variables. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/6d2/554/bb0/6d2554bb08804a0a963634345f316873.png"></div><br>  Further we write a script that is on each iteration: <br><br><ul><li>  reboots the device (indevicediagnostics restart); <br></li><li>  waiting for the download to complete; <br></li><li>  then we start the application (indevicedebug run - this will be a cold start); <br></li><li>  it ends automatically; <br></li><li>  we run again (indevicedebug run - this will be a warm start); <br></li><li>  the script processes the output, saves the logs. <br></li></ul><br>  It seems that all is well.  But we are faced with the fact that rebooting the phone is very long. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/3f9/404/96f/3f940496fe7d4ea583a23be3d14f4ae6.png"></div><br>  And after that, the launch time jumps very strongly, because for a long time after loading the phone does something in the background (time jumps very strongly - up to 40%).  This is unacceptable. <br><br>  Fortunately, the picture, approximately similar to cold start, turns out, if we do not reboot the device, but simply reinstall the application.  This is logical, because when you reinstall the application must be removed from the cache. <br><br>  After reinstallation, we get clearly not a warm start.  At the same time, the start time after the reboot and the start time after the reinstallation is connected, and if you decrease one, the other decreases simultaneously.  And reinstallation is much faster, and there is not so much variation in values. <br><br>  Therefore, we will change the script a bit: <br><br><ul><li>  the first step is to reinstall the application (indevicinstaller -i); <br></li><li>  then start indevicedebug run (cold); <br></li><li>  another indevicedebug run (warm start); <br></li><li>  and output processing. <br></li></ul><br>  Having such a script, we can collect launch statistics on different devices, taking into account the pre-main, as well as cold and warm start, and further push away from this statistics. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b82/0f5/ceb/b820f5cebed9a06b581d097eb971f092.png"></div><br><h2>  Blank swift project </h2><br>  You may think that you can immediately proceed to optimization.  But actually not.  First you should see what we need to strive for. <br><br>  And we need to strive for the launch time of an empty project, since our application cannot start faster than an empty project. <br><br>  And here we come across an unpleasant Swift surprise.  Take a simple application on Objective-C, measure it pre-main (say, on the iPhone 5S). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/19d/2e9/ffd/19d2e9ffd48e41af8cc0c50be752dc9d.png"></div><br>  His dynamic library load time will be less than a millisecond.  We make the same application on Swift, run on the same device: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/2ba/45c/a1a/2ba45ca1a4ef4a159ff494c5f4b2b47e.png"></div><br>  Loading dynamic libraries - 200 milliseconds - 2 orders of magnitude more.  If we run the application on the iPhone 5, then the loading of dynamic libraries takes almost 800 milliseconds. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/963/e33/ff2/963e33ff267148e09d48781f9416f13c.png"></div><br>  We need to understand, because of what.  To do this, turn on the Dynamic Library Loads checkbox so that the loadable dynamic libraries are displayed: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83a/67d/51e/83a67d51ecb2d4e151129ff02382a559.png"></div><br>  And look at the log: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/c13/abc/88b/c13abc88b662439b8a1014c2201a6caa.png"></div><br>  We compare the logs of projects on Objective-C and Swift.  We see that in both cases, 146 dynamic libraries are loaded, which are system libraries, and a binary application.  But Swift additionally loads nine more suspicious libraries from the application bundle - from the Frameworks folder, called libswift ***. Dylib.  These are the so-called swift standard libraries. <br>  If you have ever looked at the compilation log of your application, one of the last steps is the coping swift standard libraries.  Where do they come from? <br><br>  The fact is that swift is developing very quickly, and its developers do not bother with respecting the reverse binary compatibility.  Therefore, if you assemble any module on swift 3.0, then even on swift 3.01 you can no longer use it.  The compiler will write that this can not be done.  Swift cannot yet be part of iOS, because otherwise the new swift will not start on old iOS.  Therefore, applications always drag Swift runtime ‚Äî the swift support libraries, unlike Objective-C, which has long been part of the system. <br><br>  Therefore, we get the following conclusions: <br><br><ul><li>  no matter what anyone says, the loading of the system libraries is optimized (I myself spent a lot of time trying to make sure of this completely).  Even if you have 200 or 300 system libraries loaded, it still does not affect the start time, so do not waste time trying to reduce their number; <br></li><li>  But the libraries from the application bundle load for a long time.  Unfortunately, these include the swift standard libraries; <br></li><li>  even an empty application on the iPhone loads a second (with a cold start).  Accordingly, your application can not load less than a second; <br></li><li>  someday this problem will disappear.  A swift 4 is already being prepared, and the swift standard libraries will simply become part of the system, and applications will no longer carry these libraries with them. <br></li></ul><br>  Now it's time to move on to hardcore optimization. <br><br><h2>  Pre-main optimization </h2><br>  What is theoretically possible to influence?  What does WWDC recommend in its presentation?  First, recall the steps: <br><br><ul><li>  loading dynamic libraries; <br></li><li>  rebase / binding, i.e.  fix pointers; <br></li><li>  objc-setup, i.e.  creating Objective-C context; <br></li><li>  initialization, that is, global variables of C ++ and the + load method. <br></li></ul><br>  Apple recommends: <br><br><ul><li>  reduce the number of loadable dynamic libraries; <br></li><li>  reduce the use of Objective-C (use more swift), which will reduce the amount of Objective-C metadata created at the start; <br></li><li>  move the code from + load to + initialize so that it is called when the code first accesses the class; <br></li><li>  get rid of static C ++ variables with complex constructors. <br></li></ul><br>  We have an application on swift.  It is big.  There is already little Objective-C in it - only where you need to interact with the system, with the SDK.  In the last swift + load is already prohibited.  There are no global C ++ variables.  Therefore, of these recommendations, unfortunately, the majority is no longer relevant.  It remains only to deal with dynamic libraries and try to somehow reduce the size of the binary file loaded at the start, that is, take out symbols into dynamic libraries and load them lazily.  This will inevitably reduce our startup time (reduced rebase / binding, objc-setup). <br><br><h2>  Dynamic Library Optimization </h2><br>  Let's try to optimize the test application. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/6d4/efc/f7a/6d4efcf7a7e14c729d541882c89fe99d.png"></div><br>  Suppose our test application contains many pods written in swift, and somewhere inside it uses Yandex MapKit and YandexSpeechKit, which are static libraries, and also MapKit from the iOS SDK (why this assumption will become clear later). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/cb7/193/d92/cb7193d9232b4a29a17a8dc29a2af747.png"></div><br>  Measure the start time. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/569/8df/753/5698df75364b4e56a1fae5315933fd11.png"></div><br>  It is three times higher than that of an empty application.  Mainly due to dynamic libraries, i.e.  for an empty application, they are loaded for 200 milliseconds, and for our test one - for 600 milliseconds. Why is this happening? <br><br><ul><li>  added a dynamic library for each hearth compiled from swift; <br></li><li>  there are more swift standard libraries.  Initially there are 9 of them, and now there are already 14. <br></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/web/d73/170/81c/d7317081c8e74f9f972d58932689575a.png"></div><br>  Let's start with the simplest: how to remove the download of extra dynamic libraries that come from podov?  For this, we can use the plugin for cocoa pods, which is called cocoapods-amimono.  It patches the scripts and xcconfigs that are generated by the sweeps, so that after compiling the Podovka libraries, the remaining object files will immediately link to the binary file of the application, and thus get rid of the need for linking with dynamic libraries.  Absolutely wonderful solution.  And it works great.  How to use it? <br><br>  In the Podfile add the use of the plugin and post-install. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/887/805/463/88780546305449cbbea88713749dc590.png"></div><br>  If you are lucky, everything compiles immediately.  If not - will have to tinker.  But in the end, our launch time is almost halved: the load time of dynamic libraries drops from 600 seconds to 320. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/00e/8d1/490/00e8d1490744433d967f6182123b259a.png"></div><br>  This is precisely due to the fact that all the dynamic libraries from the pods have disappeared. <br><br>  Unfortunately, we ran into a few shortcomings of this decision, due to the fact that it does not have a large community (people made it almost by themselves): <br><br><ul><li>  cocoapods-amimono skips the integration of the pods supplied by the frameworks, that is, you need to add these pods yourself to the application and perform the integration; <br></li><li>  there is no control over which pods to hold in a binary file and which ones to leave as is; <br></li><li>  still for some reason the target, whose name contain "test", are omitted. <br></li></ul><br>  With all this you can live.  I tried the tool for three rather big applications, and each time it took me about an hour and a half to fix the link.  But in the end everything works well. <br><br><h2>  Objective-C wrappers </h2><br>  So, we now have the load time of dynamic libraries - 320 milliseconds.  It is still one and a half times larger than the empty project.  Why it happens? <br><br>  Let's see what we have left in the Frameworks folder in the bundle.  There added 5 new dynamic libraries: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/46a/188/228/46a1882288944410a43fc23ff0612fc5.png"></div><br>  They are called: libswiftAVFoundation.dylib, libswiftCoreAudio.dylib, libswiftCoreLocation.dylib, libswiftCoreMedia.dylib and libswiftMapKit.dylib.  Where did they come from? <br><br>  If you import import CoreLocation somewhere in the swift code, or import &lt;CoreLocation / CoreLocation.h&gt; in the bridging header, the system automatically adds the libswiftCoreLocation.dylib library to your application bundle.  Accordingly, the load time increases.  Unfortunately, I did not find any other solution, except how not to use CoreLocation for swift. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/9aa/f63/d23/9aaf63d23cc04bfbbddb1c469638ff6d.png"></div><br>  Therefore, we take and wrap it in Objective-C. <br><br>  To simplify refactoring, we can take only that part of CoreLocation, which we use, and write the exact same wrapper, but with a different prefix - instead of CoreLocation use, for example, CLWLocationManager (implying core location wrapped), CLWLocation, CLWHeading, etc.  Then only these wrappers can be used in swift - and the library, it would seem, is not added. <br><br>  I did it, but immediately "did not take off." <br><br>  It turned out that CoreLocation can import dependencies in header files that are added to the bridging header.  They also have to be wrapped in Objective C, or somehow bridging the header of the refactor.  CoreLocation can also be imported as a dependency of other SDK libraries, for example, MapKit.  It turns out that MapKit drags two libraries at once: libswiftCoreLocation.dylib and libswiftMapKit.dylib, and AVFoundation generally has three at once. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/91d/7ee/2e7/91d7ee2e79e54115b563a207a85a349b.png"></div><br>  That is, if you write import AVFoundation and import MapKit somewhere in a swift file, the load time of the dynamic libraries will immediately increase 1.5 times, even if you have not used this API.  Therefore, we write wrappers, and then we return to the load time of the dynamic libraries of the empty project. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/971/f63/4fa/971f634fac4b434d93f3b2dc3d781098.png"></div><br>  There is nowhere else to strive for - we got 10 milliseconds.  It remains to suffer a little to reduce the remaining stages. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/5cc/12b/da8/5cc12bda819d4244800e4f30a6a9f8d4.png"></div><br><h2>  Download via dlopen </h2><br>  As I said, Apple's recommendations on optimizing a separate stage are no longer appropriate, because we are all on swift and do not have Objective C or C ++. <br><br>  Here we have to be guided by the banal idea that at the start only those characters that are necessary to display the start screen should be loaded.  Ideally, in general, our application binary should consist only of those symbols that are needed at the start.  All the rest would be great to ship lazily.  How to do this in our test application? <br>  Earlier, I said that Yandex MapKit, YandexSpeechkit is used inside the application.  It would be great to make these static libraries dynamic and load them lazily through a dlopen.  This will inevitably reduce the time for rebase / bind, obj startup and initialization, because fewer Objective-C characters will load at the start.  How to do it in a convenient way? <br>  For a start we will convert them to dynamic libraries.  To do this, for each static library, we create a separate Cocoa Touch Framework target in our application, and in the Podfile we add the required one to the created target.  It remains only to correct the linking (if it is written well under the spec, it will immediately link up with you, and if it is written poorly under the spec, you will have to correct the linking). <br><br>  Basically, we are respectively: <br><br><ul><li>  under the clean; <br></li><li>  the framework that is compiled from the newly created target is added to the embedded binaries so that it goes along with the bundle, but we do not add it to the link; <br></li><li>  we transfer the necessary resources, we rule integration; <br></li><li>  We write Objective-C wrappers for lazy downloads - Objective-C wrappers that implement the same interface, but load the library and characters lazily. <br></li></ul><br>  The latter, in fact, is the most difficult moment.  Although not so difficult, how frightening, because here you have to use the dlof dlfcn API. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/f29/179/4a8/f291794a8e6f4729899d179728375090.png"></div><br>  I used to be very afraid of this API.  It seemed to me that everything was scary and complicated there.  But in fact, everything is not very bad. <br><br>  For starters, you can load the dynamic library via dlopen.  The first parameter takes just the path to the library (the library is in the frameworks folder of our bundle).  dlopen returns a handle that will be used later in the dlsym function that loads individual characters. <br><br>  Now, if we need a function symbol, we use dlsym and pass in the function name (which was in the source library).  dlsym will return a pointer to this function. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/59b/38e/2e7/59b38e2e7e764e6ca456296da7487c32.png"></div><br>  Further, we can call this function in the usual syntax on a pointer.  From a global variable in the same way - we load by its name through dlsym, the address of this global variable is returned.  Then you only need to dereference it.  Everything is not as difficult as it seemed initially. <br><br>  Classes are a little more difficult, but you can still live. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/8c0/efe/0f1/8c0efe0f17c44986aa2a8b9f57da7c11.png"></div><br>  First, we can import our former static libraries.  This will not load them and will not cause link errors.  These are just some declarations to the compiler, and as long as we do not use them directly, linking errors do not occur.  However, this h-nickname is worth importing. <br><br>  Next, we suppose we need some kind of class.  The name of his character will consist of the name of the class plus the OBJC_CLASS_ $ prefix.  dlsym will return us a class as an instance of the entire metaclass.  Further for this metaclass instance we can call alloc.  This will return an object of type ID.  And then the magic of Objective-C begins, because here we can call a selector on any object of type ID, which the compiler knows about.  And our selectors are declared just in the library's imported h-nickname.  Then we can map to the desired object and use the API from our library.  Those.  the only problem is that you need to load the class symbol, and then use it as usual. <br><br>  What does this give us? <br><br>  In fact, in our test project, this does not give very much - just 30 milliseconds. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/37b/f41/6cd/37bf416cd6564c16a07c0c6f6e2d7cd8.png"></div><br>  But, nevertheless, such a source of optimization must be considered.  Maybe you have somewhere using a large static library, which is not needed at the start, and its symbols are loaded at the start anyway - it depends on the application. <br><br>  Naturally, through dlopen you can download not only any dependencies, but also break your code into modules and load them lazily.  In other words, we strive to ensure that the binary file of the application is as small as possible.  This, of course, requires strong refactoring.  But what I wrote can be done fairly quickly. <br><br>  Here is a summary of how we optimized the launch of the application three times through three stages. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/1f1/46f/26b/1f146f26b0494aeb895dbe3ec9c7071c.png"></div><br><ul><li>  first got rid of the dynamic libraries of pods; <br></li><li>  then we wrote Objective-C wrappers for system frameworks that add new swift standard libraries; <br></li><li>  and finished off all the fact that we stop loading some of the new symbols at the start - we load them lazily. <br></li></ul><br>  If you have a project on Objective-C, then the first two stages you most likely will not be needed, because you already have no dynamic libraries.  But over dlopen-th you should think. <br><br>  How can dlopen automate and not write with your hands?  You can see the Facebook SDK.  There it is made through a macro system. <br><br>  Using each class symbol you need to wrap up in loading a dynamic library (if it has not yet been loaded) and loading a symbol (if it has not yet been loaded).  Yes, bulky constructions are obtained, but you can do all this through macros, so that the code for loading a symbol collapses into one line of macro usage. <br><br><h2>  After-main optimization </h2><br>  It remains to talk a bit about after-main.  It is a little bit - because in fact this is the usual task of optimizing an iOS application, about which much has already been written.  And basically it depends on the application itself.  You can not think of some kind of super-general scheme, which is suitable for any application. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/63c/c8a/ef0/63cc8aef0a884401a0d6b296dc073fb1.png"></div><br>  But, nevertheless, I will talk about what we encountered in the Maps and what worked. <br><br>  I recommend to look at three things that are in your application: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> get rid of excessive creation of entities at the start, i.e., create only those dependencies of your application that are needed at the start; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> then, of course, you need to work on optimizing the UI so that only the part of the UI that is needed at the start is loaded; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">see the initialization, for example, of some libraries, databases. </font><font style="vertical-align: inherit;">If it does not affect the perception of the launch by the user, let's postpone it.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What will it look like in the case of Maps? </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimize extra dependencies </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We had a RootViewController class in Maps, which, following the standard approach to dependency injection, accepted dependencies through its constructor. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/1c7/019/d3e/1c7019d3ef54495bac6c200e94722493.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, to create a RouteController, you must first create a Facade lookup and a Facade routing. </font><font style="vertical-align: inherit;">The user has not yet pressed the search and routing button, however these facades have already been created. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moreover, if we investigate further the injection of dependencies, then all dependencies on these two facades will also be created. </font><font style="vertical-align: inherit;">And as a result, at the start, in general, all the dependencies of the application were created. </font><font style="vertical-align: inherit;">This is not great, because, firstly, additional processor time is wasted, and secondly, this complicates profiling very much, because the profiler is clogged with an incredible number of calls, and it is already very difficult to figure it out. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead, we switched to injecting container dependencies that implement lazy dependency creation. </font><font style="vertical-align: inherit;">That is, we now:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entity dependencies are drawn up in the protocol; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the constructor, we accept some implementation of this protocol; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and in the implementation of this protocol, we use lazy var, so that dependencies are created only when addressed. </font></font><br></li></ul><br>  What it looks like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/1e6/62d/de2/1e662dde2c7843b18d8a412b7a0afe43.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create a protocol RootViewControllerDeps, which declares that its implementation should give SearchFacade and RoutingFacade. </font><font style="vertical-align: inherit;">RootViewController now accepts some implementation of this protocol. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the implementation of this protocol, we use lazy var:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/19b/7c8/6d1/19b7c86d110d42c09463d663ad154310.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now searchFacade and routingFacade will be created only when they are needed by RootViewController, i.e. </font><font style="vertical-align: inherit;">only when the user clicks Search. </font><font style="vertical-align: inherit;">And all this does not prevent us from making the classic Composition Root - some class that implements all the dependencies of the application.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/cb8/f77/9da/cb8f779dac104535af4c0d1d3e15d591.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It will implement all the protocols of top-level entities and transfer itself as a dependency container. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What did it give us?</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the start, now only necessary dependencies are created. </font><font style="vertical-align: inherit;">This reduced the launch time and simplified the profiling, because now at the start there are obviously fewer calls, and the profiler can already be figured out somehow.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a side effect, we received a healthy injection of addictions that does not use reflection. </font><font style="vertical-align: inherit;">Now, if in some class some new dependency is needed, we indicate this new dependency in the protocol, and the resolve will not occur at runtime, but at compilation.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the compiler will tell us that Composition Root cannot give this dependency. </font><font style="vertical-align: inherit;">This simplifies refactoring, because now we don‚Äôt need to start and wait until something falls somewhere because we didn‚Äôt specify any dependency in Composition Root or use the constructor in some way. </font><font style="vertical-align: inherit;">Therefore, refactoring has become much easier.</font></font><br></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI optimization </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you need to try to reduce the tree view so that the system does not waste time rendering it. </font><font style="vertical-align: inherit;">There are several aspects to this:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new views can come from containers and controllers. </font><font style="vertical-align: inherit;">It may well be that the container controller is created, its views are created, but it does not affect the UI. </font><font style="vertical-align: inherit;">Then they do not need to be created at the start;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no need to create containers in which nothing is put at the start. </font><font style="vertical-align: inherit;">They occupy additional space in the view-tree and in memory, they have to spend layout work to render;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No need to create views that do not contain content at the start. </font><font style="vertical-align: inherit;">For example, labels without text. </font><font style="vertical-align: inherit;">They need to be created when the necessary content for them appears.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use NavigationController. </font><font style="vertical-align: inherit;">Our map is in NavigationController, because the menu cards and everything else comes through Push.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/0c7/2ac/a16/0c72aca1647d4a349f12f36fb1224785.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the same time, NavigationBar is initially hidden from NavigationController - we do not need it at the start. </font><font style="vertical-align: inherit;">And it turns out that creating a NavigationController does not affect the starting UI. </font><font style="vertical-align: inherit;">So why do we need to create it then?</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/73c/000/d84/73c000d849fd4a0bbf1c234d90cfe92b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's create it lazily. </font><font style="vertical-align: inherit;">When we need to push something, the NavigationController will be created, and the content, in our case, the map, will be transferred to this NavigationController from the place where it lies now. </font><font style="vertical-align: inherit;">And then we get that at the start we will have created only content, not NavigationController.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/5ac/7a5/9c2/5ac7a59c2b4c4d32b603d87f494541fc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, we still have SplitViewController (for iPad), which is not needed on the iPhone at all. </font><font style="vertical-align: inherit;">Yes, and on the iPad it is needed only when you want to show the side socket. </font><font style="vertical-align: inherit;">Therefore, look at your applications, analyze. </font><font style="vertical-align: inherit;">Perhaps you also have something similar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result of our torment, we have come to optimizing the View tree several times. </font><font style="vertical-align: inherit;">Now we create only those containers, view controllers, buttons, views, etc., which are needed at the start.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/505/321/5ac/5053215ac57a43bc950b473cc8234e37.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In principle, on this picture you can think a lot. For example, pay attention to the design, which sticks out on the left over the entire content, but does not get on the screen. This is the good old Navigation Bar, which is hidden. But he created. And we used two custom fonts in the Navigation Bar, respectively, these two shifters are loaded at the start, although nothing is visible. Now it is not created here. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The view bundles on the left are onscreen buttons. We used to create a label for each button, Image, background. Now only the content is created. All the rest - SplitViewController was somewhere else, somewhere just containers. All this we have cleaned, leaving only what is needed at the start. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As other UI optimizations, we can remind you that:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonts should be loaded lazily, as it takes time; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if you are at the start of some graphics render in Core Graphics, then it is better for you to render it in advance; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if you have some kind of font used for the sake of one single label, then this label can also be rendered into a picture; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Of course, you need to work on autolayout - to optimize it, or to get rid of it. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The list can be continued for a long time, it all depends on your application and experience. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optional work at the start </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There remains the last of what can be said in the context of the optimization of after-main. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open the profiler. </font><font style="vertical-align: inherit;">Now only those calls remain in the profiler, only the work that is needed at the start. </font><font style="vertical-align: inherit;">Most likely, this creation of UI, initialization, for example, analytics libraries, opening databases and everything else. </font><font style="vertical-align: inherit;">Think about whether all this work you need at the time of generation of the initial interface? </font><font style="vertical-align: inherit;">Perhaps something you can postpone for 200-300 milliseconds, thus showing the starting UI earlier, and doing the work itself a little later (and the user will not get much worse). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We found such work in the maps:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we start bookmark synchronization later, because we need it in the internal screens; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We also display the bookmarks on the map a little later, because, firstly, it requires synchronization, and, secondly, Account Merge there also pulls some work. </font><font style="vertical-align: inherit;">And if bookmarks appear 200 milliseconds later, no one will notice;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we also later load the application configuration; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> audio sessions are only configured when they are needed, etc. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This list will be in each application. </font><font style="vertical-align: inherit;">Look at your application, analyze. </font><font style="vertical-align: inherit;">Perhaps something you can postpone.</font></font><br><br><h2>  Saving result </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For a month and a half (or how long it will take you) you got some results - you optimized the launch. </font><font style="vertical-align: inherit;">I would like this result not to deteriorate in the next update. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have any elements of continuous integration, then God himself told you to add there measurements of launches and collection of statistics.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after each build, run measurements on some test device, collect statistics, send these statistics, provide access to it. I will not dwell on this now, because everything is well described in the report mail.ru, which was published on Habr√©. I will simply supplement this report with a few tips. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, if you have a Composition Root, let's build the dependency creation log.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/09f/9b1/bf2/09f9b1bf2fc148439e14c8fdb01f4537.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We make a generic function that accepts a generic block and returns an instance of some type. </font><font style="vertical-align: inherit;">In this function, we call this block and log some actions - in general, we decorate the creation of dependencies. </font><font style="vertical-align: inherit;">Such a function fits into our approach fairly fairly with composition root, which implements a lazy dependency creation, because we only need to add a call to this function in the block that is called when creating the next dependency (and this is a generic, so you don‚Äôt need to bother with typing).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/87c/f79/141/87cf79141538430180a43623fb9c5c30.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we can wrap all the creation of dependencies in this trackCreation and decorate their creation. </font><font style="vertical-align: inherit;">In our case, you need to at least collect the log.</font></font><br><br>  Why do this?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then, when refactoring, you can hurt something, and you will create a dependency, which should not actually be created. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beach swift - these are dynamic libraries. So let's ensure that we do not have new dynamic libraries. We can use the Objective-C runtime to get the list of currently loaded libraries.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/b92/369/154/b92369154efd40a0bd8a2c83fe111662.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The objc_copyImageNames function returns a pointer to an array containing the paths to all loaded frameworks. There are a lot of things there, but the main thing is that you can filter out those libraries that are in the bundle of our application, since they affect the launch. You can make sure that nothing new appears there. And if it appeared, then immediately try to figure out why it happened. Something may appear there, for example, because of an iOS update: they added a new wrapper over some standard library, or some new one was updated, pulled another dependency that is written in swift, or some class in Objective- C rewritten. In general, there are a lot of options. It is necessary to ensure that new dynamic libraries do not appear. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But this is generally hardcore:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/e82/eda/504/e82eda504f214e2ab633268622cddd53.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is such a function - sysctl. It interacts directly with the operating system kernel and allows you to pull information about the current process out of it. In the structure that it returns, there is a timestamp of the beginning of this process, and, we checked, through this function it is really possible to get the full load time of the application, starting from the user clicking on the button, i.e. counting pre-main.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/7ba/dc9/21a/7badc921a40641bdaa5943218f3e50ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why didn‚Äôt I talk about it earlier when I talked about launch measurements? </font><font style="vertical-align: inherit;">Because in fact, DYLD_PRINT_STATISTICS is enough for launch measurements during optimization. </font><font style="vertical-align: inherit;">And this thing is needed to measure the time of user launches, because there you can not transfer DYLD_PRINT_STATISTICS. </font><font style="vertical-align: inherit;">And it would be very nice to measure user launches and send them to analytics systems and check again that after each update you didn‚Äôt have a full launch time. </font><font style="vertical-align: inherit;">Here you need to use sysctl to get the beginning of the process, and gettimeofday to take some point, for example, start main. </font><font style="vertical-align: inherit;">And from each other deduct them.</font></font><br><br><h2>  Instead of conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It remains to talk about what we have achieved in the maps. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/e00/cb9/866/e00cb986693c4794b8a6eb0badc0e1db.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We were able to speed up the cold start by 30%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We worked on all the parts. The loading of dynamic libraries was optimized using Objective-C wrappers for AVFoundation, MapKit and CoreLocation (it dropped one and a half times, as for the test application). We didn‚Äôt initially have swift libraries in the subfields, so in principle, the application did not load for S5 in just as long - just 2.3 seconds. It can be worse, especially in applications where there are many swift pods. But still, we did better - dynamic libraries load 1.5 times faster. Obj setup, rebase / bind and initialization, we did a little bit less by lazy loading SpeechKit. Here you can continue on - some of your own pieces of the application is lazily loading.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The green and lilac blocks are after-main, we just have it divided into two segments: from the beginning of main to didFinishLaunching and didFinishLaunching itself. From the beginning of main and to didFinishLaunching, we have several times improved time due to the fact that no extra dependencies are created at the start, and didFinishLaunching we have improved by 40-50% just due to the optimization of the view-tree and putting off unnecessary work at the start for 200-300 milliseconds. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to Apple for having the same picture on other devices!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/2f1/643/af0/2f1643af03bd4dfc9c763bcd566357d0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no such thing that we optimized on one device, and on the other it all did not work. </font><font style="vertical-align: inherit;">All devices work approximately equally, and the ratio between the different stages of launching them is approximately the same. </font><font style="vertical-align: inherit;">And while we on the iPhone 5S optimized the launch by 30%, on the iPhone 7, 6S and 5, we received a similar acceleration. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we talk about a warm start, then it is even better.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/ce0/9ab/4ce/ce09ab4ceb3c45c6a87faf617f8b9799.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because in a warm start, as we remember, our pre-main has practically no effect on anything. </font><font style="vertical-align: inherit;">But after-main is, in fact, what a warm start consists of. </font><font style="vertical-align: inherit;">And in our case, since we didFinishLaunching optimized not by 30%, but by 40%, it turned out that the launch time improved by 37%. </font><font style="vertical-align: inherit;">The same on other devices.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/95e/62d/c3c/95e62dc3cb3d4e65a573dd3158392b31.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The picture for 5S is repeated for other devices. </font><font style="vertical-align: inherit;">And for new devices like the iPhone 6S and 7, the warm launch accelerated 2 times. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And despite the fact that all these values ‚Äã‚Äãare not so big when you actually use the application, this is noticeable. </font><font style="vertical-align: inherit;">Our users have responded to this. </font><font style="vertical-align: inherit;">There are good reviews in the AppStore. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In conclusion, let's go over what we talked about today. </font><font style="vertical-align: inherit;">Startup optimization is an iterative process.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/cd4/48b/ba4/cd448bba4b5649f2b28a7a7e2f3bc990.png"></div><br>  At each iteration, you are trying to do something; you are putting forward and implementing some of your provisions.  After the iteration, cycle the measurements on different or even on one device (what works on one iPhone will work on another iPhone).  Then again, trying to improve something. <br><br>  The optimization itself consists of working on two segments: pre-main and after-main.  And they are optimized completely independently of each other, because with pre-main, only the system works for us - DYLD (dynamic loader), and after-main is our code. <br>  When optimizing pre-main, we try, first, to reduce the number of dynamic libraries through the use of a plugin for cocoapods and through writing wrappers for extra swift standard libraries.  And secondly, we are trying to reduce the size of the binary file. <br><br>  When optimizing after-main, we are guided by a profiler, etc., trying to do as little work as possible at the start.  We try not to create unnecessary entities (we create only the amount of UI that is needed to display the starting interface), and we are trying to postpone the work that is not necessary to be shown. <br><br>  That's all the secrets. <br><br><hr><br>  If you like mobile development as well as we, we recommend to pay attention to the following reports at the upcoming conference <a href="https://mobiusconf.com/">Mobius 2017 Moscow</a> : <br><br><ul><li>  <a href="https://mobiusconf.com/2017/msk/talks/zqoeak6eiouwka0oessa2/">Instant Apps: how to teach the application to work without installation</a> </li><li>  <a href="https://mobiusconf.com/2017/msk/talks/jslrnocqzieusmswmg0w0/">Writing Java Friendly Kotlin Code</a> </li><li>  <a href="https://mobiusconf.com/2017/msk/talks/1viu3dhu7esqsagsugeaco/">Life without connectivity: from chaos to consensus</a> </li><li>  <a href="https://mobiusconf.com/2017/msk/talks/7eig3wj0c46u2scags2ugk/">Make your gadget talk: Google Assistant</a> </li><li>  <a href="https://mobiusconf.com/2017/msk/talks/1tlnb0svnwgieo2uewauom/">How I hated ORM</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/336852/">https://habr.com/ru/post/336852/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336842/index.html">We bypass the commercial protection using the black box method and write packet hack for lineage 2</a></li>
<li><a href="../336844/index.html">One method for solving different tasks: the percentage distribution of calls</a></li>
<li><a href="../336846/index.html">Richard Hamming: "I often compare creativity with sex"</a></li>
<li><a href="../336848/index.html">Transfer mail from Exchange to Zimbra</a></li>
<li><a href="../336850/index.html">Back up configuration switches, or fasten a little automation to GLPI</a></li>
<li><a href="../336854/index.html">Multithreading in C ++ and SObjectizer with CSP channels, but without any actors ...</a></li>
<li><a href="../336858/index.html">Entertaining math with colored cubes</a></li>
<li><a href="../336860/index.html">How to hash passwords in high-load services. Yandex experience</a></li>
<li><a href="../336864/index.html">Getting ready for Java 9. Review of the most interesting improvements.</a></li>
<li><a href="../336866/index.html">Big Data and Odnoklassniki: what they do with the data in the 2nd most visited social network in Russia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>