<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Uncertain behavior and the Fermat theorem</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In accordance with C and C ++ standards, if program execution leads to an overflow of a signed integer variable, or to any of hundreds of other ‚Äúundef...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Uncertain behavior and the Fermat theorem</h1><div class="post__text post__text-html js-mediator-article"> In accordance with C and C ++ standards, if program execution leads to an overflow of a signed integer variable, or to any of hundreds of other ‚Äúundefined actions‚Äù (undefined behavior, UB), then the result of the program execution can be any: it can tweet obscenity, can format the disk for you ... <br>  Alas, in reality, ‚ÄúEaster eggs‚Äù, which would force the program in the case of UB to do something out of the ordinary, have not met since GCC 1.17 - it launched <a href="https://ru.wikipedia.org/wiki/NetHack">nethack</a> when it encountered unknown <code>#pragma</code> in the program code.  Usually, the result of UB is much duller: the compiler simply optimizes the code for those cases when UB does not occur, without giving the slightest importance to what this code will do in the case of UB - because the standard allows you to do anything in this case! <br>  To illustrate how the abundance of UB in the standard allows the compiler to perform unobvious optimizations, Raymond Chen <a href="http://blogs.msdn.com/b/oldnewthing/archive/2014/06/27/10537746.aspx">gives</a> this code example: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-type"><span class="hljs-type">bool</span></span> exists_in_table(<span class="hljs-type"><span class="hljs-type">int</span></span> v) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>[i] == v) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre><br>  In the condition of the cycle, we made a mistake by one, putting <code>&lt;=</code> instead of <code>&lt;</code> .  As a result, <code>exists_in_table()</code> must either return <code>true</code> on one of the first four iterations, or it will read the <code>table[4]</code> , which is UB, and in this case, <code>exists_in_table()</code> can do anything, including return <code>true</code> !  In full compliance with the standard, the compiler can optimize the <code>exists_in_table()</code> code to <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> table[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists_in_table</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Such optimizations sometimes catch programmers by surprise. <a name="habracut"></a>  John Reger <a href="http://blog.regehr.org/archives/759">gives a</a> selection of examples where UB led to significant consequences: <ul><li>  UB, with a significant shift to the left, <a href="http://code.google.com/p/nativeclient/issues/detail%3Fid%3D245">allowed the</a> compiler to remove from the NaCl a check of the return address important to safety. </li><li>  In the Linux kernel, dereferencing a pointer before checking for <code>NULL</code> <a href="https://isc.sans.edu/diary.html%3Fstoryid%3D6820">allowed the</a> compiler to remove this check, creating a vulnerability in the system. </li><li>  In Debian, using an uninitialized array as a source of random data to initialize the RNG seed <a href="http://kqueue.org/blog/2012/06/25/more-randomness-or-less/">led</a> to the fact that the entire seed calculation was deleted by the compiler. </li><li>  When the variable <code>p</code> not initialized, the program <a href="http://markshroyer.com/2012/06/c-both-true-and-false/">can</a> execute both the code inside <code>if (p) { ... }</code> and the code inside <code>if (!p) { ... }</code> . </li><li>  When the <code>INT_MAX</code> variable <code>x</code> is equal to <code>INT_MAX</code> , the expression <code>(x+1)&gt;x</code> in different places of the same program <a href="http://www.cs.utah.edu/~regehr/papers/overflow12.pdf">can be</a> interpreted as both true and false. </li><li>  An infinite loop, such as finding a non-existent value, can be removed by the compiler.  For example, so the compiler <a href="http://blog.regehr.org/archives/161">can</a> "disprove" the Great Fermat theorem.  (We will analyze this example in detail.) </li><li>  The compiler <a href="http://blog.regehr.org/archives/232">can</a> make the program "clairvoyant" by rearranging the operation, potentially capable of breaking down the process (division by zero, reading at the zero pointer, etc.), ahead of the output operation.  For example, this code: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ setlinebuf(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"hello!\n"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo3</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z)</span></span></span><span class="hljs-function"> </span></span>{ bar(); a = y%z; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ foo3(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  - will have time to print a message before SIGFPE, if it is compiled without optimizations;  and will crash right at the start, if you enable optimization.  The program "knows in advance" that it is destined to fall with SIGFPE, and therefore does not even bother printing a message.  A similar example, only with SIGSEGV, is Chen. </li></ul><br><br>  In 2012, Reger announced a contest for ‚Äúthe most bizarre UB result‚Äù.  <a href="http://blog.regehr.org/archives/767">One of the winners</a> took advantage of the fact that using a pointer after it is passed to a parameter in <code>realloc()</code> is UB.  His program prints different values ‚Äã‚Äãusing the same pointer: <br><pre> <code class="hljs vbscript">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> main() { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *p = (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>*)malloc(sizeof(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *q = (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>*)realloc(p, sizeof(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>)); *p = <span class="hljs-number"><span class="hljs-number">1</span></span>; *q = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p == q) printf(<span class="hljs-string"><span class="hljs-string">"%d %d\n"</span></span>, *p, *q); }</code> </pre><br><pre> $ clang -O realloc.c;  ./a.out 
 12
</pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The programs of the other winners of the competition, in my opinion, are more boring and partially overlap with the examples given earlier. <br>  But nothing compares to Reger‚Äôs example - the <a href="http://blog.regehr.org/archives/140">‚Äúrefutation‚Äù of Fermat's compiler theorem</a> . <br><br>  He explains that for some embedded application he needed to write an infinite loop in C ++ so that the optimizing compiler could not remove all the code following the loop from the program.  Modern compilers are smart enough to recognize ‚Äúidioms‚Äù like <code>while (1) { }</code> or <code>for (;;) { }</code> - they understand that the code following such a cycle will never be executed, which means there is no need to compile it.  For example, the function <br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { } open_pod_bay_doors(); }</code> </pre><br>  - most compilers ‚Äúshorten‚Äù to a single instruction: <br><pre> <code class="hljs"> foo: L2: jmp L2</code> </pre><br>  Clang turns out to be even smarter, it is able to recognize (and delete) even such disguised endless cycles: <br><pre> <code class="hljs objectivec"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { i+=<span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>==(i&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><br>  Here, as in the previous example, the compiler <b>is able to prove</b> that it is impossible to exit the loop, which means that it can be replaced with a single <code>jmp</code> instruction. <br><br>  Reger decided: Fermat's compilers are unlikely to prove the theorem during compilation? <br><br><pre> <code class="hljs swift">int fermat (void) { const int <span class="hljs-type"><span class="hljs-type">MAX</span></span> = <span class="hljs-number"><span class="hljs-number">1000</span></span>; int a=<span class="hljs-number"><span class="hljs-number">1</span></span>,b=<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((a*a*a) == ((b*b*b)+(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>)))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; a++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a&gt;<span class="hljs-type"><span class="hljs-type">MAX</span></span>) { a=<span class="hljs-number"><span class="hljs-number">1</span></span>; b++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b&gt;<span class="hljs-type"><span class="hljs-type">MAX</span></span>) { b=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>&gt;<span class="hljs-type"><span class="hljs-type">MAX</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } #include &lt;stdio.h&gt; int main (void) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fermat()) { printf (<span class="hljs-string"><span class="hljs-string">"Fermat's Last Theorem has been disproved.\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { printf (<span class="hljs-string"><span class="hljs-string">"Fermat's Last Theorem has not been disproved.\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><pre> regehr @ john-home: ~ $ icc fermat2.c -o fermat2
 regehr @ john-home: ~ $ ./fermat2
 Fermat's Last Theorem has been disproved.
 regehr @ john-home: ~ $ suncc -O fermat2.c -o fermat2
 "fermat2.c", line 20: warning: statement not reached
 regehr @ john-home: ~ $ ./fermat2
 Fermat's Last Theorem has been disproved.
</pre><br><br>  How so?  The loop ends with <code>return 1;</code>  - the compiler was able to prove that Fermat's theorem is incorrect ?! <br><br>  I wonder what values <code>a,b,c</code> he ‚Äúfound‚Äù? <br><br>  Reger added print "found values" before <code>return 1;</code>  - that's when the compiler recognized the impotence and honestly compiled an infinite loop.  (Nothing, naturally, was printed.) <br><br>  Despite the fact that this program does not contain any arithmetic overflows (the factors vary within 1..1000, the sum of their cubes does not exceed 2 <sup>31</sup> ), the C ++ standard declares an ‚Äúinfinite action‚Äù an infinite loop without changing the external state - therefore, C ++ compilers <b>can</b> consider any such cycle is finite. <br>  The compiler easily sees that the only way out of the <code>while(1)</code> is the operator <code>return 1;</code>  , and operator <code>return 0;</code>  end <code>fermat()</code> unreachable;  so he optimizes this feature until <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fermat</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br><br>  In other words, the only possibility to write such an infinite loop in C ++ that the compiler could not remove is to add a change in the external state to the loop.  The easiest (and standard!) Way to do this is to change a variable declared as <code>volatile</code> . </div><p>Source: <a href="https://habr.com/ru/post/229963/">https://habr.com/ru/post/229963/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../229953/index.html">Webinar "Using public clouds in retail"</a></li>
<li><a href="../229955/index.html">Spring and @Autowired for ENUM types. Optional</a></li>
<li><a href="../229957/index.html">How to discuss money with management or why sometimes careers stop?</a></li>
<li><a href="../229959/index.html">Lorentz's dynamic system and computational experiment</a></li>
<li><a href="../229961/index.html">Practical tips and tricks when working with DJI drones and their autopilot systems</a></li>
<li><a href="../229965/index.html">Why does Outlook launch Ctrl + F forwarding instead of searching like all normal programs?</a></li>
<li><a href="../229969/index.html">Release of KDE Plasma 5.0 and KDE Frameworks 5</a></li>
<li><a href="../229971/index.html">DigitalOcean opens point of presence in London</a></li>
<li><a href="../229973/index.html">Books are not flat ...</a></li>
<li><a href="../229975/index.html">Real-time WebScada based on OPC UA and WebSocket technologies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>