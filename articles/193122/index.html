<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using NDK in Android Studio</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Currently, Android Studio is very popular among Android developers, based on IntelliJ IDEA by JetBrains. However, when using this IDE, problems may ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using NDK in Android Studio</h1><div class="post__text post__text-html js-mediator-article">  Currently, Android Studio is very popular among Android developers, based on IntelliJ IDEA by JetBrains.  However, when using this IDE, problems may arise when developing applications using native code, since the Android NDK is designed primarily to use IDE Eclipse and ADT. <br><br>  The purpose of this article is to provide a detailed description of the process of creating an Android application using the NDK in Android Studio, in particular, offering a fairly simple and efficient configuration of the gradle (package building system used in Android Studio) to ensure that native libraries are included in the APK file.  The article also includes a brief instruction on working with NDK in the Eclipse IDE and an introduction to native development sufficient to write the first application. <br><a name="habracut"></a><br><br>  This article is intended primarily for novice developers.  The described solution is not the only one, but it is quite convenient, especially for those who worked with the NDK in Eclipse.  If the explanation seems too detailed to someone of the readers, then at the end of the article there is a brief summary describing only the algorithm of the required actions without comments to each step. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since there are many articles describing working with NDK, I will not use complex libraries as an example, but I will limit myself to the simplest example of hello-jni.  The source code of this example can be found in the directory &lt;path_to_ndk&gt; / samples / hello-jni <br><br>  In the Eclipse environment, there were no special problems with using NDK.  The project directory looks like this: <br><img src="https://habrastorage.org/storage3/27b/561/58d/27b56158d3b283add7f24cb6c958c898.jpg"><br>  Fig.1 Main project directory for Eclipse <br><br>  We are interested in jni and libs directories.  The jni directory contains source codes in native languages ‚Äã‚Äã(* .c; * .cpp), header files (* .h), makefiles (* .mk).  I will not dwell on the purpose of these files for a long time, since quite a lot of materials and articles are devoted to this.  I will only mention that jni means java native interface.  It is through this interface that the native procedures are called from java code.  Therefore, do not forget to include the library &lt;jni.h&gt; in your c / c ++ files and remember the correct syntax of functions that will be called via jni.  For example, in my case, the application has a package name: <br>  evi.ntest <br>  therefore, the function description looks like this: <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">jstring </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Java_evi_ntest_MainActivity_stringFromJNI</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( JNIEnv* env, jobject thiz )</span></span></span></span></code> </pre> <br>  where jstring is the name of the data type c corresponding to the type of string in java, Java is in this case a service prefix indicating the language from which the function will be called, evi_ntest is the name of the package that will call the function, MainActivity is the name of the activity from which it will be called function, stringFromJNI - the name of the function. <br>  In java-code, the description of this function looks much simpler: <br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">native</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stringFromJNI</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre><br><br>  Do not forget to also specify the code files used in the .mk files.  For starters, you can use the .mk files from the NDK examples, modifying the file names, but I further recommend that you study their structure. <br><br>  The libs directory contains ready-made binary libraries for various processor architectures (by default, armeabi).  A dynamic library is a file with a .so extension, a static library is a file with a .a extension.  To get these libraries, you need to compile the source codes using the Android NDK.  In Unix-systems (in my case - Mac OSX) this requires entering the following lines in the terminal: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> &lt;__&gt; &lt;__ndk&gt;/ndk-build</code> </pre><br>  At the same time, the NDK automatically compiles the source codes from the jni folder and places the resulting libraries in libs / armeabi (you can also set the compilation for x86, mips, arm v7-neon processors using command line parameters). <br>  When using Windows, you will need to use additional utilities, perhaps - plug-ins for MS Visual Studio. <br>  In any case, it does not matter which way the finished libraries are obtained, the fact that if the libs subdirectory is in the project folder is important, Eclipse automatically includes its contents in the APK file when it is built. <br><br>  Since this article is devoted only to the basics of working with NDK, then I‚Äôll finish the introduction to programming in native languages ‚Äã‚Äãunder android.  For more detailed acquaintance with the principles of native development, I recommend studying examples from the &lt;path_to_ndk&gt; / samples / directory, as well as reading articles, including those in Russian.  An example of a good article about Android NDK in Russian, I advise you to pay attention (it was not written by me): <br><br>  <a href="http://idev.by/android/21115/">idev.by/android/21115</a> <br><br>  I turn to the main section of the article - setting up the Android Studio IDE to work with native code. <br><br>  The Android Studio environment by default builds an APK using gradle.  This collector has extensive customization options, but with the standard settings gradle does not include native libraries in the APK file. <br><br>  Consider a partial project structure in Android Studio: <br><img src="https://habrastorage.org/storage3/b66/a1b/f80/b66a1bf80e1d45813670a69e8cf96bc4.jpg"><br>  Fig.2 Path to the source code of the project Android Studio. <br><br>  When working, I had a logical desire to place the jni folder in the src / main directory, since that is where all the other source code files are stored.  Of course, the reader can place the jni directory where it suits him.  The main thing is to remember to compile binary libraries using NDK (again, on UNIX systems, you need to go to the directory containing jni in the terminal, then call the ndk-build executable file located in the folder with the NDK, writing the full path to it terminal, in MS Windows you need to use additional utilities).  The problem is that by default gradle will not pack in the APK of the library. <br><br>  However, gradle is easy to configure to include in the assembly of java-libraries (* .jar files).  It is worth noting that jar-files are zip-archives containing any resources, as well as object code.  Thus, to include binary libraries * .so and * .a it is enough to pack them into a jar-file. <br>  This is done like this: <br><ul><li>  Rename the libs folder containing our binary libraries in lib </li><li>  Compress this folder with any zip archiver </li><li>  Change the extension of the resulting file to .jar </li></ul><br>  The resulting library can be connected at the project build stage, while the resulting APK file will include binary libraries, and the application will call procedures written in native code. <br>  This issue has been repeatedly discussed in various English-language forums, for example, Stack Overflow: <br>  <a href="http://stackoverflow.com/questions/16667903/android-studio-gradle-and-ndk">stackoverflow.com/questions/16667903/android-studio-gradle-and-ndk</a> <br>  However, this information is rather brief, fragmented and requires a certain knowledge of the gradle syntax from the reader.  The purpose of my article is to provide readers with a detailed Russian-language explanation, available even to those who have just started working with Android Studio and gradle. <br><br>  Let's look at 2 ways of packing libraries: manual and automatic. <br><br>  <b>Manual packing method:</b> <br><br>  This method is very inconvenient, but it does exist.  A valid case of practical application: the availability of a ready-made library and no need to change it.  In this case, the operations described below will need to be performed only once. <br><br>  Open build.gradle, located at the address "&lt;project_path&gt; / &lt;project_name&gt; Project / &lt;project_name&gt; /", in my case: <br><img src="https://habrastorage.org/storage3/c26/4ec/d7c/c264ecd7c029e8e9fb5e5ad3d912b050.jpg"><br>  Fig.3 Location of the configurable build.gradle file. <br><br>  This file initially looks something like this: <br><br><pre> <code class="hljs cs">buildscript { repositories { mavenCentral() } dependencies { classpath <span class="hljs-string"><span class="hljs-string">'com.android.tools.build:gradle:0.5.+'</span></span> } } apply plugin: <span class="hljs-string"><span class="hljs-string">'android'</span></span> repositories { mavenCentral() } android { compileSdkVersion <span class="hljs-number"><span class="hljs-number">17</span></span> buildToolsVersion <span class="hljs-string"><span class="hljs-string">"17.0.0"</span></span> defaultConfig { minSdkVersion <span class="hljs-number"><span class="hljs-number">9</span></span> targetSdkVersion <span class="hljs-number"><span class="hljs-number">9</span></span> } } dependencies { compile <span class="hljs-string"><span class="hljs-string">'com.android.support:support-v4:18.0.0'</span></span> }</code> </pre><br><br>  At the very bottom there is a dependencies section.  There should add the following line: <br><br>  compile fileTree (dir: 'src / main /', include: '* .jar') <br><br>  Consider this command: gradle during compilation will be forced to include the file tree (file and folder structure matching the specified mask) located at the address 'src / main /' (i.e. in the directory where the source codes are located, as well as the created us jar file), while the parameter '* .jar' is used as a mask, i.e.  all files with this extension will be included.  Note that in this case the path is considered relative to the location of the build.gradle file. <br>  As a result of executing this command, gradle will unpack the jar file and include binary libraries in the APK file. <br><br>  Become familiar with the modified build.gradle file, so as not to confuse dependencies and buildscript.dependencies. <br><br><pre> <code class="hljs pgsql">buildscript { repositories { mavenCentral() } dependencies { classpath <span class="hljs-string"><span class="hljs-string">'com.android.tools.build:gradle:0.5.+'</span></span> } } apply plugin: <span class="hljs-string"><span class="hljs-string">'android'</span></span> repositories { mavenCentral() } android { compileSdkVersion <span class="hljs-number"><span class="hljs-number">17</span></span> buildToolsVersion "17.0.0" defaultConfig { minSdkVersion <span class="hljs-number"><span class="hljs-number">9</span></span> targetSdkVersion <span class="hljs-number"><span class="hljs-number">9</span></span> } } dependencies { compile <span class="hljs-string"><span class="hljs-string">'com.android.support:support-v4:18.0.0'</span></span> compile fileTree(dir: <span class="hljs-string"><span class="hljs-string">'src/main/'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>: <span class="hljs-string"><span class="hljs-string">'*.jar'</span></span>) }</code> </pre><br><br>  The reader will most likely notice that this method is very inconvenient if there is a need for frequent changes in the native code, since after each recompilation it is necessary to delete the old jar file, rename the libs folder to lib, archive it, change the archive extension.  Therefore, we use the power of gradle and automate the process. <br><br>  <b>Automatic mode</b> <br><br>  The gradle packet collector allows you to create tasks (functions), and its capabilities include the creation of various types of archives, including zip.  We will use this and add the following lines to build.gradle (the location of this file is discussed above): <br><br><pre> <code class="hljs pgsql">task nativeLibsToJar(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Zip, description: <span class="hljs-string"><span class="hljs-string">'create a jar archive of the native libs'</span></span>) { destinationDir file("$buildDir/native-libs") baseName <span class="hljs-string"><span class="hljs-string">'native-libs'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> <span class="hljs-string"><span class="hljs-string">'jar'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fileTree(dir: <span class="hljs-string"><span class="hljs-string">'src/main/libs'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>: <span class="hljs-string"><span class="hljs-string">'**/*.so'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-string"><span class="hljs-string">'lib/'</span></span> } tasks.withType(Compile) { compileTask -&gt; compileTask.dependsOn(nativeLibsToJar) }</code> </pre><br><br>  This code snippet can be added to any part of the file, except for existing sections, for example at the end of the file.  I placed them in front of the dependencies section. <br>  This code includes the task, which creates in the build folder, located at the address "&lt;project_path&gt; / &lt;project_name&gt; Project / &lt;project_name&gt; /" subdirectory native-libs, in this subfolder creates a file native-libs.jar, the file structure corresponds the required java-library structure containing binary libraries .so.  If you plan to use also static .a libraries, instead of the line: <br><br>  from fileTree (dir: 'src / main / libs', include: '** / *. so') <br><br>  You should use: <br><br>  from fileTree (dir: 'src / main / libs', include: '** / *. *') <br><br>  Then it remains to add the line to the dependencies section: <br><br>  compile fileTree (dir: "$ buildDir / native-libs", include: 'native-libs.jar') <br><br>  During the build, this command will include the contents of the native-libs.jar library created programmatically in the APK file. <br><br>  An example of build.gradle with this code: <br><br><pre> <code class="hljs pgsql">buildscript { repositories { mavenCentral() } dependencies { classpath <span class="hljs-string"><span class="hljs-string">'com.android.tools.build:gradle:0.5.+'</span></span> } } apply plugin: <span class="hljs-string"><span class="hljs-string">'android'</span></span> repositories { mavenCentral() } android { compileSdkVersion <span class="hljs-number"><span class="hljs-number">17</span></span> buildToolsVersion "17.0.0" defaultConfig { minSdkVersion <span class="hljs-number"><span class="hljs-number">9</span></span> targetSdkVersion <span class="hljs-number"><span class="hljs-number">9</span></span> } } task nativeLibsToJar(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Zip, description: <span class="hljs-string"><span class="hljs-string">'create a jar archive of the native libs'</span></span>) { destinationDir file("$buildDir/native-libs") baseName <span class="hljs-string"><span class="hljs-string">'native-libs'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> <span class="hljs-string"><span class="hljs-string">'jar'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fileTree(dir: <span class="hljs-string"><span class="hljs-string">'src/main/libs'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>: <span class="hljs-string"><span class="hljs-string">'**/*.so'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-string"><span class="hljs-string">'lib/'</span></span> } tasks.withType(Compile) { compileTask -&gt; compileTask.dependsOn(nativeLibsToJar) } dependencies { compile <span class="hljs-string"><span class="hljs-string">'com.android.support:support-v4:18.0.0'</span></span> compile fileTree(dir: "$buildDir/native-libs", <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>: <span class="hljs-string"><span class="hljs-string">'native-libs.jar'</span></span>) }</code> </pre><br><br>  Please note that my directories jni, libs are located at the address "&lt;project_path&gt; / &lt;project_name&gt; Project / &lt;project_name&gt; / src / main".  If in your project these folders lie elsewhere, then you should take this into account in shaping the paths for all commands. <br><br>  If everything is done correctly, Android Studio will automatically create the correct library in the build directory during the project build and include it in the finished program.  Thus, after each recompilation of the native code, there is no need to perform any additional actions and settings, the gradle will do everything by itself. <br><br>  Now, as promised at the beginning of the article, a brief summary describing only the full algorithm without any unnecessary comments: <br><br><h5>  Brief summary </h5><br><br><ol><li>  Open the folder "&lt;project_path&gt; / &lt;project_name&gt; Project / &lt;project_name&gt; / src / main" and create a jni subfolder there. </li><li>  Open the file "&lt;project_path&gt; / &lt;project_name&gt; Project / &lt;project_name&gt; /build.gradle", modify the dependencies section, and then add the code: <br><br><pre> <code class="hljs pgsql">dependencies { compile <span class="hljs-string"><span class="hljs-string">'com.android.support:support-v4:18.0.0'</span></span> compile fileTree(dir: "$buildDir/native-libs", <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>: <span class="hljs-string"><span class="hljs-string">'native-libs.jar'</span></span>) } task nativeLibsToJar(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Zip, description: <span class="hljs-string"><span class="hljs-string">'create a jar archive of the native libs'</span></span>) { destinationDir file("$buildDir/native-libs") baseName <span class="hljs-string"><span class="hljs-string">'native-libs'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> <span class="hljs-string"><span class="hljs-string">'jar'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fileTree(dir: <span class="hljs-string"><span class="hljs-string">'src/main/libs'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>: <span class="hljs-string"><span class="hljs-string">'**/*.so'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-string"><span class="hljs-string">'lib/'</span></span> } tasks.withType(Compile) { compileTask -&gt; compileTask.dependsOn(nativeLibsToJar) }</code> </pre><br>  To include also static libraries * .a (if available), change the string <br><br>  from fileTree (dir: 'src / main / libs', include: '** / *. so') <br><br>  on <br><br>  from fileTree (dir: 'src / main / libs', include: '** / *. *') <br><br></li><li>  In the jni subfolder we place the files * .mk, * .h, * .c, we write the native code. </li><li>  Open the folder "&lt;project_path&gt; / &lt;project_name&gt; Project / &lt;project_name&gt; / src / main" in the terminal. </li><li>  Enter the command &lt;path_to_k tok&gt; / ndk-build in the terminal </li><li>  Run the project. </li></ol><br><br>  <b>Important!</b> <br>  This manual is intended for Unix operating systems (in my case, MacOSX).  For the MS Windows operating system, items 4 and 5 are not relevant, as additional utilities are required to compile the native libraries.  It is also likely that it would be advisable to change the library storage paths to more convenient ones and take this into account in the build script. <br><br>  At this point, I conclude the article and bow out.  I hope someone this article will save time. <br><br>  Good luck to your native programming, the main thing is that every time, do not forget to ask yourself whether you should use the native code.  There may well be java-analogs, the use of which is simpler, and in most cases better, since development time is reduced, code understanding is improved by others, the complexity of the application architecture is reduced, and the power of modern devices is enough to perform most tasks even in Dalvik VM. <br><br><habracut></habracut></div><p>Source: <a href="https://habr.com/ru/post/193122/">https://habr.com/ru/post/193122/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../193102/index.html">How we prepared the network in Kazan for the Universiade congestion</a></li>
<li><a href="../193108/index.html">An interesting way to legally bypass DRM on Amazon Kindle with Lego</a></li>
<li><a href="../193110/index.html">Studying the pyramids</a></li>
<li><a href="../193116/index.html">Accounting of statistical information about traffic jams when searching for driving by car</a></li>
<li><a href="../193118/index.html">Error in L7 at Mikrotik</a></li>
<li><a href="../193124/index.html">Kinect 3.0</a></li>
<li><a href="../193126/index.html">The future of our civilization: death or immortality?</a></li>
<li><a href="../193128/index.html">Downloading from mSATA on the ACER Aspire V7-482PG Ultrabook</a></li>
<li><a href="../193130/index.html">"Living" artificial intelligence, man and problems AI</a></li>
<li><a href="../193132/index.html">Visualization of patterns of used passwords</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>