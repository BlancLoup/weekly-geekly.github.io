<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Santa Claus task and practical logistics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is known that only 5% of programmers are able to solve problems of multi-threaded programming. And in place with that, with an increase in the numb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Santa Claus task and practical logistics</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/45d/a9b/3cd/45da9b3cd41ec6fd6d9a4fe46999ea9b.jpg"><br>  It is known that only 5% of programmers are able to solve problems of multi-threaded programming.  And in place with that, with an increase in the number of cores, even for mobile devices, the need to use several threads increases many times.  Every day there are new programming languages ‚Äã‚Äãspecifically designed for solving specific problems of parallel programming, and in already well-known and widely used solutions methods appear that not only facilitate understanding, but also reduce the solution of the problem to a kind of program code poetry. <br><br>  While reading the book <a href="http://www.ozon.ru/context/detail/id/4187085/">‚ÄúThe Perfect Code‚Äù edited by Andy Oram and Greg Wilson,</a> I happened to encounter an interesting task in the chapter on parallel processing (ch. 24. p. 444).  In it, the author, Simon Peyton Jones, gives a solution in Haskell.  There he also states that there are solutions to the Sat Klaus problem for the Ada95 and Polyphonic C # languages.  Due to my professional interests, I had to discuss with my colleagues a few earlier possibilities of multi-stream Apple implementation for the Objective-C language. <br><br>  It is considered that it is necessary to program at the level of abstractions, not ‚Äúin language‚Äù, but with the same success one can look for the beauty of poetry in emotions, and not in the elegance of a syllable expressed through language.  Under the cut, I propose to sing with me a song for those for whom linguistic expressiveness is not an empty sound, but a melody that stirs imagination. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  <b>Formulation of the problem:</b> </h4><br>  <i>‚ÄúSanta periodically sleeps until she is awakened either by all of her nine reindeer who have returned from free grazing, or by a group of three elves, of which he has only nine.</i>  <i>If deer wake him up, he harnesses each of them into a sleigh, delivers toys with them, and in the end unharns them (releasing them for free release).</i>  <i>If the elves wake him up, he leads each group to his office, confers with them on the development of new toys, and in conclusion, each of them leaves the office (giving the opportunity to return to work).</i>  <i>If Santa Claus is waited at the same time by a group of elves and a group of deer, he will give priority to deer. ‚Äù</i>  <i>(WITH)</i> <br><br><h4>  <b>Introduction:</b> </h4><br>  It seemed to me that this is an ideal task to demonstrate the capabilities of the language.  At one time, I had a lot of programming in C # multi-threaded applications, and then I thought that there was no perfect language for this purpose.  With # bribed its simplicity and efficiency.  But Apple has turned this process into a song.  And as in every song you need to feel that rhythm, that meter, which will give pleasure from the heard music.  At first, dealing with the clutter of a brace notation is not a trivial task, designed for people with developed perseverance and attentiveness. <br><br>  Arguing about the task it is easy to come to the conclusion that there is not much difference between the Elves and the Reindeer.  In our formulation, both of these biological forms can be equated to an abstract person who can perform some little understood action.  By and large, it does not even matter what kind of action it is, but, based on the initial conditions, the Deer graze, and the Elves work.  And so and so on the implementation of their personal actions need some time.  Moreover, each individual spends on the action of an individual amount of this precious resource. <br><br>  All code is written using ARC, in XCode 4.3.  This clarification is necessary because, first, XCode 4.3.  learned to see the methods, even if they are described after their use, and secondly, the ARC does not care about the destruction of objects and special dispatching of memory.  Those.  objects not only do not need to be freed, it is simply forbidden by the compiler.  The gain is significant - in the transparency of the code, and in the speed of execution, and, of course, in time spent on debugging. <br><br>  We first describe the corresponding interfaces: <br><pre><code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Persone</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> number; } <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *name; <span class="hljs-comment"><span class="hljs-comment">//   . - (Persone *)execution; @end #import "Common.h" @interface Elf : Persone @end #import "Common.h" @interface Deer : Persone @end</span></span></code> </pre> <br>  As we see.  everything is very simple and does not cause any additional questions. <br><br>  With Santa's interface all the more interesting. <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Common.h"</span></span></span><span class="hljs-meta"> @interface Santa : Persone @property (nonatomic) BOOL isBusy; //  ?  \ . - (Persone *)wakeUp:(NSArray *)group; //. , .    . . ! @end</span></span></code> </pre><br>  According to the condition of the problem, one of the two types of groups can wake up Santa.  But, there may be surprises.  For example, Santa can not sleep, at the moment when the group will be assembled, and accordingly, an understanding of whether the boss can be disturbed is required. <br><br>  In each of the interfaces there is a mysterious file that may cause confusion: <br><br>  #import "Common.h" But with it everything is simple - it describes the value of the constants used in the program, as well as some other header files: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Persone.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Deer.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Elf.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Santa.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Groups.h"</span></span></span><span class="hljs-meta"> #define kAllMessages 1 //    ,      . #define kGroupDeers @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Deer"</span></span></span><span class="hljs-meta"> //    . #define kGroupElfs @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Elf"</span></span></span><span class="hljs-meta"> //    . #define kMontsDeer 12 //      1-12. #define kMontsElf 18 //     . 1-18. #define kMontsSanta 4 //    . #define countElfInGroup 3 //     ,    . #define countDeerInGroup 9 //     ,    .</span></span></code> </pre><br>  There remains the last significant interface, which is intended for the information of persons of the same type in groups: <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Common.h"</span></span></span><span class="hljs-meta"> @interface Groups : NSObject { NSMutableDictionary *groups; //  . } - (Groups *)add:(Persone *)persone; //     . - (NSArray *)ready; //   . @end</span></span></code> </pre><br><br><h4>  <b>Implementation:</b> </h4><br>  It is quite obvious that to solve our problem we need one and only one Santa, one and only one mechanism of forming groups and an arbitrary number of instances of Deer and Elves. <br><br>  Let's start with a simple ... First, create the Deer. <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Common.h"</span></span></span><span class="hljs-meta"> @implementation Deer static int count; @synthesize name; - (id)init { if(count &gt;=9) return nil; //      9. self = [super init]; if (self) { count++; number = count; self.name = kGroupDeers; } return self; }</span></span></code> </pre><br><br>  The initializer is quite stereotypical and does not need any explanation.  The superclass has a name property, which we will use later in the form of a variable containing the key values ‚Äã‚Äãfor the dictionary. <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)eat { <span class="hljs-built_in"><span class="hljs-built_in">dispatch_async</span></span>(dispatch_get_global_queue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), ^{ <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> month = (arc4random() % kMontsDeer) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-meta"><span class="hljs-meta">#if kAllMessages NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%d-      %d "</span></span></span><span class="hljs-meta">, number, month); #endif [NSThread sleepForTimeInterval:month]; #if kAllMessages NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%d-    "</span></span></span><span class="hljs-meta">, number); #endif dispatch_async(dispatch_get_main_queue(), ^{ [[[Groups alloc] init] add:self]; }); }); }</span></span></code> </pre><br><br>  And here it is more interesting.  The eat method starts a separate thread of execution for the current instance of the Deer.  That is, each Deer, and in the future and the Elves, we will live and prosper in separate streams.  Despite the complex bracket construction, in reality, everything is extremely simple here: dispatch_async (dispatch_get_global_queue (0, 0), ^ {});  - puts what is described in brackets into the execution queue.  The argument dispatch_get_global_queue means a global queue.  (0, 0) - the first 0 indicates the priority, by default, Normal, the second 0 does not mean anything at all in the iOS SDK, and is reserved for further development of the technology. <br><br>  Inside the described block we find: NSInteger month = (arc4random ()% kMontsDeer) + 1;  - getting a random number of months of grazing by the Deer.  The range of integers obtained in this formula is from 1 to kMontsDeer.  The following is a delay in the execution of the process - a kind of pasture emulation - [NSThread sleepForTimeInterval: month];  And completing this method is adding to a similar queue but already for the main thread of some code.  This some code is another queue, but already created at the level of the current program.  As we remember, the group dispatcher should have one and only one for the entire application.  In other words - he is singleton.  Therefore, the creation of its instance through the initializer, in fact, will return to us an already existing instance, if it was created by someone earlier.  The add method will simply add the current Stag to the receive queue. <br><pre> <code class="objectivec hljs">- (Persone *)execution { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> eat]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre><br><br>  The latter method only provides the coordination of basic interfaces.  Those.  creates a template execute method. <br><br>  In the same way we create a class for elves. <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Common.h"</span></span></span><span class="hljs-meta"> @implementation Elf static int count; @synthesize name; - (id)init { if(count &gt;=10) return nil; //      10. self = [super init]; if (self) { count++; number = count; self.name = kGroupElfs; } return self; } - (void)work { dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSInteger month = (arc4random() % kMontsElf) + 1; #if kAllMessages NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"   %d .   %d "</span></span></span><span class="hljs-meta">, number, month); #endif [NSThread sleepForTimeInterval:month]; #if kAllMessages NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"  %d "</span></span></span><span class="hljs-meta">, number); #endif dispatch_async(dispatch_get_main_queue(), ^{ [[[Groups alloc] init] add:self]; }); }); } - (Persone *)execution { [self work]; return self; } @end</span></span></code> </pre><br><br><h5>  Divide and win </h5><br>  The task of the Group class is to dispatch and form groups.  The mechanism is quite simple.  Each person is queued for his type, (i.e. Elves to elves, Deer to deers), and then, if the required number of copies is collected in a queue, is removed from there and placed in a buffer specially designed for them - Santa -Claus. <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Common.h"</span></span></span><span class="hljs-meta"> @implementation Groups static Groups *instance; - (id)init { if(instance!=nil) return instance; self = [super init]; if (self) { groups = [NSMutableDictionary dictionary]; instance = self; } return self; } - (Groups *)add:(Persone *)persone { NSMutableArray *queue = [groups objectForKey:persone.name]; //     . if(queue == nil) queue = [NSMutableArray array]; [queue addObject:persone]; //    . [groups setValue:queue forKey:persone.name]; #if kAllMessages NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"  \"</span></span></span><span class="hljs-meta">%@\</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"  %d"</span></span></span><span class="hljs-meta">, persone.name, queue.count); #endif Santa *santa = [[Santa alloc] init]; if(santa.isBusy == NO) [santa wakeUp:[self ready]]; return self; } - (NSArray *)queueElf { NSMutableArray *queue = [groups objectForKey:kGroupElfs]; if(queue.count </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; countElfInGroup) return nil; //     . NSMutableArray *group = [NSMutableArray array]; for (int i=0; i&lt;countElfInGroup; i++) // 3    ... [group addObject:[queue objectAtIndex:i]]; for (id item in group) // ...    . [queue removeObject:item]; [groups setValue:queue forKey:kGroupElfs]; return [group copy]; } - (NSArray *)queueDeer { NSMutableArray *queue = [groups objectForKey:kGroupDeers]; if(queue.count &lt; countDeerInGroup) return nil; //     . NSArray *group = [queue copy]; for (id item in group) //   . [queue removeObject:item]; [groups setValue:queue forKey:kGroupDeers]; return group; } - (NSArray *)ready { NSArray *group = [self queueElf]; if(group!=nil) return group; return [self queueDeer]; }</span></span></span></span></code> </pre><br>  As mentioned earlier, this class is a singleton.  Being written using ARC, its creation seems to be extremely simple.  It is assumed that an instance of this class will be used only within the main thread.  This will prevent the problem when the same instance of the dictionary implementing the queues is accessed from different threads.  Of course, this creates some overhead in terms of execution time, but, they are so insignificant that they can be neglected. <br><br>  The most interesting place of this code is the following section: <br><br><pre> <code class="objectivec hljs">Santa *santa = [[Santa alloc] init]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(santa.isBusy == <span class="hljs-literal"><span class="hljs-literal">NO</span></span>) [santa wakeUp:[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ready]];</code> </pre><br><br>  We, like with the group dispatcher, receive a copy of our Santa, and then we will be him, stuffing the resulting group into his chambers.  No matter what.  For this, it will be Deers or Elves - (NSArray *) ready method answers <br><br>  To my horror, I noticed that in preparing the article I confused the conditions of the problem.  Those.  in my case, all other things being equal, Santa serves elves, not deer.  In addition, I have a maximum number of elves equal to 10, not 9. Both of these faults are easily fixable.  For example, the method changes to the following: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *)ready { <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *group = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> queueDeer]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(group!=<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> group; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> queueElf]; }</code> </pre><br><br>  However, in the future, when it comes to the protocols of work, such an amended condition is assumed. <br><br><h5>  <b>Madrigal</b> </h5><br><br>  And so we got to the final character of our song - Santa: <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Common.h"</span></span></span><span class="hljs-meta"> @implementation Santa static Santa *santa; static int count; BOOL doWork; @synthesize isBusy; static int groupNumber; - (id)init { if(santa!=nil) return santa; self = [super init]; if (self) { santa = self; count++; number = count; NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&gt;&gt;  %d- "</span></span></span><span class="hljs-meta">, number); } return self; } - (void)sleep { NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&gt;&gt;  %d ...."</span></span></span><span class="hljs-meta">, number); } - (Santa *)wakeUp:(NSArray *)group { if(group == nil) return self; NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&gt;&gt;  %d .... "</span></span></span><span class="hljs-meta">, number); [self work:group]; //    . return self; } - (BOOL)isBusy { return doWork; } - (void)work:(NSArray *)group { if(doWork == YES) return; doWork = YES; __block Santa *santa = self; __block NSArray *currentGroup = group; __block NSInteger IDGroup = ++groupNumber; dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSInteger month = (arc4random() % kMontsSanta) + 1; NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&gt;&gt;    %d- .   %d  c  ID %d"</span></span></span><span class="hljs-meta">, number, month, IDGroup); [santa portalIn:currentGroup]; [NSThread sleepForTimeInterval:month]; NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&gt;&gt;  %d   c  ID %d"</span></span></span><span class="hljs-meta">, number, IDGroup); dispatch_async(dispatch_get_main_queue(), ^{ doWork = NO; [[santa portalOut:currentGroup] sleep]; //     . }); }); } - (Persone *)execution { NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Yahoo!!!"</span></span></span><span class="hljs-meta">); return self; } - (Santa *)portalIn:(NSArray *)group { if([[group objectAtIndex:0] isKindOfClass:[Elf class]]) NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&gt;&gt;  %d    "</span></span></span><span class="hljs-meta">, number); if([[group objectAtIndex:0] isKindOfClass:[Deer class]]) NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n\t\t      yp p\n\t\t  p p  y p.\n\t\t y,  p  p p,\n\t\t y  p,    p"</span></span></span><span class="hljs-meta">); return self; } - (Santa *)portalOut:(NSArray *)group { for (Persone *persone in group) [persone execution]; return self; }</span></span></code> </pre><br>  Before moving on to the most difficult part of the code, you need to briefly stop at two methods: <br><br>  entrance door method: <pre> <code class="objectivec hljs">portalIn:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *)group</code> </pre>  and exit door method: <pre> <code class="objectivec hljs">portalOut:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *)group.</code> </pre><br><br>  It would have been possible to do without them, but this was the initial condition of the task - to focus attention on the entrance and exit doors. <br><br>  The execution method only signals that a call has been made to this instance of Santa.  Every time we manipulate Santa, we show his number.  We do this for reasons that the reader is convinced that all actions occur with a single Santa throughout the duration of the action. <br><br>  Method <pre> <code class="objectivec hljs"> wakeUp:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *)group</code> </pre>  admits the group to the emergency rooms and wakes up Santa.  All the main things happen in the work method. <br><br>  First, we check if Santa is busy. <pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(doWork == <span class="hljs-literal"><span class="hljs-literal">YES</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre>  This is a redundant check and can be removed.  But, better we will miss one wake-up call than something goes according to plan.  Then we post the sign ‚Äúbusy‚Äù and lock the entrance doors: <pre> <code class="objectivec hljs">doWork = <span class="hljs-literal"><span class="hljs-literal">YES</span></span>;</code> </pre><br><br>  Next, we need to prepare some variables for use within the threads, background and main: <br><pre> <code class="objectivec hljs">__block Santa *santa = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; __block <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *currentGroup = group; __block <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> IDGroup = ++groupNumber;</code> </pre><br><br>  If this is not done, an exception may be raised to accessing unshared resources.  The above simple manipulation ensures that this does not happen.  It should be noted here that the double underscore is used in the __block keyword.  those.  the _ character is used twice!  Then we create a separate stream for Santa, as we did with Deer and Elves, and release the incoming group to Santa's chambers using the entrance door method: [santa portalIn: currentGroup]; <br><br>  Depending on who came to Santa, he does one of two things - either holding a planning meeting or delivering presents.  When the work is completed, Santa unlocks the door and sends the guests to their former place of work.  All the magic of the task lies in the exit door method.  As is known, ‚ÄúIteration is peculiar to man, recursion is divine.‚Äù  - L. Peter Deutsch.  Since this method is called within the main thread, it can safely recursively call the execution of a new task by person.  An elf or a deer, once born, will perform its duties indefinitely until it is stopped by a direct shot to the head from the <a href="http%25253A%25252F%25252Fru.wikipedia.org%25252Fwiki%25252FSIGABRT%2526ei%253DW_WcT4OZFdCN-wben8SADw%2526usg%253DAFQjCNHxvUa2vQQL7hN6p2quXMK5MgcYOQ%2526sig2%253DskT3sMP8al8it7ViJYwvXQ">SIGABRT</a> . <br><br><h4>  <b>And now it's time for the song.</b> </h4><br>  In a convenient place you need to place the creation code of our people.  I have it located in - (void) viewDidLoad <br><h5>  Verse 1. </h5><br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; i++) [[[Deer alloc] init] execution]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>; i++) [[[Elf alloc] init] execution]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>; i++) [[[Santa alloc] init] execution];</code> </pre><br>  But since we have already eaten the dog to create threads, why not wrap it all in a separate thread? <br><br><h5>  Verse 2. </h5><br><pre> <code class="objectivec hljs"> <span class="hljs-built_in"><span class="hljs-built_in">dispatch_async</span></span>(dispatch_get_global_queue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), ^{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>; i++) [[[Deer alloc] init] execution]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>; i++) [[[Elf alloc] init] execution]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>; i++) [[[Santa alloc] init] execution]; });</code> </pre><br>  It is quite obvious that since each person lives in a separate stream, then the sequence of creating each person will be determined only by chance.  What to do?  Especially for this, there is a very elegant way to indicate the flow creation sequence: <br><br><h5>  Verse 3. </h5><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">dispatch_async</span></span>(dispatch_get_global_queue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), ^{ dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, dispatch_get_global_queue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), ^{<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">30</span></span>; i++) [[[Deer alloc] init] execution];}); dispatch_group_async(group, dispatch_get_global_queue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), ^{<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">30</span></span>; i++) [[[Elf alloc] init] execution];}); dispatch_group_notify(group, dispatch_get_global_queue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), ^{<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>; i++) [[[Santa alloc] init] execution];}); });</code> </pre><br><br>  In the first background thread, a group is created within which the creation of the Reindeer and the Elves begins.  And when they are completed, the thread starts to create Santa. <br><br>  If in the first cases the <a href="https://docs.google.com/open%3Fid%3D0By7y4qbZwE__Uzlnd3ItYkJzUUk">protocol is approximately like this:</a> <br> <code>&gt;&gt;  1-  <br> 1-      6  <br> 2-      7  <br> 3-      9  <br> 4-      4  <br> 5-      3  <br> Yahoo!!! <br> 7-      5  <br> 9-      2  <br> Yahoo!!! <br> Yahoo!!! <br> Yahoo!!! <br> 6-      8  <br>    3 .   15  <br>    5 .   17  <br>    4 .   10  <br>    2 .   16  <br> 8-      3  <br></code> <br><br>  In the latter case, <a href="https%253A%252F%252Fdocs.google.com%252Fopen%253Fid%253D0By7y4qbZwE__STczY1U4U29CNGs">it will be something like this:</a> <br><br> <code>1-      7  <br> 4-      5  <br> 3-      12  <br> 2-      7  <br> 5-      3  <br> 6-      4  <br> 7-      7  <br> 8-      11  <br> 9-      6  <br>    1 .   11  <br>    2 .   2  <br>    3 .   16  <br>    4 .   4  <br>    5 .   16  <br>    6 .   1  <br>    7 .   2  <br>    8 .   14  <br>    9 .   15  <br>    10 .   3  <br> &gt;&gt;  1-  <br> Yahoo!!! <br> Yahoo!!! <br> Yahoo!!! <br> Yahoo!!! <br> Yahoo!!! <br> Yahoo!!! <br> Yahoo!!! <br> Yahoo!!! <br> Yahoo!!! <br> Yahoo!!! <br>   6  <br>   "Elf"  1 <br>   2  <br>   "Elf"  2 <br> <br></code> <br><br>  The study of the logs of this application is a very interesting task.  But since they are infinitely long, I will give only references, for those who want to delve into the sequence of actions, or to offer my own more optimal way to solve the problem.  Below I also <a href="https%253A%252F%252Fdocs.google.com%252Fopen%253Fid%253D0By7y4qbZwE__eU9CVXlaVXMyY2s">provide a link to the source code of the application.</a> <br><img src="http://habrastorage.org/storage2/723/bd2/48e/723bd248ecafa8546605ad34a51edf80.jpg"><br>  What could be interesting in the logs?  The fact is that the different values ‚Äã‚Äãof the initial constants provide for completely different behavior of the characters.  For example, during the initial debugging, I found that Santa could never start delivering presents, as he would be constantly busy with the routine of meetings.  After a long and unsuccessful search for errors in the code, it was found that everything fits within the standard statistical model: if the duration of the task at the Elf is too short (3-4) months, then groups will be formed so often that the Reindeer will wait indefinitely in queues (recall that the problem was solved with the inversion of the condition). <br><br>  What is the practical value of this exercise in terms of logistics?  Suppose you are a project manager for <a href="http%253A%252F%252Fru.wikipedia.org%252Fwiki%252FScrum%26sa%3DD%26sntz%3D1%26usg%3DAFQjCNGZNI6v7aiQ_AUUtmoOBdKqx_-l4A">Scrum</a> .  Since you have to hold daily meetings, sometimes turning into plenary sessions of the USSR Supreme Soviet, it may be that the Elf will not have time to develop, and the project will go on to the stage of constant <a href="http%253A%252F%252Fru.wikipedia.org%252Fwiki%252F%2525D0%2525A6%2525D0%2525B5%2525D0%2525B9%2525D1%252582%2525D0%2525BD%2525D0%2525BE%2525D1%252582%26sa%3DD%26sntz%3D1%26usg%3DAFQjCNG7MYWBeRMGv4vgWSN1ZERJ4SiMjQ">time pressure</a> .  A similar situation can occur in the team leader lead server-side developer developer client clients, with the only difference that the team lead, as a rule, ceases to perform its immediate duties (sleep (sleep);), and is forced to endlessly rake the code of Reindeer or malicious Elves  And if you break away from the sphere of IT, then the coefficients of the task of Santa, are fundamental in the process of loading / unloading / storing goods.  In general, it is easy enough to find analogues in real life. <br><br><h4>  <b>Conclusion:</b> </h4><br>  In the above code, there are some not quite obvious techniques that need to be said separately. <br><h5>  one) </h5><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> *group = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> array]; [skip] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [group <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>];</code> </pre><br><br>  Programmers who still work without ARC will be horrified by such code.  And, most likely, they will use something like [[NSArray arrayWithArray: group] autorelise];  for the object to collapse to the minimum functionality.  However, in ARC, this need is eliminated, and the code becomes more transparent. <br><h5>  2) </h5><br><pre> <code class="objectivec hljs">- (Santa *)portalOut:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *)group { [skip] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; }</code> </pre><br><br>  The method returning the current object allows reducing the listing due to the use of the objective-c prisobochnoy record: [self portalOut: currentGroup] sleep];  For fans of functional languages ‚Äã‚Äãand those who like extensible C # methods (which are actively used in LINQ), this is like a balm for the soul ... Of course, for debugging purposes, it makes sense to split the method call into two lines. <br><br><h5>  3) </h5><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#if kAllMessages NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"   %d .   %d "</span></span></span><span class="hljs-meta">, number, month); #endif</span></span></code> </pre><br><br>  The kAllMessages precompilation directive is contained in the Common.h file. If you uncomment it, you will see all the actions performed by the characters, as in the above logs.  By default, only Santa's actions are displayed in the console.  I did not dwell on the console output in the article, since, as a rule, this is the first thing with which an acquaintance begins when studying objective-c. <br><br><h4>  <b>Categorical imperative:</b> </h4><br>  It took several times more time to write an article than to write an application and debug it.  If you are not yet using an asynchronous manager, it's time to test it and evaluate the ease of implementation.  And let him throw a stone at me who thinks that Apple was able to solve this problem without reaching the pinnacle of grace for multi-threaded applications. <br><br><h4>  <b>References:</b> </h4><br>  <a href="https://docs.google.com/open%3Fid%3D0By7y4qbZwE__eU9CVXlaVXMyY2s">Application source code (iOS SDK 5, XCode 4.3).</a> <br>  <a href="https://docs.google.com/open%3Fid%3D0By7y4qbZwE__Uzlnd3ItYkJzUUk">Application log without thread execution groups.</a> <br>  <a href="https://docs.google.com/open%3Fid%3D0By7y4qbZwE__STczY1U4U29CNGs">Application log with a thread execution group.</a> <br>  <a href="https://docs.google.com/open%3Fid%3D0By7y4qbZwE__YWxBVWh5clIwRE0">An abbreviated log of Santa's work in a thread group.</a> <br><br><h4>  <b>Summary:</b> </h4><br>  The article describes the mechanism for creating a multi-threaded application in the language of objective-C in relation to iOS SDK 3+.  As an example, the task of Santa from the field of logistics was given.  Source code demonstrates the use of asynchronous dispatcher. <pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">dispatch_async</span></span>,</code> </pre>  queues of the main application thread <pre> <code class="objectivec hljs">dispatch_get_main_queue()</code> </pre>  the background flow of the application <pre> <code class="objectivec hljs"> dispatch_get_global_queue</code> </pre>  and delay interval <pre> <code class="objectivec hljs"> [<span class="hljs-built_in"><span class="hljs-built_in">NSThread</span></span> sleepForTimeInterval:month];</code> </pre>  .  To create additional queues, linear arrays and a dynamic dictionary provided by Objective-C were used. <br><br>  <b>UPD:</b> Updated the link to the source code. </div><p>Source: <a href="https://habr.com/ru/post/143080/">https://habr.com/ru/post/143080/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../143075/index.html">Siri on the protection of a stolen iPhone</a></li>
<li><a href="../143076/index.html">UK court closed access to The Pirate Bay</a></li>
<li><a href="../143077/index.html">My first Android project, my first Android customer</a></li>
<li><a href="../143078/index.html">Symantec: religious sites have more viruses than porn sites</a></li>
<li><a href="../143079/index.html">What the .git directory hides from us</a></li>
<li><a href="../143081/index.html">Do your children aged 3 to 12 have a tablet computer?</a></li>
<li><a href="../143082/index.html">Standalone Last.fm scrobbler</a></li>
<li><a href="../143083/index.html">Save memory with UKSM</a></li>
<li><a href="../143085/index.html">Free library for integration of 1C and Asterisk</a></li>
<li><a href="../143091/index.html">Webmoney personal certificate renewal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>