<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Blockchain without intermediaries: how we sent securities to a distributed registry</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All economic activity is historically built on intermediaries. Any, even simple transaction between the two parties is accompanied by the involvement ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Blockchain without intermediaries: how we sent securities to a distributed registry</h1><div class="post__text post__text-html js-mediator-article">  All economic activity is historically built on intermediaries.  Any, even simple transaction between the two parties is accompanied by the involvement of various intermediaries - banks, stock exchanges, clearing houses, etc.  Excluding the middlemen would probably make the interaction more efficient.  So why not try to build a new, decentralized infrastructure based on the blockchain, where the participants in the transaction can work directly?  In this post, we will talk about how we started the path to such an infrastructure: we developed blockchain transactions in our country and, as a result, carried out repos - borrowing money to be provided with securities. <br><br><img src="https://habrastorage.org/webt/5y/08/en/5y08enodezvkfd1qngslkh-pl4y.png"><br><a name="habracut"></a><br><h2>  Short Term Bonds </h2><br>  Our first over-the-counter financial transaction on the blockchain was the issue of a short-term bond of the mobile operator MTS with the participation of the National Settlement Depository (NSD).  This is a kind of "central bank" of all depositories.  Depositaries are infrastructure intermediaries that keep records of holders of securities and their issuance. <br><br>  In that transaction, MTS, by calling the function of the smart contract, recorded in the blockchain the will of the sale of securities to Sberbank, and he confirmed in the blockchain agreement with the terms of the transaction.  The counter-orders signed by both parties were received by the NSD node that executed them in their accounting systems.  In addition, the blockchain displayed the accounts of participants in the transaction in securities and money. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In that project, we chose the open source platform <i>Hyperledger Fabric 1.1</i> , designed to create closed corporate blockchain solutions.  Public blockchains are not suitable here, because we need to ensure the privacy of data.  We encountered such limitations in the factoring pilot of Sberbank with M.Video, which was implemented on the Ethereum blockchain.  In contrast, Hyperledger Fabric allows you to place all participants in a transaction on a dedicated channel, where they can exchange any necessary information and process it with full-featured smart contracts. <br><br>  The source code for the MTS bond issue project was made publicly available on GitHub.  Even without going into the algorithm of work, it can be understood that in the life cycle of the transaction, the blockchain was given the rather modest role of transport of clearing orders.  On the other hand, on the basis of these instructions, the balance of accounts was changing - so from the point of view of business logic, this was more interesting than a simple electronic document management service. <br><br>  The main advantage of the solution was versatility.  The ‚Äútwo counterparties and registrar‚Äù scheme covers almost any transaction on the over-the-counter market, and with minor changes - most commercial transactions in general. <br><br><h2>  REPO 1.0 </h2><br>  In the new blockchain project we decided to show how to implement a repurchase agreement in the decentralized system to borrow money against securities.  Usually, these and other transactions in the over-the-counter market go through intermediaries - depository, clearing houses, brokers. <br><br>  In this project we made a repo transaction between Sberbank and a foreign partner.  It already used Hyperledger Fabric version 1.2.  Compared to MTS bonds, we had two differences: <br><br><ul><li>  Only two participants in the transaction were connected to the blockchain, whose depositories - Euroclear and Clearstream - received all instructions via traditional data transmission channels from the back offices of Sberbank and its counterparty. <br></li><li>  In the smart contract, we implemented complex business logic: daily the blockchain was loaded with quotes of a security that acted as a loan security, and a smart contract calculated the need for the amount of early repayment, taking into account the changed value of collateral, discount, calendar of the stock exchanges and other parameters.  Such P2P synchronization of the calculation algorithms between the participants cannot be obtained without a distributed registry.  It is much more convenient than the independent calculation of obligations and amounts by each side - no time consuming reconciliations, no evidence. <br></li></ul><br>  Between contractors organized a chat and document flow within the channel.  Data on them was stored in the blockchain.  After each change in the distributed registry, channel participants received an email alert. <br><br>  "REPO 1.0" we have worked with the legal side.  With the help of one large law firm, they analyzed the cases of the High Court of London.  In addition, the EDS of the bank and its counterparty used different cryptographic algorithms. <br><br><h3>  How does REPO 1.0 work? </h3><br>  Each transaction participant has its own blockchain node.  All nodes are connected to each other in a P2P network.  Suppose you need to make a deal.  We are deploying a smart contract between the parties to the transaction, which fully describes the financial instrument. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f42/e38/b7e/f42e38b7e23eac1217952790f217a4e9.png"><br><br>  After creating a contract on our part, the trader signs it.  The client also reviews and signs the contract.  Then the signatures are reviewed and verified.  In this case, the transaction was carried out according to English law, data on EDS were entered into the GMRA document.  For signing by the client, it is necessary to verify that an authorized person is present in the signature certificate.  Finally, the client accepts the contract and agrees to all the conditions.  You can attach any number of documents to the signed contract. <br><br>  After that, the contract receives the status of "in work".  The contract ‚Äúin work‚Äù is automatically recalculated when new market prices are uploaded.  If there is a security in the contract, the market price is taken, the Loan-To-Value (LTV) is recalculated - the ratio of the loan amount to the value of the collateral in securities.  LTV is one of the key terms in a repo transaction, its meaning is stated in the contract.  The stock price has increased dramatically - and LTV is becoming less than what is specified in the GMRA (when it comes to English law).  Accordingly, the bank returns securities to the client (as one of the options), since, taking into account new prices, it turns out that the bank holds higher collateral. <br><br>  But if the LTV becomes larger, then the program allows you to print a collateral notice to the client about the need to make additional collateral (shares or money) so that the LTV value returns to the initial one.  Previously, collateral notice could only be sent by mail, separate documents were created for this, and during the creation of these documents the LTV could change again.  Now we see the same calculations online with a client, we can easily interact. <br><br>  In addition, the program every day fixes the price of the repurchase of securities, taking into account interest.  If a client disagrees with the market price upload, he watches the full log of recalculations - what happened, what happened, what price was loaded, where it came from.  And then begins the discussion in the chat. <br><br><h2>  REPO 2.0 </h2><br>  We wanted our repo on the blockchain to initiate the movement of real assets based on its internal logic.  But in REPO 1.0, due to organizational difficulties with connecting Western depositories, we have not yet been able to achieve this.  So we started the new pilot REPO 2.0.  He had two goals: <br><br><ul><li>  The transaction should take place with the participation of both parties and the depositary, to maximize the use of the infrastructure of the MTS bond project. <br></li><li>  The blockchain must be empowered to revalue collateral and set a margin call, which could be automatically executed by a depository connected to a distributed network. <br></li></ul><br>  NSD immediately wanted to join the project.  In order to land a deal initiated in the blockchain on the conservative field of federal laws regulating the domestic financial market, we worked with lawyers to a five-page additional agreement to the electronic document contract.  It was signed by all participants in the transaction and NSD. <br><br>  NSD made a clearing house in this transaction.  He carried out all orders on the movement of funds and securities.  This transaction was concluded under Russian law. <br><br>  The client has accepted the contract by electronic signature.  Then the contract with his signature accepted Sberbank - checked the compliance of all parameters with the required values ‚Äã‚Äãand the powers of the person who accepted from the client.  After that, the contract went to work.  NSD loaded market data, the smart contract produced recalculations. <br><br><h3>  How does REPO 2.0 work? </h3><br>  We used the <a href="https://github.com/olegabu/fabric-starter">Fabric Starter</a> solution to deploy the network and the interaction of the client interface with the cheyne code.  Instead of the standard grpc interface for the HLF, it provides the REST API, which in our case has significantly reduced the complexity of the integration. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/07a/86a/997/07a86a997c7017a122b03aad7995f6ad.png"><br><br>  The network went up as follows.  Each of the three parties, after the pre-installation on the Docker server, launched the Fabric Starter, which created the containers with the node components.  These components included an external peer for interaction with other organizations and a REST API service through which the node interacted with the client application.  When Starter was launched, the blockchain-network configuration was also set up and a private channel was created, in which the chein code with endorsement-policy was installed.  In our case, each transaction must be signed by all three participants. <br><br>  Docker Swarm was used to organize the communication of the servers of the participants during the testing phase, however, they switched to DNS for security reasons.  The platform itself is responsible for transporting messages, data is transmitted via the Internet with TLS encryption. <br><br><h2>  The technical side of the issue </h2><br>  The process of developing a distributed application in HLF begins quite traditionally - with data structures and a cheyne code (in fact, a set of stored procedures), the call of which leads to the preservation, modification or reading of these structures from the legger.  The platform allows the use of various programming languages ‚Äã‚Äãfor the development of chain codes and DBMS for local storage.  We prefer Go and CouchDB respectively. <br><br>  The central entity for repos in our data model is the contract itself and its subsidiary obligations.  They were created for each of the two pilots, as well as for margin calls.  This architecture was a step forward compared with the MTS bond model, which was based on the entity ‚ÄúInstruction‚Äù.  Independent objects were also created for securities, which, thus, were partially tokenized.  But we decided to postpone the development of the experiment with account management and virtual tokenization of money until one of the following versions of the solution. <br><br>  The main functions of our solution: <br><br><ul><li>  Create a contract. <br></li><li>  Sign a contract with your EDS confirming acceptance of the terms of the contract. <br></li><li>  Download market prices and start recalculation of collateral value.  Its deviation from a given threshold caused the creation of a new margin call call. <br></li><li>  Reflect the status of performance of the obligation. <br></li></ul><br>  On the technical side, the revaluation procedure is most interesting here.  Let us examine it in more detail. <br><br>  According to the business process, the procedure should be launched once a day, after Oracle (in the REPO 2.0 pilot, NSD performed its role) updated quotations of securities were loaded into the system. <br><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *CIBContract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recalculationData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub shim.ChaincodeStubInterface, loadData *loadDataType, curDay </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span> {...}</code> </pre> <br>  The main procedure cycle runs on all securities for which quotes have been updated. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, securities := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> loadData.Securities {...}</code> </pre> <br>  Further several checks are carried out.  For example, if the exchange, which received market data, is today a day off, then recalculation should not occur. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t.checkHoliday(stub, contract.Settings.Calendars) == <span class="hljs-string"><span class="hljs-string">"yes"</span></span> { hisYes := historyType{curDay, <span class="hljs-string"><span class="hljs-string">"LoadData. Calendar"</span></span>, <span class="hljs-string"><span class="hljs-string">"System"</span></span>, <span class="hljs-string"><span class="hljs-string">"LoadData. Today is holiday ! No load market data to contract !"</span></span>} ... contract.History = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(contract.History, hisYes) ‚Ä¶ err = stub.PutState(contrID, contractJSONasBytes) }</code> </pre><br>  To calculate the updated price of the bonds, the accrued coupon yield (ACY) is added to the loaded net price.  The pilot implemented support for the 30/360 scheme for calculating ACI. <br><br><pre> <code class="go hljs">priceIzm = <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(securities.Price + <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(securities.CouponRate)*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Year()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Year()))*<span class="hljs-number"><span class="hljs-number">360</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Month()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Month()))*<span class="hljs-number"><span class="hljs-number">30</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Day()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Day())))*<span class="hljs-number"><span class="hljs-number">100</span></span>/<span class="hljs-number"><span class="hljs-number">360</span></span>/<span class="hljs-number"><span class="hljs-number">100</span></span>) curCurrVal = priceIzm</code> </pre><br>  If the currency of the transaction differs from the currency in which the security is listed, the exchange conversion is carried out. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> contract.GeneralTerms.PurchasePrice.Currency != securities.Currency { curCurrName = securities.Currency + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + contract.GeneralTerms.PurchasePrice.Currency               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, currency := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> loadData.Currencies {              <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currency.Name == curCurrName {                           curCurrVal = priceIzm * currency.Value } } }</code> </pre><br>  Now we need to calculate the LTV.  Keep the old value of the coefficient for the history. <br><br><pre> <code class="go hljs">oldCurLTV := contract.MarginingTerms.CurrentLTV</code> </pre> <br>  It is necessary to take into account the margin calls made during the life of the transaction.  Requirements can come from both sides, and in two forms: <br><br><ul><li>  Securities.  The borrower makes additional collateral in the event of a fall in the market price of collateral.  The lender returns part of the security in case of a price increase. <br></li><li>  With money.  The borrower repays part of the loan ahead of schedule, which is no longer covered by the depreciating collateral.  The lender increases the loan amount in response to an increase in the value of the collateral. <br></li></ul><br>  In the first case, the number of securities in the collateral is simply updated.  And in the case of depositing money on them, it is also necessary to accrue the yield indicated in the additional terms of the transaction. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, addCollateral := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> contract.MarginingTerms.AddCollateral { currSumCollateral := addCollateral.Sum + (addCollateral.Sum*contract.MarginingTerms.RateOnCashMargin*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(deltaColDate) / <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.Basis))/<span class="hljs-number"><span class="hljs-number">100</span></span> ... allSumCollateral = allSumCollateral + currSumCollateral ... ht := historyType{curDay, System<span class="hljs-string"><span class="hljs-string">", "</span></span>LoadData. Recalculation data(addCollateral) Contract <span class="hljs-string"><span class="hljs-string">" + contrID + "</span></span> - currSumCollateral: <span class="hljs-string"><span class="hljs-string">" + strconv.FormatFloat(float64(currSumCollateral), 'f', 2, 64) ... }        ... contract.History = append(contract.History, ht) }</span></span></code> </pre> <br>  We calculate the total amount of the repurchase - in fact, it is the value of the loan with interest, which we need to return. <br><br><pre> <code class="go hljs">rePurchasePriceCur := contract.GeneralTerms.PurchasePrice.Sum + (contract.GeneralTerms.PurchasePrice.Sum*contract.GeneralTerms.RepoRate*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(deltaSigningDate)/<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.Basis))/<span class="hljs-number"><span class="hljs-number">100</span></span></code> </pre><br>  Now we calculate the LTV coefficient.  To do this, we deduct the collateral in money paid from the buy-out price and divide the resulting value by the total value of the securities in the security.  The amounts that the lender paid come with a ‚Äú-‚Äù sign and will be added to the redemption price. <br><br><pre> <code class="go hljs">contract.MarginingTerms.CurrentLTV = (rePurchasePriceCur - allSumCollateral) * <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) / (<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.GeneralTerms.PurchasedSecurities.Quantity) * curCurrVal)</code> </pre><br>  Finally we count the triggers in the contract.  The same procedure will create objects for margin call calls if the LTV value deviates from the specified corridor. <br><br><pre> <code class="go hljs">contract = t.checkTriggerEvents(stub, <span class="hljs-string"><span class="hljs-string">"LoadData"</span></span>, contract, curDay, securities)</code> </pre><br>  And write information to the history for display on the UI. <br><br><pre> <code class="go hljs">ht := historyType{curDay, <span class="hljs-string"><span class="hljs-string">"System"</span></span>, <span class="hljs-string"><span class="hljs-string">"LoadData. Recalculation data(change curLTV, ADTV) Contract "</span></span> + contrID + <span class="hljs-string"><span class="hljs-string">" - oldCurLTV: "</span></span> + strconv.FormatFloat(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(oldCurLTV), <span class="hljs-string"><span class="hljs-string">'f'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>) + <span class="hljs-string"><span class="hljs-string">", newCurLTV: "</span></span> + strconv.FormatFloat(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.CurrentLTV), <span class="hljs-string"><span class="hljs-string">'f'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>)...} contract.History = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(contract.History, ht)</code> </pre> <br><h2>  Let's sum up </h2><br>  Such a scheme can work not only with securities and contracts, but also in other scenarios.  For example, with the supply of electricity, where there are different rates, different connections at different times.  Or with factoring - lending to suppliers on signals of shipment of goods.  In economics, there are a lot of yuzkeys, when each uses its own data sources, which have to be verified. <br><br>  Our goal is to create a network that connects banks with each other and their clients across the country, and using smart contracts to describe in it contracts not of a crypto, but of a traditional economy, financial instruments.  Such a network will be stable, open, and, as it should be in a P2P network, no one will have a special status here. </div><p>Source: <a href="https://habr.com/ru/post/442692/">https://habr.com/ru/post/442692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442680/index.html">Sensory replacement technologies will allow you to see the world with the help of sounds: how the neuroplasticity of the human brain works</a></li>
<li><a href="../442682/index.html">What to collect and how to build a C ++ project</a></li>
<li><a href="../442686/index.html">DataPower Training Course</a></li>
<li><a href="../442688/index.html">Is data analysis on Scala a harsh necessity or a pleasant opportunity?</a></li>
<li><a href="../442690/index.html">Moon mission "Bereshit" - selfie against the backdrop of the Earth</a></li>
<li><a href="../442694/index.html">One of the streaming giants launched in India and attracted a million users in a week.</a></li>
<li><a href="../442696/index.html">S for Security: Internet Security of Things and reports on InoThings ++ 2019</a></li>
<li><a href="../442698/index.html">Moscow Metro application for Windows Store</a></li>
<li><a href="../442700/index.html">Should I engage in mobile solar power?</a></li>
<li><a href="../442704/index.html">Design, development and testing cycles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>