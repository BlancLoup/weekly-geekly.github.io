<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>2000 hours alone, or as an RSS reader was made / I am a robocop</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, 

 I'm going to share with you the technical side of how I made a new web rss reader in 16 weeks, and I almost lost my mind. 
 Departing from a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>2000 hours alone, or as an RSS reader was made / I am a robocop</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/1e1/86e/141/1e186e14126c25e197967e7880c49c1e.jpg" alt="I. Am. Robocop." align="left">  Hello, <br><br>  I'm going to share with you the technical side of how I made a new web rss reader in 16 weeks, and I almost lost my mind. <br>  Departing from a long history, we will assume that everything began in February of this year, when David and I ( <a href="https://habrahabr.ru/users/dmiloshev/" class="user_link">dmiloshev</a> , UI-designer) decided to make a prototype of our creation together. <br>  ‚ÄúAlone‚Äù - because there were no scams, meetings, ‚Äúcollective intelligence‚Äù, and the whole technical part was done by myself. <br><br>  If I were asked to describe the whole article in one sentence, it would have turned out: <br>  No-SQL, mongodb, node.js, my brain, Evented I / O, queues, outputs, git, nginx, memcached, Google Reader, Atom, TTL, PHP, ZF, jQuery, conclusions. <br><a name="habracut"></a><br><h4>  I. Technology </h4><br>  <strong>1. PHP / ZendFramework + something else</strong> <br>  All I had from the very beginning is a small frame that makes working with zf a little more convenient.  It contains Dependency Injection, Table Data Gateway, Transfer Object, more convenient work with configs, configured by Phing with already assigned tasks for almost all occasions.  In general, working with this is all very nice. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Architecturally php application consists of the following layers: <br><ol><li>  Routing / Controller / View - clear .. </li><li>  Service - here ACL, validation, caching, logging.  You can safely tie the REST to it and there will be an excellent API. </li><li>  Gateway - the body of business logic.  Each entity in the system has its own gateway.  Absolutely abstracted from the database. </li><li>  Mapper - here, in fact, direct work with the base. </li></ol>  A few more points that I tried to remember when designing: <br><ul><li>  <a href="http://en.wikipedia.org/wiki/KISS_principle">Kiss</a> </li><li>  Without bicycles </li><li>  Any logical part of the system should be able to scale horizontally. </li><li>  All procedures dealing with external sources should be performed in the background and not freeze the user interface. </li><li>  Any high-load should rest on the queue, processor power and timeouts, and not on the number of processes or open connections </li><li>  Any data can be recovered. </li><li>  You need to log everything, not just errors </li><li>  "It can be cached" </li><li>  David: "It is necessary that this plate was 1 pixel to the left .." =) </li></ul><br>  <strong>2. nginx</strong> no comment <br><br>  <strong>3. git</strong> Once made it clear that I was not as smart as I thought. <br><br>  <strong>4. Mongodb</strong> <br>  Previously, we used it for production in another project, but very carefully, so we could not test it in full.  Recently, the No-SQL, sharding, map-reduce and No-SPOF mods have been particularly strongly developed.  I decided it was time to climb out of my children's pants.  At the very least, it diluted the general routine very much and shook me slightly. <br>  The guys' documentation is very detailed, so it was possible to understand the full depth of the mongodb in the first two weeks.  I had to slightly turn my brain inside out after years of working with relational databases.  But all the nontrivial tasks could be solved independently, without resorting to asking questions on the forums. <br>  Slightly afraid of launching it on production.  To keep abreast of possible problems, I regularly read groups, study issues that other people face. <br>  At the moment, it is configured as a master-master, which is not fully supported, but in our case it should work as it should.  In the future we will shardit, and it will definitely be easier than with the same mysql. <br><br>  <strong>5. Memcached</strong> <br>  There is nothing to say.  Simple as a door.  Is that, in the future I want to try it on UDP ... just for fun. <br><br>  <strong>6. Memcacheq</strong> <br>  There are a lot of alternatives to this today, but I can say that he showed himself very well at production in the previous project. <br>  And it's nice that it does not need a special driver - it works on top of memcached (it helped in the next paragraph). <br><br>  <strong>7. node.js</strong> <br>  This is probably the most interesting thing that happened to me during these four months.  Server Evented I / O is very exciting, even more than the <a href="http://www.youtube.com/watch%3Fv%3D0NPOlaIoeJY">differential</a> .  Immediately I wanted to rewrite the whole php to ruby.  These are my dreams. <br>  The fact is that I discovered it quite recently and quite by accident.  After that, quite a lot of things fell into place, both in the system itself and in my head.  I had to rewrite quite a lot, but the result is very pleasing to the soul, and I hope it will please future users. <br>  I smoked <a href="http://wiki.github.com/ry/node/modules">this page</a> before the filter, at the moment I use: mongoose, kiwi, step, memcache, streamlogger, hashlib, consolelog, eyes, daemon <br>  I wrote jsonsocket from my libraries, which, in my opinion, speaks for itself.  Hands do not reach it github.  And now I dream of making bsonsocket out of it.  Of course, I had to write things to work with queues, and a layer to work with the Gateway layer in php (more on that later). <br>  I also added the <a href="http://prowl.weks.net/">prowl</a> , now the background sends me a push message to the phone random quotes from the tower once an hour (at the same time, small statistics in the form of memory usage, etc.) <br>  Many libraries (modules) are very raw, so sometimes you had to edit your hands right in someone else‚Äôs code (there is no time to do patches).  And dear gentlemen node.js for backward-compatibility, so you can often find simply not working libraries. <br><br>  <strong>8. jQuery</strong> <br>  For me, this is almost a synonym for client-side javascript. <br>  Used plugins: blockUI, validate, form, tooltip, hotkeys, easing, scrollTo, text-overflow and a couple of smaller ones. <br><br><h4>  Ii.  Development </h4><br>  I will not delve into the specifics of the service itself, technically, it is almost <a href="http://reader.google.com/">Google Reader</a> (GR). <br>  While David drove the gray squares around Photoshop, thinking about business logic, I started with basic modeling, after which I immediately switched to the feed download system. <br><br>  <strong>1. Feed Pull</strong> <br><br>  It would seem that everything is simple here - we are pulling the address, pumping out xml, parsing, writing to the database.  But there are nuances. <ul><li>  Each feed must be uniquely identified in order to be able to save it in the system. </li><li>  Also, each entry must be identified to avoid duplicates. </li><li>  Support for things like if-modified-since and etag </li><li>  Redirect processing </li><li>  Different versions of RSS / Atom </li><li>  Extensions to various services, for example gr: date-published </li><li>  HTML inside each post should be cleaned, but not completely, leaving good tags, filtering all kinds of heresy </li><li>  Searching and processing the icon was not the most pleasant thing ... for example, the livejournal does not give the content-type, you have to use magic.mime </li><li>  The specification, apparently, very few people read, for this xml may not be valid, or NOT valid. </li></ul>  <strong>Findings:</strong> <br>  External sources are very different, many just spat on the standards.  And they can not be trusted - content validation should be as strict as when interacting with the user. <br>  The perfect code did not work.  He was overgrown with many conditions and exceptions. <br>  Each item took a lot of time.  More than it might seem at first glance. <br><br>  <strong>2. Update</strong> <br><br>  Now it would be desirable, that all existing flows were updated automatically.  Moreover, it is desirable to take into account the TTL (update rate) of each individual stream.  And I would also like to smear this TTL by the time of day.  I did not rely on the protocol, because according to my research, either it does not exist at all or it does not correspond to reality.  One way or another, its not enough. <br><br>  I started thinking about my own system for determining the frequency of updating the streams, and this is what happened: <ul><li>  TTL - average time distance in seconds between entries in the stream for an hour (minimum 2 minutes, maximum 1 hour) </li><li>  Each stream has a list of average TTL for each of 24 hours in the last 10 days. </li><li>  Based on actual data for the last 10 days, a forecast is generated for the next day, which represents the average TTL values ‚Äã‚Äãfor each hour. </li><li>  Each time a stream is updated, the system recalculates its average actual TTL for the current hour (0-23) </li></ul> So, let's say that the system updates a stream at lunchtime every 2 minutes, it needs to do the appropriate updates regularly during this period of time for 10 days.  Up to this point, the system will smoothly adapt and update it more and more often.  And, for example, at night, this stream will be updated once an hour. <br><br>  Actually, the update procedure itself is the previously described Feed Pull, which, like BE, is the same as updating. <br>  And here we smoothly understand that I would like to pull all this onto the line.  But I will tell you about their organization a little later. <br><br>  By the way, in plans to fasten <a href="http://code.google.com/p/pubsubhubbub/">PubSub</a> , and also, to launch the hub. <br><br>  <strong>3. Discovery</strong> <br><br>  Clearly, the list of skills of a convenient rss reader should include searching for rss / atom feeds on any html page.  When a user simply drives in the address of the site (for example, <a href="http://www.pravda.ru/">www.pravda.ru</a> ), the system should go and search there, in fact, for the feeds to which it can be subscribed. <br><br>  But this procedure is complicated by the fact that such things cannot be done directly in the user's request, since this is not at all the task of the web server ‚Äî it must be done asynchronously.  At the user's request, we first check directly whether such a stream exists in the database, then we look into the discovery cache (which lives 2 hours), and if we did not find anything, then we put this case in a queue and wait for a maximum of 5 seconds (about Exactly wait, I'll tell you later).  If during this time the task did not have time to complete, we complete the script, returning json in the style of {wait: true}.  After that, after some timeout, the client-side makes the same request to the server.  As soon as the task is completed on the background, its result will be in the discovery cache. <br><br>  Several nuances associated with this procedure: <ul><li>  Different encodings - sometimes the encoding is not specified either in the headers or in the header ... you have to define it byte by byte (which does not always work) </li><li>  There can be two identical feeds on one page, one RSS is another Atom - in such a situation you need to choose one of them </li><li>  You need to additionally request each of the feeds in order to make sure that it works, and take its true title and description. </li><li>  Redirects </li><li>  Icons (same problems) </li><li>  Standards and validity (the same) </li></ul>  I consider this part rather crude, because we are trying to make a service for people who do not have to know what RSS or Atom is.  For example, if I, as the most ordinary user, suddenly want to subscribe to my favorite and unique vkontakte.ru, then I will see you blowing blueberry jam.  At a minimum, in the future we want to implement something a la <a href="http://googlereader.blogspot.com/2010/01/follow-changes-to-any-website.html">gr generated feed</a> .  As more than a minimum, make a convenient, human search. <br>  By the way, it is often found that there is no alternate specifically on this page, but somewhere on other pages of the same site there are.  There was a thought to write a back-round crawler, which would quietly search for rss / atom streams on those sites that are often entered by users. <br><br>  <strong>Findings:</strong> <br>  When dealing with external sources of a different type, it feels like you are digging in a giant trash can in search of a document that is accidentally thrown away. <br>  Requires specific improvements.  From the point of view of usability, a simple search for alternates on this page is not enough.  We need to do something more universal. <br><br>  <strong>4. Interface</strong> <br><br>  The next thing I really wanted was to see the interface where I could subscribe to some stream, add it as a bookmark to the left column, click and read its contents. <br>  I will not go into the details of the implementation of interfaces, I just want to say that I did all the layout and ui myself.  It was very unprofitable and distracted from other tasks.  But jquery saved time. <br>  I spent a total of two weeks on the reading room and the general interface (this is not counting rather stressful improvements and alterations in the future).  After that, we got a pretty nice toy that lit up on our monitors, pleasing the eyes and soul. <br><br>  Folders <br>  Of course, we are minimal guys, but without folders I cannot imagine working with the reader.  And, excuse me gentlemen, their usability in Google Reader leaves much to be desired.  We tried to implement them as accessible and simple as possible. <br>  But I never thought that technically it could be such a problem.  The interface is an interface, and on the server side I had to tense up pretty much so that it worked as it should - see the next paragraph. <br><br>  If possible, tried to use css sprites (where it turned out). <br>  All js and css are collected in one file, minified and compressed with gzip.  The average page (with all the statics) weighs 300kb.  With a cache - 100kb. <br>  And for ie6 we have a special page. <br><br>  <strong>Findings:</strong> <br>  The interface itself looks very easy, but I would not say the same about its implementation. <br>  Finally, when everything is compressed and firebug is turned off, it works smartly. <br>  In total, I counted 28 screens at the moment, and a million usecase s. <br><br>  <strong>5. Read / unread entries</strong> <br><br>  It turned out that this is a rather nontrivial task for a system where stopicot flows can potentially be, and even more subscribers.  Most importantly, it can be scaled horizontally. <br>  In each Entry entity, I keep a list of users who read it.  Potentially, there may be at least a million identifiers in this list, this will not affect performance, thanks to the mongodb architecture.  Also, in a separate collection is stored additional information about the reading time, etc.  it is not indexed and is needed solely for statistics, so everything works pretty quickly. <br><br>  For each user, the date of the last update of his counters is stored - for all threads to which he is subscribed. <br>  When the user refreshes the page, the system finds the number of new entries for each stream that appeared later than this date, and adds it to the number of unread (simple increment).  When a user reads any record, a simple decrement occurs. <br><br>  Selection of unread entries on a separate stream is also very simple. <br><br>  But choosing only the unread in the folder is already a problem.  I do not want to clarify the nuances, but this is due to the fact that there are simply no join-s in mongodb.  Simple request or several - it cannot be solved, only through CodeWScope.  It is impossible to index, to scale - m / r.  This is currently a potential bottleneck. <br><br>  <strong>5.1.</strong>  <strong>Unread on top</strong> <br><br>  If any of you have used Google Reader, then you probably know about the ‚Äúwatch only unread‚Äù function.  So, if there are no records in the stream that you have not read, you are looking at a blank page.  At first, we did the same, but testing showed that users do not even realize that they have this feature turned on.  They do not understand why the stream is empty, why there are no records on it, and where they go. <br>  David offered a very interesting solution, where the unread entries simply appear on top, and the reads go down.  And it cost me a few days of breaking the brain over how best to implement it, in folders. <br><br>  <strong>Findings:</strong> <br>  No-SQL is good in terms of speed and scalability.  But some seemingly trivial things turned out to be quite difficult to do with him. <br>  Denormalization is good.  It is not necessary to consider a problem that any counter will fail.  But for any denormalized data, you need to have a full conversion function (on the background, of course). <br>  <a href="http://www.mongodb.org/display/DOCS/MapReduce">M / R in mongodb is</a> still raw for production.  After a little testing, it turned out that he was blocking everything to hell during work.  In version 1.6, the developers promise to improve it.  So far without cost him. <br>  Schema-less decides. <br><br>  <strong>8. Sharing</strong> <br><br>  This is a function that allows you to sew any entry from a readable stream to your page.  In short, this means that any authoritative guy A, reading various feeds, can instantly save specific entries (of course, the most interesting and useful) to his stream (s) - similar to Shared Items in GR.  And other users have the opportunity to directly subscribe to his ‚ÄúShared Items‚Äù stream, as well as to any feed. <br><br>  One of the main concepts of our service is convenient distribution of information.  A rather interesting from a technical point of view task for me was to implement the construction of chains of shearing.  Mongodb was very helpful with its schema-less properties. <br><br>  An interesting point: <br>  Recently, Google announced a new <a href="http://gmailblog.blogspot.com/2010/05/reshare-in-google-buzz.html">ReShare</a> feature in Buzz.  So in this article (by reference), where ‚ÄúA little more background‚Äù, I came across points that David and I had been discussing closely 4 months ago, I came to the same conclusions.  Our implementation of sharing is very close. <br><br>  <strong>9. Node.js, background, queues</strong> <br><br>  Initially, the demons were written in PHP, with it, very crooked.  And, apart from mongodb, it was the most dumb place for me in the app, since the erener is not intended for such things. <br>  But when I stumbled upon node.js (it was just two weeks ago), my soul started singing, and again I was able to ‚Äúsleep‚Äù calmly.  But the problem was that rewriting all the background code into it that was already implemented in PHP (feed-pull, discovery, feed-info) was not the time at all. <br>  Very short picking in the capabilities of the node led me to a compromise solution - child-process. <br><br>  <strong>9.1.</strong>  <strong>Queue manager</strong> <br><br>  This is the first node demon.  His task is to read queues, distribute tasks to workers and monitor the process of their work. <ul><li>  One manager can serve many queues </li><li>  Managers in the system can be run any number, one per server. </li><li>  Each can be configured in its own way, for example, different managers can work with a different set of queues </li><li>  The configuration of the queues may differ and has the following parameters <ul><li>  The maximum number of workers working simultaneously (the actual number is adjusted depending on the load) </li><li>  The size of the task buffer (must be configured depending on the type of task and the number of workers) </li><li>  Maximum idle time of the worker (automatically kills and frees memory if idle) </li><li>  The maximum lifetime of the worker (if this is php-cli, you shouldn‚Äôt live long, it‚Äôs better to restart sometimes) </li><li>  Maximum memory usage in a worker (as soon as it exceeds, we kill) </li><li>  Timeout for the task execution (if the worker is stuck during the task execution, kill it, return the task to the queue) </li><li>  The number of times a task can be spilled </li></ul></li><li>  When a task is selected from a queue, a Lock is placed on it (memcache is used for locks) </li><li>  If the task has a result, it will be saved in memcache. </li><li>  Each queue has its own worker, it must be a js class with a specific interface. <ul><li>  At the moment, only one of these works - import (more will be about it later) </li></ul></li><li>  Also, there is WorkerPhp.js, which runs php-cli as a child-process and communicates with it on json <ul><li>  The life of such a worker (process) does not end with the performance of one task - he can perform one by one until the manager sees that he is noticeably ‚Äúfattened‚Äù and will not dismiss him </li><li>  In practice, more than 4 php processes per queue do not start at the same time. </li></ul></li><li>  Understands POSIX Signals </li><li>  In the case of correct completion (not kill -9), it carefully returns all running tasks from memory back to the queue </li><li>  Each manager opens a port with a REPL interface, you can enter it and ask how it is.  Also, you can change its configuration without rebooting on the fly. </li></ul>  By the way, any uncaught exception lays only one thread, but not the whole process, which is good. <br>  And all this - 500 lines of code (with comments). <br><br>  <strong>Findings:</strong> <br>  Evented I / O is how most server applications are required to work.  The lock should only be where it is really needed. <br>  Proxy php through node showed good results and saved time. <br>  A bunch of work serves only one process (not counting php-cli).  JS workers work there asynchronously and very sharply. <br><br>  <strong>9.2.</strong>  <strong>Controller - Publish / Subscribe hub</strong> <br><br>  It often happens that you need to perform bulk tasks (for example, 100) in parallel, and even asynchronously.  But the turn is a black hole.  To send there 100 tasks ... and even once a second to contact memcache for results is expensive. <br>  You can still bypass the queue, you could use the socket to directly contact the manager and ask him to perform these tasks, waiting for a response in the same connection.  But this option is not suitable, as there may be a dozen managers, and we do not know which of them can be addressed ... in short, this is wrong. <br><br>  And I created a controller (node).  It is generally one for the whole system, and at the same time, it is as simple as a stool: <ul><li>  All managers open a permanent connection with the controller. </li><li>  In case of any result or file of any task, the manager informs the controller in detail. </li><li>  You can connect to it ‚Äúfrom the other side‚Äù and subscribe to a specific task or list of tasks. </li><li>  As information on tasks is received, the controller notifies all subscribers. </li><li>  If the subscriber expects a lot of tasks, the controller notifies him as they arrive. </li><li>  There is a client for PHP (blocking) </li><li>  Garbage collection </li></ul>  Actually, it is in the ‚Äúdiscovery‚Äù procedure that I described above that the PHP script just calls the controller and waits for the result of the task for 5 seconds, after which it returns the user to the interface. <br><br>  <strong>Findings:</strong> <br>  Publish / Subscribe scheme is very effective in non-blocking environments. <br>  A 100% result is not required.  If, as a result, 5 tasks out of 100 have not been completed for some reason, as a rule, this is not terrible and we continue to work. <br><br>  <strong>9.3.</strong>  <strong>Feed-updater (background update)</strong> <br><br>  Node process, one for the whole system.  Periodically turns into the database, receiving a list of feeds that need to be updated (using TTL data), and throws them into the queue. <br><br>  <strong>9.4.</strong>  <strong>Queues</strong> <br><br>  To avoid race-conditions, a unique md5 identifier is generated for each task.  It is this identifier that is placed in the queue, and the data of this task itself is stored in memcached.  Because almost all tasks have non-fixed size, and memcacheq is not friendly with it - and should not.  When a manager takes a task, he puts a lock on it, which is also a record in memcached.  This allows you to avoid re-entering the queue of identical tasks directly during their execution. <br>  I plan to consider Redis as an alternative to all this, because memcached in this case is used for other purposes.  If he falls, the whole line will be lost. <br><br>  I also divided the queues into two groups: user and system.  The first - in priority. <br>  This simply led to the addition of ‚Äúfeed-pull-sys‚Äù, which is used by the background update without interfering with user tasks. <br><br>  <strong>Findings:</strong> <br>  This implementation is still very raw. <br>  The queue must be recoverable in any fall. <br>  Need to use a more advanced locking system - mutex? <br>  User and background processes must have different priorities. <br><br>  <strong>10. Import / Export</strong> <br><br>  Here is another interesting point that I want to talk about.  All decent readers are required to support import / export in OPML format.  But the fact is that some users can upload their opml with hundreds of feeds that are not yet in our system.  And then he will have to wait until they all load.  And yet, there may be a dozen of those willing at the same time. <br><br>  Node saves.  There was a new worker called "import" (at the moment it can work up to 10 at a time).  After downloading and validating the opml file, php throws the task into the queue and returns the user to the interface, to the progress bar.  Meanwhile, the ‚Äúimport‚Äù picks up and scatters smaller tasks into the feed-pull queue, and then waits for them to be executed by the controller, updating the counter in parallel.  And the user sees a creeping progress bar.  With that, he can leave this page, take a walk, and then return.  It's nice. <br><br><h4>  Iii.  findings </h4><ul><li>  Do not make bicycles.  Virtually any task already has a ready-made solution that just needs to be slightly adapted. </li><li>  The simpler the product is for the user in the end, the more difficult is its implementation.  The consumer, in other matters, is unlikely to notice. </li><li>  Do not overestimate yourself.  Independently making an adult product ‚Äúfor a week‚Äù is not possible (although I don‚Äôt like this word). </li><li>  Motivation, however, sometimes makes the impossible. </li><li>  The product will never be perfect.  A running application is always a trade-off between time and quality. </li><li>  If you work on your own, there‚Äôs a lot of brainstorming in the team.  It is worth using collective intelligence whenever possible. </li><li>  It takes a lot of time to switch context.  Much more effective when one developer is engaged in more tasks of the same type. </li><li>  If you intend to make your startup and move on ideas, forget about privacy and Friday beer. </li></ul>  This is only the beginning, and there is still a lot of planned work ahead.  Including what we can call innovations, I‚Äôm not afraid of that word.  Therefore, to be continued ... <br><br>  In parallel, I want to announce a half-closed launch next week. <br>  The project itself will be written by my colleague in another article the other day. <br><br>  I would be grateful for any technical comments, advice and constructive criticism. </div><p>Source: <a href="https://habr.com/ru/post/95526/">https://habr.com/ru/post/95526/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../95516/index.html">Laziness and one-time passwords Yandex. Money</a></li>
<li><a href="../95517/index.html">Hi, Abkhazia</a></li>
<li><a href="../95518/index.html">New laptops from ASUS and Lamborghini</a></li>
<li><a href="../95520/index.html">Automotive X-Prize: 25 applicants for 10 million</a></li>
<li><a href="../95521/index.html">Useful and interesting modules for Drupal 6.xx + Tips and Tricks (Part III)</a></li>
<li><a href="../95528/index.html">Do not rush to upgrade your HTC Hero to Android 2.1</a></li>
<li><a href="../95530/index.html">MiTM for GPRS</a></li>
<li><a href="../95535/index.html">What does the coming day prepare for us? Or start-up parties in the summer</a></li>
<li><a href="../95538/index.html">Memory structuring</a></li>
<li><a href="../95540/index.html">Google Maps offers a stroll to Edinburgh through France and Belgium</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>