<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>5 ways to calculate Fibonacci numbers: implementation and comparison</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Programmers Fibonacci numbers should already podnadoest. Examples of their calculations are used everywhere. All that these numbers pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>5 ways to calculate Fibonacci numbers: implementation and comparison</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Programmers Fibonacci numbers should already podnadoest.  Examples of their calculations are used everywhere.  All that these numbers provide the simplest example of recursion.  They are also a good example of dynamic programming.  But is it necessary to calculate them in a real project?  Do not.  Neither recursion nor dynamic programming is ideal.  And not a closed formula using floating point numbers.  Now I will tell you how.  But first, let's go through all the known solutions. <br><br>  The code is intended for Python 3, although it should go in Python 2. <br><br>  To begin with, let me remind you the definition 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      F <sub>n</sub> = F <sub>n-1</sub> + F <sub>n-2</sub> <br><br>  and F <sub>1</sub> = F <sub>2</sub> = 1. <br><a name="habracut"></a><br><h4>  Closed formula </h4><br>  Let's skip the details, but those who wish can <a href="http://en.wikipedia.org/wiki/Fibonacci_number">get acquainted with the derivation of the formula</a> .  The idea is to assume that there is some x for which F <sub>n</sub> = x <sup>n</sup> , and then find x. <br><br><img src="https://habrastorage.org/files/595/c24/a05/595c24a057bb4f6ebc5f52643f9be2f5.png"><br><br>  which means <br><br><img src="https://habrastorage.org/files/520/b93/744/520b937449284d639bfef75fe9d9d580.PNG"><br><br>  cut x <sup>n-2</sup> <br><br><img src="https://habrastorage.org/files/0bf/24b/b39/0bf24bb39c9543d1a64c192d96cb9d2b.PNG"><br><br>  Solve the quadratic equation: <br><br><img src="https://habrastorage.org/files/701/b06/9d2/701b069d29154ff3910e74d32830e3fd.PNG"><br><br>  From where the ‚Äúgolden ratio‚Äù œï = (1 + ‚àö5) / 2 grows.  Substituting the original values ‚Äã‚Äãand doing another calculation, we get: <br><br><img src="https://habrastorage.org/files/e37/e6d/a39/e37e6da397144b688b46b276293b373a.PNG"><br><br>  which we use to calculate F <sub>n</sub> . <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> division <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> SQRT5 = math.sqrt(<span class="hljs-number"><span class="hljs-number">5</span></span>) PHI = (SQRT5 + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> int(PHI ** n / SQRT5 + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)</code> </pre> <br><br>  Good: <br>  Fast and easy for small n <br>  The bad: <br>  Requires floating point operations.  For large n, greater accuracy is required. <br>  Evil: <br>  Using complex numbers to calculate F <sub>n is</sub> beautiful from a mathematical point of view, but ugly from a computer. <br><br><h4>  Recursion </h4><br>  The most obvious solution that you have already seen many times is most likely as an example of what recursion is.  I repeat it again, for completeness.  In Python, it can be written in one line: <br><br><pre> <code class="python hljs">fib = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> n: fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br>  Good: <br>  Very simple implementation, repeating the mathematical definition <br>  The bad: <br>  Exponential lead time.  For large n very slowly <br>  Evil: <br>  Stack overflow <br><br><h4>  Memorization </h4><br>  The recursion solution has a big problem: overlapping calculations.  When fib (n) is called, fib (n-1) and fib (n-2) are counted.  But when fib (n-1) is considered, it again independently calculates fib (n-2) ‚Äîthat is, fib (n-2) is counted twice.  If we continue the argument, it will be seen that fib (n-3) will be counted three times, and so on.  Too many intersections. <br><br>  Therefore, you just need to memorize the results so as not to count them again.  Time and memory of this solution are spent in a linear fashion.  I use a dictionary in the solution, but I could use a simple array. <br><br><pre> <code class="python hljs">M = {<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> M: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> M[n] M[n] = fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> M[n]</code> </pre><br><br>  (In Python, this can also be done using a decorator, functools.lru_cache.) <br><br>  Good: <br>  Just turn recursion into a memorized solution.  Turns exponential time into linear execution, which consumes more memory. <br>  The bad: <br>  Spends a lot of memory <br>  Evil: <br>  Possible stack overflow, like recursion <br><br><h4>  Dynamic programming </h4><br>  After solving with memorization, it becomes clear that we do not need all the previous results, but only the last two.  In addition, instead of starting with fib (n) and going backwards, you can start with fib (0) and go forward.  The following code has linear execution time, and memory usage is fixed.  In practice, the solution speed will be even higher, since there are no recursive function calls and related work.  And the code looks simpler. <br><br>  This solution is often cited as an example of dynamic programming. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span> b = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> __ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n): a, b = b, a + b <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a</code> </pre><br><br>  Good: <br>  Fast for small n, simple code <br>  The bad: <br>  Still linear execution time <br>  Evil: <br>  Yes, nothing special. <br><br><h4>  Matrix algebra </h4><br>  And, finally, the least illuminated, but the most correct solution, competently using both time and memory.  It can also be extended to any homogeneous linear sequence.  The idea of ‚Äã‚Äãusing matrices.  It is enough just to see that <br><br><img src="https://habrastorage.org/files/c7b/94d/4c3/c7b94d4c351a4719a3bafedff4eeb808.PNG"><br><br>  A generalization of this suggests that <br><br><img src="https://habrastorage.org/files/c12/ac2/4c8/c12ac24c87f045688714c416752afc40.PNG"><br><br>  Two values ‚Äã‚Äãfor x, obtained by us earlier, one of which was the golden section, are eigenvalues ‚Äã‚Äãof the matrix.  Therefore, another way to derive a closed formula is to use the matrix equation and linear algebra. <br><br>  So why is such a formulation helpful?  The fact that exponentiation can be made in logarithmic time.  This is done through <a href="http://sahandsaba.com/cryptography-rsa-part-1.html">squaring</a> .  The bottom line is that <br><br><img src="https://habrastorage.org/files/a88/dfc/655/a88dfc6558824458ad8053cd850ff3ac.PNG"><br><br>  where the first expression is used for even A, the second for odd.  It remains only to organize the multiplication of matrices, and everything is ready.  It turns out the following code.  I organized the recursive implementation of pow, since it is easier to understand.  Iterative version, see here. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, n, I, mult)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""  x   n. ,  I ‚Äì   ,    mult,  n ‚Äì   """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> I <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> n == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: y = pow(x, n // <span class="hljs-number"><span class="hljs-number">2</span></span>, I, mult) y = mult(y, y) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n % <span class="hljs-number"><span class="hljs-number">2</span></span>: y = mult(x, y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identity_matrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""   n  n"""</span></span> r = list(range(n)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [[<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == j <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matrix_multiply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A, B)</span></span></span><span class="hljs-function">:</span></span> BT = list(zip(*B)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [[sum(a * b <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a, b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(row_a, col_b)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col_b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> BT] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row_a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> F = pow([[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]], n, identity_matrix(<span class="hljs-number"><span class="hljs-number">2</span></span>), matrix_multiply) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> F[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre><br><br>  Good: <br>  Fixed memory, logarithmic time <br>  The bad: <br>  The code is more complicated <br>  Evil: <br>  We have to work with matrices, although they are not so bad <br><br><h4>  Performance comparison </h4><br>  It is worth comparing only the variant of dynamic programming and the matrix.  If we compare them by the number of characters in the number n, then it turns out that the matrix solution is linear, and the solution with dynamic programming is exponential.  A practical example is the calculation of fib (10 ** 6), a number that has more than two hundred thousand characters. <br><br>  n = 10 ** 6 <br>  We calculate fib_matrix: fib (n) has only 208988 digits, the calculation took 0.24993 seconds. <br>  We calculate fib_dynamic: fib (n) has only 208988 digits, the calculation took 11.83377 seconds. <br><br><hr><br><br><h4>  Theoretical notes </h4><br>  Without directly relating to the above code, this comment still has a certain interest.  Consider the following graph: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c9/206/c1f/5c9206c1fa711d2fa28c7b07e5954e12.png" alt="image"><br><br>  Let us calculate the number of paths of length n from A to B. For example, for n = 1 we have one path, 1. For n = 2, we again have one path, 01. For n = 3, we have two paths, 001 and 101 Quite simply, it can be shown that the number of paths of length n from A to B is exactly F <sub>n</sub> .  Writing the adjacency matrix for the graph, we get the same matrix that was described above.  This is a well-known result from graph theory that, for a given adjacency matrix A, occurrences in A <sup>n</sup> are the number of paths of length n in the graph ( <a href="http://mat.unideb.hu/media/horvath-gabor/publications/gwh2.pdf">one of the problems mentioned</a> in the film "Good Will Hunting"). <br><br>  Why are there such symbols on the edges?  It turns out that if you consider an infinite sequence of characters on an infinite sequence of paths on both sides of a graph, you will get something called ‚Äú <a href="http://en.wikipedia.org/wiki/Subshift_of_finite_type">finite type poddvigi</a> ‚Äù, which is a type of system of symbolic dynamics.  Specifically, this finite type subdivision is known as the ‚Äúgolden section shift‚Äù, and is defined by the set of ‚Äúforbidden words‚Äù {11}.  In other words, we get infinite in both directions binary sequences and no pairs of them will be adjacent.  The topological entropy of this dynamical system is equal to the golden section œï.  I wonder how this number periodically appears in different areas of mathematics. </div><p>Source: <a href="https://habr.com/ru/post/261159/">https://habr.com/ru/post/261159/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261147/index.html">New Cherry Framework 4 | Cherry ripened</a></li>
<li><a href="../261149/index.html">Intel RealSense SDK Architecture</a></li>
<li><a href="../261151/index.html">A simple alarm clock with a web interface on Asterisk</a></li>
<li><a href="../261155/index.html">ICANN suspended Freenom accreditation</a></li>
<li><a href="../261157/index.html">Gateway through the Chinese firewall</a></li>
<li><a href="../261161/index.html">Capture packages in Linux at speeds of tens of millions of packages per second without using third-party libraries</a></li>
<li><a href="../261163/index.html">The easiest and most complex Java builder</a></li>
<li><a href="../261171/index.html">Simple words about the Twelve-Factor App</a></li>
<li><a href="../261173/index.html">ReactOS - No.2 in the plans of the Russian government for import substitution software</a></li>
<li><a href="../261175/index.html">The implementation of the idea of ‚Äã‚Äãa subscription is not per person, as in Twitter / instagram, but in place</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>