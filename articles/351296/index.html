<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Blockchain on Go. Part 3: Permanent Memory and Command Line Interface</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content 



1. Blockchain on Go. Part 1: Prototype 
2. Blockchain on Go. Part 2: Proof-of-Work 
3. Blockchain on Go. Part 3: Permanent Memory and Comm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Blockchain on Go. Part 3: Permanent Memory and Command Line Interface</h1><div class="post__text post__text-html js-mediator-article">  Content <br><br><ol><li>  <a href="https://habrahabr.ru/post/348672/">Blockchain on Go.</a>  <a href="https://habrahabr.ru/post/348672/">Part 1: Prototype</a> </li><li>  <a href="https://habrahabr.ru/post/350804/">Blockchain on Go.</a>  <a href="https://habrahabr.ru/post/350804/">Part 2: Proof-of-Work</a> </li><li>  <b>Blockchain on Go.</b>  <b>Part 3: Permanent Memory and Command Line Interface</b> </li><li>  <a href="https://habrahabr.ru/post/351752">Blockchain on Go.</a>  <a href="https://habrahabr.ru/post/351752">Part 4: Transactions, Part 1</a> </li><li>  <a href="https://habrahabr.ru/post/351834/">Blockchain on Go.</a>  <a href="https://habrahabr.ru/post/351834/">Part 5: Addresses</a> </li><li>  Blockchain on Go.  Part 6: Transactions, Part 2 </li><li>  Blockchain on Go.  Part 7: Network </li></ol><br><h3>  Introduction </h3><br>  In the <a href="https://habrahabr.ru/post/350804/">previous part,</a> we built a blockchain with a PoW system and the possibility of mining.  Our implementation is getting closer to a fully functional blockchain, but it still lacks some important functions.  Today we will start storing the blockchain in the database, then we will create a command line interface for operations with the blockchain.  In essence, the blockchain is a distributed database.  For now, we‚Äôll omit the ‚Äúdistributed‚Äù and focus on the ‚Äúdatabase‚Äù. <br><a name="habracut"></a><br><h3>  Database selection </h3><br>  So far, we do not have a database in the implementation, we simply create blocks when the program is started and store them in memory.  We cannot reuse or share our blockchain with others, so we need to save it to disk. <br><br>  What database do we need?  In fact, any will do.  In <a href="https://bitcoin.org/bitcoin.pdf">Bitcoin Paper,</a> nothing is said about a specific database, so the choice is up to the developer.  <a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> , which was originally published by Satoshi Nakamoto and which is currently the reference implementation of Bitcoin, uses <a href="https://github.com/google/leveldb">LevelDB</a> (although it was only presented to the client in 2012).  And we will use ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  BoltDB </h3><br>  Because: <br><br><ol><li>  It is simple and minimal. </li><li>  It is implemented on Go </li><li>  She does not need to start the server </li><li>  It allows us to build the necessary data structures. </li></ol><br>  From <a href="https://github.com/boltdb/bolt">BoltDB README</a> : <br><blockquote>  Bolt is simply a key-value repository inspired by the Howard Chu <a href="http://symas.com/mdb/">LMDB project</a> .  The goal of the project is to provide a simple, fast and reliable database for projects that do not require a full-fledged database server, such as Postgres or MySQL. <br><br>  Since Bolt is intended to be used as such a low-level element of functionality, simplicity is key.  The API will be small and focus only on getting values ‚Äã‚Äãand setting values.  It's all! </blockquote>  Sounds perfect for our needs!  Take a moment to review the base. <br><br>  BoltDB is a ‚Äúkey-value‚Äù repository, which means that there are no tables, like in relational DBMS (MySQL, PostgreSQL, etc.), there are no rows or columns.  Instead, data is stored in key-value pairs (as in the Golang map).  Pairs are stored in ‚Äúbaskets‚Äù, which are designed to group similar pairs (like tables in relational DBMS).  Thus, to get the value, you need to know the basket and the key. <br><br>  The important thing about BoltDB is that there are no data types here: keys and values ‚Äã‚Äãare byte arrays.  Since we store Go structures (in particular, <code>Block</code> ), we must serialize them, that is, implement a mechanism for translating the structure into a byte array and restoring it back from the array.  We will use <a href="https://golang.org/pkg/encoding/gob/">encoding / gob</a> for this, although <code>JSON, XML, Protocol Buffers</code> also suitable.  We use <code>encoding/gob</code> because it is simple and it is part of the standard Go library. <br><br><h3>  Database structure </h3><br>  Before we start implementing persistent logic, we must decide how we will store our data in the database.  And for this we will use the way that Bitcoin Core is used. <br><br>  If simply, then Bitcoin Core uses two "baskets" for data storage. <br><br><ol><li>  <code>blocks</code> stores metadata describing all the blocks in a chain. </li><li>  <code>chainstate</code> stores the chain state, which represents all unspent transaction outputs and some metadata </li></ol><br>  Also blocks are stored as separate files on disk.  This is done to improve performance: reading one block does not require loading all (or some) into memory.  This we will not implement. <br><br>  In the <code>blocks</code> pair <code>key-&gt;value</code> is: <br><ol><li> <code>'b' + 32-   -&gt;    'f' + 4-   -&gt;     'l' -&gt; 4-  :       'R' -&gt; 1- boolean :       'F' + 1-    +    -&gt; 1  boolean:  ,       't' + 32-   -&gt;    <br></code> </li> <li> <code>'b' + 32-   -&gt;    'f' + 4-   -&gt;     'l' -&gt; 4-  :       'R' -&gt; 1- boolean :       'F' + 1-    +    -&gt; 1  boolean:  ,       't' + 32-   -&gt;    <br></code> </li> <li> <code>'b' + 32-   -&gt;    'f' + 4-   -&gt;     'l' -&gt; 4-  :       'R' -&gt; 1- boolean :       'F' + 1-    +    -&gt; 1  boolean:  ,       't' + 32-   -&gt;    <br></code> </li> <li> <code>'b' + 32-   -&gt;    'f' + 4-   -&gt;     'l' -&gt; 4-  :       'R' -&gt; 1- boolean :       'F' + 1-    +    -&gt; 1  boolean:  ,       't' + 32-   -&gt;    <br></code> </li> <li> <code>'b' + 32-   -&gt;    'f' + 4-   -&gt;     'l' -&gt; 4-  :       'R' -&gt; 1- boolean :       'F' + 1-    +    -&gt; 1  boolean:  ,       't' + 32-   -&gt;    <br></code> </li> <li> <code>'b' + 32-   -&gt;    'f' + 4-   -&gt;     'l' -&gt; 4-  :       'R' -&gt; 1- boolean :       'F' + 1-    +    -&gt; 1  boolean:  ,       't' + 32-   -&gt;    <br></code> </li> </ol> <code>'b' + 32-   -&gt;    'f' + 4-   -&gt;     'l' -&gt; 4-  :       'R' -&gt; 1- boolean :       'F' + 1-    +    -&gt; 1  boolean:  ,       't' + 32-   -&gt;    <br></code>  In <code>chainstate</code> pairs, <code>key-&gt;value</code> is: <br><ol><li> <code>'c' + 32-   -&gt;         'B' -&gt; 32-  :  ,          <br></code> </li> <li> <code>'c' + 32-   -&gt;         'B' -&gt; 32-  :  ,          <br></code> </li> </ol> <code>'c' + 32-   -&gt;         'B' -&gt; 32-  :  ,          <br></code>  (A <i>detailed explanation can be found <a href="https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2):_Data_Storage">here</a></i> ) <br><br>  Since we have no transactions so far, we will only make cart <code>blocks</code> .  In addition, as mentioned above, we will store the entire database in one file, without storing the blocks in separate files.  Therefore, we do not need anything related to file numbers.  Therefore, the <code>key-&gt;value</code> pairs that we will use are: <br><br><ol><li>  32-byte block hash -&gt; block structure (serialized) </li><li>  'l' -&gt; hash of the last block in the chain </li></ol><br>  This is all we need to know to implement the mechanism of constancy (persistence). <br><br><h3>  Serialization </h3><br>  As stated earlier, in BoltDB, values ‚Äã‚Äãcan only be of <code>[]byte</code> type, and we want to store the <code>Block</code> structure in the database.  We will use <code>encoding/gob</code> to serialize the structures. <br><br>  Let's implement the <code>Serialize</code> method for <code>Block</code> (error handling is omitted for brevity) <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Block)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result bytes.Buffer encoder := gob.NewEncoder(&amp;result) err := encoder.Encode(b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.Bytes() }</code> </pre> <br>  Everything is simple: at the beginning, we declare the buffer where the serialized data will be stored, then we initialize the <code>gob</code> encoder and encode the block, return the result as an array of bytes. <br><br>  Now we need a deserialization function that takes an array of bytes as input and returns <code>Block</code> .  This will not be a method, but an independent function: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeserializeBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Block</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> block Block decoder := gob.NewDecoder(bytes.NewReader(d)) err := decoder.Decode(&amp;block) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;block }</code> </pre> <br>  That's all we need for serialization. <br><br><h3>  Persistence </h3><br>  Let's start with the <code>NewBlockchain</code> function.  Now she creates a new copy of <code>Blockchain</code> and adds a genesis block to it.  We want to do the following: <br><br><ol><li>  Open DB file </li><li>  Check if the blockchain is saved there. </li><li>  If he is there: <ol><li>  Create a new <code>Blockchain</code> instance </li><li>  Set the tip of the <code>Blockchain</code> instance to the hash of the last block stored in the database </li></ol><br></li><li>  If there is no existing blockchain <br><br><ol><li>  Create genesis block </li><li>  Save to DB </li><li>  Save Genesis Hash as Hash of Last Last Block </li><li>  Create a new <code>Blockchain</code> instance with a tip indicating the genesis of the block </li></ol></li></ol><br>  In code, it looks like this: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewBlockchain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Blockchain</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tip []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> db, err := bolt.Open(dbFile, <span class="hljs-number"><span class="hljs-number">0600</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) err = db.Update(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx *bolt.Tx)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { b := tx.Bucket([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(blocksBucket)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { genesis := NewGenesisBlock() b, err := tx.CreateBucket([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(blocksBucket)) err = b.Put(genesis.Hash, genesis.Serialize()) err = b.Put([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">"l"</span></span>), genesis.Hash) tip = genesis.Hash } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tip = b.Get([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">"l"</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }) bc := Blockchain{tip, db} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;bc }</code> </pre> <br>  Let's sort the code in parts. <br><br><pre> <code class="go hljs">db, err := bolt.Open(dbFile, <span class="hljs-number"><span class="hljs-number">0600</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>  This is the standard way to open a BoltDB file.  Please note that it will not return an error if there is no file. <br><br><pre> <code class="go hljs">err = db.Update(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx *bolt.Tx)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { ... })</code> </pre> <br>  In BoltDB, database operations are performed as part of a transaction.  There are two types of transactions: read-only and read-write.  Here we open the read-write transaction <code>(db.Update(...))</code> , because we plan to put the genesis block in the database. <br><br><pre> <code class="go hljs">b := tx.Bucket([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(blocksBucket)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { genesis := NewGenesisBlock() b, err := tx.CreateBucket([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(blocksBucket)) err = b.Put(genesis.Hash, genesis.Serialize()) err = b.Put([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">"l"</span></span>), genesis.Hash) tip = genesis.Hash } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tip = b.Get([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">"l"</span></span>)) }</code> </pre> <br>  This is the core of the function.  Here we get a basket that stores our blocks: if it exists, then we read the key <code>l</code> from it, if it does not exist, then we generate a genesis block, create a basket, save the block in it and update the key <code>l</code> , which stores the hash of the last block in the chain. <br><br>  Also notice the new way to create a <code>Blockchain</code> : <br><br><pre> <code class="go hljs">bc := Blockchain{tip, db}</code> </pre> <br>  We do not store all the blocks, instead we store only the tip of the chain.  We also store the connection to the database, because we want to open it once and keep it open while the program is running.  This is how the <code>Blockchain</code> structure looks like now: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Blockchain <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { tip []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> db *bolt.DB }</code> </pre> <br>  The next thing we want to change is the <code>AddBlock</code> method: adding blocks to a chain is no longer as simple as adding an element to an array.  From now on, we will store the blocks in the database: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bc *Blockchain)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastHash []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> err := bc.db.View(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx *bolt.Tx)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { b := tx.Bucket([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(blocksBucket)) lastHash = b.Get([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">"l"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }) newBlock := NewBlock(data, lastHash) err = bc.db.Update(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx *bolt.Tx)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { b := tx.Bucket([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(blocksBucket)) err := b.Put(newBlock.Hash, newBlock.Serialize()) err = b.Put([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">"l"</span></span>), newBlock.Hash) bc.tip = newBlock.Hash <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }) }</code> </pre> <br>  Consider the code bit by bit: <br><br><pre> <code class="go hljs">err := bc.db.View(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx *bolt.Tx)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { b := tx.Bucket([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(blocksBucket)) lastHash = b.Get([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">"l"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> })</code> </pre> <br>  This is a different (read-only) type of transaction BoltDB.  Here we get the hash of the last block from the database to use to mine the hash of a new block. <br><br><pre> <code class="go hljs">newBlock := NewBlock(data, lastHash) b := tx.Bucket([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(blocksBucket)) err := b.Put(newBlock.Hash, newBlock.Serialize()) err = b.Put([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">"l"</span></span>), newBlock.Hash) bc.tip = newBlock.Hash</code> </pre> <br>  After mining a new block, we save the serialized view to the database and update the key <code>l</code> , which now stores the hash of the new block. <br><br>  Done!  It was not difficult, was it? <br><br><h3>  Checking blockchain </h3><br>  All new blocks are now stored in the database, so we can rediscover the blockchain and add a new block to it.  But after implementing this, we lose one useful feature: we cannot print blocks, because we no longer store them in an array.  Let's fix it. <br><br>  BoltDB allows you to go through all the keys in the basket, but all the keys are stored in the sort order bytes, and we want the blocks to be printed in the order in which they are placed in the blockchain.  Also, since we do not want to load all the blocks into memory (our blockchain can be very huge), then we will read them one by one.  For this purpose, we need a blockchain iterator: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BlockchainIterator <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { currentHash []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> db *bolt.DB }</code> </pre> <br>  An iterator will be created every time we want to iterate over the blocks in the blockchain and it will store the hash of the current iteration block and the connection to the database.  Because of the latter, the iterator is logically bound to the blockchain (this is a <code>Blockchain</code> instance that stores the connection to the database) and, thus, is created in the <code>Blockchain</code> method: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bc *Blockchain)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BlockchainIterator</span></span></span></span> { bci := &amp;BlockchainIterator{bc.tip, bc.db} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bci }</code> </pre> <br>  Note that the iterator first points to the tip of the blockchain, so the blocks will be obtained from top to bottom, from the newest to the oldest.  In fact, the <strong>choice of the tip means ‚Äúvoting‚Äù for the blockchain</strong> .  A blockchain can have several branches and the longest of them is considered the main one.  After receiving the tip (it can be any block in the blockchain), we can recreate the whole blockchain and find its length, and the work necessary to build it.  This fact also means that the tip is a kind of blockchain identifier. <br><br>  <code>BlockchainIterator</code> does only one thing: returns the next block from the blockchain. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *BlockchainIterator)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Block</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> block *Block err := i.db.View(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx *bolt.Tx)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { b := tx.Bucket([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(blocksBucket)) encodedBlock := b.Get(i.currentHash) block = DeserializeBlock(encodedBlock) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }) i.currentHash = block.PrevBlockHash <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> block }</code> </pre> <br>  That's all about the database! <br><br><h3>  Command Line Interface (CLI) </h3><br>  So far, our implementation does not provide us with any interface for interacting with the program: we simply executed <code>NewBlockchain, bc.AddBlock</code> in <code>main</code> .  It's time to improve it!  We want to have such commands: <br><br><pre> <code class="bash hljs">blockchain_go addblock <span class="hljs-string"><span class="hljs-string">"Pay 0.031337 for a coffee"</span></span> blockchain_go printchain</code> </pre> <br>  All command line related operations will be processed by the <code>CLI</code> structure. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> CLI <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { bc *Blockchain }</code> </pre> <br>  The ‚Äúentry point‚Äù of the structure is the <code>Run</code> function <code>Run</code> <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cli *CLI)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { cli.validateArgs() addBlockCmd := flag.NewFlagSet(<span class="hljs-string"><span class="hljs-string">"addblock"</span></span>, flag.ExitOnError) printChainCmd := flag.NewFlagSet(<span class="hljs-string"><span class="hljs-string">"printchain"</span></span>, flag.ExitOnError) addBlockData := addBlockCmd.String(<span class="hljs-string"><span class="hljs-string">"data"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"Block data"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> os.Args[<span class="hljs-number"><span class="hljs-number">1</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"addblock"</span></span>: err := addBlockCmd.Parse(os.Args[<span class="hljs-number"><span class="hljs-number">2</span></span>:]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"printchain"</span></span>: err := printChainCmd.Parse(os.Args[<span class="hljs-number"><span class="hljs-number">2</span></span>:]) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: cli.printUsage() os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addBlockCmd.Parsed() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *addBlockData == <span class="hljs-string"><span class="hljs-string">""</span></span> { addBlockCmd.Usage() os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } cli.addBlock(*addBlockData) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> printChainCmd.Parsed() { cli.printChain() } }</code> </pre> <br>  We use the standard <a href="https://golang.org/pkg/flag/">flag</a> package for parsing command line arguments. <br><br><pre> <code class="go hljs">addBlockCmd := flag.NewFlagSet(<span class="hljs-string"><span class="hljs-string">"addblock"</span></span>, flag.ExitOnError) printChainCmd := flag.NewFlagSet(<span class="hljs-string"><span class="hljs-string">"printchain"</span></span>, flag.ExitOnError) addBlockData := addBlockCmd.String(<span class="hljs-string"><span class="hljs-string">"data"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"Block data"</span></span>)</code> </pre> <br>  To begin with, we create two <code>addblock</code> and <code>printchain</code> , then add the <code>-data</code> flag to the first one.  <code>printchain</code> does not require any flags. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> os.Args[<span class="hljs-number"><span class="hljs-number">1</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"addblock"</span></span>: err := addBlockCmd.Parse(os.Args[<span class="hljs-number"><span class="hljs-number">2</span></span>:]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"printchain"</span></span>: err := printChainCmd.Parse(os.Args[<span class="hljs-number"><span class="hljs-number">2</span></span>:]) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: cli.printUsage() os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br>  Then we check the command specified by the user and parse the associated subcommand. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addBlockCmd.Parsed() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *addBlockData == <span class="hljs-string"><span class="hljs-string">""</span></span> { addBlockCmd.Usage() os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } cli.addBlock(*addBlockData) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> printChainCmd.Parsed() { cli.printChain() }</code> </pre> <br>  Next, we check which subcommand we use, and start the associated function. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cli *CLI)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { cli.bc.AddBlock(data) fmt.Println(<span class="hljs-string"><span class="hljs-string">"Success!"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cli *CLI)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printChain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { bci := cli.bc.Iterator() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { block := bci.Next() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Prev. hash: %x\n"</span></span>, block.PrevBlockHash) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Data: %s\n"</span></span>, block.Data) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Hash: %x\n"</span></span>, block.Hash) pow := NewProofOfWork(block) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"PoW: %s\n"</span></span>, strconv.FormatBool(pow.Validate())) fmt.Println() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(block.PrevBlockHash) == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } }</code> </pre> <br>  This code is similar to the one that was before.  The only difference is that now we use the <code>BlockchainIterator</code> to iterate over the blocks in the blockchain. <br><br>  Also, don't forget to change the <code>main</code> function accordingly: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { bc := NewBlockchain() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> bc.db.Close() cli := CLI{bc} cli.Run() }</code> </pre> <br>  Note that a new <code>Blockchain</code> is created regardless of which command line arguments were passed. <br><br>  That's all!  Let's check that everything works as we expect: <br><br><pre> <code class="bash hljs">$ blockchain_go printchain No existing blockchain found. Creating a new one... Mining the block containing <span class="hljs-string"><span class="hljs-string">"Genesis Block"</span></span> 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b Prev. <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>: Data: Genesis Block Hash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b PoW: <span class="hljs-literal"><span class="hljs-literal">true</span></span> $ blockchain_go addblock -data <span class="hljs-string"><span class="hljs-string">"Send 1 BTC to Ivan"</span></span> Mining the block containing <span class="hljs-string"><span class="hljs-string">"Send 1 BTC to Ivan"</span></span> 000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13 Success! $ blockchain_go addblock -data <span class="hljs-string"><span class="hljs-string">"Pay 0.31337 BTC for a coffee"</span></span> Mining the block containing <span class="hljs-string"><span class="hljs-string">"Pay 0.31337 BTC for a coffee"</span></span> 000000aa0748da7367dec6b9de5027f4fae0963df89ff39d8f20fd7299307148 Success! $ blockchain_go printchain Prev. <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>: 000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13 Data: Pay 0.31337 BTC <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a coffee Hash: 000000aa0748da7367dec6b9de5027f4fae0963df89ff39d8f20fd7299307148 PoW: <span class="hljs-literal"><span class="hljs-literal">true</span></span> Prev. <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b Data: Send 1 BTC to Ivan Hash: 000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13 PoW: <span class="hljs-literal"><span class="hljs-literal">true</span></span> Prev. <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>: Data: Genesis Block Hash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b PoW: <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  (the <i>sound of opening a beer can</i> ) <br><br><h3>  Links </h3><br>  <a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-3/">Original article</a> <br>  <a href="https://habrahabr.ru/post/348672/">The first part of the series of articles</a> <br>  <a href="https://github.com/Jeiwan/blockchain_go/tree/part_3">Sources</a> <br>  <a href="https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2):_Data_Storage">Bitcoin Core Data Storage</a> <br>  <a href="https://github.com/boltdb/bolt">BoltDB</a> <br>  <a href="https://golang.org/pkg/encoding/gob/">encoding / gob</a> <br>  <a href="https://golang.org/pkg/flag/">flag</a> </div><p>Source: <a href="https://habr.com/ru/post/351296/">https://habr.com/ru/post/351296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351286/index.html">Environment for 1C-Bitrix based on Docker</a></li>
<li><a href="../351288/index.html">Bottom-Up Strategy for Implementing Changes in an Organization</a></li>
<li><a href="../351290/index.html">Negative selection of personnel in the hierarchical structure of the enterprise</a></li>
<li><a href="../351292/index.html">From Excel to EDS: how to organize convenient processing of materials for a scientific conference</a></li>
<li><a href="../351294/index.html">FastTrack Training. "Network Basics". "The Basics of Telephony." Part 2. Eddie Martin. December 2012</a></li>
<li><a href="../351298/index.html">Apache PHP MySQL bundle on Solaris 11.3</a></li>
<li><a href="../351300/index.html">Analysis of performance tasks with JBreak (part 2)</a></li>
<li><a href="../351304/index.html">Thymeleaf Tutorial: Chapter 7. Conditional Execution</a></li>
<li><a href="../351308/index.html">Comparison of open OLAP-systems Big Data: ClickHouse, Druid and Pinot</a></li>
<li><a href="../351310/index.html">SSH in humans is not secure enough. How I struggle with paranoia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>