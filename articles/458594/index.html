<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Do not forget to increase the chance of response to the client, using a second request in L7 balancing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Using nginx to balance HTTP traffic at the L7 level, it is possible to send a client request to the next application server if the target does not ret...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Do not forget to increase the chance of response to the client, using a second request in L7 balancing</h1><div class="post__text post__text-html js-mediator-article">  Using nginx to balance HTTP traffic at the L7 level, it is possible to send a client request to the next application server if the target does not return a positive response.  A sample of the passively checking the health of the application server showed the ambiguity of the documentation and the specificity of the server exclusion algorithms from the pool of working servers. <br><a name="habracut"></a><br><h2>  HTTP traffic balancing overview </h2><br>  There are various ways to balance HTTP traffic.  By OSI model levels, <a href="https://habr.com/ru/company/selectel/blog/250201/">there are balancing technologies</a> at the network, transport, and application levels.  Depending on the scope of the application <a href="https://habr.com/ru/company/mailru/blog/347026/">, their combinations can be used</a> . <br><br>  Traffic balancing technology has positive effects in the operation of the application and its maintenance.  Here are some of them.  Horizontal scaling of the application, in which the <a href="https://youtu.be/6NdxUY1La2I">load is distributed among several nodes</a> .  Planned decommissioning of an application server due to removal of a client request flow from it.  Implementation of the A / B strategy for testing the modified application functionality.  Improving application resiliency by <a href="https://habr.com/ru/company/okmeter/blog/423085/">sending requests to properly functioning application servers</a> . <br><br>  The last function is implemented in two modes.  In passive mode, the balancer in client traffic evaluates the responses of the target application server and, under certain conditions, excludes it from the pool of working servers.  In the active mode, the balancer periodically independently sends requests to the application server at a given URI, and, based on certain characteristics of the response, decides to exclude it from the pool of working servers.  Further, the balancer, under certain conditions, returns the application server to the pool of working servers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Passive check of the application server and its exclusion from the pool of working servers </h2><br>  Let us take a closer look at the passive check of the application server in the freely distributed nginx / 1.17.0 edition.  Application servers are selected alternately with Round Robin algorithm, their weights are the same. <br><br>  The three-step scheme presents a time section starting with sending a client request to the application server No. 2.  A bright indicator characterizes requests / responses between the client and the balancer.  Dark indicator - requests / responses between nginx and application servers. <br><br><img src="https://habrastorage.org/webt/vg/dl/yl/vgdlylmjdofsxs-iktkfimfaqr8.gif"><br><br>  In the third step, the diagram shows how the balancer redirects the client's request to the next application server, in case the target server responded with an error or did not respond at all. <br><br>  The list of HTTP and TCP errors for which the server uses the next server is specified in the directive <i>proxy_next_upstream</i> . <br><br>  By default, nginx redirects only <a href="https://tools.ietf.org/html/rfc7231">requests with idempotent HTTP methods</a> to the next application server. <br><br>  What does the client get?  On the one hand, the ability to redirect a request to the next application server increases the chances of providing a satisfactory response to the client when the target server fails.  On the other hand, it is obvious that sequential accessing first to the target server and then to the next one increases the total response time to the client. <br><br>  In the end, the client <a href="http_upstream_module.html">returns the response of the application server, on which the</a> <i>proxy_next_upstream_tries</i> <a href="http_upstream_module.html">valid attempts counter has ended</a> . <br><br>  When using the redirect function to the next working server, you need to further harmonize the timeouts on the balancer and application servers.  The upper limit of the travel time of the request between the application servers and the balancer is the client timeout, or the waiting time defined by the business.  When calculating timeouts, it is also necessary to take into account the stock of network events (delays / losses during the delivery of packets).  If the client closes the session every time out while the balancer gets a guaranteed response, the good intention to make the application reliable will be in vain. <br><br><img src="https://habrastorage.org/webt/th/wt/da/thwtdayvqkzx3tr6dvlbmou1a3q.jpeg"><br><br>  Management of the passive health check of application servers is performed by directives, for example, with the following variants of their values: <br><br><pre><code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> backend { <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> app01:<span class="hljs-number"><span class="hljs-number">80</span></span> weight=<span class="hljs-number"><span class="hljs-number">1</span></span> max_fails=<span class="hljs-number"><span class="hljs-number">5</span></span> fail_timeout=<span class="hljs-number"><span class="hljs-number">100s</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> app02:<span class="hljs-number"><span class="hljs-number">80</span></span> weight=<span class="hljs-number"><span class="hljs-number">1</span></span> max_fails=<span class="hljs-number"><span class="hljs-number">5</span></span> fail_timeout=<span class="hljs-number"><span class="hljs-number">100s</span></span>; } <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://backend; <span class="hljs-attribute"><span class="hljs-attribute">proxy_next_upstream</span></span> timeout http_500; <span class="hljs-attribute"><span class="hljs-attribute">proxy_next_upstream_tries</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; ... } ... }</code> </pre> <br>  As of <i>07/02/2019</i> , the documentation states that the <i>max_fails</i> parameter specifies the number of unsuccessful attempts to work with the server that must occur within the time specified by the <i>fail_timeout</i> parameter. <br><br>  The <i>fail_timeout</i> parameter specifies the time during which a specified number of failed attempts to work with the server should occur so that the server is considered unavailable;  and the time during which the server will be considered unavailable. <br><br>  In the given example of the part of the configuration file, the balancer is set to catch 5 failed hits for 100 seconds. <br><br><h2>  Returning the application server to the working server pool </h2><br>  As follows from the documentation, the balancer after the expiration of <i>fail_timeout</i> cannot consider the server inoperable.  But, unfortunately, the documentation is not explicitly stated how exactly the server‚Äôs performance is evaluated. <br><br>  Without an experiment, one can only assume that the state verification mechanism is similar to the previously described one. <br><br><h2>  Expectations and reality </h2><br>  In the presented configuration, the following behavior is expected from the balancer: <br><br><ol><li>  As long as the balancer does not exclude application server No. 2 from the pool of working servers, client requests will be sent to it. </li><li>  Requests returned with 500 errors from application server # 2 will be sent to the next application server, and the client will receive positive responses. </li><li>  As soon as the balancer within 5 seconds receives 5 responses with code 500, it will exclude application server No. 2 from the pool of working servers.  All requests following the 100 second window will be immediately sent to the remaining working application servers without additional time. </li><li>  After 100 seconds the balancer must somehow assess the performance of the application server and return it to the pool of working servers. </li></ol><br>  After conducting natural tests, according to the balancer journals, it was established that approval number 3 does not work.  The balancer eliminates an inoperative server as soon as the condition on the <i>max_fails</i> parameter is <i>met</i> .  Thus, a faulty server is excluded from service without waiting for the expiration of 100 seconds.  The <i>fail_timeout</i> parameter plays the role of only the upper limit of the error accumulation time. <br><br>  In part of statement number 4, it turns out that nginx checks the operation of the application server previously excluded from service with only one request.  And if the server still responds with an error, then the next check will take place after the <i>fail_timeout expires</i> . <br><br><h2>  What is missing? </h2><br><ol><li>  The algorithm implemented in nginx / 1.17.0 may not in a fair way check the server‚Äôs performance before returning it to the pool of working servers.  At least, according to the current documentation, not 1 request is expected, but the quantity specified in <i>max_fails</i> . </li><li>  The state check algorithm does not take into account the speed of requests.  The larger it is, the stronger the spectrum with unsuccessful attempts is shifted to the left, and the application server too quickly leaves the pool of working servers.  I suppose that this may have a negative impact on applications that allow themselves to ‚Äúgive short errors in clots‚Äù.  For example, when garbage collection. </li></ol><br><img src="https://habrastorage.org/webt/dg/5k/t2/dg5kt2myincbznycsx2owz_rh6w.jpeg"><br><br>  I wanted to ask you if there is a practical benefit from the server health check algorithm, which evaluates the speed of unsuccessful attempts? </div><p>Source: <a href="https://habr.com/ru/post/458594/">https://habr.com/ru/post/458594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45858/index.html">Drawbacks i.mail</a></li>
<li><a href="../458582/index.html">Amazon engineer created an interlocking device with AI, which does not allow a cat with street loot into the house</a></li>
<li><a href="../458584/index.html">Group-IB Webinar July 11, Malware Analysis for Beginners: Basic Approaches</a></li>
<li><a href="../45859/index.html">Mobius transformations - a visual explanation (video)</a></li>
<li><a href="../458590/index.html">Architectural approaches in iOS applications</a></li>
<li><a href="../4586/index.html">"Soup" explains its policy</a></li>
<li><a href="../45860/index.html">Website creation in Veliky Novgorod and other provincial cities</a></li>
<li><a href="../458604/index.html">Why the two largest electronics manufacturers joined forces in a new GPU project</a></li>
<li><a href="../458606/index.html">Run OpenVPN in Docker in 2 seconds</a></li>
<li><a href="../458614/index.html">Creating a React-Hook usePosition () to get and track browser coordinates</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>