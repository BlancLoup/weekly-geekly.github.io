<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>New C ++ 17 that everyone should use</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ladies and gentlemen, hello. 

 We have just completed the translation of an interesting book by Jacek Galovitsa about STL C ++ 17, which we hope to r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>New C ++ 17 that everyone should use</h1><div class="post__text post__text-html js-mediator-article">  Ladies and gentlemen, hello. <br><br>  We have just completed the translation of an interesting <a href="https://www.amazon.com/17-STL-Cookbook-Jacek-Galowicz/dp/178712049X">book by</a> <a href="https://galowicz.de/">Jacek Galovitsa</a> about STL C ++ 17, which we hope to release the sooner the better. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0v/b7/8d/0vb78dsfvggmcqqvpveje9iets8.jpeg"></div><br>  Today we want to bring to your attention the translation of the article by Julian Templeman from the site O'Reilly with a small announcement of the capabilities of the standard standard C ++ library library. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Happy New Year, everyone! <br><a name="habracut"></a><br>  C ++ 17 is a major new release with <a href="https://stackoverflow.com/questions/38060436/what-are-the-new-features-in-c17">over 100 new features</a> and significant changes.  If we talk about major changes, then in the new version nothing comparable in importance with the rvalue links that we received in C ++ 11 appeared, however, there are a lot of changes and additions, for example, structured bindings and new container types.  Moreover, a lot of work has been done to make the whole C ++ language more consistent, the developers have tried to <a href="https://isocpp.org/files/papers/p0636r0.html">remove useless and unnecessary behaviors from it</a> - for example, trigraph support and <code>std::auto_ptr</code> . <br><br>  In this article, we will discuss two of the most important innovations of C ++ 17, without which the developer can‚Äôt do without creating modern C ++ code.  It will be about structured bindings that provide a convenient new way of working with structured types, as well as some new types and containers that have been added to the Standard Library. <br><br><h2>  Structured bindings for multiple assignments </h2><br>  Structured bindings are a completely new phenomenon, and at the same time very useful.  They provide multiple assignments from structured types (for example, tuples, arrays, and structures) ‚Äîfor example, assigning all members of a structure to individual variables in a single assignment statement.  So the code turns out more compact and more clear. <br>  Code samples with structural bindings are run on Linux using the clang ++ version 4 compiler with the <code>-std=c++1z</code> flag, which activates C ++ 17 features. <br><br>  In C ++ 11, tuples appeared that are similar to arrays in that both of them are collections of fixed length, but may contain a mixture of different types.  With a tuple, you can return more than one value from a function, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tuple&gt; auto get() { return std::make_tuple("fred", 42); }</span></span></span></span></code> </pre><br>  This simple code returns a two-element tuple, and, starting with the C ++ 14 standard, you can use auto return types for this function, so the declaration of this function is much cleaner than otherwise.  Calling a function is simple, but retrieving values ‚Äã‚Äãfrom a tuple may look rather clumsy and illogical, and you may need <code>std::get</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t = get(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(t) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br>  You can also use <code>std::tie</code> to bind tuple members to variables that you first want to declare: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie(name, age) = get();</code> </pre> <br>  However, working with structured bindings in C ++ 17, you can bind members of tuples directly to named variables, and then there is no need for <code>std::get</code> , or you can first declare the variables: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [name, age] = get(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; name &lt;&lt; <span class="hljs-string"><span class="hljs-string">" is "</span></span> &lt;&lt; age &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br>  By working in this way, we can also get references to the members of the tuple, and this was not possible when using <code>std::tie</code> .  Here we get links to the members of the tuple and, when we change the value of one of them, the value of the whole tuple changes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [first, second] = t2; first += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"value is now "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(t2) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br>  The output will show that the value of <code>t2</code> has changed from 10 to 11. <br><br><h2>  Structured bindings for arrays and structures </h2><br>  The tuple case is most obvious, but structured bindings can also be used with arrays and structures, for example: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> age; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> city; }; Person p1{<span class="hljs-string"><span class="hljs-string">"bill"</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-string"><span class="hljs-string">"New York"</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [name, age, city] = p1; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; name &lt;&lt; <span class="hljs-string"><span class="hljs-string">"("</span></span> &lt;&lt; age &lt;&lt; <span class="hljs-string"><span class="hljs-string">") lives in "</span></span> &lt;&lt; city &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br>  With arrays in the same way: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span>, 6&gt; arr{<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [i, j, k, l, _dummy1, _dummy2] = arr;</code> </pre> <br>  In this implementation, there are a couple of flaws: <br><br>  Firstly - and this flaw is also relevant for <code>std::tie</code> - you have to bind all the elements.  Therefore, it is impossible, for example, to extract only the first four elements from an array.  If you want to partially extract the structure or array, simply substitute stub variables for those members that you do not need, as shown in the example with the array. <br>  Secondly (and this will disappoint programmers who are accustomed to using such an idea in functional languages, for example, in Scala and Clojure), destructurization acts only one level in depth.  Suppose I have a <code>Location</code> member in the Person structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Location</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> city; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> country; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> age; Location loc; };</code> </pre> <br>  You can construct <code>Person</code> and <code>Location</code> by using nested initialization: <br><br><pre> <code class="cpp hljs">Person2 p2{<span class="hljs-string"><span class="hljs-string">"mike"</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, {<span class="hljs-string"><span class="hljs-string">"Newcastle"</span></span>, <span class="hljs-string"><span class="hljs-string">"UK"</span></span>}};</code> </pre> <br>  It can be assumed that the binding in this case is useful for access to members, but in practice it turns out that such an operation is invalid: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [n, a, [c1, c2]] = p2; <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br>  Finally, I note that in this way you can extract members only from those classes in which the data you need is public and non-static.  This issue is discussed in more detail in the next article on structured bindings. <br><br><h2>  New library types and containers </h2><br>  A number of new and useful data types have also been added to the Standard Library in C ++ 17, some of which originated in Boost. <br>  The code in this section was tested in Visual Studio 2017. <br><br>  Probably the simplest type of <code>std::byte</code> - it represents a single byte.  For the representation of bytes, developers traditionally used <code>char</code> (signed or unsigned), but now there is a type that can be not only a character or an integer;  however, bytes can be converted to integer and back.  The <code>std::byte</code> designed to interact with the data store and does not support arithmetic operations, although it supports bitwise operations. <br><br>  <b>std :: variant</b> <br><br>  The concept of "option" may seem familiar to those who dealt with Visual Basic.  A variant is a type-safe union, which at a given moment of time contains the value of one of the alternative types (and there can be no references, arrays or <code>'void'</code> ). <br><br>  A simple example: let's say there is some data where a person‚Äôs age can be represented as an integer or as a string with a date of birth.  Such information can be represented using a variant containing an unsigned integer or string.  Assigning an integer to a variable, we set the value, and then we can extract it with <code>std::get</code> , like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::variant&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; age; age = <span class="hljs-number"><span class="hljs-number">51</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(age);</code> </pre> <br>  If you try to use a member that is not defined in this way, the program will throw an exception: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(age) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_variant_access &amp;ex) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Doesn't contain a string"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  Why use <code>std::variant</code> , but not the usual union?  Basically, because unions are present in the language primarily for compatibility with C and do not work with objects that are not related to POD-types.  This, in particular, implies that it‚Äôs not so easy to put members into a union with copies of custom copy constructors and destructors.  With <code>std::variant</code> there are no such restrictions. <br><br>  <b>std :: optional</b> <br><br>  The other type, <code>std::optional</code> , is surprisingly useful and in practice provides capabilities that exist in many functional languages.  <code>'optional'</code> is an object that may or may not contain values;  this object is convenient to use as the return value of a function when it cannot return a value;  then it serves as an alternative, for example, to a null pointer. <br><br>  Working with <code>optional</code> , we gain an additional advantage: now the possibility of a function failure is clearly indicated directly in the declaration, and, since we have to extract a value from optional, the probability that we accidentally use a zero value is significantly reduced. <br><br>  The following example defines a conversion function that attempts to turn a string into an integer.  Returning to <code>optional</code> , the function leaves this possibility: an invalid string can be passed, which cannot be converted.  The caller uses the <code>value_or</code> function to get the value from <code>optional</code> , and if the function fails, it returns the default value of zero (if the conversion failed). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;experimental/optional&gt; using namespace std::experimental; optional&lt;int&gt; convert(const std::string&amp; s) { try { int res = std::stoi(s); return res; } catch(std::exception&amp;) { return {}; } } int v = convert("123").value_or(0); std::cout &lt;&lt; v &lt;&lt; std::endl; int v1 = convert("abc").value_or(0); std::cout &lt;&lt; v1 &lt;&lt; std::endl;</span></span></span></span></code> </pre> <br>  <b>std :: any</b> <br><br>  Finally, there is <code>std::any</code> , which provides a type-safe container for a single value of any type (provided that it has a constructor when copying).  You can check whether any contains any value and extract this value with <code>std::any_cast</code> , like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;experimental/any&gt; using namespace std::experimental; std::vector&lt;any&gt; v { 1, 2.2, false, "hi!" }; auto&amp; t = v[1].type(); //     std::any? if (t == typeid(double)) std::cout &lt;&lt; "We have a double" &lt;&lt; "\n"; else std::cout &lt;&lt; "We have a problem!" &lt;&lt; "\n"; std::cout &lt;&lt; any_cast&lt;double&gt;(v[1]) &lt;&lt; std::endl;</span></span></span></span></code> </pre> <br>  You can use the <code>type()</code> member to get a <code>type_info</code> object that says what is contained in <code>any</code> .  An exact match between the types is required, otherwise the program will throw an exception <code>std::bad_any_cast</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; any_cast&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(v[<span class="hljs-number"><span class="hljs-number">1</span></span>]) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_any_cast&amp;) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"wrong type"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br>  When can this type of data come in handy?  The simple answer is in all cases when one could use the pointer <code>void*</code> , but in this case type safety is guaranteed.  For example, you may need different representations of the base value: say, represent '5' both as an integer and as a string.  Such cases are common in interpreted languages, but can be useful in cases where a representation is required that will not be automatically converted. <br><br>  In this article, only two new C ++ 17 issues are reviewed, and I recommend that any C ++ specialist also get acquainted with all the other new products. <br><br>  Major compilers, including GCC, Clang and MSVC, already support many of these innovations;  More on this <a href="http://en.cppreference.com/w/cpp/compiler_support">here</a> . <br><br>  There are some very good summarizing articles on the Internet with descriptions of various innovations that appeared in C ++ 17, among which I would especially note <a href="">Tony van Erd</a> 's article, a detailed article on <a href="https://stackoverflow.com/questions/38060436/what-are-the-new-features-in-c17">StackOverflow</a> and an <a href="http://www.bfilipek.com/2017/01/cpp17features.html">excellent article by</a> Bartek. </div><p>Source: <a href="https://habr.com/ru/post/345560/">https://habr.com/ru/post/345560/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345542/index.html">How changing two lines of code can take several days</a></li>
<li><a href="../345546/index.html">Asynchronous loading of large datasets into Tensorflow</a></li>
<li><a href="../345550/index.html">How EdTech Leaders Earn</a></li>
<li><a href="../345552/index.html">Service Workers. Instructions for use</a></li>
<li><a href="../345556/index.html">Load testing "non-HTTP". Part 1 JMeter</a></li>
<li><a href="../345566/index.html">My strategy for the Russian AI Cup 2017</a></li>
<li><a href="../345570/index.html">Checklist of troubles that may occur when moving</a></li>
<li><a href="../345574/index.html">Tcl / Tk - creating extensions / packages based on dynamic libraries</a></li>
<li><a href="../345576/index.html">Developing AI for a turn-based game on Node.js (part 1)</a></li>
<li><a href="../345578/index.html">Bitcoin will not become new digital money: limited emission and money functions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>