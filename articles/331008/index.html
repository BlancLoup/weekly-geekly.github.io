<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>AsyncDisplayKit 2.0 (Texture) Tutorial: Automatic Layout</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Welcome to the second part of the AsyncDisplayKit (Texture) series! 


 The AsyncDisplayKit layout system allows you to write an incredibly fast, decl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>AsyncDisplayKit 2.0 (Texture) Tutorial: Automatic Layout</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/16d/b61/39d/16db6139d3714a519eda45caad8f4d8b.png"></p><br><p>  Welcome to the second part of the AsyncDisplayKit (Texture) series! </p><br><p>  The AsyncDisplayKit layout system allows you to write an incredibly fast, declarative code. </p><br><p>  In addition to quick setup, it automatically adapts to the device on which the application is running.  Suppose you are trying to create a node that can be used in the view controller of the application or as a popover in an iPad application.  If its layout is correctly created, you can move the node to this new environment without worrying about changing the basic layout code! </p><a name="habracut"></a><br><p><img src="https://habrastorage.org/web/652/7ce/13a/6527ce13a5d545d695faedd67d7d087c.gif"></p><br><p>  In this tutorial, AsyncDisplayKit 2.0, you will return to the <strong>CardNode</strong> class from the <a href="https://www.raywenderlich.com/124696/asyncdisplaykit-2-0-tutorial-automatic-layout">first part</a> and learn about the layout specifications that were used to create it.  You will see how easy it is to make layout specifications to get the desired result. </p><br><h2 id="problema-s-auto-layout">  The problem with Auto Layout </h2><br><p>  I hear you shout: ‚ÄúWhat's wrong with Auto Layout?!‚Äù In Auto Layout, every spaceline you create is represented as an equation in the system of equations.  This means that each added constraint increases the calculation time of the constraints exponentially.  This calculation is always performed in the main thread. </p><br><p>  One of the goals of ASDK design is to adhere to the UIKit API as best you can.  Unfortunately, Auto Layout is an opaque system in which there is no way to perform the calculation of the constraints in another stream. </p><br><h2 id="davayte-nachnem">  let's start </h2><br><p>  To get started, download your start project <a href="">from here</a> .  Since you‚Äôll study part of the layout specifications, you should start with a modified version of the finished product from the first tutorial on AsyncDisplayKit 2.0. </p><br><blockquote>  <strong>Note</strong> : Before you start working with the tutorial on AsyncDisplayKit 2.0, read the <a href="https://habrahabr.ru/company/mobileup/blog/329002/">first part</a> . </blockquote><br><h2 id="znakomstvo-s-aslayoutspec">  Introduction to ASLayoutSpec </h2><br><p>  Before you begin, I will tell you a little background. </p><br><p>  Layout specifications are a generalization of the layout system, which is briefly described in the <a href="https://youtu.be/OiY1cheLpmI%3Ft%3D14m56s">Building Paper Event</a> .  The idea is to unify the calculation and application of the sizes and positions of the node and sub-nodes, and be able to reuse them. </p><br><p>  In ASDK 1.9.X, you could create asynchronous layouts, but the layout code was similar to the pre-auto layout in <strong>UIKit</strong> .  The size of the node <strong>subnodes</strong> could be calculated in the <strong>-calculateSizeThatFits:</strong> method.  These sizes could be cached and then added later in <strong>-layout</strong> .  And the positions of the nodes still had to be calculated using good old mathematics ‚Äî no one likes to tinker with mathematics. </p><br><p><img src="https://habrastorage.org/web/54b/ecb/227/54becb22764544e6a606c91271a9f4c2.png"></p><br><h2 id="specifikaciya-maketa">  Layout Specification </h2><br><p>  In ASDK 2.0, ASDisplayNode subclasses can implement <strong>-layoutSpecThatFits:.</strong>  An object of the <strong>ASLayoutSpec</strong> class determines the size and position of all subnodes.  In doing so, the layout specification also determines the size of the mentioned parent node. </p><br><p>  The node will return the layout specification object from <strong>-layoutSpecThatFits:.</strong>  This object will determine the size of the node, as well as the size and position of all its subnodes recursively. </p><br><p>  The <strong>ThatFits</strong> argument is an object of class <strong>ASSizeRange</strong> .  It has two properties of type <strong>CGSize</strong> (min and max), which determine the smallest and largest dimensions of the node. </p><br><p>  ASDK provides many different kinds of specifications.  Here are some of them: </p><br><ul><li>  <strong>ASStackLayoutSpec</strong> : Allows you to define a vertical or horizontal stack of children.  The <strong>justifyContent</strong> property determines the distance between children in the direction of the stack, and the <strong>alignItem</strong> s determines their distance along the opposite axis.  This specification is configured in the same way as UIKit <strong>UIStackView</strong> . </li><li>  <strong>ASOverlayLayoutSpec</strong> : Allows you to stretch one element of the layout over another.  The object that overlaps it must have an intrinsic content size for this to work. </li><li>  <strong>ASRelativeLayoutSpec</strong> : Places an element in a relative position within its available space.  Think of nine sections of <a href="https://youtu.be/vvGVsmWdjyw%3Ft%3D4m54s">nine sliced ‚Äã‚Äãimages</a> .  You can place an object in one of these sections. </li><li>  <strong>ASInsetLayoutSpec</strong> : Allows you to indent around an existing object.  Do you want classic ‚ÄúiOS 16 pixel indents‚Äù around your cell?  No problems! </li></ul><br><h2 id="aslayoutelement-protokol">  ASLayoutElement protocol </h2><br><p>  Layout specifications control the layout of one or more children.  An element can be a node, such as <strong>ASTextNode</strong> or <strong>ASImageNode</strong> .  In addition to nodes, a child layout specification template can also be another layout specification. </p><br><p>  Hey, how is this possible? </p><br><p>  Child elements of the layout specification must comply with the <strong>ASLayoutElement</strong> protocol.  <strong>ASLayoutSpec</strong> and <strong>ASDisplayNode</strong> correspond to <strong>ASLayoutElement</strong> , so both types and their subclasses can be child elements. </p><br><p><img src="https://habrastorage.org/web/dbe/dcf/16d/dbedcf16d06b4661a5b0b20929c5c37a.png"></p><br><p>  This simple concept turns out to be incredibly powerful.  One of the most important characteristics of the layout is <strong>ASStackLayoutSpec</strong> .  The ability to place an image and text is one thing, but to place an image and another stack is another! </p><br><p>  You are absolutely right.  It's time to duel!  I mean, write code ... </p><br><p><img src="https://habrastorage.org/web/677/a78/a1c/677a78a1cb284ceba80152c44755a597.png"></p><br><h2 id="razmeschenie-izobrazheniya-zhivotnogo">  Placing an image of an animal </h2><br><p>  So, you are at work, and your designer sent you a screenshot of what he wants for the new Encyclopedia for Animals application you are working on. </p><br><p><img src="https://habrastorage.org/web/6ff/8dc/e38/6ff8dce38cbc43628669f1afc6aea671.png"></p><br><p>  The first thing to do is to split the screen into appropriate layout specifications in order to understand the overall layout.  Sometimes this can lead to a stupor, but remember that the power of the layout depends on how easily they can be assembled.  Start simple. </p><br><p>  Looking ahead, I can only say that the upper and lower halves will work fine on the stack together.  Now that you know this, you can place the two halves separately and combine them at the end. </p><br><p>  Unzip the startup project and open <strong>RainforestStarter.xcworkspace</strong> .  Go to <strong>CardNode.m</strong> to the <strong>-layoutSpecThatFits:</strong> method.  Now it simply returns an empty <strong>ASLayoutSpec</strong> object. </p><br><p>  If you compile and run the project, you will see the following: </p><br><p><img src="https://habrastorage.org/web/3dc/f86/485/3dcf8648597d4bde88013f2d2b451a6a.png"></p><br><p>  Well, this is just the beginning.  How about showing the image of the animal first? </p><br><p>  By default, the network image node has no content and, therefore, does not have its own size.  Looking at the screenshot, we can say that the image of the animal should occupy the full width of the screen and 2/3 of the height. </p><br><p>  To do this, replace the existing <strong>return statement with the</strong> following: </p><br><pre><code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//1 CGFloat ratio = constrainedSize.min.height/constrainedSize.min.width; //2 ASRatioLayoutSpec *imageRatioSpec = [ASRatioLayoutSpec ratioLayoutSpecWithRatio:ratio child:self.animalImageNode]; //3 return imageRatioSpec;</span></span></code> </pre> <br><p>  Consider each numbered comment in turn: </p><br><ol><li>  <strong>Calculate Ratio</strong> : First, you determine the ratio you want to apply to your image.  Ratios are determined by height / width.  Here you indicate that the height of this image should be 2/3 of the minimum height of the cell, which is the height of the screen. </li><li>  <strong>Create Ratio Layout Spec</strong> : Then you create a new <strong>ASRatioLayoutSpec</strong> using the calculated relation and the <strong>childImageNode</strong> child element. </li><li>  <strong>Return a Spec</strong> : The returned <strong>imageRatioSpec</strong> determines the height and width of the cell. </li></ol><br><p>  Compile and run to see what your layout looks like: </p><br><p><img src="https://habrastorage.org/web/66d/d3d/c1a/66dd3dc1a6c34b6497eece647fb34fa2.png"></p><br><p>  Pretty easy, huh?  Since the image is the only element that has a size, the cells are stretched to adjust to it. </p><br><blockquote>  <strong>Note</strong> : <strong>constrainedSize</strong> passed to the table node cell consists of the minimum (0, 0) and maximum value ( <strong>tableNodeWidth, INF</strong> ).  Therefore, you need to use <strong>preferredFrameSize</strong> to determine the height of the image.  <strong>preferredFrameSize</strong> was set to <strong>AnimalPagerController</strong> in Part 1. </blockquote><br><h2 id="dobavlenie-gradienta">  Add gradient </h2><br><p>  Now that you have an image of an animal, the next logical step is to add a gradient node on top of it. </p><br><p>  ASOverlayLayoutSpec is just a specification for work. </p><br><p>  First add the following line after <strong>imageRatioSpec</strong> initialization: </p><br><pre> <code class="objectivec hljs">ASOverlayLayoutSpec *gradientOverlaySpec = [ASOverlayLayoutSpec overlayLayoutSpecWithChild:imageRatioSpec overlay:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.gradientNode];</code> </pre> <br><p>  When creating your layout specifications, you always get those that contain the rest.  It's time for <strong>gradientOverlaySpec</strong> . </p><br><p>  Replace the current <strong>return with the</strong> following. </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gradientOverlaySpec;</code> </pre> <br><p>  Compile and run to see the gradient stretched across each <strong>imageNode</strong> object. </p><br><p>  The gradient for each bird is great! </p><br><p><img src="https://habrastorage.org/web/236/713/1e7/2367131e7a194e4f8d18351737ee4af0.png"></p><br><h2 id="dobavlenie-teksta-s-imenem-zhivotnogo">  Add text with animal name </h2><br><p>  The only thing left to do is add the name of the animal. </p><br><p>  Although the task seems simple, there are several requirements to consider: </p><br><ol><li>  The name should be placed on top of the gradient. </li><li>  The name should be in the lower left corner of the image of the animal. </li><li>  Indent - 16 points on the left and 8 below. </li></ol><br><p>  You already know how to place text on top.  The time has come to break out of the proven and true specification of the overlay. </p><br><p>  Add the following line immediately after <strong>gradientOverlaySpec</strong> </p><br><pre> <code class="objectivec hljs">ASOverlayLayoutSpec *nameOverlaySpec = [ASOverlayLayoutSpec overlayLayoutSpecWithChild:gradientOverlaySpec overlay:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.animalNameTextNode];</code> </pre> <br><p>  In addition, you need to change the <strong>return statement</strong> to the following: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nameOverlaySpec;</code> </pre> <br><p>  Compile and run the application to see the text on the screen: </p><br><p><img src="https://habrastorage.org/web/62f/255/175/62f255175c4840bbbccbce64cfecf0e7.png"></p><br><p>  Not bad.  You just need to move this text to the bottom corner. </p><br><p>  It is worth mentioning the general case that you come across.  You have text on a bird, so the natural desire is to wrap the <strong>OverlaySpec</strong> into other specifications to place it where you want.  As a rule, you need to take a step back and think about what you are trying to express. </p><br><p>  In this case, you use <strong>nameOverlaySpec</strong> to extend anything else on top of existing content. </p><br><p>  In fact, you do not want to expand the name of the content.  You just want to say the name that it should be in the lower left corner of your free space, and then stretch this layout specification to the available space. </p><br><h2 id="znakomstvo-s-asrelativelayoutspec">  Introduction to ASRelativeLayoutSpec </h2><br><p>  Actually, you need <strong>ASRelativeLayoutSpec</strong> . </p><br><p>  <strong>ASRelativeLayoutSpec</strong> takes an <strong>ASLayoutElement</strong> child object, examines the space in which it is available, and then places this child element according to your instructions. </p><br><p>  When determining the relative specification, you can set its <strong>verticalPosition</strong> and <strong>horizontalPosition</strong> properties. </p><br><p>  These two properties may be as follows: </p><br><ul><li>  <strong>ASRelativeLayoutSpecPositionStart</strong> </li><li>  <strong>ASRelativeLayoutSpecPositionCenter</strong> </li><li>  <strong>ASRelativeLayoutSpecPositionEnd</strong> </li></ul><br><p>  The combination allows you to place the object in one of the corners, edges or in the center of the available space. </p><br><p>  As an exercise: how would you put this frog on the right edge of free space? </p><br><p><img src="https://habrastorage.org/web/34f/946/071/34f946071dfa434cb96a45ba9ae1617a.png"></p><br><p>  If you said: ‚ÄúSet the verticalPosition to <strong>ASRelativeLayoutSpecPositionCenter</strong> and <strong>horizontalPosition</strong> to <strong>ASRelativeLayoutSpecPositionEnd</strong> ‚Äù, then you are right! </p><br><p>  Now that you've practiced, the next line should make a little more sense.  Add this line right before <strong>nameOverlaySpec</strong> : </p><br><pre> <code class="objectivec hljs">ASRelativeLayoutSpec *relativeSpec = [ASRelativeLayoutSpec relativePositionLayoutSpecWithHorizontalPosition:ASRelativeLayoutSpecPositionStart verticalPosition:ASRelativeLayoutSpecPositionEnd sizingOption:ASRelativeLayoutSpecSizingOptionDefault child:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.animalNameTextNode];</code> </pre> <br><p>  So you set the horizontalPosition of the child to start and the verticalPosition to complete.  In frog language, it would look something like this: </p><br><p><img src="https://habrastorage.org/web/84c/536/aea/84c536aea1334264a32c2cce9432c00b.png"></p><br><p>  Now that you have a relative specification, change the <strong>nameOverlaySpec</strong> definition to the following: </p><br><pre> <code class="objectivec hljs">ASOverlayLayoutSpec *nameOverlaySpec = [ASOverlayLayoutSpec overlayLayoutSpecWithChild:gradientOverlaySpec overlay:relativeSpec];</code> </pre> <br><p>  Compile and run to see what you got: </p><br><p><img src="https://habrastorage.org/web/1ed/5a5/057/1ed5a505701648e1b9aedbfd0e1182aa.png"></p><br><p>  Good!  Only there is one more thing to do in this half of the cell. </p><br><h2 id="znakomstvo-s-asinsetlayoutspec">  Introduction to ASInsetLayoutSpec </h2><br><p>  The last thing you need to do is put the name of the animal 16 points to the left and 8 points down.  To do this, you have <strong>ASInsetLayoutSpec</strong> . </p><br><p>  To add a small indent around any of your objects, simply wrap the object in the insert specification and let the <strong>UIEdgeInsets</strong> determine what indent you need. </p><br><p>  Add the following line after <strong>nameOverlaySpec</strong> : </p><br><pre> <code class="objectivec hljs">ASInsetLayoutSpec *nameInsetSpec = [ASInsetLayoutSpec insetLayoutSpecWithInsets:<span class="hljs-built_in"><span class="hljs-built_in">UIEdgeInsetsMake</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">16.0</span></span>, <span class="hljs-number"><span class="hljs-number">8.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>) child:nameOverlaySpec];</code> </pre> <br><p>  Then change the <strong>return statement</strong> again to return the outermost specification. </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nameInsetSpec;</code> </pre> <br><p>  Compile and run. </p><br><p><img src="https://habrastorage.org/web/3e2/654/8d5/3e26548d5c384b47aac974710d815ef0.png"></p><br><p><img src="https://habrastorage.org/web/4c2/985/763/4c2985763eba4389a089acc2821b5989.png"></p><br><p>  You do not want the insert to be applied to the entire area covered by the overlay, as it includes the image of your animal. </p><br><p>  What you really want is to apply an insert to the <strong>relativeSpec</strong> space.  To fix this, first delete the current <strong>nameInsetSpec</strong> . </p><br><p>  Then add the following new and improved version right before the definition of the <strong>nameOverlaySpec</strong> : </p><br><pre> <code class="objectivec hljs">ASInsetLayoutSpec *nameInsetSpec = [ASInsetLayoutSpec insetLayoutSpecWithInsets:<span class="hljs-built_in"><span class="hljs-built_in">UIEdgeInsetsMake</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">16.0</span></span>, <span class="hljs-number"><span class="hljs-number">8.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>) child:relativeSpec];</code> </pre> <br><p>  Now you need <strong>nameOverlaySpec</strong> to apply a new insert, not <strong>relativeSpec</strong> .  Replace the <strong>nameOverlaySpec</strong> definition with: </p><br><pre> <code class="objectivec hljs">ASOverlayLayoutSpec *nameOverlaySpec = [ASOverlayLayoutSpec overlayLayoutSpecWithChild:gradientOverlaySpec overlay:nameInsetSpec];</code> </pre> <br><p>  Finally, go back to: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nameOverlaySpec;</code> </pre> <br><p>  Now compile and run to see what happened: </p><br><p><img src="https://habrastorage.org/web/c09/bee/a0b/c09beea0bd4143609bead4f85e59647b.png"></p><br><p>  Half the work is done! </p><br><h2 id="nizhnyaya-polovina">  Bottom half </h2><br><p>  The second half is a little easier.  This is just a description of the animal with an insert around it ... and you already know how to do it. </p><br><p>  Add the following line before the <strong>return statement</strong> to create an insert with the description text. </p><br><pre> <code class="objectivec hljs">ASInsetLayoutSpec *descriptionTextInsetSpec = [ASInsetLayoutSpec insetLayoutSpecWithInsets:<span class="hljs-built_in"><span class="hljs-built_in">UIEdgeInsetsMake</span></span>(<span class="hljs-number"><span class="hljs-number">16.0</span></span>, <span class="hljs-number"><span class="hljs-number">28.0</span></span>, <span class="hljs-number"><span class="hljs-number">12.0</span></span>, <span class="hljs-number"><span class="hljs-number">28.0</span></span>) child:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.animalDescriptionTextNode];</code> </pre> <br><p>  If you returned this insert and then compiled and launched the application, you would see the following: </p><br><p><img src="https://habrastorage.org/web/ee9/d6a/47f/ee9d6a47f6054e30997fefbb0d05aae3.png"></p><br><p>  This is exactly what you wanted.  Now that we have dealt with both halves, it is quite easy to combine them together. </p><br><h2 id="vnutrennie-razmery-kontenta">  The internal dimensions of the content </h2><br><p>  You do not need to worry that the text has the size of the content to fill the space.  This is because <strong>ASTextNode</strong> has its internal content size based on its text and attributes. </p><br><p>  The following nodes do not have default size: </p><br><ul><li>  Subclasses of <strong>ASDisplayNode</strong> </li><li>  <strong>ASNetworkImageNode</strong> and <strong>ASMultiplexImageNode</strong> </li><li>  <strong>ASVideoNode</strong> and <strong>ASVideoPlayerNode</strong> </li></ul><br><p>  The common thing is that these sites have no initial content and, therefore, there is no way to determine their own size.  They must either have <strong>preferredFrameSize</strong> , or be placed in the layout specification, before they have a specific size to work with. </p><br><h2 id="znakomstvo-s-asstacklayoutspec">  Introduction to ASStackLayoutSpec </h2><br><p>  This is the perfect time to use the stack layout specification.  You can think of it as a layout specification equivalent to <strong>UIStackView</strong> , excluding its automatic backward compatibility, which is quite elegant. </p><br><p>  Stacks can be defined both vertical and horizontal.  And like everything else, layout specifications can accept either nodes or other markup as child elements. </p><br><p>  To configure this stack, add these three lines after defining the insert description: </p><br><pre> <code class="objectivec hljs">ASStackLayoutSpec *verticalStackSpec = [[ASStackLayoutSpec alloc] init]; verticalStackSpec.direction = ASStackLayoutDirectionVertical; verticalStackSpec.children = @[nameOverlaySpec, descriptionTextInsetSpec];</code> </pre> <br><p>  Here you create a stack, setting its direction to vertical and adding the top half and bottom half as children. </p><br><p>  And return the new layout specification again. </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> verticalStackSpec;</code> </pre> <br><p>  Compile and run.  Almost done! </p><br><p><img src="https://habrastorage.org/web/3ef/d28/a58/3efd28a5862d44898f3f97c4a06a57d4.png"></p><br><blockquote>  <strong>Note</strong> : As mentioned earlier, stacks are one of the most important layout specifications.  Most layouts can be expressed as stacks or a series of nested stacks. </blockquote><p>  The nesting of the stacks, each with its own <strong>justifyContent</strong> and <strong>alignItems settings</strong> , means that they can be incredibly expressive as well as incredibly frustrating.  Do not forget to see the <a href="http://nguyenhuy.github.io/froggy-asdk-layout/">flex box froggy game</a> and <a href="http://asyncdisplaykit.org/docs/automatic-layout-containers.html">Async Display Kit docs</a> for more in-depth study. </p><br><h2 id="znakomstvo-s-asbackgroundlayoutspec">  Meet ASBackgroundLayoutSpec </h2><br><p>  Remember the overlay specification?  One of the rules is that the object that is superimposed on it must have its own size. </p><br><p>  The element at the back determines the size, and the element at the front just stretches over it. </p><br><p>  The background specification is exactly the opposite.  If you have one element that can define its own size, and the other you want to stretch it, you will need a background specification. </p><br><p>  In this case, you need to use the background layout specification to stretch the image of the blurred animal. </p><br><p>  To do this, add the following line: </p><br><pre> <code class="objectivec hljs">ASBackgroundLayoutSpec *backgroundLayoutSpec = [ASBackgroundLayoutSpec backgroundLayoutSpecWithChild:verticalStackSpec background:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.backgroundImageNode];</code> </pre> <br><p>  And replace the <strong>return statement</strong> </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> backgroundLayoutSpec;</code> </pre> <br><p>  Compile and run to see what happened: </p><br><p><img src="https://habrastorage.org/web/652/7ce/13a/6527ce13a5d545d695faedd67d7d087c.gif"></p><br><p>  The completed project is available here.  I repeat that there is also a version for Swift. </p><br><p>  Once you understand these concepts, start exploring the documentation.  It was just a small overview of what the layout system is capable of. </p><br><p>  We hope you like this tutorial AsyncDisplayKit 2.0, and if you have any questions, feel free to leave them in the comments! </p><br><p>  PS Special thanks to <a href="https://habrahabr.ru/users/beatasunshine/" class="user_link">BeataSunshine</a> and <a href="https://habrahabr.ru/users/evgen/" class="user_link">evgen</a> for their help in translating the article. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/331008/">https://habr.com/ru/post/331008/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330996/index.html">NTT Com announced the creation of the world's first fully software-defined network</a></li>
<li><a href="../330998/index.html">Fujitsu has developed virtual machine management technology that improves server utilization</a></li>
<li><a href="../331000/index.html">MyTaskHelper.ru in practice: creating a free database to check the results of the OGE</a></li>
<li><a href="../331002/index.html">Database Encryption Running Firebird 3.0</a></li>
<li><a href="../331006/index.html">Redmine + Mercurial project management system on Ubuntu 16.04</a></li>
<li><a href="../331010/index.html">Interplanetary File System - no longer need to copy to the network</a></li>
<li><a href="../331014/index.html">Interplanetary File System - We localize the global gateway or sites in IPFS</a></li>
<li><a href="../331016/index.html">Overview of server monitoring systems. Replacing munin with ...</a></li>
<li><a href="../331018/index.html">Lecture on sports programming in the framework of the Intellect project</a></li>
<li><a href="../331020/index.html">Microsoft Azure Media Services - an overview of the main features of the platform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>