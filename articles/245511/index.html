<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Analog video capture with STM32F4-DISCOVERY</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I will discuss how to capture an analog black-and-white video signal using the STM32F4-DISCOVERY board, and about the features of tra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Analog video capture with STM32F4-DISCOVERY</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/0b9/7dc/4d6/0b97dc4d6ba3afc23c740e14b16aaca9.jpg" alt="image" align="right"><br>  In this article, I will discuss how to capture an analog black-and-white video signal using the STM32F4-DISCOVERY board, and about the features of transferring it to a computer using USB. <br><a name="habracut"></a><br><h4>  Transferring images to a computer via USB </h4><br>  Using the STM32F4-DISCOVERY board, you can create various USB devices - the USB peripheral module in the microcontroller used has great functionality.  But there are few examples of unusual designs using it on the network - in most cases, USB is used to implement the HID classes (emulation of keyboards, mice and joysticks) and CDC (COM port emulation).  The built-in USB host is usually used to connect USB flash drives. <br><br>  I wanted to make some unusual USB device, such as a webcam.  You can implement it in two ways - write your own USB device class, and a driver for it, or, much easier, use the USB standard <a href="http://en.wikipedia.org/wiki/USB_video_device_class">USB video device class</a> ( <a href="http://en.wikipedia.org/wiki/USB_video_device_class">USB video device class</a> ).  Drivers for such devices are built even in Windows XP.  The basic description on UVC can be found in <a href="http://code.google.com/p/rember-english-word/source/browse/trunk/USB_Video_Class_1.0a.pdf%3Fr%3D6">this</a> document (I used the version of UVC 1.0, although there is a newer 1.1). <br>  There are very few examples of the implementation of UVC on a microcontroller on the Internet.  Quite a lot of complexity is the proper compilation of device descriptors (descriptors describe all its functionality).  Even a small error in the descriptor can cause the device to appear to be detected, or even to the BSOD.  You can copy descriptors from an existing webcam, but they can be unnecessarily complicated - cameras often contain a microphone, allow you to capture a single image (Still image capture in UVC terminology), allow you to change a large number of camera settings.  It‚Äôs easy to get confused in all this, so I wanted to make the project as simple as possible. <br>  After a long search, I accidentally stumbled upon such a <a href="http://code.google.com/p/lxyppc-tetrix/">Chinese project</a> .  This is Tetris for STM32F103, and a computer is used to display the image, which sees the controller as a UVC device.  The project even implemented MJPEG coding.  The project is quite interesting, but the code is incredibly confusing, with almost no comments.  I took the descriptors from it, and slightly corrected them to fit my requirements. <br><br>  When compiling descriptors, among other things, you need to specify the parameters of the transmitted image.  I settled on an image size of 320x240 pixels and an NV12 image format.  The UVC standard allows you to bring only two formats of uncompressed images: NV12 and YUY2. <br>  The second format is more common, but NV12 is more suitable for encoding black and white images and takes up less space.  In this format, data is encoded as YUV 4: 2: 0 (for four pixels there are two bytes of color information).  First comes the information about the brightness of the entire image (320 * 240 bytes in my case), then the color information (bytes U and V alternately): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/eb1/360/70c/eb136070c729d5419220408a627a47ae.gif" alt="image"><br><br>  The total image will be (320 * 240 * 3/2) bytes.  This format has a flaw - not all programs can work with it.  Guaranteed with this format works free program ContaCam, Skype also worked fine. <br>  In order to upload test images to the controller, a special converter was written, issuing .h files with encoded image data.  In addition to NV12, the converter can encode images to YUY2 format. <br>  A detailed description of how to properly configure descriptors and transmit data in the case of uncompressed images can be found in a separate document: " <a href="http://www.cajunbot.com/wiki/images/8/88/USB_Video_Payload_Uncompressed_1.1.pdf">Universal Serial Bus Device Class Definition for Video Devices: Uncompressed Payload</a> " <br><br>  As a basic project, I took my <a href="http://we.easyelectronics.ru/STM32/usb-mikrofon-na-baze-stm32f4-discovery.html">USB microphone</a> project.  It also implemented data transfer to a computer through an isochronous endpoint.  Work with USB is implemented using the library from the controller manufacturer (STSW-STM32046).  After replacing the descriptors, VID / PID (as I understood it, you can install any), the controller showed up as an image processing device.  The next stage is the transfer of a video stream to a computer (for a start, a test image stored in the controller's memory). <br><br>  Pre-worth mentioning the various USB requests (Requests) that need to be processed.  When the controller receives a request from a computer (host) for certain types of requests, the USB library calls the usbd_video_Setup function, which should process the request. <br>  Most of this function is taken from the microphone code - this is the processing of Standard Device Requests.  Here you can pay attention to switching between alternative interfaces, which occurs when you receive a request SET_INTERFACE.  The UVC device must provide at least two alternative interfaces, one of which (Zero Bandwidth, goes under 0 number), the computer switches the USB device when it is not needed, thereby restricting the data flow on the bus.  When a program on the computer is ready to receive data from the device, it sends a request to it to switch to another alternative interface, after which the device begins to receive IN Token Packets from the host, indicating that the host is waiting for data transfer. <br>  There is another type of request - Class Device Requests, specific to this class - UVC.  They are used to obtain data from the camera on its state and control its operation.  But even in the simplest implementation, when no camera parameters can be changed, the program must handle requests: GET_CUR, GET_DEF, GET_MIN, GET_MAX, SET_CUR.  All of them are transmitted before turning on the camera from the computer.  According to the UVC specification, the computer requests from the camera the modes in which it can work, and then sends an indication of the mode in which the camera should work.  And there are two types of such requests: Probe and Commit.  In my case, this data is not used in any way, but if the request is not processed (not to pick up the sent data or not to respond), the program on the computer will ‚Äúhang‚Äù and the controller will need to reboot. <br><br>  During the creation of the project, it was discovered that the USB library sometimes incorrectly processes data transfer requests to the host ‚Äî after transferring some small amount of data, the data transfer stops and you can only restart the computer to restart it.  This applies to both the transmission of video information (through 1 endpoint) and the control information (through 0 endpoint).  This is corrected by pre-clearing the FIFO of the desired endpoint before writing to it. <br><br>  After all the necessary requests have been transmitted, and the computer has sent a request to switch the alternative interface to the main mode, you can begin to transmit video data.  The computer starts issuing on the IN Token Packet bus every millisecond, on receipt of which, the controller calls the usbd_video_DataIn function, from which the DCD_EP_Tx library data transfer function should be called. <br>  Video data is transmitted in packets, at the beginning of each packet there should be a header 2 bytes long (the UVC specification supports the use of longer headers with additional information).  The first byte of the header is always 2 - this is the total length of the header.  The second byte allows the host to detect the beginning of the frame and their shift - the first bit of this byte must be switched in the first packet of the new frame.  In subsequent packets of this frame, the value of this bit must remain the same.  The remaining bits can be left zero.  The rest of the package is occupied by video data.  Their length in the package can be arbitrary (but not more than a certain size). <br>  I specifically selected the length of the video data in the packet so that the image size in bytes was divided into it without a trace - so all the packets are of the same length. <br><br>  It turns out this result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d9/f4d/709/1d9f4d70919b7017923b237e916789c2.png" alt="image"><br><br>  And what about performance? <br>  The controller supports the USB Full Speed ‚Äã‚Äãstandard, which gives a theoretical speed of 12 Mbps.  Thus, the maximum that can be expected is that the frame transmission time will be (320 * 240 * 3/2) / (12 * 10 ^ 6/8) = 76 ms, which gives 13 FPS.  However, USB is a half-duplex protocol, and the microcontroller has its limitations.  The controller sends the data via USB using FIFO, and this controller has 1250 bytes of memory, and it should be divided between all control points.  The memory allocation is indicated in the file ‚Äúusb_conf.h‚Äù, and the sizes are indicated in 32-bit words. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RX_FIFO_FS_SIZE 64 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TX0_FIFO_FS_SIZE 16 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TX1_FIFO_FS_SIZE 232 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TX2_FIFO_FS_SIZE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TX3_FIFO_FS_SIZE 0</span></span></code> </pre> <br>  For FIFO receiving commands from a computer, at least 64 words need to be allocated; on the FIFO of transferring control information to a computer through 0, the end point needs another 16 words.  Everything else can be allocated to the first endpoint for the transfer of video data.  The total is (64 + 16 + 232) * 4 = 1248 bytes.  Since there is a limit of 232 words (928 bytes), the packet size (VIDEO_PACKET_SIZE) was set to (768 + 2) bytes.  Thus, one frame consists of (320 * 240 * 3/2) / (768) = 150 packets, which will be transmitted 150 * 1ms, which gives 6.6 FPS. <br>  The real result coincides with the calculated: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/86f/3e8/3d1/86f3e83d17fab39fbba7ca1e24722991.png" alt="image"><br><br>  Not very much, but when transferring an uncompressed image with the same size, you will not get more.  Therefore, I decided to try to compress the image on the microcontroller. <br><br><h4>  Transition to MJPEG </h4><br>  The UVC standard supports various types of compression, one of which is <a href="https://ru.wikipedia.org/wiki/MJPEG">MJPEG</a> .  In this type of compression, each original image frame is compressed using the JPEG standard.  The resulting compressed frame can be sent to a computer as described above.  The descriptors and data transfer features for MJPEG are described in the document " <a href="http://www.cajunbot.com/wiki/images/7/71/USB_Video_Payload_MJPEG_1.1.pdf">Universal Serial Bus Device Class Definition for Video Devices: Motion-JPEG Payload</a> ". <br><br>  Transferring a static image prepared on a computer turned out to be quite simple - we convert a regular JPEG file into an .h file, add it to the project, transfer it to the packets, as well as before.  Since the size of the compressed image can be arbitrary, the length of the last data packet is also obtained variable, so it needs to be calculated. <br>  With a compressed image size of 30,000 bytes, it will consist of (30000/768) =&gt; 40 packets, which will be transmitted 40ms, which corresponds to 25 FPS. <br>  For JPEG compression, I decided to use an encoder taken <a href="http://electronix.ru/forum/index.php%3Fshowtopic%3D48542%26view%3Dfindpost%26p%3D421139">here</a> .  It is adapted for ARM, and is designed only for a black and white image that suits me, so I was going to take data from a black and white camera. <br>  On the STM32F4, this encoder started working right away, I didn‚Äôt do any adaptation for Cortrx-M4.  The test bmp file was compressed for 25ms, which corresponds to 40 FPS.  In order to read the compressed image from the controller, I used the program "STM32 ST-LINK Utility".  Before debugging a program, you need to know the starting address of the array in which the compressed image will be placed, and then specify it in this program.  Read dump can be saved immediately as .jpg. <br>  Next, I added the ability to work with two output arrays for double buffering in the encoder, and combined it with the USB data output project. <br><div class="spoiler">  <b class="spoiler_title">CCM Memory Usage</b> <div class="spoiler_text">  The RAM controller used is divided into several blocks.  One of them - (64 KB) is called CCM, and it cannot be accessed through DMA.  I decided to put here two arrays to store the compressed image. <br>  In order to use this memory, in IAR you need to edit the used .icf file, adding lines to it: <br><pre> <code class="cpp hljs">define symbol __ICFEDIT_region_RAMCCM_start__ = <span class="hljs-number"><span class="hljs-number">0x10000000</span></span>; define symbol __ICFEDIT_region_RAMCCM_end__ = <span class="hljs-number"><span class="hljs-number">0x1000FFFF</span></span>; ....... define region CCMRAM_region = mem:[from __ICFEDIT_region_RAMCCM_start__ to __ICFEDIT_region_RAMCCM_end__]; ....... place in CCMRAM_region {section .ccmram};</code> </pre><br><br>  Arrays in the code must be declared as follows: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> location = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">".ccmram"</span></span></span><span class="hljs-meta"> uint8_t outbytes0[32000]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> location = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">".ccmram"</span></span></span><span class="hljs-meta"> uint8_t outbytes1[32000];</span></span></code> </pre><br></div></div><br>  The resulting construction worked, but only in the ContaCam program and in the browser (tested <a href="http://davidwalsh.name/demo/camera.php">here</a> ).  On the static image managed to get 35 FPS. <br>  An example of a compressed image (image size 17 KB): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11d/020/4e7/11d0204e7764dccb3f5ed95eee20e2ad.png" alt="image"><br><br>  The image is upside down, since the information in bmp files is stored in this way. <br><br>  But other programs either didn‚Äôt work at all, or they gave this image: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8dc/923/2e3/8dc9232e3aa256d2fc54923c3d26000f.jpg" alt="image"><br><br>  This is due to the fact that the UVC standard does not support the transfer of black and white images using MJPEG. <br>  JPEG image requirements are: <br><blockquote>  ‚Ä¢ Color encoding - YCbCr <br>  ‚Ä¢ Bits per pixel - 8 per color component (before filtering / subsampling) <br>  ‚Ä¢ Subsampling - 422 <br></blockquote><br>  Thus, it was necessary to remake the existing encoder to form pseudo-color images - in this image only brightness data (Y) is encoded in this image, and instead of color data (Cb and Cr), zeros are transmitted.  I had to get acquainted with the structure of the JPEG format deeper. <br><br><h4>  Transition from black and white to pseudo </h4><br>  How the encoder worked before: <br>  1. A JPEG file header is generated. <br>  2. Block by block (8x8 pixels) processing of the original image. <br>  2.1 Each block is read from memory, its discrete cosine transform (DCT) is produced <br>  2.2 The resulting 64 values ‚Äã‚Äãare quantized and the result is packed using Huffman codes. <br>  3. A data end marker is formed and the size of the compressed image is calculated. <br>  More details about JPEG can be read <a href="http://habrahabr.ru/post/206264/">here</a> and <a href="http://habrahabr.ru/post/102521/">here</a> . <br>  Information about the presence of color in a compressed image is stored in the JPEG header, so it needs to be changed.  It is necessary to change the SOF0 and SOS sections, indicating in them the use of three components, for the luminance component the decimation 22, for the color 11. I specified 0 as the identifier of the quantization tables. <br>  Now you can change the method of encoding information.  Since the color information is encoded with thinning, four blocks of luminance information must correspond to the two color information blocks.  Thus, first four blocks of luminance information are sequentially coded, after which it is necessary to encode two more blocks of color information (an example from the above <a href="http://habrahabr.ru/post/206264/">article</a> ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/389/dd0/1c1/389dd01c1fab498c399d8f77979c959b.png" alt="image"><br><br>  In the used library, quantization, final compression of the processed data, and their recording in memory are performed by a separate function, so to form color information, it is enough to zero the array of DCT coefficients and call this function twice. <br>  However, in JPEG coding there is an important feature ‚Äî it is not the DC coefficients at the beginning of each block that are coded, but the difference between the current DC coefficient and the DC coefficient of the previous block of the <b>corresponding component</b> .  In the library, this difference was initially calculated before quantization, so we had to modify the above function, so that during processing of the Cr and Cb channels the difference was not calculated - there are zeroes in these components, and so on. <br>  As a result, the picture started to display correctly in all used video capture programs.  The disadvantage of such a pseudo-color coding is that its speed has dropped somewhat.  Compression of the test image began to take 35 ms, which gives 28 FPS. <br><br><h4>  Analog video capture </h4><br>  Now that you have a way to transfer video data to a computer at an acceptable speed, you can also capture video.  From the very beginning of experiments with USB, I intended to capture the video signal from an analog video camera by means of the debug board itself. <br>  Since I had previously made a <a href="http://forum.easyelectronics.ru/viewtopic.php%3Ff%3D16%26t%3D834">homemade TV on a microcontroller</a> , the method of capturing a black and white video signal was not new to me.  Of course, the STM32F4 controller is very different from ATxmega, so the approach to capturing video had to be changed. <br><br>  The PAL format itself is already repeatedly described on various resources, so I‚Äôll dwell on its main provisions, and only for the black and white version. <br>  The frame frequency of this format is 25 Hz, but it uses interlaced scanning ‚Äî that is, when a frame is transmitted, first even and even odd lines are transmitted first.  Each such rowset is called a field.  Fields in this format come with a frequency of 50 Hz (20 ms).  In one field, 312.5 lines are transmitted (of which only 288.5 are video information).  All lines are separated by sync pulses that follow with a period of 64 ¬µs.  The video signal itself in a row takes 52 ¬µs. <br>  Fields are separated by personnel and equalizing sync pulses.  An important feature of equalizing sync pulses is that their period is two times less than the period of rows - 32 Œºs, so that they can be easily distinguished from sync pulses. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/292/214/647/2922146471650735d9509492cb1906cd.png" alt="image"><br><br>  Thus, in order to capture an image into the memory of the controller, you need to write a program capable of detecting clock signals, extract the equalizing pulses from them, and start ADC conversion in before starting to transmit video data of each line. <br><br>  Now it should be more stop on the method of digitizing the video signal. <br>  The STM32F4 controller has three separate ADCs, each of which can operate at a speed of 2.4 MSPS at a bit depth of 12 bits.  When reducing the bit rate, the speed of work increases, but this is not enough to get a resolution of 320 * 240.  However, the controller allows you to combine several ADCs - you can configure the capture of all ADCs simultaneously, or you can set the capture delay between the ADCs, as a result of which the overall capture rate increases. <br><br>  What is the speed of capture will be when using two ADCs at once (Interleaved dual mode)? <br>  For the ADC clocking, the APB2 bus is used, the clock frequency of which, when the controller is initialized, is set to the wounded half of the system frequency (168 MHz / 2) = 84 MHz.  For an ADC, this is too much, so when setting up an ADC, you need to set the prescaler to 2. The resulting frequency of 42 MHz is still greater than the maximum allowed by the datasheet (36 MHz), but my ADC works well with this frequency. <br>  In case if each ADC with 8 bits installed would work separately, then the maximum conversion rate would be (42 MHz / (3 + 8)) = 3.81 MSPS.  By setting the delay between the data capture time of 6 cycles, you can get a speed of 7 MSPS, and at 7 cycles - 6 MSPS. <br>  I chose the last option.  It turns out that the entire line (64 Œºs) will occupy 384 bytes, and the active part of the line with the video signal (52 Œºs) will occupy 312 bytes (pixels). <br>  The ADC transmits the conversion results to memory using DMA.  When using two 8-bit ADCs, the data is transmitted to memory as 16-bit words at the time of completion of the conversion of the second ADC.  In principle, it would be possible to capture the contents of almost the entire frame into memory - for this you need (384 * 240) = 92.16 KB.  But I went another way - data capture begins after the controller detects a synchronization pulse, and stops after the capture of 366 bytes (183 DMA transmissions).  Why such a number is chosen - I will tell further.  As a result, video data occupy (366 * 240) = 87.84 Kbytes of RAM. <br><br>  Consider the method of detecting the clock signal.  Ideally, it is better to detect it with a special microcircuit, or at least with a comparator, but this complicates the design.  Since I still have one unused ADC, I decided to use it to detect clock signals.  Each ADC includes a special module ‚ÄúAnalog watchdog‚Äù.  It can generate an interrupt if the digitized value is outside the specified limits.  However, this module is not able to respond to a change in the front of the digitized signal ‚Äî it will form an interrupt until the input signal or the settings of the module change.  Since I needed to detect signal fronts, I had to reconfigure this module with each interruption.  I did not implement in the program the automatic determination of the thresholds of the Analog watchdog, so that they are specified manually for the camera used. <br><br>  In order to detect equalizing pulses, one of the timers of the controller operating at 1 MHz is used.  The timer runs continuously, and in the Analog watchdog interrupt handler (if a leading edge of the clock pulse is detected), its current value is read and compared with the previous one.  Thus, it is possible to distinguish the lower case sync pulses from equalizing ones.  After the equalization sync pulses are over, the controller skips 17 horizontal sync pulses and, upon detecting the leading edge of the sync pulse, starts capturing the video data of the current line.  Since the input to the interrupt handler in this controller can occur in a variable time, and also because the ADC 3 is slower than the first two together, the time between the front of the clock and the start of the capture can differ, which leads to " jitter "lines.  That is why the capture of video data starts from the leading edge of the clock, and the row occupies 366 bytes - so part of the clock falls into the frame, and it can be removed programmatically for each row. <br>  The oscillogram shows how the video signal is captured (during the DMA operation, the ‚Äúyellow‚Äù channel is set to 1): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdf/ef6/2b5/fdfef62b5ca8c9082285944ddfecda2f.png" alt="image"><br><br>  Capture begins only after the appearance of video data: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/504/6e5/2c2/5046e52c281f983b6f538c4e6af6cab2.png" alt="image"><br><br>  Not all lines in one field are captured, since the limit is set to 240 lines. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2c2/1af/10c/2c21af10c9815b873ff5beef0ab562da.png" alt="image"><br><br>  The result is the following raw image (obtained using ST-Link Utility): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/093/c7f/db0/093c7fdb03ffb58fc503fdbb72ee7b9c.png" alt="image"><br><br>  After the image is captured in the controller's memory, it needs to be processed - for each row, remove the offset associated with the capture of the clock signal, and subtract the black level value from the pixel brightness values.  I did not try to optimize this piece of code, so its execution takes 5 ms. <br><br>  After the image has been processed, you can begin to encode it in JPEG, while simultaneously transferring the already encoded data of the previous image via USB. <br>  Thus, the frame is captured 20 ms, processing goes 5 ms, and the coding together with the data transfer goes 35 ms, which in total gives 60 ms, or the frame rate of 16.6 FPS.  As a result, it turns out that one frame (in fact, a field) is captured, and two frames are skipped.  Since the scan in PAL format is interlaced, it turns out that the even and odd fields are alternately captured, causing the image to shake by one pixel.  You can get rid of this by adding an additional delay between frame capture ‚Äî then another field will be skipped, and the output frame rate will drop to (50/4) = 12.5 FPS. <br><br><h4>  A little bit about the video source </h4><br>  Initially, I planned to use the KPC-190S video camera as a source of signal (this camera is almost 15 years old).  It cannot be said that it provides good image quality - it is quite noisy, with not very high contrast, and a small amplitude (from the oscillogram it can be seen that it is close to 1 V).  For a small adjustment of the output signal, the camera is connected to the controller via a resistor divider on a variable resistor.  The only signal output of the board to which the camera is connected is PC2 (all ADCs are connected to it). <br>  Appearance design: <br><br> <a href="https://img-fotki.yandex.ru/get/15561/14557097.3/0_e1fd5_98fe4cea_orig"><img src="https://habrastorage.org/getpro/habr/post_images/0e9/6f3/c9b/0e96f3c9b576336ca9de17dc8a0b16ce.jpg"></a> <br><br>  Since the camera did not provide good image quality, I decided to try taking a signal from a Canon A710 camera.  It has an analogue output for connecting to a TV, which displays everything that is displayed on the screen of the camera.  The signal quality of the camera is better, but its video signal is color.  In order to remove the color component from the signal, I used the following filter: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/28f/98c/351/28f98c351a4aeb28655e9225b9930f91.png" alt="image"><br><br>  In addition, the sync pulses at the camera output have a negative polarity, so that in order for them to be detected by the controller's ADC, it was necessary to add an additional bias voltage to the signal using an adjustable power source.  Just had to slightly change the thresholds of the Analog watchdog. <br>  Appearance design with a connected camera: <br><br> <a href="https://img-fotki.yandex.ru/get/15495/14557097.3/0_e1fd4_e8971018_orig"><img src="https://habrastorage.org/getpro/habr/post_images/81b/be7/84f/81bbe784f3af323bd76504b34ca5afc0.jpg"></a> <br><br>  An example of the image received from the camera: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed2/a70/943/ed2a70943d97eede892f0ccd76b47f20.jpg" alt="image"><br><br>  Device video: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/V_uk3eTgr50" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Project source codes: <a href="http://github.com/iliasam/STM32F4_UVC_Camera">github.com/iliasam/STM32F4_UVC_Camera</a> </div><p>Source: <a href="https://habr.com/ru/post/245511/">https://habr.com/ru/post/245511/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245497/index.html">Algorithm TILT or non-standard use of the rank of the matrix</a></li>
<li><a href="../245503/index.html">Concurrent programming with CUDA. Part 1: Introduction</a></li>
<li><a href="../245505/index.html">How to independently register Ltd.</a></li>
<li><a href="../245507/index.html">ASH Viewer</a></li>
<li><a href="../245509/index.html">Onto engineer: work on concepts</a></li>
<li><a href="../245513/index.html">Read SVG in C ++</a></li>
<li><a href="../245515/index.html">Time Series, metrics and statistics: familiarity with InfluxDB</a></li>
<li><a href="../245517/index.html">A simple built-in woofer amplifier on a chip with an FM receiver based on Arduino</a></li>
<li><a href="../245521/index.html">Qt 5.4 and Qt Creator 3.3 Release</a></li>
<li><a href="../245523/index.html">Concurrent programming with CUDA. Part 2: GPU hardware and parallel communication patterns</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>