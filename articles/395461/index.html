<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Smart computer socket on the Arduino do it yourself</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 


 Smart socket on the Arduino, what could be easier. The main objective of this project was to develop sockets with wireless control, as we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Smart computer socket on the Arduino do it yourself</h1><div class="post__text post__text-html js-mediator-article"><p><img src="http://i.imgur.com/JpKXQsX.jpg?1" alt="image"></p><br><h1>  Foreword </h1><br><p>  Smart socket on the Arduino, what could be easier.  The main objective of this project was to develop sockets with wireless control, as well as ‚Äúautomate‚Äù the entrance to Windows.  The motivating component is to figure out what RFID tags are and how to work with them.  As a result, two devices were developed - a deblocking device, which reads the cards and the smart socket itself, which receives a ‚Äúturn on‚Äù signal from the deblocking device.  If I am interested in you please read. <a name="habracut"></a></p><br><p>  By the way, the deblorer in this project can both read RFID tags and write on them.  The scope of the smart outlet is quite large.  With their help, you can remotely turn on and off electrical devices.  Also, this project can be used as an example to create more complex control devices for electrical devices (in conclusion).  At first, I think it‚Äôs worthwhile to show the project at work, and then tell how everything works. </p><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/5MTsqm6ES8k%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjJHjz6hBbUdLaBrwhhtM59S_wWtw" frameborder="0" allowfullscreen=""></iframe><br><h1>  What is it made of </h1><br><h2>  Smart socket </h2><br><p>  Inside view: </p><br><p><img src="http://i.imgur.com/X3TCyqV.jpg" alt="image"></p><br><h3>  Connection diagram: </h3><br><p><img src="http://i.imgur.com/vlm0N7i.png" alt="image"></p><br><p>  Components Used: </p><br><ul><li>  Arduino leonardo </li><li>  AC-DC miniature power supply for 12V </li><li>  Bluetooth module </li><li>  Standard 220V socket, 2 pieces </li><li>  220V plug with wire </li><li>  Contact area </li><li>  Two-color LED to indicate operation </li><li>  Chipboard for components </li></ul><br><p>  Read more about the components.  I placed all the components on the site of particleboard 15 by 15 centimeters. </p><br><p><img src="http://i.imgur.com/7EmuzSS.jpg?1" alt="image"></p><br><p>  Fastening of all components to the site was carried out with the help of screws and pre-drilled holes in the site.  I used Arduino Leonardo as a microcontroller, since this board, unlike Uno, for example, can act as a USB-HID device.  In the photo Uno, but this is a photo taken before the idea of ‚Äã‚Äãunlocking Windows with an outlet.  We need Leonardo to simulate a password entry.  Instead, Leonardo for these purposes could take Arduino Due, Micro, Zero or Esplora. </p><br><h3>  Relay module </h3><br><p>  With regards to the relay module, it is on two channels: </p><br><p><img src="http://i.imgur.com/OwpcU3r.jpg" alt="image"></p><br><p>  Switched currents up to 10A at AC250V or DC30V.  There are two control pins for each relay, and power and ground pins.  It is important to note that the pins in this module are inverse, that is, by doing so: </p><br><pre><code class="cpp hljs">digitalWrite(relay_pin, HIGH);</code> </pre> <br><p>  You open the relay.  To go current, you need to submit a logical zero to the pin. </p><br><p>  About the wiring.  For the low-voltage part of the circuit, I used the usual connectors from the DuPont cable.  For the high-voltage part, I took aluminum wires with a cross section of 2 mm.  Be very careful and attentive when installing high-voltage wires! </p><br><p>  About the power supply.  I used the power supply for LED strips, the output parameters of which are 12V, 0.4 A - enough and not much for Arduino.  Why is it needed?  It is necessary for the low-voltage part of the circuit to use the same voltage that goes to our sockets.  Plus from the power supply is fed to the Vin input of the Arduino, minus - to the Gnd.  To the note: it is completely safe to connect the USB cable simultaneously with the connected power supply unit on the Vin. </p><br><h3>  Bluetooth module </h3><br><p>  Now the most interesting is the Bluetooth module.  In this project, I used the HC-05 module, since it can act both as a master and as a slave. </p><br><p><img src="http://i.imgur.com/O54h1Kj.jpg" alt="image"></p><br><p>  My slave is the module installed in the smart socket, the master is the module in the deblocking device.  Thus, the enabler is always the initiator of the connection.  These modules can be configured so that when turned on they are connected automatically.  So I did.  Configuring this bluetooth module is done by sending AT commands to it.  In order for the module to receive AT commands, it must be switched to AT mode.  The module that I caught (FC-114) has a button on board (see photo).  If you hold it down when turned on, the module will enter AT mode.  Agree, inconvenient.  With this approach, I can not dynamically connect to any previously unknown module.  It would be good to be able to apply a logical unit to any pin of the module and thus enter the AT mode.  This is done in many modules, but not in the FC-114.  This pin has the number 34 in my module and in the future, if you need to connect to the bluetooth modules dynamically, I soldered a wire to pin 34 of the module, which can be connected to the Arduino pin. </p><br><p><img src="http://i.imgur.com/dHB9ar5.jpg?1" alt="image"></p><br><p>  Now about the commands for connecting two bluettoth modules of HC-05.  In slave mode, each HC-05 module works out of the box.  You just need to know its MAC address, which we will use when configuring the wizard.  We will do this with the help of AT-commands, which I mentioned above.  First you need to connect the RX pin of the Bluetooth module to pin 0 of the Arduino (also RX), pin TX respectively to pin 1 of the Arduino.  Please note that the connection here is not a crossover, because we use the UART Arduino.  Next, you need to fill in an empty sketch on the Arduino, because again we use the UART Arduino. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br><p>  Further, before turning on the power, as I mentioned above, it is necessary to hold down a small button on the bluetooth module in order to enter AT mode.  After that, using the standard IDE (Tools -&gt; Serial Monitor).  Also, by opening the Serial Monitor, you must set the baud rate to 38400 and set the \ r \ n character substitution after each command (Both NL &amp; CR).  You can check that everything is connected correctly and works by typing "AT".  In response, we should get "OK".  Then you can write the command "AT + NAME?".  In response, we should get the name of the bluetooth module.  At the moment we are working with a slave device, so all we need is to find out its MAC address and make sure that it works in the "Slave" mode, and not the "Master" mode.  To do this, enter two commands: </p><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">AT</span></span>+<span class="hljs-type"><span class="hljs-type">ROLE?</span></span></code> </pre> <br><p>  If we received 0, it means that the device is operating in the "Slave" mode, 1 - "Master".  To change this value, the command is sent as follows: </p><br><pre> <code class="hljs pgsql">AT+<span class="hljs-keyword"><span class="hljs-keyword">ROLE</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span> -     "Slave":</code> </pre><br><p>  Now we‚Äôll find out the Slave MAC address, so that Master knows who he needs to connect to.  Enter the command: </p><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">AT</span></span>+<span class="hljs-type"><span class="hljs-type">ADDR?</span></span></code> </pre> <br><p>  For example, the answer was: "ADDR: 20: 2: 110001".  This means that the MAC address of our Slave is 20: 2: 110001. </p><br><p><img src="http://i.imgur.com/H1OFZ7m.jpg" alt="image"></p><br><p>  On this work with Slave'om finished.  Proceed to configuring the Master.  In the same way, we connect it to Arduino and fill in an empty sketch, open the Serial Monitor, set the transfer rate to 38400, and replace the / r / n.  Next, enter the command in order. </p><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">AT</span></span>+ORGL <span class="hljs-built_in"><span class="hljs-built_in">AT</span></span>+RMAAD <span class="hljs-built_in"><span class="hljs-built_in">AT</span></span>+ROLE=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">AT</span></span>+CMODE=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">AT</span></span>+INIT <span class="hljs-built_in"><span class="hljs-built_in">AT</span></span>+INQ <span class="hljs-built_in"><span class="hljs-built_in">AT</span></span>+LINK=MAC- (: <span class="hljs-number"><span class="hljs-number">20</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">110001</span></span>)</code> </pre> <br><p>  So, more about each team.  The ORGL command completely resets the device, and the RMAAD command deletes all previous "pairs" with other Slave devices.  The ROLE command, as mentioned above, having an argument of 1 means that we want the device to operate in Master mode.  The CMODE command with an argument of 1 (the default is 0) means that our Master device can connect to the Slave device with any address (you can specify a specific one).  The INIT command launches the SPP (Serial Port Profile) library, which is necessary for transmitting / receiving information.  A capacious statement of why it is needed: "While the Bluetooth specification describes how this technology works, profiles determine how to work with this technology."  You may get error 17 in this step.  This means that the library is already running, just continue.  The INQ command means that our Master device starts searching for Slave devices.  The output of this command is a list of the MAC addresses of the devices found.  For example: </p><br><pre> <code class="hljs css">+<span class="hljs-selector-tag"><span class="hljs-selector-tag">INQ</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:address</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">type</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">signal</span></span> 20<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:2</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:110001</span></span>,0,7<span class="hljs-selector-tag"><span class="hljs-selector-tag">FFF</span></span></code> </pre> <br><p>  Signal and type can be ignored.  We find the MAC address of our Slave and the next LINK command we connect the master device with the Slave.  Note that here the colon in the MAC address is replaced with commas.  After that, your bluetooth devices should start blinking twice in ~ 2 seconds.  That means they are connected.  Before that, they blinked often enough (twice a second) - this means that they are searching for a ‚Äúpair‚Äù. </p><br><p>  Full list of AT commands: </p><br><p><img src="http://i.imgur.com/FNgshvt.jpg" alt="image"></p><br><h2>  Deblorator </h2><br><p>  Inside view: </p><br><p><img src="http://i.imgur.com/wZWqCE8.jpg?1" alt="image"></p><br><h3>  Connection diagram: </h3><br><p><img src="https://i.imgur.com/X7oqpPj.png" alt="image"></p><br><p>  Components Used: </p><br><ul><li>  Arduino uno </li><li>  Bluetooth module </li><li>  RFID sensor </li><li>  LCD module </li><li>  Toggle switch to switch mode </li><li>  Piezoelectric element </li></ul><br><p>  Read more about the components. </p><br><h3>  LCD module </h3><br><p>  In this project, the LCD module 1620 was used. This display is capable of displaying 2 lines of 16 characters each.  The module is connected to the Arduino microcontroller via the I2C interface.  I2C is a serial data bus for integrated circuit communications using two bidirectional communication lines (SDA and SCL).  Data is transmitted over two wires - a data wire and a clock wire.  There is a master (master) and a slave (slave), master generates clock cycles, the slave only receives bytes.  There can be up to 127 devices on a single two-wire bus.  I2C uses two bi-directional lines pulled up to the supply voltage and controlled via an open collector or open drain - a serial data line (SDA, Eng. Serial Dta) and a serial clock line (SCL, Eng. Serial Clock).  The sketch uses the LiquidCrystal_I2C library to work with this module.  With its help to display data on the display is extremely simple.  This code example displays two character strings on two display lines. </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lcd_display_two_lines</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* first_line, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* second_line</span></span></span><span class="hljs-function">)</span></span> { g_lcd.clear(); g_lcd.setCursor(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       g_lcd.print(first_line); g_lcd.setCursor(0, 1); //       g_lcd.print(second_line); }</span></span></code> </pre> <br><h3>  RFID module </h3><br><p><img src="http://i.imgur.com/1PtY3L6.jpg" alt="image"></p><br><p>  This module and RFID technology in general was particularly interesting.  In the framework of this project, the RC-522 RFID module was used, which works with HF standard cards, in particular MIFARE with a frequency of 13.56 MHz.  This module is connected to the Arduino microcontroller via SPI interface.  SPI is a full-duplex serial synchronous data transmission standard designed to provide simple, low-cost, high-speed pairing of microcontrollers and peripherals.  SPI uses four digital signals: </p><br><ul><li>  MOSI - Serves to transfer data from the master device to the slave; </li><li>  MISO - Serves to transfer data from the slave to the master; </li><li>  SCK - Used to transmit a clock signal for slave devices; </li><li>  NSS - chip select, slave select </li></ul><br><p>  The RFID module acts as a slave and the microcontroller as the master. </p><br><h2>  The memory structure of the RFID card MIFARE Classic </h2><br><p>  The memory of MIFARE Classic chips has a clear structure (unlike MIFARE DESFIre, which has a more complex file organization of memory).  MIFARE 1K and MIFARE 4K memory is divided into sectors, 16 sectors from MIFARE 1K and 40 sectors from MIfare 4K.  Each MIFARE 1K sector and the first 32 sectors of MIFARE 4K consist of three data blocks and one key storage unit (Sector Trailer).  The last 8 sectors of MIFARE 4K consist of 15 data blocks and one (16th) key storage unit.  Data blocks are available for reading / writing, subject to successful key authorization. </p><br><p>  About the "service" block.  The Sector Trailer block stores the secret key values ‚Äã‚Äã(A and B) for access to the corresponding sector, as well as the access condition (determined by the value of the access bits).  The Sector Trailer unit is always the last (fourth) unit in the sector.  Each sector of MIFARE Classic can have its own access keys and conditions for writing / reading data. </p><br><p>  About data blocks.  Each data block consists of 16 bytes available for writing / reading (except for block 0 of sector 0, where non-erasable information of the manufacturer is stored).  Data reading / reading is performed by key and access bits.  Data blocks can be configured as normal write / read blocks, or as conventional unit storage units (electronic wallet function).  You can write any information (numbers, symbols, etc.) into ordinary data blocks.  If the data block is configured as a block for storing conditional units, then the work with such block occurs by the commands increment / decrement.  That is, the numerical value stored in such a block can only be increased and decreased. </p><br><p>  About access rules.  All sectors of the MIFARE Classic card are accessed according to the same rules.  Access to this or that sector is made with the help of keys (Key A and Key B).  Using the Access Condition (access condition in the Sector Trailer), the conditions for writing and reading data from each sector are set using one key (A or B) or both keys A and B simultaneously.  For example, when clients use MIFARE cards, you can read (read only) data from a block by key A, while the system administrator can read and write data to MIFARE memory using key B. In the fourth block of each sector (Sector Trailer) for three access bits of C1, C2, and C3 are used to provide this access control.  Using these bits, you can set eight different modes of access to the MIFARE sector.  The C1 bit is considered the least significant bit (LSB). </p><br><p>  How I used the memory of RFID tags.  Within the project, two modes are used: the main one - reading the RFID card and switching on the socket, the additional one - programming the RFID card.  To authorize an RFID card by the unlocker, a 128-byte secret key is written to it.  128 bytes = 8 blocks of 16 bytes each.  3 blocks are written to sector 1, 3 blocks to sector 2 and, finally, 2 remaining blocks to sector 3. To read, authentication by key A is required, for writing, by key B, which are in the trailer block.  The key length of 128 bytes was chosen without any principles; at least the entire memory of the card could be used.  The key is a random character set that is in the firmware and deblocking code, and the smart socket.  Such a solution does not clearly possess super-security, but within the framework of the project there was no task to ensure a secure system.  This is also in conclusion. </p><br><h3>  Connect a toggle switch </h3><br><p><img src="http://i.imgur.com/BiqW7zj.jpg" alt="image"></p><br><p>  It seems to me that it makes sense to also note the connection of the toggle switch to the Arduino.  The toggle switch in the enabler is used to switch the operation mode.  In the first mode, the device reads the RFID cards, and if the secret key mentioned above is recorded in the necessary memory blocks of the card, it sends a bluetooth signal "Turn on the sockets and unlock Windows" to the smart socket.  In the second mode, the releaser writes a secret key to the RFID card.  Before writing, it reads the card: if the correct secret key is already written on it, it clears the necessary memory blocks by writing zeros.  Agree, it is strange to provide the unlocker with the reading function and the RFID card writing function.  About why so - in the conclusion. </p><br><p>  When connecting toggle switches, buttons, switches, there is a "contact bounce" - a phenomenon in which, instead of a clear and stable switch, we get random multiple uncontrolled closures and openings of contacts.  In other words, contacts in contact begin to oscillate (i.e., ‚Äúrattle‚Äù), giving rise to many positives instead of one.  Accordingly, the microcontroller will ‚Äúcatch‚Äù all these clicks, because the bounce is not different from the real button press. </p><br><p><img src="http://i.imgur.com/m8q14M2.gif" alt="image"></p><br><p>  To suppress the "bounce" I used a 20 kOhm pull-up resistor built into the Arduino.  It performs pull-up to a logical unit.  Since the toggle switch has both positions - ON, pulling up to a logical one is what you need.  It is used in this way: </p><br><pre> <code class="hljs lisp">pinMode(<span class="hljs-name"><span class="hljs-name">pin_number</span></span>, INPUT)<span class="hljs-comment"><span class="hljs-comment">; //     pinMode(pin_number, INPUT_PULLUP); //    </span></span></code> </pre> <br><h2>  Conclusion </h2><br><p>  So, I got two devices, one of them receives signals via bluetooth and activates sockets, and also unlocks Windows on the connected computer, and the other sends these signals after successful validation by RFID tag.  However, as I said, it was strange to do both writing and reading in one device, without any protection.  I did this only because I wanted to go beyond reading the ID of the RFID card and comparing it with a hardcoded value, and try to work with its memory, what it was actually intended for.  Thus, now I know how to record any information on an RFID card, how to calculate it, how to make a Read Only card, etc.  It turned out the system for home use.  So it turns out, I use my device at home, the smart socket is connected to a computer, speakers and a charger for the phone are connected to it.  The release is at the entrance of the room.  I will not say that this is a device, without which I cannot live, but it has ideas of real practical application.  One of them is quite feasible and will be implemented. </p><br><p>  It is planned to make the access control system to the student‚Äôs workplace in the classroom with computers.  Looking ahead, I‚Äôll say that our university uses the MIFARE 1K RFID card as a student ID.  Suppose we have a small audience on 6 computers, in other words, on 6 workplaces. </p><br><p>  First, we ‚Äúclone‚Äù the smart socket - we make 5 more such devices, so that in addition to using a computer, a student can connect his laptop / soldering iron / telephone to the socket.  This is where we can use the dynamic connection of the bluetooth Master device to the Slave device I was talking about when talking about the bluetooth module.  More in any way to modify the smart outlet is not necessary.  The only thing is to find a solution so that the Arduino microcontroller connected to the computer via USB cable cannot be reprogrammed. </p><br><p>  Now it is necessary to say about the changes in deblorator.  We deprive it of the recording function, leaving only the ability to read RFID cards.  If we used homemade RFID cards, then it would take more to make a device for recording RFID cards.  Since it is planned to use ready-made student cards with ready-written information, this device is not required for a future project, but if you use your own "custom" cards, creating it would be very simple considering the work done on this project.  Also, the enabler will need to be equipped with an Ethernet or WiFi module in order to be able to make requests to the management server.  What and why, you ask?  To make the system more flexible and convenient, before coming to work in the classroom, a student must ‚Äúbook‚Äù a place for himself using this website.  The releaser, when checking the student's RFID card, will contact the server to verify the reservation (and something else, if you want).  It remains to think about how to implement a cross-check of the student‚Äôs presence (he left and did not attach the card) and a convenient way of informing about the end of ‚Äúworking‚Äù time. </p><br><h2>  Firmware code </h2><br><p>  <a href="https://bitbucket.org/sashadereh/arduino-smart-socket/src">https://bitbucket.org/sashadereh/arduino-smart-socket/src</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/395461/">https://habr.com/ru/post/395461/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../395449/index.html">A commercial module may appear on the ISS.</a></li>
<li><a href="../395451/index.html">No options</a></li>
<li><a href="../395453/index.html">Security systems should protect, not record how you are killed.</a></li>
<li><a href="../395455/index.html">Do-it-yourself FPV racing drone (part 1) - build</a></li>
<li><a href="../395459/index.html">Water meter reading: ESP8266 + Android</a></li>
<li><a href="../395463/index.html">WRIO Internet OS. Introduction</a></li>
<li><a href="../395467/index.html">Ask Ethan # 62: the largest spiral galaxy</a></li>
<li><a href="../395469/index.html">Cloud incident</a></li>
<li><a href="../395471/index.html">Edward Snowden lives a free life - like a robot</a></li>
<li><a href="../395473/index.html">Moscow GikPiknik: Atlas Report</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>