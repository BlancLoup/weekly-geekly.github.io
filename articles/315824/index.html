<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Linux version of PVS-Studio gave itself a tour of Disney</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, the Linux version of the PVS-Studio analyzer has been published. With its help, a number of open source projects were tested. Among them are...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Linux version of PVS-Studio gave itself a tour of Disney</h1><div class="post__text post__text-html js-mediator-article"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43b/fc9/0ce/43bfc90ce2367bfe20057be2382a62ba.png"></div><p></p><br>  Recently, the Linux version of the PVS-Studio analyzer has been published.  With its help, a number of open source projects were tested.  Among them are Chromium, GCC, LLVM (Clang) and others.  And today, projects that were developed by Walt Disney Animation Studios for the virtual reality community will join this list.  Let's proceed to the review of the found warnings of the analyzer. <br><a name="habracut"></a><br><h2>  Something about Disney </h2><br>  For many years, Walt Disney has been making television audiences all over the world delighted with amazing stories and characters, giving it unforgettable impressions.  From year to year Disney releases more and more fascinating, entertaining and challenging films, and cartoons.  Accordingly, there is an increasing need for the development of various programs that will contribute to the realization of the artists' creative ideas on visual effects. <br><br>  Walt Disney Animation Studios programmers support animation and visual effects specialists by creating technologies that are available as open source C and C ++ programs for everyone in the virtual reality industry.  These programs include: <br><br><ul><li>  Partio (allows you to work with standard particle file formats through a single interface, implemented on the same principle as unified image libraries) </li><li>  Alembic (an open interchange format that is becoming the industry standard for exchanging animated computer graphics between digital content creation packages) </li><li>  Universal Scene Description (an efficient system capable of reading and transmitting scene data for the exchange between different graphic applications) </li><li>  OpenSubdiv (provides detailed rendering of surfaces (subdivision surface) based on reduced models) </li><li>  Dinamica (plugin for Autodesk Maya, developed on the basis of the real-time physics engine Bullet Physics Library) </li><li>  PTex (texture mapping system) </li></ul><br>  Open source programs from Disney can be downloaded from <a href="https://disney.github.io/">https://disney.github.io/</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Test results </h2><br>  The projects reviewed by Walt Disney are small and have only a few tens of thousands of lines of C and C ++ code.  From here and such a small amount of errors on projects. <br><br><h3>  Project partio </h3><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/28c/9c7/9b528c9c79acef4761c9336daf365ac3.png"></div><p></p><br><br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V547/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V547/">V547</a> Expression '"R"' is always true.  PDA.cpp 90 <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ParticlesDataMutable* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPDA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(input-&gt;good()) { *input&gt;&gt;word; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(word==<span class="hljs-string"><span class="hljs-string">"V"</span></span>){ attrs.push_back(simple-&gt;addAttribute(....); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-string"><span class="hljs-string">"R"</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// &lt;= attrs.push_back(simple-&gt;addAttribute(....); }else if("I"){ // &lt;= attrs.push_back(simple-&gt;addAttribute(....); } index++; } .... }</span></span></code> </pre> <br>  The analyzer issued a message that the condition is always true.  This will lead to the fact that the action that is defined in the <i>else</i> branch will never be executed.  I think this situation arose because of the negligence of the programmer, and the conditions that will not lead to such an error should look like this: <br><pre> <code class="cpp hljs">.... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(word==<span class="hljs-string"><span class="hljs-string">"V"</span></span>){ attrs.push_back(simple-&gt;addAttribute(....); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(word==<span class="hljs-string"><span class="hljs-string">"R"</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// &lt;= attrs.push_back(simple-&gt;addAttribute(....); }else if(word=="I"){ // &lt;= attrs.push_back(simple-&gt;addAttribute(....); } ....</span></span></code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V528/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V528/">V528</a> It is odd that the pointer to the 'char' type is compared with the '\ 0' value.  Probably meant: * charArray [i]! = '\ 0'.  MC.cpp 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CharArrayLen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** charArray)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(charArray != <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(charArray[i] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { i++; } } return i; }</span></span></code> </pre> <br>  If I understand correctly, the <i>CharArrayLen</i> function counts the number of characters in the <i>charArray</i> string.  But is this really the case?  In my opinion, in the condition of the <i>while loop</i> there is an error related to the fact that the pointer to the type <i>char is</i> compared with the value of <i>'\ 0'</i> .  There is a high probability that the pointer dereference operation is forgotten.  Therefore, the <i>while loop</i> condition should look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((*charArray)[i] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span>)</code> </pre> <br>  By the way, the check located slightly higher is also quite strange: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(charArray != <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br>  Verification, of course, works, but it will be much better to replace it with this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(charArray != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)</code> </pre> <br>  In general, it seems that the function was developed by the trainee, or it was not added.  It‚Äôs not clear why not just write code using the <i>strlen ()</i> function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CharArrayLen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** charArray)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (charArray == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(*charArray); }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V701/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V701/">V701</a> realloc () possible leak: when realloc () fails in allocating memory, original pointer 'attributeData [i]' is lost.  Consider assigning realloc () to a temporary pointer.  ParticleSimple.cpp 266 <br><br><pre> <code class="cpp hljs">ParticleIndex ParticlesSimple:: addParticle() { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;attributes.size();i++) attributeData[i]= (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(attributeData[i], <span class="hljs-comment"><span class="hljs-comment">// &lt;= (size_t)attributeStrides[i]* (size_t)allocatedCount); .... }</span></span></code> </pre> <br>  The analyzer detected dangerous use of <i>realloc</i> in the code.  The construction <i>foo = realloc (foo, ...) is</i> dangerous because if the memory allocation is impossible, the function will return <i>nullptr</i> , thus overwriting the previous pointer value, which can lead to a memory leak, or even a program crash.  Perhaps this situation is extremely rare for many cases, but to be safe, I think, is still worth it.  To prevent such a situation, it is recommended to save the pointer value in an additional variable before using <i>realloc</i> . <br><br>  Similar analyzer warnings: <br><br><ul><li>  V701 realloc () possible leak: when realloc () fails in allocating memory, the original pointer 'attributeData [i]' is lost.  Consider assigning realloc () to a temporary pointer.  ParticleSimple.cpp 280 </li><li>  V701 realloc () possible leak: when realloc () fails in allocating memory, the original pointer 'data' is lost.  Consider assigning realloc () to a temporary pointer.  ParticleSimpleInterleave.cpp 281 </li><li>  V701 realloc () possible leak: when realloc () fails in allocating memory, the original pointer 'data' is lost.  Consider assigning realloc () to a temporary pointer.  ParticleSimpleInterleave.cpp 292 </li></ul><br><h3>  Alembic Project </h3><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0d/231/e0d/f0d231e0dc0c84fcc16019e49d948aea.png"></div><p></p><br><br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V501/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V501/">V501</a> There are identical sub-expressions.  operator.  ONuPatch.h 253 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sample</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasKnotSampleData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( (m_numU != ABC_GEOM_NUPATCH_NULL_INT_VALUE) || (m_numV != ABC_GEOM_NUPATCH_NULL_INT_VALUE) || (m_uOrder != ABC_GEOM_NUPATCH_NULL_INT_VALUE) || (m_vOrder != ABC_GEOM_NUPATCH_NULL_INT_VALUE) || m_uKnot || m_uKnot) <span class="hljs-comment"><span class="hljs-comment">// &lt;= return true; else return false; } .... protected: .... int32_t m_numU; int32_t m_numV; int32_t m_uOrder; int32_t m_vOrder; Abc::FloatArraySample m_uKnot; Abc::FloatArraySample m_vKnot; .... }</span></span></code> </pre> <br>  And again the error associated with the absentmindedness of the programmer.  It is easy to guess that instead of repeating the <i>m_uKnot</i> field, the condition should be <i>m_vKnot</i> . <br><br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V523/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V523/">V523</a> The 'then' statement is equivalent to the 'else' statement.  OFaceSet.cpp 230 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OFaceSetSchema::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Sample &amp;iSamp ) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( iSamp.getSelfBounds().hasVolume() ) { <span class="hljs-comment"><span class="hljs-comment">// Caller explicity set bounds for this sample of the faceset. m_selfBoundsProperty.set( iSamp.getSelfBounds() ); // &lt;= } else { m_selfBoundsProperty.set( iSamp.getSelfBounds() ); // &lt;= // NYI compute self bounds via parent mesh's faces } .... }</span></span></code> </pre><br>  PVS-Studio detected the <i>if..else statement</i> in the code, in which the same thing is done in both outcomes, despite the different comments.  It is likely that this section of code is languishing in a queue of immediate tasks for a team of programmers, but in the meantime, this section of code is wrong and needs some work. <br><br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V629/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V629/">V629</a> Consider inspecting the '1 &lt;&lt; iStreamID' expression.  Bit shifting of the 32-bit type.  StreamManager.cpp 176 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> StreamManager::put( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> iStreamID ) { .... <span class="hljs-comment"><span class="hljs-comment">// CAS (compare and swap) non locking version Alembic::Util::int64_t oldVal = 0; Alembic::Util::int64_t newVal = 0; do { oldVal = m_streams; newVal = oldVal | ( 1 &lt;&lt; iStreamID ); // &lt;= } while ( ! COMPARE_EXCHANGE( m_streams, oldVal, newVal ) ); }</span></span></code> </pre> <br>  The analyzer has detected a potential error in an expression that contains a shift operation. <br><br>  In the expression <i>newVal = oldVal |</i>  <i>(1 &lt;&lt; iStreamID) the</i> unit represented as <i>int</i> is shifted, and then the result of the shift is converted to the 64-bit type.  The potential error here is that if the value of the variable <i>iStreamID</i> may be greater than 32, then this part of the code will not work correctly due to the occurrence of undefined behavior. <br><br>  The code will become safer if the number 1 is represented by a 64-bit unsigned data type: <br><br><pre> <code class="cpp hljs"> newVal = oldVal | ( Alembic::Util::<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; iStreamID );</code> </pre> <br>  The analyzer issued another such warning: <br><br><ul><li>  V629 Consider inspecting the '1 &lt;&lt; (val - 1)' expression.  Bit shifting of the 32-bit type.  StreamManager.cpp 148 </li></ul><br><h3>  Project Universal Scene Description </h3><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ae/9ac/db2/1ae9acdb223284031e774b3f7a3a7195.png"></div><p></p><br><br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V668/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V668/">V668 it was</a> no use.  The exception will be generated in the case of memory allocation error.  uvTextureStorageData.cpp 118 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> GlfUVTextureStorageData::Read(....) { .... _rawBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[_size]; <span class="hljs-comment"><span class="hljs-comment">// &lt;= if (_rawBuffer == nullptr) { // &lt;= TF_RUNTIME_ERROR("Unable to allocate buffer."); return false; } .... return true; }</span></span></code> </pre> <br>  According to the modern standard of the language, <i>new</i> in case of unsuccessful allocation of memory throws an exception, but does not return <i>nullptr</i> .  This code is a kind of archaic programming.  For modern compilers, these checks are no longer meaningful and can be removed. <br><br>  <b>PVS-Studio Warning:</b> <a href="http://www.viva64.com/ru/w/V501/">V501</a> There are identical sub-expressions of 'HdChangeTracker :: DirtyPrimVar'  operator.  basisCurves.cpp 563 <br><br><pre> <code class="cpp hljs">HdBasisCurves::_GetInitialDirtyBits() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mask = HdChangeTracker::Clean; mask |= HdChangeTracker::DirtyPrimVar <span class="hljs-comment"><span class="hljs-comment">// &lt;= | HdChangeTracker::DirtyWidths | HdChangeTracker::DirtyRefineLevel | HdChangeTracker::DirtyPoints | HdChangeTracker::DirtyNormals | HdChangeTracker::DirtyPrimVar // &lt;= | HdChangeTracker::DirtyTopology .... ; return (HdChangeTracker::DirtyBits)mask; }</span></span></code> </pre> <br>  To determine the <i>mask</i> used many fields, among which are duplicate.  It should not be so, therefore, the programmer, or once again because of inattention, uses the same field, or, most likely, <i>there</i> should be another field instead of the repeating <i>DirtyPrimVar</i> field. <br><br>  Similar warning: <br><br><ul><li>  V501 There are identical sub-expressions "HdChangeTracker :: DirtyPrimVar"  operator.  mesh.cpp 1199 </li></ul><br><h3>  OpenSubdiv project </h3><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70f/2df/8a0/70f2df8a07a91b632b1b101914949162.png"></div><p></p><br><br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V595/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V595/">V595</a> The 'destination' pointer was used before it was verified against nullptr.  Check lines: 481, 483. hbr_utils.h 481 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createTopology</span></span></span><span class="hljs-class">(....) {</span></span> .... OpenSubdiv::HbrVertex&lt;T&gt; * destination = mesh-&gt;GetVertex( fv[(j+<span class="hljs-number"><span class="hljs-number">1</span></span>)%nv] ); OpenSubdiv::HbrHalfedge&lt;T&gt; * opposite = destination-&gt;GetEdge(origin); <span class="hljs-comment"><span class="hljs-comment">// &lt;= if(origin==NULL || destination==NULL) // &lt;= { printf(....); valid=false; break; } .... }</span></span></code> </pre><br>  Perhaps the V595 is the most common warning given by the analyzer.  PVS-Studio considers the code dangerous if the pointer is dereferenced, and then checked below the code.  If the pointer is checked, then assume that it can be zero. <br><br>  This is what happens in the above code section.  To initialize the <i>opposite</i> pointer, the <i>destination</i> pointer is dereferenced <i>,</i> and then these pointers are checked for <i>NULL</i> equality. <br><br>  And a couple more warnings: <br><br><ul><li>  V595 The 'destination' pointer was used against it.  Check lines: 145, 148. hbr_tutorial_1.cpp 145 </li><li>  V595 The 'destination' pointer was used against it.  Check lines: 215, 218. hbr_tutorial_2.cpp 215 </li></ul><br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V547/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V547/">V547</a> Expression 'buffer [0] ==' \ r '&amp;&amp; buffer [0] ==' \ n '' is always false.  Probably the '||'  operator should be used here.  hdr_reader.cpp 84 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadHdr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[MAXLINE]; <span class="hljs-comment"><span class="hljs-comment">// read header while(true) { if (! fgets(buffer, MAXLINE, fp)) goto error; if (buffer[0] == '\n') break; if (buffer[0] == '\r' &amp;&amp; buffer[0] == '\n') break; // &lt;= .... } .... }</span></span></code> </pre> <br>  The programmer made a mistake in writing the condition, which leads to the fact that the condition is always <i>false</i> .  Most likely, the programmer wanted to make it so that if end-of-line markers such as <i>\ n</i> or <i>\ r \ n</i> are encountered, it is necessary to exit the <i>while loop</i> .  Therefore, the erroneous condition should be written as follows: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'\r'</span></span> &amp;&amp; buffer[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V593/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V593/">V593</a> Consider reviewing the expression A = B! = C 'kind.  The expression is calculated as the following: 'A = (B! = C)'.  main.cpp 652 <br><br><pre> <code class="cpp hljs">main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ** argv) { .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(OSD_USES_GLEW) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (GLenum r = glewInit() != GLEW_OK) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= printf("Failed to initialize glew. error = %d\n", r); exit(1); } #endif .... }</span></span></span></span></code> </pre> <br>  The analyzer detected a potential error in the expression <i>GLenum r = glewInit ()! = GLEW_OK</i> , which, most likely, does not work as the programmer intended.  When creating such code, the programmer, as a rule, wants to perform actions in the following order: <br><br><pre> <code class="cpp hljs">(GLenum r = glewInit()) != GLEW_OK</code> </pre> <br>  But the priority of the '! =' Operator is higher than the priority of the assignment operator.  Therefore, the expression is calculated as: <br><br><pre> <code class="cpp hljs">GLenum r = (glewInit() != GLEW_OK)</code> </pre> <br>  Therefore, if the <i>glewInit ()</i> function <i>does</i> not work correctly, an incorrect error code will be printed on the screen.  More precisely, the unit will always be printed. <br><br>  To correct the error, you can use brackets or make the creation of an object outside the condition, which will give the code a more readable look.  See also chapter 16 in the book The <a href="http://www.viva64.com/ru/b/0391">Main Question of Programming, Refactoring, and All That</a> . <br><br>  PVS-Studio discovered several more similar places: <br><br><ul><li>  V593 Consider reviewing the A = B! = C 'kind.  The expression is calculated as the following: 'A = (B! = C)'.  glEvalLimit.cpp 1419 </li><li>  V593 Consider reviewing the A = B! = C 'kind.  The expression is calculated as the following: 'A = (B! = C)'.  glStencilViewer.cpp 1128 </li><li>  V593 Consider reviewing the A = B! = C 'kind.  The expression is calculated as the following: 'A = (B! = C)'.  farViewer.cpp 1406 </li></ul><br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V701/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V701/">V701</a> realloc () possible leak: when realloc () fails in allocating memory, original pointer 'm_blocks' is lost.  Consider assigning realloc () to a temporary pointer.  allocator.h 145 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; T* HbrAllocator&lt;T&gt;::Allocate() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_freecount) { .... <span class="hljs-comment"><span class="hljs-comment">// Keep track of the newly allocated block if (m_nblocks + 1 &gt;= m_blockCapacity) { m_blockCapacity = m_blockCapacity * 2; if (m_blockCapacity &lt; 1) m_blockCapacity = 1; m_blocks = (T**) realloc(m_blocks, // &lt;= m_blockCapacity * sizeof(T*)); } m_blocks[m_nblocks] = block; // &lt;= .... } .... }</span></span></code> </pre><br>  And again the dangerous use of the <i>realloc</i> function.  And why it is dangerous - described above in the section 'Project Partio'. <br><br><h3>  Dynamica Project </h3><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a6/0e6/571/5a60e6571952e5cf9969b0d246b58b4b.png"></div><p></p><br><br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V512/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V512/">V512</a> A call of the 'memset' function will lead you to.  pdbIO.cpp 249 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pdb_header_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> magic; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> swap; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> time; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data_size; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num_data; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> padding[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//pdb_channel_t **data; int data; }; bool pdb_io_t::write(std::ostream &amp;out) { pdb_header_t header; .... header.magic = PDB_MAGIC; header.swap = 0; header.version = 1.0; header.time = m_time; header.data_size = m_num_particles; header.num_data = m_attributes.size(); memset(header.padding, 0, 32 * sizeof(char) + sizeof(int)); .... }</span></span></code> </pre><br>  The analyzer has detected a potential error related to filling the memory buffer <i>header.padding</i> .  Through <i>memset, the</i> programmer clears 36 bytes in the <i>header.padding</i> buffer consisting of only 32 bytes <i>.</i>  At first glance, such use is erroneous, but, in fact, the programmer turned out to be a trickster and, together with <i>header.padding,</i> reset the <i>data</i> variable <i>.</i>  After all, the <i>padding</i> and <i>data</i> <i>fields of the pdb_header_t</i> structure <i>are</i> arranged sequentially, and therefore sequentially located in memory.  Yes!  There is no error in this situation, but due to such tricks, an error may potentially occur in this place.  For example, if another programmer changes the <i>pdb_header_t</i> structure, adding <i>padding</i> and <i>data</i> between the fields, and will not notice the tricks of his colleague.  Therefore, it is better to reset each variable separately. <br><br><h3>  Ptex Project </h3><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7c/229/19f/a7c22919f0ff8b0e29c6e408bff427d5.png"></div><p></p><br><br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V612/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/w/V612/">V612</a> An unconditional 'return' within a loop.  PtexHashMap.h 292 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Entry* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lockEntriesAndGrowIfNeeded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; newMemUsed)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_size*<span class="hljs-number"><span class="hljs-number">2</span></span> &gt;= _numEntries) { Entry* entries = lockEntries(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_size*<span class="hljs-number"><span class="hljs-number">2</span></span> &gt;= _numEntries) { entries = grow(entries, newMemUsed); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entries; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lockEntries(); }</code> </pre> <br>  In the above function, there is a suspicious <i>while loop</i> , in which on the first pass a pointer to <i>entries is</i> returned.  Do not you think that there is something confusing?  This section of the code requires more detailed consideration. <br><br><h2>  Conclusion </h2><br>  Static code analysis when writing high-quality software plays a very important role, as using static analysis on a regular basis, you reduce labor costs to eliminate stupid or hard-to-find errors and can spend more time on something useful. <br><br>  If you haven‚Äôt checked your project for errors yet and didn‚Äôt go into an exciting search for bugs, then I advise you to download <a href="http://www.viva64.com/ru/pvs-studio-download-linux/">PVS-Studio for Linux</a> and be sure to do it. <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0455/"><img src="https://habrastorage.org/getpro/habr/post_images/35e/064/ddf/35e064ddf91f5d99b620384893909ff7.png"></a> </div><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Maxim Stefanov.  <a href="http://www.viva64.com/en/b/0455/">PVS-Studio for Linux Went on Tour Around Disney</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/315824/">https://habr.com/ru/post/315824/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../315812/index.html">WebRTC: Making a peer to peer javascript game</a></li>
<li><a href="../315816/index.html">Why ready-made methods do not work and what is needed instead</a></li>
<li><a href="../315818/index.html">Learning to work with asyncio + aiohttp: Moscow will host a course from Core Python developer</a></li>
<li><a href="../315820/index.html">Results and forecasts: the main thing about the digital advertising market in 2016-2017</a></li>
<li><a href="../315822/index.html">Interview with Tanya Evdokimenko (Playrix) o mobile games</a></li>
<li><a href="../315828/index.html">How to stop the outflow of people from the online course and at the same time get to the hackathon</a></li>
<li><a href="../315830/index.html">What information is sent and stored in the cloud of EPP and EDR solutions</a></li>
<li><a href="../315832/index.html">Is your website accessible from China and features of Chinese hosting?</a></li>
<li><a href="../315834/index.html">So when does email die?</a></li>
<li><a href="../315836/index.html">A selection of video materials on the development of Xamarin + key news Connect (); // 2016</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>