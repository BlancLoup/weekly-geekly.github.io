<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generalized programming techniques in Rust: how we translated Exonum from Iron to actix-web</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust Ecosystem is still not fully settled. It often has new libraries that are noticeably better than its predecessors, and previously popular framewo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generalized programming techniques in Rust: how we translated Exonum from Iron to actix-web</h1><div class="post__text post__text-html js-mediator-article">  Rust Ecosystem is still not fully settled.  It often has new libraries that are noticeably better than its predecessors, and previously popular frameworks are becoming obsolete.  This is exactly what happened with the Iron web framework, which we used when developing Exonum. <br><br>  Actix-web was chosen to replace Iron.  Then I will tell you how we have ported the existing code to a new solution, using generalized programming techniques. <br><br> <a href="https://habr.com/company/bitfury/blog/429450/"><img src="https://habrastorage.org/webt/c1/e0/un/c1e0unbkgiazhkhwcm7m5yt5v24.jpeg"></a> <a name="habracut"></a><br>  <font color="#A9A9A9"><i>Image of <a href="https://pixnio.com/objects/metal-macro-iron-detail-object-mechanism-steel-machine-rust">ulleo</a> PD</i></font> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  How we used Iron </h2><br>  In Exonum, the Iron framework was used without any abstractions.  We installed handlers for certain resources, request parameters were obtained by parsing URLs with auxiliary methods, and the result was returned simply as a string. <br><br>  It looked like this: <br><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_blocks_response</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, router: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Router) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> blocks = <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| -&gt; IronResult&lt;Response&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.required_param(req, <span class="hljs-string"><span class="hljs-string">"count"</span></span>)?; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> latest: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>&gt; = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.optional_param(req, <span class="hljs-string"><span class="hljs-string">"latest"</span></span>)?; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> skip_empty_blocks: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.optional_param(req, <span class="hljs-string"><span class="hljs-string">"skip_empty_blocks"</span></span>)? .unwrap_or(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> info = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.blocks(count, latest.map(Height), skip_empty_blocks)?; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ok_response(&amp;::serde_json::to_value(info).unwrap()) }; router.get(<span class="hljs-string"><span class="hljs-string">"/v1/blocks"</span></span>, blocks, <span class="hljs-string"><span class="hljs-string">"blocks"</span></span>); }</code> </pre> <br>  In addition, some middleware add-ons in the form of CORS headers were used.  To combine all the handlers into a single API, we used mount. <br><br><h2>  Why had to refuse him </h2><br>  Iron was a good ‚Äúworkhorse‚Äù with a lot of extras.  However, it was written in those days when projects such as futures and <a href="https://habr.com/company/bitfury/blog/351824/">tokio</a> did not exist. <br><br>  The Iron architecture provides for synchronous processing of requests, so it was easy to fit on the blades with a large number of simultaneously open connections.  For Iron to become scalable, it should be made asynchronous.  For this it was necessary to rethink and rewrite the entire framework, but the developers gradually abandoned the work on it. <br><br><h2>  Why we switched to actix-web </h2><br>  This is a popular framework that ranks high <a href="https://www.techempower.com/benchmarks/">on TechEmpower benchmarks</a> .  At the same time, unlike Iron, it is actively developing.  Actix-web has a well-designed API and high-quality implementation based on the actix actor framework.  Requests are processed asynchronously by the thread pool, and if processing causes panic, the actor is automatically restarted. <br><br>  Of course, actix-web had drawbacks, for example, it contained a large amount of unsafe code.  But later he was rewritten to Safe Rust, which solved this problem. <br><br><blockquote>  The transition to actix solved the problem with the stability of the work.  Iron-backend could drop a large number of connections.  In general, the new API is a simpler, more productive and unified solution.  It will be easier for users and developers to use the software interface, and its speed will increase. </blockquote><br><h2>  What do we want from a web framework </h2><br>  It was important for us not just to change Iron to actix-web, but to make the groundwork for the future - to work out a new API architecture for abstracting from a specific web framework.  This will allow to create handlers, almost without thinking about web-specificity, and transfer them to any backend.  This can be done by writing a frontend that would operate on basic types and types. <br><br>  To understand what this frontend looks like, let's define what any HTTP API is: <br><br><ul><li>  Requests are made exclusively by clients, and the server only responds to them (it does not initiate). </li><li>  Requests are for reading and changing. </li><li>  As a result of the request, the server returns a response, which, when successful, contains the required data, and in case of an error, contains information about it. </li></ul><br>  If you analyze all the layers of abstraction, it turns out that any HTTP request is just a function call: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span></span>(context: &amp;ServiceContext, query: Query) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;Response, ServiceError&gt;</code> </pre> <br>  Everything else can be considered extensions of this basic entity.  Thus, in order to abstract from a specific implementation of a web framework, we need to write handlers in a style similar to the example above. <br><br><h5>  Endpoint for generalized processing of HTTP requests </h5><br>  You can go the simplest and most straightforward way and declare a type Endpoint, <br>  Describing the implementation of specific queries: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// ,   GET .      //    ,      . //         . trait Endpoint: Sync + Send + 'static { type Request: DeserializeOwned + 'static; type Response: Serialize + 'static; fn handle(&amp;self, context: &amp;Context, request: Self::Request) -&gt; Result&lt;Self::Response, io::Error&gt;; }</span></span></code> </pre><br>  After that, you will need to implement this handler in a specific framework.  Let's say for actix-web it looks like this: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//    actix-web.  ,   , //  `Endpoint`   . type FutureResponse = actix_web::FutureResponse&lt;HttpResponse, actix_web::Error&gt;; // ¬´¬ª    actix-web.      //   .     , //     . type RawHandler = dyn Fn(HttpRequest&lt;Context&gt;) -&gt; FutureResponse + 'static + Send + Sync; //   ,     ,     . #[derive(Clone)] struct RequestHandler { ///  . pub name: String, /// HTTP . pub method: actix_web::http::Method, ///  .  ,       . pub inner: Arc&lt;RawHandler&gt;, }</span></span></code> </pre><br>  Structures can be used to pass request parameters through context.  Actix-web is able to automatically de-serialize parameters using serde.  For example, a = 15 &amp; b = hello is deserialized into a structure of the following form: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleQuery</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre><br>  This agrees well with the associated Request type from the Endpoint type. <br><br>  Now we‚Äôll write an adapter that "wraps" the concrete Endpoint implementation in RequstHandler for actix-web.  Please note that in the process information about Request and Response types is lost.  This technique is called type erasure.  Its task is to turn static dispatching into dynamic. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> RequestHandler { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_endpoint</span></span></span></span>&lt;E: Endpoint&gt;(name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, endpoint: E) -&gt; RequestHandler { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |request: HttpRequest&lt;Context&gt;| -&gt; FutureResponse { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = request.state(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> future = Query::from_request(&amp;request, &amp;()) .map(|query: Query&lt;E::Request&gt;| query.into_inner()) .and_then(|query| endpoint.handle(context, query).map_err(<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from)) .and_then(|value| <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(HttpResponse::<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>().json(value))) .into_future(); <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(future) }; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { name: name.to_owned(), method: actix_web::http::Method::GET, inner: Arc::from(index) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Arc&lt;RawHandler&gt;, } } }</code> </pre><br>  At this stage, you can add handlers for POST requests and stop, since we have created a type that abstracts implementation details.  However, it is still not very ergonomic. <br><br><h5>  Type problems </h5><br>  When writing a handler, a lot of auxiliary code is generated: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//    . struct ElementCountEndpoint { elements: Rc&lt;RefCell&lt;Vec&lt;Something&gt;&gt;&gt;, } //   Endpoint. impl Endpoint for ElementCountEndpoint { type Request = (); type Result = usize; fn handle(&amp;self, context: &amp;Context, _request: ()) -&gt; Result&lt;usize, io::Error&gt; { Ok(self.elements.borrow().len()) } } //    . let endpoint = ElementCountEndpoint::new(elements.clone()); let handler = RequestHandler::from_endpoint("/v1/element_count", endpoint); actix_backend.endpoint(handler);</span></span></code> </pre><br>  Ideally, you want to be able to pass a normal closure as a handler, reducing the amount of syntactic noise by an order of magnitude: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> elements = elements.clone(); actix_backend.endpoint(<span class="hljs-string"><span class="hljs-string">"/v1/elements_count"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || {   <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(elements.borrow().len()) });</code> </pre><br>  How to do this, I will discuss further. <br><br><h2>  Easy immersion in generalized programming </h2><br>  We need to implement the ability to automatically generate an adapter that implements an Endpoint with the correct associated types.  Only a closure with an HTTP request handler will be sent to the input. <br><br>  Arguments and the result of the closure can be of different types, so you will have to work with overloading methods here.  Rust does not support overloading directly, but allows it to be emulated using the Into and From types. <br><br>  In addition, the return type of the closure does not have to match the return value of the Endpoint implementation.  To manipulate this type, it must be extracted from the type of received circuit. <br><br><h5>  Fetching Types from Fn Type </h5><br>  In Rust, each closure has a unique type that cannot be explicitly written in the program.  For manipulation of closures, there is a type Fn.  It contains the signature of the function with the types of the arguments and the return value, but retrieving them separately is not so easy. <br><br>  The basic idea is to use a supporting structure of the following form: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///       F: Fn(A) -&gt; B. struct SimpleExtractor&lt;A, B, F&gt; {   //   .   inner: F,   _a: PhantomData&lt;A&gt;,   _b: PhantomData&lt;B&gt;, }</span></span></code> </pre><br>  We are forced to use PhantomData, since Rust requires that all the generalization parameters be in the definition of the structure.  However, the specific type of closure or function F is not generalized (although it implements a generalized type of Fn).  The type parameters A and B are not directly used in it. <br><br>  It is this restriction of the Rust type system that does not allow using a simpler strategy - to implement the Endpoint type for closures directly: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; Endpoint <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span></span> = A; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span></span> = B; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, context: &amp;Context, request: A) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;B, io::Error&gt; { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre><br>  The compiler in this case returns an error: <br><br><pre> <code class="rust hljs">error[E0207]: the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parameter</span></span></span></span> `A` is not constrained by the <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">or</span></span></span></span> predicates --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span> | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; Endpoint <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B { | ^ unconstrained <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parameter</span></span></span></span></code> </pre><br>  The supporting structure of SimpleExtractor makes it possible to describe the From conversion.  It allows you to save any function and extract the types of its arguments: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> SimpleExtractor&lt;A, B, F&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B, A: DeserializeOwned, B: Serialize, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(inner: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { SimpleExtractor { inner, _a: PhantomData, _b: PhantomData, } } }</code> </pre><br>  The following code compiles successfully: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Query</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">//   . fn my_handler(_: &amp;Context, q: Query) -&gt; String { format!("{} has {} apples.", qb, qa) } let fn_extractor = SimpleExtractor::from(my_handler); //  . let c = 15; let my_closure = |_: &amp;Context, q: Query| -&gt; String { format!("{} has {} apples, but Alice has {}", qb, qa, c) }; let closure_extractor = SimpleExtractor::from(my_closure);</span></span></code> </pre><br><h5>  Specialization and Marker Types </h5><br>  Now we have a function with explicitly parameterized argument types, suitable for use instead of Endpoint.  For example, we can easily implement the conversion from SimpleExtractor to RequestHandler.  Still, this is not a complete solution.  You also need to somehow distinguish between GET request handlers and POST requests at the type level (and synchronous handlers from asynchronous).  So-called marker types will help us with this. <br><br>  To begin with, we will rewrite SimpleExtractor so that it can distinguish between synchronous and asynchronous results.  At the same time we realize the type From for each of the cases.  Please note that types can be implemented for specific variants of generalized structures. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///   HTTP-. pub struct With&lt;Q, I, R, F&gt; { ///  -. pub handler: F, ///     . _query_type: PhantomData&lt;Q&gt;, ///   . _item_type: PhantomData&lt;I&gt;, ///  ,  . ///  ,       . _result_type: PhantomData&lt;R&gt;, } //   ,   . impl&lt;Q, I, F&gt; From&lt;F&gt; for With&lt;Q, I, Result&lt;I&gt;, F&gt; where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt;, { fn from(handler: F) -&gt; Self { Self { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } } //     . impl&lt;Q, I, F&gt; From&lt;F&gt; for With&lt;Q, I, FutureResult&lt;I&gt;, F&gt; where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt;, { fn from(handler: F) -&gt; Self { Self { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } }</span></span></code> </pre><br>  Now we need to declare the structure in which to combine the request handler with its name and type: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamedWith</span></span></span></span>&lt;Q, I, R, F, K&gt; {   <span class="hljs-comment"><span class="hljs-comment">///  .   pub name: String,   ///    .   pub inner: With&lt;Q, I, R, F&gt;,   ///  .   _kind: PhantomData&lt;K&gt;, }</span></span></code> </pre><br>  After that, you can declare several empty structures that will act as marker types.  Markers allow you to implement for each of the handlers your conversion code to the previously described RequestHandler. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// ,    .  HTTP   GET-. pub struct Immutable; /// ,   .  HTTP   POST, PUT, UPDATE ///    ,        POST. pub struct Mutable;</span></span></code> </pre><br>  Now we can define four different implementations of the type From For all combinations of template parameters R and K (the return value of the handler and the type of request). <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//     get . impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, Result&lt;I&gt;, F, Immutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt; + 'static + Send + Sync + Clone, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, Result&lt;I&gt;, F, Immutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let context = request.state(); let future = Query::from_request(&amp;request, &amp;()) .map(|query: Query&lt;Q&gt;| query.into_inner()) .and_then(|query| handler(context, query).map_err(From::from)) .and_then(|value| Ok(HttpResponse::Ok().json(value))) .into_future(); Box::new(future) }; Self { name: f.name, method: actix_web::http::Method::GET, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } //     post . impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, Result&lt;I&gt;, F, Mutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt; + 'static + Send + Sync + Clone, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, Result&lt;I&gt;, F, Mutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let handler = handler.clone(); let context = request.state().clone(); request .json() .from_err() .and_then(move |query: Q| { handler(&amp;context, query) .map(|value| HttpResponse::Ok().json(value)) .map_err(From::from) }) .responder() }; Self { name: f.name, method: actix_web::http::Method::POST, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } //     get . impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Immutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt; + 'static + Clone + Send + Sync, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Immutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let context = request.state().clone(); let handler = handler.clone(); Query::from_request(&amp;request, &amp;()) .map(move |query: Query&lt;Q&gt;| query.into_inner()) .into_future() .and_then(move |query| handler(&amp;context, query).map_err(From::from)) .map(|value| HttpResponse::Ok().json(value)) .responder() }; Self { name: f.name, method: actix_web::http::Method::GET, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } //     post . impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Mutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt; + 'static + Clone + Send + Sync, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Mutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let handler = handler.clone(); let context = request.state().clone(); request .json() .from_err() .and_then(move |query: Q| { handler(&amp;context, query) .map(|value| HttpResponse::Ok().json(value)) .map_err(From::from) }) .responder() }; Self { name: f.name, method: actix_web::http::Method::POST, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } }</span></span></code> </pre><br><h5>  "Facade" for backend </h5><br>  Now for all this it remains to write the "facade", which would take the circuit and add them to the corresponding backend.  In our case, there is only one backend - actix-web - but behind the facade you can hide any additional implementations, for example, the generator of Swagger-specifications. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceApiScope</span></span></span></span> { actix_backend: actix::ApiBuilder, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ServiceApiScope { <span class="hljs-comment"><span class="hljs-comment">///    Immutable    . pub fn endpoint&lt;Q, I, R, F, E&gt;(&amp;mut self, name: &amp;'static str, endpoint: E) -&gt; &amp;mut Self where //     ,      : Q: DeserializeOwned + 'static, I: Serialize + 'static, F: Fn(&amp;ServiceApiState, Q) -&gt; R + 'static + Clone, E: Into&lt;With&lt;Q, I, R, F&gt;&gt;, //  ,          //  NamedWith  RequestHandler. RequestHandler: From&lt;NamedWith&lt;Q, I, R, F, Immutable&gt;&gt;, { self.actix_backend.endpoint(name, endpoint); self } ///    Mutable . pub fn endpoint_mut&lt;Q, I, R, F, E&gt;(&amp;mut self, name: &amp;'static str, endpoint: E) -&gt; &amp;mut Self where Q: DeserializeOwned + 'static, I: Serialize + 'static, F: Fn(&amp;ServiceApiState, Q) -&gt; R + 'static + Clone, E: Into&lt;With&lt;Q, I, R, F&gt;&gt;, RequestHandler: From&lt;NamedWith&lt;Q, I, R, F, Mutable&gt;&gt;, { self.actix_backend.endpoint_mut(name, endpoint); self }</span></span></code> </pre><br>  Notice how the types of the query parameters, the type of its result, and the synchronicity / asynchrony of the handler are derived automatically from its signature.  Additionally, you must explicitly specify the name of the request, as well as its type <br><br><h2>  Disadvantages approach </h2><br>  This approach still has its drawbacks.  In particular, <i>endpoint and endpoint_mut should know the specifics of the implementation of specific backends</i> .  This does not allow us to add backends on the fly, but this functionality is rarely needed. <br><br>  Another problem is that <i>you cannot define a specialization for a handler without additional arguments.</i>  In other words, if we write the following code, it will not compile because it conflicts with the existing generalized implementation: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;(), I, F&gt; <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> With&lt;(), I, <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;I&gt;, F&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;ServiceApiState) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;I&gt;, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(handler: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } }</code> </pre> <br>  As a result, requests that do not have parameters must still accept the JSON string null, which is deserialized into ().  This problem could be solved by specialization in the C ++ style, but for now it is available only in the nightly-version of the compiler and it is not clear when it ‚Äústabilizes‚Äù. <br><br>  <i>Similarly, the type of return value cannot be specialized.</i>  Even if the request does not imply it, it will always give JSON with null. <br><br>  <i>Decoding the URL query in GET requests also imposes some unobvious restrictions on the type of parameters,</i> but these are already features of the serde-urlencoded implementation. <br><br><h2>  Conclusion </h2><br>  Thus, we have implemented an API that allows you to simply and clearly create handlers, almost without thinking about web specifics.  Later, they can be transferred to any backends or even use several backends at the same time. </div><p>Source: <a href="https://habr.com/ru/post/429450/">https://habr.com/ru/post/429450/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../429440/index.html">Own VPN client on JavaScript. Part 8 - Electron Setting Component</a></li>
<li><a href="../429442/index.html">Own VPN client on JavaScript. Part 9 - Electron component Callback</a></li>
<li><a href="../429444/index.html">Own VPN client on JavaScript. 10 part - Combining all components</a></li>
<li><a href="../429446/index.html">Own VPN client on JavaScript. Part 11 - Building an Application for Windows</a></li>
<li><a href="../429448/index.html">We write the FPGA loader in LabVIEW. Part 2</a></li>
<li><a href="../429452/index.html">The Pentagon began to declassify other people's malware</a></li>
<li><a href="../429456/index.html">Already a story: how did a startup culture start in the 1930s</a></li>
<li><a href="../429458/index.html">How I did the animation of the solar system for a second-grade son</a></li>
<li><a href="../429460/index.html">Summary of the report ‚ÄúWhat we know about microservices‚Äù (HL2018, Avito, Vadim Madison)</a></li>
<li><a href="../429464/index.html">Can these 35-ton units solve a huge problem with renewable energy sources?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>