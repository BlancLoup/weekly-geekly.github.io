<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PCAP programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This text is a translation of Tim Karstens‚Äôs 2002 Programming with pcap article. There is not much PCAP information on the Russian-language Internet. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PCAP programming</h1><div class="post__text post__text-html js-mediator-article"><p>  This text is a translation of Tim Karstens‚Äôs 2002 <a href="http://www.tcpdump.org/pcap.htm"><strong>Programming with pcap</strong></a> article.  There is not much PCAP information on the Russian-language Internet.  The translation was made primarily for people who are interested in the subject of traffic capture, but they do not speak English well.  Under the cut, in fact, the translation itself. <a name="habracut"></a></p><br><h3 id="vstuplenie">  Introduction </h3><br><p>  Let's start by defining who this article is written for.  Obviously, some basic knowledge of C is necessary (unless, of course, you just want to understand the theory), to understand the code in the article, but you don‚Äôt need to be a programming ninja: in those moments that can be understood only by more experienced programmers, I will try explain in detail all the concepts.  Also, some basic knowledge of how networks work can help understanding, given that PCAP is a library for implementing sniffing (Note of translator: Sniffing is the process of capturing network traffic, yours, or someone else's).  All the code examples presented here were tested on FreeBSD 4.3 with the default kernel. </p><br><h3 id="nachalo-raboty-obschaya-forma-prilozheniya-pcap">  Getting Started: General PCAP Application Form </h3><br><p>  The first thing you need to understand is the overall structure of the PCAP sniffer.  It may look like this: </p><br><ol><li> We begin by defining the interface identifier from which we want to receive traffic.  In Linux, it could be something like <code>eth0</code> , in BSD it could be <code>xl1</code> , and so on.  We can either specify this identifier in the string, or ask PCAP to provide it to us. </li><li>  Next, you need to initialize the PCAP.  At this stage, we need to pass PCAP the name of the device with which we will work.  If necessary, we can capture traffic from multiple devices.  To distinguish them, we will use session descriptors.  Just like when working with files, we need to call our traffic capture session so that we can distinguish it from other similar sessions. </li><li>  In case we want to receive some kind of specific traffic (for example, only TCP / IP packets, or packets only from port 23, and so on), we must create a set of rules, "compile" them, and apply them to a specific session.  This is a three-phase, closely related process.  The set of rules is initially in a line, and then compiled into a clear PCAP format.  Compilation is performed by calling a function inside our program; it is not related to the use of any external application.  Next we tell PCAP to apply this filter to the session we need. </li><li>  Finally, we tell PCAP to start capturing traffic.  In the case of using <code>pcap_loop</code> , PCAP will work until it receives as many packets as we have indicated.  Every time he gets a new package, he calls a function defined by us.  This function can do everything we want.  She can read the package and transmit the information to the user, she can save it to a file, or not do anything at all. </li><li>  After we finish the capture, the session can be closed. <br>  This is actually a very simple process.  Only five steps, one of which is optional (step 3).  Let's look at each step, and their implementation. </li></ol><br><h4 id="opredelenie-ustroystva">  Device definition </h4><br><p>  It's terribly easy.  There are two ways to identify the device we want to listen to. </p><br><p>  The first is to simply allow the user to tell the program the name of the device from which he wants to capture traffic.  Consider this code: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;pcap.h&gt; int main(int argc, char *argv[]) { char *dev = argv[1]; printf("Device: %s\n", dev); return(0); }</span></span></span></span></code> </pre> <br><p>  The user defines the device specifying his name as the first argument of the program.  Now, the <code>dev</code> line contains the name of the interface that we will listen in in the format understandable by PCAP (of course, provided that the user gave us the real interface name) </p><br><p>  The second method is also very simple.  Let's take a look at the program: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;pcap.h&gt; int main(int argc, char *argv[]) { char *dev, errbuf[PCAP_ERRBUF_SIZE]; dev = pcap_lookupdev(errbuf); if (dev == NULL) { fprintf(stderr, "Couldn't find default device: %s\n", errbuf); return(2); } printf("Device: %s\n", dev); return(0); }</span></span></span></span></code> </pre> <br><p>  In this case, PCAP will simply set the device name itself.  "But wait, Tim," you say.  "What to do with the <code>errbuf</code> string?".  Most PCAP commands allow us to pass them a string as one of the arguments.  For what purpose?  In the event that the command fails, PCAP will write the error description to the transferred string.  In this case, if the execution of <code>pcap_lookupdev()</code> fails, the error message will be placed in <code>errbuf</code> .  Cool, is not it?  This is how the device name is set to capture traffic. </p><br><h4 id="nastroyka-ustroystva-dlya-sniffinga">  Device setup for sniffing </h4><br><p>  The task of creating a traffic capture session is also very simple.  For this we will use the <code>pcap_open_live()</code> function.  The prototype of this function: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pcap_t</span></span> *pcap_open_live(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *device, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> snaplen, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> promisc, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> to_ms, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ebuf)</code> </pre> <br><p>  The first argument is the device name that we defined in the previous section.  <code>snaplen</code> is an integer that specifies the maximum number of bytes that PCAP can capture.  <code>promisc</code> , when set to <code>true</code> , sets the device to promiscuous mode (anyway, even if it is set to <code>false</code> , in certain cases the interface may be in promiscuous mode).  <code>to_ms</code> is the read time in milliseconds (a value of 0 means no timeout; at least on some platforms, this means that you can wait for enough packets to stop sniffing before you finish analyzing these packets. Therefore, you should use non-zero time).  Finally, <code>ebuf</code> is a string in which we can store error messages (just like we did with <code>errbuf</code> ).  The function returns the session handle. </p><br><p>  For demonstration, consider this code snippet: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;pcap.h&gt; ... pcap_t *handle; handle = pcap_open_live(dev, BUFSIZ, 1, 1000, errbuf); if (handle == NULL) { fprintf(stderr, "Couldn't open device %s: %s\n", dev, errbuf); return(2); }</span></span></span></span></code> </pre> <br><p>  This code opens a device placed in the <code>dev</code> variable, says to read as many bytes as specified in <code>BUFSIZ</code> (a constant that is defined in pcap.h).  We say to switch the device into illegible mode, in order to capture traffic before any error occurs, and in case of an error, put its description in the <code>errbuf</code> line;  and after, in case of an error, we use this line to display a message about what went wrong. </p><br><p>  Comments on legible / unintelligible sniffing modes: the two methods are very different in style.  Usually, the interface is in legible mode, capturing only the traffic that is sent to him.  Only traffic directed from it, to it, or routed through it will be captured by a sniffer.  Illegible mode, on the contrary, captures all traffic that passes through the cable.  In a non-switching environment, this can be all network traffic.  The obvious advantage of this method is that it is possible to capture more packets, which may be useful, or not, depending on the purpose of capturing traffic.  However, there are disadvantages.  Illegible mode is easily detected, one node can clearly determine whether the other is in illegible mode or not.  It also works only in a non-switched environment (for example, a hub, or a router using APR).  Another disadvantage is that in networks with a large amount of traffic may not be enough system resources to capture and analyze all packets. </p><br><p>  Not all devices provide the same data link layer headers in the packets you read.  Ethernet devices, and some non-Ethernet devices, can provide Ethernet headers, but other types of devices, such as locking devices in BSD and OS X, PPP interfaces, and Wi-Fi interfaces in monitoring mode, do not. </p><br><p>  You need to determine the type of data link headers that the device provides and use it to analyze the contents of the packets.  <code>pcap_datalink()</code> returns the type of data link headers.  (See <a href="http://www.tcpdump.org/linktypes.html">list of data link header values</a> . Returned values ‚Äã‚Äãare DHT_ values ‚Äã‚Äãin this list) </p><br><p>  If your program does not support the link level headers provided by the device, then it will have to stop working with the following code: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pcap_datalink(handle) != DLT_EN10MB) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Device %s doesn't provide Ethernet headers -not supported\n"</span></span>, dev); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br><p>  which will work if the device does not support Ethernet headers.  This might work for the code below, which uses Ethernet headers. </p><br><h4 id="filtraciya-trafika">  Traffic filtering </h4><br><p>  Often we are interested in capturing only a certain type of traffic.  For example, it happens that the only thing we want is to capture traffic from port 23 (telnet) to search for passwords.  Or maybe we want to intercept the file that was sent via port 21 (FTP).  Maybe we want to capture only DNS traffic (port 53 UDP).  However, there are rare cases where we just want to blindly capture all Internet traffic.  Let's take a look at the <code>pcap_compile()</code> and <code>pcap_setfilter()</code> functions. </p><br><p>  The process is very simple.  After we called <code>pcap_open_live()</code> and have a running sniffing session, we can apply our filter.  You ask why not just use the usual <code>if</code> / <code>else if</code> expressions?  Two reasons: first, the PCAP filter is more efficient because it filters directly through BPF;  accordingly, we need far fewer resources, because the BPF driver does it directly.  The second is that PCAP filters are simply simpler. </p><br><p>  Before you apply a filter, we must compile it.  The filter condition is contained in a regular string (or an array of <code>char</code> ).  The syntax is well documented on the <a href="http://tcpdump.org/">tcpdump.org</a> main page;  I will leave it to you for independent consideration.  However, we will use simple test expressions, and, perhaps, you are sufficiently ingenious to deduce the rules of the syntax of these conditions from the examples given. </p><br><p>  To compile the filter, we call the <code>pcap_compile()</code> function.  The prototype defines this function as: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pcap_compile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pcap_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p, struct bpf_program *fp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> optimize, bpf_u_int32 netmask)</span></span></span></span></code> </pre> <br><p>  The first argument is our session descriptor ( <code>pcap_t* handle</code> in our previous example).  The next one is a pointer to the place where we will store the compiled version of the filter.  Next comes the expression itself, in the usual string format.  Then comes an integer that determines whether filter expressions need to be optimized or not (0 - no, 1 - yes).  Finally, we must define the network mask of the network to which we apply the filter.  The function returns -1 on error;  all other values ‚Äã‚Äãmean success. </p><br><p>  After compiling the filter, it's time to apply it.  Call <code>pcap_setfilter()</code> .  Following our PCAP explanation format, we need to consider a prototype of this function: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pcap_setfilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pcap_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p, struct bpf_program *fp)</span></span></span></span></code> </pre> <br><p>  It is very straightforward and simple.  The first argument is our session descriptor, the second is a pointer to the compiled version of our filter (it should be the same variable as in the previous <code>pcap_compile()</code> function). </p><br><p>  Perhaps this example will help you understand better: </p><br><div class="spoiler">  <b class="spoiler_title">Sample job, compile and apply PCAP filter</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;pcap.h&gt; ... pcap_t *handle; /*   */ char dev[] = "rl0"; /*    */ char errbuf[PCAP_ERRBUF_SIZE]; /*     */ struct bpf_program fp; /*   */ char filter_exp[] = "port 23"; /*   */ bpf_u_int32 mask; /*    */ bpf_u_int32 net; /* IP  */ if (pcap_lookupnet(dev, &amp;net, &amp;mask, errbuf) == -1) { fprintf(stderr, "Can't get netmask for device %s\n", dev); net = 0; mask = 0; } handle = pcap_open_live(dev, BUFSIZ, 1, 1000, errbuf); if (handle == NULL) { fprintf(stderr, "Couldn't open device %s: %s\n", dev, errbuf); return(2); } if (pcap_compile(handle, &amp;fp, filter_exp, 0, net) == -1) { fprintf(stderr, "Couldn't parse filter %s: %s\n", filter_exp, pcap_geterr(handle)); return(2); } if (pcap_setfilter(handle, &amp;fp) == -1) { fprintf(stderr, "Couldn't install filter %s: %s\n", filter_exp, pcap_geterr(handle)); return(2); }</span></span></span></span></code> </pre> </div></div><br><p>  This program is configured to sniff traffic that passes through port 23, in promiscuous mode, on the <code>rl0</code> device. </p><br><p>  You may notice that the previous example contains a function that we have not yet talked about.  <code>pcap_lookupnet()</code> is a function that, when given a device name, returns the IPv4 network number and the corresponding network mask (the network number is an IPv4 ANDed address with a network mask, so it contains only the network part of the address).  This is important because we need to know the network mask for applying the filter. </p><br><p>  In my experience, this filter does not work on some operating systems.  In my test environment, I found that OpenBSD 2.9 with the kernel supported this filter type by default, but FreeBSD 4.3 with the default kernel did not.  Your experience may vary. </p><br><h3 id="realnyy-sniffing">  Real sniffing </h3><br><p>  At the current stage, we learned how to determine the device, prepare it to capture traffic, and apply filters.  Now is the time to grab a few packages.  There are two main ways to capture packets.  We can simply capture one packet, or we can enter a loop that runs until n packets are captured.  We begin by showing how to capture one packet, and then consider the methods of using loops.  <code>pcap_next()</code> look at the <code>pcap_next()</code> prototype: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u_char *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pcap_next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pcap_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p, struct pcap_pkthdr *h)</span></span></span></span></code> </pre> <br><p>  The first argument is the session descriptor.  The second is a pointer to a structure that contains general information about the packet, specifically, the time at which it was captured, the length of the packet, and the length of its specific part (for example, if it is fragmented).  <code>pcap_next()</code> returns a <code>u_char</code> pointer to the packet, which is described in the structure.  We will talk about reading packages later. </p><br><p>  This is a demonstration of using <code>pcap_next()</code> to capture packets: </p><br><div class="spoiler">  <b class="spoiler_title">Capture one packet</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;pcap.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { pcap_t *handle; /*   */ char *dev; /*    */ char errbuf[PCAP_ERRBUF_SIZE]; /*     */ struct bpf_program fp; /*   */ char filter_exp[] = "port 23"; /*   */ bpf_u_int32 mask; /*   */ bpf_u_int32 net; /* IP */ struct pcap_pkthdr header; /*     PCAP */ const u_char *packet; /*  */ /*   */ dev = pcap_lookupdev(errbuf); if (dev == NULL) { fprintf(stderr, "Couldn't find default device: %s\n", errbuf); return(2); } /*    */ if (pcap_lookupnet(dev, &amp;net, &amp;mask, errbuf) == -1) { fprintf(stderr, "Couldn't get netmask for device %s: %s\n", dev, errbuf); net = 0; mask = 0; } /*      */ handle = pcap_open_live(dev, BUFSIZ, 1, 1000, errbuf); if (handle == NULL) { fprintf(stderr, "Couldn't open device %s: %s\n", dev, errbuf); return(2); } /*     */ if (pcap_compile(handle, &amp;fp, filter_exp, 0, net) == -1) { fprintf(stderr, "Couldn't parse filter %s: %s\n", filter_exp, pcap_geterr(handle)); return(2); } if (pcap_setfilter(handle, &amp;fp) == -1) { fprintf(stderr, "Couldn't install filter %s: %s\n", filter_exp, pcap_geterr(handle)); return(2); } /*   */ packet = pcap_next(handle, &amp;header); /*    */ printf("Jacked a packet with length of [%d]\n", header.len); /*   */ pcap_close(handle); return(0); }</span></span></span></span></code> </pre> </div></div><br><p>  An application captures the traffic of any device received through <code>pcap_loockupdev()</code> , putting it in promiscuous mode.  It detects that the packet goes to port 23 (telnet) and tells the user the size of the packet (in bytes).  Again, the program includes the <code>pcap_close()</code> call, which we will discuss later (although it is quite understandable). </p><br><p>  The second way to capture traffic is to use <code>pcap_loop()</code> or <code>pcap_dispatch()</code> (which in turn uses <code>pcap_loop()</code> ).  To understand the use of these two functions, we need to understand the idea of ‚Äã‚Äãa callback function. </p><br><p>  The callback function is not something new, it is a common thing in a lot of APIs.  The concept behind the callback function is very simple.  Suppose that there is a program that is waiting for an event of a certain kind.  Just for example, suppose the program is waiting for a keypress.  Every time a user presses a key, my program will call a function to handle this keystroke.  This is the callback function.  These functions are used in PCAP, but instead of calling them at the moment a key is pressed, they are called when PCAP captures a packet.  You can use callback functions only in pcap_loop () and pcap_dispatch () which are very similar in this regard.  Each of them calls the callback function each time a packet gets through which passes through the filter (if there is a filter of course. If not, all packets that were captured will call the callback function). </p><br><p>  The <code>pcap_loop()</code> prototype is shown below: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pcap_loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pcap_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cnt, pcap_handler callback, u_char *user)</span></span></span></span></code> </pre> <br><p>  The first argument is the session descriptor.  Next comes an integer that tells <code>pcap_loop()</code> number of packets that need to be captured (a negative value means that the loop must run before an error occurs).  The third argument is the name of the callback function (id only, no parameters).  The last argument is useful in some applications, but in most cases it is simply set to NULL.  Suppose that we have arguments that we want to pass to the callback function, in addition to those that are passed to it by <code>pcap_loop()</code> .  The final argument is where we make it.  Obviously, you must bring them to the <code>u_char *</code> type to make sure that you get the right results.  As we will see later, PCAP uses some interesting ways to transfer information in the form of <code>u_char *</code> .  After we show an example of how PCAP does this, it will be obvious how to do it in this moment.  If not, refer to the reference text on C, since the explanations of the pointers are beyond the scope of this document.  <code>pcap_dispatch()</code> almost identical in use.  The only difference between <code>pcap_dispatch()</code> and <code>pcap_loop()</code> is that <code>pcap_dispatch()</code> will only process the first series of packets received from the system, while pcap_loop () will continue processing packets or batches of packets until the counter ends.  For a more in-depth discussion of the differences, see the official PCAP documentation. </p><br><p>  Before we give an example of using <code>pcap_loop()</code> , we need to check the format of our callback function.  We cannot independently define the prototype of the callback function, otherwise <code>pcap_loop()</code> will not know how to use it.  So we have to use this format as a prototype of our callback function: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">got_packet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u_char *args, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct pcap_pkthdr *header, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u_char *packet)</span></span></span></span>;</code> </pre> <br><p>  Let's break it down in more detail.  First, the function must have a <code>void</code> type.  This is logical, because <code>pcap_loop()</code> would not know what to do with the return value anyway.  The first argument matches the last argument of <code>pcap_loop()</code> .  Regardless of what value is passed to the last argument <code>pcap_loop()</code> , it is passed to the first argument of our callback function.  The second argument is the PCAP header, which contains information about when the packet was captured, how big it is, and so on.  The <code>pcap_pkthdr</code> structure <code>pcap_pkthdr</code> defined in the pcap.h file as: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pcap_pkthdr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeval</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ts</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> bpf_u_int32 caplen; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> bpf_u_int32 len; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> };</code> </pre> <br><p>  These values ‚Äã‚Äãmust be sufficiently clear.  The last argument is the most interesting of all, and the most difficult to understand for a novice programmer.  This is another pointer to <code>u_char</code> , and it points to the first byte of the data section contained in the packet that was captured by <code>pcap_loop()</code> . </p><br><p>  But how can you use this variable (called packet) in the prototype?  A packet contains many attributes, so, as you can guess, this is not a string, but a set of structures (for example, a TCP / IP packet contains an Ethernet header, an IP header, a TCP header, and finally, data).  This <code>u_char</code> pointer points to the serialized version of these structures.  To start using one of them you need to make some interesting type conversions. </p><br><p> ,     ,        .       TCP/IP   Ethernet. </p><br><div class="spoiler"> <b class="spoiler_title">  Ethernet, IP, TCP</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Ethernet    6  */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ETHER_ADDR_LEN 6 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  Ethernet */</span></span></span><span class="hljs-meta"> struct sniff_ethernet { u_char ether_dhost[ETHER_ADDR_LEN]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> u_char ether_shost[ETHER_ADDR_LEN]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> u_short ether_type; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* IP? ARP? RARP?  .. */</span></span></span><span class="hljs-meta"> }; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* IP header */</span></span></span><span class="hljs-meta"> struct sniff_ip { u_char ip_vhl; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  &lt;&lt; 4 |   &gt;&gt; 2 */</span></span></span><span class="hljs-meta"> u_char ip_tos; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> u_short ip_len; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> u_short ip_id; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  */</span></span></span><span class="hljs-meta"> u_short ip_off; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IP_RF 0x8000 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* reserved   */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IP_DF 0x4000 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* dont   */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IP_MF 0x2000 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* more   */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IP_OFFMASK 0x1fff </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     */</span></span></span><span class="hljs-meta"> u_char ip_ttl; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> u_char ip_p; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  */</span></span></span><span class="hljs-meta"> u_short ip_sum; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> struct in_addr ip_src,ip_dst; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*      */</span></span></span><span class="hljs-meta"> }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IP_HL(ip) (((ip)-&gt;ip_vhl) &amp; 0x0f) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IP_V(ip) (((ip)-&gt;ip_vhl) &gt;&gt; 4) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* TCP header */</span></span></span><span class="hljs-meta"> typedef u_int tcp_seq; struct sniff_tcp { u_short th_sport; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> u_short th_dport; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> tcp_seq th_seq; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> tcp_seq th_ack; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> u_char th_offx2; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  , rsvd */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TH_OFF(th) (((th)-&gt;th_offx2 &amp; 0xf0) &gt;&gt; 4) u_char th_flags; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TH_FIN 0x01 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TH_SYN 0x02 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TH_RST 0x04 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TH_PUSH 0x08 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TH_ACK 0x10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TH_URG 0x20 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TH_ECE 0x40 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TH_CWR 0x80 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TH_FLAGS (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR) u_short th_win; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  */</span></span></span><span class="hljs-meta"> u_short th_sum; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> u_short th_urp; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> };</span></span></code> </pre> </div></div><br><p>         PCAP    <code>u_char</code> ?    ,    .        ?         (          :   ). </p><br><p>  ,   ,      TCP/IP  Ethernet.       .   ‚Äî   ,    . ,         .      . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*  Ethernet    14  */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SIZE_ETHERNET 14 const struct sniff_ethernet *ethernet; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  Ethernet */</span></span></span><span class="hljs-meta"> const struct sniff_ip *ip; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  IP */</span></span></span><span class="hljs-meta"> const struct sniff_tcp *tcp; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  TCP */</span></span></span><span class="hljs-meta"> const char *payload; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> u_int size_ip; u_int size_tcp;</span></span></code> </pre> <br><p>        : </p><br><pre> <code class="cpp hljs">ethernet = (struct sniff_ethernet*)(packet); ip = (struct sniff_ip*)(packet + SIZE_ETHERNET); size_ip = IP_HL(ip)*<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size_ip &lt; <span class="hljs-number"><span class="hljs-number">20</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" * Invalid IP header length: %u bytes\n"</span></span>, size_ip); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } tcp = (struct sniff_tcp*)(packet + SIZE_ETHERNET + size_ip); size_tcp = TH_OFF(tcp)*<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size_tcp &lt; <span class="hljs-number"><span class="hljs-number">20</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" * Invalid TCP header length: %u bytes\n"</span></span>, size_tcp); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } payload = (u_char *)(packet + SIZE_ETHERNET + size_ip + size_tcp);</code> </pre> <br><p>  How it works?     . <code>u_char</code>  ‚Äî      . </p><br><p>  ,  ,         <code></code> . ,       ,     ‚Äî <code>sniff_ethernet</code> ,       <code></code> ,          .   ‚Äî  <code></code>   Ethernet ,   14,  <code>SIZE_ETHERNET</code> . </p><br><p> ,       ,      ‚Äî       .  IP,     Ethernet,    .      4-     IP.    4- ,      4,      .      20 . </p><br><p> TCP      ,      4- ,   " "  TCP,        20 . </p><br><p> ,   : </p><br><table><tbody><tr><th> VARIABLE </th><th> LOCATION(in bytes) </th></tr><tr><td> sniff_ethernet </td><td>  X </td></tr><tr><td> sniff_ip </td><td> X + SIZE_ETHERNET </td></tr><tr><td> sniff_tcp </td><td> X + SIZE_ETHERNET + {IP header length} </td></tr><tr><td>  payload </td><td> X + SIZE_ETHERNET + {IP header length} + {TCP header length} </td></tr></tbody></table><br><p> <code>sniff_ethernet</code> ,    ,     <code></code> . <code>sniff_ip</code> ,     <code>sniff_ethernet</code> ,   <code></code>    ,    <code>sniff_ethernet</code> (14   <code>SIZE_ETHERNET</code> ). <code>sniff_tcp</code>      ,      ‚Äî <code>X</code>   Ethernet,  IP . (14 ,  4    IP). ,  (     )    . </p><br><p> ,     ,     ,        .       .   <a href="">sniffer.c</a>   . </p><br><h3 id="zavershenie">  Completion </h3><br><p>           PCAP.         PCAP ,      ,  ,     .        . </p><br><blockquote>   2002.   .   ,          : <br>            : <br>           ,    ,     . <br><br> This document is Copyright 2002 Tim Carstens.  All rights reserved. Redistribution and use, with or without modification, are permitted provided that the following conditions are met: <br> Redistribution must retain the above copyright notice and this list of conditions. <br> The name of Tim Carstens may not be used to endorse or promote products derived from this document without specific prior written permission. <br> / <em>Insert 'wh00t' for the BSD license here</em> / </blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/337840/">https://habr.com/ru/post/337840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337828/index.html">How to create a user-friendly service catalog: do it in 9 steps</a></li>
<li><a href="../337830/index.html">Incident solution ServiceNow comes to Slack</a></li>
<li><a href="../337832/index.html">How ServiceNow began: a brief history of the company</a></li>
<li><a href="../337834/index.html">How companies move their infrastructure to the cloud and avoid mistakes</a></li>
<li><a href="../337836/index.html">Weekend Literature: 15 Code Structuring Materials for Developers</a></li>
<li><a href="../337842/index.html">How to speed up the loading site</a></li>
<li><a href="../337844/index.html">We invite you to Hackathon "M.Video": we are looking for solutions on the topic of AI and machine learning</a></li>
<li><a href="../337848/index.html">Hackathon HackCV, October 7-8</a></li>
<li><a href="../337852/index.html">Final Imagine Cup 2017 through the eyes of the MIPT team</a></li>
<li><a href="../337854/index.html">My 5 kopecks about Highload Cup 2017 or the history of the 9th place</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>