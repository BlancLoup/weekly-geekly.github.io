<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Quake III source code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Translator's note: the translation of the first part of this article is already on Habr√©, but for some reason its author has not completed the work.]...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Quake III source code</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/422/cf3/817/422cf381796e390e765c8e00c9bfd90b.jpg" alt="image"><br><br>  <i>[Translator's note: the translation of the first part of this article is already on Habr√©, but for some reason its author has not completed the work.]</i> <br><br><h2>  Quake III Renderer </h2><br>  The Quake III renderer was an evolutionary development of the hardware-accelerated Quake II renderer: the classic part is built on the ‚Äúbinary split‚Äù / ‚Äúpotentially visible set‚Äù architecture, but two new notable key aspects are added: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  A shader system built on top of a fixed OpenGL 1.X pipeline.  This was a great achievement for 1999.  It provided a large space for innovation in an era before the widespread today vertex, geometric and fragmentary shaders. <br></li><li>  Multi-core architecture support: the OpenGL client-server model blocks some methods and the threading system partially solves this problem. </li></ul><a name="habracut"></a><br><h3>  Architecture </h3><br>  The <code>renderer.lib</code> completely contained in <code>renderer.lib</code> and is statically linked to <code>quake3.exe</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/87a/44d/f19/87a44df198af43f93e51f1bf1490fd08.png"><br><br>  The overall architecture repeats Quake Classic: it uses the famous combination of BSP / PVS / lighting maps: <br><br><ul><li>  Preliminary processing: <br><ol><li>  The designer of the game creates using QRadiant .map and saves it. </li><li>  q3bsp.exe cuts the map into binary partitioning space (BSP).  I wrote about this in the Quake1 renderer review. </li><li>  A system of portals is generated from BSP: I wrote about this in an article about the <a href="http://fabiensanglard.net/doom3/dmap.php">Doom3 Dmap tool</a> . </li><li>  <code>q3vis.exe</code> uses the portal system and generates PVS (potentially visible set) for each sheet.  Each PVS is compressed and stored in the bsp file, as described in the previous article. </li><li>  Portal system is cleared. </li><li>  <code>q3light.exe</code> calculates the light for each polygon on the map and saves the result as a light map texture in the bsp file. </li><li>  At this stage, all pre-calculated data (PVS and lighting maps) are stored in the .bsp file. </li></ol></li><li>  Lead time: <br><ol><li>  The engine loads the map and bsp. </li><li>  When visualization is needed: </li><li>  The engine unzips the PVS for the current sheet and determines what <u>is actually</u> visible. </li><li>  For each polygon, it uses multi-texturing to combine a lightmap with color. </li></ol></li></ul><br>  The stage of multitexturing and lighting maps is clearly visible if you change the slider and display only one or the other: <br><br>  Texture drawn by level designer / artists: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dcc/6eb/546/dcc6eb5469a7618bee635b3eca07b798.jpg"><br><br>  Light map generated by <code>q3light.exe</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c1/63e/a3b/5c163ea3b930043741c7ba9777ace874.jpg"><br><br>  The final result when connecting using multitexturing at runtime: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b2/705/deb/5b2705deb11919a99100334561ea3118.jpg"><br><br>  The rendering architecture was reviewed by Brian Hook at the Game Developer Conference in 1999.  Unfortunately, <a href="http://www.gdcvault.com/play/1016403/The-Quake-3-Arena-Rendering">video from GDC Vault is</a> no longer available!  <i>[But it is on <a href="https://www.youtube.com/watch%3Fv%3DTFfkX_ahl94">youtube</a> .]</i> <br><br><h3>  Shaders </h3><br>  The shader system is built on top of the fixed OpenGL 1.X pipeline, and therefore is very expensive.  Developers can program vertex modifications, but also add texture passes.  This is covered in detail in the Quake 3 Shader bible bible shaders: <br> <a href="http://fd.fabiensanglard.net/quake3/Q3%2520Shaders.pdf"><img src="https://habrastorage.org/getpro/habr/post_images/719/e31/fa1/719e31fa12eb77bacb63cfea747c5dcd.png"></a> <br><br><h3>  Multicore renderer and SMP (symmetric multiprocessing) </h3><br>  Many do not know that Quake III Arena was released with <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BC%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D1%2587%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BC%25D1%2583%25D0%25BB%25D1%258C%25D1%2582%25D0%25B8%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BE%25D1%2580%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">SMP</a> support using cvariable <code>r_smp</code> .  Frontend and backend exchange information through the standard Producer-Consumer scheme.  When <code>r_smp</code> is set to 1, the surfaces being drawn are alternately stored in a double buffer located in RAM.  The frontend (which in this example is called <b>Main thread</b> ) alternately writes to one of the buffers, while the other reads the backend (in this example, it is called the <b>Renderer thread</b> ). <br><br>  An example demonstrates how everything works: <br><br>  <u>t0-t1:</u> <br><ul><li>  Main thread decides what to draw, and writes the surfaces in surfacebuffer1. </li><li>  There is no data for the Renderer thread, so it is blocked. </li><li>  The GPU thread also does nothing. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/ffe/355/9be/ffe3559beb531b6bd587035c0f582117.png"><br><br>  <u>t1-t2:</u> processes start everywhere: <br><ul><li>  The main thread decides what will be visible in the next frame.  It writes the surface to the surfacebuffer2 buffer: this is a typical example of double buffering. </li><li>  Meanwhile, the Renderer thread makes an OpenGL call and waits patiently until the GPU thread has copied everything to a safe place. </li><li>  The GPU thread reads the surface from where the Renderer thread points. </li></ul><br>  Notice that at t2: <br><ul><li>  Renderer thread still passes data to the GPU: SurfaceBuffer1 is used. </li><li>  Main thread finished writing to SurfaceBuffer2 ... but cannot start writing to SurfaceBuffer1: it is locked </li></ul><br>  This case (when the Renderer thread blocks the Main thread) often occurs when playing Quake III: <br>  Let us demonstrate limiting the blocking of one of the OpenGL API methods. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7d/16a/d68/c7d16ad68d4768463f271e74b43bf7d1.png"><br><br>  <u>After t2:</u> <br><ul><li>  As soon as the Renderer thread finishes with SurfaceBuffer1 (t3), it starts pumping surfaces from SurfaceBuffer2. </li><li>  As soon as it is unlocked (at t3), the Main thread starts working in the next frame, writing to SurfaceBuffer1. </li><li>  In this configuration, the GPU is almost never idle. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/636/421/ec4/636421ec45a20c218ebaea9d77abc826.png"><br><br>  <u><b>Note:</b></u> Synchronization is done through the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686915(v%3Dvs.85).aspx">Windows Event Objects</a> in <a href="">winglimp.c</a> (the part with SMP acceleration below). <br><br><h2>  Network model </h2><br>  The Quake3 network model is, without a doubt, the most elegant part of the engine.  At a low level, Quake III still abstracts data exchange with the <a href="https://habrahabr.ru/post/324804/">NetChannel module that first appeared in Quake World</a> .  The most important thing to understand is: <br><br>  In environments with a fast rhythm of change, any information not received during the first transmission is not worth re-sending, because it will still be outdated. <br><br>  Therefore, as a result, the engine uses UDP / IP: there are no TCP / IP traces in the code, because ‚Äúreliable transmission‚Äù creates an unacceptable delay.  The network stack has been enhanced by two mutually exclusive layers: <br><ul><li>  Encryption using a previously transmitted key. </li><li>  Compression using a pre-computed Huffman key. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/6e4/deb/fa5/6e4debfa5e4c343b2ac03d9c338edf11.png"><br><br>  But the most amazing design is on the server side, where the elegant system minimizes the size of each UDP datagram and compensates for the unreliability of UDP: the snapshot history generates delta parquets using memory introspection. <br><br><h3>  Architecture </h3><br>  The client side of the network model is quite simple: the client sends commands to the server every frame and receives game state updates.  The server side is a bit more complicated, because it must transfer the general state of the game to each client, taking into account the lost UDP packets.  This mechanism contains three main elements: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0d/547/d6b/f0d547d6b01ad4237fe0cf2998f48c3c.png"><br><br><ul><li>  <b>Master Gamestate</b> is a common, true state of things.  Clients send their teams to Netchannel.  They are converted to event_t, which change the state of the game when it is received by the server. </li><li>  For each client, the server stores the <b>last 32 game states</b> sent over the network in a cyclic array: they are called snapshots.  The array is cyclically moved using the famous binary mask trick I described in the Quake World Network article ( <a href="https://habrahabr.ru/post/324804/">elegant solutions</a> ). </li><li>  The server also has an <b>‚Äúempty‚Äù state</b> , in which each field has a value of 0. It is used for delta snapshots that do not have ‚Äúprevious states‚Äù. </li></ul><br>  When the server decides to send an update to the client, it uses all three elements in order to generate a message, which is then transmitted through NetChannel. <br><br>  <u><b>An interesting fact:</b></u> storing such a number of game states for each player takes up a large amount of memory: in my measurements, 8 MB for four players. <br><br><h3>  Snapshot system </h3><br>  To understand the system of snapshots, I will give an example with the following conditions: <br><ul><li>  The server sends the update to Client1. </li><li>  The server tries to transfer a state that has four fields to Client2 (three integer values ‚Äã‚Äãfor position [X], position [Y], position [Z] and one integer value for health). </li><li>  Communication takes place via UDP / IP: these messages are often lost on the Internet. </li></ul><br>  <u>Frame 1 server:</u> <br><br>  The server received several updates from each client.  They influenced the overall state of the game (green).  It is time to transfer the status to Client1 client: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/260/c8c/58e/260c8c58ef4fe726eacda0250a6108af.png"><br><br>  To generate a message, the network module ALWAYS does the following: <br><ol><li>  Copies the general state of the game in the next slot of the client's history. </li><li>  Compares it to another snapshot. </li></ol><br>  This is what we see in the next image. <br><br><ol><li>  The overall game state (Master gamestate) is copied with index 0 into Client1 history: it is now called ‚ÄúSnapshot1‚Äù. </li><li>  Since this is the first update in Client1 history of correct snapshots, therefore, the engine uses an empty ‚ÄúDummy snapshot‚Äù snapshot, in which all fields are set to zero.  This results in a FULL update because each field is sent to NetChannel. </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/044/4a6/720/0444a67205e9c39364b725220a2ae768.png"><br><br>  The most important thing to understand here is that if there are no valid snapshots in the client's history, the engine takes an empty snapshot to generate a delta message.  This results in a full update sent to the client in 132 bits (each field is <a href="">preceded by a bit marker</a> ): <code>[1 A_on32bits 1 B_on32bits 1 B_on32bits 1 C_on32bits]</code> . <br><br>  <u>Frame 2 servers:</u> <br>  Now let's move a little bit to the future: here is the second frame of the server.  As we can see, each client sent commands, and all of them influenced the overall state of the game Master gamestate: Client2 moved along the Y axis, so now pos [1] is equal to E (blue).  Client1 also sent commands, but, more importantly, it acknowledged receipt of the previous update, so Snapshot1 was marked as confirmed (‚ÄúACK‚Äù): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/440/cf4/932/440cf49322d5563fa77e0c373b1d2d2e.png"><br><br>  The process is the same: <br><br><ol><li>  The overall state of the game is copied to the following client history slot: (index 1): this is a Snapshot2 </li><li>  This time we have the right snapshot in our client history (snapshot1).  Compare these two snapshots </li></ol><br>  As a result, only a partial update is sent over the network (pos [1] = E).  This is the beauty of this design: the process is always the same. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4fc/a81/b40/4fca81b404ae1a2bc00b0654c4949394.png"><br><br>  <u>Note:</u> since each field is <a href="">preceded by a bit marker</a> (1 = changed, 0 = did not change), 36 bits are used for the partial update from the example above: <code>[0 1 32bitsNewValue 0 0]</code> . <br><br>  <u>Frame 3 servers:</u> <br>  Let's take another step forward to see how the system deals with lost packages.  Now we are in frame 3. Clients continue to send commands to the server. <br>  Client2 suffered damage and health is now equal to H. But Client1 did not confirm the last update.  It may be that the UDP server is lost, the client ACK may be lost, but as a result it cannot be used. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a4c/341/275/a4c3412752eaf6f167279b0a002295fb.png"><br><br>  Despite this, the process remains the same: <br><ol><li>  We copy the general state of the game into the following client history slot: (index 2): this is a Snapshot3 </li><li>  Compare the last valid confirmed snapshot (snapshot1). </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/1c2/ed7/d05/1c2ed7d05941b0f9bbcf3afe8e1bcfff.png"><br><br>  As a result, the message sends it partially and contains a combination of old and new changes: (pos [1] = E and health = H).  Note that snapshot1 may be too outdated to use.  In this case, the engine again uses "empty snapshot", which leads to a complete update. <br><br>  The beauty and elegance of the system is in its simplicity.  One algorithm automatically: <br><br><ul><li>  Generates partial or full updates. </li><li>  In one message, resends the OLD information that was not received and the NEW information. </li></ul><br><h3>  Introspection Memory on C </h3><br>  You may be wondering how Quake3 compares introspection snapshots ... because in C it doesn't exist. <br><br>  The answer is the following: each field location for <code>netField_t</code> is pre-created using an array and smart preprocessing directives: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bits; } netField_t; <span class="hljs-comment"><span class="hljs-comment">//        ... #define NETF(x) #x,(int)&amp;((entityState_t*)0)-&gt;x netField_t entityStateFields[] = { { NETF(pos.trTime), 32 }, { NETF(pos.trBase[0]), 0 }, { NETF(pos.trBase[1]), 0 }, ... }</span></span></code> </pre> <br>  The complete code for this part is in <code>MSG_WriteDeltaEntity</code> from <a href="">snapshot.c</a> .  Quake3 doesn't even know what it compares: it blindly uses the index, the offset and the size of the <code>entityStateFields</code> and sends differences across the network. <br><br><h3>  Pre-fragmentation </h3><br>  Having gone deep into the code, you can see that the NetChannel module cuts messages into blocks of 1400 bytes ( <a href=""><code>Netchan_Transmit</code></a> ), even though the maximum size of the UDP datagram is 65,507 bytes.  So the engine avoids packet breaking by routers when transmitting over the Internet, because most networks have a maximum packet size (MTU) of 1500 bytes.  Getting rid of fragmentation in routers is very important because: <br><br><ul><li>  When entering the network, the router must block the packet while it fragments it. </li><li>  When you leave the network, the problems are even more serious, because you need to wait for all the parts of the datagram, and then collect them with a lot of time. </li></ul><br><h3>  Messages with reliable and unreliable transmission </h3><br>  Although the snapshot system compensates for UDP datagrams lost in the network, some messages and commands must be delivered (for example, when a player leaves the game or when the server needs the client to download a new level). <br><br>  Such binding is abstracted by the NetChannel module: I wrote about this <a href="https://habrahabr.ru/post/324804/">in a previous post</a> . <br><br><h3>  Recommended reading </h3><br>  One of the developers, Brian Hook, <a href="">wrote a short article on the network model</a> . <br><br>  By Unlagged Neil "haste" Toronto, Neil "haste" Toronto <a href="http://www.ra.is/unlagged/network.html">also described it</a> . <br><br><h2>  Virtual machine </h2><br>  If the previous engines gave the virtual machine only gameplay, then idtech3 entrusts it with much more important tasks.  Among other things: <br><br><ul><li>  The visualization runs on the client virtual machine. </li><li>  The delay compensation mechanism is entirely implemented in the client VM. </li></ul><br>  Moreover, its design is much more complex: it combines the protection / portability of the Quake1 virtual machine with the high performance of Quake2 native DLLs.  This is achieved by compiling on-the-fly bytecode to x86 commands. <br><br>  <u><b>An interesting fact: the</b></u> virtual machine was originally supposed to be a simple bytecode interpreter, but the performance was very low.  Therefore, the development team wrote a runtime x86 compiler.  According to the <a href="http://fd.fabiensanglard.net/doom3/pdfs/johnc-plan_1999.pdf">.plan</a> file <a href="http://fd.fabiensanglard.net/doom3/pdfs/johnc-plan_1999.pdf">of August 16, 1999,</a> this task was accomplished in one day. <br><br><h3>  Architecture </h3><br>  The Quake III virtual machine is called QVM.  Its three parts are constantly loaded: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/06d/911/c55/06d911c55e261aabc8a643ac37e2665a.png"><br><br><ul><li>  Client side: loaded two virtual machines.  Depending on the state of the game, messages are sent to one of them: <br><ul><li>  <code>cgame</code> : receives messages in the combat phase.  Performs only clipping invisible graphics, predictions and manages <code>renderer.lib</code> . </li><li>  <code>q3_ui</code> : receives messages in menu mode.  Uses system calls to draw a menu. </li></ul><br></li><li>  Server side: <br><ul><li>  <code>game</code> : always receives messages, executes game logic and uses <code>bot.lib</code> for AI work. </li></ul></li></ul><br><h3>  QVM insides </h3><br>  Before we start using QVM, let's check how the bytecode is generated.  As usual, I prefer to explain with illustrations and a short accompanying text: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10a/f0f/05a/10af0f05ada087bde98a7d422d29b4b0.png"><br><br>  <code>quake3.exe</code> and its bytecode interpreter are generated using Visual Studio, but the bytecode VM uses a completely different approach: <br><br><ol><li>  Each .c file (translation module) is compiled separately using LCC. </li><li>  LCC is used with a special parameter, due to which the output is not carried out to PE (Windows Portable Executable), but to an intermediate representation, which is a text assembly of a stack machine.  Each file created consists of <code>text</code> , <code>data</code> and <code>bss</code> with the export and import of characters. </li><li>  The id Software special tool called <code>q3asm.exe</code> gets all the text assembly files and compiles them together into a .qvm file.  In addition, it converts all information from text to binary (for speed, in case it is impossible to apply native converted files).  Also, <code>q3asm.exe</code> recognizes methods called by the system. </li><li>  After downloading the binary bytecode, <code>quake3.exe</code> converts it to x86 commands (not necessarily required). </li></ol><br><h3>  LCC internals </h3><br>  Here is a specific example starting with the function that we need to run in the virtual machine: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variableA; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variableB; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variableC=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fooFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> variableA + <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); }</code> </pre> <br>  The <code>module.c</code> <code>lcc.exe</code> in the translation <code>module.c</code> <code>lcc.exe</code> called with a special flag to avoid generating a Windows PE object and perform output to an intermediate representation.  This is the output file .obj LCC, corresponding to the above C function: <br><br><pre> <code class="cpp hljs"> data <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> variableC align <span class="hljs-number"><span class="hljs-number">4</span></span> LABELV variableC byte <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> fooFunction code proc fooFunction <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> ADDRFP4 <span class="hljs-number"><span class="hljs-number">0</span></span> INDIRP4 ARGP4 ADDRLP4 <span class="hljs-number"><span class="hljs-number">0</span></span> ADDRGP4 <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> CALLI4 ASGNI4 ARGP4 variableA INDIRI4 ADDRLP4 <span class="hljs-number"><span class="hljs-number">0</span></span> INDIRI4 ADDI4 RETI4 LABELV $<span class="hljs-number"><span class="hljs-number">1</span></span> endproc fooFunction <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> bss <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> variableB align <span class="hljs-number"><span class="hljs-number">4</span></span> LABELV variableB skip <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> variableA</code> </pre> <br>  A few notes: <br><br><ul><li>  The bytecode is divided into parts ( <code>text</code> , <code>data</code> and <code>bss</code> ): we clearly see <code>bss</code> (uninitialized variables), <code>data</code> (initialized variables), and <code>code</code> (usually called <code>text</code> ) </li><li>  Functions are defined using a sandwich from <code>proc</code> , <code>endproc</code> . </li><li>  The LCC intermediate representation is a stack machine: all operations are performed on the stack and no assumptions are made about the CPU registers. </li><li>  At the end of the LCC phrase, we have a group of files importing / exporting variables / functions. </li><li>  Each announcement starts with a type of operation (for example, <code>ARGP4</code> , <code>ADDRGP4</code> , <code>CALLI4</code> ...).  Each parameter and result is transferred to the stack. </li><li>  Import and export are here, so the assembler can "link" the translation modules together.  Note that <code>import strlen</code> , because neither q3asm.exe nor the VM interpreter refer to the standard C library, <code>strlen</code> is considered a system call and is executed by the virtual machine. </li></ul><br>  Such a text file is generated for each .c file in the VM module. <br><br><h3>  Internals q3asm.exe </h3><br>  <code>q3asm.exe</code> gets the text files of the LCC intermediate view and assembles them together into a .qvm file: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/845/d4a/c44/845d4ac44899e6f6e6da5daa092c8ddd.png"><br><br>  Here you can see the following: <br><br><ul><li>  q3asm understands each of the import / export characters in text files. </li><li>  Some methods are predefined in a text file of system calls.  You can see <a href="">syscall for the client VM</a> and <a href="">for the server VM</a> .  Symbols in system calls have attributes in the form of negative integer values ‚Äã‚Äãso that the interpreter can recognize them. </li><li>  q3asm changes the view from text to binary in order to get space and speed, but nothing more, no optimizations are performed here. </li><li>  The first method you collect <b>should be</b> <code>vmMain</code> , because it is an input manager.  In addition, it <b>must</b> be in the <code>0x2D</code> text bytecode segment. </li></ul><br><h3>  QVM: how it works </h3><br>  Again, a drawing showing a unique entry point and a unique exit point that dispatch: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/04f/f05/ea7/04ff05ea7fc1635298d262a3ca824c7f.png"><br><br>  Some details: <br><br>  <u>Messages (Quake3 -&gt; VM) are sent to the virtual machine as follows:</u> <br><br><ul><li>  Any part of Quake3 can call <code>VM_Call( vm_t *vm, int callnum, ... )</code> . </li><li>  <code>VMCall</code> can receive up to 11 parameters and writes each 4-bit value to the VM bytecode ( <code>vm_t *vm</code> ) from 0x00 to 0x26. </li><li>  <code>VMCall</code> writes the message id to 0x2A. </li><li>  The interpreter begins to interpret opcodes in 0x2D (where <code>q3asm.exe</code> recorded <code>vmMain</code> ). </li><li>  <code>vmMain</code> used to dispatch and route a message to the corresponding bytecode method. </li></ul><br>  The list of messages sent by the <a href="">client VM</a> and <a href="">server VM</a> is presented at the end of each file. <br><br>  <u>System calls (VM -&gt; Quake3) are performed as follows:</u> <br><br><ul><li>  One after another, the interpreter executes VM opcodes ( <code>VM_CallInterpreted</code> ). </li><li>  When it encounters a <code>CALLI4</code> opcode, it checks the method index to int. </li><li>  If the value is negative, then the call is system. </li><li>  Called with parameters, the system call function pointer ( <code>int (*systemCall)( int *parms )</code> ). </li><li>  The function pointed to by <code>systemCall</code> is used to dispatch and route the system call to the required part of quake3.exe </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The list of system calls provided by the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">client VM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">server VM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is at the beginning of each file. </font></font><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interesting fact:</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parameters are always very simple types, they are either primitive (char, int, float), or are pointers to primitive types (char *, int []). </font><font style="vertical-align: inherit;">I suspect that this has been done to minimize the problems of struct communication between Visual Studio and LCC. </font></font><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An interesting fact:</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quake3 VM does not perform a dynamic connection, so the developer of the QVM mod did not have access to any libraries, even the standard C library (strlen, memset is here, but in fact are system calls). </font><font style="vertical-align: inherit;">Some managed to emulate them with a predefined buffer: </font></font><a href="http://icculus.org/homepages/phaethon/q3/malloc/malloc.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malloc in QVM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unprecedented freedom </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to the transfer of functions to a virtual machine, the modder community has gained much more opportunities. </font><font style="vertical-align: inherit;">In </font></font><a href="http://www.ra.is/unlagged/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nela Toronto's Unlagged</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the prediction system was rewritten using "reverse </font><a href="http://www.ra.is/unlagged/"><font style="vertical-align: inherit;">agreement</font></a><font style="vertical-align: inherit;"> ".</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Performance problem and its solution </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Because of such a long toolchain, VM code development was difficult: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The tulchain was slow. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tulchain was not integrated into Visual Studio. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Building QVM required using command line tools. </font><font style="vertical-align: inherit;">This hampered the development process.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Due to the large number of elements of the toolchain, it was difficult to find the parts responsible for the errors. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, idTech3 also had the ability to load native DLLs for VM parts, and this solved all the problems: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/899/35b/869/89935b869c382c9d33ebf10da2a20cbe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, the VM system was very flexible because the virtual machine has the ability to execute:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interpreted bytecode </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bytecode compiled into x86 commands </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Windows Compiled Code </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recommended reading </font></font></h3><br> <a href="http://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools"><img src="https://habrastorage.org/getpro/habr/post_images/f23/ff8/79a/f23ff879a8a061c15558b82290f3d18e.jpg"></a> <br><br> <a href="https://sites.google.com/site/lccretargetablecompiler/"><img src="https://habrastorage.org/getpro/habr/post_images/86f/219/802/86f219802c8253665457fed5dbe4efc0.png"></a> <br><br> <a href="http://fd.fabiensanglard.net/quake3/building_a_c_based_processor.pdf"><img src="https://habrastorage.org/getpro/habr/post_images/095/37b/c64/09537bc64c10656d55e9b796d52a8231.png"></a> <br><br><h2>  Artificial Intelligence </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The modders community has written bots for all previous idTech engines. </font><font style="vertical-align: inherit;">At one time, two systems were quite famous:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For Quake1 was </font></font><a href="http://botepidemic.no-origin.net/gladiator/obots/obots.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Omicron</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For Quake2 they wrote Gladiator. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But for idTech3, the bots system was a fundamental part of the gameplay, so it needed to be developed within the company and it had to be present in the game initially. </font><font style="vertical-align: inherit;">But serious problems arose during the development: </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : page 275 of the book ‚ÄúMasters of Doom‚Äù:</font></font><br><br><blockquote>          ‚Äî .  ‚Äî  ,  .       ,      .  Quake III,     ,       .          . <br><br>          ,   .   ,  ,   ,    .   . <br><br>     , ,    .    ,  ,    .   .    1999 ,       . </blockquote><br><h3>  Architecture </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, Jean-Paul van Waverin (Mr.Elusive) worked on the bots, and it's funny, because he wrote Omicron and Gladiator. </font><font style="vertical-align: inherit;">This explains why part of the server bots code is highlighted in a separate project </font></font><code>bot.lib</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4b5/701/93f/4b570193fcddd75148251154d01b9a3a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I could write about this, but Jean-Paul van Waveren himself wrote a </font></font><br> <a href="http://fd.fabiensanglard.net/quake3/The-Quake-III-Arena-Bot.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">103-page work</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with a detailed explanation. </font><font style="vertical-align: inherit;">Moreover, Alex J. Champandard created an </font></font><a href="http://aigamedev.com/open/article/quake3-engine/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">overview of the bot system code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which describes the location of each module mentioned in the work of van Waverin. </font><font style="vertical-align: inherit;">These two documents are sufficient for understanding Quake3 AI.</font></font></div><p>Source: <a href="https://habr.com/ru/post/330818/">https://habr.com/ru/post/330818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330802/index.html">If you are reading this, then your work is probably not hard.</a></li>
<li><a href="../330810/index.html">What determines the interesting gameplay?</a></li>
<li><a href="../330812/index.html">JavaScript Decorators</a></li>
<li><a href="../330814/index.html">Dropout - a method for solving the problem of retraining in neural networks</a></li>
<li><a href="../330816/index.html">Tips for a novice rocker (part 2)</a></li>
<li><a href="../330820/index.html">Support for Deep Learning Researchers</a></li>
<li><a href="../330822/index.html">RESTForms - REST API for your InterSystems Cach√© classes</a></li>
<li><a href="../330824/index.html">Understanding the jungle of programming, or why was Mowgli friends with Python?</a></li>
<li><a href="../330826/index.html">Dark patterns - how malicious interfaces try to attack and deceive</a></li>
<li><a href="../330828/index.html">Adaptation of Xamarin.Forms to the development of corporate and B2E applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>