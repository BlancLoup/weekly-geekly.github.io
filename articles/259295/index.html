<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>From detour to Dijkstra‚Äôs algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instead of introducing 
 I sorted out my old ‚Äúnotes,‚Äù so to speak, and came across this one. I still have no invites for Habr√©, I thought, and decided...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>From detour to Dijkstra‚Äôs algorithm</h1><div class="post__text post__text-html js-mediator-article"><h4>  Instead of introducing </h4><br>  I sorted out my old ‚Äúnotes,‚Äù so to speak, and came across this one.  I still have no invites for Habr√©, I thought, and decided to publish.  In this article I will explain how to understand the Dijkstra algorithm for finding the shortest paths from a given vertex in a graph.  What do I come to him naturally from the algorithm to bypass the graph in width. <br><br>  The comments asked for more information about the data structure, hiding behind the priority_queue in STL C ++.  At the end of the article is a brief story and its implementation. <br><a name="habracut"></a><br><h4>  Wide bypass graph </h4><br>  The first algorithm that I would like to describe, and which definitely cannot be skipped, is a <b>bypass of the graph in width</b> .  What is it?  Let's move away a bit from the formal description of the graphs, and imagine such a picture.  Put on the ground ropes, soaked with something fuel, of the same length so that none of them intersect, but some of them touch the ends of each other.  And now let's fire one of the ends.  How will the fire behave?  It will be evenly thrown over the ropes at neighboring intersections, until everything lights up.  It is not difficult to generalize this picture to three-dimensional space.  This is how life in width will look like bypassing the graph.  Now we will describe more formally.  Suppose that we have started a wide bypass from some vertex V. At the next moment in time, we will look through the neighbors of the vertex V (the neighbor of the vertex V is called the vertex that has a common edge with V).  And so on until all the vertices in the graph have been viewed. <br><br><h5>  Implementation of the crawl wide </h5><br>  Suppose we are at some vertex in the process of traversing a width, then we will use the queue to which we will add all the vertex neighbors, excluding those that we have already visited. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u)</span></span></span><span class="hljs-function"> </span></span>{ used[u] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; q; q.push(u); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!q.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u = q.front(); q.pop(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) g[u].size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v = g[u][i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!used[v]) { used[v] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; q.push(v); } } } }</code> </pre> <br>  In this implementation, g is a list of adjacent vertices, i.e.  in g [u] there is a list of adjacent vertices with u (std :: vector is used as a list), used is an array that allows us to understand which vertices we have already visited.  Here a walk in width does nothing but a walk in width itself.  It would seem, why?  However, it can be easily modified in order to look for what we need.  For example, the distance and the path from any vertex to all others.  It should be noted that the ribs have no weight, i.e.  graph is not weighted.  We give the implementation of the search for distances and paths. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u)</span></span></span><span class="hljs-function"> </span></span>{ used[u] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; p[u] = u; dist[u] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; q; q.push(u); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!q.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u = q.front(); q.pop(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) g[u].size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v = g[u][i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!used[v]) { used[v] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; p[v] = u; dist[v] = dist[u] + <span class="hljs-number"><span class="hljs-number">1</span></span>; q.push(v); } } } }</code> </pre><br>  Here p is an array of ancestors, i.e.  in p [v] lies the ancestor of the vertex v, dist [v] is the distance from the vertex from which we started the traversal to the vertex v.  How to restore the path?  This is quite easy to do, just passing through the array of ancestors of the vertex we need.  For example, recursively: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_way</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[u] != u) { print_way(p[u]); } <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; u &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; }</code> </pre><br><h4>  Shortest paths </h4><br>  All further reasoning will be true only if the edge weights are not negative. <br><br>  We now turn to weighted graphs, i.e.  graph edges have weight.  For example, the length of the edge.  Or a fee for the passage on it.  Or the time it takes to pass through it.  The task is to find the shortest path from one vertex to some other.  In this article I will start from a wide bypass, I don‚Äôt remember seeing this approach anywhere else.  Maybe I missed it.  So, let's look again at the implementation of a wide bypass, and specifically on the condition of adding to the queue.  By traversing the width, we add to the queue only those vertices in which we have not yet been.  Now we will change this condition and we will add those vertices, the distance to which can be reduced.  Obviously, the queue will become empty if and only if there is not a single vertex to which the distance can be reduced.  The process of reducing the path from the vertex V, let's call the relaxation of the vertex V. <br><br>  It should be noted that initially the path to all vertices is equal to infinity (for infinity we take some sufficiently large value, namely: one that no path will have a length greater than the value of infinity).  This algorithm follows directly from a wide bypass, and it was to him that I myself came when I solved the first task in life for the shortest paths in a graph.  It is worth mentioning that this method is looking for the shortest paths from the top, from which we started the algorithm, to all the others.  I will give the implementation: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> INF = <span class="hljs-number"><span class="hljs-number">1e+9</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; g[LIM]; <span class="hljs-comment"><span class="hljs-comment">//  g[u]   : (    u  v,  v) void shortcut(int u) { fill(dist, dist + n, INF); dist[u] = 0; p[u] = u; queue&lt;int&gt; q; q.push(u); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; (int) g[u].size(); i++) { int v = g[u][i].second, len = g[u][i].first; if (dist[v] &gt; dist[u] + len) { p[v] = u; dist[v] = dist[u] + len; q.push(v); } } } }</span></span></code> </pre><br>  Why do we keep such pairs in the adjacency list?  A little later, it will become clear when we improve this algorithm, but, frankly, <b>for this implementation, the</b> pairs can be stored and vice versa.  You can slightly improve the addition to the queue.  To do this, it is worthwhile to start an array of bool, in which we will mark whether the vertex with which it is necessary to relax is in the queue. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> INF = <span class="hljs-number"><span class="hljs-number">1e+9</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; g[LIM]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inque[LIM]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shortcut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u)</span></span></span><span class="hljs-function"> </span></span>{ fill(dist, dist + n, INF); dist[u] = <span class="hljs-number"><span class="hljs-number">0</span></span>; p[u] = u; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; q; q.push(u); inque[u] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!q.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u = q.front(); q.pop(); inque[u] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) g[u].size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v = g[u][i].second, len = g[u][i].first; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dist[v] &gt; dist[u] + len) { p[v] = u; dist[v] = dist[u] + len; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!inque[v]) { q.push(v); inque[v] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } } } }</code> </pre><br>  If you look closely, then this algorithm is very similar to <a href="http://e-maxx.ru/algo/levit_algorithm">Levit's</a> algorithm, but still it‚Äôs not him, although in the worst case it works for the same asymptotics.  Let's roughly estimate it.  In the worst case, we will have to relax every time we pass along any edge.  Total O (n * m).  The assessment is rather rough, but at the initial stage this is quite enough.  It is also worth noting that this is the <b>worst case</b> , and in practice even such an implementation works fairly quickly.  And now, the most interesting! ... drumming ... Improve our algorithm to <b>the Dakesta algorithm</b> ! <br><br><h4>  Dijkstra's Algorithm </h4><br>  The first optimization that comes to mind.  And let's relax those vertices, the path to which is now the minimum?  Actually, it was this idea that came into my mind one day.  But as it turned out, this idea came to the first far from me.  First she came to the remarkable scientist Edsger Dijkstra.  Moreover, it was he who proved that choosing the top for relaxation in this way, we will spend the relaxation no more than n times!  On an intuitive level, it is clear that if the path to a certain peak is minimal now, then we will not be able to make it even less.  More formally can be read <a href="http://e-maxx.ru/algo/dijkstra">here</a> or on <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2594%25D0%25B5%25D0%25B9%25D0%25BA%25D1%2581%25D1%2582%25D1%2580%25D1%258B">Wikipedia</a> . <br><br>  Now it remains for the small, to understand how to effectively find the top with the minimum distance to it.  To do this, use the priority queue (heap, heap).  In stl there is a class that implements it and is called <b>priority_queue</b> .  Let me give you an implementation, which, again, directly follows from the previous (described in this article) algorithm. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dijkstra</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u)</span></span></span><span class="hljs-function"> </span></span>{ fill(dist, dist + n, INF); dist[u] = <span class="hljs-number"><span class="hljs-number">0</span></span>; p[u] = u; priority_queue&lt; pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt;, greater&lt; pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; &gt; q; q.push(make_pair(<span class="hljs-number"><span class="hljs-number">0</span></span>, u)); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!q.empty()) { pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; u = q.top(); q.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (u.first &gt; dist[u.second]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) g[u.second].size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v = g[u.second][i].second, len = g[u.second][i].first; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dist[v] &gt; dist[u.second] + len) { p[v] = u.second; dist[v] = dist[u.second] + len; q.push(make_pair(dist[v], v)); } } } }</code> </pre><br>  Most likely it is not entirely clear what is happening here.  Let's start by declaring a priority queue.  Here, the first argument of the template is the data that is stored in the queue, and specifically the form pairs (distance to the vertex, vertex number), the second argument of the template is the container in which the data will be stored, the third argument, the comparator (found, by the way, in the header file functional).  Why do we need some other comparator?  Because with the standard declaration of <b>priority_queue &lt;pair &lt;int, int&gt;&gt;</b> , you only get those vertices that are as close as possible, but we need to do the opposite.  Asymptotics of such a solution of the problem posed <b>O (n * log (n) + m * log (n))</b> . <br><br>  Indeed, we have only n relaxations, and we look for the vertex with the minimum length of the path to it behind log (n) (this is exactly the asymptotics of the standard queue with stl priorities).  It should also be noted that it may turn out that we have added the same vertex to the queue, but with different paths to it.  For example, we spent the relaxation from the vertex A, which has a vertex C in the neighbors, and then we relaxed from the vertex B, which also has a vertex C in the neighbors, to avoid the problems associated with this, we simply skip those vertices that we got out of the queue, but the distance from the queue to which is not relevant,  more than the current shortest.  For this, the implementation has a line <b>if (u.first&gt; dist [u.second]) continue;</b>  . <br><br><h4>  Instead of conclusion </h4><br>  It turned out that it is actually very easy to write Dijkstra for <b>O (n * log (n) + m * log (n))</b> ! <br><br><h4>  Addition </h4><br>  The comments were asked to tell how you can do with your hands priority_queue. <br><br>  Let us face the next task (as in the Dijkstra algorithm). <br>  You need to maintain a data structure that meets the following requirements: <br>  1) Adding no more than O (log (n)) time. <br>  2) Removal of the minimum element in no more than O (log (n)) time. <br>  3) Search for a minimum in O (1) time. <br><br>  It turns out that these requirements are satisfied by the data structure, which in Russian-language literature is usually called the ‚Äúheap‚Äù, in the English-language ‚Äúheap‚Äù or ‚Äúpriority queue‚Äù. <br><br>  Generally speaking, a bunch is a tree.  Let's look at the properties of this tree in more detail.  Suppose we have already built a heap, then we define it as follows - for each vertex in the heap it is true that the element at this vertex is no more than the elements in its descendants.  Then at the root of the tree is the minimum element, which allows us to continue to look for a minimum of O (1). <br><br>  Now we will define our heap so that the other properties are fulfilled.  We call the level of a vertex in a tree the distance from the root to it.  We prohibit adding a new level in the heap until it is completely filled with the previous one.  More formally: let the current maximum height of the tree H, then it is forbidden to add vertices to the height H + 1, as long as it is possible to add it to the height H. Indeed, under such conditions, the height of the heap is always no more than O (log (n)). <br><br>  It remains to learn how to add and remove items in the heap. <br><br>  We will implement a bunch on a binary tree, in which there will be at most one vertex with the number of descendants less than two.  The tree will be stored in an array, then the descendants of the vertex at position pos will lie at positions 2 * pos and 2 * pos + 1, and the parent will lie at position pos / 2. <br><br>  We will add an element to the first possible vacant place at the current maximum level, then perform an operation called ‚Äúsifting up‚Äù.  This means that while the parent of the added element is more than the element itself, then change the positions of the added element and the parent, repeat recursively until the root.  Let us prove that this does not violate the properties of the heap.  This is simple, since the current element is smaller than the parent, it is also smaller than all the descendants of the parent. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ data.push_back(value); sift_up(data.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sift_up</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> parent_position = position / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cmp(data[position], data[parent_position])) { swap(data[position], data[parent_position]); sift_up(parent_position); } }</code> </pre><br><br>  We will delete the minimum element as follows: first, swap the root of the tree with the last element at the maximum level, then delete the vertex in which this element was (now there will be a minimum).  The properties of the heap will then be broken, and in order to restore them you need to perform an operation called ‚Äúsifting down‚Äù.  We start recursively from the root: for the current element we find the minimum from the descendants, swap with the current element, start recursively for the vertex with which the current element was changed.  Note that after this operation, heap properties are executed. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ swap(data[<span class="hljs-number"><span class="hljs-number">1</span></span>], data.back()); data.pop_back(); sift_down(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sift_down</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> cmp_position = position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span> * position &lt; data.size() &amp;&amp; !cmp(data[<span class="hljs-number"><span class="hljs-number">2</span></span> * position], data[cmp_position])) { cmp_position = <span class="hljs-number"><span class="hljs-number">2</span></span> * position; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span> * position + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; data.size() &amp;&amp; !cmp(data[<span class="hljs-number"><span class="hljs-number">2</span></span> * position + <span class="hljs-number"><span class="hljs-number">1</span></span>], data[cmp_position])) { cmp_position = <span class="hljs-number"><span class="hljs-number">2</span></span> * position + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cmp_position != position) { swap(data[cmp_position], data[position]); sift_down(cmp_position); } }</code> </pre><br><br>  Since the tree height is O (log (n)), addition and removal will work for O (log (n)). <br><br>  All code <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cmp_t</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">heap_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">heap_t</span></span>() : data(<span class="hljs-number"><span class="hljs-number">1</span></span>) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> value_t&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">top</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ data.push_back(value); sift_up(data.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ swap(data[<span class="hljs-number"><span class="hljs-number">1</span></span>], data.back()); data.pop_back(); sift_down(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sift_up</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> parent_position = position / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cmp(data[position], data[parent_position])) { swap(data[position], data[parent_position]); sift_up(parent_position); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sift_down</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> cmp_position = position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span> * position &lt; data.size() &amp;&amp; !cmp(data[<span class="hljs-number"><span class="hljs-number">2</span></span> * position], data[cmp_position])) { cmp_position = <span class="hljs-number"><span class="hljs-number">2</span></span> * position; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span> * position + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; data.size() &amp;&amp; !cmp(data[<span class="hljs-number"><span class="hljs-number">2</span></span> * position + <span class="hljs-number"><span class="hljs-number">1</span></span>], data[cmp_position])) { cmp_position = <span class="hljs-number"><span class="hljs-number">2</span></span> * position + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cmp_position != position) { swap(data[cmp_position], data[position]); sift_down(cmp_position); } } <span class="hljs-keyword"><span class="hljs-keyword">cmp_t</span></span> cmp; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span>&gt; data; };</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/259295/">https://habr.com/ru/post/259295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259283/index.html">Understanding UEFI and GPT: Installing Windows and Kubuntu on a single disk</a></li>
<li><a href="../259285/index.html">Bolts in tea, or a webinar on probability theory in practice</a></li>
<li><a href="../259287/index.html">New converged solutions from HP Networking</a></li>
<li><a href="../259291/index.html">Tunnel modeling - version 0.9</a></li>
<li><a href="../259293/index.html">Time management for the developer</a></li>
<li><a href="../259297/index.html">Interface settings and much more in the assembly Vivaldi 1.0.190.2</a></li>
<li><a href="../259299/index.html">Rusty evidence</a></li>
<li><a href="../259301/index.html">Cackle comment system: how we did the analytics</a></li>
<li><a href="../259303/index.html">Creating plug-ins for AutoCAD using the .NET API (Part 5 - Introduction to Blocks)</a></li>
<li><a href="../259305/index.html">PHP Digest number 63 - interesting news, materials and tools (May 11 - 31, 2015)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>