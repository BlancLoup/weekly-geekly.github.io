<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Yandex.Maps change API. Why we needed to break backward compatibility in a clusterer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I work in Yandex, Yandex has maps, and maps has an API. API is the thing that allows you to embed Yandex maps on your website. Since version 2.0, our ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Yandex.Maps change API. Why we needed to break backward compatibility in a clusterer</h1><div class="post__text post__text-html js-mediator-article">  I work in Yandex, Yandex has maps, and maps has an API.  API is the thing that allows you to embed Yandex maps on your website.  Since version 2.0, our API is able to cluster tags on the client.  Here are the labels before and after clustering: <br><br> <a href="http://habrahabr.ru/company/yandex/blog/207202/"><img src="https://habrastorage.org/getpro/habr/post_images/b05/8ff/74c/b058ff74c26fb19f92b70e1eec7b9870.png" alt="image"></a> <br><br>  The other day, the next release of our beta version 2.1.4.  This release is notable for the fact that it happened what the Bolsheviks were so afraid of.  <a href="http://habrahabr.ru/company/yandex/blog/196288/">As we warned</a> , we had to break backward compatibility in a tag clusterizer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article I want not only to list the innovations in working with the clusterizer in version 2.1.4, but also to explain why we needed to produce these innovations.  And then you have to rewrite the code, and rewrite the code is sad, if you do not understand why it has to be done. <br><a name="habracut"></a><br>  The content of the article: <br><ol><li>  Cancel asynchronous adding of tags (this item is worth reading for those who have somehow used the objectsaddtomap method). </li><li>  Change public clustering methods. </li><li>  Changing the way the map is divided into tiles (maybe no one will notice). </li><li>  Renaming the Cluster entity to the ClusterPlacemark (most likely no one will notice). </li><li>  Changes to clusterer.balloon and clusterer.hint (it is worth reading if you used cluster baluns or wanted to add hints to clusters). </li><li>  The task of arbitrary icons of clusters is what's new (it is worth reading if ... well, here it is clear). </li><li>  A small refinement of the preset option or how to change the color of the cluster when hovering. </li><li>  Prefixing options for clusters and labels in a cluster. </li><li>  Summary table of differences in the code. </li><li>  Comparison of the speed of the versions (for the credibility of the article). </li></ol><br><h4>  Cancel asynchronous tagging. </h4><br>  In version 2.0, geo-objects were created, added to the map and rendered immediately, in one stream.  The weaker the browser, the more objects you added to the map, the more likely it was to see the message. <br><img src="https://habrastorage.org/getpro/habr/post_images/8cd/185/4eb/8cd1854eb56ad543466dc90ddad47bd2.png" alt="image"><br>  This situation, our developer Anton calls the scientific term "zalipon." <br><br>  Cluster begin to use when the number of labels on the card a lot.  When there are a lot of objects, the problem of these very zlipons appears.  It was necessary to solve something, and in the clusteriser it was decided to make asynchronous adding objects to the map by default.  It was possible to understand that objects were added to the map by the objectsaddtomap event.  This is one of the examples for version 2.0. <br><br><pre><code class="hljs pgsql">//      . //      , //       ,   //     . <span class="hljs-keyword"><span class="hljs-keyword">cluster</span></span>.events.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-string"><span class="hljs-string">'objectsaddtomap'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> () { //       . var geoObjectState = <span class="hljs-keyword"><span class="hljs-keyword">cluster</span></span>.getObjectState(myGeoObjects[<span class="hljs-number"><span class="hljs-number">1</span></span>]); // ,        . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (geoObjectState.isShown) { //     ,      . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (geoObjectState.isClustered) { geoObjectState.<span class="hljs-keyword"><span class="hljs-keyword">cluster</span></span>.state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'activeObject'</span></span>, myGeoObjects[<span class="hljs-number"><span class="hljs-number">1</span></span>]); geoObjectState.<span class="hljs-keyword"><span class="hljs-keyword">cluster</span></span>.balloon.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //      ,    . myGeoObjects[<span class="hljs-number"><span class="hljs-number">1</span></span>].balloon.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(); } } });</code> </pre> <br>  I can not say that working with this was very convenient.  But it is better inconvenient than nothing - the hanging browser is a weightier argument than the beauty of the code. <br><br>  In version 2.1 we stepped in the direction of the separation of objects and their display on the map.  Someone might have noticed that the getOverlay methods have become asynchronous and inconvenient - this is it.  In fact, asynchronous rendering of layouts is a great way to optimize the process of adding objects to the map. <br><br>  To better understand the essence of things, look at the path of the label from its creation to the appearance on the map.  The process can be divided into three stages: <br><ul><li>  Creating a class instance </li><li>  Adding an object to the map </li><li>  Rendering label layout in HTML </li></ul><br>  On the first point, I think, explanations are not needed.  It is not very clear what is the difference between stages two and three.  Adding an object to a map is the process by which a label is attached to the parent collection (most often to map.geoObjects).  The label receives from this collection some options, including a map projection.  After the label object finds out in which projection the map is drawn, it can project its geometry onto the plane (which it does).  After projecting the coordinates of the label on the plane, it becomes clear at which pixel point of the screen you need to draw the label icon.  At this point, phase two ends. <br><br>  The third stage is just the process of drawing a label on the map at a particular pixel coordinate.  In version 2.1, we perform the first two stages synchronously, in one thread.  But we draw the object by timeout. <br><br>  So, since the labels are already drawn and asynchronously, it has become possible to simplify the clustering logic and remove the delayed addition of labels to the map.  The clusterer no longer has the synchAdd options and the corresponding objectsaddtomap event has disappeared. <br><br>  In other words, to upgrade to version 2.1.4, you will need to remove the subscription to the objectsaddtomap event from the code.  All the code inside this event handler can now be executed immediately synchronously after adding objects to the clusteriser.  (At the end of the article I will give a table with examples in the ‚Äúbecame-was‚Äù format, for whom it is not interesting to read further - you can go straight to it.) <br><br><h4>  Modifying public clustering methods </h4><br>  In version 2.0, the clusteriser was a successor of the ymaps.Collection object.  It inherits from the collection the add, remove, setParent, and other methods as well as each, getIterator, and other unnecessary methods (I will explain why these methods were unnecessary).  It seemed that the clusteriser is quite a collection ‚Äî you can add objects to it and delete objects back.  But not only does the clusteriser contain some elements, it may or may not show these elements on the map, and also generates additional cluster objects. <br><br>  Therefore, what implementation of the each method you can do will still not be very logical.  Whether it is necessary to sort through all the objects added.  Whether it is necessary to walk on objects and clusters.  But clusters are being rebuilt all the time.  It came to the realization that the clustering is not quite a collection.  That is not a collection at all. <br><br>  Now the clusteriser has simple and clear public methods for accessing objects. <br><ul><li>  Clusterer.getGeoObjects - returns an array of elements added to the clusterizer </li><li>  Clusterer.getClusters - returns an array of clusters currently added to the map.  Please note that these are not all clusters, but only those that are currently visible. </li></ul><br>  Look for examples of working with these methods in <a href="">our documentation</a> . <br><br><h4>  Changing the way the map is divided into tiles </h4><br>  As you know, we use the grid clustering algorithm (for those interested in detail - here is a <a href="http://tech.yandex.ru/events/yasubbotnik/msk-jul-2012/talks/301/">link</a> to my ancient speech about the clustering unit).  The algorithm is simple and therefore beautiful (when you cluster objects on the client, first of all you have to think about the speed of code execution). <br><br>  The map was divided into square cells.  Labels that fall into one cell form a cluster.  In order not to cause computations with each small map dredge, the cells were combined into larger squares, which we called ‚Äúcluster tiles‚Äù.  All cluster tiles were processed, in which the visible area of ‚Äã‚Äãthe map was fully or partially hit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc4/75b/34b/dc475b34bf2c7b512a8badfc8b56ad98.png" alt="image"><br><br>  In this version we decided not to introduce confusion into the concept of the word "tile".  Now cluster tiles are located exactly in the same place as regular card tiles and always have a size of 256x256 pixels.  This implies a limitation - the clusterization cell size should be a) not more than 256 and b) an entire number of clustering cells should fit into the tile.  That is, the valid values ‚Äã‚Äãfor cluster sizes are 2, 4, 8, 16, 32, 64, 128, and 256. <br><br>  Now the good news is that even if you set the wrong value, we will still bring it to the nearest correct one and everything will be fine.  For what I wrote all this, you ask.  Just because.  Maybe it will be interesting to someone, and it will be pleasant to someone to know why the situation on the map has changed a bit after clustering. <br><br>  Since the tiles are small and, generally speaking, the border of the map may coincide with the border of the tile, we introduced an additional indent for the visible area of ‚Äã‚Äãthe map - <code>mapViewport</code> (128 pixels by default).  That is, always processed a little more than necessary.  But the user most likely will not notice rebuilds when moving the map. <br><br><h4>  Rename Cluster to ClusterPlacemark </h4><br>  I always suspected that no one but a couple of people (I and our documentator Olesya) could tell at once what the difference between Cluster and Clusterer is (if you understand the difference, you are a great fellow). <br><ul><li>  Clusterer - clustering objects, something like a collection. </li><li>  Cluster is a group of objects generated by a clusterizer.  The map looks like a label. </li></ul><br>  We studied the number of transitions to different pages of documentation - the Clusterer and Cluster pages are very popular.  And I suspect that people who click on Cluster are victims of cruelty and misunderstanding.  That is why it was decided to rename the entity Cluster to ClusterPlacemark.  When you look at Clusterer and ClusterPlacemark, it seems to be becoming clearer what's what. <br><br>  Since there were no people in the Maps API Club who were using clusters separate from the clusterizer (look for suffixes), this change should go completely unnoticed.  And erroneous clicks in the documentation on Cluster instead of Clusterer should go into the distant past.  However, if you liked reading the documentation for the Cluster object and see its loss as a loss of a close friend, read the documentation for the ClusterPlacemark. <br><br><h4>  Changes to clusterer.balloon and clusterer.hint </h4><br>  I'll start with the fun - we finally added the ability to show a pop-up hint to the cluster label.  You can do this with this code: <br><pre> <code class="hljs pgsql">var clusterer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ymaps.Clusterer(); clusterer.createCluster = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> (center, geoObjects) { //  -     . var clusterPlacemark = ymaps.Clusterer.prototype.createCluster.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(this, center, geoObjects), geoObjectsLength = clusterPlacemark.getGeoObjects().length, hintContent; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (geoObjectsLength &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) { hintContent = <span class="hljs-string"><span class="hljs-string">' '</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (geoObjectsLength &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) { hintContent = <span class="hljs-string"><span class="hljs-string">'  '</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hintContent = <span class="hljs-string"><span class="hljs-string">' '</span></span>; } clusterPlacemark.properties.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'hintContent'</span></span>, hintContent); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clusterPlacemark; };</code> </pre> <br>  By default, hints will not be shown, because the clusters do not specify the value of the <code>hintContent</code> field (there is a circle with numbers on the map, it‚Äôs better not to describe the words anyway).  As you begin to set this value, hints will begin to show. <br><br>  Now, about changing hints and baluns in general.  To work with baluns in version 2.0, each cluster created a <code>.balloon</code> field.  The discovery of the balloon looked like <code>cluster.balloon.open();</code>  . <br><br>  The disadvantage of this solution was the low speed of code execution.  After all, if you have 100 clusters, each of them may have a balun, which means that each cluster must be created and assigned a balun manager in the <code>cluster.balloon</code> field.  Therefore, as part of the work on speed, it was decided to make one manager of baluns and hints per clusterizer.  Now the balun on the cluster can be opened like this: <br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//     -. clusterer.balloon.open(clusterPlacemark);</span></span></code> </pre><br>  For more details on changing the code for opening baluns, see the summary table below. <br><br><h4>  Setting arbitrary cluster icons - what's new </h4><br>  In version 2.0, all geo-objects were equal.  But some were more equal.  Tags drawn on the canvas became interactive with the help of active areas.  Labels rendered using DOM were interactive in their own right.  This gave rise to differences in behavior and a lot of inconvenience. <br>  Therefore, in version 2.1 it was decided to bring all the objects under the event horizon (whatever that means).  Now all tags become interactive due to active areas overlaid on top of the map.  Because of this, for the labels, now you need to specify what shape and size the active area above the label should be (when you hover over which part of the picture the cursor should change, the label should click and click). <br><br>  Standard label-clusters have 3 types of pictures - large, medium and small.  These pictures are round.  If you try to move the mouse over the cluster label, you will see that the active area of ‚Äã‚Äãthe label coincides with the picture and is also a circle. <br><br><img src="http://img-fotki.yandex.ru/get/9759/4604496.1e/0_72c88_d65686e4_S.png" alt="image"><img src="http://img-fotki.yandex.ru/get/9317/4604496.1e/0_72c87_21903b1e_S.png" alt="image"><img src="http://img-fotki.yandex.ru/get/9058/4604496.1e/0_72c86_c5078d_S.png" alt="image"><br><br>  Some users have already encountered the fact that in version 2.1.3, when replacing images for a cluster icon, the active area still remains round (and the label is generally square or moreover triangular). <br><img src="http://img-fotki.yandex.ru/get/9508/4604496.1e/0_72cc7_d169017d_L.png" alt="image"><br>  - a custom tag, and the circle was clickable anyway. <br><br>  We have corrected this and now you can independently determine the shape of the active area for the label.  You can do it this way (example for round labels). <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">clusterer</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.options</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.set</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">clusterIcons</span></span>: [ { href: <span class="hljs-string"><span class="hljs-string">'images/small.png'</span></span>, size: [<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>], offset: [-<span class="hljs-number"><span class="hljs-number">10</span></span>, -<span class="hljs-number"><span class="hljs-number">10</span></span>], shape: new ymaps.shape.<span class="hljs-built_in"><span class="hljs-built_in">Circle</span></span>(new ymaps.geometry.pixel.Circle([0, 0], 10)) }, { <span class="hljs-attribute"><span class="hljs-attribute">href</span></span>: <span class="hljs-string"><span class="hljs-string">'images/medium.png'</span></span>, size: [<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>], offset: [-<span class="hljs-number"><span class="hljs-number">15</span></span>, -<span class="hljs-number"><span class="hljs-number">15</span></span>], shape: new ymaps.shape.<span class="hljs-built_in"><span class="hljs-built_in">Circle</span></span>(new ymaps.geometry.pixel.Circle([0, 0], 15)) }, { <span class="hljs-attribute"><span class="hljs-attribute">href</span></span>: <span class="hljs-string"><span class="hljs-string">'images/big.png'</span></span>, size: [<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>], offset: [-<span class="hljs-number"><span class="hljs-number">20</span></span>, -<span class="hljs-number"><span class="hljs-number">20</span></span>], shape: new ymaps.shape.<span class="hljs-built_in"><span class="hljs-built_in">Circle</span></span>(new ymaps.geometry.pixel.Circle([0, 0], 20)) } ] });</code> </pre><br>  The code is not very simple, so there is an alternative approach - simpler, but coarser.  If you do not specify the shape parameter when describing icons, the rectangular area above the icon, which is formed based on the size and offset parameters, will become active.  That is, such a code will also work fine, just a clickable area will be a rectangular area around the icon. <br><img src="http://img-fotki.yandex.ru/get/9118/4604496.1e/0_72cc8_5dbc5564_L.png" alt="image"><br>  The picture is complex, so we don‚Äôt bother and make interactive a rectangular area around the icon.  Choose a solution depending on the degree of your perfectionism. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">clusterer</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.options</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.set</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">clusterIcons</span></span>: [ { href: <span class="hljs-string"><span class="hljs-string">'images/small.png'</span></span>, size: [<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>], offset: [-<span class="hljs-number"><span class="hljs-number">10</span></span>, -<span class="hljs-number"><span class="hljs-number">10</span></span>] }, { <span class="hljs-attribute"><span class="hljs-attribute">href</span></span>: <span class="hljs-string"><span class="hljs-string">'images/medium.png'</span></span>, size: [<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>], offset: [-<span class="hljs-number"><span class="hljs-number">15</span></span>, -<span class="hljs-number"><span class="hljs-number">15</span></span>] }, { <span class="hljs-attribute"><span class="hljs-attribute">href</span></span>: <span class="hljs-string"><span class="hljs-string">'images/big.png'</span></span>, size: [<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>], offset: [-<span class="hljs-number"><span class="hljs-number">20</span></span>, -<span class="hljs-number"><span class="hljs-number">20</span></span>] } ] });</code> </pre><br><br>  Another small addition.  If you do not want to show content inside the cluster label, you can set the clusterIconContentLayout option to null and the label will be shown without numbers inside <code>clusterer.options.set('clusterIconContentLayout', null);</code> <br><br><h4>  A small refinement of the cluster preset </h4><br>  The API Cards Club came across questions on ‚Äúhow to set a style for a specific cluster‚Äù.  There was no good answer to this question, as the keys indicated in the description of option.presetStorage worked only if they were set to the clusterer entirely.  And for single tags, these keys are not suitable.  In this version, the keys are universal - suitable for the clusteriser as a whole, and for label clusters in particular. <br><br>  You can change the color of the cluster when you hover like this. <br><pre> <code class="hljs cs">clusterer.events.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-string"><span class="hljs-string">'mouseenter'</span></span>, function (e) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = e.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'target'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> target.getGeoObjects == <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { target.options.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'preset'</span></span>, <span class="hljs-string"><span class="hljs-string">'islands#redClusterIcons'</span></span>); } }); clusterer.events.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-string"><span class="hljs-string">'mouseleave'</span></span>, function (e) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = e.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'target'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> target.getGeoObjects == <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { target.options.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'preset'</span></span>, <span class="hljs-string"><span class="hljs-string">'islands#blueClusterIcons'</span></span>); } });</code> </pre> <br><br><h4>  Prefixing options for clusters and labels in a cluster </h4><br>  Two types of objects can be found in the clusteriser - cluster labels and single objects that are not included in any group of objects.  Sometimes it is necessary to set options for those and others.  It is clear that no one wants to go through all the labels and clusters in order to set the same options for each.  To set options on all objects at once, these same options can be specified once through the clusterizer.  And the clusterer will transfer these options to its child objects. <br><br>  In particular, in version 2.0 it was possible to do this: <code>clusterer.options.set('cursor', 'help');</code>  And the view of the cursor changed both for single objects and for label clusters. <br><br>  An inquisitive reader will ask with a squint: ‚ÄúAnd what if I want to set different types of cursors for cluster marks and single tags?‚Äù We considered this case and decided that cluster marks would also understand options that have a ‚Äúcluster‚Äù prefix. <br><br><pre> <code class="hljs pgsql">clusterer.<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>({ //   . ursor: <span class="hljs-string"><span class="hljs-string">'pointer'</span></span>, //   -. clusterCursor: <span class="hljs-string"><span class="hljs-string">'help'</span></span> });</code> </pre> <br><br>  In this system, everything was fine, except for the case when you wanted to customize only single labels without affecting label-clusters.  If you wanted to change only the options for single labels, you wrote <code>clusterer.options.set('cursor', 'help');</code>  And they got too massive effect - the options extended to both single objects and clustered labels.  That is, if you wanted to affect only single labels, you had to set options anyway for both single objects and clusters. <br><br>  In version 2.1, it became a bit more convenient.  Now all options for child objects are set with prefixes.  For cluster labels with the 'cluster' prefix, for single labels - with the 'geoObject' prefix.  Now the options of the child objects are independent of each other.  Ask what you like more. <br><br><pre> <code class="hljs pgsql">//         . lusterer.<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'geoObjectCursor'</span></span>, <span class="hljs-string"><span class="hljs-string">'help'</span></span>);</code> </pre> <br><br><h5>  Summary table of changes </h5><br><table><tbody><tr><th>  It was </th><th>  It became </th></tr><tr><td><pre> <code class="hljs pgsql">//  <span class="hljs-number"><span class="hljs-number">1.</span></span>    c  . //      , //       ,   //     . clusterer.events.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-string"><span class="hljs-string">'objectsaddtomap'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> () { //       . var geoObjectState = clusterer.getObjectState(myGeoObjects[<span class="hljs-number"><span class="hljs-number">1</span></span>]); // ,       . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (geoObjectState.isShown) { //     ,       . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (geoObjectState.isClustered) { geoObjectState.<span class="hljs-keyword"><span class="hljs-keyword">cluster</span></span>.state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'activeObject'</span></span>, myGeoObjects[<span class="hljs-number"><span class="hljs-number">1</span></span>]); geoObjectState.<span class="hljs-keyword"><span class="hljs-keyword">cluster</span></span>.balloon.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //      ,    . myGeoObjects[<span class="hljs-number"><span class="hljs-number">1</span></span>].balloon.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(); } } });</code> </pre><br></td><td><pre> <code class="hljs pgsql">//  <span class="hljs-number"><span class="hljs-number">1.</span></span>    c  . //       . var geoObjectState = clusterer.getObjectState(myGeoObjects[<span class="hljs-number"><span class="hljs-number">1</span></span>]); // ,       . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (geoObjectState.isShown) { //     ,       . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (geoObjectState.isClustered) { geoObjectState.<span class="hljs-keyword"><span class="hljs-keyword">cluster</span></span>.state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'activeObject'</span></span>, myGeoObjects[<span class="hljs-number"><span class="hljs-number">1</span></span>]); clusterer.balloon.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(geoObjectState.<span class="hljs-keyword"><span class="hljs-keyword">cluster</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //      ,    . myGeoObjects[<span class="hljs-number"><span class="hljs-number">1</span></span>].balloon.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(); } }</code> </pre></td></tr><tr><td><pre> <code class="hljs pgsql">//  <span class="hljs-number"><span class="hljs-number">2.</span></span>   -. var <span class="hljs-keyword"><span class="hljs-keyword">options</span></span> = ymaps.<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.presetStorage.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'islands#redClusterIcons'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">cluster</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>({ icons: <span class="hljs-keyword"><span class="hljs-keyword">options</span></span>.clusterIcons, iconContentLayout: <span class="hljs-keyword"><span class="hljs-keyword">options</span></span>.clusterContentLayout });</code> </pre></td><td><pre> <code class="hljs pgsql">//  <span class="hljs-number"><span class="hljs-number">2.</span></span>   -. <span class="hljs-keyword"><span class="hljs-keyword">cluster</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'preset'</span></span>, <span class="hljs-string"><span class="hljs-string">'islands#redClusterIcons'</span></span>);</code> </pre></td></tr><tr><td><pre> <code class="hljs pgsql">//  <span class="hljs-number"><span class="hljs-number">3.</span></span>  -  . clusterer.<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'clusterIconContentLayout'</span></span>, ymaps.templateLayoutFactory.createClass(<span class="hljs-string"><span class="hljs-string">''</span></span>));</code> </pre></td><td><pre> <code class="hljs pgsql">//  <span class="hljs-number"><span class="hljs-number">3.</span></span>  -  . clusterer.<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'clusterIconContentLayout'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);</code> </pre></td></tr><tr><td><pre> <code class="hljs pgsql">//  <span class="hljs-number"><span class="hljs-number">4.</span></span>       . lusterer.<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>({ clusterBalloonLayout: myClusterBalloonLayout, balloonLayout: myPlacemarkBalloonLayout });</code> </pre></td><td><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">lusterer</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.options</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.set</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">clusterBalloonLayout</span></span>: myClusterBalloonLayout, geoObjectBalloonLayout: myPlacemarkBalloonLayout });</code> </pre></td></tr></tbody></table><br>  Otherwise, everything remains unchanged.  All innovations are described in the documentation. <br><br><h4>  Comparison of clustering speed in versions 2.0.36 and 2.1.4 </h4><br>  It is better to see once than read once and not to believe.  How the measurements were taken.  This case was taken as a sample: <br><pre> <code class="hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!doctype html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">http-equiv</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Content-Type"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/html; charset=UTF-8"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://api-maps.yandex.ru/2.0.36/?load=package.full &amp;lang=ru-RU&amp;ns=ym"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> ym.ready(</span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">var</span></span></span><span class="javascript"> map = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">new</span></span></span><span class="javascript"> ym.Map(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'map'</span></span></span><span class="javascript">, { </span><span class="hljs-attr"><span class="javascript"><span class="hljs-attr">center</span></span></span><span class="javascript">: [</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">55.755381</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">37.619044</span></span></span><span class="javascript">], </span><span class="hljs-attr"><span class="javascript"><span class="hljs-attr">zoom</span></span></span><span class="javascript">: </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">13</span></span></span><span class="javascript"> }), coords = [], center = [</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">55.755381</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">37.619044</span></span></span><span class="javascript">], placemarks = [], i; </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">for</span></span></span><span class="javascript"> (i = </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">0</span></span></span><span class="javascript">; i &lt; </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">10000</span></span></span><span class="javascript">; i++) { coords[i] = [ center[</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">0</span></span></span><span class="javascript">] + </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">0.5</span></span></span><span class="javascript"> * </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Math</span></span></span><span class="javascript">.random() * </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Math</span></span></span><span class="javascript">.random() * </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Math</span></span></span><span class="javascript">.random() * (</span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Math</span></span></span><span class="javascript">.random() &lt; </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">0.5</span></span></span><span class="javascript"> ? </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">-1</span></span></span><span class="javascript"> : </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">1</span></span></span><span class="javascript">), center[</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">1</span></span></span><span class="javascript">] + </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">0.7</span></span></span><span class="javascript"> * </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Math</span></span></span><span class="javascript">.random() * </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Math</span></span></span><span class="javascript">.random() * </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Math</span></span></span><span class="javascript">.random() * (</span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Math</span></span></span><span class="javascript">.random() &lt; </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">0.5</span></span></span><span class="javascript"> ? </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">-1</span></span></span><span class="javascript"> : </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">1</span></span></span><span class="javascript">) ]; } </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">var</span></span></span><span class="javascript"> startTime = +</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">new</span></span></span><span class="javascript"> </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Date</span></span></span><span class="javascript">(); </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">for</span></span></span><span class="javascript"> (i = </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">0</span></span></span><span class="javascript">, l = coords.length; i &lt; l; i++) { placemarks[i] = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">new</span></span></span><span class="javascript"> ym.GeoObject({ </span><span class="hljs-attr"><span class="javascript"><span class="hljs-attr">geometry</span></span></span><span class="javascript">: { </span><span class="hljs-attr"><span class="javascript"><span class="hljs-attr">type</span></span></span><span class="javascript">: </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"Point"</span></span></span><span class="javascript">, </span><span class="hljs-attr"><span class="javascript"><span class="hljs-attr">coordinates</span></span></span><span class="javascript">: coords[i] } }); } </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">var</span></span></span><span class="javascript"> clusterer = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">new</span></span></span><span class="javascript"> ym.Clusterer(); clusterer.add(placemarks); map.geoObjects.add(clusterer); </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">var</span></span></span><span class="javascript"> stopTime = +</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">new</span></span></span><span class="javascript"> </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Date</span></span></span><span class="javascript">(); alert(stopTime - startTime); }); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"map"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"height: 400px; width: 800px;"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  This piece of code does not affect the moments in which backward compatibility is broken, so it can be run either in version 2.0.36 or in version 2.1.4 without changes, simply by switching the link to the API version.  Time was measured in milliseconds. <br><img src="http://img-fotki.yandex.ru/get/5007/4604496.1e/0_72c83_c1f87d07_XL.png" alt="image"><br>  I want to make a remark about IE11.  Tests for all browsers were run on my laptop, and for IE11 on another laptop with Windows (I have a macbook).  So, it‚Äôs not worth comparing the speed of its work with other browsers.  But it is worth assessing how much the api has accelerated from version to version. <br><br>  It is important to understand - we have reduced only the initialization time of the card with a clusterizer and labels.  The browser executes the code, exhales, and then can return to drawing objects.  At the same time, the total load did not change much - it was only distributed over time, some of the actions are performed later.  Nevertheless, it is important for weak browsers - what they could not do in one thread at once and hung up, is now distributed over time and browsers can overpower this load. <br><br><h4>  Conclusion </h4><br>  We understand that any compatibility scrapping is a small tragedy in the life of a developer.  But as time goes on, things change, we gain experience and get feedback from users.  Many things wanted to change in version 2.0, but we could not do this because we promised not to change anything. <br><br>  Now we have a bit of freedom in connection with the release of the new version 2.1.  Of course, I wanted to change even more, but again we were restrained by the fact that we can change only small things (it is still 2.1, not 3.0). <br>  We hope that at least some innovations will help you in the development and the benefit will block the inconvenience of having to rewrite the code. <br><br>  I was told that the article should have a positive ending, so I congratulate everyone on the upcoming! </div><p>Source: <a href="https://habr.com/ru/post/207202/">https://habr.com/ru/post/207202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207188/index.html">A passion for programming. Chapter 14. Be a Mentor</a></li>
<li><a href="../207190/index.html">For designers and not only</a></li>
<li><a href="../207196/index.html">Search for black holes on a home computer</a></li>
<li><a href="../207198/index.html">Button. 100 years long story</a></li>
<li><a href="../207200/index.html">Do not postpone acquisitions in foreign online stores</a></li>
<li><a href="../207208/index.html">I2P proxy on hosting</a></li>
<li><a href="../207210/index.html">Dell VRTX: First Steps</a></li>
<li><a href="../207214/index.html">Implementation of the I2C interface based on the FT2232H chip (MPSSE mode)</a></li>
<li><a href="../207216/index.html">Qadars - a new banking Trojan with the ability to bypass two-factor authentication</a></li>
<li><a href="../207220/index.html">December distribution of servers: voting</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>