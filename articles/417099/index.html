<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As I wrote the standard C ++ 11 library or why the boost is so scary. Chapter 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Summary of the previous parts 
 Due to limitations on the ability to use C ++ 11 compilers and from the lack of alternatives to boost, there was a des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As I wrote the standard C ++ 11 library or why the boost is so scary. Chapter 2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="Yes - yes, with this motto I rushed into battle." width="300" height="350" align="left"><h3>  Summary of the previous parts </h3><br>  Due to limitations on the ability to use C ++ 11 compilers and from the lack of alternatives to boost, there was a desire to write our own implementation of the C ++ 11 standard library on top of the C ++ 98 / C ++ 03 library supplied with the compiler. <br><br>  In addition to the standard <b>type_traits</b> , <b>thread</b> , <b>mutex</b> , <b>chrono</b> header files, <b>nullptr.h</b> implementing <i>std :: nullptr_t</i> and <b>core.h</b> were also <b>added to</b> which macros related to compiler-specific functionality were added, as well as extending the standard library. <br><br>  Link to GitHub with the result today for the impatient and non-readers: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  <b><a href="https://github.com/oktonion/stdex">Commits and constructive criticism are welcome</a></b> </blockquote><a name="habracut"></a><br><h4>  Table of contents </h4><br>  <a href="https://habr.com/post/417027/">Introduction</a> <br>  <a href="https://habr.com/post/417027/">Chapter 1. Viam supervadet vadens</a> <br>  <b>Chapter 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</b> <br>  <a href="https://habr.com/post/417295/">Chapter 3. Finding the perfect implementation of nullptr</a> <br>  <a href="https://habr.com/post/417547/">Chapter 4. C ++ Template "Magic"</a> <br>  .... <a href="https://habr.com/post/417547/">4.1 Starting small</a> <br>  .... <a href="https://habr.com/post/417949/">4.2 How many we get wonderful errors are compiled by the log</a> <br>  .... <a href="https://habr.com/post/418347/">4.3 Pointers and all-all-all</a> <br>  .... <a href="https://habr.com/post/420365/">4.4 What else is needed for the template library</a> <br>  Chapter 5 <br>  ... <br><br><h3>  Chapter 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif </h3><br>  After all the code was slightly combed and divided by ‚Äústandard‚Äù headers into a separate <b>namespace stdex,</b> I started filling <b>type_traits</b> , <b>nullptr.h</b> and along the same <b>core.h</b> , which contained macros to determine the version of the standard used by the compiler and support it ‚Äú <b>Native</b> ‚Äù <b>nullptr</b> , <b>char16_t</b> , <b>char32_t</b> and <b>static_assert</b> . <br><br>  In theory, everything is simple - according to the C ++ standard <a href="http://eel.is/c%2B%2Bdraft/cpp">(Section 14.8), the</a> <b>__cplusplus</b> macro should be defined by the compiler and correspond to the version of the supported standard: <br><br><pre><code class="cpp hljs">C++ pre-C++<span class="hljs-number"><span class="hljs-number">98</span></span>: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 1 C++98: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L C++98 + TR1: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ??? C++11: #define __cplusplus 201103L C++14: #define __cplusplus 201402L C++17: #define __cplusplus 201703L</span></span></span></span></code> </pre> <br>  accordingly, the code to determine if support is trivial: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (__cplusplus &gt;= 201103L) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  C++ 11   #define _STDEX_NATIVE_CPP11_SUPPORT //   11  (nullptr, static_assert) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT //    char16_t, char32_t #endif</span></span></span></span></code> </pre><br><img src="https://habrastorage.org/webt/oq/qj/y8/oqqjy8dy_l8fyahlkfb3m-6uv3u.jpeg" alt="image" width="300" height="250" align="left">  In fact, not everything is so simple and now interesting crutches with a rake begin. <br><br>  First of all, not everyone, or more precisely, not one of the compilers, implements the next standard completely and immediately.  For example, in Visual Studio 2013 there was no <b>constexpr for a</b> very long time, and it was stated that it supports C ++ 11 - with the reservation that the implementation is not complete.  That is, <b>auto</b> - please, <b>static_assert</b> is just as easy (even from earlier MS VS), but <b>constexpr</b> is <a href="https://msdn.microsoft.com/en-us/library/hh567368.aspx">not</a> .  Secondly, not all compilers (and this surprises even more) correctly expose this define and update it in a timely manner.  Unexpectedly, the same Visual Studio compiler <a href="https://developercommunity.visualstudio.com/content/problem/120156/-cplusplus-macro-still-defined-as-pre-c11-value.html">did not change the version of the __cplusplus</a> <b>define</b> already from the very first versions of the compiler, although full support for C ++ 11 has long been declared (which is also not true, for which some rays of dissatisfaction are <b>coming</b> to them - as soon as the conversation turns to specific functionality of the ‚Äúnew "11 standard developers immediately say that there is no C99 preprocessor, there are still other" features ").  And the situation is further aggravated by the fact that, according to the standard, compilers are allowed to set this define to different values ‚Äã‚Äãfrom the values ‚Äã‚Äãabove, if they do not fully meet the stated standards.  It would be logical to assume, for example, such a development of defines for a given macro (with the introduction of a new functionality, increase the number behind the define data): <br><br><pre> <code class="cpp hljs">standart C++<span class="hljs-number"><span class="hljs-number">98</span></span>: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// C++98 standart C++98 + TR1: #define __cplusplus 200311L // C++03 nonstandart C++11: #define __cplusplus 200411L // C++03 + auto and dectype nonstandart C++11: #define __cplusplus 200511L // C++03 + auto, dectype and constexpr(partly) ... standart C++11: #define __cplusplus 201103L // C++11</span></span></span></span></code> </pre><br>  But at the same time, no one of the main popular compilers is worn out with this feature. <br><br>  Because of all this (I won't be afraid of this word) the mess now for each non-standard compiler you have to write your own specific checks in order to find out which C ++ standard and in what volume it supports.  The good news is that we need to learn about just a few of the functions of the compiler to work correctly.  First, now we add a version check for Visual Studio through the <b>_MSC_VER</b> macro, unique to this compiler.  Since in my arsenal of supported compilers there is also C ++ Borland Builder 6.0, the developers of which, in turn, were very keen to maintain compatibility with Visual Studio (including its ‚Äúfeatures‚Äù and bugs), then there is also suddenly this macro.  For clang-compatible compilers, there is a non-standard macro <b>__has_feature (</b> feature_name <b>)</b> , which allows you to find out if the compiler has support for this or that functionality.  As a result, the code swells up to: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif</span></span></span></span></code> </pre><br>  Want to cover more compilers?  Add checks for Codegear C ++ Builder, which is Borland's successor (in its worst manifestations, but more on that later): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif</span></span></span></span></code> </pre><br>  It is also worth noting that since Visual Studio already supports <b>nullptr</b> from the <b>_MSC_VER 1600</b> compiler version, as well as the built-in <b>char16_t</b> and <b>char32_t</b> types, we need to handle this correctly.  Some more checks added: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if ((!defined(_MSC_VER) || _MSC_VER &lt; 1600) &amp;&amp; !defined(_STDEX_NATIVE_CPP11_SUPPORT)) #define _STDEX_IMPLEMENTS_NULLPTR_SUPPORT #else #define _STDEX_NATIVE_NULLPTR_SUPPORT #endif #if (_MSC_VER &gt;= 1600) #ifndef _STDEX_NATIVE_CPP11_TYPES_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif</span></span></span></span></code> </pre><br>  At the same time, we will also check for support for C ++ 98, since for compilers without it there will not be some standard library header files, and we can‚Äôt verify the absence of them using the means of the compiler. <br><br><div class="spoiler">  <b class="spoiler_title">Full version</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if ((!defined(_MSC_VER) || _MSC_VER &lt; 1600) &amp;&amp; !defined(_STDEX_NATIVE_CPP11_SUPPORT)) #define _STDEX_IMPLEMENTS_NULLPTR_SUPPORT #else #define _STDEX_NATIVE_NULLPTR_SUPPORT #endif #if (_MSC_VER &gt;= 1600) #ifndef _STDEX_NATIVE_CPP11_TYPES_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if _MSC_VER // Visual C++ fallback #define _STDEX_NATIVE_MICROSOFT_COMPILER_EXTENSIONS_SUPPORT #define _STDEX_CDECL __cdecl #if (__cplusplus &gt;= 199711L) #define _STDEX_NATIVE_CPP_98_SUPPORT #endif #endif // C++ 98 check: #if ((__cplusplus &gt;= 199711L) &amp;&amp; ((defined(__INTEL_COMPILER) || defined(__clang__) || (defined(__GNUC__) &amp;&amp; ((__GNUC__ &gt; 4) || (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 4)))))) #ifndef _STDEX_NATIVE_CPP_98_SUPPORT #define _STDEX_NATIVE_CPP_98_SUPPORT #endif #endif</span></span></span></span></code> </pre><br></div></div><br>  And now volumetric configs from boost in which a lot of hardworking developers have written out all these compiler-dependent macros begin to appear in memory and of them compiled a map of what is supported and what is not a specific compiler for a particular version, which personally makes me uncomfortable, I never want to look at it and not touch more.  But the good news is that you can stop there.  At least this is enough for me to support most popular compilers, but if you find an inaccuracy or want to add another compiler, I will only be happy to accept a pull request. <br><br>  I consider it a great achievement compared to the boost that I managed to keep the compiler-dependent macros from sprawling along the code, which makes the code cleaner and easier to understand, and not to load dozens of configuration files for each OS and for each compiler.  We will talk about the disadvantages of this approach a little later. <br><br>  At this stage, we can already begin to connect the missing functionality of the 11 standard, and the first thing we introduce is <b>static_assert</b> . <br><br><h3>  static_assert </h3><br>  We define the <i>StaticAssertion</i> structure, which will take a boolean value as a template parameter - there will be our condition, if you fail to do this (the expression is set to <b>false</b> ), a non-specialized template compilation error will occur.  And another dummy structure for receiving <b>sizeof (</b> <i>StaticAssertion</i> <b>)</b> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> stdex { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticAssertion</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticAssertion</span></span></span><span class="hljs-class">&lt;true&gt; {</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// StaticAssertion&lt;true&gt; template&lt;int i&gt; struct StaticAssertionTest { }; // StaticAssertionTest&lt;int&gt; } }</span></span></code> </pre><br>  further macro magic <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message) static_assert((expression), #message) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// no C++11 support #define CONCATENATE(arg1, arg2) CONCATENATE1(arg1, arg2) #define CONCATENATE1(arg1, arg2) CONCATENATE2(arg1, arg2) #define CONCATENATE2(arg1, arg2) arg1##arg2 #define STATIC_ASSERT(expression, message)\ struct CONCATENATE(__static_assertion_at_line_, __LINE__)\ {\ stdex::detail::StaticAssertion&lt;static_cast&lt;bool&gt;((expression))&gt; CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _WITH__), message);\ };\ typedef stdex::detail::StaticAssertionTest&lt;sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))&gt; CONCATENATE(__static_assertion_test_at_line_, __LINE__) #ifndef _STDEX_NATIVE_NULLPTR_SUPPORT #define static_assert(expression, message) STATIC_ASSERT(expression, ERROR_MESSAGE_STRING) #endif #endif</span></span></span></span></code> </pre><br>  using: <br><br><pre> <code class="cpp hljs">STATIC_ASSERT(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*) == <span class="hljs-number"><span class="hljs-number">4</span></span>, non_x32_platform_is_unsupported);</code> </pre><br><blockquote>  An important difference between my implementation and the <a href="">standard one</a> is that there is no overload of this keyword <u>without a</u> message to the user.  This is due to the fact that in C ++ it is impossible to define several defines with a different number of arguments but with the same name, and an implementation without a message is much less useful than the chosen option.  This feature leads to the fact that in fact <b>STATIC_ASSERT</b> in my implementation is a version added already in C ++ 11. </blockquote>  We will understand in order what happened.  As a result of checks of <b>__cplusplus</b> versions and non-standard compiler macros, we have information on support of C ++ 11 in sufficient volume (and therefore <b>static_assert</b> ), expressed by the _STDEX_NATIVE_CPP11_SUPPORT <b>define</b> .  Therefore, if this macro is defined we can simply use the standard <b>static_assert</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message) static_assert((expression), #message)</span></span></code> </pre><br><blockquote>  Note that the second parameter of the <b>STATIC_ASSERT</b> macro is not a <b>string literal at all</b> and therefore, using the preprocessor operator <b>#,</b> we convert the <i>message</i> parameter to a string to be transferred to the standard <b>static_assert</b> . </blockquote>  If we don‚Äôt have support from the compiler, then we‚Äôll proceed to our implementation.  To begin with, we will declare auxiliary macros for ‚Äúgluing‚Äù strings (the preprocessor operator <b>##</b> is responsible for this). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE(arg1, arg2) CONCATENATE1(arg1, arg2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE1(arg1, arg2) CONCATENATE2(arg1, arg2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE2(arg1, arg2) arg1##arg2</span></span></code> </pre><br><blockquote>  I didn‚Äôt specifically use just <b># define CONCATENATE (</b> <i>arg1</i> , <i>arg2</i> <b>)</b> <i>arg1 ## arg2</i> in order to be able to pass the result of the same <b>CONCATENATE</b> macro as an argument to <i>arg1</i> and <i>arg2</i> . </blockquote>  Next, we declare a structure with a beautiful name __static_assertion_at_line_ {line number} (the macro <b>__LINE__</b> is also defined by the standard and should be expanded into the line number on which it was called), and inside this structure we add a field of our type <i>StaticAssertion</i> named STATIC_ASSERTION_FAILED_AT_LINE_ {line number} _WITH __ { error messages from the caller}. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message)\ struct CONCATENATE(__static_assertion_at_line_, __LINE__)\ {\ stdex::detail::StaticAssertion</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;static_cast&lt;bool&gt;((expression))&gt; CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _WITH__), message);\ };\ typedef stdex::detail::StaticAssertionTest&lt;sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))&gt; CONCATENATE(__static_assertion_test_at_line_, __LINE__)</span></span></span></span></code> </pre><br>  <i>With a</i> template parameter in <i>StaticAssertion,</i> we pass an expression that is checked in <b>STATIC_ASSERT</b> , leading it to <b>bool</b> .  Finally, in order to avoid creating local variables and zero-overhead checking a user condition, an alias is declared for the type <i>StaticAssertionTest &lt;sizeof ({structure name declared above)</i> with the name __static_assertion_test_at_line_ {line number}. <br><br>  All beauty with naming is needed only to make it clear from a compilation error that this is the result of assert, and not just an error, as well as to display an error message that was given for this assert.  The <b>sizeof</b> trick is needed to force the compiler to instantiate the <i>generic StaticAssertion</i> class inside the newly declared structure and thus check the condition passed to assert. <br><br><div class="spoiler">  <b class="spoiler_title">STATIC_ASSERT issue results</b> <div class="spoiler_text"><blockquote>  GCC: <br>  30: 103: error: field 'STATIC_ASSERTION_FAILED_AT_LINE_36_WITH__non_x32_platform_is_unsupported' has incomplete type 'stdex :: detail :: StaticAssertion &lt;false&gt;' <br>  25:36: note: in definition of macro 'CONCATENATE2' <br>  23:36: note: in expansion of macro 'CONCATENATE1' <br>  30:67: note: in expansion of macro 'CONCATENATE' <br>  24:36: note: in expansion of macro 'CONCATENATE2' <br>  23:36: note: in expansion of macro 'CONCATENATE1' <br>  30:79: note: in expansion of macro 'CONCATENATE' <br>  24:36: note: in expansion of macro 'CONCATENATE2' <br>  23:36: note: in expansion of macro 'CONCATENATE1' <br>  30:91: note: in expansion of macro 'CONCATENATE' <br>  36: 3: note: in expansion of macro 'STATIC_ASSERT' <br><br>  Borland C ++ Builder: <br>  [C ++ Error] stdex_test.cpp (36): E2450 Undefined structure 'stdex :: detail :: StaticAssertion &lt;0&gt;' <br>  [C ++ Error] stdex_test.cpp (36): E2449 Size of 'STATIC_ASSERTION_FAILED_AT_LINE_36_WITH__non_x32_platform_is_unsupported' is unknown or zero <br>  [C ++ Error] stdex_test.cpp (36): E2450 Undefined structure 'stdex :: detail :: StaticAssertion &lt;0&gt;' <br><br>  Visual Studio: <br>  Error C2079 'main :: __ static_assertion_at_line_36 :: STATIC_ASSERTION_FAILED_since you work </blockquote><br></div></div><br>  The second "trick" that I wanted to have, while <u>absent</u> in the standard is the <b>countof</b> - counting the number of elements in the array.  Sichniki love to declare this macro through sizeof (arr) / sizeof (arr [0]), but we will go further. <br><br><h3>  countof </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstddef&gt; namespace stdex { namespace detail { template &lt;class T, std::size_t N&gt; constexpr std::size_t _my_countof(T const (&amp;)[N]) noexcept { return N; } } // namespace detail } #define countof(arr) stdex::detail::_my_countof(arr) #else //no C++11 support #ifdef _STDEX_NATIVE_MICROSOFT_COMPILER_EXTENSIONS_SUPPORT // Visual C++ fallback #include &lt;stdlib.h&gt; #define countof(arr) _countof(arr) #elif defined(_STDEX_NATIVE_CPP_98_SUPPORT)// C++ 98 trick #include &lt;cstddef&gt; template &lt;typename T, std::size_t N&gt; char(&amp;COUNTOF_REQUIRES_ARRAY_ARGUMENT(T(&amp;)[N]))[N]; #define countof(x) sizeof(COUNTOF_REQUIRES_ARRAY_ARGUMENT(x)) #else #define countof(arr) sizeof(arr) / sizeof(arr[0]) #endif</span></span></span></span></code> </pre><br>  For compilers with <b>constexpr</b> support, <b>we will</b> announce the constexpr version of this template (which is not necessary, in fact, for all standards, implementation through the <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> template is <i>sufficient</i> ), for the rest, we introduce the version through the <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> template function.  Visual Studio again distinguished itself by having its own <b>_countof</b> implementation in the <b>stdlib.h</b> header file. <br><br>  The <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> function looks daunting and it‚Äôs pretty hard to figure out what it does.  If you take a closer look, you can understand that it takes as its input a single argument an array of elements of the template type <i>T</i> and size <i>N</i> - so in the case of transferring other types of elements (not arrays) we get a compilation error, which undoubtedly pleases.  Looking more closely, you can figure out (with difficulty) that it returns an array of <b>char</b> elements of size <i>N.</i>  The question is why do we need all this?  This is where the <b>sizeof</b> operator comes into <b>play</b> and its unique ability to work at compile time.  The call <b>sizeof (</b> <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> <b>)</b> determines the size of the array returned by the array of <b>char</b> elements, and since the <b>sizeof (char)</b> == 1 standard, this is the number of <i>N</i> elements in the source array.  Exquisite, beautiful, and completely free. <br><br><h3>  forever </h3><br>  Another small helper macro that I use wherever an infinite loop is needed is <b>forever</b> .  It is defined as: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined(forever) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> forever for(;;) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STRINGIZE_HELPER(x) #x #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STRINGIZE(x) STRINGIZE_HELPER(x) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WARNING(desc) message(__FILE__ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"("</span></span></span><span class="hljs-meta"> STRINGIZE(__LINE__) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">") : warning: "</span></span></span><span class="hljs-meta"> desc) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> WARNING(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdex library - macro 'forever' was previously defined by user; ignoring stdex macro definition"</span></span></span><span class="hljs-meta">) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> STRINGIZE_HELPER #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> STRINGIZE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> WARNING #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  example syntax for defining an explicit infinite loop: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; forever { ++i; }</code> </pre><br>  This macro is used exclusively for the explicit definition of an infinite loop and is included in the library only for the reasons of ‚Äúadd syntactic sugar‚Äù.  In the future, I intend to replace it with an option via define.  What is noteworthy in the above code snippet from the library is the very <b>WARNING</b> macro that generates a warning message in all compilers if the <b>forever</b> macro has already been defined by the user.  It uses the familiar standard macro <b>__LINE__</b> and also the standard <b>__FILE__</b> , which is converted to a string with the name of the current source file. <br><br><h3>  stdex_assert </h3><br>  To implement <b>assert</b> , a macro <b>stdex_assert is</b> introduced in <b>runtime</b> as: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(assert) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> NDEBUG #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #define stdex_assert(condition, message) \ do { \ if (! (condition)) { \ std::cerr &lt;&lt; "Assertion `" #condition "` failed in " &lt;&lt; __FILE__ \ &lt;&lt; " line " &lt;&lt; __LINE__ &lt;&lt; ": " &lt;&lt; message &lt;&lt; std::endl; \ std::terminate(); \ } \ } while (false) #else #define stdex_assert(condition, message) ((void)0) #endif #endif</span></span></span></span></code> </pre><br>  I will not say that I am very proud of this implementation (it will be changed in the future), but here I used an interesting trick to which I would like to draw attention.  In order to hide the checks from the scope of the application code, the <b>do</b> <i>{}</i> <b>while (false)</b> construct is used, which is executed, which is obvious, once and does not include the "service" code in the general application code.  This technique is quite useful and is used in several places in the library. <br><br>  Otherwise, the implementation is very similar to the standard <b>assert</b> - with a certain <b>NDEBUG</b> macro, which is usually set by compilers in release assemblies, assert does nothing, otherwise it interrupts program execution with outputting the message to the standard error stream if the assert condition is not followed. <br><br><h3>  noexcept </h3><br>  For functions that do not throw exceptions, the <b>noexcept</b> keyword was introduced in the new standard.  It is also quite simple and painlessly possible to implement through a macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> stdex_noexcept noexcept #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> stdex_noexcept throw() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  however, you must understand that according to the standard <b>noexcept</b> can take the value <b>bool</b> , and also <a href="https://en.cppreference.com/w/cpp/language/noexcept">be used</a> to determine at compile time that the expression passed to it does not throw exceptions.  This functionality cannot be implemented without compiler support, and therefore there is only a ‚Äútruncated‚Äù <b>stdex_noexcept</b> in the library. <br><br>  The end of the second chapter.  The <a href="https://habr.com/post/417295/">third chapter</a> will discuss the intricacies of the implementation of nullptr, why it is different for different compilers, as well as how type_traits was advanced and what other bugs in compilers I came across while developing it. <br><br>  Thank you for attention. </div><p>Source: <a href="https://habr.com/ru/post/417099/">https://habr.com/ru/post/417099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417087/index.html">HPE Digitize 2018: event and live streaming</a></li>
<li><a href="../417089/index.html">Quantum computer: one photon to rule by all</a></li>
<li><a href="../417091/index.html">Creating a cartoon water shader for the web. Part 3</a></li>
<li><a href="../417093/index.html">Modbus touch switches: why you need it and how to use it in a smart apartment</a></li>
<li><a href="../417097/index.html">JavaScript Metaprogramming</a></li>
<li><a href="../417101/index.html">Definition of Ready - what we forgot to tell us</a></li>
<li><a href="../417103/index.html">Spark SQL. A little bit about the query optimizer</a></li>
<li><a href="../417105/index.html">Printing on a 3D printer. Secret experiences from the company 3Dtool</a></li>
<li><a href="../417107/index.html">The creator of the game while True: learn () about programming in a game dev, problems with VR and simulation ML</a></li>
<li><a href="../417109/index.html">Richard Hamming: Chapter 10. Coding Theory - I</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>