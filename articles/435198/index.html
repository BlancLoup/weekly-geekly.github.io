<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Arduin and LED, or how to pump the children's designer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="My son is firmly hooked on the Magformers magnetic designer . Once, looking through the series of Fixics, where the same designer appeared, the child ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Arduin and LED, or how to pump the children's designer</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/wp/c4/ox/wpc4oxeubxh_dsoa07dy5wfccoa.jpeg"><br><br>  My son is firmly hooked on the <a href="https://www.google.com.ua/search%3Fq%3Dmagformers">Magformers magnetic designer</a> .  Once, looking through the <a href="https://www.youtube.com/watch%3Fv%3D5Tsg0M7siJI">series of Fixics, where the same designer appeared, the</a> child asked: ‚ÄúDad, why do parts of shine fixes glow, but don't we?‚Äù. <br><br>  It turned out that there really is a ‚ÄúMagformers Neon LED Set‚Äù, where besides the usual building blocks there is also an element with an LED.  Since by this time we already had a whole box of magnets of all possible shapes and sizes (as for me, the <a href="https://www.aliexpress.com/af/magnetic-building-blocks.html%3Fd%3Dy%26origin%3Dn%26blanktest%3D0%26jump%3Dafs%26initiative_id%3DAS_20180201130507%26isViewCP%3Dy%26catId%3D0">Chinese magformers</a> are not inferior to the original), <a href="https://www.aliexpress.com/af/magnetic-building-blocks.html%3Fd%3Dy%26origin%3Dn%26blanktest%3D0%26jump%3Dafs%26initiative_id%3DAS_20180201130507%26isViewCP%3Dy%26catId%3D0">I</a> didn‚Äôt want to buy another set just for the sake of a light bulb.  Moreover, this set cost significantly more expensive than the same without lighting. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Having estimated that there were only a couple of components there, most of which I already had, I decided to assemble my own hulk.  Yes, and with effects that were not in the original. <br><br>  Under the cat you will find a variant of the twinkle on the ATTiny85 and the LED panel on the WS8212 LEDs.  I'll tell you about the circuitry, how I fed this whole thing from the battery, as well as the unobvious problems that I raked along the way.  I will also talk in detail about the program component of the project. <br><a name="habracut"></a><br><h2>  The first steps </h2><br>  It seemed to me that the light on a regular LED (even if it is RGB) is boring and trite.  But to feel something like WS8212 seemed interesting.  On ebee both individual LEDs and matrixes up to 16x16 in size were offered.  Having bought several different modules, I stopped at the 4x4 matrix.  There are a lot of LEDs in it to indulge in various visual effects, while the module is comparable in size with the window of a square block designer. <br><br><img src="https://habrastorage.org/webt/f8/wj/kv/f8wjkvhcyj5zvrzyp81xb0zslu4.jpeg"><br><br>  To control the LED matrix, just one pin of the microcontroller is enough, so that even the arduin nano looks like a brute force (besides, it will not fit into the case).  But the digispark clone on the ATTiny85 controller turned out to be just right - there is not a lot of memory and pins in it, but more than enough for an LED blinker.  The module integrates perfectly with the Arduino IDE and has a USB downloader on board, so programming this module is very simple and comfortable.  I have long wanted to try it. <br><br>  Started with the simplest scheme. <br><br><img src="https://habrastorage.org/webt/-8/yx/5b/-8yx5b02f2dxtqaps1tw6aoj_io.png"><br><br>  In this form, it was possible to quickly debug all the glow / blink algorithms (see below).  But here a toy with wire power is not the case - you need to think about battery power.  And in order not to go broke on the finger batteries (which, moreover, do not fit into the envelope), it was decided to use lithium batteries.  And since there is a lithium battery, then you need to think about how to charge it.  In the bins, I just found a <a href="https://mysku.ru/blog/aliexpress/30210.html">‚Äúpopular‚Äù charge controller on the TP4056 microcircuit</a> bought on the occasion. <br><br>  Only now connect it immediately failed.  The circuit of the Digispark ATTiny85 module is not very much designed for this - either there is USB power, but then the power is supplied directly to the microcontroller (via the +5 bus) or from the VIN input, but then the power goes through the 7805 linear stabilizer. inserted into the gap between the USB connector and the microcontroller is not provided.  I had to modify a bit of the scheme and remove the extra details. <br><br><img src="https://habrastorage.org/webt/99/ta/ab/99taabsud7cdoakqixa8ah4ee0y.png"><br><br>  So, now the power from the USB goes to the VIN leg and goes on to the input of the charger.  The output of the charger (in fact, the battery is connected directly) comes back into the board through the 5V leg.  And although in fact there will be from 3 to 4.2V (battery voltage) it is quite normal - the operating voltage range of the microcontroller is 1.8-5.5V.  And even the LED module normally works from 2.7V, although below the 3.2V the blue LED is slightly lacking and the colors ‚Äúfloat‚Äù a little to yellow. <br><br>  In order to save electricity, I also dropped the always-on D2 LED.  The general scheme now looks like this <br><br><img src="https://habrastorage.org/webt/pr/d_/fq/prd_fqhsjwulccuuw-1aissl52k.png"><br><br>  It would be possible to feed the circuit through the USB connector in the charger, but then the opportunity to upload the firmware via the USB connector on the controller board would be lost.  It would be possible to leave two USB connectors for various purposes - one for charging, the other for firmware, but this is somehow wrong. <br><br>  A 6x25x35 battery bought on ebee, but it turned out to be either defective, or I killed it with a short circuit or with a large charge current (the board has a default charging current set to 1A and one resistor needs to be soldered to reduce the current).  In any case, when the load was connected, even at 10mA, the voltage on the battery dropped to 1V.  At the time of testing, I switched to a half-dead LiPo battery from a small quadcopter.  A little later, I ordered the battery from another seller and it turned out to be good. <br><br>  In principle, this could have stopped, soldered the connecting wires and gently shoved everything into some kind of body, but I decided to measure the consumption of the circuit.  And then I shed a tear.  Well, that in working condition (when the light bulbs shine to the full), this thing eats up to 130mA, so at rest the consumption is more than 25mA!  Those.  my 600mAh battery this blinker eats less than a day! <br><br>  It turned out that about 10mA consume LEDs.  Even if they do not glow, the microcontroller still works in each of them and expects a command.  Those.  You need to come up with a power supply circuit for LEDs. <br><br>  The remaining 15 mA is consumed by the microcontroller.  Yes, it can be put to sleep and according to the datasheet the consumption will be measured by micro amperes, but in fact it was not possible to get less than 1 mA.  I disconnected the ADC and translated the pins into input.  There seems to be a leak somewhere in the scheme, but my modest knowledge of electronics is not enough to find and understand it. <br><br><h2>  Complicate the scheme </h2><br>  Then I remembered that I bought a PT1502 chip for sample.  This microcircuit is a lithium battery charge controller complete with a power source with several control inputs.  The only difficulty is that the microcircuit goes in a 4x4 mm QFN20 package and requires some strapping.  Soldering this at home is difficult, but possible.  The fee is difficult for an ordinary LUT and must be ordered from the Chinese.  But we are not afraid of difficulties, right? <br><br>  In a few squares, the scheme can be described as follows. <br><br><img src="https://habrastorage.org/webt/t9/c5/rg/t9c5rgauskpsz1momglwordnf0o.png"><br><br>  In the off state, the power to the controller and the LEDs is not supplied.  The device has a 'Power' button, which turns on the blinker (it also switches modes).  The LED shines, say, a minute and if there is no user activity (no one presses a button), then the device turns off.  Those.  It does not just go to sleep, but it turns off power to itself with the Power Hold signal.  And off all at once - and the microcontroller, and LEDs.  The power-on and power-off functionality is implemented inside the PT1502 microcircuit. <br><br>  All that remains is to draw a schematic diagram and make a board.  The scheme, for the most part, is lapped from the datasheet PT1502, as well as the Digispark ATTiny85 module.  The PT1502 power controller chip is functionally divided into several parts, because the circuit is divided into blocks. <br><br><img src="https://habrastorage.org/webt/fc/s6/qu/fcs6qu4zqgfja5p4hjacywrds8k.png"><br><br>  This is, in fact, a lithium battery charge controller with its strapping.  LED1 indicates the status of the charge - lit, then the charge is on.  Resistor R6 sets the charge current to 470mA.  Since I have a 600 mAh battery, in principle it is possible to raise the current and up to 600 mA by setting the resistor to 780-800 Ohm.  However, I am not sure about the special quality of my battery - it‚Äôs better to charge more slowly, but it will live longer. <br><br>  Consider a power plan <br><br><img src="https://habrastorage.org/webt/z1/rb/_a/z1rb_a2zu2a95pvxzk629o1tsjm.png"><br><br>  Button SW1 starts the entire system - the PT1502 chip wakes up by itself and then starts all the power supplies (of which it has 3).  When the power supply is established, the microcircuit starts the microcontroller by releasing the RESET signal.  For the convenience of debugging, I also added a separate Reset button. <br><br>  The HOLD signal is used to turn off the entire system.  When the microcontroller starts, it should put a unit on this line.  When it is time to round out, the microcontroller sets a zero to the HOLD line and the PT1502 power supply chip will stop all power supplies. <br><br>  It would be possible to track the low battery with the help of the BAT_LOW output, but in this work I hammered on it - I do not need to save any data and nothing will explode if I do not notice the dead battery in time.  Die so die.  But just in case the board provided contact for this case. <br><br>  Let's return for a second to the SW1 button.  I decided not to make 2 separate buttons for switching on and for controlling.  Therefore, the same button is also connected to ATTiny85 and during operation switches blinking modes.  The values ‚Äã‚Äãof the divider R7-R8 are chosen so as not to burn the port of the microcontroller PB2.  With all voltage ranges of the battery (3.3 - 4.2V), the voltage of the controller will be supplied within the limits specified by the datasheet (0.7 * VCC - VCC + 0.5V) <br><br>  Consider the power source <br><br><img src="https://habrastorage.org/webt/u1/3q/kf/u13qkfyn6g7gffo_qb8j9licy4w.png"><br><br>  This is a pulse DC-DC converter.  The output voltage is set by resistors R10-R11 and according to the formula from the datasheet is set to 3.3V.  Everything else is a simple strapping. <br><br>  For good, such a sophisticated power supply is not really needed - it would have been possible to power the microcontroller directly from the battery.  Simply, this source is already implemented in the PT1502 chip and it can be turned on / off when we need to - why not use this? <br><br><img src="https://habrastorage.org/webt/ad/8w/0z/ad8w0zewrcux0hdetprifertqss.png"><br><br>  The chip also has 2 linear stabilizers, but I will not use them.  Unfortunately, as it turned out, the input voltage to the source is still needed, otherwise the microcircuit thinks that the power supply is still not stable enough and does not start the microcontroller (this knowledge was given to me a week to re-solder the test board to and fro ‚Äî I could not understand why ) <br><br>  Let us turn to the logical part. <br><br><img src="https://habrastorage.org/webt/sq/su/xj/sqsuxjeblb7507pz8ej2h1t3yui.png"><br><br>  The USB binding is lapped from the Digispark board unchanged.  This is needed to match the USB voltages (which run 3.3V) and the microcontroller signals (which in the original is powered by 5V).  Since, in my case, the microcontroller is also powered by 3.3V, the circuit could be simplified, but just in case, I spread the original circuit on the board. <br><br><img src="https://habrastorage.org/webt/qe/q8/xr/qeq8xr1bwr-ux0jnsk5na1p6eaw.png"><br><br>  In the strapping of the microcontroller is nothing interesting. <br><br>  The final touch is the connector. <br><br><img src="https://habrastorage.org/webt/ic/vt/ey/icvtey-cwulcyqozyphkmglv-0m.png"><br><br>  In fact, I got such a debug board on ATTiny85 with USB support and a lithium battery power controller.  Therefore, I didn‚Äôt confine myself only to outputting a line to an LED.  Instead, I brought all the lines of the microcontroller to a comb - at the same time it is convenient to connect to the programmer as well. <br><br>  And let almost all the lines are rigidly tied to a specific functionality (PB1 - line Hold, PB2 - power button, PB3 / PB4 - USB, PB5 - Reset) in the future it will be possible to bypass within certain limits.  For example, do not unsolder the USB cable and release the PB3 / PB4 lines.  Or, for example, refuse to reset and release PB5.  In the meantime, only PB0 remains free - connect our LED to it. <br><br>  Go to the board.  Given the limitations on the size of the board at 40x40mm, the number of components and the QFN20 package of the PT1502 chip, I did not even consider making the board at home.  Therefore, I immediately began to breed the most compact two-layer board.  Here's what I got <br><br><img src="https://habrastorage.org/webt/yt/6q/wh/yt6qwhfd9zkia64yyejpjx9litu.png"><br><br>  For ease of use on the reverse side I signed all the possible functions of the conclusions (the idea of ‚Äã‚Äãslyamzil from the Digispark board) <br><br><img src="https://habrastorage.org/webt/q-/on/8t/q-on8tdmxq_bvht8egr5ilipb4s.png"><br><br>  I ordered the <a href="http://jlcpcb.com/">board</a> on <a href="http://jlcpcb.com/">JLCPCB</a> .  I‚Äôm not very pleased with the quality, to be honest - if you re-solder a microchip many times, then the mask near the small contacts PT1502 will be a bit crammed.  Well, small inscriptions floated a little.  However, if everything is soldered from the first time, then the rules. <br><br>  For soldering QFN20 you will need a soldering dryer, everything else can be soldered with a regular soldering iron with a certain skill.  Here is the wired card <br><br><img src="https://habrastorage.org/webt/ct/km/4g/ctkm4gs_myfjjfeoukwn4ijuuc4.jpeg"><br><br><h2>  Housing </h2><br>  It's time to go to the body.  I printed it on a 3D printer.  No frills design - box and button.  The box has special hooks to install the light into the standard square module of the designer. <br><br><img src="https://habrastorage.org/webt/g9/bz/yd/g9bzydcnm7bwonoo6rhe-1hby7k.png"><br><br>  In the case lives the main board and battery. <br><br><img src="https://habrastorage.org/webt/zp/4u/x-/zp4ux-vaqurrmg9yqe3jb3jkry8.jpeg"><br><br><img src="https://habrastorage.org/webt/4f/oa/dw/4foadwyytzwav_lfiyvqrl5lcxs.jpeg"><br><br>  The LED panel is attached to the cover, which in turn is screwed to the main box with screws <br><br>  At first I thought to fasten the LED panel to the cover with screws, but in the end I just stuck it on a double-sided tape.  It turned out like this <br><br><img src="https://habrastorage.org/webt/vy/ks/y2/vyksy2ccuvrwcrjmxgvzolhlia0.jpeg"><br><br>  In this form, the device can already be used, but it still looks ugly - not enough diffuser. <br><br>  I tried to make the first version of the diffuser using the technology of shrinking PET bottles with a building dryer (peeped from model airplanes). <br><br>  So, first you need a blank.  I made it from plaster, which I filled in the form, which I printed on a 3D printer.  In the first embodiment, the form was one-piece and I could not pull the cast disc out of it.  Therefore it was necessary to make a form of two parts. <br><br><img src="https://habrastorage.org/webt/gb/x0/0i/gbx00iokd8ea_lfquvmbbfebed4.jpeg"><br><br>  The idea of ‚Äã‚Äãthe method is as follows.  You put a bottle of baby yogurt on the disc and set it down with a building dryer.  Here are just rewashing the pieces of 20 different containers from under the different jelly, I never managed to sit this thing nicely, without folds and bubbles.  Apparently you need to fence some kind of vacuum installation and shrink sheet plastic.  In general, it was too difficult for such crafts. <br><br>  Rummaging through the bottom of the barrel, I found a plastic Verbatim PET Transparent probe in a couple of meters.  I decided to try the diffuser just to print.  And although at the entrance to the plastic printer seems crystal clear, the real detail turns out to be dull dull.  This is probably due to the internal structure, since  the layers do not fill the volume completely but overlap at intervals and slots.  Moreover, if you try to process the part with sandpaper for a smoother surface, you will get even more matting.  However, this is exactly what I needed. <br><br>  I was too lazy to mess with the mount for the diffuser, so I attached it to the hot melt glue.  So I now conditionally collapsible design.  I could have been confused with the invention of some snaps, but I already had a transparent plastic probe.  So let it be hot melt. <br><br><img src="https://habrastorage.org/webt/xb/vy/49/xbvy49czm3mqdgjrexvvrcsm25m.jpeg"><br><br><img src="https://habrastorage.org/webt/fz/tx/tx/fztxtxljbgq0uwqnhlne0-mvcdc.jpeg"><br><br><h2>  Firmware </h2><br>  For the LED blinker, it is not necessary to dive very strongly into the periphery of the microcontroller - just a couple of functions for working with GPIO.  But since the module fits into the Arduino platform, why not use it? <br><br>  First, a few definitions and constants <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Number of total LEDs on the board. Mine has 4x4 LEDs #define NUM_HW_PIXELS 16 // Pin number where LED data pin is attached #define DATA_PIN 0 // Pin number where mode switch button is attached #define BUTTON_PIN 2 // Power Enabled pin #define POWER_EN_PIN 1 // Max brightness (dimming the light for debugging) #define MAX_VAL 255</span></span></code> </pre> <br>  Here is determined by the number of pixels in my matrix, pin numbers and the maximum brightness of the LEDs (during debugging it was convenient to set it at the level of 50, so as not to blind the eyes) <br><br>  The LEDs in my matrix are arranged in a rather non-obvious way - zigzag.  Because for different effects had to be renumbered. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// LED indexes for different patterns uint8_t circleLEDIndexes[] = {0, 1, 2, 3, 4, 11, 12, 13, 14, 15, 8, 7}; uint8_t beaconLEDIndexes[] = {6, 5, 10, 9}; uint8_t policeLEDIndexes[] = {7, 6, 10, 11, 4, 5, 9, 8};</span></span></code> </pre> <br>  To control the LEDs, I did not reinvent the wheel and took a <a href="https://github.com/acrobotic/Ai_Ardushield_Lumina/tree/master/firmware/effects">ready-made library for working with WS8211 LEDs</a> .  The library interface is slightly whitened-colored.  Some auxiliary functions (for example, converting HSV to RGB) also come from there. <br><br>  First, the WS8211 board and library need to be initialized. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Driver Ai_WS2811 ws2811; void setup() { // Set up power pinMode(POWER_EN_PIN, OUTPUT); digitalWrite(POWER_EN_PIN, HIGH); // initialize LED data pin pinMode(LED_PIN, OUTPUT); // Initialize button pin pinMode(BUTTON_PIN, INPUT); // Initialize WS8211 library static CRGB ledsBuf[NUM_HW_PIXELS]; ws2811.init(DATA_PIN, NUM_HW_PIXELS, ledsBuf); // Set the watchdog timer to 2 sec wdt_enable(WDTO_2S); }</span></span></code> </pre> <br>  First of all, you need to set the POWER HOLD signal to one - it will be a signal from the PT1502 chip, that the microcontroller has started up and is working properly.  The microcircuit in turn will regularly supply electricity to the microcontroller and the LEDs as long as the HOLD signal is set to one. <br><br>  Next, the LED output control legs and the input buttons are configured.  You can then initialize the WS8211 library. <br><br>  Since this is a fairly self-contained device, the microcontroller should not be allowed to stick in an incomprehensible state and gobble up the entire battery.  To do this, I start the watchdog timer for 2 seconds.  The timer will restart in the main program loop. <br><br>  Now we need to define a couple of auxiliary functions.  The WS8211 library stores a buffer with the color values ‚Äã‚Äãof each LED.  Work with the buffer directly is not very convenient, because I wrote a simple function to write RGB values ‚Äã‚Äãto a specific LED <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRgb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> g, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ CRGB * leds = ws2811.getRGBData(); leds[led_idx].r = r; leds[led_idx].g = g; leds[led_idx].b = b; }</code> </pre> <br>  But in most cases in the RGB color model it is not very convenient to count colors, if not impossible.  For example, when drawing all sorts of rainbows, it is more convenient to work with <a href="https://ru.wikipedia.org/wiki/HSV_(%25D1%2586%25D0%25B2%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C)">the HSV color model</a> .  The color of each pixel is set by the color tone value and brightness.  Saturation value is omitted for simplicity (maximum is used).  The hue values ‚Äã‚Äãare reduced to the range of 0-255 (instead of the standard 0-359). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * HVS to RGB conversion (simplified to the range 0-255) **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setHue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> brightness)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//this is the algorithm to convert from RGB to HSV double r = 0; double g = 0; double b = 0; double hf = hue/42.6; // Not /60 as range is _not_ 0-360 int i=(int)floor(hue/42.6); double f = hue/42.6 - i; double qv = 1 - f; double tv = f; switch (i) { case 0: r = 1; g = tv; break; case 1: r = qv; g = 1; break; case 2: g = 1; b = tv; break; case 3: g = qv; b = 1; break; case 4: r = tv; b = 1; break; case 5: r = 1; b = qv; break; } brightness = constrain(brightness, 0, MAX_VAL); setRgb(led_idx, constrain(brightness*r, 0, MAX_VAL), constrain(brightness*g, 0, MAX_VAL), constrain(brightness*b, 0, MAX_VAL) ); }</span></span></code> </pre><br>  The function is taken from the library Ai_WS8211 and slightly filed.  In the original version of this function from the library there were a couple of bugs because of what the color on the rainbows appeared with jerks. <br><br>  Let us turn to the implementation of various effects.  Each function is called from the main loop to draw one ‚Äúframe‚Äù.  As each effect operates with different parameters between calls, they are stored in static variables. <br><br>  This is the simplest effect - all LEDs are filled with one color that changes smoothly. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rainbow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> hue = <span class="hljs-number"><span class="hljs-number">0</span></span>; hue++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; NUM_HW_PIXELS; led++) setHue(led, hue, MAX_VAL); ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">80</span></span>); }</code> </pre> <br>  The next effect is more interesting - it displays a rainbow along the contour of the matrix, and the colors in the rainbow gradually shift in a circle. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slidingRainbow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(circleLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hue = (pos + led*<span class="hljs-number"><span class="hljs-number">256</span></span>/ARRAY_SIZE(circleLEDIndexes)) % <span class="hljs-number"><span class="hljs-number">256</span></span>; setHue(circleLEDIndexes[led], hue, MAX_VAL); } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre> <br>  And this effect fills the entire matrix with a random color, which at first smoothly lights up, and then also goes out smoothly. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomColorsFadeInOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> color = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> goesUp = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curLevel = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !goesUp) { color = rand() % <span class="hljs-number"><span class="hljs-number">256</span></span>; goesUp = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curLevel == MAX_VAL &amp;&amp; goesUp) { goesUp = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; NUM_HW_PIXELS; led++) setHue(led, color, curLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(goesUp) curLevel++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> curLevel--; ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre><br>  The next group of effects draws various flashing lights.  For example, a child likes to build a bulldozer from magnets and an orange flasher will be very useful there. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orangeBeacon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ORANGE_HUE = <span class="hljs-number"><span class="hljs-number">17</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos+=<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(circleLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = brightnessByPos(pos, led*<span class="hljs-number"><span class="hljs-number">255</span></span>/ARRAY_SIZE(circleLEDIndexes), <span class="hljs-number"><span class="hljs-number">70</span></span>); setHue(circleLEDIndexes[led], ORANGE_HUE, brightness); } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Technically, the effect looks like a bright dot that moves across the matrix.  But to make the neighboring LEDs look beautiful, they gradually fade away as they move away from the main point.  Therefore, I needed a function that calculates this very brightness. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">brightnessByPos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ledPos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(pos - ledPos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(diff &gt; <span class="hljs-number"><span class="hljs-number">127</span></span>) diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>-diff); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = MAX_VAL - constrain(MAX_VAL*diff/delta, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_VAL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> brightness; }</code> </pre><br>  Pos is a certain conditional position of the luminous point brightness, displayed on the looped range of 0-255.  ledPos is the position of the LED (displayed on the same range) whose brightness you want to calculate.  If the position difference is greater than delta, then the LED is off, and the closer to the position, the brighter it lights up. <br><br>  Or, for example, a red and blue flashing beacon <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">policeBeacon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RED_HUE = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BLUE_HUE = <span class="hljs-number"><span class="hljs-number">170</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(policeLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ledPos = led*<span class="hljs-number"><span class="hljs-number">255</span></span>/ARRAY_SIZE(policeLEDIndexes); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = brightnessByPos(pos, ledPos, <span class="hljs-number"><span class="hljs-number">50</span></span>); setHue(policeLEDIndexes[led], RED_HUE, brightness); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(brightness == <span class="hljs-number"><span class="hljs-number">0</span></span>) { brightness = brightnessByPos((pos+<span class="hljs-number"><span class="hljs-number">100</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span>, ledPos, <span class="hljs-number"><span class="hljs-number">50</span></span>); setHue(policeLEDIndexes[led], BLUE_HUE, brightness); } } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  If we are talking about cars, then the traffic light is not a problem here. <br><br>  These are features that include different traffic lights at different positions. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearPixels</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;NUM_HW_PIXELS; i++) { setRgb(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>; i++) setRgb(i, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yellowTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">4</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; i++) setRgb(i, MAX_VAL, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greenTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">8</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; i++) setRgb(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); }</code> </pre> <br>  It's time to revive.  The traffic light is working on a special program, set in something like bytecode.  The plate describes the mode and the time for which this mode should be included. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TRAFFIC_LIGHTS { NONE, RED, YELLOW, GREEN }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trafficLightState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> state; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> duration; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> trafficLightState trafficLightStates[] = { {NONE, <span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-comment"><span class="hljs-comment">// clear yellow {RED, 7000}, // red {YELLOW, 2000}, // red + yellow {NONE, 1}, // clear red+yellow {GREEN, 7000}, // green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 1}, // clear green {YELLOW, 2000}, // yellow };</span></span></code> </pre> <br>  Actually the function that handles it all <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curStateIdx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> curStateTimeStamp = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Switch to a new state when time comes if(millis() - curStateTimeStamp &gt; (unsigned long)trafficLightStates[curStateIdx].duration) { curStateIdx++; curStateIdx %= ARRAY_SIZE(trafficLightStates); curStateTimeStamp = millis(); } switch(trafficLightStates[curStateIdx].state) { case NONE: clearPixels(); ws2811.sendLedData(); break; case RED: redTrafficLights(); break; case YELLOW: yellowTrafficLights(); break; case GREEN: greenTrafficLights(); break; default: break; } // Just waiting delay(10); }</span></span></code> </pre><br>  Upon reaching the specified time interval, the next traffic light mode is turned on and the time starts again. <br><br>  The last effect for which my imagination was enough is the stars.  5 random LEDs light up at random brightness and then fade out.  If one star goes out, the other will light up in a random place. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> numleds = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ledIndexes[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curVal[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> maxVal[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;numleds; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ledIndexes[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> led = rand() % (NUM_HW_PIXELS+<span class="hljs-number"><span class="hljs-number">1</span></span>); CRGB * leds = ws2811.getRGBData(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(leds[led].r == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ledIndexes[i] = led; maxVal[i] = rand() % (MAX_VAL<span class="hljs-number"><span class="hljs-number">-1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; curVal[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> led = ledIndexes[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] &lt; maxVal[i]) curVal[i]++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] == maxVal[i]) maxVal[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] == <span class="hljs-number"><span class="hljs-number">0</span></span> || --curVal[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) ledIndexes[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; setRgb(led<span class="hljs-number"><span class="hljs-number">-1</span></span>, curVal[i], curVal[i], curVal[i]); } } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">80</span></span>); }</code> </pre> <br>  Somewhere here the malicious bug crept in.  Sometimes the asterisks light up sharply, or vice versa go out sharply.  But honestly, I was too lazy to deal with it - it looks quite normal. <br><br>  It's time to think about saving battery.  I already gave the values ‚Äã‚Äãof consumption of this whole thing.  If you do not think about turning off the power, the LEDs will eat the battery in a couple of hours.  This function deals with power outages after 90 seconds of inactivity.  Initially it was 60 seconds, but with a real game, this was not enough, and 2 minutes was somehow long. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutdownOnTimeOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resetTimer = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> periodStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(periodStartTime == <span class="hljs-number"><span class="hljs-number">0</span></span> || resetTimer) { periodStartTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(millis() - periodStartTime &gt;= <span class="hljs-number"><span class="hljs-number">90000U</span></span>L) { periodStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; shutDown(); } }</code> </pre> <br>  Actually power off occurs so. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ clearPixels(); ws2811.sendLedData(); wdt_disable(); digitalWrite(POWER_EN_PIN, LOW); <span class="hljs-comment"><span class="hljs-comment">// No power after this point while(true) ; }</span></span></code> </pre> <br>  If the user presses the buttons, then the timer is reset.  After the set time has elapsed, the function sets the HOLD signal to zero, which is the PT1502 command to turn off the power.  Watchdog, by the way, also needs to be stopped, otherwise after 2 seconds it will wake up the system and turn on the power again. <br><br>  Finally, the main loop that starts it all <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// List of pointers to functions that serve different modes void (*Modes[])() = { rainbow, slidingRainbow, orangeBeacon, policeBeacon, trafficLights, stars, randomColorsFadeInOut }; void loop() { static uint8_t mode = eeprom_read_byte( (uint8_t*) 10 ); static bool waitingForBtnUp = false; static long btnPressTimeStamp; // Button switches mode if(digitalRead(BUTTON_PIN) == HIGH &amp;&amp; !waitingForBtnUp) { delay(20); if(digitalRead(BUTTON_PIN) == HIGH) { mode++; mode %= ARRAY_SIZE(Modes); // num modes clearPixels(); ws2811.sendLedData(); delay(1); eeprom_write_byte( (uint8_t*) 10, mode ); waitingForBtnUp = true; btnPressTimeStamp = millis(); shutdownOnTimeOut(true); } } // Shut down on long press over 5s if(digitalRead(BUTTON_PIN) == HIGH &amp;&amp; waitingForBtnUp &amp;&amp; millis() - btnPressTimeStamp &gt; 5000) shutDown(); // Detect button release if(digitalRead(BUTTON_PIN) == LOW &amp;&amp; waitingForBtnUp) waitingForBtnUp = false; // display LEDs according to current mode Modes[mode](); // pong shutdown timer shutdownOnTimeOut(); // Yes, we still alive wdt_reset(); }</span></span></code> </pre><br>  Pressing the button toggles modes and resets the auto off timer.  Depending on the current mode, one of the effect functions from the Modes list is launched.  The watchdog is also reset on each cycle. <br><br>  If a child, say, played in a police car and after 1.5 minutes the flasher turned off, then most likely after re-switching on the son will want to continue playing in the police car.  For this, the selected mode is stored in the EEPROM (cell number 10 is selected from the balda). <br><br>  Here is a video that shows how it all works. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5MLX1hc8Jz4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Bootloader </h2><br>  Almost everything is ready.  But there is one more thing that needs to be filed - a bootloader.  The fact is that the standard bootloader does not suit us. <br><br>  Firstly, when the power is turned on, it waits for as much as 6 seconds - perhaps the firmware will be poured into it.  Only after this control is transferred to the main firmware.  This is convenient at the development stage, but will be annoying in the finished device. <br><br>  And secondly, the standard bootloader does not know anything about the PT1502 chip, which would be nice to send the HOLD signal.  Without this signal, the microcircuit thinks that the microcontroller either did not start, or, on the contrary, wants to switch off.  And if so, then in a few milliseconds PT1502 will cut off the power to the entire circuit. <br><br>  The benefit to fix both problems is not difficult.  The digispark ATTiny85 uses <a href="https://github.com/micronucleus/micronucleus">a micronucleus loader</a> .  This bootloader is just enough to file for our needs.  It is only necessary to correct the corresponding defines in the configuration file. <br><br>  First of all, I copied the standard firmware \ configuration \ t85_default configuration into my own directory and already made all the changes in it.  So it will be in which case it is easy to roll back to the original bootloader. <br><br>  In the bootloaderconfig.h file there is a choice of the way to enter the bootloader.  From what is offered out of the box, nothing suits us, but the closest option is ENTRY_JUMPER.  In this embodiment, the entrance to the loader occurs only if a certain level appears on a certain pin (a jumper is closed on the board). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENTRYMODE ENTRY_JUMPER</span></span></code> </pre> <br>  We do not have a jumper, but there is a button on the leg of PB2.  Let the entrance to the bootloader occur if the power button is held for 5-7 seconds when the power is turned on.  But if you press and release, then the transition to the main firmware occurs immediately. <br><br>  We need to define 3 functions - initialization, deinitialization and actually checking, and whether it is time to enter the bootloader.  In the original, they are all simple and implemented by macros.  We will only be simple the first 2 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HOLD_PIN PB1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_PIN PB2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_PORT PORTB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_DDR DDRB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_INP PINB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bootLoaderInit() {JUMPER_DDR &amp;= ~_BV(JUMPER_PIN); JUMPER_DDR |= _BV(HOLD_PIN); JUMPER_PORT &amp;= ~_BV(JUMPER_PIN); JUMPER_PORT |= _BV(HOLD_PIN); _delay_ms(1);} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bootLoaderExit() {;}</span></span></code> </pre> <br>  bootLoaderInit () sets the pin of the button (JUMPER_PIN) to the input and turns off the suspender on it.  We already have a suspender on the board, and to the ground, and when we press the button on the pin, the opposite will be one.  At the same time, you can immediately configure the HOLD signal for output and put a unit on it ... <br><br>  For an explanation of bit arithmetic, go, for example, <a href="http://www.c-cpp.ru/books/bitovye-operatory">here</a> , and an understanding of the GPIO setting registers in AVR controllers can be found, for example, <a href="http://microtechnics.ru/mikrokontrollery-avr-gpio-porty-vvoda-vyvoda/">from here</a> . <br><br>  The bootLoaderExit () function is empty, since  the set configuration is quite suitable for the subsequent transition to the main firmware <br><br>  The bootLoaderStartCondition () function, which is responsible for entering the bootloader in the macro format, did not fit in anymore, and therefore became a full feature <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __ASSEMBLER__ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Bootloader condition is to hold the button for 5 seconds inline unsigned char bootLoaderStartCondition() { long int i; for(i=0; i&lt;10000000; i++) if( !(JUMPER_INP &amp; _BV(JUMPER_PIN))) return 0; return 1; } #endif</span></span></span></span></code> </pre> <br>  The function for a few seconds (in fact about 6-7) checks the status of the button.  If the button was released earlier, then we do not need to enter the bootloader.  Patient and persistent are allowed on to the bootloader. <br><br>  As it turned out, the bootloaderconfig.h file participates in the compilation of assembly files and the code in this file causes errors.  I had to put the function in the block #ifndef __ASSEMBLER__ <br><br>  Another parameter, which I corrected, tells the bootloader what to do if it was not connected to USB - to exit after one second.  The fact is that during the break-in, the son often pressed the button and inadvertently entered the bootloader.  I don‚Äôt know how miraculously, but if the bootloader didn‚Äôt see the USB connection, it could randomly overwrite some pages of memory.  Therefore, if there is no connection, we will simply go to the main program. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Define bootloader timeout value. * * The bootloader will only time out if a user program was loaded. * * AUTO_EXIT_NO_USB_MS The bootloader will exit after this delay if no USB is connected. * Set to 0 to disable * Adds ~6 bytes. * (This will wait for an USB SE0 reset from the host) * * All values are approx. in milliseconds */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AUTO_EXIT_NO_USB_MS 1000</span></span></code> </pre> <br>  We compile ... and we get an error that the code does not fit into the bootloader space allocated to it.  Since the flash memory in the controller is very small, the bootloader is squeezed to the maximum to leave more space for the main program.  But this is easily fixed in the Makefile.inc file following the instructions. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hexadecimal address for bootloader section to begin. To calculate the best value: # - make clean; make main.hex; ### output will list data: 2124 (or something like that) # - for the size of your device (8kb = 1024 * 8 = 8192) subtract above value 2124... = 6068 # - How many pages in is that? 6068 / 64 (tiny85 page size in bytes) = 94.8125 # - round that down to 94 - our new bootloader address is 94 * 64 = 6016, in hex = 1780 BOOTLOADER_ADDRESS = 1940</span></span></code> </pre> <br>  Then I just reduced the starting address of the bootloader one page (64 bytes), thereby increasing the space for the bootloader. <br><br>  For the rest, compiling and uploading a bootloader using the USBAsp programmer was not a problem. <br><br><h2>  Conclusion </h2><br>  It was a very interesting way from the prototype on the breadboard to the finished device.  It seems to look like an ordinary twinkler from a lesson on arduine, but in fact in the process of work I had to solve a whole bunch of interesting problems - here both the fight against consumption, and the choice of the element base, and the design of the case, and bringing to mind the firmware with the bootloader.  I sincerely hope that my experience will be useful to someone. <br><br>  Could it have been easier?  Sure you may.  I think everything could be done with a transistor.  Unfortunately <a href="http://easyelectronics.ru/vklyuchit-vyklyuchit-sxemy-upravleniya-pitaniem.html">,</a> I read <a href="http://easyelectronics.ru/vklyuchit-vyklyuchit-sxemy-upravleniya-pitaniem.html">this article</a> after soldering the board.  I would have seen the article earlier - I would have done everything on the very same TP4056 - it is easier to solder it.  Anyway, the DC-DC converter inside PT1502 is not needed for this device.  However, a practical study of the PT1502 chip is useful to me for my other project, as well as the ability to solder the chips in the QFN20 package. <br><br>  Finally, here are the links to my project: <br><br>  <a href="https://github.com/grafalex82/MagformersLED">Firmware code</a> <br>  <a href="https://easyeda.com/editor">Scheme and fee</a> <br>  <a href="https://cad.onshape.com/documents/db0b892b322747d7bc535bdc/v/fcce0f163beeab5202f6b8d5">Housing model and diffuser</a> <br>  <a href="https://www.thingiverse.com/thing:3335346">Ready STL models for printing</a> </div><p>Source: <a href="https://habr.com/ru/post/435198/">https://habr.com/ru/post/435198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435184/index.html">Artificial intelligence has learned to find Alzheimer's disease in the brain for 6 years before being diagnosed</a></li>
<li><a href="../435186/index.html">Rolls-Royce develops the fastest electric aircraft in the world</a></li>
<li><a href="../435190/index.html">Google managed to withdraw from taxation $ 22.7 billion through Ireland and Bermuda</a></li>
<li><a href="../435194/index.html">Simplify writing a resume developer</a></li>
<li><a href="../435196/index.html">Researchers pass ReCAPTCHA using Google services</a></li>
<li><a href="../435200/index.html">We are engaged in the automation of public Vkontakte</a></li>
<li><a href="../435202/index.html">We write our programming language, part 1: we write the language VM</a></li>
<li><a href="../435204/index.html">Reception for developers to overcome procrastination</a></li>
<li><a href="../435206/index.html">In Europe, approved the Copyright Directive - why streaming platforms oppose</a></li>
<li><a href="../435208/index.html">Internet of things ... that cry for good UI / UX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>