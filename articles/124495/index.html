<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mechanics of casual games</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At Habrahabr periodically attempts are made to describe the process of igrodelaniya from various sides - from the incarnation of 3D-graphics to the cr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mechanics of casual games</h1><div class="post__text post__text-html js-mediator-article">  At Habrahabr periodically attempts are made to describe the process of igrodelaniya from various sides - from the incarnation of 3D-graphics to the creation of network protocols.  These topics are certainly important, but rather narrow.  In this article I will try to use a wider approach - I will consider the <i>principle of</i> creating a game engine for a so-called.  casual games.  The described mechanics are quite suitable for creating all sorts of pakmanov, arkanoids, platformers, etc. The process description will be exemplified by a primitive scrolldown shooter (from nostalgic feelings to <a href="http://www.whitegames.ru/view_game.php%3Fid%3D103">Zybex</a> and <a href="http://game.met2tr.com/zx-spectrum-games-xevious-zx-spectrum.html">Xevious</a> ) - we fly around the field, knocking down meteorites.  Tool - Qt. <br><a name="habracut"></a><br>  Immediately make a reservation that there is no beauty and completeness in the code.  The classes are primitive and repeat the code, the functions are not optimal, the graphics are <s>ugly</s> , but it all puffs and turns.  This is a base from which to work further.  Experienced programmers - flipping through a cup of something hot, beginners or pouring into the subject will probably give food for thought.  Getting started. <br><br><h4>  Application cycle </h4><br>  In order to choose the right way to organize the program, you need to decide on the participants of the main cycle.  In any casual (and most non-casual) game, there are at least three of them: <br><ul><li>  Clock generator gameplay </li><li>  Continuity simulator </li><li>  Scene rendering </li></ul><br>  Other points are also possible - animation manager, artificial intelligence, etc. For example, these three are enough for us. <br><br>  What kind of participants are these? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>The clock of the gameplay</b> is tied to the timer ... uh ... the clock of the gameplay.  It controls the movement of objects on the playing field.  Its main purpose is to ensure the integrity of the gameplay and its <i>sameness</i> .  This is very important - not only to ensure that the speed of the game does not depend on the performance of the computer, but also to ensure synchronization when playing over the network. <br><br>  <b>The continuity simulator</b> is auxiliary functions, the main purpose of which is to ensure that nothing important happens between the calls of the game process generator.  For example, consider the following game moment: <br><img src="http://img534.imageshack.us/img534/3826/61773312.jpg" alt="image"><br><br>  To the left and to the right there are two consecutive calls of the clock generator of the game process.  Suppose that the speed of the yellow circle = 3. The distance between the circle and the rectangle, as can be seen from the figure, = 2. It turns out that the circle and the rectangle will not collide if they are not helped.  This help and provides simulator continuity. <br><br>  <b>Rendering the scene</b> - everything seems to be clear.  It is a separate item, because: <br><ul><li>  should not depend on the speed of the game process; </li><li>  must ensure the smoothness of the image (at an object speed = 10 points on the screen and a game frequency = 30, jerks of a moving object will be visible if the frames are rendered only when the game generator is called) </li></ul><br><h4>  Possible ways of organizing cycles </h4><br>  Immediately comes to mind the idea to make a separate thread for each of the participants.  However, this approach is not optimal, since: <br><ul><li>  does not provide default synchronization between loop members.  Suddenly you have to sacrifice rendering and animation for the sake of maintaining synchrony network battles? </li><li>  significantly complicates development and, as a result, increases the number of errors  Different threads = different resources, issues of synchronization and sharing, and other delights of multi-threaded programs. </li></ul><br>  Therefore, we will do the threads, but somewhat differently - a separate thread for processing messages from the OS (drawing, polling the keyboard), and a separate thread for the gameplay, in which all three participants are called. <br>  With drawing and polling the keyboard, everything is clear - it's just a stream of the main form of the application.  We will deal with the flow of gameplay. <br><br><h4>  Gameplay flow </h4><br>  The flow structure is shown in the figure: <br><img src="http://img35.imageshack.us/img35/4256/15993442.jpg" alt="image"><br><br>  Now a little code with explanations. <br>  To begin, set the frequency.  Roughly speaking, how many ms should pass between calls for processing logic, rendering: <br><blockquote>  <font color="black"><a href="http://s-c.me/22429/s">Copy Source</a> |</font>  <font color="black"><a href="http://s-c.me/22429/h">Copy HTML</a></font> <ol><li>  // Clock Generator: FREQ - Logic, FPS - Rendering </li><li>  const <font color="#0000ff">int</font> FREQ = 1000/40;  // 1000 / FPS </li><li>  const <font color="#0000ff">int</font> MAX_FPS = 1000/180; </li></ol></blockquote><br><br>  But the code of the main loop - with the call of all participants, checks on time, etc. <br><blockquote>  <font color="black"><a href="http://s-c.me/22428/s">Copy Source</a> |</font>  <font color="black"><a href="http://s-c.me/22428/h">Copy HTML</a></font> <ol><li>  while ( <font color="#008000">true</font> ) </li><li>  { </li><li>  qint64 time_cur_tick = QDateTime :: currentMSecsSinceEpoch (); </li><li>  int numLoops = <font color="#0000ff">0</font> ; </li><li></li><li>  bool ft = true; </li><li>  while ( <font color="#008000">time_prev_tick &lt;time_cur_tick &amp;&amp; numLoops &lt;MAX_LOOPS</font> ) </li><li>  { </li><li>  <font color="#008000">// call logic</font> </li><li>  w-&gt; UpdateLogic ( <font color="#008000">1 / FREQ</font> ); </li><li>  numLoops ++; </li><li></li><li>  if ( <font color="#008000">ft</font> ) </li><li>  { </li><li>  ft = false; </li><li>  last_freq = time_cur_tick; </li><li>  } </li><li>  time_prev_tick + = FREQ; </li><li></li><li>  <font color="#008000">// Update time_cur_tick for more accurate clocking</font> </li><li>  time_cur_tick = QDateTime :: currentMSecsSinceEpoch (); </li><li>  } </li><li></li><li>  time_tmp = QDateTime :: currentMSecsSinceEpoch (); </li><li>  w-&gt; SimulateConsistLogic ( <font color="#008000">(float</font> ) ( <font color="#008000">time_tmp - last_freq</font> ) / FREQ); </li><li></li><li>  time_tmp = QDateTime :: currentMSecsSinceEpoch (); </li><li>  if ( <font color="#008000">time_tmp - time_lastrender&gt; = MAX_FPS &amp;&amp;</font> <br>  <font color="#008000">w-&gt; paint_mx.tryLock (</font> )) </li><li>  { </li><li>  time_lastrender = time_tmp; </li><li>  <font color="#ff0000">float</font> freq_bit = <font color="#0000ff">0</font> ; </li><li>  if ( <font color="#008000">time_tmp! = last_freq</font> ) </li><li>  freq_bit = ( <font color="#008000">float</font> ) ( <font color="#008000">time_tmp - last_freq</font> ) / FREQ; </li><li></li><li>  emit signalGUI ( <font color="#008000">freq_bit</font> ); </li><li>  w-&gt; paint_mx.unlock (); </li><li>  } </li><li>  } </li></ol></blockquote><br><br>  <i>(note - if you look at the source code - everything is a bit more complicated there. There is counting frames per second, displaying debug information, etc.)</i> <br><br>  Surely the question arose - why the rendering functions and the continuity simulator know the time that has passed since the last update of the game logic?  Everything is simple - in order to calculate the instantaneous state of the scene, and correctly process it and display it on the screen.  To save resources, calling the continuity simulator can also transfer the time of its last call. <br><br><h4>  How it all works </h4><br>  In our example, three types of objects: <br><ul><li>  player ship </li><li>  bullets </li><li>  meteorites </li></ul><br>  For them the corresponding classes (CShip, CBullet, CMeteorite) are made  For bullets and meteorites, QVector storage containers are specified. <br>  To handle user input, an array of ‚Äúdriving directions‚Äù has been created and the keyReleaseEvent and keyPressEvent functions have been redefined: <br>  keyReleaseEvent checks whether the array of keystrokes contains a released key, and deletes it if present. <br>  keyPressEvent accordingly puts the pressed key into the array of the pressed keys (if it is not there).  Processing of this array occurs as a function of the clock generator of the game.  In the same place there are movements of game objects, calculation of inertia when the ship is moving, the creation of meteorites: <br><blockquote>  <font color="black"><a href="http://s-c.me/22435/s">Copy Source</a> |</font>  <font color="black"><a href="http://s-c.me/22435/h">Copy HTML</a></font> <ol><li>  void MainWindow :: UpdateLogic ( <font color="#008000">float ftime</font> ) </li><li>  { </li><li>  <font color="#ff0000">float</font> speed = <font color="#0000ff">2</font> ; </li><li>  for ( <font color="#008000">int i = 0; i &lt;m_dir.size (</font> ); <font color="#A31515">i</font> ++) </li><li>  { </li><li>  if ( <font color="#008000">m_dir [i] == MainWindow :: UP</font> ) </li><li>  actor1.adjust <font color="#ff0000">Direction</font> ( <font color="#008000">QVector2D (0, -speed</font> )); </li><li>  if ( <font color="#008000">m_dir [i] == MainWindow :: DOWN</font> ) </li><li>  actor1.adjust <font color="#ff0000">Direction</font> ( <font color="#008000">QVector2D (0, speed</font> )); </li><li>  if ( <font color="#008000">m_dir [i] == MainWindow :: LEFT</font> ) </li><li>  actor1.adjust <font color="#ff0000">Direction</font> ( <font color="#008000">QVector2D (-speed, 0</font> )); </li><li>  if ( <font color="#008000">m_dir [i] == MainWindow :: RIGHT</font> ) </li><li>  actor1.adjust <font color="#ff0000">Direction</font> ( <font color="#008000">QVector2D (speed, 0</font> )); </li><li></li><li>  if ( <font color="#008000">m_dir [i] == MainWindow :: SPACE &amp;&amp;</font> <br>  <font color="#008000">m_allowbullet == 0</font> ) </li><li>  { </li><li>  m_bullets.push_back ( <font color="#008000">CBullet (actor1.getX (</font> ), actor1.getY () - <font color="#0000ff">1</font> , QVector2D ( <font color="#008000">0, -15</font> ))); </li><li>  qDebug ( <font color="#008000">QString (‚ÄúAdded bullet. Pos% 1‚Äù</font> ) .arg ( <font color="#008000">m_bullets.size (</font> ) - <font color="#0000ff">1</font> ) .toAscii ()); </li><li>  m_allowbullet = <font color="#0000ff">5</font> ; </li><li>  fired ++; </li><li>  } </li><li>  } </li><li>  actor1.step <font color="#ff0000">Direction</font> (); </li><li>  bool dir_touched = false; </li><li>  for ( <font color="#008000">int i = 0; i &lt;m_dir.size (</font> ); <font color="#A31515">i</font> ++) </li><li>  { </li><li>  if ( <font color="#008000">m_dir [i]! = MainWindow :: SPACE</font> ) </li><li>  { </li><li>  dir_touched = true; </li><li>  break; </li><li>  } </li><li>  } </li><li></li><li>  if ( <font color="#008000">! dir_touched</font> ) </li><li>  { </li><li>  m_allowmove = <font color="#0000ff">0</font> ; </li><li>  <font color="#ff0000">float</font> inertia = <font color="#0000ff">0</font> .  <font color="#0000ff">5</font> ; </li><li>  if ( <font color="#008000">actor1.getSpeed ‚Äã‚Äã(</font> ) &lt; <font color="#0000ff">0</font> . <font color="#0000ff">5</font> ) </li><li>  inertia = <font color="#0000ff">1</font> ; </li><li>  actor1.adjustSpeed ‚Äã‚Äã( <font color="#008000">inertia</font> ); </li><li>  } </li><li></li><li></li><li>  for ( <font color="#008000">int i = 0; i &lt;m_bullets.size (</font> ); <font color="#A31515">i</font> ++) </li><li>  m_bullets [ <font color="#A31515">i</font> ] .step <font color="#ff0000">Direction</font> (); </li><li></li><li>  for ( <font color="#008000">int x = 0; x &lt;m_enemies1.size (</font> ); x ++) </li><li>  m_enemies1 [x] .step <font color="#ff0000">Direction</font> (); </li><li></li><li>  CheckGameRules (); </li><li>  if ( <font color="#008000">m_enemies1.size (</font> ) &lt;max_enemies) </li><li>  { </li><li>  CMeteorite meteo ( <font color="#008000">mrand (field_ident + CMeteorite :: meteo_size,</font> <br>  <font color="#008000">field_ident + field_w - CMeteorite :: meteo_size</font> ), </li><li>  -mrand ( <font color="#008000">0, 20</font> ), </li><li>  QVector2D ( <font color="#008000">0, 1</font> )); </li><li>  while ( <font color="#008000">true</font> ) </li><li>  { </li><li>  int <font color="#A31515">i</font> = <font color="#0000ff">0</font> ; </li><li>  while ( <font color="#008000">i &lt;m_enemies1.size (</font> )) </li><li>  { </li><li>  if ( <font color="#008000">meteo.getBoundsT (</font> ) .intersects ( <font color="#008000">m_enemies1 [i] .getBoundsT (</font> ))) </li><li>  break; </li><li></li><li>  <font color="#A31515">i</font> ++; </li><li>  } </li><li></li><li>  if ( <font color="#008000">i == m_enemies1.size (</font> )) </li><li>  break; </li><li></li><li>  meteo = CMeteorite ( <font color="#008000">mrand (1, 100</font> ), -mrand ( <font color="#008000">0, 20</font> ), </li><li>  QVector2D ( <font color="#008000">0, 1</font> )); </li><li></li><li>  } </li><li>  m_enemies1.push_back ( <font color="#008000">meteo</font> ); </li><li>  } </li><li>  UpdateBullet (); </li><li>  } </li></ol></blockquote><br>  The CheckGameRules function checks the game rules - who crashed into whom, who went beyond what, and so on.  By the way, in 2D this is all <u><i>very</i></u> conveniently done by the functions of the QPolygon, QRect classes and their ilk. <br><br><blockquote>  <font color="black"><a href="http://s-c.me/22432/s">Copy Source</a> |</font>  <font color="black"><a href="http://s-c.me/22432/h">Copy HTML</a></font> <ol><li>  void MainWindow :: CheckGameRules ( <font color="#008000">const float ftime</font> ) </li><li>  { </li><li>  QRect field_rect ( <font color="#008000">field_ident, field_ident,</font> <br>  <font color="#008000">field_w,</font> <br>  <font color="#008000">field_h</font> ); </li><li></li><li>  for ( <font color="#008000">int i = 0; i &lt;m_bullets.size (</font> ); <font color="#A31515">i</font> ++) </li><li>  { </li><li>  CBullet blt = m_bullets [ <font color="#A31515">i</font> ]; </li><li>  <font color="#ff0000">float</font> tx = <font color="#0000ff">0</font> , ty = <font color="#0000ff">0</font> ; </li><li>  blt.getTickCoords ( <font color="#008000">ftime, tx, ty</font> ); </li><li></li><li>  blt.setX ( <font color="#008000">tx</font> ); </li><li>  blt.setY ( <font color="#008000">ty</font> ); </li><li></li><li>  if ( <font color="#008000">! field_rect.contains (m_bullets [i] .getX (</font> ), m_bullets [ <font color="#A31515">i</font> ] .getY ())) </li><li>  { </li><li>  m_bullets.remove ( <font color="#008000">i--</font> ); </li><li>  } </li><li>  else </li><li>  { </li><li>  for ( <font color="#008000">int j = 0; j &lt;m_enemies1.size (</font> ); j ++) </li><li>  { </li><li>  CMeteorite enm = m_enemies1 [j]; </li><li>  <font color="#ff0000">float</font> etx = <font color="#0000ff">0</font> , ety = <font color="#0000ff">0</font> ; </li><li>  enm.getTickCoords ( <font color="#008000">ftime, etx, ety</font> ); </li><li>  enm.setX ( <font color="#008000">etx</font> ); </li><li>  enm.setY ( <font color="#008000">ety</font> ); </li><li></li><li>  if ( <font color="#008000">blt.checkCollision (enm.getBodyT (</font> ))) </li><li>  { </li><li>  m_enemies1.remove ( <font color="#008000">j--</font> ); </li><li>  m_bullets.remove ( <font color="#008000">i--</font> ); </li><li>  score ++; </li><li>  break; </li><li>  } </li><li>  } <font color="#008000">// for</font> </li><li>  } </li><li>  } </li><li></li><li>  for ( <font color="#008000">int j = 0; j &lt;m_enemies1.size (</font> ); j ++) </li><li>  { </li><li></li><li>  CMeteorite enm = m_enemies1 [j]; </li><li>  if ( <font color="#008000">! field_rect.contains (enm.getBoundsT (</font> )) &amp;&amp; </li><li>  field_rect.  <font color="#ff0000">bottomRight</font> () .y () &lt;enm.getBoundsT ().  <font color="#ff0000">topLeft</font> () .y ()) </li><li>  { </li><li>  m_enemies1.remove ( <font color="#008000">j--</font> ); </li><li>  } </li><li></li><li>  if ( <font color="#008000">actor1.checkCollision (enm.getBodyT (</font> ))) </li><li>  { </li><li>  m_enemies1.remove ( <font color="#008000">j--</font> ); </li><li>  hits ++; </li><li>  } </li><li>  } </li><li></li><li></li><li>  if ( <font color="#008000">! field_rect.contains (actor1.getBoundsT (</font> ), true)) </li><li>  { </li><li>  while ( <font color="#008000">field_rect.x (</font> )&gt; = actor1.getBoundsT (). <font color="#ff0000">left</font> ()) </li><li>  actor1.setX ( <font color="#008000">actor1.getX (</font> ) + <font color="#0000ff">1</font> ); </li><li></li><li> while ( <font color="#008000">field_rect.x (</font> ) * <font color="#0000ff">2</font> + field_rect. <font color="#ff0000">width</font> () &lt;= actor1.getBoundsT (). x () + actor1.getBoundsT (). <font color="#ff0000">width</font> ()) </li><li>  actor1.setX ( <font color="#008000">actor1.getX (</font> ) - <font color="#0000ff">1</font> ); </li><li></li><li>  while ( <font color="#008000">field_rect.top (</font> )&gt; = actor1.getBoundsT (). <font color="#ff0000">top</font> ()) </li><li>  actor1.setY ( <font color="#008000">actor1.getY (</font> ) + <font color="#0000ff">1</font> ); </li><li></li><li>  while ( <font color="#008000">field_rect.y (</font> ) * <font color="#0000ff">2</font> + field_rect. <font color="#ff0000">height</font> () &lt;= actor1.getBoundsT (). y () + actor1.getBoundsT (). <font color="#ff0000">height</font> ()) </li><li>  actor1.setY ( <font color="#008000">actor1.getY (</font> ) - <font color="#0000ff">1</font> ); </li><li></li><li>  actor1.s <font color="#ff0000">top</font> (); </li><li></li><li>  } </li><li>  } </li></ol></blockquote><br><br>  Accordingly, the call simulator continuity is simple to ugliness.  With only a small step, we check the game logic: <br><blockquote>  <font color="black"><a href="http://s-c.me/22433/s">Copy Source</a> |</font>  <font color="black"><a href="http://s-c.me/22433/h">Copy HTML</a></font> <ol><li>  void MainWindow :: SimulateConsistLogic ( <font color="#008000">float ftime</font> ) </li><li>  { </li><li>  for ( <font color="#008000">float bt = 0; bt &lt;ftime; bt = bt + 0.1</font> ) </li><li>  { </li><li>  CheckGameRules ( <font color="#008000">bt</font> ); </li><li>  } </li><li>  } </li></ol></blockquote><br><br>  Rendering renders the playing field and calls Draw () of all objects with the parameter of the current offset from the last call of the clock generator of the game process.  Plus the output of service information: <br><blockquote>  <font color="black"><a href="http://s-c.me/22434/s">Copy Source</a> |</font>  <font color="black"><a href="http://s-c.me/22434/h">Copy HTML</a></font> <ol><li>  void MainWindow :: Render () </li><li>  { </li><li>  QPainter qpainter ( <font color="#008000">this</font> ); </li><li></li><li>  const int bgw = <font color="#0000ff">2</font> ; </li><li>  qpainter.setPen ( <font color="#008000">QPen (Qt :: black, bgw</font> )); </li><li>  qpainter.setBrush ( <font color="#008000">QBrush (Qt :: darkGray</font> )); </li><li>  qpainter.drawRect ( <font color="#008000">field_ident, field_ident,</font> <br>  <font color="#008000">field_w + field_ident,</font> <br>  <font color="#008000">field_h + field_ident</font> ); </li><li></li><li></li><li>  for ( <font color="#008000">int i = 0; i &lt;m_bullets.size (</font> ); <font color="#A31515">i</font> ++) </li><li>  { </li><li>  CBullet blt = m_bullets [ <font color="#A31515">i</font> ]; </li><li>  blt.Draw ( <font color="#008000">qpainter, freq_bit</font> ); </li><li>  } </li><li></li><li>  for ( <font color="#008000">int i = 0; i &lt;m_enemies1.size (</font> ); <font color="#A31515">i</font> ++) </li><li>  { </li><li>  CMeteorite enm = m_enemies1 [ <font color="#A31515">i</font> ]; </li><li>  enm.Draw ( <font color="#008000">qpainter, freq_bit</font> ); </li><li>  } </li><li></li><li>  actor1.Draw ( <font color="#008000">qpainter, freq_bit</font> ); </li><li></li><li>  QPalette pal; </li><li>  qpainter.setBrush ( <font color="#008000">pal.brush (QPalette :: Window</font> )); </li><li>  qpainter.setPen ( <font color="#008000">QPen (pal.color (QPalette :: Window</font> ), <font color="#0000ff">1</font> )); </li><li>  qpainter.drawRect ( <font color="#008000">field_ident - bgw / 2, 0,</font> <br>  <font color="#008000">field_w + field_ident + bgw / 2,</font> <br>  <font color="#008000">field_ident - bgw</font> ); </li><li></li><li>  qpainter.setPen ( <font color="#008000">QPen (Qt :: black, bgw</font> )); </li><li>  qpainter.setBrush ( <font color="#008000">QBrush (Qt :: darkGray, Qt :: NoBrush</font> )); </li><li>  qpainter.drawRect ( <font color="#008000">field_ident, field_ident,</font> <br>  <font color="#008000">field_w + field_ident,</font> <br>  <font color="#008000">field_h + field_ident</font> ); </li><li></li><li>  ui-&gt; label_freq-&gt; setText ( <font color="#008000">QString ("% 1"</font> ) .arg ( <font color="#008000">freq</font> ) .toAscii ()); </li><li>  ui-&gt; label_fps-&gt; setText ( <font color="#008000">QString ("% 1"</font> ) .arg ( <font color="#008000">fps</font> ) .toAscii ()); </li><li>  ui-&gt; label_speed-&gt; setText ( <font color="#008000">QString ("% 1"</font> ) .arg ( <font color="#008000">actor1.getSpeed ‚Äã‚Äã(</font> )) .toAscii ()); </li><li></li><li>  ui-&gt; label_score-&gt; setText ( <font color="#008000">QString ("% 1"</font> ) .arg ( <font color="#008000">score</font> ) .toAscii ()); </li><li>  ui-&gt; label_fired-&gt; setText ( <font color="#008000">QString ("% 1"</font> ) .arg ( <font color="#008000">fired</font> ) .toAscii ()); </li><li>  ui-&gt; label_hits-&gt; setText ( <font color="#008000">QString ("% 1"</font> ) .arg ( <font color="#008000">hits</font> ) .toAscii ()); </li><li></li><li>  } </li></ol></blockquote><br><br>  Actually, the rest is trivial programming.  The skeleton of the application is disassembled, and the implementation details can be viewed in the attached source codes.  As a result - the appearance of what I got: <br><img src="http://img94.imageshack.us/img94/6756/43066921.jpg" alt="image"><br>  Sources <a href="http://rghost.ru/15143731">here</a> .  We fly by arrows, we shoot with space. <br>  <a href="https://github.com/cookierama/game">Sources on githaba</a> . </div><p>Source: <a href="https://habr.com/ru/post/124495/">https://habr.com/ru/post/124495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../124484/index.html">Processes and threads in Android: we write AsyncTask correctly</a></li>
<li><a href="../124486/index.html">Rent textbooks with Amazon</a></li>
<li><a href="../124491/index.html">Remote mouse control using .NET Remoting</a></li>
<li><a href="../124492/index.html">Correct setting DDoS Deflate</a></li>
<li><a href="../124493/index.html">Truecrypt collects $ 150,000, but why?</a></li>
<li><a href="../124496/index.html">Search by torrents in the DHT network</a></li>
<li><a href="../124499/index.html">W3C Digest. What's new in CSS3. Release 2</a></li>
<li><a href="../124501/index.html">7 ways to budget training for testers</a></li>
<li><a href="../124503/index.html">Lecture "Introduction to SilverLight"</a></li>
<li><a href="../124505/index.html">GitHub Reflog v1.7.19</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>