<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What brings the idea (Objective-C) - target-action on the blocks and a lot of runtime</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="An idea came to me somehow, is it possible to take a block and give it to target-action? 
 There are ready-made solutions, like BlocksKit and other li...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What brings the idea (Objective-C) - target-action on the blocks and a lot of runtime</h1><div class="post__text post__text-html js-mediator-article">  An idea came to me somehow, is it possible to take a block and give it to target-action? <br>  There are ready-made solutions, like <a href="https://github.com/zwaldowski/BlocksKit">BlocksKit</a> and other libraries, for example, but their solution is to save the block, install the target and call the block from the specified selector. <br><br>  Why, then, need this article? <br><br>  I wanted to create a way to generate a selector, which will be called block.  What is difficult here, you say?  imp_implementationWithBlock + class_addMethod and the case is closed.  But with this approach, there is one serious requirement; this is the first argument of the block ‚Äî the owner of the method. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      How to get around this requirement and do this? <br><pre><code class="objectivec hljs">[button addTarget:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> action:[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ax_lambda:^(<span class="hljs-built_in"><span class="hljs-built_in">UIButton</span></span> *sender, <span class="hljs-built_in"><span class="hljs-built_in">UIEvent</span></span> *event){ <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"click on button %@, event = %@"</span></span>, sender, event); }] forControlEvents:<span class="hljs-built_in"><span class="hljs-built_in">UIControlEventTouchUpInside</span></span>]; [button addTarget:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> action:[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ax_lambda:^{ <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"click"</span></span>); }] forControlEvents:<span class="hljs-built_in"><span class="hljs-built_in">UIControlEventTouchUpInside</span></span>];</code> </pre> <br>  Or even like this <br><pre> <code class="objectivec hljs"> __block <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> performSelector:[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ax_lambda:^(<span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> *argA, <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> *argB) { sum = [argA integerValue] + [argB integerValue]; }] withObject:@(<span class="hljs-number"><span class="hljs-number">2</span></span>) withObject:@(<span class="hljs-number"><span class="hljs-number">3</span></span>)]; <span class="hljs-comment"><span class="hljs-comment">//sum ‚Äî 5 SEL selSum = [self ax_lambda:^NSInteger(NSInteger argA, NSInteger argB){ return argA + argB; }]; NSInteger(*funcSum)(id, SEL, NSInteger, NSInteger) = (NSInteger(*)(id, SEL, NSInteger, NSInteger))objc_msgSend; NSInteger sum2 = funcSum(self, selSum, 2, 3); //sum2 ‚Äî 5</span></span></code> </pre><br>  The implementation was so interesting that I decided to write about it. <br><a name="habracut"></a><br>  In essence, the main task is to get rid of the first self argument in the block call.  This is the root problem of the entire solution (it is a pity that it is not the only one). <br>  Earlier, I already wrote a little <a href="https://habrahabr.ru/post/271255/">about blocks</a> , and noted that a block is an object, which means the call will occur through NSInvocation. <br>  If I get the moment of calling the block and remove the argument self (by shifting the arguments) in NSInvocation, then I will get the desired result. <br><br>  Further it will be necessary to understand along the way. <br><br><br><h2>  AXProxyBlock </h2><br>  The question is how to break in at the time of the block call?  How to get a block call at all? <br>  Very often I write this phrase, but a block is an object.  The object in the objc in the final form is a structure.  Once id is a pointer to a structure, the opposite is allowed <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">(__bridge, hello)</a> . <br>  It turns out, you can create a fake unit.  Well, or a proxy for the block. <br><br><div class="spoiler">  <b class="spoiler_title">The interface of my class is the following:</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(^AXProxyBlockInterpose)(<span class="hljs-built_in"><span class="hljs-built_in">NSInvocation</span></span> *invocation); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AXProxyBlock</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSProxy</span></span></span><span class="hljs-class"> + (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">instancetype</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initWithBlock</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">block</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setBeforeInvoke</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AXProxyBlockInterpose</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">beforeInvoke</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSString</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blockSignatureStringCTypes</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br></div></div><br><br>  As you can guess, setBeforeInvoke takes a block in which you can do "magic" transformations of block arguments. <br>  blockSignatureStringCTypes returns the signature of the proxied block.  Why is it in the header file?  About this later. <br><br>  <a href="http://clang.llvm.org/docs/Block-ABI-Apple.html">link to the documentation page that is about to begin</a> <br><br><div class="spoiler">  <b class="spoiler_title">To get started on the documentation, we will create block structures and a listing with our names.</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> AXBlockStruct_1 { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reserved; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*copy_helper)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *dst, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *src); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*dispose_helper)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *src); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *signature; } AXBlockStruct_1; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> AXBlockStruct { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *isa; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> flags; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reserved; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*invoke)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *, ...); <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> AXBlockStruct_1 *descriptor; } AXBlockStruct; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NS_ENUM</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>, AXBlockFlag) { AXBlockFlag_HasCopyDispose = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">25</span></span>), AXBlockFlag_HasCtor = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">26</span></span>), AXBlockFlag_IsGlobal = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">28</span></span>), AXBlockFlag_HasStret = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">29</span></span>), AXBlockFlag_HasSignature = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">30</span></span>) };</code> </pre></div></div><br><br>  And now let's do our class. <br><div class="spoiler">  <b class="spoiler_title">You need to make the appropriate structure:</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AXProxyBlock</span></span></span><span class="hljs-class"> () </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// isa      NSProxy,     int _flags; int _reserved; IMP _invoke; AXBlockStruct_1 *_descriptor; // ,    ,     AXProxyBlockInterpose _beforeInvoke; id _block; NSMethodSignature *_blockMethodSignature; IMP _impBlockInvoke; } @end</span></span></code> </pre></div></div><br><br>  Now it is necessary that at the time of the call the class imitated the received block: <br><div class="spoiler">  <b class="spoiler_title">Matching Field Values</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">instancetype</span></span>)initWithBlock:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)block { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { AXBlockStruct *blockRef = (__bridge AXBlockStruct *)block; _flags = blockRef-&gt;flags; _reserved = blockRef-&gt;reserved; _descriptor = calloc(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(AXBlockStruct_1)); _descriptor-&gt;size = class_getInstanceSize([<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> flag_stret = _flags &amp; AXBlockFlag_HasStret; _invoke = (flag_stret ? (IMP)_objc_msgForward_stret : (IMP)_objc_msgForward); ...</code> </pre></div></div><br><br>  Description of the purpose of these fields can be read all on the same <a href="http://clang.llvm.org/docs/Block-ABI-Apple.html">page of the clang documentation</a> .  Now the fields correspond to the block at the time of the call. <br><br>  But I have 2 very important ivar, which I did not turn on under the spoiler above, since they already relate to the call of the block and I want to stop on them in more detail. <br><br><pre> <code class="objectivec hljs"> _impBlockInvoke = (IMP)blockRef-&gt;invoke; _blockMethodSignature = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> blockMethodSignature];</code> </pre><br><br>  _impBlockInvoke is a function of block calling, implementation.  This is a normal function pointer and can be called up by hand. <br>  _blockMethodSignature is a block signature method.  What it is will be discussed in great detail later. <br><br><div class="spoiler">  <b class="spoiler_title">How to get NSMethodSignature for a block</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSMethodSignature</span></span> *)blockMethodSignature { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *signature = [[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> blockSignatureStringCTypes] UTF8String]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">NSMethodSignature</span></span> signatureWithObjCTypes:signature]; } - (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)blockSignatureStringCTypes { AXBlockStruct *blockRef = (__bridge AXBlockStruct *)_block; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> flags = blockRef-&gt;flags; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *signatureLocation = blockRef-&gt;descriptor; signatureLocation += <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); signatureLocation += <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; AXBlockFlag_HasCopyDispose) { signatureLocation += <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(*)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *dst, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *src)); signatureLocation += <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *src)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *signature = (*(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)signatureLocation); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> stringWithUTF8String:signature]; }</code> </pre><br></div></div><br><br>  We take our block, we get a descriptor from it, then we shift by the required amount to get the block signature (const char *) and create an NSMethodSignature through it.  NSMethodSignature determines the number and types of arguments, the return value, and so on. <br>  It looks not difficult, but the manipulations with the flag are confused: depending on the type of block, its signature may be located differently.  For example, the global block does not need to shift beyond the functions of copying and destruction. <br><br>  My class doesn‚Äôt have a method to call the block, it means that forwardInvocation will be called, and before it you need to know what type of NSInvocation will be formed, so the methodSignatureForSelector is called, in which we give our _blockMethodSignature. <br><br><div class="spoiler">  <b class="spoiler_title">forwardInvocation</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)forwardInvocation:(<span class="hljs-built_in"><span class="hljs-built_in">NSInvocation</span></span> *)anInvocation { [anInvocation setTarget:_block]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_beforeInvoke) { _beforeInvoke(anInvocation); } IMP imp = _impBlockInvoke; [anInvocation invokeUsingIMP:imp]; }</code> </pre></div></div><br>  The code here should be very clear (set a new target for a call, called a block before if exists), but where is the call [anInvocation invoke] ?! <br>  This is black magic.  The invokeUsingIMP method is a <a href="https://github.com/nst/iOS-Runtime-Headers">private API that can be found here, as well as a lot of other things.</a> <br><br><br><h2>  Putting the puzzle to continue </h2><br>  I think that the blocking of the material is peculiar, and if you go straight to solving the second half of the problem, fewer people read the article.  Therefore, now the wrapper will be glimpsed as picking up a puzzle of ready-made solutions and in the end the second half of the task will be dealt with.  This will allow you to relax a little and gather material in a more structured way. <br><br>  Let's talk about the method that was called at the very beginning of the article - ax_lambda.  This is just a category for NSObject, it is a wrapper for calling the main function, which looks like this: <br><pre> <code class="objectivec hljs">SEL ax_lambda(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> obj, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> block, <span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> *lambdas);</code> </pre><br>  I think now it becomes clearer what the wrapper was written for.  And if the first and second argument does not cause questions, then the third makes you wonder.  First, I will talk about the need for a third argument, and then I will give a category code for the spoilers. <br><br><pre> <code class="objectivec hljs">SEL ax_lambda(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> obj, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> block, <span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> *lambdas) { SEL selector = ax_generateFreeSelector(obj); AXProxyBlockWithSelf *proxyBlock = [AXProxyBlockWithSelf initWithBlock:block]; [proxyBlock setBeforeInvoke:^(<span class="hljs-built_in"><span class="hljs-built_in">NSInvocation</span></span> *invocation){ ax_offsetArgInInvocation(invocation); }]; [lambdas addObject:proxyBlock]; IMP imp = imp_implementationWithBlock(proxyBlock); <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *signatureString = [proxyBlock blockSignatureStringCTypes]; class_addMethod([obj <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>], selector, imp, [signatureString UTF8String]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> selector; }</code> </pre><br>  This is the main function, the very assembled puzzle.  The class AXProxyBlockWithSelf will be discussed further, so far I will only note that this is a descendant of the class AXProxyBlock, as you probably guessed. <br>  To make a block with a method, a selector, implementation and string signature are required.  The implementation will be obtained from the proxy block, the proxy will also give the string signature (in AXProxyBlock it is the signature of the block being proxied, but in AXProxyBlockWithSelf it is different and this will be discussed later), well, the selector is not difficult to generate.  So why the third parameter? <br><br>  Calling imp_implementationWithBlock will cause a block to be copied (Block_copy).  The copy_helper field in the block is a pointer to the block copy function.  However, the block proxy does not have this capability.  Even if I create a copy function of the form void (*) (void * dst, void * src), I cannot get the desired result.  The object to be copied will come to src and it will not be an instance of my class.  Therefore, calling imp_implementationWithBlock does not increase the reference count for the proxyBlock object (and proxyBlock will be destroyed after the function is completed).  To prevent this, I use a collection that will increase the internal reference count.  It turns out the lifetime of the block depends on the lifetime of the collection storing it.  In the case of a category, the unit‚Äôs lifetime is limited to the owner‚Äôs lifetime. <br><br><div class="spoiler">  <b class="spoiler_title">AXLambda.h</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">SEL ax_lambda(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> obj, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> block, <span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> *lambdas); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AX_Lambda</span></span></span><span class="hljs-class">) - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SEL</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ax_lambda</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">block</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">AXLambda.m</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> kAX_NSObjectAssociatedObjectKey; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_AX_Lambda</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">copy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSMutableArray</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ax_lambdas</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_AX_Lambda</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dynamic</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ax_lambdas</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setAx_lambdas</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSMutableArray</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lambdas</span></span></span><span class="hljs-class"> </span></span>{ objc_setAssociatedObject(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, &amp;kAX_NSObjectAssociatedObjectKey, lambdas, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } - (<span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> *)ax_lambdas { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> *marrey = objc_getAssociatedObject(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, &amp;kAX_NSObjectAssociatedObjectKey); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (marrey == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ax_lambdas = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> array]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> objc_getAssociatedObject(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, &amp;kAX_NSObjectAssociatedObjectKey); } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AX_Lambda</span></span></span><span class="hljs-class">) - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SEL</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ax_lambda</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">block</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ax_lambda(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, block, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ax_lambdas); } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre><br></div></div><br><br>  Well, the functions used in SEL ax_lambda (id obj, id block, NSMutableArray * lambdas); <br><div class="spoiler">  <b class="spoiler_title">SEL ax_generateFreeSelector (id obj)</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">SEL ax_generateFreeSelector(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> obj) { SEL selector; <span class="hljs-built_in"><span class="hljs-built_in">NSMutableString</span></span> *mstring = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableString</span></span> string]; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { [mstring setString:<span class="hljs-string"><span class="hljs-string">@"ax_rundom_selector"</span></span>]; u_int32_t rand = arc4random_uniform(<span class="hljs-built_in"><span class="hljs-built_in">UINT32_MAX</span></span>); [mstring appendFormat:<span class="hljs-string"><span class="hljs-string">@"%zd"</span></span>, rand]; selector = <span class="hljs-built_in"><span class="hljs-built_in">NSSelectorFromString</span></span>(mstring); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ([obj respondsToSelector:selector]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> selector; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">void ax_offsetArgInInvocation (NSInvocation * invocation)</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ax_offsetArgInInvocation(<span class="hljs-built_in"><span class="hljs-built_in">NSInvocation</span></span> *invocation) { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *foo = malloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)); <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> arguments = [[invocation methodSignature] numberOfArguments]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; arguments<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-comment"><span class="hljs-comment">//i = 0 is self [invocation getArgument:foo atIndex:i+1]; [invocation setArgument:foo atIndex:i]; } free(foo); }</span></span></code> </pre><br></div></div><br><br><br><h2>  We deal with NSMethodSignature on the example of combining stringWithFormat and NSArray </h2><br>  Before you proceed to the next part, you need a basic understanding of how NSInvocation and NSMethodSignature work.  I thought to highlight this in a separate article, but I came to the conclusion that if I didn‚Äôt go deep into the material, the article would turn out to be interesting and simple (in the analysis of a specific example), but not very large.  So I decided to write about it right here. <br><br>  I needed a method to generate a string from a format and an array of arguments, for example, like this: <br><pre> <code class="objectivec hljs"> <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *format = <span class="hljs-string"><span class="hljs-string">@"%@, foo:%@, hello%@"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *input = @[@(<span class="hljs-number"><span class="hljs-number">12</span></span>), @(<span class="hljs-number"><span class="hljs-number">13</span></span>), <span class="hljs-string"><span class="hljs-string">@" world"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *result = [<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> ax_stringWithFormat:format array:input]; <span class="hljs-comment"><span class="hljs-comment">//result ‚Äî @"12, foo:13, hello world"</span></span></code> </pre><br><br>  Unfortunately, the methods I found on SO did not work ( <a href="http://stackoverflow.com/questions/1058736/how-to-create-a-nsstring-from-a-format-string-like-xxx-yyy-and-a-nsarr">first</a> , <a href="http://stackoverflow.com/questions/8273380/converting-nsarray-contents-to-a-varargs-with-arc-for-use-with-nsstring-initwi">second</a> ).  Perhaps I did not correctly try to use them (who succeeded ‚Äî write it down, please) on ARC, but since I needed a working version, I wrote my own implementation. <br><br>  Without making any detours with pointers or transformations, the decision is based entirely on the principle of how the methods work. <br><br>  The final form of the method looks like this: <br><pre> <code class="objectivec hljs">+ (<span class="hljs-keyword"><span class="hljs-keyword">instancetype</span></span>)ax_stringWithFormat:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)format array:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *)arguments;</code> </pre> <br><br>  The standard method for creating a string by format and parameters is as follows. <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">instancetype</span></span>)initWithFormat:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)format arguments:(va_list)argList <span class="hljs-built_in"><span class="hljs-built_in">NS_FORMAT_FUNCTION</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  But to use (and the problem itself) you need to create a va_list ( <a href="http://www.cplusplus.com/reference/cstdarg/va_list/">what it is</a> and <a href="http://www.cplusplus.com/reference/cstdarg/va_start/">how to use it</a> ). <br>  The following method is great <br><div class="spoiler">  <b class="spoiler_title">+ (instancetype) ax_string: (NSString *) format, ...</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">+ (<span class="hljs-keyword"><span class="hljs-keyword">instancetype</span></span>)ax_string:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)format, ... { va_list list; va_start(list, format); <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *str = [[<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> alloc] initWithFormat:format arguments:list]; va_end(list); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; }</code> </pre><br></div></div><br>  Now the problem is how to call it with arguments from NSArray. <br><br>  <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSInvocation_Class/">NSInvocation</a> is an object used to store and forward a message between objects and / or between applications. <br>  However, when creating NSInvocation, you must have NSMethodSignature. <br>  <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSMethodSignature_Class/index.html">NSMethodSignature</a> allows <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSMethodSignature_Class/index.html">you</a> to determine how many arguments the method takes, the types of arguments, the offsets, the type of the return value.  This is a very logical <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSInvocation_Class/">remark from the documentation.</a> <br><blockquote>  You can‚Äôt support the use of variable numbers. </blockquote><br>  After all, it is not known how many arguments and what type will be passed to the function / method with a variable number of arguments. <br><br>  And if you still know?  If I myself know this information before the call?  Then I can say that in this case, the method will take for example 4 arguments and the function will accept a variable number of arguments, this will work. <br>  NSMethodSignature can be created through the generated signature, if you specify all the information above yourself.  NSArray contains only pointers and all parameter offsets only by the pointer value, so everything is pretty simple.  As I already <a href="https://habrahabr.ru/post/270913/">wrote</a> , you can use self and _cmd in the method because they are implicitly passed to the method. <br><div class="spoiler">  <b class="spoiler_title">+ (NSMethodSignature *) ax_generateSignatureForArguments: (NSArray *) arguments</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">+ (<span class="hljs-built_in"><span class="hljs-built_in">NSMethodSignature</span></span> *)ax_generateSignatureForArguments:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *)arguments { <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> count = [arguments count]; <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> sizeptr = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> sumArgInvoke = count + <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// self + _cmd +             NSInteger offsetReturnType = sumArgInvoke * sizeptr; NSMutableString *mstring = [[NSMutableString alloc] init]; [mstring appendFormat:@"@%zd@0:%zd", offsetReturnType, sizeptr]; for (NSInteger i = 2; i &lt; sumArgInvoke; i++) { [mstring appendFormat:@"@%zd", sizeptr * i]; } return [NSMethodSignature signatureWithObjCTypes:[mstring UTF8String]]; }</span></span></code> </pre><br></div></div><br>  It is worth telling a little about what is happening here.  First you need to look at <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">the</a> coding types <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">here</a> . <br>  And now, in order, I really hope that you looked at the table. <br><br>  In the first place of the signature will be the return type and its offset (the return type is after all the arguments, so it will have the maximum offset, but written on the first).  Suppose sizeof (void *) is 8 and an array of 3 arguments.  But including self + _cmd + the format that will be passed and that we get 6 arguments.  6x8 = 48 <br>  @ 48 <br>  Then self and _cmd follow.  self comes first in arguments for this <br>  @ 48 @ 0: 8 <br>  Then format <br>  @ 48 @ 0: 8 @ 16 <br>  and arguments <br>  @ 48 @ 0: 8 @ 16 @ 24 @ 32 @ 40 <br><br>  Now, having a signature, you can use NSInvocation <br><div class="spoiler">  <b class="spoiler_title">+ (instancetype) ax_stringWithFormat: (NSString *) format array: (NSArray *) arrayArguments</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">+ (<span class="hljs-keyword"><span class="hljs-keyword">instancetype</span></span>)ax_stringWithFormat:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)format array:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *)arrayArguments { <span class="hljs-built_in"><span class="hljs-built_in">NSMethodSignature</span></span> *methodSignature = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ax_generateSignatureForArguments:arrayArguments]; <span class="hljs-built_in"><span class="hljs-built_in">NSInvocation</span></span> *invocation = [<span class="hljs-built_in"><span class="hljs-built_in">NSInvocation</span></span> invocationWithMethodSignature:methodSignature]; [invocation setTarget:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>]; [invocation setSelector:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(ax_string:)]; [invocation setArgument:&amp;format atIndex:<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; [arrayArguments count]; i++) { <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> obj = arrayArguments[i]; [invocation setArgument:(&amp;obj) atIndex:i+<span class="hljs-number"><span class="hljs-number">3</span></span>]; } [invocation invoke]; __autoreleasing <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *string; [invocation getReturnValue:&amp;string]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string; }</code> </pre><br></div></div><br><br>  And now, if you slightly change the method above, you can get rid of the + (instancetype) ax_string method: (NSString *) format, ... <br><div class="spoiler">  <b class="spoiler_title">Full code under the spoiler</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">+ (<span class="hljs-keyword"><span class="hljs-keyword">instancetype</span></span>)ax_stringWithFormat:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)format array:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *)arrayArguments { <span class="hljs-built_in"><span class="hljs-built_in">NSMethodSignature</span></span> *methodSignature = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ax_generateSignatureForArguments:arrayArguments]; <span class="hljs-built_in"><span class="hljs-built_in">NSInvocation</span></span> *invocation = [<span class="hljs-built_in"><span class="hljs-built_in">NSInvocation</span></span> invocationWithMethodSignature:methodSignature]; [invocation setTarget:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>]; [invocation setSelector:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(stringWithFormat:)]; [invocation setArgument:&amp;format atIndex:<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; [arrayArguments count]; i++) { <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> obj = arrayArguments[i]; [invocation setArgument:(&amp;obj) atIndex:i+<span class="hljs-number"><span class="hljs-number">3</span></span>]; } [invocation invoke]; __autoreleasing <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *string; [invocation getReturnValue:&amp;string]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string; } <span class="hljs-comment"><span class="hljs-comment">//https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html + (NSMethodSignature *)ax_generateSignatureForArguments:(NSArray *)arguments { NSInteger count = [arguments count]; NSInteger sizeptr = sizeof(void *); NSInteger sumArgInvoke = count + 3; //self + _cmd + (NSString *)format NSInteger offsetReturnType = sumArgInvoke * sizeptr; NSMutableString *mstring = [[NSMutableString alloc] init]; [mstring appendFormat:@"@%zd@0:%zd", offsetReturnType, sizeptr]; for (NSInteger i = 2; i &lt; sumArgInvoke; i++) { [mstring appendFormat:@"@%zd", sizeptr * i]; } return [NSMethodSignature signatureWithObjCTypes:[mstring UTF8String]]; }</span></span></code> </pre><br></div></div><br><br><h2>  Solution of the second half of the problem - how to add 1 more argument to the block unnoticed? </h2><br><br>  Interception of the moment when the block was called and displacement of arguments was considered.  The application code of the idea and the small nuances of this application were considered.  However, there is a problem that prevents completion. <br><br>  A block received in imp_implementationWithBlock must accept the owner arguments first.  It turns out that the signature of the input block for the ax_lambda function is different from the required signature, and the arguments in NSInvocation will be passed completely wrong. <br><br>  The AXProxyBlockWithSelf class redoes the signature of the proxied block, adding an additional first argument to it.  Thus, the call to the proxyblock will be completed with the correct arguments, and the first argument will be shifted before the block call itself. <br>  Need to rewrite method - (NSString *) blockSignatureStringCTypes <br><br><div class="spoiler">  <b class="spoiler_title">- (NSString *) blockSignatureStringCTypes</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)blockSignatureStringCTypes { <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *signature = [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> blockSignatureStringCTypes]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *unformatObject = [signature ax_unformatDec]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *formatNewSignature = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> addSelfToFormat:unformatObject]; <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *byteSignature = [signature ax_numbers]; <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *byteNewSignature = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> changeByteSignature:byteSignature]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> ax_stringWithFormat:formatNewSignature array:byteNewSignature]; }</code> </pre><br></div></div><br>  So, there is a block signature, with argument types and offset, return type, and so on. <br>  You need to insert an additional argument into the signature and shift the arguments. <br><div class="spoiler">  <b class="spoiler_title">We get the original form of the signature string format</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)ax_unformatDec { <span class="hljs-built_in"><span class="hljs-built_in">NSCharacterSet</span></span> *characterSet = [<span class="hljs-built_in"><span class="hljs-built_in">NSCharacterSet</span></span> decimalDigitCharacterSet]; <span class="hljs-built_in"><span class="hljs-built_in">NSPredicate</span></span> *predicate = [<span class="hljs-built_in"><span class="hljs-built_in">NSPredicate</span></span> predicateWithFormat:<span class="hljs-string"><span class="hljs-string">@"length &gt; 0"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *separated = [[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> componentsSeparatedByCharactersInSet:characterSet] filteredArrayUsingPredicate:predicate]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *format = [separated componentsJoinedByString:<span class="hljs-string"><span class="hljs-string">@"%@"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> lastSubstring] isEqualToString:[format lastSubstring]] ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> format; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [format stringByAppendingString:<span class="hljs-string"><span class="hljs-string">@"%@"</span></span>]; } } - (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)lastSubstring { <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> lastIndex = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> length] - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> substringFromIndex:lastIndex]; }</code> </pre><br></div></div><br>  Next you need to look at <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">the</a> coding types <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">here</a> . <br><div class="spoiler">  <b class="spoiler_title">Add the \ "owner \" argument to the first place</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)addSelfToFormat:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)format { <span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> *marray = [[format componentsSeparatedByString:<span class="hljs-string"><span class="hljs-string">@"?"</span></span>] mutableCopy]; [marray insertObject:<span class="hljs-string"><span class="hljs-string">@"?%@@"</span></span> atIndex:<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [marray componentsJoinedByString:<span class="hljs-string"><span class="hljs-string">@""</span></span>]; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Get the NSArray argument offsets to call</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *)ax_numbers { <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *pattern = <span class="hljs-string"><span class="hljs-string">@"\\d+"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">NSRegularExpression</span></span> *regex = [<span class="hljs-built_in"><span class="hljs-built_in">NSRegularExpression</span></span> regularExpressionWithPattern:pattern options:<span class="hljs-built_in"><span class="hljs-built_in">NSRegularExpressionCaseInsensitive</span></span> error:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSRange</span></span> fullRange = <span class="hljs-built_in"><span class="hljs-built_in">NSMakeRange</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> length]); <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *matches = [regex matchesInString:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> options:<span class="hljs-built_in"><span class="hljs-built_in">NSMatchingReportProgress</span></span> range:fullRange]; <span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> *numbers = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> array]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">NSTextCheckingResult</span></span> *checkingResult <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matches) { <span class="hljs-built_in"><span class="hljs-built_in">NSRange</span></span> range = [checkingResult range]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *numberStr = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> substringWithRange:range]; <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> *number = @([numberStr integerValue]); [numbers addObject:number]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> numbers; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Change the offset of the arguments to a new value, taking into account the added argument</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *)changeByteSignature:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *)byteSignature { <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> *marray = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> array]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> *number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> byteSignature) { <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> offset = [number integerValue] + value; [marray addObject:@(offset)]; } [marray insertObject:@<span class="hljs-number"><span class="hljs-number">0</span></span> atIndex:<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> marray; }</code> </pre><br></div></div><br><br>  Well, in the end we create a new signature using the new format string and NSArray with a new offset.  Thus, when invoking the implementation, the owner will be passed according to the documentation as the first argument, shifted due to interception and the original block is called. <br><br><br>  <a href="https://github.com/ajjnix/AXBlock">The full code is here.</a>  It was just an experiment, I had no desire to write this code for use in projects.  But I am glad that I was able to complete this business successfully.  I'm also glad that maybe I could help someone by putting a <a href="http://stackoverflow.com/a/35039384/4759124">solution for</a> generating a string using NSArray on SO. <br>  I hope I managed to bring the material in an understandable form and break into blocks. </div><p>Source: <a href="https://habr.com/ru/post/276599/">https://habr.com/ru/post/276599/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276587/index.html">Analysis of the current situation in the Russian BIM market in the field of civil engineering</a></li>
<li><a href="../276589/index.html">Introduction to IL2CPP</a></li>
<li><a href="../276593/index.html">Creating a program architecture or how to design a stool</a></li>
<li><a href="../276595/index.html">Quadcopter navigation using monocular vision</a></li>
<li><a href="../276597/index.html">Binding Request Traker 4.x on Ubuntu to ldap using the example of ActiveDirectory</a></li>
<li><a href="../276603/index.html">Evgeny Kaspersky spoke about cybercrime at Innopolis University [video]</a></li>
<li><a href="../276607/index.html">Performance and memory profiling from multiple viewing angles</a></li>
<li><a href="../276609/index.html">Package Manager opkg. Offline installation of packages in the root file system image</a></li>
<li><a href="../276611/index.html">Criticism of the article ‚ÄúHow to write in C in 2016‚Äù</a></li>
<li><a href="../276613/index.html">Notes of a true architect: just about the most important thing (Part 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>