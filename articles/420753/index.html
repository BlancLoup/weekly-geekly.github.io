<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Microservice Frontend - Modern Approach to Front Sharing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Microservice architecture has long become the de facto standard in the development of large and complex systems. It has a number of advantages: it is ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Microservice Frontend - Modern Approach to Front Sharing</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ff/bs/ky/ffbskynryldvlmxczvxjwrsxa-a.png" alt="too FAT SPA"></div><br><br>  <b><a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B8%25D0%25BA%25D1%2580%25D0%25BE%25D1%2581%25D0%25B5%25D1%2580%25D0%25B2%25D0%25B8%25D1%2581%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0">Microservice architecture</a></b> has long become the de facto standard in the development of large and complex systems.  It has a number of advantages: it is a strict division into modules, and weak connectivity, and resistance to failures, and the gradualness of output in production, and independent versioning of components. <br><br>  True, often, speaking of microservice architecture, only the backend architecture is mentioned, and the frontend both was and remains monolithic.  It turns out that we made a great back, and the front pulls us back. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Today I will tell you how we did the microservice front in our SaaS solution and what problems we encountered. <br><a name="habracut"></a><br><h2>  <font color="#173146">Problematics</font> </h2><br>  Initially, the development in our company looked like this: there are many teams involved in the development of microservices, each of which publishes its own API.  And there is a separate team that develops a SPA for the end user, using API of different microservices.  With this approach, everything works: the developers of microservices know everything about their implementation, and the SPA developers know all the subtleties of user interactions.  But there was a problem: now every frontender must know all the details of all microservices.  Microservices become more and more, front-end vendors become more and more - and Agile begins to fall apart, as there is a specialization within the team, that is, interchangeability and universality disappear. <br><br>  So we came to the next stage - modular development.  The frontend team is divided into subcommands.  Each was responsible for its own part of the application.  It has become much better, but over time this approach has exhausted itself for several reasons. <br><br><ul><li>  All modules are heterogeneous, with their own specifics.  For each module, their technology is better suited.  At the same time, the choice of technologies is a difficult task in the conditions of the SPA. </li><li>  Since the SPA application (and in the modern world this means a compilation into a single bundle or at least an assembly), only outputs of the entire application can be done at the same time.  The risk of each issue is growing. </li><li>  It's harder to manage dependencies.  Different modules need different (possibly specific) versions of dependencies.  Someone is not ready to switch to the updated dependency API, but someone cannot make a feature due to bugs in the old dependency branch. </li><li>  Due to the second point, the release cycle of all modules must be synchronized.  Everyone is waiting for lagging behind. </li></ul><br><h2>  <font color="#173146">We cut the frontend</font> </h2><br>  The moment of accumulation of critical mass came, and the frontend was decided to divide into ... frontend microservices.  Let's define what a frontend microservice is: <br><br><ul><li>  completely isolated part of the UI, in no way dependent on others;  radical isolation;  literally developed as a separate application; </li><li>  Each frontend microservice is responsible for a certain set of business functions from beginning to end, that is, it is fully functional in itself; </li><li>  can be written on any technology. </li></ul><br>  But we went further and introduced another level of division. <br><br><h3>  <font color="#173146">Fragment concept</font> </h3><br>  We call a fragment a bundle consisting of <code>js + css +  </code> .  In essence, this is an independent part of the UI that must fulfill a set of design rules in order for it to be used in a shared SPA.  For example, all styles should be as specific as possible for a fragment.  There should be no direct interaction with other fragments.  You must have a special method to which you can pass a DOM element where the fragment should be drawn. <br><br>  Thanks to the handle, we can save information about all registered fragments of the environment, and then have access to them by ID. <br><br>  This approach allows you to place two applications written in different frameworks on one page.  It also allows you to write a universal code that allows you to dynamically load the necessary fragments on the page, initialize them and manage the life cycle.  For most modern frameworks, it is enough to follow the "rules of hygiene" to make this possible. <br><br>  In cases where the fragment does not have the ability to ‚Äúcohabit‚Äù with others on the same page, there is a fallback scenario in which we draw the fragment in an iframe (solving related problems is beyond the scope of this article). <br><br>  All a developer needs to do if he wants to use an existing fragment on a page is: <br><br><ol><li>  Connect the microservice platform script to the page. <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"//{URL to static cache service}/api/v1/mui-platform/muiPlatform.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br></li><li>  Call the method of adding a fragment to the page. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.MUI.createFragment( <span class="hljs-comment"><span class="hljs-comment">// fragment name "hello-label", // fragment model { text: "HelloLabelFragment text from run time" }, // fragment position { selector: ".hello-label-placeholder", position: "afterend" }) .then(callback);</span></span></code> </pre><br></li></ol><br>  Also for communication between fragments there is a bus built on <code>Observable</code> and <code>rxjs</code> .  It is written on NativeJS.  In addition, the SDK provides wrappers for various frameworks that help to use this bus natively.  The example for Angular 6 is a utility method that returns <code>rxjs/Observable</code> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {fromEvent} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "@netcracker/mui-platform/angular2-factory/modules/shared/utils/event-utils" fromEvent("&lt;event-name&gt;"); fromEvent(EventClassType);</code> </pre><br>  In addition, the platform provides a set of services that are often used by different fragments and are basic in our infrastructure.  These are services such as localization / internationalization, authorization service, work with cross-domain cookies, local storage and much more.  Wrappers for various frameworks are also supplied for use in the SDK. <br><br><h2>  <font color="#173146">We merge frontend</font> </h2><br>  For example, we can consider this approach in the SPA admin (it combines various possible settings from different microservices).  We can make the contents of each bookmark a separate fragment, which will be supplied and developed by each microservice separately.  Thanks to this, we can make a simple ‚Äúcap‚Äù that will show the corresponding microservice when clicking on a bookmark. <br><br><img src="https://habrastorage.org/webt/uw/su/7x/uwsu7xp8fbiscef1hmkkmyw8bxw.png" alt="image"><br><br><h2>  <font color="#173146">Develop the idea of ‚Äã‚Äãa fragment</font> </h2><br>  The development of one bookmark with one fragment does not always allow to solve all possible tasks.  It is often necessary in one microservice to develop a certain part of the UI, which will then be reused in another microservice. <br><br>  And here fragments help us too!  Since all that the fragment needs is a DOM element for rendering, we give any microservice a global API through which it can place any fragment inside its DOM tree.  To do this, simply pass the fragment ID and the container in which it needs to be drawn.  The rest will be done by itself! <br>  Now we can build a ‚Äúmatryoshka‚Äù of any nesting level and reuse entire UI pieces without the need for support in several places. <br><br>  It often happens that there are several fragments on one page that should change their state when some general data on the page changes.  To do this, they have a global (NativeJS) event bus through which they can communicate and respond to changes. <br><br><img src="https://habrastorage.org/webt/yn/q7/g-/ynq7g-cvebke-ppttzyrawkfwsw.png" alt="image"><br><br><h3>  <font color="#173146">Shared services</font> </h3><br>  In the microservice architecture, central services inevitably appear, the data from which everyone else needs.  For example, a localization service that stores translations.  If each microservice separately begins to climb behind this data to the server, we will receive just a shaft of requests during initialization. <br><br>  To solve this problem, we developed implementations of NativeJS services that provide access to such data.  This made it possible not to make unnecessary requests and cache data.  In some cases, even in advance to display such data on the page in HTML, in order to completely get rid of requests. <br><br>  In addition, wrappers over our services for different frameworks were developed to make their use very natural (DI, fixed interface). <br><br><h2>  <font color="#173146">Pluses of frontend microservices</font> </h2><br>  The most important thing that we get from the division of a monolith into fragments is the possibility of choosing technologies by each team individually and transparent dependency management.  But in addition, it gives the following: <br><br><ul><li>  very clearly defined areas of responsibility; </li><li>  independent outputs: each fragment can have its release cycle; </li><li>  increasing the stability of the solution as a whole, since the issuance of individual fragments does not affect others; </li><li>  the ability to easily roll back features, roll them to the audience in part; </li><li>  the piece fits easily into each developer‚Äôs head, which leads to real </li></ul>  interchangeability of team members;  In addition, each fender can more deeply understand all the subtleties of interaction with the corresponding backend. <br><br>  The solution with a microserse frontend looks good.  After all, now every fragment (microservice) can decide for itself how to deploy: whether you just need nginx to distribute statics, full-fledged middleware to aggregate requests to backups or support websockets, or some other specificity in the form of binary data transfer protocol inside http.  In addition, fragments can choose their own assembly methods, optimization methods and so on. <br><br><h2>  <font color="#173146">Cons of frontend microservices</font> </h2><br>  You can never do without a fly in the ointment. <br><br><ul><li>  The interaction between fragments cannot be provided by standard tube methods (DI, for example). </li><li>  How to deal with common dependencies?  After all, the size of the application will grow by leaps and bounds, if they are not taken out of the fragments. </li><li>  For routing in the final application, one should still be responsible. </li><li>  What to do if one of the fragments is unavailable / cannot be drawn. </li><li>  It is not clear what to do with the fact that different microservices can be on different domains. </li></ul><br><h2>  <font color="#173146">Conclusion</font> </h2><br>  Our experience with this approach has proven its viability.  The speed of displaying features in production has increased significantly.  The number of implicit dependencies between parts of the interface has been reduced to almost zero.  We got a consistent UI.  You can safely test the features without involving a large number of people. <br><br>  Unfortunately, in one article it is very difficult to highlight the whole range of problems and solutions that can be found along the way of repeating such an architecture.  But for us, the pros clearly outweigh the cons.  If Habr shows interest in disclosing details of the implementation of this approach, we will definitely write a sequel! </div><p>Source: <a href="https://habr.com/ru/post/420753/">https://habr.com/ru/post/420753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420735/index.html">We invite you to the finale of the marathon ‚ÄúFind yourself in digital‚Äù in the office of Mail.Ru Group</a></li>
<li><a href="../420737/index.html">Mini ai cup 2 or almost AgarIO - what could be done to win</a></li>
<li><a href="../420739/index.html">The box is still in the pen: why in 2018 you still need to learn languages ‚Äã‚Äãyourself</a></li>
<li><a href="../420741/index.html">Cheat sheet for programmers or "we google for you"</a></li>
<li><a href="../420749/index.html">GitLab for Continuous Delivery project on InterSystems technologies: Containers</a></li>
<li><a href="../420757/index.html">Programming Contest: Trading (Results)</a></li>
<li><a href="../420761/index.html">TypeScript 3.0</a></li>
<li><a href="../420763/index.html">KDD 2018, second day, seminars</a></li>
<li><a href="../420765/index.html">Impressions of the Gemini PDA. Pocket dual-boot combine or useless toy?</a></li>
<li><a href="../420767/index.html">Rostelecom Demands to Recognize Sputnik Bankrupt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>