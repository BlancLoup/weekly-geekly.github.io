<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How not to step on a rake, working with serialization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despite the fact that using the serialization mechanism when programming in C # is quite simple and convenient, there are some points to consider. Abo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How not to step on a rake, working with serialization</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/729/d70/814/729d70814cad467fb3107e2dfe3537fa.png"></div><br><br>  Despite the fact that using the serialization mechanism when programming in C # is quite simple and convenient, there are some points to consider.  About what rake you can step on while working with serialization, about code examples in which these rakes are hidden, and also how PVS-Studio will help you to avoid bumps on your forehead, and this article will be. <br><a name="habracut"></a><br><br><h2>  Who is the article for? </h2><br>  This article will be especially useful for developers who are just starting to get acquainted with the serialization mechanism.  More experienced programmers can also learn something interesting for themselves, or just make sure that even professionals sometimes make mistakes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, it is understood that the reader is already familiar with the serialization mechanism. <br><br>  What does PVS-Studio have to do with it?  In <a href="http://www.viva64.com/en/d/0013/">release 6.05</a> , 6 diagnostic rules were added that detect suspicious code associated with the use of the serialization mechanism.  These diagnostics are mainly looking for problem areas associated with the <i>[Serializable]</i> attribute or the implementation of the <i>ISerializable</i> interface. <br><br>  <b>Note.</b> <br><br>  It should be understood that the statements described in the article are relevant for some serializers, for example, <i>BinaryFormatter</i> and <i>SoapFormatter</i> , and for others, for example, with a hand-written serializer, the behavior may differ.  For example, the absence of the <i>[Serializable]</i> attribute of a class may not interfere with its serialization and deserialization with its own serializer. <br><br>  By the way, if you are working with serialization, I advise you to <a href="http://www.viva64.com/ru/pvs-studio-download/">download a</a> trial version of the analyzer and check your code for the presence of suspicious places. <br><br><h2>  Realizing ISerializable, do not forget about the serialization designer </h2><br>  The implementation of the interface type <i>ISerializable</i> allows <i>you</i> to control the serialization, choosing which members need to be serialized, which are not, which values ‚Äã‚Äãneed to be recorded when members are serialized, and so on. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/558/f0f/809/558f0f80913b47f595edeb44de7cf391.png"></div><br><br>  The <i>ISerializable</i> interface contains a single method <i>declaration</i> , <i>GetObjectData</i> , which will be called when the object is serialized.  But together with this method, a constructor must be implemented, which will be called when an object is deserialized.  Since the interface cannot oblige you to implement some kind of constructor in your type, this task falls on the shoulders of the programmer who implements the serializable type.  The serialization constructor has the following signature: <br><pre><code class="cs hljs">Ctor(SerializationInfo, StreamingContext)</code> </pre> <br>  Without this constructor, the serialization of the object will succeed (assuming the correct implementation of the <i>GetObjectData</i> method), but it cannot be restored (deserialized) - an exception of the type <i>SerializationException</i> will be generated. <br><br>  Let's look at an example of similar code from the Glimpse project: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SerializableTestObject</span></span> : <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> TestProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObjectData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">)</span></span> { info.AddValue(<span class="hljs-string"><span class="hljs-string">"TestProperty"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.TestProperty); } }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0505/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0505/">V3094</a> Possible exception when deserializing.  The SerializableTestObject (SerializationInfo, StreamingContext) constructor is missing.  Glimpse.Test.AspNet SessionModelConverterShould.cs 111 <br><br>  Serialization of an instance of this class will succeed, but an exception will occur during deserialization, since there is no corresponding constructor.  Most likely, this is not an error (based on the name of the class and the file), but as an illustration of the described situation - what you need. <br><br>  The serialization constructor for this class might look like this: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SerializableTestObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">)</span></span> { TestProperty = info.GetString(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(TestProperty)); }</code> </pre> <br><h2>  Pay attention to the serialization constructor access modifier </h2><br>  When developing a type that implements the <i>ISerializable</i> interface, it is important to correctly define the access modifier for the serialization constructor.  There are several possible cases: <ul><li>  serialization constructor declared with <i>private</i> modifier in unprinted class; </li><li>  serialization constructor declared with <i>public</i> or <i>internal</i> access modifier; </li><li>  serialization constructor declared with <i>protected</i> modifier in sealed class. </li></ul><br>  Of greatest interest is the first of the above options, as it carries the greatest danger.  Let us briefly dwell on the second paragraph, but the third will not be considered - declaring the member with the <i>protected</i> modifier in the structure will not be given by the compiler (compilation error), if such a member is declared in the sealed class - the compiler will issue a warning. <br><br><h3>  The serialization constructor in the unprinted class has the access modifier 'private' </h3><br>  This is the most dangerous case of improper use of access modifiers to serialization constructors.  If the type is unprinted, it is assumed that it may have heirs.  However, if the serialization constructor has a <i>private</i> access modifier, it cannot be called from a child class. <br><br>  In this case, the child class developer has 2 choices - refuse to use this parent class or manually deserialize the members of the base class.  It is worth noting that the second case can hardly be considered a solution to the problem: <ul><li>  it‚Äôs not a fact that the base class provided for trivial deserialization of members; </li><li>  the developer of the child class may forget to deserialize any member of the base class; </li><li>  with all the desire, it will not be possible to deserialize the private members of the base class. </li></ul><br>  Therefore, when developing an unprinted serializable class, pay attention to which access modifier the serialization constructor has. <br><br>  When analyzing the projects, it was possible to find several such in which the rule described above was not observed. <br><br>  <b>NHibernate</b> <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConnectionManager</span></span> : <span class="hljs-title"><span class="hljs-title">ISerializable</span></span>, <span class="hljs-title"><span class="hljs-title">IDeserializationCallback</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConnectionManager</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">)</span></span> { .... } .... }</code> </pre> <br>  <b>PVS-Studio Warning:</b> <a href="http://www.viva64.com/ru/d/0509/">V3103</a> A Private Ctor (SerializationInfo, StreamingContext) constructor in deserializing derived types.  NHibernate ConnectionManager.cs 276 <br><br>  <b>Roslyn</b> <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestDiagnostic</span></span> : <span class="hljs-title"><span class="hljs-title">Diagnostic</span></span>, <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestDiagnostic</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">)</span></span> { .... } .... }</code> </pre> <br>  <b>PVS-Studio Warning:</b> <a href="http://www.viva64.com/ru/d/0509/">V3103</a> A private TestDiagnostic (SerializationInfo, StreamingContext) constructor in unsealed type.  DiagnosticAnalyzerTests.cs 100 <br><br>  In both of the examples above, the serialization constructor should be set to the <i>protected</i> access modifier so that child classes could call it when deserializing. <br><br><h3>  Do not declare the serialization constructor with the 'public' or 'internal' modifiers. </h3><br>  This is a good programming style tip.  Declaring a serialization constructor with a <i>public</i> or <i>internal</i> modifier will not lead to an error, but there is no point in this - this constructor should not be called from the outside, and the serializer no matter what access modifier the constructor has. <br><br>  When checking open source projects, several of them met in which this rule was not observed. <br><br>  <b>Msbuild</b> <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FileState</span></span> : <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SystemState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">)</span></span> { .... } .... }</code> </pre> <br>  <b>PVS-Studio Warning:</b> <a href="http://www.viva64.com/ru/d/0509/">V3103</a> The Ctor (SerializationInfo, StreamingContext) constructor should not be used for deserialization.  Making it internal is not recommended.  Consider making it private.  Microsoft.Build.Tasks SystemState.cs 218 <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FileState</span></span> : <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">)</span></span> { .... } .... }</code> </pre> <br>  <b>PVS-Studio Warning:</b> <a href="http://www.viva64.com/ru/d/0509/">V3103</a> The Ctor (SerializationInfo, StreamingContext) constructor should not be used for deserialization.  Making it internal is not recommended.  Consider making it private.  Microsoft.Build.Tasks SystemState.cs 139 <br><br>  In both cases, the serialization constructor should be set to the <i>private</i> access modifier, so both of the above classes are sealed. <br><br>  <b>NHibernate</b> <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StatefulPersistenceContext</span></span> : <span class="hljs-title"><span class="hljs-title">IPersistenceContext</span></span>, <span class="hljs-title"><span class="hljs-title">ISerializable</span></span>, <span class="hljs-title"><span class="hljs-title">IDeserializationCallback</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StatefulPersistenceContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">)</span></span> { .... } .... }</code> </pre> <br>  <b>PVS-Studio Warning:</b> <a href="http://www.viva64.com/ru/d/0509/">V3103</a> The Ctor (SerializationInfo, StreamingContext) constructor should not be used for deserialization.  Making it internal is not recommended.  Consider making it protected.  NHibernate StatefulPersistenceContext.cs 1478 <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Configuration</span></span> : <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">)</span></span> { .... } .... }</code> </pre> <br>  <b>PVS-Studio Warning:</b> <a href="http://www.viva64.com/ru/d/0509/">V3103</a> The Ctor (SerializationInfo, StreamingContext) constructor should not be used for deserialization.  Making it public is not recommended.  Consider making it protected.  NHibernate Configuration.cs 84 <br><br>  Due to the fact that both classes are unprinted, for the serialization constructors, the <i>protected</i> access modifier should be set. <br><br><h2>  Implement the GetObjectData virtual method in unprinted classes </h2><br><br>  The rule is simple - if you are developing an unprinted class that implements the <i>ISerializable</i> interface, declare the <i>GetObjectData</i> method with the <i>virtual</i> modifier.  This will allow child classes to correctly serialize the object when using polymorphism. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/53e/1f3/384/53e1f3384d1b4233a5e8ac4f01870d9b.png"></div><br>  To better understand the essence of the problem, I propose to consider a few examples. <br><br>  Suppose we have the following declarations of the parent and child classes. <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Base</span></span> : <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObjectData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">)</span></span> { .... } } [Serializable] <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Derived</span></span> : <span class="hljs-title"><span class="hljs-title">Base</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> new </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObjectData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">)</span></span> { .... } }</code> </pre> <br>  Suppose there is a method for serializing and deserializing an object of the following form: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryFormatter bf, MemoryStream ms</span></span></span><span class="hljs-function">)</span></span> { Base obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Derived(); bf.Serialize(ms, obj); ms.Seek(<span class="hljs-number"><span class="hljs-number">0</span></span>, SeekOrigin.Begin); Derived derObj = (Derived)bf.Deserialize(ms); }</code> </pre> <br>  In this case, the serialization will be performed incorrectly due to the fact that the <i>GetObjectData</i> method will be called not of the child, but of the parent class.  Therefore, members of the child class will not be serialized.  If during deserialization, the values ‚Äã‚Äãof the members added to the <i>GetObjectData</i> method of the child class are retrieved from the object of the <i>SerializationInfo</i> type, an exception will be generated because the object of the <i>SerializationInfo</i> type will not contain the requested keys. <br><br>  To correct an error in the parent class, the <i>virtual modifier</i> must be added to the <i>GetObjectData</i> method, and the <i>override</i> in the derived class. <br><br>  If only an explicit implementation of the <i>ISerializable</i> interface is present in the parent class, you cannot add the <i>virtual</i> modifier to it.  However, leaving everything as it is, you risk complicating the lives of the developers of the child classes. <br><br>  Consider an example of the implementation of the parent and child classes: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Base</span></span> : <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ISerializable.GetObjectData(SerializationInfo info, StreamingContext context) { .... } } [Serializable] <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Derived</span></span> : <span class="hljs-title"><span class="hljs-title">Base</span></span>, <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObjectData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">)</span></span> { .... } }</code> </pre> <br>  In this case, the child class will not be able to access the <i>GetObjectData</i> method of the parent class.  And if private members are serialized in the base method, they will also fail to access them from the child class, which means that they will not be able to perform the correct serialization.  To correct the error, in addition to the explicit implementation, the implicit implementation of the virtual method <i>GetObjectData</i> must be added to the base class.  Then the corrected code might look like this: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Base</span></span> : <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ISerializable.GetObjectData(SerializationInfo info, StreamingContext context) { GetObjectData(info, context); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObjectData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">)</span></span> { .... } } [Serializable] <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Derived</span></span> : <span class="hljs-title"><span class="hljs-title">Base</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObjectData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.GetObjectData(info, context); } }</code> </pre> <br>  Alternatively, if inheritance of this class is not implied, it should be sealed by adding the <i>sealed</i> modifier to the class declaration. <br><br>  <b>Roslyn</b> <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestDiagnostic</span></span> : <span class="hljs-title"><span class="hljs-title">Diagnostic</span></span>, <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _kind; .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _message; .... <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ISerializable.GetObjectData(SerializationInfo info, StreamingContext context) { info.AddValue(<span class="hljs-string"><span class="hljs-string">"id"</span></span>, _descriptor.Id); info.AddValue(<span class="hljs-string"><span class="hljs-string">"kind"</span></span>, _kind); info.AddValue(<span class="hljs-string"><span class="hljs-string">"message"</span></span>, _message); info.AddValue(<span class="hljs-string"><span class="hljs-string">"location"</span></span>, _location, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Location)); info.AddValue(<span class="hljs-string"><span class="hljs-string">"severity"</span></span>, _severity, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(DiagnosticSeverity)); info.AddValue(<span class="hljs-string"><span class="hljs-string">"defaultSeverity"</span></span>, _descriptor.DefaultSeverity, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(DiagnosticSeverity)); info.AddValue(<span class="hljs-string"><span class="hljs-string">"arguments"</span></span>, _arguments, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[])); } .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0510/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0510/">V3104</a> 'GetObjectData' implementation in the unsealed type 'TestDiagnostic' is not virtual, it is not possible.  CSharpCompilerSemanticTest DiagnosticAnalyzerTests.cs 112 <br><br>  The <i>TestDiagnostic</i> class is unsealed (albeit private, so it is possible to inherit from it within the same class), but it only has an explicit implementation of the <i>ISerializable</i> interface, in which, among other things, private members are serialized.  This means one thing - the child class developer will not be able to serialize the necessary members in any way: the <i>GetObjectData</i> method will not be available to it, and the access modifier will not allow accessing members directly. <br><br>  It would be more correct to bring all the serialization code given above to the virtual method <i>GetObjectData</i> , which can be referenced from an explicit interface implementation: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ISerializable.GetObjectData(SerializationInfo info, StreamingContext context) { GetObjectData(info, context); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObjectData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">)</span></span> { info.AddValue(<span class="hljs-string"><span class="hljs-string">"id"</span></span>, _descriptor.Id); info.AddValue(<span class="hljs-string"><span class="hljs-string">"kind"</span></span>, _kind); info.AddValue(<span class="hljs-string"><span class="hljs-string">"message"</span></span>, _message); info.AddValue(<span class="hljs-string"><span class="hljs-string">"location"</span></span>, _location, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Location)); info.AddValue(<span class="hljs-string"><span class="hljs-string">"severity"</span></span>, _severity, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(DiagnosticSeverity)); info.AddValue(<span class="hljs-string"><span class="hljs-string">"defaultSeverity"</span></span>, _descriptor.DefaultSeverity, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(DiagnosticSeverity)); info.AddValue(<span class="hljs-string"><span class="hljs-string">"arguments"</span></span>, _arguments, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[])); }</code> </pre> <br><h2>  All serializable members must be serializable. </h2><br>  This condition is mandatory for correct object serialization regardless of whether automatic serialization occurs (when the type is decorated with the <i>[Serializable]</i> attribute and does not implement the <i>ISerializable</i> interface) or the serialization is performed manually (implemented by <i>ISerializable</i> ). <br><br>  Otherwise, if during serialization a member is encountered that is not decorated with the <i>[Serializable]</i> attribute, an exception of type <i>SerializationException</i> will be thrown. <br><br>  If it is necessary to serialize an object without considering members that have a non-realizable type, several approaches are possible: <ul><li>  make the non-serializable type serializable; </li><li>  if automatic serialization occurs, decorate fields that do not need to be serialized with the <i>[NonSerialized]</i> attribute; </li><li>  if manual serialization occurs, simply ignore those members that you do not need. </li></ul><br>  It is worth paying attention to the fact that the <i>[NonSerialized]</i> attribute is applicable only to fields.  Thus, you cannot prohibit the serialization of a property, but if it has a non-serializable type, you will get an exception.  For example, when trying to serialize the class <i>SerializedClass</i> , which is defined below: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NonSerializedType</span></span> { } [Serializable] <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SerializedClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Int32 <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NonSerializedType NSProp { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  You can <i>get around</i> this situation by implementing the property through the field decorated with the <i>[NonSerialized]</i> attribute: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SerializedClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Int32 <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; [NonSerialized] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NonSerializedType nsField; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NonSerializedType NSProp { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nsField; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { nsField = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre> <br>  Such errors, when the type being serialized has members of non-realizable types that are not decorated with the <i>[NonSerialized]</i> attribute, detects the <a href="http://www.viva64.com/ru/d/0507/">V3097</a> diagnostic rule of the PVS-Studio static code analyzer. <br><br>  I remind you that this warning does not necessarily indicate the presence of an error - it all depends on the serializer being used. <br><br>  Consider a few code examples in which the described condition was violated. <br><br>  <b>Subtext</b> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BlogUrlHelper</span></span> { .... } [Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AkismetSpamService</span></span> : <span class="hljs-title"><span class="hljs-title">ICommentSpamService</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> BlogUrlHelper _urlHelper; .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0507/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0507/">V3097</a> Possible exception: the 'AkismetSpamService' type marked by [Serialable] contains non-serializable members not marked by [NonSerialized].  Subtext.Framework AkismetSpamService.cs 31 <br><br>  The <i>BlogUrlHelper</i> type of the <i>_urlHelper</i> field <i>is</i> not serializable, so when some serializers attempt to serialize an instance of the <i>AkismetSpamService</i> class, <i>an</i> SerializationException will be generated.  Solve the problem you need, starting from the situation.  If serializers of the <i>BinaryFormatter</i> or <i>SoapFormatter</i> type are <i>used</i> , it is necessary either to decorate the field with the <i>[NonSerialized]</i> attribute, or to decorate with the <i>[Serializable]</i> attribute the <i>BlogUrlHepler</i> type.  If you use other serializers that do not require the presence of the <i>[Serializable]</i> attribute in the serializable fields, you can not score a head. <br><br>  <b>NHibernate</b> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Organisation</span></span> { .... } [Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ResponsibleLegalPerson</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Organisation organisation; .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/en/d/0507/">warning</a> <b>:</b> <a href="http://www.viva64.com/en/d/0507/">V3097</a> Possible exception: the 'ResponsibleLegalPerson' type marked by [Serialable] contains non-serializable members not marked by [NonSerialized].  NHibernate.Test ResponsibleLegalPerson.cs 9 <br><br>  The situation is similar to that described above - either pan or gone.  It all depends on the serializer used. <br><br><h2>  Do not forget about the attribute [Serializable] when implementing the interface ISerializable </h2><br>  This advice applies more to those who are just starting to work with serialization.  Managing serialization manually, through the implementation of the <i>ISerializable</i> interface, it is easy to forget to decorate the type with the <i>[Serializable]</i> attribute, which potentially leads to the generation of an exception of type <i>SerializationException</i> .  Serializers like <i>BinaryFormatter</i> require this attribute. <br><br><img src="https://habrastorage.org/files/14d/cbd/742/14dcbd7428254b23b86cd0bf06d673e9.png"><br><br>  <b>SharpDevelop</b> <br><br>  Interesting examples of this error met in the SharpDevelop project. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SearchPatternException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span>, <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SearchPatternException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">info, context</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0506/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0506/">V3096</a> Possible exception when serializing 'SearchPatternException' type.  [Serializable] attribute is missing.  ICSharpCode.AvalonEdit ISearchStrategy.cs 80 <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DecompilerException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span>, <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecompilerException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">info, context</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0506/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0506/">V3096</a> Possible exception when serializing 'DecompilerException' type.  [Serializable] attribute is missing.  ICSharpCode.Decompiler DecompilerException.cs 28 <br><br>  To transfer an exception object between application domains, it is serialized and deserialized.  Accordingly, native exception types must be serializable.  In the examples above, the <i>SearchPatternException</i> and <i>DecompilerException</i> types inherit from <i>Exception</i> and implement serialization constructors, but they are not decorated with the <i>[Serializable]</i> attribute, which means that when trying to serialize these types of objects (for example, to pass between domains), a <i>SerializationException</i> will be generated.  Thus, for example, by throwing an exception in another application domain, in the current application you will catch not a generated exception, but a <i>SerializationException</i> . <br><br><h2>  Make sure that the required members of the type are serialized in the GetObjectData method. </h2><br>  By implementing the <i>ISerializable</i> interface and defining the <i>GetObjectData</i> method, you take responsibility for which type members will be serialized and what values ‚Äã‚Äãwill be written to them.  In this case, developers have a lot of control over serialization: as a serializable value associated with a member (or to be more honest with any string), you can write the actual value of the serialized object, the result of a method, a constant or literal value - whatever you want. <br><br>  However, in this case, a large responsibility falls on the shoulders of the developer, because it is necessary not to forget any member to be serialized, even if it is in the base class.  We are all human, so sometimes some members are still forgotten. <br><br>  In order to diagnose such situations, the diagnostic rule <a href="http://www.viva64.com/ru/d/0508/">V3099 is</a> provided in the static code analyzer PVS-Studio.  I suggest to get acquainted with some examples of the code found by this rule. <br><br>  <b>SharpDevelop</b> <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">XshdElement</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LineNumber { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ColumnNumber { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptVisitor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IXshdVisitor visitor</span></span></span><span class="hljs-function">)</span></span>; } [Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">XshdColor</span></span> : <span class="hljs-title"><span class="hljs-title">XshdElement</span></span>, <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObjectData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"info"</span></span>); info.AddValue(<span class="hljs-string"><span class="hljs-string">"Name"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Name); info.AddValue(<span class="hljs-string"><span class="hljs-string">"Foreground"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Foreground); info.AddValue(<span class="hljs-string"><span class="hljs-string">"Background"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Background); info.AddValue(<span class="hljs-string"><span class="hljs-string">"HasUnderline"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Underline.HasValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Underline.HasValue) info.AddValue(<span class="hljs-string"><span class="hljs-string">"Underline"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Underline.Value); info.AddValue(<span class="hljs-string"><span class="hljs-string">"HasWeight"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.FontWeight.HasValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.FontWeight.HasValue) info.AddValue(<span class="hljs-string"><span class="hljs-string">"Weight"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.FontWeight .Value .ToOpenTypeWeight()); info.AddValue(<span class="hljs-string"><span class="hljs-string">"HasStyle"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.FontStyle.HasValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.FontStyle.HasValue) info.AddValue(<span class="hljs-string"><span class="hljs-string">"Style"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.FontStyle.Value.ToString()); info.AddValue(<span class="hljs-string"><span class="hljs-string">"ExampleText"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ExampleText); } }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0508/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0508/">V3099</a> XshdColor 'type are serialized inside' GetObjectData 'method: LineNumber, ColumnNumber.  ICSharpCode.AvalonEdit XshdColor.cs 101 <br><br>  In this code, there are no problems described earlier, such as incorrect access modifiers for the serialization constructor, the absence of the <i>[Serializable]</i> attribute or the <i>virtual</i> modifier for the <i>GetObjectData</i> method. <br>  Alas, there is still a mistake here.  The <i>GetObjectData</i> method <i>does</i> not take into account the properties of the base class, which means that some of the data will be lost during serialization.  As a result, during deserialization, an object with a different state will be restored. <br><br>  In this case, the solution is to manually add the necessary values, for example, in this way: <br><pre> <code class="cs hljs">info.AddValue(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(LineNumber), LineNumber); info.AddValue(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(ColumnNumber), ColumnNumber);</code> </pre> <br>  If the base class also implemented the <i>ISerializable</i> interface, the solution would be more elegant - a call in the <i>GetObjectData</i> derived method of the base method. <br><br>  <b>NHibernate</b> <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SessionImpl</span></span> : <span class="hljs-title"><span class="hljs-title">AbstractSessionImpl</span></span>, <span class="hljs-title"><span class="hljs-title">IEventSource</span></span>, <span class="hljs-title"><span class="hljs-title">ISerializable</span></span>, <span class="hljs-title"><span class="hljs-title">IDeserializationCallback</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ISerializable.GetObjectData(SerializationInfo info, StreamingContext context) { log.Debug(<span class="hljs-string"><span class="hljs-string">"writting session to serializer"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!connectionManager.IsReadyForSerialization) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"Cannot serialize a Session while connected"</span></span>); } info.AddValue(<span class="hljs-string"><span class="hljs-string">"factory"</span></span>, Factory, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(SessionFactoryImpl)); info.AddValue(<span class="hljs-string"><span class="hljs-string">"persistenceContext"</span></span>, persistenceContext, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(StatefulPersistenceContext)); info.AddValue(<span class="hljs-string"><span class="hljs-string">"actionQueue"</span></span>, actionQueue, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(ActionQueue)); info.AddValue(<span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>, timestamp); info.AddValue(<span class="hljs-string"><span class="hljs-string">"flushMode"</span></span>, flushMode); info.AddValue(<span class="hljs-string"><span class="hljs-string">"cacheMode"</span></span>, cacheMode); info.AddValue(<span class="hljs-string"><span class="hljs-string">"interceptor"</span></span>, interceptor, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IInterceptor)); info.AddValue(<span class="hljs-string"><span class="hljs-string">"enabledFilters"</span></span>, enabledFilters, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, IFilter&gt;)); info.AddValue(<span class="hljs-string"><span class="hljs-string">"enabledFilterNames"</span></span>, enabledFilterNames, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;)); info.AddValue(<span class="hljs-string"><span class="hljs-string">"connectionManager"</span></span>, connectionManager, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(ConnectionManager)); } .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fetchProfile; .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0508/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0508/">V3099</a> SortImpl 'type are serialized inside' GetObjectData 'method: fetchProfile.  NHibernate SessionImpl.cs 141 <br><br>  This time they forgot to serialize the field of the current class ( <i>fetchProfile</i> ).  As can be seen from the definition, it is not decorated with the <i>[NonSerialized]</i> attribute (unlike other fields that are not serializable in the <i>GetObjectData</i> method). <br><br>  There are two more similar places in this project: <ul><li>  V3099 type are serialized inside the GetObjectData method: currentDocumentName, preMappingBuildProcessed.  NHibernate Configuration.cs 127 </li><li>  V3099 type: "ConnectionManager" type are serialized inside "GetObjectData" method: flushingFromDtcTransaction.  NHibernate ConnectionManager.cs 290 </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An interesting peculiarity is related to such errors - they either lead to the generation of an exception, or to subtle logical errors. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An exception will be generated if the serialization constructor tries to get the value of the field that has not been added (will be addressed using the missing key). </font><font style="vertical-align: inherit;">If a member is completely forgotten (both in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetObjectData</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">and in the serialization constructor), the state of the object will be </font><i><font style="vertical-align: inherit;">damaged</font></i><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Generalization </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Briefly summarizing all the information above, you can formulate a few tips and rules: </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decorate with the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Serializable]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> attribute </font><font style="vertical-align: inherit;">types that implement the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISerializable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> interface </font><font style="vertical-align: inherit;">;</font></font></li><li> ,       <i>[Serializable]</i>   ; </li><li>   <i>ISerializable</i> ,      ( <i>Ctor(SerializationInfo, StreamingContext)</i> ); </li><li>       <i>private</i>   ,   ‚Äî <i>protected</i> ; </li><li>   ,   <i>ISerializable</i> ,   <i>GetObjectData</i> ; </li><li> ,    <i>GetObjectData</i>    ,    ,   . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/files/cf5/17e/e67/cf517ee67dc6491c9a216d824b567a55.png"></div><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope you learned something new from the article and became </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> best expert on serialization issues. </font><font style="vertical-align: inherit;">By adhering to the above tips and rules, you can spend less time debugging, making life easier for yourself and other developers working with your classes. </font><font style="vertical-align: inherit;">And the PVS-Studio analyzer will make life even easier, allowing you to detect such errors immediately after they appear.</font></font><br><br><h2>  Additional Information </h2><br><ul><li> <a href="http://www.viva64.com/ru/d/0505/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3094. </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Possible exception when deserializing type. </font><font style="vertical-align: inherit;">The Ctor (SerializationInfo, StreamingContext) constructor is missing</font></font></li><li> <a href="http://www.viva64.com/ru/d/0506/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3096. </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Possible exception when serializing type. </font><font style="vertical-align: inherit;">[Serializable] attribute is missing</font></font></li><li> <a href="http://www.viva64.com/ru/d/0507/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3097. </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Possible exception: type marked by [Serialable] contains non-serializable</font></font></li><li> <a href="http://www.viva64.com/ru/d/0508/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3099. </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Not all members of the type are serialized inside 'GetObjectData' method</font></font></li><li> <a href="http://www.viva64.com/ru/d/0509/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3103. </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A private Ctor (SerializationInfo, StreamingContext) constructor in unsealed type</font></font></li><li> <a href="http://www.viva64.com/ru/d/0510/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3104. </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"GetObjectData"</font></font></li><li> <a href="https://msdn.microsoft.com/en-us/library/7ay27kt9(v%3Dvs.110).aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Msdn </font><font style="vertical-align: inherit;">Serialization in the .NET Framework</font></font></a> </li><li> <a href="https://msdn.microsoft.com/en-us/library/ty01x675(v%3Dvs.110).aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Msdn </font><font style="vertical-align: inherit;">Custom Serialization</font></font></a> </li></ul><br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0409/"><img src="https://habrastorage.org/files/8d2/41b/5bf/8d241b5bf34747169141ed7c1997143b.png"></a> </div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to share this article with an English-speaking audience, then please use the link to the translation: Sergey Vasiliev. </font></font><a href="http://www.viva64.com/en/b/0409/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to not serialize</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/304734/">https://habr.com/ru/post/304734/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304722/index.html">Development of the first game [on Unity3D]</a></li>
<li><a href="../304724/index.html">Projecting Google Material Design onto the desktop system ... (part one)</a></li>
<li><a href="../304726/index.html">Digest of grocery design, June 2016</a></li>
<li><a href="../304728/index.html">Concepts for the desperate</a></li>
<li><a href="../304732/index.html">Ansible where to start</a></li>
<li><a href="../304738/index.html">Vulnerabilities of corporate information systems - 2015: inside is worse than outside</a></li>
<li><a href="../304740/index.html">Signal and Transport Protocols WebRTC: Tearing Covers</a></li>
<li><a href="../304742/index.html">Usability rules for bots</a></li>
<li><a href="../304744/index.html">ETERNUS Snapshot Manager - an effective tool for high data availability</a></li>
<li><a href="../304748/index.html">Introduction to compilers, interpreters and JITs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>