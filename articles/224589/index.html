<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learning the file system to read</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What will happen in this article 


 We continue a series of articles on creating a file system in the Linux kernel, based on the materials of the OS ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learning the file system to read</h1><div class="post__text post__text-html js-mediator-article"><h4>  What will happen in this article </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/852/5d0/e03/8525d0e0391718d86da143640be69774.png" alt="image" align="left"><br><br>  We continue a series of articles on creating a file system in the Linux kernel, based on the materials of the OS course at the <a href="http://mit.spbau.ru/">Academic University</a> . <br><br>  <a href="http://habrahabr.ru/company/spbau/blog/218833/">Last time,</a> we set up the environment we need to get to know the kernel.  Then we took a look at the loadable kernel modules and wrote a simple ‚ÄúHello, World!‚Äù.  Finally, we wrote a simple and useless file system.  It's time to continue. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The main purpose of this article is to teach the file system to read from disk.  For now, it will only read service information (superblock and index nodes), so it is still rather difficult to use it. <br><br>  Why so little?  The fact is that in this post we need to determine the structure of our file system - how it will be stored on disk.  In addition, we will encounter a couple of interesting points, such as SLAB and RCU.  All this will require some explanations - a lot of words and a little code, so the post will be quite voluminous. <br><br><a name="habracut"></a><br><br><h4>  Boring start </h4><br><br>  Our file system should be simple, so it will be stored on disk simply: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/777/8f0/f7d/7778f0f7db70516b68a0d617d14e480e.jpg"><br><br>  Let's start from the end: <br><br><ul><li>  data blocks - blocks of useful data, i.e. the contents of files and folders; </li><li>  table of inodes - a table of index nodes;  the number of index nodes is determined during formatting and they are stored in a continuous sequence of blocks; </li><li>  free inodes - a bitmap of free / occupied index nodes that occupies exactly 1 block; </li><li>  free blocks - bitmap of free / occupied blocks, also takes 1 block; </li><li>  super block - obviously, the superblock of our file system;  it stores the block size, the number of blocks in the table of index nodes, the index node number of the root folder; </li></ul><br><br>  Actually similar disk layout is used in other file systems.  For example, a <a href="http://www.nongnu.org/ext2-doc/ext2.html">group of blocks</a> in ext2 / 3 has a similar structure, only ext2 / 3 works with several such groups, and we confine ourselves to one.  This format is considered obsolete, and new file systems are moving away from it.  For example, btrfs uses a more interesting <a href="http://lwn.net/Articles/342892/">scheme</a> , which gives a number of advantages over the ext family.  But let us return to our sheep. <br><br>  We determined that the superblock and bitmaps of blocks / index nodes occupy the first three blocks of the file system, and how much does the table of index nodes occupy?  Generally speaking, it is not correct to fix this value, it strongly depends on how the file system will be used.  For example, if you are going to store mostly large files, then it makes sense to make this table smaller, because it is unlikely that you will run out of index nodes earlier than disk space.  On the other hand, if you intend to store many small files, there is a chance to exhaust index nodes earlier than free disk space if the table is too small. <br><br>  In the mke2fs utility, which is used to format a disk for ext2 / 3 file systems, there is a <a href="http://linux.about.com/library/cmd/blcmdl8_mkfs.ext2.htm">-i switch</a> that indicates how much disk you need to create an index node, i.e., if you specify -i 16384, then for every 16 kilobytes of disk space created by index node.  I will use the simplest option - I will create an index node for every 16 KB of disk space, without the possibility of changing this value (for now at least). <br><br>  The last common point to be affected is the block size.  The file system can work with blocks of different sizes, I will support blocks of 512, 1024, 2048 and 4096 bytes - nothing unusual.  This is due to the fact that it is easier to work with blocks that fit into the page (we will return to this a bit later), but it is not necessary to do this at all, moreover, large block sizes can contribute to greater productivity. <br><br>  In general, choosing the right block size for classic file systems is a rather interesting topic.  For example, in a <a href="http://www.amazon.com/Modern-Operating-Systems-3rd-Edition/dp/0136006639">well-known book on OS</a> , information is provided that, with a block size of 4 Kb, 60 - 70% of files will be placed in one block.  The more files fit in one block, the less fragmentation, the higher the read speed, but more space is wasted.  In our case, everything else, the block size is the main file system limiter - with a block size of 4 KB, the bitmap of free blocks can cover only 128 MB of disk space. <br><br><h4>  Back to practice </h4><br><br>  It's time to write some code.  Let's start with the structures that we will use, starting with the simplest: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_disk_super_block</span></span></span><span class="hljs-class"> {</span></span> __be32 dsb_magic; __be32 dsb_block_size; __be32 dsb_root_inode; __be32 dsb_inode_blocks; };</code> </pre> <br><br>  The structure of the super block is stored at the very beginning of disk block 0.  It begins with a magic number, from which we can make sure that it is aufs that is stored on the disk (I mentioned this last time). <br><br>  Given that we will support different block sizes (which, however, will not require any effort from us), we need to know what size is used in this particular file system, and the superblock stores this information for us in the dsb_block_size field. <br><br>  In addition, the number of blocks in the table of index nodes is stored in the dsb_inode_blocks field - I have already mentioned that the size of this table may be different. <br><br>  The dsb_root_inode field stores the index node number of the root directory.  Of course, it is not necessary to store it, you can simply use a fixed number for the root, but then the structure will be completely empty, and with it it seems more solid. <br><br>  Notice that fixed-size types are used for fields.  This is because we will write this structure to disk "as is".  However, fix the size is not enough, you need to fix the order of bytes.  I will use <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2580%25D1%258F%25D0%25B4%25D0%25BE%25D0%25BA_%25D0%25B1%25D0%25B0%25D0%25B9%25D1%2582%25D0%25BE%25D0%25B2">big endian</a> , it‚Äôs a network byte order, which is indicated by the type name (__be32). <br><br>  In principle, it is not particularly important which order to use, the main thing is that it was fixed.  Although it is believed that little endian platforms are more, and therefore it is preferable to use it, but let's get back to business. <br><br>  The type __be32, in fact, is synonymous with uint32_t, but its name emphasizes that the variable stores data in big endian (a sort of documentation method).  In the core there is a similar type for little endian. <br><br>  Now let's see, perhaps, the most important file system structure - the index node: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_disk_inode</span></span></span><span class="hljs-class"> {</span></span> __be32 di_first; __be32 di_blocks; __be32 di_size; __be32 di_gid; __be32 di_uid; __be32 di_mode; __be64 di_ctime; };</code> </pre><br><br>  The index node, first of all, determines where the file / directory is stored on the disk.  Ways to store files can be very diverse, I will use quite simple - one extent per file.  An extent is a continuous sequence of disk blocks, i.e. each file / directory will be stored in a continuous sequence of blocks.  The di_first and di_blocks fields store the first block and the number of blocks in the extent, respectively. <br><br>  Then you say, and how in such a file system to append data to the end of the file and add entries to the directory?  Indeed, a full implementation of operations that lead to a change in the size of a file / directory, with this method of storage is a headache (not to mention the effectiveness of such an implementation), so we will not do a full implementation of the record, but more on this in another article. <br><br>  However, such an organization has some positive aspects - the files are not fragmented, and this has a good effect on the sequential read speed.  Therefore, such a structure can be remarkably used in read-only file systems, for example, in <a href="http://ru.wikipedia.org/wiki/ISO_9660">iso 9660</a> (although it already supports file fragmentation). <br><br>  It is clear that extents are not a tricky structure and do little, but along with the classic tree structures for storing files on disk, they turn out to be a pretty good option for file systems with fragmentation. <br><br>  In addition to pointing out to disk space, the index node also stores the actual file size in the di_size field.  And the truth is, the file size is not obliged to fall exactly in the block size. <br><br>  The di_gid and di_uid fields are group and user IDs.  To save such information in the file system does not always make sense, I inserted them for example. <br><br>  The di_mode field - stores access rights for the group of the file owner, the file owner and all other users.  Since I saved the group and the owner, then the access rights should be kept.  Another di_mode stores the type of the object that describes the index node, for example, is the object a directory or file. <br><br>  Finally, the di_ctime field stores the date the file was created.  Usually, file systems store along with the creation date also the dates of the last modification and file access, but we will score on them. <br><br><h4>  Format the disk </h4><br><br>  So, when we determined the file system storage format on the disk, it's time to write a utility that will bring the disk into the correct format.  A Linux disk is just a file (it is appropriate to recall the <a href="http://en.wikipedia.org/wiki/Everything_is_a_file">well-known Unix design solution</a> ).  So, formatting a disk is simply writing the necessary data to the file.  And the necessary data in our case is the superblock, bitmaps, and the root directory (empty for now). <br><br>  In order not to turn the article on the Linux kernel into an article on C ++ (especially in the light of <a href="http://www.drdobbs.com/cpp/linus-and-c/229700143">Linus‚Äôs relationship to the latter</a> ), I suggest you take a look at the source code on github yourself, but briefly go through the main classes: <br><br><ul><li>  Configuration - the class that stores the configuration of the future file system (block size, index nodes table size, number of blocks, device file name). </li><li>  Block - represents one disk block.  Data is written and read from disk in blocks. </li><li>  BlocksCache - provides access to blocks. </li><li>  Inode - wrapper over the index node.  It hides the byte transforms, the writing and reading of the index node data from the block. </li><li>  SuperBlock - wrapper on the superblock.  As in the case of inode, it hides writing and reading from a block, fills bitmaps, selects index nodes and blocks, that is, it actually performs formatting. </li></ul><br><br>  The utility allows you to change the block size using the -s or --block_size keys, and the number of blocks that will be used for the file system via the -b or --blocks keys. <br><br>  In general, the utility is not at all tricky, but many may rightly think that the code is too sophisticated for such a simple task.  The fact is that first of all we will teach the file system to read from the disk, and then we will begin to write.  But in order to test the performance of our driver, you need to write something to the disk.  Therefore, we will later add to the utility the ability to import files / directories when formatting a disk, which will help us a lot. <br><br><h4>  Back to file system </h4><br><br>  Now back to our downloadable module.  We begin by reading the superblock from the disk.  But before that, we will create another structure for the superblock: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_super_block</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> asb_magic; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> asb_inode_blocks; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> asb_block_size; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> asb_root_inode; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> asb_inodes_in_block; };</code> </pre><br><br>  This structure will represent the superblock in memory.  The idea is simple - we read from the aufs_disk_super_block disk and convert it to aufs_super_block by converting the order of bytes and compute various useful data along the way (in this case, asb_inodes_in_block).  In general, this structure is a great place for any file system global variables. <br><br>  Recalling the last post, we already have three structures for representing the superblock: <br><br><ul><li>  super_block - the structure that the kernel provides; </li><li>  aufs_disk_super_block - structure that is stored on disk; </li><li>  aufs_super_block is another structure that will be stored in memory; </li></ul><br><br>  Two structures are understandable, but why do we need a third one?  The fact is that Linux does not know anything about our file system, so it‚Äôs likely that super_block (like inode, like any other Linux kernel structure) does not contain all the fields we need.  Therefore, we are forced to start our own additional structures and link them with the structures of the nucleus.  How to connect them? <br><br>  In the core there are two common ways of organizing such a connection (let's call them composition and inheritance).  For the super block we will use the composition.  This method requires support from the kernel - there is an interesting field inside <a href="">the super_block structure</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">super_block</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *s_fs_info; ... };</code> </pre><br><br>  In this field we can save a pointer to any data, in fact, there we will save a pointer to aufs_super_block.  And wherever we have access to the super_block structure, we can access the aufs_super_block structure.  But yes, these are all lyrics; our task is to read the superblock from the disk.  To do this, we will write a couple of functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> struct aufs_super_block *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aufs_super_block_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct super_block *sb)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_super_block</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">asb</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_super_block</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kzalloc</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_super_block</span></span></span><span class="hljs-class">), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GFP_NOFS</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_disk_super_block</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dsb</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">buffer_head</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bh</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!asb) { pr_err(<span class="hljs-string"><span class="hljs-string">"aufs cannot allocate super block\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } bh = sb_bread(sb, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!bh) { pr_err(<span class="hljs-string"><span class="hljs-string">"cannot read 0 block\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> free_memory; } dsb = (struct aufs_disk_super_block *)bh-&gt;b_data; aufs_super_block_fill(asb, dsb); brelse(bh); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (asb-&gt;asb_magic != AUFS_MAGIC) { pr_err(<span class="hljs-string"><span class="hljs-string">"wrong magic number %u\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)asb-&gt;asb_magic); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> free_memory; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asb; free_memory: kfree(asb); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre><br><br>  The first thing that this function does is allocate memory for the structure of the superblock.  There are quite a few ways to allocate memory in the kernel, <a href="">kzalloc</a> (and <a href="">kmalloc</a> along with it) is the easiest.  It works like a regular malloc, only requires the transfer of an additional set of flags.  The difference between kzalloc and kmalloc is that the first one fills the allocated memory with zeros (which simply boils down to passing an additional flag inside kmalloc). <br><br>  I mentioned the flags, why are they?  The fact is that different parts of the kernel must satisfy different guarantees.  For example, in the context of processing a network packet, you cannot block, and to use <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D1%258F%25D0%25BC%25D0%25BE%25D0%25B9_%25D0%25B4%25D0%25BE%25D1%2581%25D1%2582%25D1%2583%25D0%25BF_%25D0%25BA_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D0%25B8">DMA you</a> need to allocate memory in a special region of memory.  Since memory allocation is used everywhere, a ‚Äúsettings‚Äù mechanism is required.  In our case, the GFP_NOFS flag is used, which says that the memory allocator will not access the file system tools, which is logical when implementing the file system, although in this particular case it is not necessary. <br><br>  Naturally in the core, do not forget to check that the memory was allocated without problems. <br><br>  The next crucial point is the call to the <a href="">sb_bread</a> function.  Here it is reading from the disk!  The function takes a pointer to the superblock and the block number to be read is quite simple.  The function returns a pointer to the <a href="">buffer_head</a> structure, and the block data itself is accessible via the b_data field of this structure. <br><br>  Naturally, in this case, do not forget to check that the reading was successful. <br><br>  Next we simply convert the pointer to char to a pointer to the aufs_disk_super_block structure.  The aufs_super_block_fill function fills the aufs_super_block structure using aufs_disk_super_block without doing anything unusual: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aufs_super_block_fill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct aufs_super_block *asb, struct aufs_disk_super_block </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dsb)</span></span></span><span class="hljs-function"> </span></span>{ asb-&gt;asb_magic = be32_to_cpu(dsb-&gt;dsb_magic); asb-&gt;asb_inode_blocks = be32_to_cpu(dsb-&gt;dsb_inode_blocks); asb-&gt;asb_block_size = be32_to_cpu(dsb-&gt;dsb_block_size); asb-&gt;asb_root_inode = be32_to_cpu(dsb-&gt;dsb_root_inode); asb-&gt;asb_inodes_in_block = asb-&gt;asb_block_size / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct aufs_disk_inode); }</code> </pre><br><br>  As it is not difficult to guess, the function be32_to_cpu converts the number from big endian to the byte order used by the platform. <br><br>  After we have finished working with the block, we need to release it; for this, the <a href="">brelse</a> function <a href="">exists</a> .  It actually just reduces the reference count to this block.  The block will not be released immediately, as soon as the reference count reaches 0 ‚Äî for blocks in the kernel, the garbage collector works, which without serious need will not release the block.  The reason is that reading blocks from a disk is a rather expensive operation, so it is reasonable to support the cache of read blocks, and when you read the same block again, return the already read block (if, of course, it is still present in the cache). <br><br>  The last thing we do is check the magic number, you need to make sure that the disk actually contains aufs. <br><br>  For those who have paid attention to goto, goto is used quite often in the kernel.  Basically, for the organization of error handling - there are no exceptions in the C language, and the idea of ‚Äã‚Äãdividing the main execution path and error handling is quite attractive, then goto comes to the rescue.  In this case, the use of goto gives almost nothing - I intend to put it here, as an example of why it is used.  In general, among the developers of the goto haters kernel there are not so many, so there are places in the code that are abusing the <a href="http://www.cs.utexas.edu/users/EWD/transcriptions/EWD02xx/EWD215.html">hapless operator</a> - you should be ready for this. <br><br>  The attentive reader probably paid attention to one discrepancy.  As I said, file systems can work with different block sizes, and this information is most likely stored in the superblock.  So what is the size of the block that the sb_bread function will read when reading a superblock?  In our case, everything is simple, by default, the block size is set to the block size of the block device (how many blocks ...).  And we hope that its size is sufficient for the structure of the superblock - in our case it is. <br><br>  We wrote a function to read the superblock, we will call it from aufs_fill_super (see previous post), now it looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aufs_fill_sb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct super_block *sb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> silent)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inode</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">root</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_super_block</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">asb</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_super_block_read</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sb</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!asb) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; sb-&gt;s_magic = asb-&gt;asb_magic; sb-&gt;s_fs_info = asb; sb-&gt;s_op = &amp;aufs_super_ops; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sb_set_blocksize(sb, asb-&gt;asb_block_size) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { pr_err(<span class="hljs-string"><span class="hljs-string">"device does not support block size %u\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)asb-&gt;asb_block_size); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; } root = aufs_inode_get(sb, asb-&gt;asb_root_inode); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(root)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(root); sb-&gt;s_root = d_make_root(root); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sb-&gt;s_root) { pr_err(<span class="hljs-string"><span class="hljs-string">"aufs cannot create root\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  As I already mentioned, we save the pointer to aufs_super_block in the s_fs_info field.  In addition, we set the correct block size by calling <a href="">sb_set_blocksize</a> .  As the comment inside the function says, the block size should be from 512 bytes to the page size - this is the reason for our choice of block sizes.  If the file system should work with a large block size, additional efforts will be required (though not so much). <br><br>  So we allocated aufs_super_block in dynamic memory, which means we have to release it.  To do this, we need to make some changes to another function from the previous post: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aufs_put_super</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct super_block *sb)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_super_block</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">asb</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_super_block</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sb</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_fs_info</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (asb) kfree(asb); sb-&gt;s_fs_info = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; pr_debug(<span class="hljs-string"><span class="hljs-string">"aufs super block destroyed\n"</span></span>); }</code> </pre><br><br>  It is not hard to guess that the kfree function is a pair for the kmalloc function, more precisely even the function, since there are several kfree implementations in the kernel (still <a href="">here</a> and <a href="">here</a> ), but we will not go into details. <br><br>  Another important change inside the aufs_fill_sb function is the aufs_inode_get call.  In the last article we created a fictitious inode, now we will learn how to read them from disk. <br><br>  But before that, I‚Äôll draw your attention to an interesting point - the <a href="">IS_ERR</a> and <a href="">PTR_ERR pair</a> .  These are simple conversions of pointers to a number and back, based on the fact that the kernel has full information about the location of its memory and, accordingly, which bits of the pointer can be used for other than its intended purpose.  This is the simplest example of using knowledge about the structure of a pointer; there are more interesting ones, and <a href="">not only in the core</a> . <br><br>  We will start working with index nodes with an expansion of the <a href="">super_operations</a> structure, which we met last time.  Now we fill it in this way: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">super_operations</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_super_ops</span></span></span><span class="hljs-class"> = {</span></span> .alloc_inode = aufs_inode_alloc, .destroy_inode = aufs_inode_free, .put_super = aufs_put_super, };</code> </pre><br><br>  We added a couple more pointers to the aufs_inode_alloc and aufs_inode_free functions.  These are specific functions for allocation and inode release, then we will encounter SLAB (in fact, we have already encountered this beast in the form of kmalloc) and RCU (quite a bit). <br><br>  So, the memory allocation for the index node will start with the definition of another structure - the representation of the index node in memory (as was the case with the superblock): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_inode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inode</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ai_inode</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ai_block; };</code> </pre><br><br>  This time we will use "inheritance" instead of composition.  Inheritance in C does not look tricky (which is not surprising, given that C does not support inheritance).  To do this, we simply make the first field of the aufs_inode structure the base structure (base class) - the <a href="">inode</a> structure.  Thus, a pointer to aufs_inode can be used as a pointer to an inode, as well, and vice versa (if of course we know for sure that this pointer refers to aufs_inode). <br><br>  Compared to composition, ‚Äúinheritance‚Äù does not in itself require support from the kernel, moreover, it is more profitable from the point of view of the number of memory allocations - one allocation is required for each index node instead of two (as was the case with the superblock).  Also, unlike the superblock, almost all the required fields are already present inside the inode.  However, this is the exception rather than the rule, because our file system stores the data on the disk is very simple. <br><br>  To allocate memory for index nodes, we will use the SLAB allocator.  SLAB allocator - caching allocator that allows you to allocate blocks of memory of the same size.  It is not difficult to guess that due to this limitation, you can simplify memory management and speed up memory allocation.  The SLAB allocator asks the OS for large chunks of memory and allocates small areas of them on demand, respectively, requests to the OS memory manager occur less frequently, and user requests are satisfied faster. <br><br>  But initially the gain in speed of memory allocation when using SLABs was not only (and not so much) due to simpler memory management, but by reducing the cost of initializing this memory.  Indeed, the SLAB allocator is often used not just to select objects of the same size, but to select objects of the same type, which allows you to skip the initialization of some fields when you re-allocate one chunk of memory.  For example, mutexes, spinlockes, and other similar objects, when an object is released, most likely have the ‚Äúcorrect‚Äù meaning, and when re-allocated, they do not need to be reinitialized.  For details and measurements, please refer to the original <a href="">article</a> . <br><br>  Currently, Linux has three different types of SLAB allocators - SLAB, SLUB and SLOB.  We will not go into the differences between them, they provide the same interface.  So, to create a SLAB allocator, we will use the following function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aufs_inode_cache_create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ aufs_inode_cache = kmem_cache_create(<span class="hljs-string"><span class="hljs-string">"aufs_inode"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct aufs_inode), <span class="hljs-number"><span class="hljs-number">0</span></span>, (SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD), aufs_inode_init_once); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (aufs_inode_cache == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  When creating a SLAB, the kmem_cache_create function <a href="">is</a> passed the name, the size of the object, the initialization function (a function that will be called only once when the object is first allocated), and a couple more parameters, the essence of which I will not go into.  But in order not to leave those who are interested at all without information, I will say that creating SLAB for index nodes in all file systems looks the same - the differences are not significant. <br><br>  We will call the aufs_inode_cache_create function when the module is loaded, before registering the file system in the kernel.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is also a pair function that we will call when the module is unloaded:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aufs_inode_cache_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ rcu_barrier(); kmem_cache_destroy(aufs_inode_cache); aufs_inode_cache = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmem_cache_destroy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">destroys the SLAB allocator. By the time of the destruction, all objects from this cache should be freed, otherwise we will receive an unpleasant error message in the system log, along with a whole bunch of difficult to catch troubles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the promised touch RCU. In a nutshell, RCU is a common synchronization mechanism in the kernel (as well as secure memory release for lock-free algorithms). RCU in itself deserves a separate article and there is </font></font><a href="http://habrahabr.ru/company/ifree/blog/206984/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">such</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Habr√© </font><font style="vertical-align: inherit;">. Moreover, the creator of this technique, and in combination, the maintener RCU in the Linux kernel wrote a whole </font></font><a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">book</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in which he touched his brainchild too. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But we need to deal only with </font><a href=""><font style="vertical-align: inherit;">rcu_barrier</font></a><font style="vertical-align: inherit;"> from the entire zoo of RCU functions </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(as with kfree, there is another implementation of this function </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">If it is simple, then this function will wait until all deferred work on the protected RCU data is completed, after which it will return control to the one who called it, respectively, the blocking function. </font><font style="vertical-align: inherit;">Why do we need it, we will see below. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's return to the memory allocation, consider the function already mentioned above:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">struct inode *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aufs_inode_alloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct super_block *sb)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_inode</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_inode</span></span></span><span class="hljs-class"> *) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kmem_cache_alloc</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_inode_cache</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GFP_KERNEL</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;i-&gt;ai_inode; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It uses the previously created SLAB allocator (through one of the </font></font><a href="http://lxr.free-electrons.com/ident%3Fi%3Dkmem_cache_alloc%3Bv%3D3.14"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmem_cache_alloc</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementations </font><font style="vertical-align: inherit;">) and returns a pointer to the inode ‚Äî nothing unusual, but the release function is a bit more interesting:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aufs_inode_free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct inode *inode)</span></span></span><span class="hljs-function"> </span></span>{ call_rcu(&amp;inode-&gt;i_rcu, aufs_free_callback); }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we again face RCU. Here it is worth saying a few words about lock-free algorithms, the problem of such algorithms is that without locks there is no guarantee that the object is not used in parallel by any other execution thread, which means it is impossible to free the memory occupied by this object - another thread can store a pointer him Therefore, in lock-free algorithms, you have to think about strategies for safe memory release, and RCU provides the means to solve this problem. All implementations of the </font></font><a href="http://lxr.free-electrons.com/ident%3Fi%3Dcall_rcu%3Bv%3D3.14"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">call_rcu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">postpone the execution of a certain function (in our case, the release function aufs_free_callback) until it becomes safe. And the rcu_barrier already mentioned above is waiting for the completion of all deferred functions.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You're tired? </font><font style="vertical-align: inherit;">It's okay, we are already approaching the final. </font><font style="vertical-align: inherit;">Now we will read the index node from the disk. </font><font style="vertical-align: inherit;">To do this, I wrote the already mentioned aufs_inode_get function:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">struct inode *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aufs_inode_get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct super_block *sb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> no)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_super_block</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">asb</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AUFS_SB</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sb</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">buffer_head</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bh</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_disk_inode</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">di</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_inode</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ai</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inode</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inode</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> block = <span class="hljs-number"><span class="hljs-number">0</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; inode = iget_locked(sb, no); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!inode) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERR_PTR(-ENOMEM); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(inode-&gt;i_state &amp; I_NEW)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inode; ai = AUFS_INODE(inode); block = aufs_inode_block(asb, no); offset = aufs_inode_offset(asb, no); pr_debug(<span class="hljs-string"><span class="hljs-string">"aufs reads inode %u from %u block with offset %u\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)no, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)block, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)offset); bh = sb_bread(sb, block); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!bh) { pr_err(<span class="hljs-string"><span class="hljs-string">"cannot read block %u\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)block); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> read_error; } di = (struct aufs_disk_inode *)(bh-&gt;b_data + offset); aufs_inode_fill(ai, di); brelse(bh); unlock_new_inode(inode); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inode; read_error: pr_err(<span class="hljs-string"><span class="hljs-string">"aufs cannot read inode %u\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)no); iget_failed(inode); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERR_PTR(-EIO); }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will start the explanation with simple moments - the functions AUFS_SB and AUFS_INODE allow you to get a pointer to the structures aufs_super_block and aufs_inode, via pointers to super_block and inode, respectively. </font><font style="vertical-align: inherit;">I will not give them the code (it is quite simple), because I have already described above how these structures are related. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Functions aufs_inode_block and aufs_inode_offset allow you to get the block number and the offset inside the block by the index node number - no magic, simple arithmetic, so I will not dwell on them either. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now the interesting point - a couple of functions </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iget_locked</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unlock_new_inode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. As in the case of blocks, the kernel supports the inode cache, this is necessary not only in order not to once again read the index node from the disk. The fact is that one and the same file / directory can be opened by several processes at once, in this case all of them must operate with one instance of inode so that they can be synchronized with each other. A similar reasoning holds true for blocks, perhaps even to a greater degree, so this also applies to the block.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So the function idet_locked first looks for the inode in the cache and allocates memory for a new one if the inode is not found. If the index node was re-allocated and not found in the cache, the I_NEW flag will be set in the i_state field and the spinlock of this node will be captured (i_lock field). Therefore, our function first checks the i_state field, and if the I_NEW flag is cleared, simply return the cached inode. Otherwise, we have to fill in the inode, for this we read the necessary block from the disk (using the already known sb_bread). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The aufs_inode_fill function is exactly engaged in filling:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aufs_inode_fill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct aufs_inode *ai, struct aufs_disk_inode </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *di)</span></span></span><span class="hljs-function"> </span></span>{ ai-&gt;ai_block = be32_to_cpu(di-&gt;di_first); ai-&gt;ai_inode.i_mode = be32_to_cpu(di-&gt;di_mode); ai-&gt;ai_inode.i_size = be32_to_cpu(di-&gt;di_size); ai-&gt;ai_inode.i_blocks = be32_to_cpu(di-&gt;di_blocks); ai-&gt;ai_inode.i_ctime.tv_sec = be64_to_cpu(di-&gt;di_ctime); ai-&gt;ai_inode.i_mtime.tv_sec = ai-&gt;ai_inode.i_atime.tv_sec = ai-&gt;ai_inode.i_ctime.tv_sec; ai-&gt;ai_inode.i_mtime.tv_nsec = ai-&gt;ai_inode.i_atime.tv_nsec = ai-&gt;ai_inode.i_ctime.tv_nsec = <span class="hljs-number"><span class="hljs-number">0</span></span>; i_uid_write(&amp;ai-&gt;ai_inode, (<span class="hljs-keyword"><span class="hljs-keyword">uid_t</span></span>)be32_to_cpu(di-&gt;di_uid)); i_gid_write(&amp;ai-&gt;ai_inode, (<span class="hljs-keyword"><span class="hljs-keyword">gid_t</span></span>)be32_to_cpu(di-&gt;di_gid)); }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Again, no magic, except for a couple of functions </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i_uid_write</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i_gid_write</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . But they do not do anything special - just assign values ‚Äã‚Äãto the corresponding fields. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, I will focus on the representation of time as a </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">timespec</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> structure </font><font style="vertical-align: inherit;">, this structure consists of only a couple of numbers ‚Äî the number of seconds and nanoseconds. That is, potentially time can be stored fairly accurately. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, at the very end of the function, we must release the spinlock and return the pointer, for this purpose the unlock_new_inode function is used.</font></font><br><br><h4>  Instead of conclusion </h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fasting turned out really great and even so does not cover all the moments. I tried to explain all the key parts of the implementation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All sources are available by </font></font><a href="https://github.com/krinkinmu/aufs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reference</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . There are now two folders in the repository - kern and user. As it is not difficult to guess, one stores the code of our module, the second - the code of the utility for formatting. The code has become more, and therefore the probability of errors in it has become more - comments, corrections, any constructive criticism and pull requests are welcome. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To get a disk image for mounting, you can do this:</font></font><br><br><pre> <code class="bash hljs">dd bs=1M count=100 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=image ./mkfs.aufs ./image</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you can use the image file as shown in the previous post. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some examples of debugging output have been removed from the code examples in this article, but if you use the code from the repository, you can verify that the module is working using the dmesg command.</font></font></div><p>Source: <a href="https://habr.com/ru/post/224589/">https://habr.com/ru/post/224589/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224569/index.html">Acronis Disk Director: split disks without problems</a></li>
<li><a href="../224571/index.html">Basis for a smart room, or how an Arduino lives in a dorm</a></li>
<li><a href="../224573/index.html">One step to new format, PM</a></li>
<li><a href="../224579/index.html">Why in search without linguistics can not do?</a></li>
<li><a href="../224585/index.html">Another JavaScript Language - ColaScript</a></li>
<li><a href="../224593/index.html">Lambda expressions in java 8</a></li>
<li><a href="../224595/index.html">Ciklum Speakers' Corner on Mobile Development with Xamarin, June 6, 6:30 p.m.</a></li>
<li><a href="../224597/index.html">Ilon Mask presented the passenger version of the spacecraft Dragon</a></li>
<li><a href="../224599/index.html">Lumo Lift: a miniature fitness tracker and "controller" posture</a></li>
<li><a href="../224601/index.html">Online LaTeX editor Papeeria. Spring news</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>