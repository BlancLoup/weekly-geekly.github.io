<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell. The problem of the sages and caps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Three wise men argued which of them is the wisest. To find out the truth, everyone put a random color cap on his head. Every sage sees the colors of t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell. The problem of the sages and caps</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_d/xr/f2/_dxrf2c0g_mvkpeied_r1uscstw.png"></div><blockquote>  Three wise men argued which of them is the wisest.  To find out the truth, everyone put a random color cap on his head.  Every sage sees the colors of the caps of his opponents, but does not see his own.  The winner is the one who can determine the color of his cap. <br><br>  It so happened that all three pulled the caps white.  A passerby passing by tells them: ‚Äúa white cap is put on one of you‚Äù.  After some time, the smartest of the wise men exclaimed: ‚ÄúI have a white cap !!!‚Äù. <br><br>  How did he figure it out? <br></blockquote>  There is a certain sequence of reasoning that led our sage to the right answer.  We will try to model this reasoning. <br><a name="habracut"></a><br><h6>  How did he figure it out? </h6><br>  This problem can be formulated for any number of wise men.  Let's consider the easiest option. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Two wise men sit, each wearing a white cap.  Both know that there is at least one white cap.  Then one of the wise men argues: ‚Äúif I had a cap of any non-white on me, then my opponent would have guessed that there is a white cap on it.  But he is silent.  So white cap on me! " <br><br>  When there are three wise men, one of them argues like this: ‚ÄúIf I‚Äôm not wearing a white cap, the other sage will think so.  <i>... (further there are arguments from the problem about two wise men) ...</i> one of them would have guessed that there is a white cap on it.  But they both are silent.  So my first guess is wrong, and I have a white cap! ‚Äù <br><br>  By induction, we can extend this reasoning to any number of sages.  Further in the article, we will model the situation with the three wise men. <br><br><h6>  Task statement </h6><br>  In our original formulation, the problem is not completely correct.  It is not clear how much time must pass to conclude that the other sage did not guess the color of his cap.  Let me rephrase the problem more correctly. <br><blockquote>  There are three wise men.  Each is wearing a cap, either black or white.  Everyone knows the colors of his opponents, but does not know his own. <br><br>  On the first day, they are told that there is at least one white cap.  They think all day and vote at the end of the day independently of each other.  They give one of two possible results: ‚ÄúI know my color,‚Äù ‚ÄúI don't know my color.‚Äù <br><br>  On the second day, they become acquainted with the "voting results" of each of the opponents.  Then they think again all day and vote again at the end of the day. <br><br>  and so on. <br><br>  Question.  How will each of the sages vote on each of the days under different initial conditions? <br></blockquote><br><h6>  Code </h6><br>  To begin with we will describe our main types with which we will work. <br><br><pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Color</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Black</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">White</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> = [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Color</span></span></span><span class="hljs-class">] fullState :: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class">] fullState = do c1 &lt;- [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Black</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">White</span></span></span><span class="hljs-class">] c2 &lt;- [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Black</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">White</span></span></span><span class="hljs-class">] c3 &lt;- [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Black</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">White</span></span></span><span class="hljs-class">] return [c1, c2, c3] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateInfo</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> -&gt; a stateInfoColor :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateInfo</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Color</span></span></span><span class="hljs-class"> stateInfoColor i state = state !! i stateInfoAnyWhite :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateInfo</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> stateInfoAnyWhite state = or $ map (\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class"> == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">White</span></span></span><span class="hljs-class">) state</span></span></code> </pre> <br>  The state of our world (which cap is worn) is described using the <i>State</i> type.  In the variable <i>fullState</i> we store a list of all possible states. <br><br>  The <i>StateInfo</i> type describes some information that we can calculate from the state of the world.  For example, using <i>stateInfoColor</i> we can isolate the color of the cap for a particular sage.  And using <i>stateInfoAnyWhite,</i> we calculate whether the statement that all caps are white is true for a given state. <br><br>  Next come the more complex structures. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Knowledge</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> -&gt; (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class">) knowledgeAbout :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateInfo</span></span></span><span class="hljs-class"> a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Knowledge</span></span></span><span class="hljs-class"> knowledgeAbout stateInfo state = let info = stateInfo state in \s -&gt; stateInfo s == info knowledgeIsTrue :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateInfo</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Knowledge</span></span></span><span class="hljs-class"> knowledgeIsTrue si _ state = si state knowledgeAboutColor1 :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Knowledge</span></span></span><span class="hljs-class"> knowledgeAboutColor1 = knowledgeAbout $ stateInfoColor 0 knowledgeAboutColor2 :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Knowledge</span></span></span><span class="hljs-class"> knowledgeAboutColor2 = knowledgeAbout $ stateInfoColor 1 knowledgeAboutColor3 :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Knowledge</span></span></span><span class="hljs-class"> knowledgeAboutColor3 = knowledgeAbout $ stateInfoColor 2</span></span></code> </pre><br>  The <i>Knowledge</i> type describes some ‚Äúknowledge‚Äù about the world.  As we will see, the <i>Knowledge</i> type will be combined with the <i>StateInfo</i> type in different ways.  This is a very important type.  I will dwell on it in more detail. <br><br>  As can be seen from the definition of <i>Knowledge</i> , this is a function that, from the state of the world, computes some filtering function.  Those.  we transfer the "present" state of the world, and it gives out a certain subset of possible states that do not contradict our knowledge. <br><br>  For example, the <i>knowledgeAboutColor1</i> function is knowledge about the color of the first sage.  If I give the state [White, Black, Black], in which the color of the first sage is white, then it will return a function that filters out all the states in which the first sage has a different color. <br><br>  We will not have special structures denoting sage.  We will reason in terms of "knowledge."  Here is an example of such reasoning. <br><br> <code>      =     +     +   ,      <br> <br>      =      +   <br></code> <br><br>  Here are some more helper functions in terms of <i>Knowledge</i> and <i>StateInfo</i> . <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">knowledgeAnd</span></span> :: [<span class="hljs-type"><span class="hljs-type">Knowledge</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Knowledge</span></span> knowledgeAnd list stateTrue = \s -&gt; and $ map (\f -&gt; f stateTrue s) list stateInfoList :: [<span class="hljs-type"><span class="hljs-type">StateInfo</span></span> a] -&gt; <span class="hljs-type"><span class="hljs-type">StateInfo</span></span> [a] stateInfoList sil state = map (\si-&gt; si state) sil knowledgeImply :: <span class="hljs-type"><span class="hljs-type">Knowledge</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Knowledge</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">StateInfo</span></span> <span class="hljs-type"><span class="hljs-type">Bool</span></span> knowledgeImply knowledge1 knowledge2 state = and $ map (\(b1, b2) -&gt; not $ and [b1, not b2]) $ map (\s -&gt; (knowledge1 state s, knowledge2 state s)) fullState</code> </pre><br>  The <i>knowledgeAnd</i> function simply combines knowledge into one. <br><br>  The action of the <i>stateInfoList</i> function <i>is</i> obvious from its type. <br><br>  The third function of <i>knowledgeImply more</i> interesting.  It is a statement that the second knowledge is derived from the first knowledge. <br><br>  Next comes the code directly related to the task. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KnowledgeList</span></span></span><span class="hljs-class"> = [(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Knowledge</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Knowledge</span></span></span><span class="hljs-class">)] insightList :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KnowledgeList</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateInfo</span></span></span><span class="hljs-class"> [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class">] insightList knowledgeList = stateInfoList $ map knowledgeInsight knowledgeList knowledgeInsight :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Knowledge</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Knowledge</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateInfo</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> knowledgeInsight (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">currentKnowledge</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">targetKnowledge</span></span></span><span class="hljs-class">) = knowledgeImply currentKnowledge targetKnowledge manStart_1 = knowledgeAnd [knowledgeAboutColor2, knowledgeAboutColor3, knowledgeAbout stateInfoAnyWhite] manStart_2 = knowledgeAnd [knowledgeAboutColor1, knowledgeAboutColor3, knowledgeAbout stateInfoAnyWhite] manStart_3 = knowledgeAnd [knowledgeAboutColor1, knowledgeAboutColor2, knowledgeAbout stateInfoAnyWhite] knowledgeList_1 :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KnowledgeList</span></span></span><span class="hljs-class"> knowledgeList_1 = [(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">manStart_1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">knowledgeAboutColor1</span></span></span><span class="hljs-class">), (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">manStart_2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">knowledgeAboutColor2</span></span></span><span class="hljs-class">), (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">manStart_3</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">knowledgeAboutColor3</span></span></span><span class="hljs-class">)] insightList_1 :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateInfo</span></span></span><span class="hljs-class"> [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class">] insightList_1 = insightList knowledgeList_1</span></span></code> </pre><br>  The <i>KnowledgeList</i> type is something like a list of sages.  For each sage we have a pair of knowledge.  The first element is his current knowledge.  The second element is what he is trying to figure out, namely the color of his hat. <br><br>  The <i>knowledgeInsight</i> function calculates whether a particular sage could determine his color.  In other words, does the knowledge to which he aspires flow from the knowledge that he possesses.  Our magical <i>knowledgeImply</i> function is used. <br><br>  Variables <i>manStart_1</i> , <i>manStart_2</i> , <i>manStart_3</i> - this is the initial knowledge of the relevant sages. <br><br>  The variable <i>knowledgeList_1</i> is a list of all the wise men on the first day (their knowledge). <br><br>  The <i>insightList_1</i> variable is the first day‚Äôs voting results. <br><br>  Having the results of the voting, we can compile a new list of knowledge of the sages. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">addNewKnowledge</span></span> :: <span class="hljs-type"><span class="hljs-type">Knowledge</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">KnowledgeList</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">KnowledgeList</span></span> addNewKnowledge newKnowledge knowledgeList = flip map knowledgeList $ \(oldKnowledge, targetKnowledge) -&gt; (knowledgeAnd [oldKnowledge, newKnowledge], targetKnowledge) knowledgeList_2 :: <span class="hljs-type"><span class="hljs-type">KnowledgeList</span></span> knowledgeList_2 = addNewKnowledge (knowledgeAbout insightList_1) knowledgeList_1 insightList_2 :: <span class="hljs-type"><span class="hljs-type">StateInfo</span></span> [<span class="hljs-type"><span class="hljs-type">Bool</span></span>] insightList_2 = insightList knowledgeList_2 knowledgeList_3 :: <span class="hljs-type"><span class="hljs-type">KnowledgeList</span></span> knowledgeList_3 = addNewKnowledge (knowledgeAbout insightList_2) knowledgeList_2 insightList_3 :: <span class="hljs-type"><span class="hljs-type">StateInfo</span></span> [<span class="hljs-type"><span class="hljs-type">Bool</span></span>] insightList_3 = insightList knowledgeList_3</code> </pre><br>  With the help of the <i>addNewKnowledge</i> function <i>,</i> we <i>go</i> over all the wise men and add new knowledge to them (the results of the previous day‚Äôs voting). <br><br>  Repeating the procedure several times, we obtain the variables <i>insightList_1</i> , <i>insightList_2</i> and <i>insightList_3</i> - the voting results for three days. <br><br>  The final touch is to output the result for a particular initial state. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">startState</span></span> = [<span class="hljs-type"><span class="hljs-type">White</span></span>, <span class="hljs-type"><span class="hljs-type">White</span></span>, <span class="hljs-type"><span class="hljs-type">White</span></span>] main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> putStr $ <span class="hljs-string"><span class="hljs-string">"day 1 result: "</span></span> ++ (show $ insightList_1 startState) ++ <span class="hljs-string"><span class="hljs-string">"\n"</span></span> putStr $ <span class="hljs-string"><span class="hljs-string">"day 2 result: "</span></span> ++ (show $ insightList_2 startState) ++ <span class="hljs-string"><span class="hljs-string">"\n"</span></span> putStr $ <span class="hljs-string"><span class="hljs-string">"day 3 result: "</span></span> ++ (show $ insightList_3 startState) ++ <span class="hljs-string"><span class="hljs-string">"\n"</span></span></code> </pre><br><h6>  Result </h6><br>  To begin, consider the most difficult and interesting option, when all caps are white. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">startState</span></span> = [<span class="hljs-type"><span class="hljs-type">White</span></span>, <span class="hljs-type"><span class="hljs-type">White</span></span>, <span class="hljs-type"><span class="hljs-type">White</span></span>] <span class="hljs-comment"><span class="hljs-comment">{- result: day 1 result: [False,False,False] day 2 result: [False,False,False] day 3 result: [True,True,True] -}</span></span></code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wt/zm/jp/wtzmjpcqvhvyijl6u5kzwjc3mya.png"></div><br>  In the first two days, the wise men thought.  And on the third day, the three of them said they knew their color. <br><br>  Unfortunately, it was not possible to identify the "most intelligent".  We assume that all wise men are as smart as possible and use all available information to the fullest.  In their reasoning, they all use the fact that other sages are also the most intelligent. <br><br>  What happens if one of the caps is black? <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">startState</span></span> = [<span class="hljs-type"><span class="hljs-type">Black</span></span>, <span class="hljs-type"><span class="hljs-type">White</span></span>, <span class="hljs-type"><span class="hljs-type">White</span></span>] <span class="hljs-comment"><span class="hljs-comment">{- result: day 1 result: [False,False,False] day 2 result: [False,True,True] day 3 result: [True,True,True] -}</span></span></code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fs/qx/pv/fsqxpvu5vxlpat5d1qhj6uc-2qe.png"></div><br>  We see that two wise men in white were able to determine their color on the second day.  It is not surprising, because for them the whole situation boils down to the problem of two wise men.  Looking at their reaction, the remaining sage was able to determine his color. <br><br>  And here is an example with two black caps. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">startState</span></span> = [<span class="hljs-type"><span class="hljs-type">Black</span></span>, <span class="hljs-type"><span class="hljs-type">Black</span></span>, <span class="hljs-type"><span class="hljs-type">White</span></span>] <span class="hljs-comment"><span class="hljs-comment">{- result: day 1 result: [False,False,True] day 2 result: [True,True,True] day 3 result: [True,True,True] -}</span></span></code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/o_/7-/kj/o_7-kjs5egap2z_giwk0et1judk.png"></div><br>  As you can see, the sage in a white cap on the first day was able to determine its color.  And this is a clear signal to the rest of the wise men that they have black caps. <br><br><div class="spoiler">  <b class="spoiler_title">Article code entirely</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Color</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Black</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">White</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> = [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Color</span></span></span><span class="hljs-class">] fullState :: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class">] fullState = do c1 &lt;- [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Black</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">White</span></span></span><span class="hljs-class">] c2 &lt;- [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Black</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">White</span></span></span><span class="hljs-class">] c3 &lt;- [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Black</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">White</span></span></span><span class="hljs-class">] return [c1, c2, c3] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateInfo</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> -&gt; a stateInfoColor :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateInfo</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Color</span></span></span><span class="hljs-class"> stateInfoColor i state = state !! i stateInfoAnyWhite :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateInfo</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> stateInfoAnyWhite state = or $ map (\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class"> == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">White</span></span></span><span class="hljs-class">) state </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- =================== type Knowledge = State -&gt; (State -&gt; Bool) knowledgeAbout :: (Eq a) =&gt; StateInfo a -&gt; Knowledge knowledgeAbout stateInfo state = let info = stateInfo state in \s -&gt; stateInfo s == info knowledgeIsTrue :: StateInfo Bool -&gt; Knowledge knowledgeIsTrue si _ state = si state knowledgeAboutColor1 :: Knowledge knowledgeAboutColor1 = knowledgeAbout $ stateInfoColor 0 knowledgeAboutColor2 :: Knowledge knowledgeAboutColor2 = knowledgeAbout $ stateInfoColor 1 knowledgeAboutColor3 :: Knowledge knowledgeAboutColor3 = knowledgeAbout $ stateInfoColor 2 -- =================== knowledgeAnd :: [Knowledge] -&gt; Knowledge knowledgeAnd list stateTrue = \s -&gt; and $ map (\f -&gt; f stateTrue s) list stateInfoList :: [StateInfo a] -&gt; StateInfo [a] stateInfoList sil state = map (\si-&gt; si state) sil knowledgeImply :: Knowledge -&gt; Knowledge -&gt; StateInfo Bool knowledgeImply knowledge1 knowledge2 state = and $ map (\(b1, b2) -&gt; not $ and [b1, not b2]) $ map (\s -&gt; (knowledge1 state s, knowledge2 state s)) fullState -- ================== type KnowledgeList = [(Knowledge, Knowledge)] insightList :: KnowledgeList -&gt; StateInfo [Bool] insightList knowledgeList = stateInfoList $ map knowledgeInsight knowledgeList knowledgeInsight :: (Knowledge, Knowledge) -&gt; StateInfo Bool knowledgeInsight (currentKnowledge, targetKnowledge) = knowledgeImply currentKnowledge targetKnowledge manStart_1 = knowledgeAnd [knowledgeAboutColor2, knowledgeAboutColor3, knowledgeAbout stateInfoAnyWhite] manStart_2 = knowledgeAnd [knowledgeAboutColor1, knowledgeAboutColor3, knowledgeAbout stateInfoAnyWhite] manStart_3 = knowledgeAnd [knowledgeAboutColor1, knowledgeAboutColor2, knowledgeAbout stateInfoAnyWhite] knowledgeList_1 :: KnowledgeList knowledgeList_1 = [(manStart_1, knowledgeAboutColor1), (manStart_2, knowledgeAboutColor2), (manStart_3, knowledgeAboutColor3)] insightList_1 :: StateInfo [Bool] insightList_1 = insightList knowledgeList_1 -- =============== addNewKnowledge :: Knowledge -&gt; KnowledgeList -&gt; KnowledgeList addNewKnowledge newKnowledge knowledgeList = flip map knowledgeList $ \(oldKnowledge, targetKnowledge) -&gt; (knowledgeAnd [oldKnowledge, newKnowledge], targetKnowledge) knowledgeList_2 :: KnowledgeList knowledgeList_2 = addNewKnowledge (knowledgeAbout insightList_1) knowledgeList_1 insightList_2 :: StateInfo [Bool] insightList_2 = insightList knowledgeList_2 knowledgeList_3 :: KnowledgeList knowledgeList_3 = addNewKnowledge (knowledgeAbout insightList_2) knowledgeList_2 insightList_3 :: StateInfo [Bool] insightList_3 = insightList knowledgeList_3 -- ============= startState = [White, White, White] main = do putStr $ "day 1 result: " ++ (show $ insightList_1 startState) ++ "\n" putStr $ "day 2 result: " ++ (show $ insightList_2 startState) ++ "\n" putStr $ "day 3 result: " ++ (show $ insightList_3 startState) ++ "\n"</span></span></span></span></code> </pre><br></div></div><br><h6>  Conclusion </h6><br>  The resulting example is a good starting point for further research and experimentation.  With it, you can solve other problems in the style of "I know that he knows that I know ..". <br><br>  In my code, the number of wise men and days is tough.  I did not specifically begin to generalize it to N sages and N days to make it clearer.  Perhaps in the next article I will rewrite it through the komonad. </div><p>Source: <a href="https://habr.com/ru/post/349558/">https://habr.com/ru/post/349558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349546/index.html">Games in which you need to write code (part 2)</a></li>
<li><a href="../349548/index.html">Remote work robots: technical details and application</a></li>
<li><a href="../349550/index.html">Quantum computing in the Fujitsu Digital Annealer computer</a></li>
<li><a href="../349554/index.html">10 main secrets of productivity Ilona Mask</a></li>
<li><a href="../349556/index.html">Nextcloud talk</a></li>
<li><a href="../349560/index.html">How we did the SQL Olympiad</a></li>
<li><a href="../349562/index.html">Cyrillic programming can improve performance</a></li>
<li><a href="../349564/index.html">Variable forms and wow effects: magic with simple words</a></li>
<li><a href="../349566/index.html">Cargo cult around and within us: IT HR and marketing</a></li>
<li><a href="../349568/index.html">Our strength is fiber, or Powered Fiber Cable System</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>