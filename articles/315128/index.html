<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple API gateway based on PHP and Lumen</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The term ‚Äúmicroservices‚Äù is widely known today - it has suddenly become very fashionable, and many companies announce the transition to this architect...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple API gateway based on PHP and Lumen</h1><div class="post__text post__text-html js-mediator-article">  The term ‚Äúmicroservices‚Äù is widely known today - it has suddenly become very fashionable, and many companies announce the transition to this architectural pattern even without really understanding it.  However, the discussion of the usefulness of microservices is left outside of this article. <br><br>  Traditionally, before the collection of microservices, an additional layer is offered - the so-called API gateway, which solves several problems at once (they will be listed later).  At the time of this writing, there are almost no open source implementations of such gateways, so I decided to write my own in PHP using the Lumen microlimmer (part of Laravel). <br><br>  In this article, I will show how simple this task is for modern PHP! <br><a name="habracut"></a><br><h2>  What is API gateway? </h2><br>  In short, the <a href="http://microservices.io/patterns/apigateway.html">API gateway</a> is a smart proxy server between users and any number of services (API), hence the name. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The need for this layer appears immediately upon transition to the microservice pattern: <br><br><ul><li>  A single address is much more convenient than hundreds (with Netflix there are more than 600) individual API addresses; </li><li>  It is logical to check the user data (token) in a single place, at the "entrance"; </li><li>  It is convenient to implement restrictions on the number of requests in a single place; </li><li>  The whole system becomes more flexible - you can change the internal structure at least every day.  Support for older versions of the API is becoming a trivial matter; </li><li>  You can cache or mutate responses; </li><li>  For the convenience of the user (or the developers of the front end), you can combine answers from different services.  Facebook has long been offering this opportunity. </li></ul><br>  More benefits are just those that came to mind in 10-20 seconds. <br><br>  Nginx released a <a href="https://www.nginx.com/blog/microservices-from-design-to-deployment-ebook-nginx/">good free e-book</a> dedicated to microservices and API gateway - I advise you to read to anyone who is interested in this pattern. <br><br><h2>  Existing options </h2><br><ul><li>  <a href="https://github.com/NREL/api-umbrella">API Umbrella</a> , Lua; </li><li>  <a href="https://github.com/Mashape/kong">Kong</a> , Lua; </li><li>  <a href="https://aws.amazon.com/api-gateway/">AWS API Gateway</a> is a paid service from Amazon. </li></ul><br>  As I said above, there are very few options, and those appeared relatively recently.  Many opportunities in them yet. <br><br><h2>  Why PHP and Lumen? </h2><br>  With the release of version 7, PHP has become highly productive, and with the advent of frameworks like Laravel and Symfony, PHP has proven to the world that it can be beautiful and functional.  Lumen, being a ‚Äúcleared‚Äù fast version of Laravel, is ideal here, because we will not need sessions, templates and other features of the full stack of applications. <br><br>  In addition, I just have more experience with PHP and Lumen, and deploying the resulting application through Docker - the language in which it is written will not be important for future users.  This is just a layer that performs its role! <br><br><h2>  Selected terminology </h2><br>  I propose the following architecture and its corresponding terminology.  In the code I will adhere to these terms in order not to get confused: <br><br><img src="https://habrastorage.org/files/48a/ca9/ee6/48aca9ee6ab5482bb0cd359a8a2647f9.jpg"><br>  The application itself decided to call <a href="https://github.com/PoweredLocal/vrata">Vrata</a> , because the ‚Äúgate‚Äù in Russian is almost ‚Äúgateway‚Äù, and the world doesn‚Äôt have enough applications with Russian names) <br><br>  Directly behind the "gate" is the number of N microservices - API services that can respond to web requests.  Each service can have any number of instances, so the API gateway will select a specific instance through the so-called service registry. <br><br>  Each service offers some amount of resources (in the REST language), and each resource can have several possible actions.  A fairly simple and logical structure for any experienced REST programmer. <br><br><h2>  Vrata requirements </h2><br>  Having not yet started the code, you can immediately determine some requirements for the future application: <br><br><ul><li>  The gateway should scale horizontally, because it's 2016, and everyone wants to scale horizontally.  Therefore, there should be no state of the application; </li><li>  The gateway must be able to combine requests and call microservices asynchronously; </li><li>  The gateway should be able to limit the number of requests in a period of time; </li><li>  The gateway must be able to validate the authentication token.  It is traditionally proposed that the API gateway performs authentication, and microservices hidden under it perform authorization on their resources; </li><li>  The gateway should be able to automatically import available resources from microservices.  To begin, select the Swagger format, as the most popular in the world today; </li><li>  The gateway must be able to change (mutate) microservice responses; </li><li>  And finally: the gateway should be perfectly launched directly from the Docker image and configured via environment variables.  We do not want any additional repositories, deployment scripts and so on! </li></ul><br>  I will say right away that most of the points are already working, and it was very easy to implement them.  After all, the truth is told - we live in the best era for the programmer! <br><br><h2>  Implementation </h2><br><h3>  Authentication </h3><br>  There was almost no work in this direction - it was enough to fix Laravel Passport for Lumen and we received the support of all modern OAuth2 features, including JWT.  My little package port is published on <a href="https://github.com/dusterio/lumen-passport">GitHub / Packagist</a> and someone is already installing it. <br><br><h3>  Routes and controller </h3><br>  All downstream routes from microservices are imported into Vrata from the configuration file in JSON format.  At the time of launch, these routes are added to the service provider: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    ‚Äì     $registry = $this-&gt;app-&gt;make(RouteRegistry::class); //   Lumen   ,      $registry-&gt;bind(app());</span></span></code> </pre> <br>  Meanwhile, in the database of routes: <br><br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> Application $app */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Application $app)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   -      Lumen //           //  middleware   OAuth2,      $this-&gt;getRoutes()-&gt;each(function ($route) use ($app) { $method = strtolower($route-&gt;getMethod()); $app-&gt;{$method}($route-&gt;getPath(), [ 'uses' =&gt; 'App\Http\Controllers\GatewayController@' . $method, 'middleware' =&gt; [ 'auth', 'helper:' . $route-&gt;getId() ] ]); }); }</span></span></code> </pre><br>  Now every public (and allowed in the configs) route from microservices has a route to the API gateway.  In addition, synthetic or merged requests that exist only on this gateway are also added.  All requests go to the same controller: <br><br>  This is how the controller handles any GET request: <br><br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> Request $request * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> RestClient $client * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> Response */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request $request, RestClient $client)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,  -  $parametersJar = $request-&gt;getRouteParams(); //     N   $output = $this-&gt;actions-&gt;reduce(function($carry, $batch) use (&amp;$parametersJar, $client) { //  N    $responses = $client-&gt;asyncRequest($batch, $parametersJar); //        $parametersJar = array_merge($parametersJar, $responses-&gt;exportParameters()); //     -  array reduce return array_merge($carry, $responses-&gt;getResponses()-&gt;toArray()); }, []); //    .    JSON return $this-&gt;presenter-&gt;format($this-&gt;rearrangeKeys($output), 200); }</span></span></code> </pre><br>  Guzzle was chosen as the HTTP client, which copes with async requests perfectly and also has ready integration tools. <br><br><h3>  Composite requests </h3><br>  Complex compound requests are already working ‚Äî this is when one route on the gateway corresponds to any number of routes on different microservices.  Here is a working example: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// Boolean-,    'aggregate' =&gt; true, 'method' =&gt; 'GET', //     ,       "jar" 'path' =&gt; '/v2/devices/{mac}/extended', //     'actions' =&gt; [ 'device' =&gt; [ //      'service' =&gt; 'core', 'method' =&gt; 'GET', 'path' =&gt; 'devices/{mac}', //        'sequence' =&gt; 0, //          -    'critical' =&gt; true ], 'ping' =&gt; [ 'service' =&gt; 'history', //         'output_key' =&gt; false, 'method' =&gt; 'POST', 'path' =&gt; 'ping/{mac}', 'sequence' =&gt; 0, 'critical' =&gt; false ], 'settings' =&gt; [ 'service' =&gt; 'core', //     JSON- 'output_key' =&gt; 'network.settings', 'method' =&gt; 'GET', //  ,     'device' 'path' =&gt; 'networks/{device%network_id}', 'sequence' =&gt; 1, 'critical' =&gt; false ] ]</span></span></code> </pre><br>  As you can see, complex routes are already available and have a good set of features - you can allocate critical ones, you can make parallel requests, you can use the response of one service in a request to another, and so on.  In addition, the output is excellent performance - only 56 milliseconds to receive a cumulative response (loading Lumen and three background queries, all microservices with databases). <br><br><h3>  Service Registry </h3><br>  This is the weakest part so far - only one very simple method is implemented: DNS.  Despite its primitiveness, it works fine in an environment like Docker Cloud or AWS, where the provider itself oversees a group of services and dynamically edits the DNS record. <br><br>  At the moment, Vrata simply takes the hostname of the service, without delving into the cloud or one physical computer.  The most popular registry for today, perhaps, is <a href="https://www.consul.io/">Consul</a> , and it should be added as follows. <br><br>  The essence of the registry is very simple - you need to keep a table of live and dead instances of the service, giving the address of specific instances when necessary.  AWS and Docker Cloud (and many others) can do this for you, providing you with one magic hostname that always works. <br><br><h3>  Docker image </h3><br>  Speaking of microservices, it‚Äôs simply impossible not to mention Docker, one of the ‚Äúhottest‚Äù technologies of the last couple of years.  Microservices are usually tested and deployed as Docker images ‚Äî this became standard practice, so we quickly prepared a public image in the Docker Hub. <br><br>  One command entered in the terminal of any OS X, Windows or Linux machine, and my Vrata gateway works for you: <br><br><pre> <code class="bash hljs">$ docker run -d -e GATEWAY_SERVICES=... -e GATEWAY_GLOBAL=... -e GATEWAY_ROUTES=... pwred/vrata</code> </pre><br>  The entire configuration can be transferred in environment variables in JSON format. <br><br><h2>  Afterword </h2><br>  The application (gateway) is already used in practice in the company where I work.  All code in a <a href="https://github.com/PoweredLocal/vrata">repository on GitHub</a> .  If someone wants to participate in the development - welcome :) <br><br>  Since composite queries, both in concept and implementation, are very similar to the GraphQL query format promoted by Facebook (as opposed to REST), support for GraphQL queries is one of the priority future features. </div><p>Source: <a href="https://habr.com/ru/post/315128/">https://habr.com/ru/post/315128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../315116/index.html">Online course on entry-level computer networks</a></li>
<li><a href="../315118/index.html">The implementation of the classification of text convolutional network on keras</a></li>
<li><a href="../315120/index.html">Make it tomorrow. How not to waste time on trivia</a></li>
<li><a href="../315124/index.html">Bike Agile</a></li>
<li><a href="../315126/index.html">FAS filed a case against Microsoft</a></li>
<li><a href="../315130/index.html">About slaves, heroes and hero slaves</a></li>
<li><a href="../315132/index.html">We explain to grandma: How to encrypt in an hour</a></li>
<li><a href="../315134/index.html">We accept email on Node.js</a></li>
<li><a href="../315136/index.html">As I added 30,000 people to the first circle of contacts, they will block this social network in the Russian Federation</a></li>
<li><a href="../315138/index.html">Deconstruction of the myth of deep learning. Lecture in Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>