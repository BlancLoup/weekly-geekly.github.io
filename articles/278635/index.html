<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rust in detail, part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 2: Sending and receiving messages 
 In this series of articles, we look at the process of creating a scalable chat server in real time, in full d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rust in detail, part 2</h1><div class="post__text post__text-html js-mediator-article"><h2>  Part 2: Sending and receiving messages </h2><br>  In this series of articles, we look at the process of creating a scalable chat server in real time, in full detail.  The purpose of the article is to show an example of the practical application of the <strong>Rust</strong> language against the background of studying the concepts of system programming and system APIs, step by step. <br><br>  The second part is a direct continuation of the <a href="http://habrahabr.ru/post/268609/">first</a> , so if you missed it (or forgot the context), I recommend that you familiarize yourself with it first.  In this part, we continue the implementation of the WebSocket protocol. <br><a name="habracut"></a><br><h2>  14 frames </h2><br>  Now we are ready to start the exchange of real messages.  But first of all, we need to understand how the WebSocket protocol encodes the data for transmission.  The description can be found in the <a href="https://tools.ietf.org/html/rfc6455">RFC</a> , which obliges us to pack data into <em>frames</em> , which consist of a <em>header</em> containing meta information (frame type, etc.) and <em>payload</em> , that is, the data we want to send . <br><br>  The beginning of the frame header consists of 2 bytes (or 16 bits), which look like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/cda/8ac/441/cda8ac441c9241889ed27f792113bb48.png"></div><br>  Each diamond in the diagram represents one bit (one or zero). <br><br><ul><li> <code>fin</code> - the last <em>fragment</em> marker in a series of fragmented frames, which are used when the length of the transmitted data is not known in advance - for example, for streaming transmission.  For the time being, we will not cover this topic in detail, since there is no need to solve this problem directly. </li><li>  <code>rsv1</code> , <code>rsv2</code> , and <code>rsv3</code> reserved for future versions of WebSocket in case any protocol extensions appear.  For our task this is also irrelevant, therefore, we can safely ignore these fields. </li><li>  <code>opcode</code> specifies the type of frame sent or received, which may contain binary data or text.  In addition, there are several types of <em>control frames</em> (control frames) used for pings, or in cases where one of the parties interrupts the connection.  We will discuss this issue later. </li><li>  <code>masked</code> set to 1 (true) when data is encoded using a bitmask.  Details later. </li><li>  <code>payload len</code> - the size of the transmitted data.  This field requires special logic for processing, since  its value depends on the size of the data - we will return to this soon. </li></ul><br>  Note that all this data is packed in only <strong>2</strong> <em>octets</em> (an octet is a byte consisting of 8 bits).  For example, take this object serialized in JSON: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"fin"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"rsv1"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"rsv2"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"rsv3"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"opcode"</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"masked"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"payload_len"</span></span>: <span class="hljs-number"><span class="hljs-number">64</span></span> }</code> </pre> <br>  All of these values ‚Äã‚Äãcan also be encoded in <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B8%25D1%2582%25D0%25BE%25D0%25B2%25D0%25BE%25D0%25B5_%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25B5">binary format</a> , as groups of bits: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"fin"</span></span> : b1, <span class="hljs-attr"><span class="hljs-attr">"rsv1"</span></span> : b0, <span class="hljs-attr"><span class="hljs-attr">"rsv2"</span></span> : b0, <span class="hljs-attr"><span class="hljs-attr">"rsv3"</span></span> : b0, <span class="hljs-attr"><span class="hljs-attr">"opcode"</span></span> : b10, <span class="hljs-attr"><span class="hljs-attr">"masked"</span></span> : b1, <span class="hljs-attr"><span class="hljs-attr">"payload_len"</span></span>: b1000000 }</code> </pre> <br>  Or just as one big binary number: <code>1.0.0.0.0010.1.1000000</code> , or in hexadecimal system: <code>0x82C0</code> . <br>  These are different views of the frame header received from clients, and for the convenience of work we need to bring the binary number to a structure with separate fields, dividing it into separate parts. <br><br><h2>  15 Unpacking Headers </h2><br>  In order to pull out from the number in the binary number system the information we need, we use a technique known as <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B8%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25B0%25D1%2581%25D0%25BA%25D0%25B0"><em>bitmasks</em></a> .  It sounds scary, but in reality it is a rather simple idea. <br><br>  We simply "select" the bits that we want to "extract" from the number: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/31b/bcb/e32/31bbcbe32ed349bc9ef8959787fbbbe9.png"></div><br>  Gray squares reflect zeros, and yellow ones are ones. <br>  Thus, the scheme corresponds to the bit mask <abbr title="0x0F in hexadecimal, 15 in decimal"><code>00001111b</code></abbr> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ba0/4ec/034/ba04ec0340a64151b3813568c18bac54.png"></div><br>  Following the same logic, this is the bitmask <abbr title="0x20 in hex, 32 in decimal"><code>00100000b</code></abbr> . <br><br>  We "overlay" the mask with the <code>&amp;</code> operator (bitwise <strong>AND</strong> , <code>and</code> ) as follows: <code> &amp; </code> . <br>  Here's how it works: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/211/c44/e83/211c44e839674294be92f87ae44abf03.png"></div><br>  Again, the gray squares correspond to <code>0</code> , and the green ones - <code>1</code> . <br>  Having two "variables" <code>A = 1b</code> and <code>B = 0b</code> , at the output we get <code>Out = 0b</code> . <br>  The same is true for the values <code>A = 0b</code> and <code>B = 1b</code> . <br>  <code>Out = 1b</code> at the output is obtained only if both incoming numbers are ones.  That's the whole logic. <br><br>  In the case when we have a <em>lot of</em> bits, the <code></code> operation (AND) is applied sequentially to each of them.  Suppose we have the values <code>A = 101b</code> and <code>B = 011b</code> .  In this case, the output is <code>Out = 001b</code> , since the only common bit for <code>A</code> and <code>B</code> is the third unit, <code>1b</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/030/01d/add/03001dadd0e143d49a42277b2df1d68a.png"></div><br>  Now, using the same logic, we can apply masks with "selected" bits, examples of which we saw at the beginning, to extract parts of the frame header that we are interested in. <br><br><h2>  16 byte order </h2><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2580%25D1%258F%25D0%25B4%25D0%25BE%25D0%25BA_%25D0%25B1%25D0%25B0%25D0%25B9%25D1%2582%25D0%25BE%25D0%25B2">Byte order</a> (endianness <a name="ref1"></a>  <sup><a href="https://habr.com/ru/post/278635/">[1]</a></sup> ) determines how two bytes or more are grouped in memory.  The order can go from <em>younger to older</em> (little-endian), or from <em>older to younger</em> (big-endian). <br><br>  Let's see what the difference is. <br><br>  One word can contain numbers up to <abbr title="65535 in decimal"><code>0xFFFF</code></abbr> . <br>  For example, in the case of the value <code>0x0001</code> - in which order should these two bytes be placed in memory? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/117/28d/282/11728d28252b420b8c33ba3efce82046.png"></div><br>  The simplest analogy that can be drawn is the writing of words on paper.  As a rule, in European languages ‚Äã‚Äãthey are written from left to right.  In the same way, we also write Arabic numbers ‚Äî on the left, high order numbers (thousands, hundreds), on the right, lower order numbers (tens, ones).  In the binary number system, the higher order bytes - those that make up the bulk of the number, that is, for example, for the number <abbr title="10818 in decimal"><code>0x2A42</code></abbr> high byte is <code>0x2A</code> .  Such a record corresponds to the order of <em>big-endian</em> . <br><br>  At the same time, in some oriental languages ‚Äã‚Äã(for example, in Hebrew and Arabic), it is customary to write words from right to left.  The order of writing to <em>little-endian</em> works in a similar way: the low bytes are always to the left, and in this case we write the binary number <code>0x2A42</code> as <code>0x422A</code> . <br><br>  Here is how these numbers look in memory: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e43/e8b/9b8/e43e8b9b8a8145619d5c17cbd772737c.png"></div><br>  In general, this is all you need to know about the order of bytes - just remember the example with a two-byte number <code>0x0001</code> , which we write in the "little" way in little-endian as <code>0x0100</code> . <br><br>  We need to know all this for one simple reason: over the network, all data comes to us in big-endian, and this is a traditional order for network applications, also called ‚Äúnetwork byte order‚Äù.  At the same time, x86 (and x86-64) architecture processors use little-endian order <a name="ref2"></a>  <sup><a href="https://habr.com/ru/post/278635/">[2]</a></sup> , which means the need to convert numbers from one order to another.  Sounds hard?  In fact, we can significantly simplify our lives using libraries from the standard <a href="http://crates.io/">Crates</a> repository. <br><br>  The library of interest to us is called <a href="http://burntsushi.net/rustdoc/byteorder/"><em>byteorder</em></a> , and it allows you to work with bytes in a fairly simple way, simply by indicating the order of interest to us before reading or writing bytes.  All this we will look at an example a little later. <br><br><h2>  17 Refactoring the join process </h2><br>  Before we proceed to the implementation of unpacking bytes, let's do a little warm-up - let's reconsider the <code>WebSocketClient</code> structure a bit so that our code does not turn into noodles.  Let me remind you that in this structure we process client connections, and the <code>read</code> method in it is called every time new data from the client comes to us. <br><br>  First, let's move the connection handling code to a separate function, simply renaming <code>fn read</code> to <code>fn read_handshake</code> .  Now we can add a new <code>read</code> implementation that, depending on the state of the connected client, will transfer control of the desired implementation: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state { ClientState::AwaitingHandshake =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.read_handshake(); }, _ =&gt; {} } }</code> </pre> <br>  Everything is simple here - we make a comparison with the current value of <code>self.state</code> , and process the case when the state is equal to <code>AwaitingHandshake</code> (waiting for the connection to start using the HTTP protocol).  For all other possible cases, we use the universal <code>_</code> pattern, because the Rust compiler requires <code>match</code> cover all possible cases for the safe operation of our program. <br><br>  And since we have touched upon the topic of the current connection state ( <code>self.state</code> ), let's do another small refactoring, which is available to us thanks to Rust's interesting features.  In the first part of the article, we parse the HTTP request headers using a special structure, <code>Parser</code> , which contains the context and status of the HTTP parser.  At the same time, we need this structure only once - when we have not yet proceeded to communicate using the WebSocket protocol, so it would be nice to free the memory we use with the parser that we do not need. <br><br>  We can easily achieve this with a simple trick: we simply move the state of the parser to the enum of the <code>ClientState</code> .  Code example: <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClientState</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//       enum: AwaitingHandshake(RefCell&lt;Parser&lt;HttpParser&gt;&gt;), ‚Ä¶ } struct WebSocketClient { //         : headers: Rc&lt;RefCell&lt;HashMap&lt;String, String&gt;&gt;&gt;, ‚Ä¶ interest: EventSet, ‚Ä¶ } //    : impl WebSocketClient { fn new(socket: TcpStream) -&gt; WebSocketClient { ‚Ä¶ WebSocketClient { socket: socket, headers: headers.clone(), interest: EventSet::readable(), state: ClientState::AwaitingHandshake(RefCell::new(Parser::request(HttpParser { current_key: None, headers: headers.clone() }))) } } }</span></span></code> </pre> <br>  What does this give us, and how is this even possible?  Strictly speaking, enumerations are structures with some peculiarities.  More precisely, enumerations in Rust are <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25B5%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D1%2582%25D0%25B8%25D0%25BF_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585"><em>algebraic data types</em></a> (ADT), about which you could hear in the context of some functional languages ‚Äã‚Äã(OCaml, Haskell, and others).  ADT allows us to define complex data structures (including recursive ones), using only the type system.  This way some of the structures built into the language are implemented - for example, <code>Option</code> and <code>Result</code> , already familiar to us.  There is no black magic in these structures, and you can easily implement them yourself if you wish. <br><br>  Thus, Rust allows us to store the state directly along with type information.  In this case, however, the enumeration fields are immutable, so we will use <code>RefCell</code> to encapsulate the variable state of the parser. <br><br>  Due to the fact that we have transferred ownership of the parser to the enumeration (or rather to the <code>ClientState::AwaitingHandshake</code> type), all memory associated with it will be automatically released when the state transitions to another enum value - for example, to <code>ClientState::Connected</code> .  This effect we sought.  Now, after we removed the <code>http_parser</code> from the client structure, we need to change the <code>read</code> and <code>read_handshake</code> functions <code>read_handshake</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state { ClientState::AwaitingHandshake(_) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.read_handshake(); }, _ =&gt; {} } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_handshake</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> is_upgrade = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ClientState::AwaitingHandshake(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> parser_state) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> parser = parser_state.borrow_mut(); parser.parse(&amp;buf); parser.is_upgrade() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_upgrade { <span class="hljs-comment"><span class="hljs-comment">//    self.state = ClientState::HandshakeResponse; ‚Ä¶ } }</span></span></code> </pre> <br>  In <code>read_handshake</code> you can see an unfamiliar expression, <a href="http://rurust.github.io/rust_book_ru/src/if-let.html"><code>if let</code></a> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> is_upgrade = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ClientState::AwaitingHandshake(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> parser_state) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state {</code> </pre> <br>  <code>if let</code> is a simplified version of the match pattern <code>match</code> operator.  With it, we can only do matching on one sample, which in some cases is more convenient than <code>match</code> , which requires handling all possible cases. <br><br>  And pay attention to the pattern with which we are doing the mapping, and in particular the <code>ref</code> keyword: <br><br><pre> <code class="rust hljs">ClientState::AwaitingHandshake(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> parser_state)</code> </pre> <br>  <code>ref</code> used to get the value by reference (that is, to borrow it) - without <code>ref</code> sample would look as if we want to transfer the state of the parser to the new owner, the metavariable <code>parser_state</code> (or implicitly copy it). <br><br>  If you pay attention, we could get a link to the status of the parser in the <code>read</code> function when we did the mapping with the current connection state - for example, like this: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state { ClientState::AwaitingHandshake(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> parser_state) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.read_handshake(parser_state); }, ‚Ä¶ }</code> </pre> <br>  But this approach is a violation of the rules of the borrowing analyzer, and therefore as a result we would get the following error: <br><br><pre> <code class="rust hljs">error: cannot borrow `*<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>` <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mutable because `<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state.<span class="hljs-number"><span class="hljs-number">0</span></span>` is also borrowed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> immutable ClientState::AwaitingHandshake(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> parser_state) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.read_handshake(...), ^~~~</code> </pre> <br><img src="https://habrastorage.org/files/dc7/50d/c1c/dc750dc1c2b84e2abfc20d028004b376.png" align="right"><br>  This happens because during the decompression of the state of the <code>ref parser_state</code> from <code>self.state</code> we also implicitly borrow <code>self</code> and to prevent possible future changes and movements from <code>self.state</code> . <br><br>  At the same time, in the <code>read_handshake</code> function at the time of entry, we <em>once again</em> borrow <code>self</code> with the ability to change - as a result, an attempt is made to double borrow <code>self</code> to change, which, as you remember, the compiler rules in Rust are forbidden - that is why we borrow the state of the parser as part of the <code>read_handshake</code> function. <br><br>  All this may not seem very convenient, but in this way Rust protects us from memory damage - following such strict but simple rules, we can always be sure that our program works correctly. <br><br><h2>  18 Unpacking the frame </h2><br>  Finally, let's write the code to unpack the frame header.  But before we get to this, it would be nice to divide the project into modules - as the number of lines grows, keeping all the code in one file becomes quite inconvenient.  We will start with the <code>frame.rs</code> module, which will contain code related to working with frames. <br><br>  Below is a complete listing of the module - the code is quite voluminous, but do not be afraid, after we consider it in detail: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io::Read; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::error::Error; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> byteorder::{ReadBytesExt, BigEndian}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_LEN_U16: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> = <span class="hljs-number"><span class="hljs-number">126</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_LEN_U64: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> = <span class="hljs-number"><span class="hljs-number">127</span></span>; <span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, Clone, Copy, PartialEq)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[allow(dead_code)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpCode</span></span></span></span> { TextFrame = <span class="hljs-number"><span class="hljs-number">1</span></span>, BinaryFrame = <span class="hljs-number"><span class="hljs-number">2</span></span>, ConnectionClose = <span class="hljs-number"><span class="hljs-number">8</span></span>, Ping = <span class="hljs-number"><span class="hljs-number">9</span></span>, Pong = <span class="hljs-number"><span class="hljs-number">0xA</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> OpCode { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(op: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;OpCode&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> op { <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(OpCode::TextFrame), <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(OpCode::BinaryFrame), <span class="hljs-number"><span class="hljs-number">8</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(OpCode::ConnectionClose), <span class="hljs-number"><span class="hljs-number">9</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(OpCode::Ping), <span class="hljs-number"><span class="hljs-number">0xA</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(OpCode::Pong), _ =&gt; <span class="hljs-literal"><span class="hljs-literal">None</span></span> } } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSocketFrameHeader</span></span></span></span> { fin: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, rsv1: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, rsv2: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, rsv3: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, masked: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, opcode: OpCode, payload_length: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSocketFrame</span></span></span></span> { header: WebSocketFrameHeader, mask: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">4</span></span>]&gt;, <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> payload: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> WebSocketFrame { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span></span>&lt;R: Read&gt;(input: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> R) -&gt; io::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;WebSocketFrame&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> buf = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(input.read_u16::&lt;BigEndian&gt;()); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> header = Self::parse_header(buf); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> len = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(Self::read_length(header.payload_length, input)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mask_key = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> header.masked { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mask = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(Self::read_mask(input)); <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(mask) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">None</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> payload = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(Self::read_payload(len, input)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(mask) = mask_key { Self::apply_mask(mask, &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> payload); } <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(WebSocketFrame { header: header, payload: payload, mask: mask_key }) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_opcode</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; OpCode { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.header.opcode.clone() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_header</span></span></span></span>(buf: <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;WebSocketFrameHeader, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> opcode_num = ((buf &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> opcode = OpCode::from(opcode_num); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(opcode) = opcode { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(WebSocketFrameHeader { fin: (buf &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span> == <span class="hljs-number"><span class="hljs-number">0x80</span></span>, rsv1: (buf &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x40</span></span> == <span class="hljs-number"><span class="hljs-number">0x40</span></span>, rsv2: (buf &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x20</span></span> == <span class="hljs-number"><span class="hljs-number">0x20</span></span>, rsv3: (buf &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x10</span></span> == <span class="hljs-number"><span class="hljs-number">0x10</span></span>, opcode: opcode, masked: buf &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span> == <span class="hljs-number"><span class="hljs-number">0x80</span></span>, payload_length: (buf <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7F</span></span>, }) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">" opcode: {}"</span></span>, opcode_num)) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply_mask</span></span></span></span>(mask: [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">4</span></span>], bytes: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (idx, c) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bytes.iter_mut().enumerate() { *c = *c ^ mask[idx % <span class="hljs-number"><span class="hljs-number">4</span></span>]; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_mask</span></span></span></span>&lt;R: Read&gt;(input: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> R) -&gt; io::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">4</span></span>]&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf = [<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(input.read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf)); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(buf) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_payload</span></span></span></span>&lt;R: Read&gt;(payload_len: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, input: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> R) -&gt; io::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> payload: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::with_capacity(payload_len); payload.extend(iter::repeat(<span class="hljs-number"><span class="hljs-number">0</span></span>).take(payload_len)); <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(input.read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> payload)); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(payload) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_length</span></span></span></span>&lt;R: Read&gt;(payload_len: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, input: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> R) -&gt; io::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> payload_len { PAYLOAD_LEN_U64 =&gt; input.read_u64::&lt;BigEndian&gt;().map(|v| v <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>).map_err(|e| io::Error::from(e)), PAYLOAD_LEN_U16 =&gt; input.read_u16::&lt;BigEndian&gt;().map(|v| v <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>).map_err(|e| io::Error::from(e)), _ =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(payload_len <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) <span class="hljs-comment"><span class="hljs-comment">// payload_len &lt; 126 } } }</span></span></code> </pre> <br>  The first change you might notice in the code is the use of the <code>pub</code> modifiers for functions, structures, variables, and constants in an explicit form.  They define the interface of the module ‚Äî that is, the characters available to other modules for import using the <code>use frame::{a, b, c};</code> construct <code>use frame::{a, b, c};</code>  . <br><br>  Then we define two new structures: <code>WebSocketFrameHeader</code> contains frame header data, and <code>WebSocketFrame</code> needed to represent the received and sent frames.  The <code>WebSocketFrame</code> structure also contains a <code>read</code> function that allows you to read frames not only from the socket, but also from any other data source ‚Äî files, strings, etc.  That is why, instead of explicitly specifying the type of argument as <code>TcpStream</code> we use a generic abstract type for data sources <a href="http://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> .  This rule should always be followed - rarely does it become necessary to specify specific types for function arguments, so it is better to use interfaces / types - this can be useful, for example, when writing tests. <br><br><h3>  Read title </h3><br>  Let's start the analysis of the code by unpacking the header: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_header</span></span></span></span>(buf: [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span>]) -&gt; WebSocketFrameHeader { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> opcode_num = ((buf &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> opcode = OpCode::from(opcode_num); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(opcode) = opcode { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(WebSocketFrameHeader { fin: (buf &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span> == <span class="hljs-number"><span class="hljs-number">0x80</span></span>, rsv1: (buf &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x40</span></span> == <span class="hljs-number"><span class="hljs-number">0x40</span></span>, rsv2: (buf &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x20</span></span> == <span class="hljs-number"><span class="hljs-number">0x20</span></span>, rsv3: (buf &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x10</span></span> == <span class="hljs-number"><span class="hljs-number">0x10</span></span>, opcode: opcode, masked: buf &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span> == <span class="hljs-number"><span class="hljs-number">0x80</span></span>, payload_length: (buf <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7F</span></span>, }) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">" opcode: {}"</span></span>, opcode_num)) } }</code> </pre> <br>  In addition to the bitwise <code>&amp;</code> (AND) we use the <em>right shift</em> operation - <code>&gt;&gt;</code> . <br>  The idea here is even simpler than with bitwise <code></code> - it works like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/cda/8ac/441/cda8ac441c9241889ed27f792113bb48.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f10/e98/ff3/f10e98ff35de42039c50814136eb0ed9.png"></div><br>  That is, we simply shift a certain number of bits from left to right for easier work with bitwise masks. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> opcode_num = ((buf &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>;</code> </pre> <br>  In the example above, we shift the 8 high bits to the right and apply the mask we already know: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/31b/bcb/e32/31bbcbe32ed349bc9ef8959787fbbbe9.png"></div><br>  The further process differs only in that we apply different masks to other parts of the header. <br><br>  Then we create the <code>OpCode</code> from the frame type number: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> opcode = OpCode::from(opcode_num);</code> </pre> <br>  In such cases, it is always worth using enumerations, because they provide type safety.  When using untyped numbers and constants it is very easy to make a mistake, because you can easily use a number that does not correspond to any real opcode.  In <code>opcode_num</code> , then there will be an undefined value. <br>  In addition, we can associate each type in the list with any number: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpCode</span></span></span></span> { TextFrame = <span class="hljs-number"><span class="hljs-number">1</span></span>, BinaryFrame = <span class="hljs-number"><span class="hljs-number">2</span></span>, ‚Ä¶ }</code> </pre> <br>  In order to obtain from the number the corresponding type of <code>OpCode</code> , we use a separate function: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> OpCode { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(op: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;OpCode&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> op { <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(OpCode::TextFrame), <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(OpCode::BinaryFrame), ‚Ä¶ _ =&gt; <span class="hljs-literal"><span class="hljs-literal">None</span></span> } } }</code> </pre> <br>  The function is safe because the return value is of type <code>Option&lt;OpCode&gt;</code> - for those cases where the number does not match any opcode, we simply return <code>None</code> . <br><br><h3>  Determination of data size </h3><br>  Now we need to determine the size of the data.  The 7-bit frame header is responsible for this, therefore the maximum possible value for <code>payload len</code> is 127. At the same time, obviously, the frame size can go far beyond these limits, so we use special logic to determine the actual length in bytes.  Quotation from <a href="https://tools.ietf.org/html/rfc6455">RFC</a> (section 5.2): <br><br><blockquote>  The size of the data, in bytes: if 0-125, then this is the size of the data.  If 126, then <br>  the size is the next 2 bytes, which should be interpreted as <br>  A 16-bit unsigned integer.  If 127, the size is as follows <br>  8 bytes, which should be interpreted as a 64-bit unsigned integer <br>  number. <br></blockquote><br>  That is, if we speak in terms of Rust, we read <code>u16</code> , if <code>payload_len</code> is <code>126</code> , and <code>u64</code> , if <code>127</code> .  In order not to use these "magic" values ‚Äã‚Äãin the code, we define a pair of constants with more or less clear names: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_LEN_U16: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> = <span class="hljs-number"><span class="hljs-number">126</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_LEN_U64: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> = <span class="hljs-number"><span class="hljs-number">127</span></span>;</code> </pre> <br>  And we will write a separate function to read the data size: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_length</span></span></span></span>&lt;R: Read&gt;(payload_len: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, input: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> R) -&gt; io::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> payload_len { PAYLOAD_LEN_U64 =&gt; input.read_u64::&lt;BigEndian&gt;().map(|v| v <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>).map_err(<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from), PAYLOAD_LEN_U16 =&gt; input.read_u16::&lt;BigEndian&gt;().map(|v| v <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>).map_err(<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from), _ =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(payload_len <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) <span class="hljs-comment"><span class="hljs-comment">// payload_len &lt; 127 } }</span></span></code> </pre> <br>  The code is quite dense, so let's gradually analyze it.  First of all, pay attention to the function signature: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_length</span></span></span></span>&lt;R: Read&gt;(payload_len: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, input: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> R) -&gt; io::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; {</code> </pre> <br>  It takes two arguments: <code>payload_len</code> (the value from the header), and <code>input</code> , which uses the parameterized type <code>R</code>  <code>&lt;R: Read&gt;</code> defines this type. <br><br>  <a href="http://rurust.github.io/rust_book_ru/src/generics.html"><em>Parameterized</em></a> (or <em>generic</em> ) types allow functions to accept and return values ‚Äã‚Äãthat are not strictly defined, but of arbitrary type ‚Äî these are kind of stubs for type designations. <br><br>  In the <code>read_length</code> function <code>read_length</code> we take as an argument any type that implements the type <a href="http://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> .  Thus, we mean that the <code>input</code> variable must respond to a specific interface through which we read bytes from some data source (which can be a network socket, a file, or even just an array of bytes ‚Äî the <code>Read</code> type is implemented for all these sources). <br><br>  And finally, we return the result of type <code>io::Result&lt;usize&gt;</code> .  <code>io::Result</code> is a <a href="http://rurust.github.io/rust_book_ru/src/type-aliases.html"><em>type alias</em></a> for <code>Result</code> .  In the <code>std::io</code> module, it is defined as follows: <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span></span>&lt;T&gt; = std::result::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;T, io::Error&gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, this is just a brief entry for the type </font></font><code>Result&lt;T, io::Error&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, where </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the exact same parameterized type that we used above for the function arguments </font></font><code>read_length</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We can define our own type aliases in the same way. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next we do the mapping to the variable </font></font><code>payload_len</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> payload_len { PAYLOAD_LEN_U64 =&gt; input.read_u64::&lt;BigEndian&gt;().map(|v| v <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>).map_err(<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from), ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we use the very library </font></font><code>byteorder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that we talked about at the beginning. </font><font style="vertical-align: inherit;">At the beginning of the module, we import it as follows:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> byteorder::{ReadBytesExt, BigEndian};</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The module </font></font><code>ReadBytesExt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">provides a type that contains methods for reading numbers in different sizes - </font></font><code>u16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>u32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>u64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- in a specific byte order. </font></font><code>ReadBytesExt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It works in an interesting way: it extends the type </font></font><code>Read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the standard library, which leads to the addition of its methods to any structures that implement it </font></font><code>Read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Rust allows you to expand any type (or structure) by adding arbitrary methods to existing and future structures.</font></font><a name="ref3"></a>  <sup><a href="https://habr.com/ru/post/278635/">[3]</a></sup> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using this feature is pretty easy - for example, this is how it is implemented </font></font><code>ReadBytesExt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">byteorder</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> code </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///  `Read`,     . ( `std::io`.) pub trait ReadBytesExt: io::Read { fn read_u16&lt;T: ByteOrder&gt;(&amp;mut self) -&gt; Result&lt;u16&gt; { // ‚Ä¶   ‚Ä¶ } // ‚Ä¶  read_u32, read_u64,  . . ‚Ä¶ } ///    `ReadBytesExt`   ,  `Read`: impl&lt;R: io::Read + ?Sized&gt; ReadBytesExt for R {}</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pay attention to the last line, where the most interesting thing happens. Here a generic type is declared </font></font><code>R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which includes all structures that implement the type </font></font><code>Read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. For this type </font></font><code>R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(or rather, for a set of types) the type is realized </font></font><code>ReadBytesExt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The implementation body ( </font></font><code>impl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) is empty, since it </font></font><code>ReadBytesExt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">already contains the necessary method implementations (which resembles abstract classes from "traditional" OOP languages). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We also specify the byte order using the parameterization of types: it is determined by the type that implements the type </font></font><code>ByteOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The library </font></font><code>byteorder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">already has several such implementations, of which we are most interested in </font></font><code>BigEndian</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>LittleEndian</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is how we all use it in our code, reading 8 bytes in the big-endian network order:</font></font><br><br><pre> <code class="rust hljs">input.read_u64::&lt;BigEndian&gt;() .map(|v| v <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) .map_err(<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from),</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using the methods of structure </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>map_err</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we bring the result </font></font><code>Result&lt;u64, byteorder::Error&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the type we need </font></font><code>Result&lt;usize, io::Error&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here transforms the type of the return value, and </font></font><code>map_err</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, accordingly, the type of error.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mask </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">According to the protocol, after we read the frame size, we need to read a 4-byte mask ‚Äî but only if the bit </font></font><code>mask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is 1. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is a good time to use the type </font></font><code>Option</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mask_key = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> header.masked { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mask = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(Self::read_mask(input)); <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(mask) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">None</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In this piece of code, you can find a new interesting construct: macro </font></font><a href="http://rustbyexample.com/std/result/try.html"><code>try!</code></a>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This macro allows us to handle routine errors in short form. </font><font style="vertical-align: inherit;">In this case, it is expanded into this code:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> Self::read_mask(input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(val) =&gt; val, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from(err)) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, it checks the return </font></font><code>read_mask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value of the </font><font style="vertical-align: inherit;">function </font><font style="vertical-align: inherit;">- if it is not an error, then it is unpacked from </font></font><code>Ok(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and returned as a result:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(val) =&gt; val,</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the result is an error, then it is converted to the type returned by the function (in this case </font></font><code>io::Error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), and immediately returned as the result of the function (interrupting its further execution):</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from(err)) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Macros </font></font><code>try!</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are a simple and non-polluting code way to handle errors. </font><font style="vertical-align: inherit;">It </font></font><code>match</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">would be rather tiring and, frankly, not very pleasant to </font><font style="vertical-align: inherit;">handle every mistake manually in this way, with comparison through </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at the implementation of the function </font></font><code>read_mask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(which, however, is nothing special - we simply sequentially read 4 bytes from the data source into the array):</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_mask</span></span></span></span>&lt;R: Read&gt;(input: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> R) -&gt; io::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">4</span></span>]&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf = [<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(input.read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf)); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(buf) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After we read the mask, we can proceed directly to reading the frame data: </font></font><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_payload</span></span></span></span>&lt;R: Read&gt;(payload_len: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, input: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> R) -&gt; io::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> payload: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::with_capacity(payload_len); payload.extend(iter::repeat(<span class="hljs-number"><span class="hljs-number">0</span></span>).take(payload_len)); <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(input.read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> payload)); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(payload) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explanations are needed here. </font><font style="vertical-align: inherit;">First we create a buffer that will contain the frame data:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> payload: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::with_capacity(payload_len);</code> </pre> <br> <code>Vec::with_capacity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creates a vector with a pre-allocated memory for it. </font><font style="vertical-align: inherit;">We use a vector, dynamically allocated array, because with the standard method of declaring byte arrays </font></font><code>[0; &lt;&gt;]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we cannot use a variable to specify the size, since these are </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static buffers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and their size cannot be changed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vectors allow you to create arrays of arbitrary size. </font><font style="vertical-align: inherit;">In order to use them effectively, you need to know about the difference between </font></font><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capacity</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">length</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/70f/b44/a2a/70fb44a2a71f4faa83199133f5202bb8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the length determines the number of elements in the vector, the capacity is the number of elements that the vector can hold without </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">re-allocating memory</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . When allocating memory for a vector, all its elements are moved to another area of ‚Äã‚Äãmemory - obviously, this is not a quick process (especially with a large size of elements), so if we guess with the intended capacity, the vector will work faster. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An interesting detail is related to this. We read data from the source </font></font><code>Read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as follows:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(input.read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> payload));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we do not explicitly indicate the number of bytes read anywhere, the method </font></font><code>read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for estimating uses the size of the transferred buffer. </font><font style="vertical-align: inherit;">Since the size of a vector is determined by its length, not its capacity, and our vector </font></font><code>payload</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains no elements, it will, accordingly, </font></font><code>read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try to read 0 bytes and will not return anything. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this reason, we use this trick, pre-filling the buffer with zeros:</font></font><br><br><pre> <code class="rust hljs">payload.extend(iter::repeat(<span class="hljs-number"><span class="hljs-number">0</span></span>).take(payload_len));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We create an </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iterator</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that infinitely repeats zeros, and limit the number of elements in a variable </font></font><code>payload_len</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, resulting in a sequence </font></font><code>[0, 0, 0, ...payload_len]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's all - now we have a vector with frame data. </font><font style="vertical-align: inherit;">We can only apply a mask to it, following the </font></font><a href="https://tools.ietf.org/html/rfc6455"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">description in the RFC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><blockquote> <strong>5.3      </strong> <br><br>       , <br>  ,   .     <br>     . <br><br>    i   (¬´transformed-octet-i¬ª), <br>   i   (¬´original-octet-i¬ª)   <br>  (XOR)        i   4 (¬´masking-key-octet-j¬ª): <br><br><pre> `j = i MOD 4<font></font>
transformed-octet-i = original-octet-i XOR masking-key-octet-j` </pre><br></blockquote><br>      ,  <em> </em>        : <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply_mask</span></span></span></span>(mask: [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">4</span></span>], bytes: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (idx, c) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bytes.iter_mut().enumerate() { *c = *c ^ mask[idx % <span class="hljs-number"><span class="hljs-number">4</span></span>]; } }</code> </pre> <br>  <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>iterate_mut()</code></a>        ,  <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>enumerate()</code></a>    ,          . <br><br><img src="https://habrastorage.org/files/a7f/797/05a/a7f79705ac38413cae784a277d313eb0.png" align="right"><br>   <em> </em> , <strong><code>^</code></strong> ,    ,   <em> </em> : <code>1</code>       ,   (..  <code>1</code> ) <code>A</code>  <code>B</code> ,     . <br><br>              ,       <em></em>    . <br><br>      ,                  (,      "   " ‚Äî     ,  ).      WebSocket    ,        " ". <a name="ref4"></a>  <sup><a href="https://habr.com/ru/post/278635/">[four]</a></sup> <br><br><h3>  Results </h3><br>          ,      ,         <code>WebSocketClient</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> WebSocketClient { <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶    ‚Ä¶ fn read(&amp;mut self) { match self.state { ClientState::AwaitingHandshake(_) =&gt; { ‚Ä¶ }, //      `Connected`: ClientState::Connected =&gt; { let frame = WebSocketFrame::read(&amp;mut self.socket); match frame { Ok(frame) =&gt; println!("{:?}", frame), Err(e) =&gt; println!("   : {}", e) } } } } }</span></span></code> </pre> <br>    ‚Äî        <code>cargo run</code>       .       : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b25/287/915/b25287915bad4d3d8933e82d16969a2d.png"></div><br><h1> 19   </h1><br>   ,  ,       . ,    ‚Äî      -  (,  ,  ..)     . <br><br>           : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> WebSocketFrameHeader { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_header</span></span></span></span>(len: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, opcode: OpCode) -&gt; WebSocketFrameHeader { WebSocketFrameHeader { fin: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, rsv1: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, rsv2: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, rsv3: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, masked: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, payload_length: Self::determine_len(len), opcode: opcode } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">determine_len</span></span></span></span>(len: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len &lt; (PAYLOAD_LEN_U16 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { len <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len &lt; (<span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>::MAX <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { PAYLOAD_LEN_U16 } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { PAYLOAD_LEN_U64 } } }</code> </pre> <br>  <code>new_header</code>  2  ‚Äî       ,     .  <code>determine_len</code>    "" ,    (..,    126  127). <br><br>   ,      ‚Äî       .         ,          : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> WebSocketFrame { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(payload: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; WebSocketFrame { WebSocketFrame { header: WebSocketFrameHeader::new_header(payload.len(), OpCode::TextFrame), payload: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::from(payload), mask: <span class="hljs-literal"><span class="hljs-literal">None</span></span> } } }</code> </pre> <br>     <code>From</code> ,    .     ‚Äî <code>From&lt;&amp;'a str&gt;</code> .    ‚Äî  <code>&amp;'a str</code> ,    <code>&amp;str</code> ,    <code>&lt;'a&gt;</code>  <code>impl&lt;'a&gt;</code> ? <br><br>          Rust: <em> </em> .       ,     ,      ‚Äî    ,  .   ,    ,   - ,       . <br><br>          ,            ‚Äî ,      .    <em>  </em> ,       . <strong><code>'a</code></strong>         . <br><br> ,       ,        ‚Äî , ,           ,    <code>From</code> . <br><br>  -,     ,      .     ,        <a href="http://rurust.github.io/rust_book_ru/src/lifetimes.html"> "  Rust"</a> . <br><br>          . ,           ,       ‚Äî ,     .   ,  <code>parse_header</code> ‚Äî <code>serialize_header</code>    : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> WebSocketFrame { <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶    ‚Ä¶ fn serialize_header(hdr: &amp;WebSocketFrameHeader) -&gt; u16 { let b1 = ((hdr.fin as u8) &lt;&lt; 7) | ((hdr.rsv1 as u8) &lt;&lt; 6) | ((hdr.rsv2 as u8) &lt;&lt; 5) | ((hdr.rsv3 as u8) &lt;&lt; 4) | ((hdr.opcode as u8) &amp; 0x0F); let b2 = ((hdr.masked as u8) &lt;&lt; 7) | ((hdr.payload_length as u8) &amp; 0x7F); ((b1 as u16) &lt;&lt; 8) | (b2 as u16) } }</span></span></code> </pre> <br>     , <code>&lt;&lt;</code> ‚Äî    .      ,     <code>&gt;&gt;</code> ,     ,  <em></em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7af/150/7a1/7af1507a148044398d7b7aba5b5a8a79.png"></div><br>  , <strong><code>|</code></strong> ‚Äî  <code></code> ‚Äî    ,     <em></em> .  , ,      <strong><code>1</code></strong> ,    ‚Äî <strong><code>0</code></strong> ,     <code>1</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0cd/c79/b77/0cdc79b778be4892a0b577460b7ec95f.png"></div><br>          ( <code>u16</code> ) ‚Äî       8 ,          : <br><br><pre> <code class="rust hljs">((b1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | (b2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>)</code> </pre> <br>         <code>write</code> ,        (, ,  ..): <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span></span>&lt;W: Write&gt;(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, output: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> W) -&gt; io::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;()&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hdr = Self::serialize_header(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.header); <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(output.write_u16::&lt;BigEndian&gt;(hdr)); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.header.payload_length { PAYLOAD_LEN_U16 =&gt; <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(output.write_u16::&lt;BigEndian&gt;(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.payload.len() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>)), PAYLOAD_LEN_U64 =&gt; <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(output.write_u64::&lt;BigEndian&gt;(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.payload.len() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>)), _ =&gt; {} } <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(output.write(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.payload)); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(()) }</code> </pre> <br>   2  ,    (   <em>125</em> ),      ‚Äî   ,   RFC     ,            . <br><br>    ‚Äî      !     <code>WebSocketClient.write</code> ‚Äî  ,          <code>write_handshake</code> ,    <code>write</code>      : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> WebSocketClient { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state { ClientState::AwaitingHandshake(_) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.write_handshake(); }, _ =&gt; {} } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_handshake</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> headers = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.headers.borrow(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response_key = gen_key(&amp;headers.get(<span class="hljs-string"><span class="hljs-string">"Sec-WebSocket-Key"</span></span>).unwrap()); ‚Ä¶ } }</code> </pre> <br>      <code>ClientState::Connected</code> ‚Äî      ,   .  ‚Äî  ,    ,      ,              .      <code>WebSocketClient</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSocketClient</span></span></span></span> { socket: TcpStream, ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//    : outgoing: Vec&lt;WebSocketFrame&gt; }</span></span></code> </pre> <br>    -: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> WebSocketClient { <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶    ‚Ä¶ fn new(socket: TcpStream) -&gt; WebSocketClient { let headers = Rc::new(RefCell::new(HashMap::new())); WebSocketClient { ‚Ä¶ outgoing: Vec::new() } } }</span></span></code> </pre> <br> , ,      <code>write</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state { ClientState::HandshakeResponse =&gt; ‚Ä¶, ClientState::Connected =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"   : {}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.outgoing.len()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> frame <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.outgoing.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(e) = frame.write(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.socket) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"  : {}"</span></span>, e); } } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.outgoing.clear(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.interest.remove(EventSet::writable()); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.interest.insert(EventSet::readable()); }, _ =&gt; {} }</code> </pre> <br>        ,  ,       .  ,   ,   -         .    <code>read</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state { ClientState::AwaitingHandshake(_) =&gt; { ‚Ä¶ }, ClientState::Connected =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> frame = WebSocketFrame::read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.socket); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> frame { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(frame) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{:?}"</span></span>, frame), <span class="hljs-comment"><span class="hljs-comment">//     : let reply_frame = WebSocketFrame::from("!"); self.outgoing.push(reply_frame); //      : self.interest.remove(EventSet::readable()); self.interest.insert(EventSet::writable()); }, Err(e) =&gt; println!("   : {}", e) } } } }</span></span></code> </pre> <br>   <code>cargo run</code> ,    ,  ,   .      : <br><br><pre> <code class="javascript hljs">ws = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(<span class="hljs-string"><span class="hljs-string">'ws://127.0.0.1:10000'</span></span>); ws.onmessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'  : '</span></span>, event.data); };</code> </pre> <br>   ""  : <br><br><pre> <code class="javascript hljs">ws.send(<span class="hljs-string"><span class="hljs-string">'!'</span></span>);</code> </pre> <br>       : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/414/6d0/fde/4146d0fdeaaa4377adf47f3f486c6497.png"></div><br><h2> 20   </h2><br>      ,       .     ,         .      ,         .         ,   -. <br><br>  ,      <code>WebSocketClient.read</code>   : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state { ClientState::AwaitingHandshake(_) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.read_handshake(); ClientState::Connected =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.read_frame(), _ =&gt; {} } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_frame</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> frame = WebSocketFrame::read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.socket); ‚Ä¶ }</code> </pre> <br>         , ping  pong,     .       <code>read_frame</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_frame</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> frame = WebSocketFrame::read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.socket); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> frame { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(frame) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> frame.get_opcode() { OpCode::TextFrame =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{:?}"</span></span>, frame), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> reply_frame = WebSocketFrame::from(<span class="hljs-string"><span class="hljs-string">"!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.outgoing.push(reply_frame); }, _ =&gt; {} } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.interest.remove(EventSet::readable()); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.interest.insert(EventSet::writable()); } <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(e) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"   : {}"</span></span>, e) } }</code> </pre> <br>        <code>get_opcode</code> ,    . <br><br>        <code>Ping</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> frame.get_opcode() { OpCode::TextFrame =&gt; ‚Ä¶, OpCode::Ping =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.outgoing.push(WebSocketFrame::pong(&amp;frame)); } _ =&gt; {} }</code> </pre> <br>       <code>Pong</code>     (   ): <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> WebSocketFrame { <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶    ‚Ä¶ pub fn pong(ping_frame: &amp;WebSocketFrame) -&gt; WebSocketFrame { let payload = ping_frame.payload.clone(); WebSocketFrame { header: WebSocketFrameHeader::new_header(payload.len(), OpCode::Pong), payload: payload, mask: None } } }</span></span></code> </pre> <br>      <code>Close</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> frame.get_opcode() { OpCode::TextFrame =&gt; ‚Ä¶, OpCode::Ping =&gt; ‚Ä¶, <span class="hljs-comment"><span class="hljs-comment">//        ConnectionClose: OpCode::ConnectionClose =&gt; { self.outgoing.push(WebSocketFrame::close_from(&amp;frame)); }, _ =&gt; {} }</span></span></code> </pre> <br>            <code>ConnectionClose</code>   ,        .   ,      ,    ,   ,        : <br><br><blockquote>       2-   (   ), <br>      /code/    7.4. <br></blockquote><br>  7.4    ,         ‚Äî     .       , <code>close_from</code> ,         : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> WebSocketFrame { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close_from</span></span></span></span>(recv_frame: &amp;WebSocketFrame) -&gt; WebSocketFrame { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> body = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> recv_frame.payload.len() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> status_code = &amp;recv_frame.payload[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> body = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::with_capacity(<span class="hljs-number"><span class="hljs-number">2</span></span>); body.write(status_code); body } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new() }; WebSocketFrame { header: WebSocketFrameHeader::new_header(body.len(), OpCode::ConnectionClose), payload: body, mask: <span class="hljs-literal"><span class="hljs-literal">None</span></span> } } }</code> </pre> <br>  .       ,      TCP-.      ,        <code>WebSocketClient</code> ,     <code>hup</code>  : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> WebSocketClient { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state { ClientState::HandshakeResponse =&gt; ‚Ä¶, ClientState::Connected =&gt; { <span class="hljs-comment"><span class="hljs-comment">//         : let mut close_connection = false; for frame in self.outgoing.iter() { if let Err(e) = frame.write(&amp;mut self.socket) { println!("   : {}", e); } // ,     ,   : if (frame.is_close()) { close_connection = true; } } self.outgoing.clear(); self.interest.remove(EventSet::writable()); //     -    `hup`,   - //     : if (close_connection) { self.interest.insert(EventSet::hup()); } else { self.interest.insert(EventSet::readable()); } }, _ =&gt; {} } } }</span></span></code> </pre> <br>          ‚Äî   : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> WebSocketFrame { <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶    ‚Ä¶ pub fn is_close(&amp;self) -&gt; bool { self.header.opcode == OpCode::ConnectionClose } }</span></span></code> </pre> <br>    ‚Äî  <code>WebSocketServer</code>          : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Handler <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> WebSocketServer { <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶    ‚Ä¶ fn ready(&amp;mut self, event_loop: &amp;mut EventLoop&lt;WebSocketServer&gt;, token: Token, events: EventSet) { if events.is_readable() { ‚Ä¶ } if events.is_writable() { ‚Ä¶ } //   : if events.is_hup() { let client = self.clients.remove(&amp;token).unwrap(); client.socket.shutdown(Shutdown::Both); event_loop.deregister(&amp;client.socket); } } }</span></span></code> </pre> <br>      . <br><br><h2> 21  </h2><br>       .          ,    WebSocket     ,    WebSocket    . <br><br>         ,           .        ,    <a href="https://twitter.com/nbaksalyar"> </a>   <a href="http://feeds.feedburner.com/NikitaBaksalyar">RSS- </a> . <br><br> ,   ,   <a href="https://github.com/nbaksalyar/rust-chat">  GitHub</a> .     -,    -   . <br><br> C  ! <br><br><h2>  Notes </h2><br><a name="n1"></a> [1]  , ,      " <a href="http://www.lib.ru/INOOLD/SWIFT/gulliver.txt"> </a> ",     ¬´¬ª (little-endian)  ¬´¬ª (big-endian).  <a href="https://habr.com/ru/post/278635/">‚Üë</a> <br><a name="n2"></a> [2]    ¬´¬ª  ,    x86.   ,   : ,    ,     ‚Äî    . ,  little-endian,       ,     .  <a href="https://habr.com/ru/post/278635/">‚Üë</a> <br><a name="n3"></a> [3]   -   C#,        ‚Äî <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D1%2580%25D0%25B0%25D1%2581%25D1%2588%25D0%25B8%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F"> </a> .         ,    ,  .  <a href="https://habr.com/ru/post/278635/">‚Üë</a> <br><a name="n4"></a> [4]             ,  <a href="http://security.stackexchange.com/questions/36930/how-does-websocket-frame-masking-protect-against-cache-poisoning"></a> *(.)*.     " <a href="http://w2spconf.com/2011/papers/websocket.pdf">Talking to Yourself for Fun and Profit</a> ".  <a href="https://habr.com/ru/post/278635/">‚Üë</a> <br><br><hr><br>   ,  <a href="https://habrahabr.ru/users/podust/" class="user_link">podust</a>      . <br><br></div><p>Source: <a href="https://habr.com/ru/post/278635/">https://habr.com/ru/post/278635/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278621/index.html">Selection of materials for the novice developer of JavaScript games</a></li>
<li><a href="../278623/index.html">Humane VimScript: minimalistic object orientation</a></li>
<li><a href="../278629/index.html">‚ÄúStrict mode‚Äù and other MySQL settings in Laravel 5.2</a></li>
<li><a href="../278631/index.html">System 6 (Systemicus) GUI, some aspects</a></li>
<li><a href="../278633/index.html">How to write a simple blog using Asp .Net MVC, Nhibernate and Ninject. Part 1</a></li>
<li><a href="../278637/index.html">Chapter 21. Part 2 - Creating objects and data output objects. PowerShell in depth - Don Jones, Richard Siddaway</a></li>
<li><a href="../278647/index.html">Video from JUG.ru meeting with Kotlin Andrei Breslav and Dmitry Zhemerov</a></li>
<li><a href="../278649/index.html">Announcement Rust 1.7</a></li>
<li><a href="../278651/index.html">How to independently analyze the labor market</a></li>
<li><a href="../278653/index.html">Hedy Lamarr. And in the movie to shoot nude, and in the enemy torpedo pulnut</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>