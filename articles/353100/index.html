<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Explicit Proxy with authorization by AD Group + Interception Proxy with authorization by MAC</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In many organizations, the network structure involves the use of terminal servers, personal computers, as well as mobile devices. This publication wil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Explicit Proxy with authorization by AD Group + Interception Proxy with authorization by MAC</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ww/gy/7r/wwgy7relk4bkn9y8crew8gh6sxc.jpeg"></div><br><p>  In many organizations, the network structure involves the use of terminal servers, personal computers, as well as mobile devices.  This publication will talk about how to put all this through a Squid proxy server, without registering the browser settings on each device once again.  There are many articles on configuring Squid, but everywhere in pieces.  I decided to pack everything together and describe the working configuration from beginning to end. </p><a name="habracut"></a><br><p>  On terminal servers, we will use Explicit Proxy with authorization based on Active Directory groups (servers must be located in the domain, and users must connect to them through domain accounts).  For devices - Interception Proxy authorization will be based on MAC addresses, this will allow us to more flexibly configure access rules without being tied to ip address ranges. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dh/dz/2l/dhdz2lf0o46hsaxumr_hdayxzxo.jpeg"></div><br><p>  We will use CentOS Linux 7.X.XXX and Squid 4.0.23. </p><br><p>  In order to avoid confusion, the Explicit Proxy is an ‚Äúopaque‚Äù proxy server, in which the client's browser specifies the proxy server address, Interception Proxy is a ‚Äútransparent‚Äù mode, when the client specifies the proxy server as a gateway and the browser does not knows <br>  Squid will listen on 3 ports: </p><br><ul><li>  port 3127 - for HTTPS traffic with Interception Proxy.  That is, we will use iptables to forward HTTPS requests from clients on which a proxy server is registered as a gateway; <br></li><li>  port 3128 - for HTTP and HTTPS traffic with Explicit Proxy.  In this case, HTTP sharing <br>  and HTTPS ports are not needed, because the browser understands that it works through a proxy server; <br></li><li>  port 3129 - for HTTP traffic with Interception Proxy.  That is, we will use HTTP to redirect HTTP requests from clients to this port, on which a proxy server is registered as a gateway. <br></li></ul><br><h3 id="predvaritelnaya-nastroyka">  Presetting </h3><br><p>  We have two Ethernet interfaces: eth0 - looks to the local network, eth1 - looks to the global network.  In the case that will be described below, terminal servers and devices are located on the network 192.168.0.0/24.  The proxy server has an address of 192.168.0.133. </p><br><p>  Here is the configuration file / etc / sysconfig / network-scripts / ifcfg-eth0 to this type (we substitute our values): </p><br><div class="spoiler">  <b class="spoiler_title">/ etc / sysconfig / network-scripts / ifcfg-eth0</b> <div class="spoiler_text"><p><code>TYPE=Ethernet</code> <br> <code>BOOTPROTO=none</code> <br> <code>DEFROUTE=no</code> <br> <code>PEERDNS=yes</code> <br> <code>PEERROUTES=no</code> <br> <code>IPV4_FAILURE_FATAL=yes</code> <br> <code>IPV6INIT=no</code> <br> <code>IPV6_FAILURE_FATAL=no</code> <br> <code>NAME=eth0</code> <br> <code>UUID=f34ec600-6c46-485f-9216-0fd8954a9013</code> <br> <code>DEVICE=eth0</code> <br> <code>ONBOOT=yes</code> <br> <code>USERCTL=NO</code> <br> <code>NM_CONTROLLED=no</code> <br> <code>IPADDR=192.168.0.133</code> <br> <code>NETMASK=255.255.255.0</code> <br> <code>DNS1=192.168.0.19</code> <br> <code>DNS2=192.168.0.18</code> <br> <code>DOMAIN=balt.local</code> <br> <code>SEARCH=balt.local</code> </p> </div></div><br><p>  In the directives DOMAIN and SEARCH you need to specify your domain name. <br>  We bring the configuration file / etc / sysconfig / network-scripts / eth1 to this form (we substitute our values): </p><br><div class="spoiler">  <b class="spoiler_title">/ etc / sysconfig / network-scripts / ifcfg-eth1</b> <div class="spoiler_text"><p> <code>TYPE=Ethernet</code> <br> <code>BOOTPROTO=none</code> <br> <code>DEFROUTE=yes</code> <br> <code>PEERDNS=no</code> <br> <code>PEERROUTES=no</code> <br> <code>IPV4_FAILURE_FATAL=yes</code> <br> <code>IPV6INIT=no</code> <br> <code>IPV6_FAILURE_FATAL=no</code> <br> <code>NAME=eth1</code> <br> <code>UUID=2e6072a6-a5fd-4f39-8786-501fa14e6015</code> <br> <code>DEVICE=eth1</code> <br> <code>ONBOOT=yes</code> <br> <code>USERCTL=no</code> <br> <code>NM_CONTROLLED=no</code> <br> <code>IPADDR=112.132.114.190</code> <br> <code>NETMASK=255.255.255.252</code> <br> <code>GATEWAY=112.132.114.189</code> </p> </div></div><br><p>  Set the host name: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># hostnamectl set-hostname SRV-M29-PRX-03</span></span></code> </pre> <br><p>  We register on the DNS server A an entry for the proxy server so that it is resolved from the local network. </p><br><p>  If the local network consists of subnets, then in order for them to communicate with each other on devices with a proxy server as a gateway, you need to configure routes and enable forwarding. </p><br><p>  Create the file / etc / sysconfig / network-scripts / route-eth0 and add the required routes to it, for example: </p><br><p> <code>192.168.0.0/24 via 192.168.0.78 dev eth0</code> <br> <code>192.168.2.0/24 via 192.168.0.78 dev eth0</code> <br> <code>192.168.3.0/24 via 192.168.0.78 dev eth0</code> <br> <code>10.254.253.0/24 via 192.168.0.78 dev eth0</code> </p> <br><p>  Add to /etc/sysctl.conf: </p><br><p> <code>net.ipv4.ip_forward = 1</code> </p> <br><p>  Reboot. <br>  Configure the firewall.  Squid 4.X.XX works with both firewalld and iptables.  Who is more convenient.  This article uses iptables. <br>  Stop and delete firewalld: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># systemctl stop firewalld # yum remove firewalld.noarch</span></span></code> </pre> <br><p>  Install and run iptables: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># yum install iptables-services # systemctl enable iptables # systemctl enable ip6tables # systemctl start iptables # systemctl start ip6tables</span></span></code> </pre> <br><p>  We allow SSH and ICMP only from the local network: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># iptables -R INPUT 4 -i eth0 -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT # iptables -R INPUT 2 -i eth0 -p icmp -j ACCEPT</span></span></code> </pre> <br><p>  We configure traffic redirections from http 80 and https 443 ports to the corresponding SQUID 3129 and 3127. We also use ipset to create a list of destination addresses that will not be redirected to Squid, but will pass by it.  This is necessary, for example, for bank clients, for telegrams, etc. <br>  Create an exception list: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ipset create no_proxy_net_dst hash:net</span></span></code> </pre> <br><p>  We add to it the addresses we need.  For example, in order not to proxy telegram traffic from devices, we specify: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ipset add no_proxy_net_dst 149.154.160.0/20</span></span></code> </pre> <br><p>  Created ipset settings will be erased after a reboot, which will also cause the iptables launch to fail.  Therefore, we write a script for recovering data after a reboot. <br>  Upload the ipset settings to the file: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ipset save -file /etc/sysconfig/ipset-lists.conf</span></span></code> </pre> <br><p>  Create a script /usr/scripts/system/ipset-restore.bash, which, when loaded, first clears all the rules, and then restores the configuration from /etc/sysconfig/ipset-lists.conf: </p><br><p> <code>#!/bin/bash</code> <br> <code>ipset destroy</code> <br> <code>ipset restore -file /etc/sysconfig/ipset-lists.conf</code> </p> <br><p>  This script should be run before starting iptables, so in the /etc/systemd/system/basic.target.wants/iptables.service service we add the line: </p><br><p> <code>ExecStartPre=/usr/scripts/system/ipset-restore.bash</code> </p> <br><p>  Reboot systemd: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># systemctl daemon-reload</span></span></code> </pre> <br><p>  Create redirect rules in iptables: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># iptables -t nat -A PREROUTING -p tcp -m tcp -s 192.168.0.0/24 --dport 443 -m set ! --match-set no_proxy_net_dst dst -j REDIRECT --to-ports 3127 # iptables -t nat -A PREROUTING -p tcp -m tcp -s 192.168.0.0/24 --dport 80 -m set ! --match-set no_proxy_net_dst dst -j REDIRECT --to-ports 3129</span></span></code> </pre> <br><p>  That is, all http and https traffic from the network 192.168.0.0/24, except for the one whose destination address is specified in no_proxy_net_dst, is sent to Squid. </p><br><p>  We edit the FORWARD chain, allow packets to go freely within the local network between all subnets, and also from the 192.168.0.0/24 network to go through the eth1 WAN interface. </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># iptables -I FORWARD 1 -i eth0 -o eth0 -p all -j ACCEPT # iptables -I FORWARD 2 -i eth0 -o eth1 -s 192.168.0.0/24 -j ACCEPT # iptables -I FORWARD 3 -i eth1 -o eth0 -d 192.168.0.0/24 -j ACCEPT</span></span></code> </pre> <br><p>  Configure SNAT on eth1: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth1 -j SNAT --to-source 112.132.114.190</span></span></code> </pre> <br><p>  Well, we open the ports we need on the internal interface: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># iptables -I INPUT 1 -i eth0 -p tcp --dport 80 -j ACCEPT # iptables -I INPUT 1 -i eth0 -p tcp --dport 443 -j ACCEPT # iptables -I INPUT 1 -i eth0 -p tcp --dport 3127 -j ACCEPT # iptables -I INPUT 1 -i eth0 -p tcp --dport 3128 -j ACCEPT # iptables -I INPUT 1 -i eth0 -p tcp --dport 3129 -j ACCEPT</span></span></code> </pre> <br><p>  Save the iptables configuration: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># /sbin/iptables-save &gt; /etc/sysconfig/iptables</span></span></code> </pre> <br><p>  You can also, for peace of mind, specify ssh to listen only on the internal interface.  Edit / etc / ssh / sshd_config: </p><br><p> <code>ListenAddress 192.168.0.133</code> </p> <br><p>  We will authenticate with AD using Kerberos.  This protocol requires that network time be synchronized.  Therefore, we set up a proxy server to obtain time information from domain controllers.  We will use NTP. <br>  Install: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># yum install ntp</span></span></code> </pre> <br><p>  We edit the configuration file /etc/ntp.conf, instead of the servers centos.pool.ntp.org we specify ours: </p><br><p> <code>server srv-m29-dc-03.balt.local iburst</code> <br> <code>server srv-m29-dc-01.balt.local iburst</code> </p> <br><p>  And indicate to use only the internal interface: </p><br><p> <code>interface ignore wildcard</code> <br> <code>interface listen 192.168.0.133</code> <br> <code>interface ignore ipv6</code> </p> <br><p>  Run: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># systemctl enable ntpd # systemctl start ntpd</span></span></code> </pre> <br><p>  You can check the work using the commands: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ntpq -4 -c peers # ntpstat</span></span></code> </pre> <br><p>  I know that disabling SELinux is wrong, but my hands have not reached the settings of Squid and SELinux.  Soon I plan to return to this issue.  Therefore, I disable SELinux, but in no case do I agitate to do the rest.  If you have time, it will be better for you and Dan Walsh to figure it out and do it right. <br>  We translate SELinux into Permissive mode, edit the / etc / sysconfig / selinux file: </p><br><p> <code>SELINUX=permissive</code> </p> <br><p>  Reboot. </p><br><h3 id="ustanovka-squid">  Squid installation </h3><br><p>  The preparatory part is over.  Now we proceed to the Squid installation. <br>  In the official CentOS repositories there is only Squid 3.5.  We will install Squid 4.0.23. <br>  Therefore, we download Squid itself: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># wget http://www1.ngtech.co.il/repo/centos/7/beta/x86_64/squid-debuginfo-4.0.23-1.el7.centos.x86_64.rpm # wget http://www1.ngtech.co.il/repo/centos/7/beta/x86_64/squid-debuginfo-4.0.23-1.el7.centos.x86_64.rpm</span></span></code> </pre> <br><p>  Helpers to him: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># wget http://www1.ngtech.co.il/repo/centos/7/beta/x86_64/squid-helpers-4.0.23-1.el7.centos.x86_64.rpm</span></span></code> </pre> <br><p>  Helpers are scripts that add certain functions to Squid.  For example, we will use ext_kerberos_ldap_group_acl, with which it will check the user's membership in a group in Active Directory. <br>  We put dependences: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># wget http://www1.ngtech.co.il/repo/centos/7/x86_64/libecap-1.0.0-3.el7.centos.x86_64.rpm # wget http://www1.ngtech.co.il/repo/centos/7/x86_64/libecap-debuginfo-1.0.0-3.el7.centos.x86_64.rpm # wget http://www1.ngtech.co.il/repo/centos/7/x86_64/libecap-devel-1.0.0-3.el7.centos.x86_64.rpm # yum -y --nogpgcheck localinstall libecap-1.0.0-3.el7.centos.x86_64.rpm # yum -y --nogpgcheck localinstall libecap-devel-1.0.0-3.el7.centos.x86_64.rpm # yum -y --nogpgcheck localinstall libecap-debuginfo-1.0.0-3.el7.centos.x86_64.rpm # yum install libtool-ltdl openssl-devel cyrus-sasl-gssapi gnutls epel-release perl-Crypt-OpenSSL-X509 perl-DBI perl-Digest-MD5 perl-URI gcc gcc-c++ perl-Digest-SHA</span></span></code> </pre> <br><p>  Install Squid: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># rpm -Uhv squid-4.0.23-1.el7.centos.x86_64.rpm # rpm -Uhv squid-debuginfo-4.0.23-1.el7.centos.x86_64.rpm # rpm -Uhv squid-helpers-4.0.23-1.el7.centos.x86_64.rpm</span></span></code> </pre> <br><p>  Change the owner of the directories used by the squid: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># chown -R squid:squid /var/spool/squid/ # chown -R squid:squid /usr/bin/squidclient # chown -R squid:squid /etc/squid/ # chown -R squid:squid /usr/share/squid # chown -R squid:squid /usr/lib64/squid # chown -R squid:squid /var/log/squid/</span></span></code> </pre> <br><p>  Let's change the default configuration of /etc/squid/squid.conf: </p><br><div class="spoiler">  <b class="spoiler_title">/etc/squid/squid.conf</b> <div class="spoiler_text"><p> <code>acl localnet src fe80::/10 # RFC 1918 local private network (LAN)</code> </p> <br><p> <code>#  </code> <br> <code>acl localnet src 192.168.0.0/16 # RFC 1918 local private network (LAN)</code> <br> <code>acl localnet src fc00::/7 # RFC 4193 local private network range</code> <br> <code>acl localnet src fe80::/10 # RFC 4291 link-local (directly plugged) machines</code> </p> <br><p> <code>acl SSL_ports port 443</code> <br> <code>acl Safe_ports port 80 # http</code> <br> <code>acl Safe_ports port 21 # ftp</code> <br> <code>acl Safe_ports port 443 # https</code> <br> <code>acl Safe_ports port 70 # gopher</code> <br> <code>acl Safe_ports port 210 # wais</code> <br> <code>acl Safe_ports port 1025-65535 # unregistered ports</code> <br> <code>acl Safe_ports port 280 # http-mgmt</code> <br> <code>acl Safe_ports port 488 # gss-http</code> <br> <code>acl Safe_ports port 591 # filemaker</code> <br> <code>acl Safe_ports port 777 # multiling http</code> <br> <code>acl CONNECT method CONNECT</code> </p> <br><p> <code>#   </code> <br> <code>http_access deny !Safe_ports</code> </p> <br><p> <code>#  CONNECT   SSL </code> <br> <code>http_access deny CONNECT !SSL_ports</code> </p> <br><p> <code>#  cachemgr     </code> <br> <code>http_access allow localhost manager</code> <br> <code>http_access deny manager</code> </p> <br><p> <code>#    localhost</code> <br> <code>http_access allow localhost</code> </p> <br><p> <code>#  ,   </code> <br> <code>http_access deny all</code> </p> <br><p> <code>#        Squid</code> <br> <code>http_port 192.168.0.133:3128</code> </p> <br><p> <code>#  DNS.     </code> <br> <code>dns_nameservers 192.168.1.2 192.168.0.18</code> <br> <code>dns_v4_first on</code> </p> <br><p> <code>#  </code> <br> <code>cache_dir ufs /var/spool/squid 100 16 256</code> <br> <code>coredump_dir /var/spool/squid</code> <br> <code>refresh_pattern ^ftp: 1440 20% 10080</code> <br> <code>refresh_pattern ^gopher: 1440 0% 1440</code> <br> <code>refresh_pattern -i (/cgi-bin/|\?) 0 0% 0</code> <br> <code>refresh_pattern . 0 20% 4320</code> </p> </div></div><br><p>  The correctness of the edited configuration file can be checked using: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># squid -k parse</span></span></code> </pre> <br><p>  In the settings, we indicated that we will use caching.  Therefore, we need to create a directory tree in which our cache will be stored.  Execute the command: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># squid -z</span></span></code> </pre> <br><p>  And we start Squid: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># systemctl enable squid # systemctl start squid</span></span></code> </pre> <br><h3 id="nastroyka-explicit-proxy">  Configure Explicit Proxy </h3><br><p>  The default configuration provides for the work of an "opaque" proxy with authorization based on ip addresses - all computers on the local network are allowed to access the Internet. <br>  We are also interested in authentication in the Active Directory domain with authorization based on domain groups.  For authentication in AD, we will use the Kerberos protocol.  The helper <em>negotiate_kerberos_auth</em> will help us with this.  For authorization by groups, we will use <em>ext_kerberos_ldap_group_acl</em> helper. <br>  First, install the Kerberos client: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># yum install krb5-workstation</span></span></code> </pre> <br><p>  Need to create a user in Active Directory.  Let it be admin_squid.  This user should have the right to read the domain users belonging to domain groups.  Therefore, we add a user, for example, to the Organization Managment group. <br>  !  UPD: In most configurations, all users have this right, so no additional groups need to be added.  If not, then it is better to use a group with more limited rights than the "Organization Managment" </p><br><div class="spoiler">  <b class="spoiler_title">Img group membership</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/m2/yn/jw/m2ynjwi6y3nye8qwdjovey3cjiq.jpeg"></p></div></div><br><p>  We generate the keytab file on the domain controller.  This file is used for authentication in the Kerberos infrastructure.  At the same time, users will not need to enter a login and password, Squid will authenticate them themselves using a keytab file. </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ktpass -princ HTTP/srv-m29-prx-03.balt.local@BALT.LOCAL -mapuser BALT\admin_squid -pass 3EYldza1sR -crypto All -ptype KRB5_NT_PRINCIPAL -out C:\keytabs\PROXY.keytab</span></span></code> </pre> <br><p>  ! UPD: set the <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/ktpass">"crypto"</a> option according to your security settings. </p><br><p>  <em>princ, mapuser, pass, out</em> naturally change to your own.  The resulting PROXY.keytab file must be copied to the proxy server in / etc / squid and the rights to it must be changed: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># chown squid:squid /etc/squid/PROXY.keytab # chmod 640 /etc/squid/PROXY.keytab</span></span></code> </pre> <br><p>  Edit the Kerberos configuration file on the /etc/krb5.conf proxy server: </p><br><div class="spoiler">  <b class="spoiler_title">/etc/krb5.conf</b> <div class="spoiler_text"><p> <code>includedir /etc/krb5.conf.d/</code> <br> <code>[logging]</code> <br> <code>default = FILE:/var/log/krb5libs.log</code> <br> <code>kdc = FILE:/var/log/krb5kdc.log</code> <br> <code>admin_server = FILE:/var/log/kadmind.log</code> <br> <code>[libdefaults]</code> <br> <code>dns_lookup_realm = false</code> <br> <code>dns_lookup_kdc = false</code> <br> <code>ticket_lifetime = 24h</code> <br> <code>renew_lifetime = 7d</code> <br> <code>forwardable = true</code> <br> <code>rdns = false</code> <br> <code>default_realm = BALT.LOCAL</code> <br> <code>default_ccache_name = KEYRING:persistent:%{uid}</code> <br> <code>default_keytab_name = /etc/squid/PROXY.keytab</code> <br> <code>[realms]</code> <br> <code>BALT.LOCAL = {</code> <br> <code>kdc = srv-m29-dc-03.balt.local</code> <br> <code>kdc = srv-m29-dc-01.balt.local</code> <br> <code>admin_server = srv-m29-dc-03.balt.local</code> <br> <code>default_domain = balt.local</code> <br> <code>}</code> <br> <code>[domain_realm]</code> <br> <code>.balt.local = BALT.LOCAL</code> <br> <code>balt.local = BALT.LOCAL</code> </p> </div></div><br><p>  Here, <br>  <em>default_realm, default_domain</em> - FQDN domain <br>  <em>default_keytab_name</em> is the path to the keytab file <br>  <em>kdc, admin_server</em> - domain controllers </p><br><p>  Checking: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># kinit -kV -p HTTP/srv-m29-prx-03.balt.local</span></span></code> </pre> <br><p>  If everything is correct, then we will get ‚ÄúAuthenticated to Kerberos v5‚Äù in response. <br>  Remove the received ticket that we received from the Kerberos server in the previous step: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># kdestroy</span></span></code> </pre> <br><p>  Now we make changes to the ‚Äúsquid startup script‚Äù / etc / sysconfig / squid so that squid knows where the keytab file is: </p><br><p> <code>KRB5_KTNAME=/etc/squid/PROXY.keytab</code> <br> <code>export KRB5_KTNAME</code> </p> <br><p>  Add to /etc/squid/squid.conf: </p><br><p> <code>auth_param negotiate program /usr/lib64/squid/negotiate_kerberos_auth -s HTTP/srv-m29-prx-03.balt.local</code> <br> <code>auth_param negotiate children 10</code> <br> <code>auth_param negotiate keep_alive on</code> </p> <br><p>  These lines should be at the beginning of the file before all acl.  They describe the actual authentication using Kerberos.  Information about the parameters of auth_param can be found at the link <a href="http://www.squid-cache.org/Doc/config/auth_param/">auth_param</a> . <br>  We also add acl, which corresponds to all Kerberos-authenticated users and allows them access: </p><br><p> <code>acl kerb_auth proxy_auth REQUIRED</code> <br> <code>http_access allow kerb_auth</code> </p> <br><p>  Specify Squid to re-read the configuration: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># squid -k reconfigure</span></span></code> </pre> <br><p>  After these manipulations, users with domain accounts can access the Internet.  We indicate on terminal servers in the browser srv-m29-prx-03.balt.local, port 3128 in the proxy server settings and check.  At this stage, we can already create access rules for each domain account.  For example, if we want to prevent the user petrov.e from logging in to gmail.com, then we add to the configuration: </p><br><p> <code>acl petrov-e proxy_auth petrov.e@BALT.LOCAL</code> <br> <code>acl gmail url_regex -i mail\.google\.com</code> <br> <code>acl gmail url_regex -i gmail\.com</code> <br> <code>http_access deny petrov-e gmail</code> </p> <br><p>  We are also interested in authorization by groups.  To do this, create the necessary groups in AD: </p><br><p>  <code>SQUID-INTERNET-STANDART</code> - a standard group for which access to prohibited websites is restricted <br>  <code>SQUID-INTERNET-FULL-ACCESS</code> - a group for which access to any sites is allowed <br>  <code>SQUID-INTERNET-EXTENDED</code> - a group for which the list of allowed sites is wider than for SQUID-INTERNET-STANDART <br>  We will also create files on the proxy server and list the sites we need: <br>  <code>blocked-http.txt</code> - list of prohibited http / https sites <br>  <code>allowed-http-always.txt</code> - list of always allowed http / https sites (for example, if the corporate portal should be accessible to everyone without exception) <br>  <code>allowed-http-extended.txt</code> - list of additional allowed sites for the SQUID-INTERNET-EXTENDED group. </p><br><p>  Add, for example, in the blocked-http.txt website msn.com and vk.com: </p><br><p> <code>www\.msn\.com</code> <br> <code>vk\.com</code> </p> <br><p>  In the above files, links to sites are specified using regular expressions. <br>  We configure Squid to check the user's entry into the domain group.  For this we will use the helper <em>ext_kerberos_ldap_group_acl</em> .  Add to /etc/squid/squid.conf: </p><br><p> <code>external_acl_type SQUID-INTERNET-FULL_ACCESS ttl=300 negative_ttl=60 %LOGIN /usr/lib64/squid/ext_kerberos_ldap_group_acl -a -m 0 -S srv-m29-dc-03 -g SQUID-INTERNET-FULL_ACCESS -D BALT.LOCAL</code> <br> <code>external_acl_type SQUID-INTERNET-EXTENDED ttl=300 negative_ttl=60 %LOGIN /usr/lib64/squid/ext_kerberos_ldap_group_acl -a -m 0 -S srv-m29-dc-03 -g SQUID-INTERNET-EXTENDED -D BALT.LOCAL</code> <br> <code>external_acl_type SQUID-INTERNET-STANDART ttl=300 negative_ttl=60 %LOGIN /usr/lib64/squid/ext_kerberos_ldap_group_acl -a -m 0 -S srv-m29-dc-03 -g SQUID-INTERNET-STANDART -D BALT.LOCAL</code> <br> <code>acl SQUID-INTERNET-FULL_ACCESS external SQUID-INTERNET-FULL_ACCESS</code> <br> <code>acl SQUID-INTERNET-STANDART external SQUID-INTERNET-STANDART</code> <br> <code>acl SQUID-INTERNET-EXTENDED external SQUID-INTERNET-EXTENDED</code> </p> <br><p>  Again, what external_acl_type can be read <a href="http://www.squid-cache.org/Doc/config/external_acl_type/">external_acl_type</a> , because this article is so big.  The name of the domain controller srv-m29-dc-03 and the domain name BALT.LOCAL substitute our own. <br>  We describe acl with http / https addresses: </p><br><p> <code>acl allowed-http-always url_regex -i "/etc/squid/allowed-http-always.txt"</code> <br> <code>acl blocked-http url_regex -i "/etc/squid/blocked-http.txt"</code> <br> <code>acl allowed-http-extended url_regex -i "/etc/squid/allowed-http-extended.txt"</code> </p> <br><p>  And create rules based on these acl: </p><br><p> <code>http_access allow allowed-http-always</code> <br> <code>http_access allow SQUID-INTERNET-FULL_ACCESS</code> <br> <code>http_access allow SQUID-INTERNET-EXTENDED allowed-http-extended</code> <br> <code>http_access allow SQUID-INTERNET-EXTENDED !blocked-http</code> <br> <code>http_access allow SQUID-INTERNET-STANDART !blocked-http</code> </p> <br><p>  Commenting on the http_access allow kerb_auth line, since we no longer need any user registered on the server to go anywhere. <br>  The final squid.conf should look something like this: </p><br><div class="spoiler">  <b class="spoiler_title">/etc/squid/squid.conf</b> <div class="spoiler_text"><p> <code>#  Kerberos</code> <br> <code>auth_param negotiate program /usr/lib64/squid/negotiate_kerberos_auth -s HTTP/srv-m29-prx-03.balt.local</code> <br> <code>auth_param negotiate children 10</code> <br> <code>auth_param negotiate keep_alive on</code> </p> <br><p> <code>#  </code> <br> <code>acl localnet src 192.168.0.0/16 # RFC 1918 local private network (LAN)</code> <br> <code>acl localnet src fc00::/7 # RFC 4193 local private network range</code> <br> <code>acl localnet src fe80::/10 # RFC 4291 link-local (directly plugged) machines</code> </p> <br><p> <code>acl SSL_ports port 443</code> <br> <code>acl Safe_ports port 80 # http</code> <br> <code>acl Safe_ports port 21 # ftp</code> <br> <code>acl Safe_ports port 443 # https</code> <br> <code>acl Safe_ports port 70 # gopher</code> <br> <code>acl Safe_ports port 210 # wais</code> <br> <code>acl Safe_ports port 1025-65535 # unregistered ports</code> <br> <code>acl Safe_ports port 280 # http-mgmt</code> <br> <code>acl Safe_ports port 488 # gss-http</code> <br> <code>acl Safe_ports port 591 # filemaker</code> <br> <code>acl Safe_ports port 777 # multiling http</code> <br> <code>acl CONNECT method CONNECT</code> </p> <br><p> <code># acl,      </code> <br> <code>external_acl_type SQUID-INTERNET-FULL_ACCESS ttl=300 negative_ttl=60 %LOGIN /usr/lib64/squid/ext_kerberos_ldap_group_acl -a -m 0 -S srv-m29-dc-03 -g SQUID-INTERNET-FULL_ACCESS -D BALT.LOCAL</code> <br> <code>external_acl_type SQUID-INTERNET-EXTENDED ttl=300 negative_ttl=60 %LOGIN /usr/lib64/squid/ext_kerberos_ldap_group_acl -a -m 0 -S srv-m29-dc-03 -g SQUID-INTERNET-EXTENDED -D BALT.LOCAL</code> <br> <code>external_acl_type SQUID-INTERNET-STANDART ttl=300 negative_ttl=60 %LOGIN /usr/lib64/squid/ext_kerberos_ldap_group_acl -a -m 0 -S srv-m29-dc-03 -g SQUID-INTERNET-STANDART -D BALT.LOCAL</code> <br> <code>acl SQUID-INTERNET-FULL_ACCESS external SQUID-INTERNET-FULL_ACCESS</code> <br> <code>acl SQUID-INTERNET-STANDART external SQUID-INTERNET-STANDART</code> <br> <code>acl SQUID-INTERNET-EXTENDED external SQUID-INTERNET-EXTENDED</code> </p> <br><p> <code># </code> <br> <code>acl allowed-http-always url_regex -i "/etc/squid/allowed-http-always.txt"</code> <br> <code>acl blocked-http url_regex -i "/etc/squid/blocked-http.txt"</code> <br> <code>acl allowed-http-extended url_regex -i "/etc/squid/allowed-http-extended.txt"</code> </p> <br><p> <code># acl,      ,  </code> <br> <code>acl kerb_auth proxy_auth REQUIRED</code> <br> <code>#http_access allow kerb_auth</code> <br> <code>#     </code> <br> <code>http_access deny !Safe_ports</code> </p> <br><p> <code>#  CONNECT   SSL </code> <br> <code>http_access deny CONNECT !SSL_ports</code> </p> <br><p> <code>#  cachemgr     </code> <br> <code>http_access allow localhost manager</code> <br> <code>http_access deny manager</code> </p> <br><p> <code>#    localhost</code> <br> <code>http_access allow localhost</code> </p> <br><p> <code>#     </code> <br> <code>http_access allow allowed-http-always</code> <br> <code>http_access allow SQUID-INTERNET-FULL_ACCESS</code> <br> <code>http_access allow SQUID-INTERNET-EXTENDED allowed-http-extended</code> <br> <code>http_access allow SQUID-INTERNET-EXTENDED !blocked-http</code> <br> <code>http_access allow SQUID-INTERNET-STANDART !blocked-http</code> </p> <br><p> <code>#  ,   </code> <br> <code>http_access deny all</code> </p> <br><p> <code>#        Squid</code> <br> <code>http_port 192.168.0.133:3128</code> </p> <br><p> <code>#  DNS.     </code> <br> <code>dns_nameservers 192.168.1.2 192.168.0.18</code> <br> <code>dns_v4_first on</code> </p> <br><p> <code>#  </code> <br> <code>cache_dir ufs /var/spool/squid 100 16 256</code> <br> <code>coredump_dir /var/spool/squid</code> <br> <code>refresh_pattern ^ftp: 1440 20% 10080</code> <br> <code>refresh_pattern ^gopher: 1440 0% 1440</code> <br> <code>refresh_pattern -i (/cgi-bin/|\?) 0 0% 0</code> <br> <code>refresh_pattern . 0 20% 4320</code> </p> </div></div><br><p>  Reboot Squid: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># systemctl restart squid</span></span></code> </pre> <br><p>  After these manipulations, if the user enters the SQUID-INTERNET-STANDART domain group, he will be denied access to the sites msn.com and vk.com.  Users who are not in any of the groups will not be allowed to access the Internet at all. </p><br><p>  This completes the setting for the Explicit Proxy. </p><br><h3 id="nastroyka-interception-proxy">  Configuring Interception Proxy </h3><br><p>  With the setting of the proxy server for domain users figured out, with the help of group policies, now we set the proxy server address on the terminal servers and use it.  But for computers that are not part of the domain, and for different mobile devices, group policies do not work, and it is not convenient to manually set the proxy settings each time.  And even if to register, then, for example, having come home with the device, there will be no access to the Internet from it.  Therefore, you need to additionally configure a "transparent" proxy server.  You can select a range of ip addresses, and create rules for it in Squid, but it is more convenient (for me) to use device MAC addresses. </p><br><p>  To do this, create lists of mac addresses (this will be an analogue of the domain groups that we created earlier for the Explicit Proxy): </p><br><p>  <code>/etc/squid/ allowed-mac.txt</code> - this includes devices with standard access <br>  <code>/etc/squid/allowed-mac-extended.txt</code> - this includes accessibility devices <br>  <code>/etc/squid/allowed-mac-full-access.txt</code> - this includes devices with full access </p><br><p>  In the files, each new device must be listed in a new line.  Comments begin with the # character.  For example, for me it looks like this: </p><br><p> <code>##  (TEL)</code> <br> <code>94:E9:6A:D3:E0:CB</code> <br> <code>##  (NB) (Wi-Fi)</code> <br> <code>24:0A:64:74:2D:71</code> </p> <br><p>  Further additional settings are needed for transparent https traffic proxying.  When you go to the https site, only the CONNECT request will be displayed in the logs, that is, we will not see where the user entered on this site.  To see the activity in more detail, you need to break the TLS connection, actually implementing the "man-in-the-middle" attack.  Therefore, if you want to monitor what exactly the user did on the https resource, you need to install a self-signed proxy server certificate on his device.  Otherwise, no additional actions on the client side are needed. </p><br><p>  We create public and private keys for self-signed CA certificates.  Squid will use them to generate dynamic certificates for sites that clients request. </p><br><p>  Create a directory for the certificate: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># mkdir /etc/squid/ssl_cert # chown -R squid:squid /etc/squid/ssl_cert/ # chmod 700 /etc/squid/ssl_cert # cd /etc/squid/ssl_cert</span></span></code> </pre> <br><p>  We generate it: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># openssl req -new -newkey rsa:2048 -sha256 -days 365 -nodes -x509 -extensions v3_ca -keyout myCA.pem -out myCA.pem</span></span></code> </pre> <br><p>  Enter your data. </p><br><p>  We also generate a certificate for installation on client devices, if an interception of https is required: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># openssl x509 -in myCA.pem -outform DER -out srv-m29-prx-03.der</span></span></code> </pre> <br><p>  On the client side, it must be installed in trusted root certificates. </p><br><p>  Create a directory for dynamic certificates.  For this we use the ssl_crtd helper: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># /usr/lib64/squid/security_file_certgen -c -s /etc/squid/ssl_db -M 4MB # chown -R squid:squid /etc/squid/ssl_db/</span></span></code> </pre> <br><p>  We create lists of https sites: </p><br><p>  <code>/etc/squid/blocked_https.txt</code> - blocked https sites <br>  <code>/etc/squid/allowed-https-extended.txt</code> - additional allowed https sites <br>  <code>/etc/squid/allowed-https-always.txt</code> - always allowed https sites <br>  <code>/etc/squid/monitored-https.txt</code> - sites whose traffic we want to decrypt </p><br><p>  We rule config / etc / squid / squid.conf. </p><br><p>  We specify Interception Proxy to work in squid.conf on ports 3127 for https and 3129 for http. </p><br><p> <code>http_port 192.168.0.133:3129 intercept</code> <br> <code>https_port 192.168.0.133:3127 intercept ssl-bump cert=/etc/squid/ssl_cert/myCA.pem generate-host-certificates=on dynamic_cert_mem_cache_size=4MB</code> </p> <br><p>  Create acl for https traffic and MAC addresses: </p><br><p> <code>acl allowed-mac arp "/etc/squid/allowed-mac.txt"</code> <br> <code>acl allowed-mac-extended arp "/etc/squid/allowed-mac-extended.txt"</code> <br> <code>acl allowed-mac-full-access arp "/etc/squid/allowed-mac-full-access.txt"</code> <br> <code>acl step1 at_step SslBump1</code> <br> <code>acl allowed-https-always ssl::server_name_regex -i "/etc/squid/allowed-https-always.txt"</code> <br> <code>acl blocked-https ssl::server_name_regex -i "/etc/squid/blocked-https.txt"</code> <br> <code>acl allowed-https-extended ssl::server_name_regex -i "/etc/squid/allowed-https-extended.txt"</code> <br> <code>acl monitored-HTTPS ssl::server_name_regex -i "/etc/squid/monitored-HTTPS.txt"</code> </p> <br><p>  Add permissive rules for devices and http traffic: </p><br><p> <code>http_access allow allowed-mac-full-access</code> <br> <code>http_access allow allowed-mac-extended allowed-http-extended</code> <br> <code>http_access allow allowed-mac-extended !blocked-http</code> <br> <code>http_access allow allowed-mac !blocked-http</code> </p> <br><p>  Add allow rules for devices and traffic https: </p><br><p> <code>ssl_bump peek step1</code> <br> <code>ssl_bump bump allowed-mac-full-access monitored-HTTPS</code> <br> <code>ssl_bump bump allowed-mac-extended monitored-HTTPS</code> <br> <code>ssl_bump bump allowed-mac monitored-HTTPS</code> <br> <code>ssl_bump splice allowed-https-always</code> <br> <code>ssl_bump splice allowed-mac-full-access</code> <br> <code>ssl_bump splice allowed-mac-extended allowed-https-extended</code> <br> <code>ssl_bump splice allowed-mac-extended !blocked-https</code> <br> <code>ssl_bump splice allowed-mac !blocked-https</code> <br> <code>ssl_bump terminate all</code> </p> <br><p>  And settings for creating dynamic certificates: </p><br><p> <code>sslcrtd_program /usr/lib64/squid/security_file_certgen -s /etc/squid/ssl_db -M 4MB</code> </p> <br><p>  Restart Squid. </p><br><p>  If we now register our proxy server as a gateway, then everything should work, without installing any certificates on the client side. </p><br><p>  A little about proxying https.  In Squid 3.5 and higher, the so-called SslBump Peek and Splice feature is used for these purposes.  Its essence lies in the fact that Squid "spies" the TLS handshake process, when there are already known client SNI and a web server certificate sent in response to a client request.  SNI is the name of the host with which the client wishes to establish a TLS connection.  Based on this data, you can decide what Squid will do next - block or skip. </p><br><p>  In fact, Squid looks at the TLS Client Hello message, creates an identical one, and sends it to the destination web server.  The server responds with a TLS Server Hello message, which can also be analyzed. </p><br><p>  That is, we have three stages (steps): </p><br><ol><li>  we receive CONNECT from the client.  At this step, we do not know the domain name of the requested site.  Only tcp-level information - ip address and port.  Therefore, to make decisions based on the domain name is now impossible; </li><li>  we receive tls client hello from the client.  There is already SNI here, that is, the name of the destination server is already known; </li><li>  we get tls server hello from the server that has the server certificate. </li></ol><br><p>  At each step, we can perform one of 5 actions: peek, splice, stare, bump, terminate.  The further processing of the connection depends on which step the action is performed on.  I will not describe everything, as it will be a lot of text.  Read what and how you can here <a href="https://wiki.squid-cache.org/Features/SslPeekAndSplice">SslPeekAndSplice</a> . </p><br><p>  I will describe only about our configuration. </p><br><p>  The string ‚Äúacl step1 at_step SslBump1‚Äù just describes the first step. </p><br><p>  The string ‚Äússl_bump peek step1‚Äù means to perform a peek in the first step, which will result in a transition to the second step, where we process TLS Client Hello and retrieve SNI. <br>  Lines: </p><br><p> <code>ssl_bump bump allowed-mac-full-access monitored-HTTPS</code> <br> <code>ssl_bump bump allowed-mac-extended monitored-HTTPS</code> <br> <code>ssl_bump bump allowed-mac monitored-HTTPS</code> </p> <br><p>  they say if the server name extracted from SNI is in the monitored-https.txt file and the mac address of the client device is in the allowed lists, then establish a TLS connection with the server (using client SNI) and establish a TLS connection with the client (using a fake dynamic server certificate) .  That is, in fact, we organize ‚Äúsquid-in-the-middle‚Äù.  Since the certificate for the client is fake, the browser will swear.  To do this, we created the above certificate srv-m29-prx-03.der, which must be installed on the client device. </p><br><p>  Lines: </p><br><p> <code>ssl_bump splice allowed-https-always</code> <br> <code>ssl_bump splice allowed-mac-full-access</code> <br> <code>ssl_bump splice allowed-mac-extended allowed-https-extended</code> <br> <code>ssl_bump splice allowed-mac-extended !blocked-https</code> <br> <code>ssl_bump splice allowed-mac !blocked-https</code> </p> <br><p>  they say if the server name extracted from SNI is in the allowed files with https lists, then we create a tcp tunnel without decoding the connection.  That is, the client and server communicate directly, as if there is no proxy server between them.  The browser receives a normal certificate from the web server, and not a fake from the proxy server, and naturally does not swear. </p><br><p>  As a result, if we need to decrypt the TLS connection, then the self-signed certificate of the proxy server needs to be installed on the device.  If you just need to decide whether to let us have a client on the site, or not, without activity logs on this site, then you can not install the certificate. </p><br><p>  Final configuration: </p><br><div class="spoiler">  <b class="spoiler_title">/etc/squid/squid.conf</b> <div class="spoiler_text"><p> <code>#  Kerberos</code> <br> <code>auth_param negotiate program /usr/lib64/squid/negotiate_kerberos_auth -s HTTP/srv-m29-prx-03.balt.local</code> <br> <code>auth_param negotiate children 10</code> <br> <code>auth_param negotiate keep_alive on</code> </p> <br><p> <code>#  </code> <br> <code>acl localnet src 192.168.0.0/16 # RFC 1918 local private network (LAN)</code> <br> <code>acl localnet src fc00::/7 # RFC 4193 local private network range</code> <br> <code>acl localnet src fe80::/10 # RFC 4291 link-local (directly plugged) machines</code> </p> <br><p> <code>acl SSL_ports port 443</code> <br> <code>acl Safe_ports port 80 # http</code> <br> <code>acl Safe_ports port 21 # ftp</code> <br> <code>acl Safe_ports port 443 # https</code> <br> <code>acl Safe_ports port 70 # gopher</code> <br> <code>acl Safe_ports port 210 # wais</code> <br> <code>acl Safe_ports port 1025-65535 # unregistered ports</code> <br> <code>acl Safe_ports port 280 # http-mgmt</code> <br> <code>acl Safe_ports port 488 # gss-http</code> <br> <code>acl Safe_ports port 591 # filemaker</code> <br> <code>acl Safe_ports port 777 # multiling http</code> <br> <code>acl CONNECT method CONNECT</code> </p> <br><p> <code># acl,      </code> <br> <code>external_acl_type SQUID-INTERNET-FULL_ACCESS ttl=300 negative_ttl=60 %LOGIN /usr/lib64/squid/ext_kerberos_ldap_group_acl -a -m 0 -S srv-m29-dc-03 -g SQUID-INTERNET-FULL_ACCESS -D BALT.LOCAL</code> <br> <code>external_acl_type SQUID-INTERNET-EXTENDED ttl=300 negative_ttl=60 %LOGIN /usr/lib64/squid/ext_kerberos_ldap_group_acl -a -m 0 -S srv-m29-dc-03 -g SQUID-INTERNET-EXTENDED -D BALT.LOCAL</code> <br> <code>external_acl_type SQUID-INTERNET-STANDART ttl=300 negative_ttl=60 %LOGIN /usr/lib64/squid/ext_kerberos_ldap_group_acl -a -m 0 -S srv-m29-dc-03 -g SQUID-INTERNET-STANDART -D BALT.LOCAL</code> <br> <code>acl SQUID-INTERNET-FULL_ACCESS external SQUID-INTERNET-FULL_ACCESS</code> <br> <code>acl SQUID-INTERNET-STANDART external SQUID-INTERNET-STANDART</code> <br> <code>acl SQUID-INTERNET-EXTENDED external SQUID-INTERNET-EXTENDED</code> </p> <br><p> <code>#  http</code> <br> <code>acl allowed-http-always url_regex -i "/etc/squid/allowed-http-always.txt"</code> <br> <code>acl blocked-http url_regex -i "/etc/squid/blocked-http.txt"</code> <br> <code>acl allowed-http-extended url_regex -i "/etc/squid/allowed-http-extended.txt"</code> </p> <br><p> <code># https </code> <br> <code>acl allowed-https-always ssl::server_name_regex -i "/etc/squid/allowed-https-always.txt"</code> <br> <code>acl blocked-https ssl::server_name_regex -i "/etc/squid/blocked-https.txt"</code> <br> <code>acl allowed-https-extended ssl::server_name_regex -i "/etc/squid/allowed-https-extended.txt"</code> <br> <code>acl monitored-HTTPS ssl::server_name_regex -i "/etc/squid/monitored-HTTPS.txt"</code> </p> <br><p> <code># </code> <br> <code>acl allowed-mac arp "/etc/squid/allowed-mac.txt"</code> <br> <code>acl allowed-mac-extended arp "/etc/squid/allowed-mac-extended.txt"</code> <br> <code>acl allowed-mac-full-access arp "/etc/squid/allowed-mac-full-access.txt"</code> <br> <code>acl step1 at_step SslBump1</code> </p> <br><p> <code># acl,      ,  </code> <br> <code>acl kerb_auth proxy_auth REQUIRED</code> <br> <code>#http_access allow kerb_auth</code> <br> <code>#     </code> <br> <code>http_access deny !Safe_ports</code> </p> <br><p> <code>#  CONNECT   SSL </code> <br> <code>http_access deny CONNECT !SSL_ports</code> </p> <br><p> <code>#  cachemgr     </code> <br> <code>http_access allow localhost manager</code> <br> <code>http_access deny manager</code> </p> <br><p> <code>#    localhost</code> <br> <code>http_access allow localhost</code> </p> <br><p> <code>#     </code> <br> <code>http_access allow allowed-http-always</code> <br> <code>http_access allow SQUID-INTERNET-FULL_ACCESS</code> <br> <code>http_access allow SQUID-INTERNET-EXTENDED allowed-http-extended</code> <br> <code>http_access allow SQUID-INTERNET-EXTENDED !blocked-http</code> <br> <code>http_access allow SQUID-INTERNET-STANDART !blocked-http</code> </p> <br><p> <code>#   mac   http </code> <br> <code>http_access allow allowed-mac-full-access</code> <br> <code>http_access allow allowed-mac-extended allowed-http-extended</code> <br> <code>http_access allow allowed-mac-extended !blocked-http</code> <br> <code>http_access allow allowed-mac !blocked-http</code> </p> <br><p> <code>#  ,   </code> <br> <code>http_access deny all</code> </p> <br><p> <code>#   mac   https </code> <br> <code>ssl_bump peek step1</code> <br> <code>ssl_bump bump allowed-mac-full-access monitored-HTTPS</code> <br> <code>ssl_bump bump allowed-mac-extended monitored-HTTPS</code> <br> <code>ssl_bump bump allowed-mac monitored-HTTPS</code> <br> <code>ssl_bump splice allowed-https-always</code> <br> <code>ssl_bump splice allowed-mac-full-access</code> <br> <code>ssl_bump splice allowed-mac-extended allowed-https-extended</code> <br> <code>ssl_bump splice allowed-mac-extended !blocked-https</code> <br> <code>ssl_bump splice allowed-mac !blocked-https</code> </p> <br><p> <code>#  https,   </code> <br> <code>ssl_bump terminate all</code> </p> <br><p> <code>#        Squid</code> <br> <code>http_port 192.168.0.133:3128</code> <br> <code>http_port 192.168.0.133:3129 intercept</code> <br> <code>https_port 192.168.0.133:3127 intercept ssl-bump cert=/etc/squid/ssl_cert/myCA.pem generate-host-certificates=on dynamic_cert_mem_cache_size=4MB</code> </p> <br><p> <code>#  DNS.     </code> <br> <code>dns_nameservers 192.168.1.2 192.168.0.18</code> <br> <code>dns_v4_first on</code> </p> <br><p> <code>#  </code> <br> <code>sslcrtd_program /usr/lib64/squid/security_file_certgen -s /etc/squid/ssl_db -M 4MB</code> </p> <br><p> <code>#  </code> <br> <code>cache_dir ufs /var/spool/squid 100 16 256</code> <br> <code>coredump_dir /var/spool/squid</code> <br> <code>refresh_pattern ^ftp: 1440 20% 10080</code> <br> <code>refresh_pattern ^gopher: 1440 0% 1440</code> <br> <code>refresh_pattern -i (/cgi-bin/|\?) 0 0% 0</code> <br> <code>refresh_pattern . 0 20% 4320</code> </p> </div></div><br><p>  Reboot Squid: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># systemctl restart squid</span></span></code> </pre> <br><h3 id="dopolnitelno">  Additionally </h3><br><p>  To view the statistics, a large number of different <a href="http://www.squid-cache.org/Misc/log-analysis.html">log-analysis</a> software is written. </p><br><p>  The most famous SARG, ScreenSquid, lightsquid, SquidAnalyzer. </p><br><p>  For the configuration above, I had to use a samopisny log analyzer so that the full user names, and not the logins and MAC addresses, were included in the report.  Who knows perl and php can remake ScreenSquid to fit your needs.  My python periodically parses access.log, uploads the result to mysql, and uploads statistics to the html document upon request.  But this is a separate topic for conversation. </p><br><p>  Also, to check the availability of the site in files with url lists, I use a simple python 3 script (if desired, you can do the same to determine the MAC address in the files): </p><br><div class="spoiler">  <b class="spoiler_title">check_url.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re allowed_http_extended = <span class="hljs-string"><span class="hljs-string">'/etc/squid/allowed-http-extended.txt'</span></span> allowed_https_extended = <span class="hljs-string"><span class="hljs-string">'/etc/squid/allowed-https-extended.txt'</span></span> blocked_http = <span class="hljs-string"><span class="hljs-string">'/etc/squid/blocked-http.txt'</span></span> blocked_https = <span class="hljs-string"><span class="hljs-string">'/etc/squid/blocked-https.txt'</span></span> monitored_HTTPS = <span class="hljs-string"><span class="hljs-string">'/etc/squid/monitored-HTTPS.txt'</span></span> dict_blocked_http = {} <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(blocked_http,<span class="hljs-string"><span class="hljs-string">'r'</span></span>,encoding=<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, l <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(f,start=<span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> l.strip() != <span class="hljs-string"><span class="hljs-string">''</span></span>: dict_blocked_http[i] = l.lower() dict_blocked_https = {} <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(blocked_https,<span class="hljs-string"><span class="hljs-string">'r'</span></span>,encoding=<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, l <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(f,start=<span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> l.strip() != <span class="hljs-string"><span class="hljs-string">''</span></span>: dict_blocked_https[i] = l.lower() dict_allowed_http_extended = {} <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(allowed_http_extended,<span class="hljs-string"><span class="hljs-string">'r'</span></span>,encoding=<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, l <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(f,start=<span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> l.strip() != <span class="hljs-string"><span class="hljs-string">''</span></span>: dict_allowed_http_extended[i] = l.lower() dict_allowed_https_extended = {} <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(allowed_https_extended,<span class="hljs-string"><span class="hljs-string">'r'</span></span>,encoding=<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, l <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(f,start=<span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> l.strip() != <span class="hljs-string"><span class="hljs-string">''</span></span>: dict_allowed_https_extended[i] = l.lower() dict_monitored_HTTPS = {} <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(monitored_HTTPS,<span class="hljs-string"><span class="hljs-string">'r'</span></span>,encoding=<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, l <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(f,start=<span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> l.strip() != <span class="hljs-string"><span class="hljs-string">''</span></span>: dict_monitored_HTTPS[i] = l.lower() checked_site = input(<span class="hljs-string"><span class="hljs-string">" : "</span></span>) checked_site = checked_site.lower().strip() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dict_blocked_http: dict_key = dict_blocked_http.get(i).strip() result = re.search(dict_key,checked_site) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"   'blocked-http.txt',  '"</span></span> + str(i) + <span class="hljs-string"><span class="hljs-string">"'   '"</span></span> + dict_key + <span class="hljs-string"><span class="hljs-string">"'"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dict_blocked_https: dict_key = dict_blocked_https.get(i).strip() result = re.search(dict_key,checked_site) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"   'blocked-https.txt',  '"</span></span> + str(i) + <span class="hljs-string"><span class="hljs-string">"'   '"</span></span> + dict_key + <span class="hljs-string"><span class="hljs-string">"'"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dict_allowed_http_extended: dict_key = dict_allowed_http_extended.get(i).strip() result = re.search(dict_key,checked_site) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"   'allowed_http_extended.txt',  '"</span></span> + str(i) + <span class="hljs-string"><span class="hljs-string">"'   '"</span></span> + dict_key + <span class="hljs-string"><span class="hljs-string">"'"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dict_allowed_https_extended: dict_key = dict_allowed_https_extended.get(i).strip() result = re.search(dict_key,checked_site) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"   'allowed_https_extended.txt',  '"</span></span> + str(i) + <span class="hljs-string"><span class="hljs-string">"'   '"</span></span> + dict_key + <span class="hljs-string"><span class="hljs-string">"'"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dict_monitored_HTTPS: dict_key = dict_monitored_HTTPS.get(i).strip() result = re.search(dict_key,checked_site) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"   'monitored_HTTPS.txt',  '"</span></span> + str(i) + <span class="hljs-string"><span class="hljs-string">"'   '"</span></span> + dict_key + <span class="hljs-string"><span class="hljs-string">"'"</span></span>)</code> </pre> </div></div><br><p>  Run the script, enter the url link, we get a list of files with indication of line numbers with which a match was found. </p><br><p>  That's all. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/353100/">https://habr.com/ru/post/353100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353084/index.html">Digital Signature Cloud Services</a></li>
<li><a href="../353088/index.html">We write the plugin for Unity correctly. Part 1: iOS</a></li>
<li><a href="../353090/index.html">IT asset management: how myths affect projects (Part 2)</a></li>
<li><a href="../353092/index.html">Digital events in Moscow from April 9 to 15</a></li>
<li><a href="../353094/index.html">ECO Flow in Vivado or working in netlist editing mode</a></li>
<li><a href="../353102/index.html">Effective use of AWS spot instances</a></li>
<li><a href="../353104/index.html">Procedural maze generation in Unity</a></li>
<li><a href="../353108/index.html">Is it possible to enter the closed door, or how patches vulnerabilities</a></li>
<li><a href="../353110/index.html">Mitap Cocoaheads in Tutu.ru office</a></li>
<li><a href="../353112/index.html">Security violations of mobile applications as a result of insufficient attention of the developers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>