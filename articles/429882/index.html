<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Control of RGB LEDs via the UDB unit of PSoC microcontrollers from Cypress</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 I have long wanted to study the programming methodology of UDB blocks in Cypress PSoC controllers, but all hands somehow did not reach....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Control of RGB LEDs via the UDB unit of PSoC microcontrollers from Cypress</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/is/cg/hl/iscghlsqtbktd8fhkstyrghp9ee.jpeg"><br><br><h2>  Introduction </h2><br>  I have long wanted to study the programming methodology of UDB blocks in Cypress PSoC controllers, but all hands somehow did not reach.  And so, there was a problem in which this could be done.  Understanding the materials from the network, I realized that practical recommendations for working with UDB are limited to certain variations of counters and PWMs.  All authors for some reason make their own variations of these two canonical examples, so the description of something else may well be interesting to readers. <br><a name="habracut"></a><br>  So.  There was a problem to dynamically control a long line of R28 LEDs WS2812B.  Classical approaches to this case are known.  You can take the banal Arduino, but there the output goes programmatically, so while the data is being output - everything else is idle, otherwise the time diagrams will fail.  You can take STM32 and output data either through DMA to PWM or through DMA to SPI.  Techniques are known.  I even, at one time, personally through SPI already ruled a line of sixteen diodes.  But the overhead is great.  One bit of data in the LEDs takes 8 bits in memory for the case of PWM and from 3 to 4 bits (depending on the PLL rate in the controller) for SPI.  While there are few LEDs, it is not scary, but if, say, a couple of hundred, then 200 * 24 = 4800 bits = 600 bytes of useful data should be physically stored in a buffer of more than 4 kilobytes for the PWM variant or more than 2 kilobytes for SPI- option.  For dynamic indication, there should be several buffers, while the STM32F103 has RAM for everything about 20 kilobytes.  It‚Äôs not that we have rested against an unrealizable task, but the reason for checking whether it can be implemented on PSoC without the need for spending extra RAM is quite significant. <br><br><h2>  References to the theory </h2><br>  First, we will understand what kind of a beast is such a UDB and how it is worked with.  This will help great educational films from the manufacturer of controllers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Start watching <a href="https://www.youtube.com/watch%3Fv%3DdnKuXRkhoj0">from here</a> , and then at the end of each video will be a link to the next series.  Step by step, you will gain basic knowledge and consider the canonical example of ‚Äúcounter‚Äù.  Well, the control system of traffic lights. <br><br>  Approximately the same, but cut into small pieces, can be <a href="http://www.cypress.com/training/psoc-creator-video-tutorial-series-how-use-udb-editor">found here</a> .  My video did not play, but it can be downloaded and viewed locally.  Among other things, there is a canonical example of the implementation of PWM. <br><br><h2>  Search for ready-made solutions </h2><br>  In order not to reinvent the wheel (and vice versa - to study the technique on someone else's experience), I rummaged around the network in search of ready-made solutions for controlling RGB LEDs.  The most popular solution is StripLightLib.cylib.  But he has for many years been planning to add support for DMA.  And I want to try exactly the solution that does not depend on the CPU.  I want to start the process and forget about it, focusing on the preparation of the next frame. <br><br>  The solution that matches my desires was found at <a href="https://github.com/PolyVinalDistillate/PSoC_DMA_NeoPixel">https://github.com/PolyVinalDistillate/PSoC_DMA_NeoPixel</a> . <br><br>  There everything is implemented on UDB (after all, LEDs are just an excuse, the goal is to study UDB).  There is support for DMA.  And the project there is clearly beautifully organized. <br><br><h2>  Problems of the chosen solution </h2><br>  How is the "firmware" in the project PSoC_DMA_NeoPixel, anyone can see after reading the article.  This will fix the material.  So far, I will only say that at first I simplified the logic of the original microprogram without reducing the resources consumed (but it has become easier to understand).  Then he began to experiment with replacing the logic of the automaton, which promised a gain in resources, but ran into a serious problem.  And so I decided - it is not eliminated!  And they began to torment me with vague doubts whether the English author had the same problem?  His demo flashes LEDs very nicely.  But what if we replace the beautiful filling with ‚Äúall units‚Äù and control the output with an oscilloscope, not with our eyes? <br>  So, as roughly as possible (you can even say ‚Äúbrutal‚Äù) we generate data: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">memset</span></span> (pPixelArray,<span class="hljs-number"><span class="hljs-number">0xff</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pPixelArray)); <span class="hljs-comment"><span class="hljs-comment">//Call NeoPixel update function (non blocking) to trigger DMA pixel update NP_Update();</span></span></code> </pre> <br>  And we see this picture on the oscilloscope: <br><br><img src="https://habrastorage.org/webt/kv/u7/wu/kvu7wuciw7tafpf_cjjbp4m-gzw.png"><br><br>  At the first bit, the width is different from all the others.  I asked to send all the units, but not all go.  Zero was among them!  Change the scan: <br><br><img src="https://habrastorage.org/webt/2k/ev/mb/2kevmb_fna8e8oce9pkdwhaofcg.png"><br><br>  The width is different for every eighth bit. <br><br>  In general, this example as an independent solution is not suitable, but as a source of inspiration - just perfect.  First, its inoperability is not visible to the eye (the LEDs light up brightly anyway, the eye does not see that they shine to half the maximum), but the code is well structured, it is pleasant to take it as a basis.  Secondly, this example gives the space for finding ways to simplify, and thirdly, it makes you wonder how to eliminate the defect.  The most is to comprehend the materiel!  So once again I recommend, after reading the article, try to disassemble the original example, having understood how it works. <br><br><h2>  Practical part </h2><br>  Now we begin to practice.  Test the main aspects of the development of firmware for UDB.  Consider the relationship and the basic techniques.  To do this, open <a href="https://yadi.sk/d/IyycAEYRlvtxGQ">my version of the project</a> .  The left block stores information about the working files.  By default, the <b>Source</b> tab is open.  The main source of the project is the <b>main.c</b> file.  Actually, there are no other work files in the <b>Source Files</b> group. <br><br><img src="https://habrastorage.org/webt/-n/xu/lm/-nxulmetonhzhf6lwlvr30f-2r8.png"><br><br>  The <b>Generated Source</b> group contains library functions.  It is better not to rule them.  After each change in the UDB firmware, this group will be re-generated.  So, where in this idyll is the description of the code for UDB?  To see it, you need to switch to the <b>Components</b> tab: <br><br><img src="https://habrastorage.org/webt/qb/yj/ku/qbyjkuvng7ibcdlhiftcf5qld6o.png"><br><br>  The author of the original project made a two-level set of components.  At the top level is the <b>NeoPixel_v1_2.cysch</b> scheme.  This is evident from the main scheme: <br><br><img src="https://habrastorage.org/webt/z3/cg/fr/z3cgfrfl4k_rdsuu2dw6kykq_o4.png"><br><br>  The component is as follows: <br><br><img src="https://habrastorage.org/webt/zp/h3/yw/zph3ywaeojjenc6ailxcmsb3f0m.png"><br><br>  We will consider software support for this scheme later.  In the meantime, we find out that there is a regular DMA block on it and a certain symbol <b>NeoPixDrv_v1</b> .  This mysterious block is described above in the tree, which follows from the following hint: <br><br><img src="https://habrastorage.org/webt/zk/_u/2p/zk_u2pxpdmiokfow6b4iur-_ab0.png"><br><br><h2>  UDB Firmware </h2><br>  Open that component (file with the extension <b>.cyudb</b> ).  The opened drawing is simply huge.  We begin to understand what is what. <br><br><img src="https://habrastorage.org/webt/e6/co/4l/e6co4lsbmphoom6ikhuhutzkzbe.png"><br><br>  Unlike the author of the original project, I consider the transfer of each bit of data in the form of three equally-sized (in time) parts: <br><br><ol><li>  Starting part (always 1) </li><li>  Part of the data </li><li>  Stop part (always 0) </li></ol><br>  With this approach, a large number of counters are not required (in the original there were as many as three pieces, for which a large amount of resources were spent).  The duration of all parts is the same and can be set using one register.  Thus, the transition graph of the firmware automaton contains the following states: <br><br>  State of rest ( <b>Idle</b> ).  In it the machine remains until new data has arrived in the FIFO. <br><br><img src="https://habrastorage.org/webt/s_/r5/zn/s_r5zn54lff9nd9thvqxphyxjqq.png"><br><br>  From the training videos I was not entirely clear how the states of the machine are connected with the ALU.  The authors use the connection as something self-evident, but I, as a beginner, could not immediately see it.  Let's immediately understand in detail.  The figure above shows that the <b>Idle</b> state is encoded by the value 1'b0.  It will be more correct to 3'b000, but the editor will still redo everything.  The inputs of the <b>Datapath</b> block <b>are</b> described like this: <br><br><img src="https://habrastorage.org/webt/dq/qc/zp/dqqczpv87oulrwzvu-cbcmucsee.png"><br><br>  If you double-click on them, a more detailed option will appear: <br><br><img src="https://habrastorage.org/webt/pu/xm/ts/puxmtsmg3jf3hjnwstnpbeu-exe.png"><br><br>  This means that the zero bit of the address of the ALU instruction corresponds to the zero bit of the variable that defines the state of the automaton.  The first is the first, the second is the second.  If desired, the bits of the address of the ALU instruction can be matched by any variables and even expressions (in the original version, the second bit of the address of the instruction of the ALU was matched by the expression, and in the current version it is clearly not used, but as an outgoing brain the example is very clear, then you can take a look). <br><br>  So.  With the current setting of the inputs, which is the binary status code of the automaton, such an ALU instruction is used.  When we are in the <b>Idle</b> state, which has the code 000, the null instruction is used.  Here she is: <br><br><img src="https://habrastorage.org/webt/4p/oz/gt/4pozgtr4-p66hypvlz2rqdjta2a.png"><br><br>  I already know from this record that this is a banal NOP.  But you can double click on it and read the full version: <br><br><img src="https://habrastorage.org/webt/-a/vl/ii/-avliivwnptl2ra9ipfxseurxqk.png"><br><br>  Everywhere inscribed NOPy.  Registers are not filled with anything. <br><br>  Now let's see what this mysterious flag is <b>! NoData</b> , forcing the machine gun to leave the state of rest.  This is the output from the <b>Datapath</b> block.  In total, up to six outputs can be described.  Simply, <b>Datapath</b> can generate much more flags, but there will not be enough tracing resources for everyone, so you need to choose which six (or less) we really need.  Here is the list in the figure: <br><br><img src="https://habrastorage.org/webt/qf/a7/yd/qfa7ydqxuql3khszkw1mqbdb63m.png"><br><br>  Double-clicking on it will reveal the details: <br><br><img src="https://habrastorage.org/webt/vu/zo/2z/vuzo2zxg56zpyaavdunmw60eapg.png"><br><br>  Here is the complete list of flags that could be displayed: <br><br><img src="https://habrastorage.org/webt/gi/la/jf/gilajfhzmatw2hjtfjk9xl1gs7m.png"><br><br>  After selecting the desired flag, you should give it a name.  From this point on, the system has a flag.  As you can see, the <b>NoData</b> flag is the name for the <b>F0 block status (empty)</b> chain.  That is a sign that there is no data in the input buffer.  And <b>! NoData</b> , respectively, its inversion.  Sign of data availability.  As soon as the data gets into the FIFO (programmatically or with the help of DMA), the flag will be cleared (and its inversion set), and on the next cycle the machine will exit the rest state and go to the <b>GetData</b> state. <br><br><img src="https://habrastorage.org/webt/lw/o3/av/lwo3avzjvfqynfpw-3t075oat-0.png"><br><br>  As you can see, the machine will definitely come out of this state, having stayed in it for exactly one cycle.  No actions are indicated for this state on the transition graph.  But you always have to look at what the ALU will do.  The status code is 1'b1, that is, 3'b001.  We look at the corresponding address in the ALU: <br><br><img src="https://habrastorage.org/webt/ic/zk/y8/iczky8asdanru7kzgfzznebiynm.png"><br><br>  There is something.  Having no experience reading what is written here, we reveal it by double clicking on the corresponding cell: <br><br><img src="https://habrastorage.org/webt/vu/yf/gf/vuyfgfecoxpfd1brc6v_lzu4a3w.png"><br><br>  It follows that the ALU itself still does not perform any actions.  But in the register A0 the contents of FIFO0 will be placed, that is, the data coming from the program or the DMA block.  Looking ahead, I will say that A0 is used as a shift register, from which the byte will be output in a sequential form.  Register A1 will put the value of register D1.  In general, all registers D are usually filled with software before the active operation of the equipment begins.  Then, when examining the API, we will see that the number of machine ticks, which sets the duration of a third bit, is put in this register.  So.  The shifted value has fallen into A0, and the value of the duration of the bit start bit in A1.  And on the next cycle, the machine will certainly switch to the <b>Constant1</b> state. <br><br><img src="https://habrastorage.org/webt/ue/jx/fh/uejxfhlbmgbh0wgkuy2k4fe-qva.png"><br><br>  As follows from the name of the state, the constant 1 is generated here. Let's consider the documentation on the LED.  This is how the unit should be transmitted: <br><br><img src="https://habrastorage.org/webt/cn/2t/i3/cn2ti3ppzpacxrbyi2uy8mq5wte.png"><br><br>  And so - zero: <br><br><img src="https://habrastorage.org/webt/z6/yg/vp/z6ygvphpsb700_acfvwiek9mbeo.png"><br><br>  I added the red lines.  If we assume that the duration of the third is equal, then the requirements for the duration of the pulses (given in the same documentation) are fulfilled.  That is, any impulse consists of a start unit, a data bit, and a stop zero.  Actually, the starting unit is transmitted when the machine is in the <b>Constant1</b> state. <br><br>  In this state, the machine clicks the unit in its internal trigger.  The name of the trigger is <b>CurrentBit</b> .  In the original project, it was generally a trigger that sets the state of the auxiliary machine.  I decided that that machine would only confuse everyone, so I simply started the trigger.  It is not described anywhere.  But if you enter the state properties, the following entry is visible in the table: <br><br><img src="https://habrastorage.org/webt/tz/2e/m4/tz2em4pv4kxwsg5fvzkhx7-ve_w.png"><br><br>  And under the state on the graph has the following text: <br><br><img src="https://habrastorage.org/webt/bx/az/0c/bxaz0clixua21k_umbqpch3vrca.png"><br><br>  Do not be scared by the symbol "Equal."  These are features of the editor.  In the resulting Verilog code (automatically created by the same system) there will be an arrow: <br><br><pre> <code class="plaintext hljs">Constant1 : begin CurrentBit &lt;= (1); if (( CycleTimeout ) == 1'b1) begin MainState &lt;= Setup1 ; end end</code> </pre> <br>  The value snapped into this trigger is the output of our entire block: <br><br><img src="https://habrastorage.org/webt/bv/jq/qd/bvjqqdmqg-2framc6_trktlfix4.png"><br><br>  That is, when the machine enters the <b>Constant1</b> state, a unit will hit the output of the block we are developing.  Now we look how the ALU is programmed for the address 3'b010: <br><br><img src="https://habrastorage.org/webt/5e/4v/hi/5e4vhiqa5gl7wo6xk0zzea_8_dm.png"><br><br>  Expand this item: <br><br><img src="https://habrastorage.org/webt/ij/wx/fc/ijwxfcl3zzmuhlef2qq-j6hhkme.png"><br><br>  A unit is subtracted from register A1.  The output value of the ALU falls into register A1.  Above, we considered that A1 is a clock counter used to set the duration of the output pulse.  Let me remind you that it was loaded from D1 at the last step. <br>  What is the condition out of the state?  <b>CycleTimeOut</b> .  It is described among the exits as follows: <br><br><img src="https://habrastorage.org/webt/7m/1c/pn/7m1cpnxbqkt6fv4x5fv73idlp3g.png"><br><br>  So, we bring the logic together.  In the past state, the contents of the D1 register that was previously filled with the program fell into the A1 register.  At this step, the automaton translates the <b>CurrentBit</b> trigger to one, and in the ALU, register A1 decreases on each clock cycle.  When A1 becomes zero, the flag will automatically be <b>coded</b> , to which the author gave the name <b>CycleTimeout</b> , as a result of which the machine will go to the <b>Setup1</b> state. <br><br>  The state <b>Setup1</b> prepares data for transmitting a useful pulse. <br><br><img src="https://habrastorage.org/webt/on/3g/j-/on3gj-j0zujays_x6uxn_grjnq8.png"><br><br>  We look at the instructions of the ALU at 3'b011.  I will immediately open it: <br><br><img src="https://habrastorage.org/webt/2u/uu/tl/2uuutl1vwixsvirqgsuwfvxhsb4.png"><br><br>  It would seem that the ALU has no action.  The operation is NOP.  And the output of the ALU does not go anywhere.  But it is not.  Extremely important action is the shift of data in the ALU.  The fact is that the carry bit among the outputs is connected to our <b>ShiftOut</b> chain: <br><br><img src="https://habrastorage.org/webt/ov/8g/-e/ov8g-emfyzhu3vhj65unf0ukirw.png"><br><br>  And as a result of this shift operation, the shifted value itself will not get anywhere, but the <b>ShiftOut</b> circuit will take the value of the <b>high</b> bit of register A0.  That is, the data that should be transmitted.  Under the state of the graph, it is clear that this value, which has left the ALU in the <b>ShiftOut</b> circuit, will be latched into the <b>CurrentBit</b> trigger.  Let me show you the drawing again so as not to wind the article up: <br><br><img src="https://habrastorage.org/webt/3t/kq/ef/3tkqefuwb4cbt1mdx7uiqlwazjo.png"><br><br>  The transmission of the second part of the bit begins - an immediate value of 0 or 1. <br><br>  We return to the instructions for the ALU.  In addition to what has already been said, it is clear that along the way, the contents of register D1 will again be put in register A1, so that the second third of the pulse can be measured again. <br><br>  The <b>DataStage</b> state is very similar to the <b>Constant1</b> state.  The machine simply subtracts one from A1 and goes to the next state upon reaching zero.  Let me even show it like this: <br><br><img src="https://habrastorage.org/webt/ya/ir/hs/yairhsxxk0q9jvmctsthu0lswjk.png"><br><br>  and so: <br><br><img src="https://habrastorage.org/webt/_-/cj/k9/_-cjk95cwake-lvvpgv5p4gc33i.png"><br><br>  Then comes the state of <b>Setup2</b> , the essence of which we already know too. <br><br><img src="https://habrastorage.org/webt/x6/bw/qa/x6bwqa1zi6_s0zdcazzcgcp_emw.png"><br><br>  In this state, the <b>CurrentBit</b> trigger <b>is</b> reset to zero (since the third third of the pulse will be transmitted, the stop part, and it is always zero).  ALU loads the contents of D1 into A1.  You can even see it with a pointed eye in a brief record: <br><br><img src="https://habrastorage.org/webt/dv/pm/1q/dvpm1qqxtwut-1egggnj5mgintu.png"><br><br>  The <b>Constant0</b> state is completely identical to the <b>Constant1</b> and <b>DataStage</b> states.  Subtract one from A1.  When the value reaches zero, we exit the state <b>ShiftData</b> : <br><br><img src="https://habrastorage.org/webt/d2/bs/bx/d2bsbxn-pd5opvpeh3g8us5aqkg.png"><br><br><img src="https://habrastorage.org/webt/4i/g2/my/4ig2mytms6p5mt2_msq8cwl33hi.png"><br><br>  <b>ShiftData</b> state <b>is</b> more complicated.  In the relevant instructions for the ALU, the following actions are performed: <br><br><img src="https://habrastorage.org/webt/r7/hn/bx/r7hnbxsnr0ynuxfexzrlisurybi.png"><br><br>  Register A0 is shifted by 1 bit, and the results are moved back to A0.  In A1, the contents of D1 are put again to begin measuring the starting third for the next bit of data. <br><br>  Output arrows should be considered with regard to priorities, for which we double-click on the state of <b>ShiftData</b> . <br><br><img src="https://habrastorage.org/webt/sp/dx/f1/spdxf1xnw2j_7ytbypqrbhql6da.png"><br><br>  If not the last bit is transmitted (about how this flag is formed, just below), then we pass one for the next bit of the current byte. <br><br>  If the last bit is transmitted and there is no data in the FIFO, we go to the rest state. <br><br>  Finally, if the last bit is transmitted, but there is data in the FIFO, we go to sample and transmit the next byte. <br><br>  Now about the bit counter.  There are only two batteries in the ALU: A0 and A1.  They are already occupied by the shift register and the delay counter, respectively.  Therefore, the bit counter is used external. <br><br><img src="https://habrastorage.org/webt/dx/p2/wv/dxp2wv0kt0othgs12nwnq7anuqs.png"><br><br>  Double click on it: <br><br><img src="https://habrastorage.org/webt/dz/tj/kz/dztjkza856xdotpsckoje-fnmzo.png"><br><br>  The value at boot is six.  It is loaded by the <b>LoadCounter</b> flag, described in the variables section: <br><br><img src="https://habrastorage.org/webt/e3/-a/tf/e3-atfbenscj9nudppvxrab9ylg.png"><br><br>  That is, when the next data byte is taken, this constant is loaded at the same time. <br><br>  When the machine enters the state <b>ShiftData</b> , the counter decreases the value.  When the value reaches zero, the <b>TerminalCount</b> output is connected, connected to the <b>FinalBit</b> circuit of our <b>family</b> .  It is this circuit that determines whether the automaton will send the next bit of the current byte or transmit a new byte (well, or wait for a new packet of data). <br><br>  Actually, from logic - everything.  How the <b>SpaceForData</b> signal is <b>generated</b> , which sets the state of the <b>Hungry</b> output (informing the DMA block that the next data can be transmitted), readers are invited to track themselves. <br><br><h2>  Software support </h2><br>  The author of the original project chose to make software support for the entire system in a block describing a complex solution.  Let me remind you that we are talking about this block: <br><br><img src="https://habrastorage.org/webt/pi/uz/vz/piuzvzjzbcuaqyqqlwnvrmwgh8m.png"><br><br>  From this level, both the DMA library block and all parts included in the UDB part are controlled.  To implement the API, the original author added header and program files: <br><br><img src="https://habrastorage.org/webt/af/2y/aw/af2yaw0qcmxmjzsevxq30sjwfc4.png"><br><br>  The format of the body of these files is depressing.  All because of the love of the developers of PSoC Designer to "pure sam."  Hence the terrible macros and kilometer names.  Class organization in C ++ would be most welcome here.  At least, we checked it when implementing our RTOS MAX: it turned out nice and comfortable.  But here you can talk a lot, and you will have to use what is lowered from above.  I only briefly show you what the API function looks like, containing these same macros: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* `$INSTANCE_NAME`_Start(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nNumberOfNeopixels, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pBuffer, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fSpeedMHz) { <span class="hljs-comment"><span class="hljs-comment">//work out cycles required at specified clock speed... `$INSTANCE_NAME`_g_pFrameBuffer = NULL; if((0.3/(1.0/(fSpeedMHz))) &gt; 255) return NULL; unsigned char fCyclesOn = (unsigned char)(0.35/(1.0/(fSpeedMHz))); `$INSTANCE_NAME`_g_nFrameBufferSize = nNumberOfNeopixels*3; //Configure for 19.2 MHz operation `$INSTANCE_NAME`_Neo_BITCNT_Start(); //Counts bits in a byte //Sets bitrate frequency in number of clocks. Must be larger than largest of above two counter periods CY_SET_REG8(`$INSTANCE_NAME`_Neo_DPTH_D1_PTR, fCyclesOn+1); //Setup a DMA channel `$INSTANCE_NAME`_g_nDMA_Chan = `$INSTANCE_NAME`_DMA_DmaInitialize(`$INSTANCE_NAME`_DMA_BYTES_PER_BURST, `$INSTANCE_NAME`_DMA_REQUEST_PER_BURST, HI16(`$INSTANCE_NAME`_DMA_SRC_BASE), HI16(`$INSTANCE_NAME`_DMA_DST_BASE)); if(pBuffer == NULL) ...</span></span></code> </pre> <br>  These rules of the game will have to accept.  Now you know where you can get inspiration from when developing your functions (best of all, in the original project).  And I would prefer to talk about the details, taking the variant already processed by the generator. <br><br>  After generating the code (described below), this file will be stored here: <br><br><img src="https://habrastorage.org/webt/b2/c_/j_/b2c_j_llpmg3yjjwirq4b3bjkag.png"><br><br>  And the view will already be perfectly readable.  There are two functions so far.  The first initializes the system, the second starts the transfer of data from the buffer to the line of LEDs. <br><br>  Initialization affects all parts of the system.  There is an initialization of the seven-bit counter included in the UDB system: <br><br><pre> <code class="cpp hljs"> NP_Neo_BITCNT_Start(); <span class="hljs-comment"><span class="hljs-comment">//Counts bits in a byte</span></span></code> </pre> <br>  There is a calculation of the constant, which should be loaded into the D1 register (recall that it sets the duration of each of the third bits): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> fCyclesOn = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)(<span class="hljs-number"><span class="hljs-number">0.35</span></span>/(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/(fSpeedMHz))); CY_SET_REG8(NP_Neo_DPTH_D1_PTR, fCyclesOn+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Setting up a DMA block takes up most of this function.  The source is the buffer, and the receiver is the FIFO0 of the UDB block (in kilometer records, <b>NP_Neo_DPTH_F0_PTR</b> ).  The author of this setting was in the data transfer function.  But, in my opinion, it is too wasteful to do all the calculations for the sake of each transmission.  Especially if one considers that one of the actions inside the function looks very, very voluminous. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//work out cycles required at specified clock speed... NP_g_pFrameBuffer = NULL; NP_g_nFrameBufferSize = nNumberOfNeopixels*3; //Setup a DMA channel NP_g_nDMA_Chan = NP_DMA_DmaInitialize(NP_DMA_BYTES_PER_BURST, NP_DMA_REQUEST_PER_BURST, HI16(NP_DMA_SRC_BASE), HI16(NP_DMA_DST_BASE)); ... NP_g_nDMA_TD = CyDmaTdAllocate(); CyDmaTdSetConfiguration(NP_g_nDMA_TD, NP_g_nFrameBufferSize, CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(NP_g_nDMA_TD, LO16((uint32)NP_g_pFrameBuffer), LO16((uint32)NP_Neo_DPTH_F0_PTR)); CyDmaChSetInitialTd(NP_g_nDMA_Chan, NP_g_nDMA_TD);</span></span></code> </pre><br>  The second function on the background of the first is the height of laconicism.  Just the first is called at the initialization stage, when the speed requirements are very free.  While working, it is better not to waste processor cycles on anything extra: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NP_Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(NP_g_pFrameBuffer) { CyDmaChEnable(NP_g_nDMA_Chan, <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre><br>  There is clearly not enough functionality for working with multiple buffers (to provide double buffering), but in general, a discussion of the functionality of the API is beyond the scope of the article.  Now the main thing is to show how to add software support to the developed firmware.  Now we know how to do it. <br><br><h2>  Project generation </h2><br>  So, the entire firmware part is ready, the API is added, what to do next?  Select the menu item <b>Build-&gt; Generate Application</b> . <br><br><img src="https://habrastorage.org/webt/b-/5d/yv/b-5dyvvwubusbcm5f4xzy7bhie4.png"><br><br>  If everything goes well, you can open the <b>Results</b> tab and view the file with the <b>rpt</b> extension. <br><br><img src="https://habrastorage.org/webt/d2/5e/4d/d25e4d3xlv845numi21z2wzxzba.png"><br><br>  It shows how much system resources are spent on the implementation of the firmware part. <br><br><img src="https://habrastorage.org/webt/bv/mm/yn/bvmmynvgxcssd33wk-aetjwwbd4.png"><br><br><img src="https://habrastorage.org/webt/wr/_u/mo/wr_umoub3comqr_3v4qxcqbhpwi.png"><br><br>  When I compare the results with those that were in the original project, it gets warmer in my heart. <br><br>  Now go to the <b>Source</b> tab and start working with the software part.  But this is already trivial and does not require special explanations. <br><br><img src="https://habrastorage.org/webt/w4/d6/d5/w4d6d5fhjcllllxyqtjva7j-upo.png"><br><br><h2>  Conclusion </h2><br>  I hope, from this example, the readers learned something new and interesting about practical work with UDB blocks.  I tried to focus on both the specific task (LED control) and the design methodology, since I had to comprehend some aspects that were obvious to specialists.  I tried to mark them while the memories of the search were fresh.  As for the solved problem, the time diagrams I got were not as perfect as the author of the original design, but they fit perfectly into the tolerances defined in the documentation for the LEDs, and the system resources were significantly less. <br><br>  In fact, this is only a part of the non-standard information found.  In particular, from most materials it may seem that UDB works well only with serial data, but it is not.  Found Application Note, which briefly shows how you can drive and parallel data.  It would be possible to consider specific examples based on this information (although, to overshadow FX2LP, another controller from Cypress, will not succeed: PSoC has a lower USB bus speed). <br><br>  I have ideas in my head about how to solve the problem of the firmware of a 3D printer that has tormented me for a long time.  There, interrupts serving stepper motors, devouring just an insane percentage of processor time.  In general, I talked a lot about interruptions and processor time in the <a href="https://habr.com/post/340032/">article about the MAX RTOS</a> .  There are estimates that for servicing stepper motors, it is possible to take out all the shelters completely at the mercy of UDB, leaving the processor with a purely computational task without the fear that it will not have time to do this in a dedicated time slot. <br><br>  But it will be possible to speculate about these things only if the topic turns out to be interesting. </div><p>Source: <a href="https://habr.com/ru/post/429882/">https://habr.com/ru/post/429882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../429872/index.html">Environment generation based on sound and music in Unity3D</a></li>
<li><a href="../429874/index.html">Apple temporarily closes the Search Ads service for Russian developers because of the "tax on Google"</a></li>
<li><a href="../429876/index.html">Researchers overcame the most powerful ad blockers, a format war is coming</a></li>
<li><a href="../429878/index.html">Why with the growth of the company, the developers who stood at the origins, are "overboard"</a></li>
<li><a href="../429880/index.html">Pix4D - from photos to measurements</a></li>
<li><a href="../429884/index.html">Conference Prostor 2018: questions and answers about the future of storage systems</a></li>
<li><a href="../429890/index.html">Open webinar "Generative competitive networks"</a></li>
<li><a href="../429892/index.html">xonsh - python as shell replacement</a></li>
<li><a href="../429894/index.html">Using the Fish eye camera on a Raspberry Pi 3 with ROS - part 2</a></li>
<li><a href="../429898/index.html">DMS (Dealership Management System) - Implementation of Information EcoSystems for Dealer Networks Management</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>