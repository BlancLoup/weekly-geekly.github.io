<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Radio-controlled switch do it yourself. Part 3 - Switch Software</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In previous posts, we designed, made and comprehensively tested a two-channel radio-controlled switch unit. 



 But so far it has been a ‚Äúsoulless pi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Radio-controlled switch do it yourself. Part 3 - Switch Software</h1><div class="post__text post__text-html js-mediator-article">  In previous posts, we <a href="http://habrahabr.ru/post/211126/">designed, made</a> and comprehensively <a href="http://habrahabr.ru/post/212785/">tested</a> a two-channel radio-controlled switch unit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca4/f33/68c/ca4f3368cf462b7f12ba8ae3e149937e.jpg"><br><br>  But so far it has been a ‚Äúsoulless piece of iron,‚Äù which, despite all its potential power embedded in the MC, does not know how. <br><a name="habracut"></a><br>  In general, our main device (if we don‚Äôt consider connecting a radio module) is in no way more complicated than the most ordinary Arduinka, to which two buttons and a pair of LEDs are connected (in the resulting device - the LEDs are replaced with transistor switches that control the tracks, but it doesn‚Äôt change the essence ). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The manufactured radio switch module doesn‚Äôt have much to do development and debugging right on it: <br><ul><li>  there is no possibility to receive diagnostic messages in the ‚Äúport monitor‚Äù, </li><li>  There is no visual confirmation of which of the relays and in what condition it is, etc. </li></ul><br>  But, as I have already noted, to ‚Äúrevitalize‚Äù our module, all you need is to write a sketch that would work out various presses (two buttons) and could enable / disable two loads according to our algorithm (in the layout this would be a pair of LEDs).  Naturally, this is the ‚Äúbasic functionality‚Äù, after we deal with it - we will add ‚Äúradio channel‚Äù functions. <br><br><blockquote>  In general, of course, it would be better to start with a ‚Äúmockup‚Äù, but in this case it turned out that the prototype was made later than the resulting device. </blockquote><br><h4>  Layout </h4><br>  So, in order to get a ‚Äúconvenient‚Äù environment for preparing our sketch, let's take a solderless breadboard, any arduino-compatible board (in my case, it is cArduino Nano), two clock buttons, two LEDs (with current limiting resistors) and several jumpers: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/359/4de/737/3594de737102d38783c8b5b9d4a2cfae.jpg"><br><br>  We collect the model, according to the concept from the <a href="http://habrahabr.ru/post/211126/">first post</a> . <br><br>  I recall: <br><ul><li>  The button for the first channel is connected between pin A1 and ground (GND), </li><li>  The second channel button is A0 and GND. </li><li>  The LEDs (indicators of the operation of the corresponding transistor switches and relays in the radio switch) are connected to D3 and D4, respectively. </li></ul><br>  Actually, this layout will allow us to write and debug the basic functionality. <br><br>  In the future, you will need to download this sketch using the programmer to the final device without alterations. <br><br>  Before starting development, you should fix the basic functions that you would like to implement. <br><br><h4>  Desired functionality </h4><br>  Naturally, this list of "hotelok" is in the head even before the start of work on the project, now I will just formulate <br><br><h5>  Basic functions </h5><br>  The two-channel switch will be used to control the light and ventilation in the bathroom, so the list of features turned out to be this: <br><ul><li>  By brief pressing, turn on / off the corresponding load channel (channel 1 - light, channel 2 - ventilation). </li><li>  For a long press (more than 2 seconds) - to record the fact of such pressing (‚Äúcocking the flag‚Äù), but for now do nothing extra. </li><li>  If the light is on for more than 1.5 minutes - automatically turn on the hood (for example, someone went to the shower and forgot to turn on the ventilation). </li><li>  If both channels were turned on and the first channel is turned off, automatically turn off the second channel after 10 minutes. </li><li>  In case if any load was turned on, but forgot to turn it off, turn it off automatically (each channel has its own auto-off time: 60 and 10 minutes, respectively). </li></ul><br><blockquote>  When forming the list of functions - actively communicate with the home.  For example, it was reasonable for me to suggest that the time after which the automatic activation of ventilation should take place is too short and there will be unnecessary alarms and, in general, all the time parameters should be able to be adjusted during operation. </blockquote><br><h5>  Radio control </h5><br>  These functions will be implemented a little later, but they should immediately be remembered (less will have to be rewritten): <br><ul><li>  The on / off commands received over the radio channel must be processed as if the switch buttons were physically pressed (i.e., full preservation of the basic logic). </li><li>  Through the radio channel you need to be able to change all the time parameters of the switch operation. </li><li>  The time parameters of the switch should be stored in non-volatile memory (so that after each shutdown of electricity there is no need to ‚Äúretrain‚Äù the module). </li><li>  All parameters (current state, ‚Äúlong press‚Äù flags, temporary) should be available over the air both on request (response to a request) and on a regular basis (every 15 seconds - ‚Äúflood‚Äù on the air with the current values ‚Äã‚Äãof parameters). </li></ul><br><h4>  Programming </h4><br>  In the course of creating software for the implementation of basic functions, we will consider the following: <br><ol><li>  Now there are two channels, but in the future they can be more / less and the code should be such that it can be easily corrected (without significant rewriting). </li><li>  The device is built in and in case of any failure to get it out of the wall is extremely problematic. </li></ol><br>  The first requirement leads to the use of an array of structures for storing the module operation parameters, and the second dictates the use of a <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2582%25D0%25B0%25D0%25B9%25D0%25BC%25D0%25B5%25D1%2580">watchdog timer</a> . <br><br>  To store the channel parameters, I created the following structure: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> button; <span class="hljs-comment"><span class="hljs-comment">//   int relay; //   boolean state; //  (/) unsigned long power_on; // ,     unsigned long auto_off; // ,      unsigned long time_off; // ,  boolean autostate; // , ,    unsigned long press_start; // ,    unsigned long press_stop; // ,    } Channel;</span></span></code> </pre> <br>  Now you can write a simple sketch. <br><br>  In the setup () function, we perform all the necessary initialization and weighed the "guard dog". <br><br>  Then everything is simple: in the main program loop (loop ()) we will consistently take the following steps: <br><ul><li>  We work with buttons (function button_read ()). </li><li>  We work out auto power off (autoOff ()). </li><li>  Implement additional work logic (chkLogic ()). </li><li>  Reset the watchdog timer (wdt_reset ()). </li></ul><br>  If the additional logic of the work is not needed (in my case it is automatic switching on and off of ventilation depending on the state of the light) - the chkLogic () function can be simply deleted. <br><br><div class="spoiler">  <b class="spoiler_title">I got this sketch</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  #include &lt;avr/wdt.h&gt; #include &lt;Bounce.h&gt; //#define DEBUG //      -  //    #define CH 2 //      #define LONGPRESS 2000 // 2  //      "" typedef struct { int button; //   int relay; //   boolean state; //  (/) unsigned long power_on; // ,     unsigned long auto_off; // ,      unsigned long time_off; // ,  boolean autostate; // , ,    unsigned long press_start; // ,    unsigned long press_stop; // ,    } Channel; //    Channel MySwitch[CH] = { 15, 3, LOW, 0, 3600000, 0, false, 0, 0, 14, 4, LOW, 0, 600000, 0, false, 0, 0 }; //    Bounce.  ,         . Bounce bouncer0 = Bounce(MySwitch[0].button,5); Bounce bouncer1 = Bounce(MySwitch[1].button,5); //     boolean logicFlag = false; boolean onFlag = false; boolean offFlag = false; void setup() { wdt_disable(); //         bootloop #ifndef DEBUG Serial.begin(9600); Serial.println("Start!"); pinMode(13, OUTPUT); #endif //  pinMode(MySwitch[0].relay, OUTPUT); pinMode(MySwitch[1].relay, OUTPUT); //  pinMode(MySwitch[0].button, INPUT); pinMode(MySwitch[1].button, INPUT); //      digitalWrite(MySwitch[0].button, HIGH); digitalWrite(MySwitch[1].button, HIGH); //delay(5000); // ,        bootloop #ifndef DEBUG Serial.println("Ready!"); #endif wdt_enable (WDTO_8S); //        8 . } void loop() { //    button_read(); //   autoOff(); //     chkLogic(); //    wdt_reset(); } void button_read(){ //    1 if ( bouncer0.update() ) { if ( bouncer0.read() == LOW) { //     MySwitch[0].press_start = millis(); } else { // ,    (  )  ,  . pressDetect(0, millis()); } } //    2 if ( bouncer1.update() ) { if ( bouncer1.read() == LOW) { MySwitch[1].press_start = millis(); } else { pressDetect(1, millis()); } } } //   void doSwitch(int ch, boolean state){ //    MySwitch[ch].state = state; //      ""      if (MySwitch[ch].state == HIGH) { //    MySwitch[ch].power_on = millis(); if(MySwitch[ch].auto_off &gt; 0) { //  ,      MySwitch[ch].time_off = MySwitch[ch].power_on + MySwitch[ch].auto_off; MySwitch[ch].autostate = true; } #ifndef DEBUG Serial.print("ON "); Serial.println(ch); #endif } else { //    MySwitch[ch].autostate = false; //    MySwitch[ch].time_off = 0; #ifndef DEBUG Serial.print("OFF "); Serial.println(ch); #endif } digitalWrite(MySwitch[ch].relay,MySwitch[ch].state); } //  void autoOff(){ //     for (int i=0; i &lt; CH; i++) { //     -   if ((millis() &gt;= MySwitch[i].time_off) &amp;&amp; MySwitch[i].autostate) { MySwitch[i].autostate = false; doSwitch(i, LOW); #ifndef DEBUG Serial.print("Auto OFF "); Serial.println(i); #endif } } } //         void pressDetect(int ch, unsigned long p_stop) { if (MySwitch[ch].press_start != 0) { if ((p_stop-MySwitch[ch].press_start) &lt; LONGPRESS) { //   MySwitch[ch].press_stop = p_stop; #ifndef DEBUG Serial.print("Short press "); Serial.println(ch); #endif doSwitch(ch, MySwitch[ch].state ? LOW : HIGH); } else { //   #ifndef DEBUG Serial.print("Long press "); Serial.println(ch); digitalWrite(13, HIGH); delay(1000); digitalWrite(13, LOW); #endif } } } //    void chkLogic(){ /*   ( /) 0- -  / 1- -  /  0   ,  1.5 ,     1 .   0  - 1    10  */ //     1,5 ,     -    if ((onFlag == false) &amp;&amp; (millis() &gt; (MySwitch[0].power_on + 90000)) &amp;&amp; (MySwitch[0].state == HIGH) &amp;&amp; (MySwitch[1].state == LOW) &amp;&amp; (MySwitch[1].press_stop &lt; MySwitch[0].power_on)) { //   doSwitch(1, HIGH); //    onFlag = true; logicFlag = true; //      MySwitch[1].autostate = false; #ifndef DEBUG Serial.println("Auto Logic ON"); #endif } //    -      -  10     if ((logicFlag == true) &amp;&amp; (offFlag == false) &amp;&amp; (MySwitch[1].state == HIGH) &amp;&amp; (MySwitch[0].state == LOW)) { MySwitch[1].time_off = millis() + 600000; MySwitch[1].autostate = true; offFlag = true; #ifndef DEBUG Serial.println("Auto Logic OFF started"); #endif } //   ,    if ((logicFlag == true) &amp;&amp; (MySwitch[0].state == LOW) &amp;&amp; (MySwitch[1].state == LOW)) { offFlag = false; onFlag = false; logicFlag = false; #ifndef DEBUG Serial.println("Logic reset"); #endif } //        -    if ((logicFlag == false) &amp;&amp; (offFlag == false) &amp;&amp; (MySwitch[0].press_stop &gt; MySwitch[1].power_on) &amp;&amp; (MySwitch[1].state == HIGH) &amp;&amp; (MySwitch[0].state == LOW)) { logicFlag = true; #ifndef DEBUG Serial.println("Auto OFF 1 after manual OFF 0"); #endif } }</span></span></code> </pre><br></div></div><br>  Basic functions work exactly as desired. <br>  Short button presses include the corresponding LEDs, additional logic works.  By long pressing any button - the built-in LED (D13) on the Arduino is lit for one second. <br><br>  Now you can implement and wireless functions. <br><br>  To do this, we turn to one of my earlier posts: <a href="http://habrahabr.ru/post/171613/">Wireless communications of the ‚Äúsmart home‚Äù</a> . <br><br>  The basic principles that I described there have withstood the test of time and have undergone very minor changes. <br><br>  The following structure is suitable for working with parameters: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Value; <span class="hljs-comment"><span class="hljs-comment">//  boolean Status; //  // 0 - RO // 1 - RW char Note[16]; //  } Parameter;</span></span></code> </pre><br>  For the transmitted data I will use the following structure: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SensorID; <span class="hljs-comment"><span class="hljs-comment">//   int CommandTo; //    ... int Command; //  // 0 -  // 1 -   // 2 -   int ParamID; //   float ParamValue; //   boolean Status; //  // 0 -    (RO) // 1 -   (RW) char Comment[16]; //  } Message;</span></span></code> </pre><br>  According to the above, my module will be described as follows: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SID 701 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   #define NumSensors 8 //   Parameter MySensors[NumSensors+1] = { //   (  ) NumSensors,0,"BR 2Floor", //    0,1,"Ch.1 (Light)", //   1 () 0,1,"Ch.2 (Vent)", //   2 () 0,1,"Ch.1 (LP)", //     1  0,1,"Ch.2 (LP)", //     2  0,1,"Auto-delayON", //      (  ),   0,1,"Auto-delayOFF", //      (  ),   0,1,"Ch.1 AutoOFF", //    1 ,   0,1,"Ch.2 AutoOFF" //    2 ,   }; Message sensor;</span></span></span></span></code> </pre><br>  It is seen that all the key parameters that describe the current state and time parameters are present. <br><br><div class="spoiler">  <b class="spoiler_title">A little more programming and the code is ready.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  #include &lt;avr/wdt.h&gt; #include &lt;Bounce.h&gt; #include &lt;SPI.h&gt; #include "RF24.h" #include &lt;EEPROM.h&gt; #define DEBUG //    -  //    #define CH 2 //      #define LONGPRESS 2000 // 2  //    #define SID 701 //   #define NumSensors 8 //   //      "" typedef struct { int button; //   int relay; //   boolean state; //  (/) unsigned long power_on; // ,     unsigned long auto_off; // ,      unsigned long time_off; // ,  boolean autostate; // , ,    unsigned long press_start; // ,    unsigned long press_stop; // ,    } Channel; //    Channel MySwitch[CH] = { 15, 3, LOW, 0, 0, 0, false, 0, 0, 14, 4, LOW, 0, 0, 0, false, 0, 0 }; //      typedef struct{ float Value; //  boolean Status; //  // 0 - RO // 1 - RW char Note[16]; //  } Parameter; //      typedef struct{ int SensorID; //   int CommandTo; //    ... int Command; //  // 0 -  // 1 -   // 2 -   int ParamID; //   float ParamValue; //   boolean Status; //  // 0 -    (RO) // 1 -   (RW) char Comment[16]; //  } Message; ///////////////////////////////////////////////////////////////////////////// Parameter MySensors[NumSensors+1] = { //   (  ) NumSensors,0,"701 (2F, bath)", //   ""         0,1,"Ch.1 (Light)", //   1 () 0,1,"Ch.2 (Vent)", //   2 () 0,1,"Ch.1 (LP)", //     1  0,1,"Ch.2 (LP)", //     2  0,1,"Auto-delayON", //      (  ),   0,1,"Auto-delayOFF", //      (  ),   0,1,"Ch.1 AutoOFF", //    1 ,   0,1,"Ch.2 AutoOFF" //    2 ,   }; Message sensor; ///////////////////////////////////////////////////////////////////////////// //    Bounce.  ,         . Bounce bouncer0 = Bounce(MySwitch[0].button,5); Bounce bouncer1 = Bounce(MySwitch[1].button,5); //     boolean logicFlag = false; boolean onFlag = false; boolean offFlag = false; //RF24 radio(CE,CSN); RF24 radio(10,9); unsigned long measureTime; #define DELTAMEASURE 15000 //   15      const uint64_t pipes[2] = { 0xF0F0F0F0A1LL, 0xF0F0F0F0A2LL }; volatile boolean waitRF24 = false; void setup() { wdt_disable(); //         bootloop //    EEPROM prepareFromEEPROM(); #ifndef DEBUG Serial.begin(9600); Serial.println("Start!"); pinMode(13, OUTPUT); #endif for(int i=0; i&lt;CH; i++) { //  pinMode(MySwitch[i].relay, OUTPUT); //  pinMode(MySwitch[i].button, INPUT); //      digitalWrite(MySwitch[i].button, HIGH); } //  initRF24(); //    ( -   ) attachInterrupt(0, isr_RF24, FALLING); measureTime = millis()+DELTAMEASURE; //delay(5000); // ,        bootloop #ifndef DEBUG Serial.println("Ready!"); #endif wdt_enable (WDTO_8S); //        8 . } void loop() { //    button_read(); //   autoOff(); //     chkLogic(); //   listenRF24(); //   -    floodRF24(); //    wdt_reset(); } void button_read(){ //    1 if ( bouncer0.update() ) { if ( bouncer0.read() == LOW) { //     MySwitch[0].press_start = millis(); } else { // ,    (  )  ,  . pressDetect(0, millis()); } } //    2 if ( bouncer1.update() ) { if ( bouncer1.read() == LOW) { MySwitch[1].press_start = millis(); } else { //MySwitch[1].press_stop = millis(); pressDetect(1, millis()); } } } //   void doSwitch(int ch, boolean state){ //     MySwitch[ch].state = state; //      ""      if (MySwitch[ch].state == HIGH) { //    MySwitch[ch].power_on = millis(); if((MySwitch[ch].auto_off &gt; 0) &amp;&amp; (MySwitch[ch].auto_off != 0)) { //  ,      MySwitch[ch].time_off = MySwitch[ch].power_on + MySwitch[ch].auto_off; MySwitch[ch].autostate = true; } #ifndef DEBUG Serial.print("ON "); Serial.println(ch); #endif } else { //    MySwitch[ch].autostate = false; //    MySwitch[ch].time_off = 0; #ifndef DEBUG Serial.print("OFF "); Serial.println(ch); #endif } digitalWrite(MySwitch[ch].relay,MySwitch[ch].state); } //  void autoOff(){ //     for (int i=0; i &lt; CH; i++) { //     -   if ((millis() &gt;= MySwitch[i].time_off) &amp;&amp; MySwitch[i].autostate) { MySwitch[i].autostate = false; doSwitch(i, LOW); #ifndef DEBUG Serial.print("Auto OFF "); Serial.println(i); #endif } } } //         void pressDetect(int ch, unsigned long p_stop) { if (MySwitch[ch].press_start != 0) { if (((p_stop-MySwitch[ch].press_start) &lt; LONGPRESS) &amp;&amp; (p_stop-MySwitch[ch].press_start) &gt; 0) { //   MySwitch[ch].press_stop = p_stop; #ifndef DEBUG Serial.print("Short press "); Serial.println(ch); #endif doSwitch(ch, MySwitch[ch].state ? LOW : HIGH); } else { //   #ifndef DEBUG Serial.print("Long press "); Serial.println(ch); digitalWrite(13, !digitalRead(13)); #endif //       MySensors[ch+3].Value = 1; //      ""   //    "" , -  (  ) //        ""  } } } //    void chkLogic(){ /*   ( /) 0- -  / 1- -  /  0   ,  1.5 ,     1 .   0  - 1    10  */ //       ( MySensors[5].Value   - ),     -    if ((onFlag == false) &amp;&amp; (millis() &gt; (MySwitch[0].power_on + MySensors[5].Value*60000)) &amp;&amp; (MySensors[5].Value != 0) &amp;&amp; (MySwitch[0].state == HIGH) &amp;&amp; (MySwitch[1].state == LOW) &amp;&amp; (MySwitch[1].press_stop &lt; MySwitch[0].power_on)) { //   doSwitch(1, HIGH); //    onFlag = true; logicFlag = true; //      MySwitch[1].autostate = false; #ifndef DEBUG Serial.println("Auto Logic ON"); #endif } //    -      -    (( MySensors[6].Value   - )    if ((logicFlag == true) &amp;&amp; (offFlag == false) &amp;&amp; (MySensors[6].Value != 0) &amp;&amp; (MySwitch[1].state == HIGH) &amp;&amp; (MySwitch[0].state == LOW)) { MySwitch[1].time_off = millis() + MySensors[6].Value*60000; MySwitch[1].autostate = true; offFlag = true; #ifndef DEBUG Serial.println("Auto Logic OFF started"); #endif } //   ,    if ((logicFlag == true) &amp;&amp; (MySwitch[0].state == LOW) &amp;&amp; (MySwitch[1].state == LOW)) { offFlag = false; onFlag = false; logicFlag = false; #ifndef DEBUG Serial.println("Logic reset"); #endif } //        -    if ((logicFlag == false) &amp;&amp; (offFlag == false) &amp;&amp; (MySwitch[0].press_stop &gt; MySwitch[1].power_on) &amp;&amp; (MySwitch[1].state == HIGH) &amp;&amp; (MySwitch[0].state == LOW)) { logicFlag = true; #ifndef DEBUG Serial.println("Auto OFF 1 after manual OFF 0"); #endif } } void floodRF24(){ //    (1   DELTAMEASURE ) //    !   -      ! if (millis() &gt; measureTime){ getValue(); //      //for (int i=1; i&lt;=NumSensors; i++) { //     (,    -  ) for (int i=1; i&lt;=4; i++) { sendSlaveMessage(0, i); delay(20); } measureTime = millis()+DELTAMEASURE; } } void getValue(){ MySensors[1].Value = MySwitch[0].state; MySensors[2].Value = MySwitch[1].state; return; } //      void isr_RF24(){ waitRF24 = true; } //   (, ,  ) -   (slave) // !     ParamID void sendSlaveMessage(int To, int ParamID) { //    radio.stopListening(); radio.openWritingPipe(pipes[0]); radio.openReadingPipe(1,pipes[1]); delay(20); //      sensor.SensorID = SID; sensor.CommandTo = To; sensor.Command = 0; sensor.ParamID = ParamID; sensor.ParamValue = MySensors[ParamID].Value; sensor.Status = MySensors[ParamID].Status; memcpy(&amp;sensor.Comment,(char*)MySensors[ParamID].Note, 16); //   RF24 bool ok = radio.write( &amp;sensor, sizeof(sensor) ); delay (20); //    radio.openWritingPipe(pipes[1]); radio.openReadingPipe(1,pipes[0]); radio.startListening(); } //   void listenRF24(){ //   ,       if (waitRF24) { waitRF24 = false; // ,   //    if (radio.available()) { bool done = false; while (!done) { done = radio.read( &amp;sensor, sizeof(sensor) ); //     -  if (sensor.CommandTo == SID) { //   ( , , , ) doCommand(sensor.SensorID, sensor.Command, sensor.ParamID, sensor.ParamValue, sensor.Status, sensor.Comment); } } } } } //   ( , , ID,  , , ) -   void doCommand(int From, int Command, int ParamID, float ParamValue, boolean Status, char* Comment) { //     -      ,    -  switch (Command) { case 0: //    break; case 1: getValue(); //     sendSlaveMessage(From, ParamID); break; case 2: //  setValue(From, ParamID, ParamValue, Comment); //  sendSlaveMessage(From, ParamID); break; default: break; } } //   (, , , ) void setValue(int From, int ParamID, float ParamValue, char* Comment) { //         -    if(MySensors[ParamID].Value != ParamValue){ //   / -  ( ) ""     //    ""    (    ) if((ParamID&lt;3) &amp;&amp; (MySwitch[ParamID-1].state != (boolean)ParamValue)) { // " " MySwitch[ParamID-1].press_start = millis()-50; // " " (  ""   ) pressDetect(ParamID-1, millis()); } else { //   MySensors[ParamID].Value = ParamValue; //   ,    -   EEPROM if (ParamID &gt; 4){ EEPROM.write(ParamID-5, MySensors[ParamID].Value); //    if(ParamID &gt; 6) { MySwitch[ParamID-7].auto_off = ((unsigned long)MySensors[ParamID].Value)*60000; } } } } } void initRF24(){ radio.begin(); radio.setRetries(15,15); //     ( ) radio.setChannel(100); radio.openWritingPipe(pipes[0]); radio.openReadingPipe(1,pipes[1]); radio.startListening(); //    } void prepareFromEEPROM() { // 4  = 4    1 : // 0 -      (  ),   // 1 -      (  ),   // 2 -    1 ,   // 3 -    2 ,   for(int i=0; i&lt;4; i++) { MySensors[i+5].Value = EEPROM.read(i); } //        for(int i=0; i&lt;CH; i++) { MySwitch[i].auto_off = ((unsigned long)MySensors[i+7].Value)*60000; } }</span></span></code> </pre></div></div><br>  Actually, it now remains to flash our module. <br><br>  For firmware, I use <a href="http://learn.adafruit.com/usbtinyisp">the USBtinyISP programmer</a> . <br><br>  I stitched, checked the work - everything is OK, but it turned out that in the "pure" MK all the EEPROM bytes are set to 255, which gives the corresponding delays. <br><br>  By the code above, it is clear that the installation of all time parameters is performed only through a radio channel.  But I haven‚Äôt written anything about the ‚Äúcontrol module‚Äù yet, so we need to somehow solve this problem ‚Äúin isolation‚Äù. <br><br>  To do this, you can use examples from the EEPROM library and directly write primary (more current) values ‚Äã‚Äãdirectly into the corresponding cells of non-volatile memory. <br><br>  A follow-up check showed that everything now works exactly as desired. <br><blockquote>  Once again I will repeat my basic principle of the devices of my ‚Äúsmart home‚Äù: <i>each created device is made to achieve a specific goal and it should work independently</i> . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the device is self-sufficient and ready to perform its main function (even without a radio channel). </font><font style="vertical-align: inherit;">You can mount.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Module installation </font></font></h4><br>         ‚Äî     (                         ). <br><br>      ,   <a href="http://habrahabr.ru/post/195884/">  </a> ‚Äî     iPhone.  ,   <a href="http://easyelectronics.ru/kondensatornoe-pitanie.html">  </a>      (, <a href="http://www.aliexpress.com/store/group/Single-Output-Power-Module/208521_211361961.html"></a> ). <br><br>  -  (    ‚Äî       ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca4/f33/68c/ca4f3368cf462b7f12ba8ae3e149937e.jpg"><br><br>    ,       ‚Äî  . <br><br>   , ,        ,         ,  ¬´ ¬ª. <br><br>     ¬´¬ª    ( ,     ,    ): <br><ul><li>    . </li><li>    (  ,     ,   ‚Äî  ). </li><li>    </li><li>      (   ¬´¬ª,   ¬´ ¬ª). </li><li>            (     ,       ). </li><li>  ,             (        ‚Äî ,       ,   ¬´- ¬ª      ). </li><li>         . </li></ul><br> , .    ,    ,  . <br><br><h4>  Result </h4><br>        ¬´¬ª ,     ¬´¬ª (    ¬´¬ª ,  /   ..). <br><br> <b><a href="http://habrahabr.ru/post/215419/"> </a> ...</b> <br><br> <b>PS</b>  <a href="http://habrahabr.ru/post/211126/"></a> <a href="http://habrahabr.ru/post/211126/"> </a>        ,         . <br><div class="spoiler"> <b class="spoiler_title">       :</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/786/45c/28f/78645c28f1a80099a1904c369506a278.jpg"><br><br>    ( )     .  /   220 ( ,     ‚Äî  ).  5,       ( ). </div></div><br>    ,          (   ¬´  ¬ª) ‚Äî ,    (   ) , ! <br><br> <b> </b> : <br><ul><li> <a href="http://habrahabr.ru/post/189744/">Arduino watchdog   RESET   </a> </li><li> <a href="http://habrahabr.ru/post/171613/">  ¬´ ¬ª</a> </li><li> <a href="http://easyelectronics.ru/kondensatornoe-pitanie.html"> </a> </li></ul><br>  Thank you <a href="http://geektimes.ru/users/nikita_rogatnev/" class="user_link">Nikita_Rogatnev</a> for help in preparing the material for publication. </div><p>Source: <a href="https://habr.com/ru/post/215177/">https://habr.com/ru/post/215177/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../215163/index.html">My tool for time tracking and invoicing</a></li>
<li><a href="../215167/index.html">The Linux Foundation and EdX begin a free course on Introduction to Linux.</a></li>
<li><a href="../215171/index.html">Simple filter tapes VK for "bad" words and what he can become</a></li>
<li><a href="../215173/index.html">Statistics using javascript libraries and CDN</a></li>
<li><a href="../215175/index.html">Firefox Download Panel Improvements</a></li>
<li><a href="../215181/index.html">How signals and slots work in Qt (part 2)</a></li>
<li><a href="../215183/index.html">The digest of interesting news and materials from the world of PHP No. 37 (February 24 - March 9, 2014)</a></li>
<li><a href="../215185/index.html">Sample Application - Phonebook on AngularJS + Bootstrap v3</a></li>
<li><a href="../215189/index.html">Python Meetup: January Meeting</a></li>
<li><a href="../215197/index.html">Interesting and informative: the flight to the ISS on the PTK NP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>