<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using the verifier as a means of rapid simulation of RTL projects. Introduction to UVM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article will describe the installation and use of free software for simulating digital logic circuits in Verilog as alternatives to the commercia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using the verifier as a means of rapid simulation of RTL projects. Introduction to UVM</h1><div class="post__text post__text-html js-mediator-article">  This article will describe the installation and use of free software for simulating digital logic circuits in Verilog as alternatives to the commercial Incisve products from Cadense and ModelSim from MentorGraphics.  Simulation comparison in ModelSim and Verilator.  There will also be considered a universal verification methodology - UVM. <br><br><h2>  Installation software for SystemC UVM </h2><br><h3>  1. Verifier </h3><br>  One of the languages ‚Äã‚Äãof the description of the equipment is verilog.  In this language, you can write a module. <br><br>  For example, there is a counting scheme: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/s6/a7/9i/s6a79i89t6vzfl-a6dqeiwi5fh8.png" alt="image"><br><br>  Its code will look like this: <br><br><pre><code class="cpp hljs">reg [<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]counter; always @(posedge clk <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> posedge reset)   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(reset)    counter &lt;= <span class="hljs-number"><span class="hljs-number">4'</span></span>d0;   <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>    counter &lt;= counter + <span class="hljs-number"><span class="hljs-number">1'</span></span>d1;</code> </pre> <br>  After the simulation, we get waveforms: <br><br><img src="https://habrastorage.org/webt/m5/-o/mg/m5-omg9r-4_fzvo1momfxt7wq-8.png" alt="image"><br><br>  It can be seen that the next value, one greater than the previous one, will be written to the counter registers on the clock edge. <br><br>  The written module may have a more complex structure, it will be difficult to check all the conditions manually.  We need automated testing.  To do this, you need to develop a test environment in one of the programming languages.  The test environment will give us the opportunity to conduct a full functional test of the device. <br><br>  To test the project code, in addition to languages ‚Äã‚Äãsuch as Verilog, SystemVerilog, Python (for writing models), you can use <a href="https://ru.wikipedia.org/wiki/SystemC">SystemC</a> .  SystemC is a system-level design and verification language implemented as an open source C ++ library. <br><br>  One way Verilog modules are verified using SystemC is to translate verilog files in C ++.  Verilator will help us in this. <br><br>  Verilator is the fastest free Verilog HDL simulator that surpasses most commercial simulators.  Verilator compiles the synthesized SystemVerilog (usually not the test bench code), as well as some SystemVerilog and Synthesis statements into single-threaded or multi-threaded C ++ or SystemC code.  Verilator has been designed for large projects where simulation speed is paramount and is particularly well suited for generating executable processor models for embedded software development teams.  Verilator is used to simulate many very large multi-million dollar gateway designs with thousands of modules and is supported by many suppliers of IP technologies, including IP from Arm and all well-known suppliers of RISC-V IP. <br><a name="habracut"></a><br>  Verilator may not be the best choice if you expect a full-featured replacement for the NC-Verilog, VCS or another commercial Verilog simulator, or the Verilog behavioral simulator for a very small project.  However, if you are looking for a way to port the synthesized Verilog to C ++ or SystemC, and your team is free to write only C ++ code, this is the free Verilog compiler for you. <br><br>  To install the latest version on Ubuntu: download the archive <a href="">from the link from the official site</a> . <br><br>  Install: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#sudo apt-get install make autoconf g++ flex bison # Prerequisites unsetenv VERILATOR_ROOT # For csh; ignore error if on bash unset VERILATOR_ROOT # For bash tar xvzf verilator*.t*gz cd verilator* ./configure make sudo make install</span></span></code> </pre> <br><h3>  2. GTK Wave </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/adc/de9/6c3/adcde96c392048d083337f797505b1fc.gif" alt="image"><br>  GTKWave is a full-featured waveform viewer and also allows you to convert files from vcd format to fst format, more convenient and faster. <br><br>  Install: <br><br><pre> <code class="bash hljs">sudo apt-get install gtkwave</code> </pre> <br><h3>  3. SYSTEMC </h3><br>  A system-level design and verification language implemented as an open source C ++ library. <br><br>  As mentioned earlier, verilator supports systemc, so you need to create a project in which the testbench will be described on systemc, and the source files on the synthesized verilog.  For this we need the libraries for the g ++ compiler provided by Accelera.  The Accellera Systems Initiative is an independent, non-profit organization dedicated to the creation, support, promotion and promotion of system-level design, simulation and verification standards for use in the global electronics industry. <br><br>  Download the archive: <br>  <a href="">http://accellera.org/images/downloads/standards/systemc/systemc-2.3.1a.tar.gz</a> <br><br>  Install: <br><br><pre> <code class="bash hljs">tar -xvf systemc-2.3.1a.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> systemc-2.3.1a mkdir objdir sudo ./configure --prefix=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/systemc-2.3.1a/ sudo make sudo make install <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ../</code> </pre> <br><h3>  4. UVM for SYSTEMC </h3><br>  This article will consider the project in which the UVM verification tool is implemented.  Verification is the confirmation that the final product meets the predefined reference requirements.  One of their verification tools can be tests.  In order to run test sequences on models of real devices at the RTL description level, it is necessary to develop a test environment. <br><br>  <a href="https://en.wikipedia.org/wiki/Universal_Verification_Methodology">UVM</a> - (Universal Verification Methodology) is a universal verification methodology, a standard that allows you to effectively develop and reuse the environment of checking IP-blocks.  UVM is a verification methodology whose task is to organize an effective environment around the unit under test.  Its advantages: <br><br><ul><li>  clear structure in the form of dedicated blocks decisive concrete </li><li>  tasks; </li><li>  the ability to reuse blocks in subsequent projects; </li><li>  maximum possible verification automation; </li><li>  the fullest reporting information that allows for the occurrence of an error to quickly and accurately identify its causes and propose solutions. </li></ul><br>  UVM methodologies consist of two parts: a set of rules for constructing a test environment and a library of block presets for verification, for example, a text generator, a statistics collector, etc.  The main advantage of UVM is versatility and compatibility with third-party environments. <br><br>  Since systemc supports the UVM methodology, let's move on to installing the necessary libraries. <br><br>  Download the archive: <br><br>  <a href="">https://www.accellera.org/images/downloads/drafts-review/uvm-systemc-1.0-beta2.tar.gz</a> <br><br>  Install: <br><br><pre> <code class="bash hljs">tar -xvf uvm-systemc-1.0-beta2.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> uvm-systemc-1.0-beta2/ mkdir objdir sudo ./configure --prefix=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/systemc_uvm/ --with-systemc=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/systemc-2.3.1a sudo make sudo make install</code> </pre><br>  Create an alliance: <br><br><pre> <code class="bash hljs">sudo mkdir /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/uvm_systemc_aliance</code> </pre> <br>  Copy the contents of the / usr / local / uvm_systemc_aliance / and /usr/local/systemc-2.3.1/ folders into this folder. <br><br>  Download the finished project at the link: <br>  <a href="https://github.com/paprikun/SYSTEMC/">https://github.com/paprikun/SYSTEMC/</a> <br><br>  Open the folder verilator examples. <br>  The rtl folder contains the device description.  In this example, this is a PWM controller. <br>  In the sim folder makefile file to build the project. <br>  In the tb folder is the code for the verifier.  The tb / uvm folder contains an example of a uvm environment.  The main file is the entry point for testing, connecting the device under test with the uvm environment. <br>  We try to build the project from the sim folder with the command make all.  We see the error: <br><br><pre> <code class="bash hljs">/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/uvm_systemc_aliance//include/systemc.h:120:16: error: <span class="hljs-string"><span class="hljs-string">'std::gets'</span></span> has not been declared using std::gets;</code> </pre> <br>  Correct by replacing line 120: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(__cplusplus) &amp;&amp; (__cplusplus &lt; 201103L) using std::gets; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Once again we try to run a testbench and stumble upon a warning: <br><br><pre> <code class="bash hljs">/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/uvm_systemc_aliance//include/sysc/packages/boost/get_pointer.hpp:21:40: warning: <span class="hljs-string"><span class="hljs-string">'template&lt;class&gt; class std::auto_ptr'</span></span> is deprecated [-Wdeprecated-declarations] template&lt;class T&gt; T * get_pointer(std::auto_ptr&lt;T&gt; const&amp; p)</code> </pre> <br>  Change auto_ptr to unique_ptr. <br><br><h2>  Build the project and simulation </h2><br>  Now that the libraries are installed and working properly, we are building the project: make all.  The simu executive file should appear in the sim folder.  This is an object created by the compiler.  Run it with the command ./simu.  The following should appear: <br><br><pre> <code class="bash hljs">SystemC 2.3.1-Accellera --- Jun 28 2019 11:39:29 Copyright (c) 1996-2014 by all Contributors, ALL RIGHTS RESERVED Universal Verification Methodology <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> SystemC (UVM-SystemC) Version: 1.0-beta2 Date: 2018-10-24 Copyright (c) 2006 - 2018 by all Contributors See NOTICE file <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> all Contributors ALL RIGHTS RESERVED Licensed under the Apache License, Version 2.0 UVM_INFO @ 0 s: reporter [RNTST] Running <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ... simulation real time = 9 sec UVM_INFO uvm_default_report_server.cpp(666) @ 179490249010 ps: reporter [UVM/REPORT/SERVER] --- UVM Report Summary --- ** Report counts by severity UVM_INFO : 1 UVM_WARNING : 0 UVM_ERROR : 0 UVM_FATAL : 0 ** Report counts by id [RNTST] 1 UVM_INFO @ 179490249010 ps: reporter [FINISH] UVM-SystemC phasing completed; simulation finished</code> </pre><br>  When the simulation is finished, the wafeform recording is complete.  The file simu.vcd can be opened by the gtkwave program: <br><br><img src="https://habrastorage.org/webt/xv/9m/ka/xv9mkaqsrcrvfczarjl5rz29i88.png"><br><br>  To display the signals on the left, select SystemC, then hold Shift, select any signals, and click Append.  Hints appear on the toolbar when you hover the cursor.  Mouse scrolling works, you need to hold shift or cntrl. <br><br>  There are also ways to convert this file to another, smaller size. <br><br>  If there are modelsim do the conversion.  In the terminal, enter the command vsim.  In the modelsim terminal: <br><br><pre> <code class="bash hljs">vcd2wlf simu.vcd simu.wlf</code> </pre> <br>  Or using gtkwave in linux terminal: <br><pre> <code class="bash hljs">vcd2lxt simu.vcd simu.lxt vcd2lxt2 simu.vcd simu.lxt2</code> </pre> <br>  To compare the simulation time, a similar project was created, but for <a href="https://www.intel.ru/content/www/ru/ru/software/programmable/quartus-prime/model-sim.html">Modelsim</a> .  Folder modelsim_example.  The UVM environment is similarly created.  The syntax is similar despite the fact that different languages.  If Modelsim is installed with uvm support, you can run it with make all. <br><br>  In addition to the environment in both projects, real-time modeling was measured. <br><br>  By the time it turned out the difference: <br><div class="scrollable-table"><table><tbody><tr><td>  Wednesday </td><td>  wafeform </td><td>  command to run </td><td>  simulation time (sec.) </td></tr><tr><td>  Modelsim </td><td>  Yes </td><td>  make sim TRACE = 1 </td><td>  18 </td></tr><tr><td>  Verilator </td><td>  Yes </td><td>  make sim TRACE = 1 </td><td>  9 </td></tr><tr><td>  Modelsim </td><td>  not </td><td>  make sim TRACE = 0 </td><td>  ten </td></tr><tr><td>  Verilator </td><td>  not </td><td>  make sim TRACE = 0 </td><td>  four </td></tr></tbody></table></div><br>  As can be seen from the table verilator has an advantage.  The data are presented for PCs with 8 GB of RAM, 8-core processor, 800 MHz, one core load. <br><br>  Compare the volume of files: <br><div class="scrollable-table"><table><tbody><tr><td>  simu.vcd </td><td>  807.7 MB </td></tr><tr><td>  simu.wlf (conversion, created in Verilator) </td><td>  41 MB </td></tr><tr><td>  simu.wlf (created in modelsim) </td><td>  9.3 MB </td></tr><tr><td>  simu.lxt </td><td>  128 MB </td></tr><tr><td>  simu.lxt2 </td><td>  162 MB </td></tr></tbody></table></div><br>  Here verilator loses, but you can experiment with the creation of waveforms and the depth of the trace, the recording period (the beginning and end of the waveform recording can be shifted).  What file to work with you. <br><br>  In the course of testing, in addition to the simulation itself, a discrepancy was found in reading input data from the in bus.  If the data from the bus in change during the clk front, Modelsim read the data after the front, verilator before: <br><br><pre> <code class="cpp hljs">input clk; input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] in; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] in_last_ ; ... always @(posedge clk) begin ... in_last_ &lt;= in; ... end</code> </pre><br><img src="https://habrastorage.org/webt/nc/ky/9r/ncky9rwjfvckf6hetlogg-futqa.png" alt="image"><br><br>  When testing, this point should be taken into account, as part of the test environment for different simulators will work differently. <br><br>  Also, verilator does not take into account the ‚Äúx‚Äù state of the signal and translates everything into ‚Äú0‚Äù; <br><br><h2>  UVM TESTBENCH </h2><br>  Consider the test environment folder tb / uvm. <br><br>  UVM testbench is an environment above the device.  In this example, the device is a PWM controller.  UVM environment: <br><br><img src="https://habrastorage.org/webt/94/tp/ox/94tpox5qii7r4qqaaakc_fbqrd4.png" alt="image"><br><br>  As can be seen in the diagram, UVM consists of blocks (classes).  Each unit performs its functions.  The example shows one of the possible layouts of the test environment.  The name and functionality of each class corresponds to the class from which it is inherited.  Consider each class in more detail. <br><br>  Environment- file env.h or env.svh.  This is a class that can contain one or several agent classes in which three classes are connected: sequencer, driver, monitor.  In the example, there is no agent, but its function is implemented in the env class.  For the test, we need to write some sequence of actions - a sequence. <br><br>  Let's go to the startup code for the sequence: <br><br><pre> <code class="cpp hljs">sequence_[n]-&gt;start(sqr, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre> <br>  Sequencer (sequencer) - file sequncer.h.  In system verilog it turned out to use sequencer by default.  A class that contains one or more sequences (sequence) (files sequence_a.h, sequence_a.svh).  Each sequence represents a chain of actions.  One such action may be sending a transaction.  Transaction - transfer data from one class to another.  The class in which transactions are described is bus_trans.  Next will be a description of two classes, each of which ideologically has its own specific functions: driver and monitor. <br><br>  Driver - file drv.h, drv.svh.  A class that accepts transactions from a sequencer and translates them into signals.  The driver serves as a sequencer assistant at a lower level.  Consider sending a single parcel. <br><br>  The sequence opens the transaction window, the driver detects this event and starts receiving data.  Sequence waiting for a response from the driver.  The driver simulates the signals for the device, then signals the sequencer that the window can be closed.  The idea is that the sequencer works at a high level, and the driver at a lower level. <br><br>  Signals are connected via the interface bus to the device.  The interface is described in the files vip_if.h, vip_if.svh. <br><br>  Next, you need to check whether the output signals with the expected.  There are two solutions: <br><br><ul><li>  Writing a model for the device </li><li>  Checking signals through a UVM agent </li></ul><br>  In the example, the second option is considered.  To test the device at a functional level, you must verify the output with the expected.  The requirement for the device was the correctness of the specified signal duty cycle and signal period.  To monitor the output signals, a new class was written - Monitor (file monitor.h, monitor.svh).  Usually, in a test environment, the monitor translates signals into transactions (to a higher level) and is sent to the comparison class - the scoreboard. <br><br>  In this example, the signals are immediately checked.  In case of a difference between the expected value and the measured one, the test stops. </div><p>Source: <a href="https://habr.com/ru/post/459338/">https://habr.com/ru/post/459338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459328/index.html">Best in class in terms of price-quality ratio - Mpow A5 (059)</a></li>
<li><a href="../45933/index.html">26.8 million unique internet users per week</a></li>
<li><a href="../459330/index.html">Bitrix for the programmer and manager: love and hate</a></li>
<li><a href="../459334/index.html">YouTrack 2019.2: system-wide banner, improvements to the page with a list of tasks, new search options and more</a></li>
<li><a href="../459336/index.html">Live and learn. Part 1. School and vocational guidance</a></li>
<li><a href="../459340/index.html">We organize ML-project with the help of Ocean</a></li>
<li><a href="../459342/index.html">Remote cache for iOS, feature toggles, dark themes and developer career - Avito iOS Meetup # 7 report</a></li>
<li><a href="../459344/index.html">DevOps metrics - where to get data for calculations</a></li>
<li><a href="../459346/index.html">Around the World with an e-book: a review of ONYX BOOX James Cook 2</a></li>
<li><a href="../459348/index.html">Another authorization bypass in public Wi-Fi networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>