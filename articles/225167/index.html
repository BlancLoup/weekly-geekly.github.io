<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>In-Memory OLTP in SQL Server 2014. Part I</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The In-Memory OLTP functionality (Hekaton project) is designed to speed up the processing of typical OLTP operations in SQL Server. As you know, the l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>In-Memory OLTP in SQL Server 2014. Part I</h1><div class="post__text post__text-html js-mediator-article">  The In-Memory OLTP functionality (Hekaton project) is designed to speed up the processing of typical OLTP operations in SQL Server.  As you know, the load on the database server, whether it is Microsoft SQL Server or Oracle / MySQL or SAP / Sybase or IBM DB2, etc., can be divided into two classes: data collection and analysis of what was collected, because what was it otherwise to collect?  The first class of tasks is called OLTP (On-Line Transactional Processing).  It is characterized by short update transactions affecting a relatively small number of tables in the database.  Examples of such applications are a banking day, a telecom billing, etc.  The second class of tasks is called OLAP (On-Line Analytical Processing) and is characterized by massive long-term reading, covering a significant number of tables and collecting, as a rule, maximum records, replete with binding, sorting, grouping predicates, aggregate functions, etc.  As a rule, data structures for different classes of tasks are divided so that they do not interfere with each other, and if the first database structure is built taking into account numerous Codd rules, the second one, on the contrary, is denormalized and is executed according to the star (snowflake) scheme. <br>  The DBMS memory striving manifested itself at the beginning of the new millennium, when it turned out that, despite Moore‚Äôs law, the clock frequency and speed of processors do not grow exponentially, but on the contrary, they go to a flat direct saturation despite ILP and other tricks.  At the same time, the prices for RAM, which was once indecently expensive, are catastrophically decreasing and, compared to the 90s, have fallen thousands of times.  Yeah, the database server makers told themselves.  In 2005, Oracle bought TimesTen in-memory, IBM in 2007, Solid, and in this case, Microsoft didn‚Äôt take anything from the outside, because they decided to train them in their team. <br><a name="habracut"></a><br>  Started with in-memory OLAP.  The first fruits of education were embodied in the VertiPaq ColumnStore engine with the release of SQL Server 2008 R2 in the form of PowerPivot for Excel and SharePoint.  As the name implies, the column index is designed in such a way that each page contains a piece of a column in a highly compressed form (~ 2 times better than with the compression that has appeared in SQL Server 2008 page) in order to tamp more data into memory.  Traditionally, OLAP benefits from column indexes, because, as we remember, this is a massive read.  As a rule, it is required to read along the rows (or range) all columns in which directories (dimension tables, star rays) are connected with foreign key columns in the fact table (hub) in order to build between them (or semi-join).  In SQL Server 2012, two useful things happened in this regard.  First, <a href="http://technet.microsoft.com/ru-ru/library/hh922900.aspx">xVelocity</a> (formerly VertiPaq) appeared in Analysis Services in the form of so-called tabular models, alternative to the traditional multidimensional, existing, give Gd memory, with SQL Server 7.0.  Secondly, the column index ceased to be a thing in itself, and it became possible to build it explicitly as needed ‚Äî the CREATE [NONCLUSTERED] COLUMNSTORE INDEX command appeared in T-SQL.  A <a href="http://msdn.microsoft.com/en-us/library/gg492153(v%3Dsql.120).aspx">cloud of restrictions</a> was immediately imposed on the column indexes, the most cruel of which was, of course, this one - it was not updated in a table that has a nonclustered columnstore index.  Consider disabling the columnstore index before the statement, and then rebuilding the columnstore index after UPDATE has completed.  In SQL Server 2014, this was tackled with an updated cluster column index.  Well, as a column ... To make the column index updateable, a delta store and delete bitmap were hung on it.  When a record is deleted, it does not physically disappear, and the flag in delete bitmap is cocked onto it.  When a record is inserted, it enters the delta store.  Both are ordinary B-Tree (rowstore) with all its pluses and minuses.  There is a Tuple Mover background process that crawls across the delta store and converts the added entries into columnstore segments, but generally speaking, reading the column index means reading not only the columnstore, but also these two overhead friends, because you want to filter the deleted entries and union added.  However, two weeks after its release, SQL Sever 2014 showed record results in independent <a href="http://www.tpc.org/tpch/results/tpch_perf_results.asp%3Fresulttype%3Dnoncluster">TPC-H</a> analytical tests, taking the first places in the tournament tables by weight categories 1, 3 and 10 TB of database volume in a non-cluster (standalone) standings.  Thus, we will assume that with in-memory OLAP everything is fine and move on to in-memory OLTP. <br><br>  As already mentioned, Hekaton is not the code name of the next version of SQL Server, as were Denali, Katmai, Yukon, etc., but, actually, a project for developing an in-memory engine, i.e.  part of the product.  This component is the most striking innovation, not only in the current version, but also, perhaps, on the scale of the entire product line, starting with 16-bit Ashton-Tate / Microsoft SQL Server 1.0, which was released 25 years ago.  Hecaton is a Greek word and means one hundred or one-hundred = a hundred times that the kagbe hints that this is not steeper than the tenth one.  I would like to immediately warn against the misconception that Hecaton is some kind of extended version of dbcc pintable, because with a table attached to the memory, work happens as with a regular disk drive, including execution plans, ensuring transaction integrity with locks, etc.  Hecaton is a compact independent core integrated into the SQL Server executive mechanism, characterized by the lack of interpretable execution plans, locks as a means of ensuring logical data integrity and latches for physical integrity compared to the traditional database engine.  Let me remind you that the latches (I don‚Äôt know how ideologically they are correctly translated into Russian, probably, latches) are lightweight locks that are superimposed on data pages, index pages, some service structures directly at the moment of their reading or change in memory as opposed to from locks that can be valid for the entire transaction.  Therefore, without plunging into details, it can be considered that there is no dedlatchey.  There are nuances, but not so painful.  Another difference is that locks can be controlled (using hints, isolation level).  Latchi are under the authority of SQL Server.  I will not go into their internal structure in detail, those who wish can refer to BOL or to the page of <a href="http://sql.dev.ms/">Yevgeny Khabarov</a> .  I won‚Äôt bother with theory at all; let's move on to examples. <br><br>  Let's create a database and in it a file group for in-memory OLTP. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DATABASE</span></span> hekaton_test <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DATABASE</span></span> hekaton_test <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> FILEGROUP fg_hekaton_test CONTAINS MEMORY_OPTIMIZED_DATA <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DATABASE</span></span> hekaton_test <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FILE</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>=<span class="hljs-string"><span class="hljs-string">'fg_hekaton_test1'</span></span>, filename=<span class="hljs-string"><span class="hljs-string">'c:\Temp\fg_hekaton_test1'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> FILEGROUP fg_hekaton_test</code> </pre> <br>  Script 1 <br><br>  This is a file-like file group, data from memory will persist into it, and during recovery.  accordingly, read backwards.  Like clustered columnstore, it consists of data files in which the records inserted in the insert or update sections and delta files in which identifiers of deleted records are stored are sequentially written.  At first, changes, as usual, are reflected in memory, and at checkpoint, 256K blocks (in the case of data) and 4K (delta) are thrown onto the disk, which is noted in the transaction log.  The merging of data-delta pairs occurs automatically upon reaching a certain size and depending on the size of the RAM, and can also be done manually by the sys.sp_xtp_merge_checkpoint_files procedure.  Read more about this process <a href="http://blogs.technet.com/b/dataplatforminsider/archive/2014/01/22/merge-operation-in-memory-optimized-tables.aspx">here</a> . <br>  Thus, the placement of tables in memory does not mean that if the server is cut off, all that is acquired by overwork, all will be lost.  In-Memory OLTP is a fully transactional technology and supports fault tolerance, including AlwaysOn. <br><br>  In the newly created database we will create a table optimized for working in memory. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> hekaton_test <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.ShoppingCart ( ShoppingCartId <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> nonclustered <span class="hljs-keyword"><span class="hljs-keyword">hash</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (bucket_count=<span class="hljs-number"><span class="hljs-number">2000000</span></span>), UserId <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ix_UserId nonclustered <span class="hljs-keyword"><span class="hljs-keyword">hash</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (bucket_count=<span class="hljs-number"><span class="hljs-number">1000000</span></span>), CreatedDate datetime2 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, TotalPrice money ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (MEMORY_OPTIMIZED=<span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>)</code> </pre><br>  Script 2 <br><br>  The last option just means that the table will be placed in memory.  Each MEMORY_OPTIMIZED table must have at least one index. The total number must not exceed 8. The fields in the index must not be nullable.  For the fields n (var) char included in the indices, the BIN2 collation should be used.  Clustered indices, by definition, no.  In its structure of classic b-tree too.  For tables in memory, indexes are HASH (better suited for point searches) and RANGE (as the name implies, better suited for scans by range). <br>  The main component of the <a href="http://dataidol.com/tonyrogerson/2014/01/16/sql-server-hekaton-in-memory-tables-understanding-the-row-chains-of-hash-indexes/">hash index</a> is the so-called mapping table, in one column which stores the results of applying the hash function to the concatenation of the fields that make up the index key, and in the other - pointers to records.  Since the hash function can produce the same results (collisions arise) for completely different values ‚Äã‚Äãof the argument (for close ones, they must differ), in reality, these will be pointers to the memory areas where the overflow chains lie.  Each such chain is a bidirectional list.  The main parameter when creating a hash index is bucket_count.  This is the number of slots in the match table.  The smaller they are, the higher the probability of a collision, the longer the chains of overflows grow from each hash.  Accordingly, it is obvious that it should not be less than the number of unique values ‚Äã‚Äãin the index key.  In fact, it is estimated as the number of unique values, rounded up to the next degree 2, and explains in detail why. <br>  The second type of index, available in-memory, is called range (range) and is very similar to the classic cluster.  Its nodes form an ordered structure, effective for scanning across ranges.  Instead of B-Tree, its modification <a href="http://dataidol.com/tonyrogerson/2014/01/21/sql-server-hekaton-xtp-in-memory-tables-range-indexes-and-row-chains/">Bw-Tree is used</a> , the most striking difference of which, perhaps, is that it does not store pointers to duplicate values.  If the table has a million identical values, the classic tree will stupidly keep a million pointers (to data) in the leaves.  In this case, Bw costs one, which allows dramatic (English-language authors love this word very much) to save space when storing this economy in memory.  The only thing is, in this case, overflow chains arise - we do not store pointers to all records, how to get to the next one with the same key value?  There is a feeling that there is no saving, just bytes on ptr were transferred from the leaves to the bouquets.  But no, read why this is not so, <a href="http://research.microsoft.com/apps/pubs/default.aspx%3Fid%3D178758">here</a> , and we will move on and create another table. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.UserSession ( SessionId <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> nonclustered <span class="hljs-keyword"><span class="hljs-keyword">hash</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (bucket_count=<span class="hljs-number"><span class="hljs-number">400000</span></span>), UserId <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, CreatedDate datetime2 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, ShoppingCartId <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ix_UserId nonclustered <span class="hljs-keyword"><span class="hljs-keyword">hash</span></span> (UserId) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (bucket_count=<span class="hljs-number"><span class="hljs-number">400000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (MEMORY_OPTIMIZED=<span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>, &lt;b&gt;DURABILITY=SCHEMA_ONLY&lt;/b&gt;)</code> </pre><br>  Script 3 <br><br>  Note the last option highlighted in bold color.  It means that the data of this table will not be saved between server restarts (the structure itself will remain).  Above, I said that there is a misconception about Hekaton that everything that is in memory is lost when restarted.  So for these tables, this is true, but you create them quite consciously to reduce overhead, in particular, for journaling where it is not needed.  It is a kind of temporary table.  By the way, table variables in Hecaton are also supported.  They are declared through the preliminary creation of the table type CREATE TYPE ... AS TABLE ... Unlike regular table variables, they are stored, of course, not in disk tempdb, but refer to the database where they were declared. <br><br>  Tables in memory do not support automatic statistics update, in particular, ALTER DATABASE ... SET AUTO_UPDATE_STATISTICS ON.  Also does not work <br>  exec sp_autostats @tblname = 'ShoppingCart' <br>  Index Name AUTOSTATS Last Updated <br>  [ix_UserId] OFF NULL <br>  [PK__Shopping__7A789AE57302F83B] OFF NULL <br>  exec sp_autostats @tblname = 'ShoppingCart', @flagc = 'ON' <br>  - For example, renaming, are not supported with memory optimized tables. <br>  However, statistics can be updated manually: UPDATE STATISTICS dbo. ShoppingCart WITH FULLSCAN, NORECOMPUTE. <br>  In general, tables in memory have a cloud of limitations.  Most tabular hints are not supported: No TABLOCK, XLOCK, PAGLOCK, ... NOLOCK does not swear, but does not react as if it were not.  Dynamic and keyset cursors are silently converted to static.  TRUNCATE TABLE and MERGE statements are not supported (when the table in memory serves as an assignment).  There are restrictions on the types of fields used.  You can read about them in detail <a href="http://msdn.microsoft.com/en-us/library/dn246937(v%3Dsql.120).aspx">here</a> , we, in order not to be upset, let's see what we have done. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, description <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.dm_os_loaded_modules <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> description = <span class="hljs-string"><span class="hljs-string">'XTP Native DLL'</span></span></code> </pre><br>  Script 4 <br><br>  In the installation directory of SQL Server C: \ Program Files \ Microsoft SQL Server \ ... \ DATA \ xtp \ 11 \, two dll appeared, which are called xtp_t_11_ &lt;9 digits&gt; .dll.  These are our tables ShoppingCart and UserSession. <br>  The built-in compiler converts T-SQL definitions of tables and stored procedures into C code (can be viewed in the same directory), from which the machine is obtained.  The corresponding dynamic libraries are loaded into memory and linked into the SQL Server process.  When restarting SQL Server, libraries are compiled and reloaded based on catalog information from metadata. <br><br>  In the next part, we plan to consider the native compilation of stored procedures, isolation levels of transactions in Hekaton, locks, logging, and overall performance compared to traditional disk objects. </div><p>Source: <a href="https://habr.com/ru/post/225167/">https://habr.com/ru/post/225167/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../225155/index.html">WWDC 2014. First impressions of the witness</a></li>
<li><a href="../225157/index.html">Review of the North Korean distribution Red Star 3.0. Server version</a></li>
<li><a href="../225161/index.html">Samsung Z - the world's first smartphone on Tizen will be released in Russia</a></li>
<li><a href="../225163/index.html">A preview of the new version of Visual Studio is available, with Roslyn and C # 6</a></li>
<li><a href="../225165/index.html">The development of STIX fonts version 2.0.0 has been announced, aimed at improving their textual component.</a></li>
<li><a href="../225169/index.html">Introducing Sencha Ext JS 5</a></li>
<li><a href="../225173/index.html">Designing the physical infrastructure of the data center - from science to art</a></li>
<li><a href="../225175/index.html">New invariant number. The study of the natural number series (NPS)</a></li>
<li><a href="../225177/index.html">Rule number N + 0: do not be afraid to dig deeper</a></li>
<li><a href="../225179/index.html">Speech recognition in Asterisk using the Yandex SpeechKit HTTP API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>