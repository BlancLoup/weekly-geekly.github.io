<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Protecting the Scrypt Encryption Utility with the Intel¬Æ Tamper Protection Toolkit</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In our article, we will show how the Intel Tamper Protection Toolkit helps protect critical sections of code and valuable data in the Scrypt encryptio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Protecting the Scrypt Encryption Utility with the Intel¬Æ Tamper Protection Toolkit</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/1f9/a19/34c/1f9a1934c18b42c6a609793f5f2e9d26.jpg">  In our article, we will show how the <i>Intel Tamper Protection Toolkit</i> helps protect critical sections of code and valuable data in the <a href="">Scrypt</a> encryption <a href="">utility</a> against static / dynamic reverse engineering and changes.  <i>Scrypt</i> is the newest and safest key generation function with a password, widely used in practice.  However, there is a threat of falsifying the parameters of the <i>scrypt</i> function, which will lead to the appearance of user password vulnerabilities.  The toolkit allows you to reduce these threats.  We define a threat model for the application in question, explain how to refactor it for further protection, taking into account the features of applying the <i>Tamper Protection</i> tool to the application. <br>  The main purpose of this article is to demonstrate the capabilities of <i>Intel Tamper Protection Toolkit</i> to protect against attacks on critical sections of code and valuable data found in real-world applications.  The toolkit allows you to counteract static and dynamic reverse engineering by obfuscation and to prevent changes to the protected application by monitoring integrity during runtime. <br><a name="habracut"></a><br>  Here we consider only one tooling component, called <i>iprot</i> , which is used for obfuscation, and apply it to the <i>Scrypt</i> version <i>1.1.6</i> encryption utility.  The utility is a simple <i>scrypt</i> key generation function based on the entered password.  The choice in favor of it was made for several reasons.  First, the code of its functions contains features frequently used by applications: read and write operations to files, memory allocation, cryptographic functions, and system calls.  Secondly, it includes a specific mathematical apparatus.  Thirdly, the utility is quite compact, but it allows you to show a wide range of problems that developers may face in practice in the process of protecting their own applications.  Finally, <i>scrypt</i> is a modern and secure key generation function that is actively used in practice, for example, new disk encryption based on <i>scrypt</i> is built into Android 4.4. <br><br><h2>  <font color="#0071c5">Code obfuscation</font> </h2><br>  Consider the example of the source code for the <i>sensitive</i> function, which is presented in the Listing below, and compile a dynamic library for it. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODIFIER (0xF00D) int __declspec(dllexport) sensitive(const int value) { int result = 0; int i; for (i = 0; i &lt; value; i++) { result += MODIFIER; } return result; }</span></span></code> </pre> <br>  <i>Sensitive source code</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We will do reverse engineering of the resulting library using IDA Pro.  The figure shows the order of execution of the code with logic and data for calculation.  Thus, a hacker can easily see the value of <i>MODIFIER</i> in the code and change it. <br><br><img src="https://habrastorage.org/files/c4e/c8e/48b/c4ec8e48b7e24ba295ae92d56635f043.png"><br>  <i>Execution order in disassembled code</i> <br><br>  Different code obfuscation techniques can help to hide implementation details, complicate reverse engineering and prevent code changes.  Code obfuscation is the process of transforming code into one for which it is difficult to do reverse engineering and understand the logic and data of a program, while the code will have the same functional purpose.  Obfuscation is used to avoid the theft of secret data in the code, their changes and to protect the intellectual property of the developer. <br><br><h2>  <font color="#0071c5">Intel Tamper Protection Toolkit</font> </h2><br>  <i>Intel Tamper Protection Toolkit</i> is a product that is used to obfuscate code and check the integrity of the application at run time for executable files under Microsoft Windows * and Android *.  Using the <i>Tamper Protection Toolkit</i> , you can protect valuable code and data in the application from static and dynamic reverse engineering and changes.  Executable files protected by the tool do not require special boot loaders or additional software and can be run on any Intel processor. <br>  The <i>Intel Tamper Protection Toolkit Beta Toolkit</i> can be downloaded <a href="https://software.intel.com/en-us/tamper-protection">here</a> . <br>  In this article, we will use the following <i>Intel Tamper Protection Toolkit</i> components in order to obfuscate critical sections of code and protect the encryption utility from possible attacks: <br><ul><li>  <i>iprot</i> - obfuscator, creating a self-modifying and self-encrypting code; </li><li>  <i>The crypto library</i> is a library with a set of basic cryptographic operations: secure hashing algorithms, message authentication (authentication) codes, and symmetric ciphers. </li></ul><br>  Obfuscator receives as input a dynamic library (.dll) and a list of export functions.  The output is a dynamic library with obfuscated export functions.  Starting from their addresses, the code supplied to the input of the dynamic library is parsed and converted into a special internal representation.  Branches, transitions and challenges, if attainable, are also understood and transformed.  In order for the code to be obfuscated, several limitations should be considered.  In the code there can be no low-level work with memory, external unreachable function calls, indirect transitions and global variables. <br>  In this article, we describe what pitfalls were encountered when making changes to the code in order to obfuscate it, and how to avoid the difficulties encountered. <br>  Obfuscate the dynamic library discussed in the previous section using <i>iprot</i> : <br><pre> <code class="bash hljs">iprot sensitive.dll sensitive -o sensitive_obf.dll</code> </pre><br>  Let's try to reverse engineer the obfuscated code using IDA Pro. <br><br><pre> <code class="cmake hljs">sensitive PROC NEAR jmp ?_001 ?_001: push ebp push eax call ?_002 ?_002 LABEL NEAR pop eax lea eax, [eax+<span class="hljs-number"><span class="hljs-number">0</span></span>FECH] mov dword ptr [eax], <span class="hljs-number"><span class="hljs-number">608469404</span></span> mov dword ptr [eax+<span class="hljs-number"><span class="hljs-number">4</span></span>H], <span class="hljs-number"><span class="hljs-number">2308</span></span> mov dword ptr [eax+<span class="hljs-number"><span class="hljs-number">8</span></span>H], -<span class="hljs-number"><span class="hljs-number">443981824</span></span> mov dword ptr [eax+<span class="hljs-number"><span class="hljs-number">0</span></span>CH], <span class="hljs-number"><span class="hljs-number">1633409</span></span> mov dword ptr [eax+<span class="hljs-number"><span class="hljs-number">10</span></span>H], -<span class="hljs-number"><span class="hljs-number">477560832</span></span> mov dword ptr [eax+<span class="hljs-number"><span class="hljs-number">14</span></span>H], <span class="hljs-number"><span class="hljs-number">15484359</span></span> mov dword ptr [eax+<span class="hljs-number"><span class="hljs-number">18</span></span>H], -<span class="hljs-number"><span class="hljs-number">1929379840</span></span> mov dword ptr [eax+<span class="hljs-number"><span class="hljs-number">1</span></span>CH], -<span class="hljs-number"><span class="hljs-number">1048448</span></span> &lt;‚Ä¶.&gt;</code> </pre><br>  <i>Disassembled Obfuscated Code</i> <br><br>  We can easily notice how the obfuscated code differs from the original one.  IDA Pro was unable to display a scheme for the execution order of the obfuscated code, and the <i>MODIFIER</i> value disappeared.  Also, the obfuscated code is protected from static and dynamic changes. <br><br><h2>  <font color="#0071c5">Key generation function by password</font> </h2><br>  Password generation key functions ( <i>PBKDF</i> ) are used to convert a password entered by a user into a key (binary data set), which can be used in cryptographic algorithms.  PBKDF is a very important component of application protection, because a password entered by a user is not safe to use in a cryptographic algorithm due to its insufficient entropy.  These functions are widely used to protect applications, for example, cryptographic keys are obtained from passwords in PGP systems for encrypting / decrypting data on a disk.  Also, operating systems use these functions to verify a user password (authentication). <br><br>  In general, the mathematical expression for PBKDF is as follows: <br>  <i>y</i> = <i>F</i> ( <i>P</i> , <i>S</i> , <i>d</i> , <i>t <sub>1</sub></i> , ..., <i>t <sub>n</sub></i> ) <br>  where <i>y</i> is the key generated by the function, <i>P</i> is the password, <i>S</i> is the salt, <i>d</i> is the length of the key being generated and <i>t <sub>1</sub></i> , ..., <i>t <sub>n</sub></i> are the parameters determined by the amount of hardware resources, such as the processor clock frequency, the amount of RAM required to calculate the function .  Salt <i>S</i> is used to create different keys for a given password.  The <i>t <sub>1</sub></i> , ..., <i>t <sub>n</sub></i> parameters play the role of determining the hardware resources consumed to compute the function, and can be configured to complicate its computation and add additional protection against <i>brute-force</i> attack using parallelization at the hardware level ordinary GPU. <br><br><img src="https://habrastorage.org/files/505/bab/d0a/505babd0a6fb4309956b6aa2fdebfbaa.png"><br>  <i>PBKDF Usage Scheme</i> <br><br>  There are two ways to recover a user password: <br><ol><li>  The attacker recovers the password using a key that was generated as a result of the leak; </li><li>  The attacker recovers the password using encrypted or signed key data. </li></ol><br>  For the first case, the <i>Intel Tamper Protection Toolkit</i> will help prevent key leakage by hiding the code that is executed to generate it and then use the generated key. <br>  The second case of <i>Intel Tamper Protection Toolkit</i> cannot be prevented, but it will help to verify that the attacker did not change the parameters used to generate the key to unsafe. <br>  Here are examples of key generation functions with a password used in practice: <br><ul><li>  <i>Password-based Key Derivation Function</i> (PBKDF2).  This is a function of the form <i>y</i> = <i>F</i> ( <i>P</i> , <i>S</i> , <i>c</i> ), where <i>c</i> is the number of iterations for regulating the processor time required to calculate the function <i>F</i> for any <i>P</i> , <i>S.</i>  PBKDF2 can be implemented for systems with a very small amount of RAM, which makes a brute force attack using the GPU very effective.  Despite this, many products continue to use PBKDF2. </li><li>  <i>bcrypt</i> .  This feature is more resistant to this type of attack using the GPU, as it uses a larger fixed amount of RAM. </li></ul><br>  The modern and most secure feature developed by Colin Percival is <i>scrypt</i> .  It has the following mathematical formula: <br><br>  <i>y</i> = <i>F</i> ( <i>P</i> , <i>S</i> , <i>d</i> , <i>N</i> , <i>r</i> , <i>p</i> ), <br><br>  where <i>y</i> is the key generated by the function, <i>d</i> is the length of the key generated, <i>P</i> is the user password, <i>S</i> is the salt, <i>p</i> , <i>r</i> and <i>N</i> are the parameters for setting the processor time and the amount of RAM required to generate the key.  The values ‚Äã‚Äãof the parameters <i>N</i> , <i>r</i> , <i>p</i> , <i>d</i> can be open and usually they are stored with the key or with encrypted data. <br><br>  Depending on the values ‚Äã‚Äãof the <i>N</i> , <i>r</i> , <i>p</i> parameters, the generation of the same key may require different amounts of processor time and memory size.  For example, if parameters request ~ 100 ms and ~ 20 MB, then a brute force attack on a regular GPU against the <i>scrypt</i> function will not be as effective as against PBKDF2, which requires a small amount of RAM and allows parallel calculations for different passwords on the GPU. <br><br><h2>  <font color="#0071c5">Scrypt encryption utility</font> </h2><br>  The encryption utility <i>Scrypt</i> uses the AES algorithm in CTR mode and the key generated by the <i>scrypt</i> function using a user password for working with input files.  It contains the required and optional parameters to run. <br>  Required are: <br><ul><li>  <i>the password</i> that the <i>scrypt</i> function uses to generate the key; </li><li>  <i>mode</i> : encryption or decryption; </li><li>  <i>input file name</i> . </li></ul><br>  Extra options: <br><ul><li>  <i>-t</i> time in seconds required to generate a key; </li><li>  <i>-m</i> proportion of RAM used to generate the key; </li><li>  <i>-M</i> number of bytes of RAM used to generate the key; </li><li>  <i>name of the output file</i> . </li></ul><br>  For example, running the utility with the command <br><br>  <i>scrypt enc infile -t 0.1 -M 20971520</i> <br><br>  will require 100ms of processor time and 20MB of RAM to generate a key.  Such parameter values ‚Äã‚Äãcomplicate the parallelization of brute force when attacking with brute force. <br>  The figure below represents the work of the <i>Scrypt</i> utility in the case when the user entered the name of the input file for encryption, the password and the parameters defining the required hardware resources. <br>  We will describe the steps performed by the utility when encrypting: <br><ol><li>  <b><i>Scrypt</i> Collect and convert parameters.</b>  The program selects the parameters of processor time and the amount of RAM required to generate the key and converts them into parameters that are perceived by the <i>scrypt</i> function. </li><li>  <b><i>Scrypt</i> Key generation.</b>  The <i>scrypt</i> function generates a 64-byte key using the user password and the <i>N</i> , <i>r</i> , <i>p</i> parameters calculated in the previous step.  The lower 32 bytes of the <i>dk <sub>1</sub></i> key are used to calculate the authentication code for the <i>N</i> , <i>r</i> , <i>p</i> , <i>salt,</i> and encrypted data parameters.  Thus, during the decryption process, you can check the correctness of the entered password and the integrity of the encrypted data.  The upper 32 bytes of the <i>dk <sub>2</sub></i> key are used to encrypt the input file with the AES algorithm in CTR mode. </li><li>  <b>Calculate authentication code for <i>scrypt</i> parameters.</b>  In this step, an authentication (authentication) code is calculated for the <i>N</i> , <i>r</i> , <i>p,</i> and <i>salt</i> parameters used to generate the key. </li><li>  <b><i>OpenSSL</i> encryption with 32-byte AES blocks in CTR mode.</b>  Encrypt the input message with <i>dk <sub>2</sub></i> using the 32-byte AES cipher in CTR mode. </li><li>  <b>Calculate the authentication code for encrypted data.</b>  Finally, the authentication code is computed to encrypt data, using <i>dk <sub>1</sub></i> to ensure integrity.  The output file contains encrypted data, <i>N</i> , <i>r</i> , <i>p</i> parameters, the <i>salt</i> used in encryption, and authentication codes that ensure the integrity of the encrypted data and parameters. </li></ol><br><br><img src="https://habrastorage.org/files/574/d6e/92d/574d6e92dc5d40d69e9bd1bc0b014376.png"><br>  <i>Scrypt encryption scheme</i> <br><br><h2>  <font color="#0071c5">Possible threats</font> </h2><br>  Analyzing the utility operation in encryption mode, we will determine the threat model.  The values ‚Äã‚Äãof the parameters <i>N</i> , <i>r</i> , <i>p</i> , <i>salts</i> and key generated, obtained in the intermediate steps, are critical data and require protection against changes in real time.  For example, in debug mode, an attacker can set other values ‚Äã‚Äãof the <i>N</i> , <i>r</i> , <i>p</i> parameters in order to weaken the resistance of a key to attack by brute force. <br><br>  The figure below illustrates the decryption process when a user enters an input file name with encrypted text, <i>N</i> , <i>r</i> , <i>p</i> , <i>salt</i> , <i>authentication codes,</i> and a <i>password</i> . <br>  We give a description of the steps performed by the utility when decrypting: <br><ol><li>  <b><i>Scrypt</i> Setting Parameters.</b>  The input file for decryption contains encrypted data, authentication codes <i>hmac <sub>1</sub></i> , <i>hmac <sub>2</sub></i> and the parameters <i>N</i> , <i>r</i> , <i>p</i> , <i>salt</i> , used for encryption.  At this step, these parameters are read from the input file and transferred to the key generation function. </li><li>  <b><i>Scrypt</i> Key generation.</b>  The <i>scrypt</i> function generates a key for the password and the <i>N</i> , <i>r</i> , <i>p</i> , and <i>salt</i> parameters obtained in the previous step.  The lower 32 bytes and the upper 32 bytes of this key are indicated in figure <i>dk <sub>1</sub></i> and <i>dk <sub>2,</sub></i> respectively. </li><li>  <b><i>Scrypt</i> Checking the integrity of parameters and password.</b>  The integrity of the <i>N</i> , <i>r</i> , <i>p</i> , <i>salt,</i> and password correctness is verified using an authentication code.  To verify the password is correct, the utility calculates the authentication code for the parameters <i>N</i> , <i>r</i> , <i>p</i> , <i>salt</i> , using <i>dk <sub>1</sub></i> , and compares the obtained value with the value <i>hmac <sub>1</sub></i> .  If they match, then the password is correct. </li><li>  <b>Check the integrity of encrypted data.</b>  To verify that the encrypted data has not been changed, an authentication code for the data is calculated using <i>dk <sub>1</sub></i> and compared with the value of <i>hmac <sub>2</sub></i> .  If they match, then the data has not been corrupted and can be decrypted in the next step. </li><li>  <b><i>OpenSSL</i> 32-byte block decryption algorithm AES in CTR mode.</b>  Finally, the data is decoded using the 32-byte AES block algorithm in CTR mode using <i>dk <sub>2</sub></i> .  The output file contains the decrypted data. </li></ol><br><br><img src="https://habrastorage.org/files/cf3/683/eba/cf3683eba8a84a90afa82f94773a24ae.png"><br>  <i>Scrypt decryption scheme</i> <br><br><h2>  <font color="#0071c5">Porting utility under Windows</font> </h2><br>  The aim of the work is to protect the encryption utility <i>Scrypt</i> under Windows OS using the <i>Tamper Protection toolkit</i> .  The original version of the utility is written under Linux OS, so the first task is to port it under Windows OS. <br>  The platform dependent code will be placed between the following conditional directives: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(WIN_TP) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    Windows #else //    Linux #endif // defined(WIN_TP)</span></span></span></span></code> </pre><br><br>  The preprocessor directive <i>WIN_TP</i> separates code intended for Windows.  <i>WIN_TP</i> must be defined for building under Windows, otherwise code for Linux will be selected for building. <br>  We use the Microsoft * Visual Studio 2013 development environment for building and debugging utilities.  There are differences between some objects of Windows OS and Linux OS, such as process, stream, memory and file management, service infrastructures, user interfaces, and so on.  We had to take into account all these differences when porting the utility.  We describe them below. <br><ul><li>  The utility uses the <i>getopt ()</i> function to parse command line arguments.  The list of available program arguments is given above.  The <i>getopt ()</i> function is in the header file <i>unitstd.h</i> according to the POSIX standard set.  We use the <i>get_opt ()</i> implementation from the <i>getopt_port</i> open project.  To do this, add the <i>getopt.h</i> and <i>getopt.c files</i> from the <i>getopt_port</i> project to our project. </li><li>  The remaining <i>gettimeofday ()</i> function declared in the POSIX API is used by the utility to measure <i>salsa opps</i> and count the number of operations per second <i>salsa20 / 8</i> performed on the user platform.  The <i>salsa opps metric is</i> used by the utility to select safer values ‚Äã‚Äãfor the <i>N</i> , <i>r</i> , and <i>p</i> parameters, so the <i>scrypt</i> algorithm performs the <i>salsa20 / 8</i> operations the minimum number of times it can avoid brute force attacks.  We have added the implementation of the <i>gettimeofday ()</i> function to the <i>scryptenc_cpuperf.c</i> file. </li><li>  Before launching the configuration algorithm, the utility requests the operating system the amount of available RAM that will be captured by a call to the <i>getrlimit</i> function <i>(RLIMIT_DATA, ...)</i> from the POSIX set to generate the key.  In Windows, the hard and non-hard limits for the maximum size of the process data segment (initialized and uninitialized data and heap) are set to 4GB.  All this is shown in the code below. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* ... RLIMIT_DATA... */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(WIN_TP) rl.rlim_cur = 0xFFFFFFFF; rl.rlim_max = 0xFFFFFFFF; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((uint64_t)rl.rlim_cur &lt; memrlimit) { memrlimit = rl.rlim_cur; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (getrlimit(RLIMIT_DATA, &amp;rl)) return (1); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((rl.rlim_cur != RLIM_INFINITY) &amp;&amp; ((uint64_t)rl.rlim_cur &lt; memrlimit)) memrlimit = rl.rlim_cur; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// defined(WIN_TP)</span></span></span></span></code> </pre></li><li>  Additionally, a directive has been added to the MSVS compiler to define inline functions in the <i>sysendian.h</i> file. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(WIN_TP) static __inline uint32_t #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> static inline uint32_t #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// WIN_TP be32dec(const void *pp);</span></span></span></span></code> </pre></li><li>  We ported the <i>tarsnap_readpass (...)</i> function to perform hidden password entry in the terminal.  The function disables the display of characters in the terminal window and masks the password with whitespace.  The password is stored in a dedicated buffer and sent to the following <i>Scrypt</i> configuration and key generation functions. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     ,     */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(WIN_TP) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((usingtty = _isatty(_fileno(readfrom))) != 0) { GetConsoleMode(hStdin, &amp;mode); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (usingtty) mode &amp;= ~ENABLE_ECHO_INPUT; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> mode |= ENABLE_ECHO_INPUT; SetConsoleMode(hStdin, mode); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((usingtty = isatty(fileno(readfrom))) != 0) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (tcgetattr(fileno(readfrom), &amp;term_old)) { warn(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Cannot read terminal settings"</span></span></span><span class="hljs-meta">); goto err1; } memcpy(&amp;term, &amp;term_old, sizeof(struct termios)); term.c_lflag = (term.c_lflag &amp; ~ECHO) | ECHONL; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (tcsetattr(fileno(readfrom), TCSANOW, &amp;term)) { warn(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Cannot set terminal settings"</span></span></span><span class="hljs-meta">); goto err1; } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// defined(WIN_TP)</span></span></span></span></code> </pre></li><li>  The original <i>getsalt ()</i> function to obtain a pseudo-random sequence reads the special file <i>/ dev / urandom</i> , which is part of the Unix operating system.  On Windows, we use the <i>rdrand ()</i> instruction from a hardware random number generator, available on <i>Intel Xeon</i> and <i>Core</i> chips, starting with <i>Ivy Bridge</i> .  The standard C function for generating a pseudo-random sequence is not intentionally used, since in this case the <i>getsalt ()</i> function cannot be obfuscated using the <i>Tamper Protection</i> obfuscation tool.  The <i>getsalt ()</i> function must be protected by the obfuscator from static and dynamic modification and reverse engineering, since the <i>salt</i> produced by this function is categorized by us in section 3 as a protected object.  Below are the changes made to the code to get the <i>salt</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(WIN_TP) uint8_t i = 0; for (i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; buflen; i++, buf++) { _rdrand32_step(buf); } #else /*  /dev/urandom. */ if ((fd = open("/dev/urandom", O_RDONLY)) == -1) goto err0; /*  ,    buffer. */ while (buflen &gt; 0) { if ((lenread = read(fd, buf, buflen)) == -1) goto err1; /*     ,    buffer. */ if (lenread == 0) goto err1; /*    */ buf += lenread; buflen -= lenread; } /*     */ while (close(fd) == -1) { if (errno != EINTR) goto err0; } #endif // defined(WIN_TP)</span></span></span></span></code> </pre></li></ul><br><br><h2>  <font color="#0071c5">Utility Protection with Intel Tamper Protection Toolkit</font> </h2><br>  Now we will refactor the utility code to protect all important data defined in our threat model.  The protection of such data is achieved by obfuscating the code with the help of the <i>iprot</i> tool, an obfuscating compiler from the set.  We will also adhere to the principle of reasonableness and obfuscate only those functions that create, process and use important data. <br>  We already know that obfuscator accepts a dynamic library as input and generates a binary file containing only the protected functions specified on the command line.  Therefore, we will put all the functions that work with important data inside the dynamic library for its further obfuscation.  The remaining functions, such as parsing command line arguments, reading the password, we will leave unprotected in the main executable file. <br><br>  The new structure of the protected utility is shown in the figure below.  The utility is divided into two parts: the main executable file and the dynamic library that will be obfuscated.  The main executable file is responsible for parsing command line arguments, reading the password and loading the input file into memory.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The dynamic library contains export functions such as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scryptenc_file</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scryptdec_file</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which work with important data ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">salt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The key data structure used in the dynamic library is called the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scrypt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> context </font><font style="vertical-align: inherit;">and contains the HMAC verification information for the parameters of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">salt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . HMAC contextual information is used to verify the integrity of monitored parameters by trusted functions, such as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt_ctx_enc_init</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt_ctx_dec_init</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scryptenc_file</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scryptdec_file</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which were added as a result of code refactoring. </font><font style="vertical-align: inherit;">These trusted functions will be resistant to change, as we intentionally obfuscate them with a tool. </font><font style="vertical-align: inherit;">Two new functions, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt_ctx_enc_init</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt_ctx_dec_init, were</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> needed to initialize the context of the scrypt function for each of the modes: encryption, decryption. </font></font><br><br><img src="https://habrastorage.org/files/d78/74b/f82/d7874bf8251d47eb8403618fe8d6fa67.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Architecture of the protected utility Scrypt</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let </font><i><font style="vertical-align: inherit;">us</font></i><font style="vertical-align: inherit;"> give a detailed description of the figure, how the utility works in each of the modes: encryption and decryption. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encryption:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The utility uses the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getopt ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">to parse command line arguments. </font><font style="vertical-align: inherit;">The list of arguments is given above.</font></font></li><li>    /       . </li><li>       <i>scrypt_ctx_enc_init</i>     <i>scrypt</i>       ( <i>N</i> , <i>r</i> , <i>p</i>  <i></i> ),     <i>maxmem</i> , <i>maxmemfrac</i>  <i>maxtime</i> ,            .       HMAC ( -)  ,        ,  <i>scrypt</i>  .     ,     ,   <i>scrypt</i>   . </li><li>        ,      . </li><li>    <i>scrypt_ctx_enc_init</i>      .     <i>scrypt</i> ,   HMAC.    ,                <i>scrypt</i>   HMAC.           ,        . ,       -,      ,    . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The export encryption function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scryptenc_file</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> using the entered password </font><font style="vertical-align: inherit;">is </font><i><font style="vertical-align: inherit;">invoked</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The function checks the integrity of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function context </font><font style="vertical-align: inherit;">with the parameters ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">salt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) used to generate the key. </font><font style="vertical-align: inherit;">If the verification is passed, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algorithm is called </font><font style="vertical-align: inherit;">to generate the key. </font><font style="vertical-align: inherit;">The generated key is then used for encryption. </font><font style="vertical-align: inherit;">The export form of the function has the same output as the original function of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utility </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This means that the output has the same hash value used to verify the integrity of the encrypted data and the correct password entered during the decryption process.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Decryption: </font></font><br><ol><li>    <i>getopt()</i>     . </li><li>    /       . </li><li>       <i>scrypt_ctx_dec_init</i>  ,                      .     ,     ,   <i>scrypt</i>   . </li><li>        ,      . </li><li>    <i>scrypt_ctx_dec_init</i>      .   ,   . </li><li>      <i>scryptdec_file</i> ,   .      <i>scrypt</i>   ( <i>N</i> , <i>r</i> , <i>p</i>  <i></i> ),    .   ,    <i>scrypt</i>   .      ,        . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the protected utility, we replace the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenSSL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementation of the AES algorithm in CTR mode and the function of calculating the authentication code with similar functions from the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intel Tamper Protection Toolkit crypto library</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Unlike </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenSSL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crypto library</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> satisfies all the restrictions on the source code and can be obfuscated using the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iprot</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tool </font><font style="vertical-align: inherit;">and used with obfuscable code without modification. The AES algorithm is called inside the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scryptenc_file</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scryptdec_file functions</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to encrypt / decrypt the input file and uses the key generated by the password. The function of calculating the authentication code is called in export functions ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt_ctx_enc_init</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt_ctx_dec_init</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scryptenc_file,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scryptdec_file</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) to check the integrity of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> context data </font><font style="vertical-align: inherit;">before using them. In the protected utility, all export functions of the dynamic library are obfuscated using </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iprot</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamper Protection</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> helps us achieve the goal of reducing threats. Our solution is a reworked utility with an obfuscated </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iprot</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dynamic library. The solution is resistant to the attacks defined earlier and this can be proved: context </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can only be updated via export functions, because they contain their own HMAC key to recalculate the HMAC value in context. Also, these functions and HMAC verification data are protected from modification and reverse engineering with the obfuscator. In addition, other important data, such as the </font><font style="vertical-align: inherit;">key </font><font style="vertical-align: inherit;">generated by the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">, is protected because the generation takes place inside the obfuscated export functions </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scryptenc_file</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scryptdec_file</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obfustsiruyuschy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compiler </font><i><font style="vertical-align: inherit;">iprot</font></i><font style="vertical-align: inherit;"> generates code that is self-modifying at run time and protected from making changes and debugging. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider how the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt_ctx_enc_init</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">protects the </font><i><font style="vertical-align: inherit;">scrypt</font></i><font style="vertical-align: inherit;"> context.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The main executable file using the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buf_p</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pointer </font><font style="vertical-align: inherit;">indicates which function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt_ctx_enc_init</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is </font><i><font style="vertical-align: inherit;">called</font></i><font style="vertical-align: inherit;"> . If the pointer is empty (the value is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), then the function is called the first time, otherwise the second time. During the first call, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parameters are initialized </font><font style="vertical-align: inherit;">, the HMAC is calculated, and the amount of memory required for calculating the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function is returned </font><font style="vertical-align: inherit;">. All of this is illustrated in the following code.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//  :       scrypt if (buf_p == NULL) { //   scrypt    // &lt;...&gt; //  HMAC itp_res = itpHMACSHA256Message((unsigned char *)ctx_p, sizeof(scrypt_ctx)-sizeof(ctx_p-&gt;hmac), hmac_key, sizeof(hmac_key), ctx_p-&gt;hmac, sizeof(ctx_p-&gt;hmac)); *buf_size_p = (r &lt;&lt; 7) * (p + (uint32_t)N) + (r &lt;&lt; 8) + 253; }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">During the second call, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buf_p</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> points to the allocated memory passed to the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrypt_ctx_enc_init</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">. Using the HMAC value, the function checks the integrity of the context to make sure that no data has been changed between the first and second function calls. After that, it initializes the address inside the context, using the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buf_p</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pointer </font><font style="vertical-align: inherit;">, and recalculates the HMAC value for the changed context. The code that is executed when the call is repeated is shown below.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  :    scrypt  if (buf_p != NULL) { //  HMAC itp_res = itpHMACSHA256Message( (unsigned char *)ctx_p, sizeof(scrypt_ctx)-sizeof(ctx_p-&gt;hmac), hmac_key, sizeof(hmac_key), hmac_value, sizeof(hmac_value)); if (memcmp(hmac_value, ctx_p-&gt;hmac, sizeof(hmac_value)) != 0) { return -1; } //      scrypt: // ctx_p-&gt;addrs.B0 = ‚Ä¶ //  HMAC itp_res = itpHMACSHA256Message( (unsigned char *)ctx_p, sizeof(scrypt_ctx)-sizeof(ctx_p-&gt;hmac), hmac_key, sizeof(hmac_key), ctx_p-&gt;hmac, sizeof(ctx_p-&gt;hmac)); }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We already know that the obfuscator imposes some restrictions on the source code, so it can be obfuscating: there should be no relocations and indirect transitions (Eng. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indirect jump</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) in the code. C language constructs containing global variables, system calls, and standard C functions can generate relocations and indirect transitions. The code above contains one standard C-function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which makes the code non-infustible using </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iprot</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . For this reason, we implement several of our own standard C-functions, such as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memmove</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used in the utility. We will also replace all global variables in the dynamic library with local ones and take care that the data is initialized on the stack. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, we are faced with the problem of obfuscation of a code containing </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">double</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> values </font><font style="vertical-align: inherit;">, which is not described in the documentation for the tool. For example, the code below shows that the pickparams function to limit the number of operations </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">salsa20 / 8</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uses the double variable type with a value of 32768. This value is not initialized on the stack and the compiler places it in the data segment of the executable file, which generates a relocation in the code.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> opslimit; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(WIN_TP) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// unsigned char d_32768[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x40}; unsigned char d_32768[sizeof(double)]; d_32768[0] = 0x00; d_32768[1] = 0x00; d_32768[2] = 0x00; d_32768[3] = 0x00; d_32768[4] = 0x00; d_32768[5] = 0x00; d_32768[6] = 0xE0; d_32768[7] = 0x40; double *var_32768_p = (double *) d_32768; #endif /*     salsa20/8. */ #if defined(WIN_TP) if (opslimit &lt; *var_32768_p) opslimit = *var_32768_p; #else if (opslimit &lt; 32768) opslimit = 32768; #endif</span></span></span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We eliminated this problem simply by initializing on the stack the desired sequence of bytes in hexadecimal form, representing the required </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">double</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> value </font><font style="vertical-align: inherit;">, and created a double pointer to the address of this sequence. </font><font style="vertical-align: inherit;">Perhaps some small utilities like </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">double2hex</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can help developers get a hexadecimal representation for double values ‚Äã‚Äãand can be used as an auxiliary tool. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To obfuscate a dynamic library using </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iprot</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we use the following command:</font></font><br><pre> <code class="bash hljs">iprot scrypt-dll.dll scryptenc_file scryptdec_file scrypt_ctx_enc_init scrypt_ctx_dec_init -c 512 -d 2600 -o scrypt_obf.dll</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The interface of the protected utility has not changed. </font><font style="vertical-align: inherit;">Compare non-obfuscated and obfuscated code. </font><font style="vertical-align: inherit;">The disassembly code below shows a significant difference between the two.</font></font><br><br><table><tbody><tr><td><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#   scrypt_ctx_enc_init PROC NEAR push ebp mov ebp, esp sub esp, 100 mov dword ptr [ebp-4H], 0 mov eax, 1 imul ecx, eax, 0 mov byte ptr [ebp+ecx-1CH], 1 mov edx, 1 shl edx, 0 mov byte ptr [ebp+edx-1CH], 2 mov eax, 1 shl eax, 1 mov byte ptr [ebp+eax-1CH], 3 mov ecx, 1 &lt;‚Ä¶&gt;</span></span></code> </pre><br></td><td><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#       scrypt_ctx_enc_init PROC NEAR mov ebp, esp sub esp, 100 mov dword ptr [ebp-4H], 0 mov eax, 1 imul ecx, eax, 0 mov byte ptr [ebp+ecx-1CH], 1 push eax pop eax lea eax, [eax+3FFFD3H] mov dword ptr [eax], 608469404 mov dword ptr [eax+4H], -124000508 mov dword ptr [eax+8H], -443981569 mov dword ptr [eax+0CH], 1633409 mov dword ptr [eax+10H], -477560832 &lt;‚Ä¶&gt;</span></span></code> </pre></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result of obfuscation, the utility performance dropped and the library size increased. </font><font style="vertical-align: inherit;">Obfuscator allows developers to choose between greater security and greater performance with the help of options: cell size and distance between mutation points. </font><font style="vertical-align: inherit;">In our case, the obfuscator uses 512-byte cells and 2600-byte mutation distances. </font><font style="vertical-align: inherit;">A cell is a subsequence of instructions from the original executable file. </font><font style="vertical-align: inherit;">The cells in the obfuscated code are encrypted until you need to execute the code stored in them. </font><font style="vertical-align: inherit;">After the decryption of the cell and the complete execution of the code contained in it, it is encrypted back. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code of the utility protected by the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intel Tamper Protection Toolkit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will soon appear on Github.</font></font><br><br><h2> <font color="#0071c5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We thank Raghudip Kannavar for the idea of ‚Äã‚Äãprotecting the encryption utility </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scrypt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and Andrei Somsikov for numerous useful discussions.</font></font><br><br><h2>  <font color="#0071c5">Links</font> </h2><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K. Grasman. </font></font><a href="https://github.com/kimgr/getopt_port/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getopt_port on github</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C. Percival. </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The scrypt encryption utility</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C. Percival. </font><font style="vertical-align: inherit;">‚ÄúStronger key derivation via sequential memory-hard functions‚Äù.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C. Percival, S. Josefsson (2012-09-17). </font><font style="vertical-align: inherit;">‚ÄúThe scrypt Password-Based Key Derivation Function‚Äù. </font><font style="vertical-align: inherit;">IETF.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N. Provos, D. Mazieres, J. Talan Sutton 2012 (1999). </font><font style="vertical-align: inherit;">‚ÄúA Future-Adaptable Password Scheme‚Äù. </font><font style="vertical-align: inherit;">Proceedings of 1999 USENIX Annual Technical Conference: 81‚Äì92.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W. Shawn. </font></font><a href="https://github.com/lattera/freebsd"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Freebsd sources on github</font></font></a> </li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Authors: Roman Kazantsev, Denis Katerinsky, Thaddeus Letnes </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{Roman.Kazanstev, Denis.Katerinskiy, Thaddeus.C.Letnes}@intel.com</font></font></b> </div><p>Source: <a href="https://habr.com/ru/post/274045/">https://habr.com/ru/post/274045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274033/index.html">A little bit about working with containers</a></li>
<li><a href="../274035/index.html">SVG highs and lows</a></li>
<li><a href="../274037/index.html">How to kill the smartphone Sony Xperia C2305 using a router D-Link DIR-300</a></li>
<li><a href="../274041/index.html">Interactive Client Map - Apache Spark Streaming and Yandex.Maps</a></li>
<li><a href="../274043/index.html">More than go</a></li>
<li><a href="../274049/index.html">Happy New Year 2016</a></li>
<li><a href="../274051/index.html">My Location Companion application for ViaLatM service</a></li>
<li><a href="../274053/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 28. "Carder Court"</a></li>
<li><a href="../274055/index.html">Work on the design of space reptiloids: wandering through the maze of possibilities</a></li>
<li><a href="../274057/index.html">Go in 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>