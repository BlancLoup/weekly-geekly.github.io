<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A few words about caching data when reading and smartpoint</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I don‚Äôt think that I‚Äôm going to make a big mistake if I say that most of the readers of this article have a folder on the computer in which the code i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A few words about caching data when reading and smartpoint</h1><div class="post__text post__text-html js-mediator-article">  I don‚Äôt think that I‚Äôm going to make a big mistake if I say that most of the readers of this article have a folder on the computer in which the code is stored, which is then used in combat projects.  Small such pieces of algorithms on which the very possibility of implementing an idea is tested.  I call them "nishtyachki." <br><br>  The more a programmer works according to his tasks, the more this daddy swells.  Here is my already climbed beyond seven hundred different demos. <br><br>  But the problem is that in 99 percent of cases all these ‚Äúnishtyachki‚Äù are written to the table, and only the owner of this folder knows about the existence of these developments, and in the same place sometimes whole bins of ideas, implementation approaches, algorithmic tricks, and just stopped on the take-off of thoughts, which it would not be a sin to share (what if someone takes and develops the approach). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article, I will share three developments that came out of just such ‚Äúfolders with nishtyak‚Äù and have been used in our combat projects for many years now. <br>  There will be a little assembler - but don't be scared, it‚Äôs only there in the form of an informational component. <br><a name="habracut"></a><br><h4>  Let's start with caching </h4><br>  It is unlikely that I will reveal the secret that byte reading a file is bad. <br><br>  Well, that means - it‚Äôs bad, it works, and it doesn‚Äôt give any errors, but the brakes ... Cylinder heads are as much as they are scalded, trying to give the data they need to everyone, and here we‚Äôre reading one byte from the file. <br><br>  And why do we even read exactly one byte? <br>  If we abstract a little from the load on the file system and imagine that the file we are reading looks like: ‚Äúa byte containing the data block size + data block, then a byte again containing the data block size + data block‚Äù - then everything is absolutely logical.  In this case, we execute the only correct logic, read the prefix containing the size and the data block itself, and then repeat until we are at the end of the file. <br><br>  Conveniently?  Even there can be no questions - of course convenient. <br><br>  And what we really have to do to get away from the brakes when reading: <br><ol><li>  Read immediately a large amount of data in a temporary buffer; </li><li>  The actual reading is done from the temporary buffer; </li><li>  And if in the temporary data buffer it is not enough, again read them from the file and take into account offsets and other related data; </li></ol><br>  And such a leapfrog with manual caching in a whole heap of project sites where work with files is required. <br><br>  Not comfortable?  Certainly inconvenient, I want the same simplicity, as in the first version. <br><br>  Having understood the essence of the problem, our team gave birth to the following idea: once working with data goes through the heirs from TStream (TFileStream, TWinHTTHStream, TWinFTPStream) - wouldn't you write us a caching proxy over the stream itself?  Well, why not, but we are not the first to take, for example, the same TStreamAdapter from System.Classes, which acts as a layer between IStream and abstract TStream, as a model. <br>  Convenient, by the way, a thing - I advise. <br><br>  Our proxy is made in the form of a banal heir from TStream, so with the help of it you can absolutely freely control the work with the data of any other heir of this class. <br><br>  In general, the implementation of such proxy streams is quite common.  For example, if you omit the TStreamAdapter, you will most likely be aware of such classes as TZCompressionStream and TZDecompressionStream from the ZLib module, which provide a very convenient way to compress and decompress data stored in any arbitrary TStream descendant.  Yes, I used to indulge in such a <a href="">thing myself</a> , having implemented a fairly convenient proxy in the form of the <a href="">TFWZipItemStream</a> class, which, passing all data through itself, edits it ‚Äúon the fly‚Äù and <a href="">reads the checksum of</a> all the data passing through it. <br><br>  Therefore, using the previously accumulated experience, the TBufferedStream class was born, and as a clarification on working with it, a comment was immediately stuck to the class declaration: "// type buffered reading from stream. ReadOnly !!!" <br><br>  But, before proceeding with the study of the code of this class, let's write a small console application that measures the load on the application using different variants of the heirs from TStream, according to the speed of code execution. <br><br>  As the PayLoad functionality, let's do the following - let's calculate the offsets for the resources section of each library located in the system directory (GetSystemDirectory) and notice the time taken to execute using TBufferedStream, then TFileStream, and finally, TMemoryStream. <br><br>  Such a sequence of tests was chosen in order to level the influence of the file system cache, i.e.  The TBufferedStream will work with non-cached data, and the next two tests will (should) be performed significantly faster due to repeated access to the cached (file system) data. <br><br>  Who do you think will win? <br><br>  However: <br><br>  First we need a function that will build a list of files on which the work will be performed: <br><br><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSystemRootFiles</span></span></span><span class="hljs-function">:</span></span> TStringList; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Path: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; SR: TSearchRec; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := TStringList.Create; SetLength(Path, MAX_PATH); GetSystemDirectory(@Path[<span class="hljs-number"><span class="hljs-number">1</span></span>], MAX_PATH); Path := IncludeTrailingPathDelimiter(PChar(Path)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FindFirst(Path + <span class="hljs-string"><span class="hljs-string">'*.dll'</span></span>, faAnyFile, SR) = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> SR.FindData.nFileSizeLow &gt; <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result.Add(Path + SR.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> FindNext(SR) &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> FindClose(SR); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  It creates an instance of TStringList and is filled with paths to libraries that are larger than two megabytes (for the demo, enough). <br><br><div class="spoiler">  <b class="spoiler_title">The next function will be the overall kit over the start of each test with time measurement, also simple, in essence:</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AData: TStringList; StreamType: TStreamClass)</span></span></span><span class="hljs-function">:</span></span> DWORD; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> TotalTime: DWORD; I: Integer; AStream: TStream; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Writeln(StreamType.ClassName, <span class="hljs-string"><span class="hljs-string">': '</span></span>); Writeln(<span class="hljs-string"><span class="hljs-string">'==========================================='</span></span>); AStream := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; TotalTime := GetTickCount; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> AData.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> StreamType = TBufferedStream <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> AStream := TBufferedStream.Create(AData[I], fmOpenRead <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> fmShareDenyWrite, $<span class="hljs-number"><span class="hljs-number">4000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> StreamType = TFileStream <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> AStream := TFileStream.Create(AData[I], fmOpenRead <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> fmShareDenyWrite); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> StreamType = TMemoryStream <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> AStream := TMemoryStream.Create; TMemoryStream(AStream).LoadFromFile(AData[I]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(<span class="hljs-string"><span class="hljs-string">'File: "'</span></span>, AData[I], <span class="hljs-string"><span class="hljs-string">'" CRC = '</span></span>); CalcResOffset(AStream); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> Result := GetTickCount - TotalTime; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">The PayLoad functionality itself is in the common_payload.pas module and looks like a CalcResOffset procedure.</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcResOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AData: TStream; ReleaseStream: Boolean)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> IDH: TImageDosHeader; NT: TImageNtHeaders; Section: TImageSectionHeader; I, A, CRC, Size: Integer; Buff: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">65</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-comment"><span class="hljs-comment">//  ImageDosHeader AData.ReadBuffer(IDH, SizeOf(TImageDosHeader)); //   ,         if IDH.e_magic &lt;&gt; IMAGE_DOS_SIGNATURE then begin Writeln('Invalid DOS header'); Exit; end; //    PE  AData.Position := IDH._lfanew; //   AData.ReadBuffer(NT, SizeOf(TImageNtHeaders)); //   ,         if NT.Signature &lt;&gt; IMAGE_NT_SIGNATURE then begin Writeln('Invalid NT header'); Exit; end; //  ""      if NT.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = 0 then begin Writeln('Resource section not found'); Exit; end; // ""     AData.Position := IDH._lfanew + SizeOf(TImageFileHeader) + 4 + Nt.FileHeader.SizeOfOptionalHeader; //     ... for I := 0 to NT.FileHeader.NumberOfSections - 1 do begin AData.ReadBuffer(Section, SizeOf(TImageSectionHeader)); // ...     if PAnsiChar(@Section.Name[0]) = '.rsrc' then begin //     -  ""    AData.Position := Section.PointerToRawData; Break; end; end; // " " (PayLoad) -      //    :) CRC := 0; Size := Section.SizeOfRawData div SizeOf(Buff); for I := 0 to Size - 1 do begin AData.ReadBuffer(Buff[0], SizeOf(Buff)); for A := Low(Buff) to High(Buff) do Inc(CRC, Buff[A]); end; Writeln(CRC); finally if ReleaseStream then AData.Free; end; end;</span></span></code> </pre><br></div></div><br>  I was too lazy to invent something complex that clearly demonstrated the need to read a file in pieces, so I decided to stop at working with sections of the PE file. <br><br>  The task of this procedure is to calculate the address of the resource section (.rsrc) of the file transferred to it (in the form of a stream) and simply calculate the sum of all bytes located in this section. <br><br>  It immediately shows two things needed for work, reading the buffer with data (DOS header and PE header), after which the resources section is reached, from which data is read in chunks of 64 bytes and summarized with the result. <br>  PS: yes, I know that the data from the section are not considered as a whole, because  reading is in blocks and the last, not a multiple of 64 bytes is not considered, but then this is an example. <br><br><div class="spoiler">  <b class="spoiler_title">Run this trouble with this code:</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> S: TStringList; A, B, C: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> S := GetSystemRootFiles; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-comment"><span class="hljs-comment">//A := MakeTest(S, TBufferedStream); B := MakeTest(S, TFileStream); C := MakeTest(S, TMemoryStream); Writeln('==========================================='); //Writeln('TBufferedStream = ', A); Writeln('TFileStream = ', B); Writeln('TMemoryStream = ', C); finally S.Free; end; except on E: Exception do Writeln(E.ClassName, ': ', E.Message); end; Readln; end.</span></span></code> </pre><br></div></div><br>  We look at the result (the picture already includes the results from the TBufferedStream): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a89/d2e/f07/a89d2ef07f0041dc918ff98d6b019021.png"></div><br><br>  TFileStream, as expected, was far behind, but TMemoryStream showed a result very close to the results of the TBufferedStream that we have not yet reviewed. <br><br>  It's okay, the fact is that he did it with a big overhead from memory, because  he had to load each library into the application‚Äôs memory (drawdown), but caught up in speed for the very same reason (avoiding the need to frequently read data from the disk). <br><br><div class="spoiler">  <b class="spoiler_title">And now TBufferedStream itself:</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TBufferedStream</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TStream) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FStream: TStream; FOwnership: TStreamOwnership; FPosition: Int64; FBuff: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> byte; FBuffStartPosition: Int64; FBuffSize: Integer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBuffer_EndPosition</span></span></span><span class="hljs-function">:</span></span> Int64; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetBufferSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Buffer_StartPosition: Int64 <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FBuffStartPosition; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Buffer_EndPosition: Int64 <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> GetBuffer_EndPosition; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer_Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Buffer; Size: LongInt)</span></span></span><span class="hljs-function">:</span></span> Longint; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer_Update</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer_Contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(APosition: Int64)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStream: TStream; AOwnership: TStreamOwnership = soReference)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AFileName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Mode: Word; ABuffSize: Integer = 1024 * 1024)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Buffer; Count: Longint)</span></span></span><span class="hljs-function">:</span></span> Longint; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Buffer; Count: Longint)</span></span></span><span class="hljs-function">:</span></span> Longint; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Seek</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Offset: Int64; Origin: TSeekOrigin)</span></span></span><span class="hljs-function">:</span></span> Int64; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> BufferSize: Integer <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FBuffSize <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> SetBufferSize; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvalidateBuffer</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br>  The public section is nothing out of the ordinary, the same overlapped Read / Write / Seek as any other proxy stream. <br><br>  The whole trick starts with this function: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TBufferedStream</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Buffer; Count: Longint)</span></span></span><span class="hljs-function">:</span></span> Longint; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Readed: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> Result &lt; Count <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Readed := Buffer_Read(PAnsiChar(@Buffer)[Result], Count - Result); Inc(Result, Readed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Readed = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Buffer_Update <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  As you can see from the code, we try to read the data by calling the Buffer_Read function, which returns it from the already prepared cache, and if we could not read it, we try to reinitialize the cache by calling Buffer_Update. <br><br>  Reinitializing the cache looks like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TBufferedStream</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer_Update</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FStream.Position := FPosition; FBuffStartPosition := FPosition; SetLength(FBuff, FBuffSize); SetLength(FBuff, FStream.<span class="hljs-keyword"><span class="hljs-keyword">Read</span></span>(FBuff[<span class="hljs-number"><span class="hljs-number">0</span></span>], FBuffSize)); Result := Length(FBuff) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Those.  we allocate memory for the cache, the size specified in the BufferSize property of the class, after which we attempt to read the cache from the stream we control. <br><br>  If the data was considered successful, we correct the actual cache size (because if you wanted to count megabytes, and only 15 bytes are available, then we will free up unnecessary memory, why do we need too much?). <br><br>  The read operation from the cache is also simple: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TBufferedStream</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer_Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Buffer; Size: LongInt)</span></span></span><span class="hljs-function">:</span></span> Longint; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Buffer_Contains(FPosition) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; Result := Buffer_EndPosition - FPosition + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Result &gt; Size <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := Size; Move(FBuff[Integer(FPosition - Buffer_StartPosition)], Buffer, Result); Inc(FPosition, Result); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Just check the current position of the stream and make sure that we really store the necessary data available on this offset, after which with the banal Move we transfer the data to the external buffer. <br><br>  The remaining methods of this class are too trivial, so I will not consider them, they can be found in demos in the archive for the article: " <a href="">. \ Src \ bufferedstream \</a> " <br><br>  <b>What is the result?</b> <br><ol><li>  The TBufferedStream class has a much smaller (at times) overhead data reading speed than the TFileStream because of the cache implemented in it.  The number of read operations from the disk (which in itself is a fairly ‚Äúhard operation‚Äù) has been significantly reduced. </li><li>  For the same reason, overhead costs for speed are much less compared to TMemoryStream, since  only the necessary data is read into the cache, and not the entire file. </li><li>  The memory overhead is significantly lower than TMemoryStream, for obvious reasons.  Of course, in this case, TFileStream will win in terms of memory costs, but, again, speed ... </li><li>  The class provides an easy-to-use layer, which allows not to think about the life time of the stream controlled by it and retains all the functionality necessary for work. </li></ol><br>  Liked? <br><br>  Then we go to the second part. <br><br><h4>  TOnMemoryStream </h4><br>  But imagine that the data we want to read is already located in the memory of our application.  In order not to overcomplicate, we will again dwell on the same libraries discussed in the first part of the article.  In order to perform the same work that was shown in the CalcResOffset function, we will need to somehow transfer the library data to some TStream heir (for example, in the same TMemoryStream). <br><br>  And what will we do in this case? <br>  In 99 percent of cases, create a TMemoryStream and call the Write (WriteBuffer) function. <br>  Is it normal, because we are in fact simply copying the data that we already have?  And we will do this for one reason only - in order to be able to work with the data through the usual TStream. <br><br>  To correct this superfluous overhead memory, such a simple class was developed: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TOnMemoryStream</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TCustomMemoryStream) <span class="hljs-comment"><span class="hljs-comment">///     . ///      not ReadOnly,        private FReadOnly: Boolean; protected procedure SetSize(NewSize: Longint); override; public constructor Create(Ptr: Pointer; Size: Longint; ReadOnlyMode: Boolean = True); function Write(const Buffer; Count: Longint): Longint; override; property ReadOnly: Boolean read FReadOnly write FReadOnly; end; implementation { TOnMemoryStream } constructor TOnMemoryStream.Create(Ptr: Pointer; Size: Longint; ReadOnlyMode: Boolean = True); begin inherited Create; SetPointer(Ptr, Size); FReadOnly := ReadOnlyMode; end; function TOnMemoryStream.Write(const Buffer; Count: Longint): Longint; var Pos: Longint; begin if (Position &gt;= 0) and (Count &gt;= 0) and (not ReadOnly) and (Position + Count &lt;=Size) then begin Pos := Position + Count; Move(Buffer, Pointer(Longint(Memory) + Position)^, Count); Position := Pos; Result := Count; end else Result := 0; end; procedure TOnMemoryStream.SetSize(NewSize: Longint); begin raise Exception.Create('TOnMemoryStream.SetSize can not be called.'); end;</span></span></code> </pre><br>  I do not even know what to add to this code as a comment, so let's just take a look at working with this class. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">program</span></span> onmemorystream_demo; <span class="hljs-meta"><span class="hljs-meta">{$APPTYPE CONSOLE}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R *.res}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows, SysUtils, common_payload <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'..\common\common_payload.pas'</span></span>, OnMemoryStream <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'OnMemoryStream.pas'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> M: TOnMemoryStream; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> M := TOnMemoryStream.Create( Pointer(GetModuleHandle(<span class="hljs-string"><span class="hljs-string">'ntdll.dll'</span></span>)), <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-comment"><span class="hljs-comment">{     8 }</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> CalcResOffset(M, False); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> M.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> E: Exception <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Writeln(E.ClassName, <span class="hljs-string"><span class="hljs-string">': '</span></span>, E.<span class="hljs-keyword"><span class="hljs-keyword">Message</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Readln; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br>  Everything is simple here - we are looking for the address of the loaded NTDLL.DLL and read its resource section directly from memory, using all the advantages of the stream (and there is no need to copy anything into the temporary buffer. <br><br>  Now a few comments on the use of the class. <br><br>  In general, it is very pleasant, if it is used only in data reading operations, but ... as can be seen from the code, it does not prohibit writing data to the memory block it controls, and this can be very troublesome. <br><br>  We can easily overwrite data critical for the operation of the application, and then go to a banal AV, so in our projects using this class feature is minimized (literally rebuilding search indexes in the right places on a pre-allocated buffer is so easy). <br><br>  By the way, it is for this reason that we refused to use the Friendly classes, which allow access to the TCustomMemoryStream.SetPointer call, since  in this case, the recording will not be controlled by anyone at all, which may result in good such badabum. <br><br>  The source code of the class and example can be viewed in the archive: " <a href="">.src \ onmemorystream \</a> " <br><br>  However, we turn to the concluding part of the article. <br><br><h4>  Smartpainer Special Case - SharedPtr </h4><br>  Now I will teach the bad. <br><br>  Let's take a look at how to work with objects in Delphi.  Usually it looks like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> T: TObject; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> T := TObject.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-comment"><span class="hljs-comment">//    finally T.Free; end;</span></span></code> </pre><br>  Newbies in the language, of course, forget about using the finalization section, rolling pearls like this: <br><br><pre> <code class="delphi hljs">T := TObject.Create; <span class="hljs-comment"><span class="hljs-comment">//    T.Free;</span></span></code> </pre><br>  And even then, forgetting the need to release the object, they do not tell the Free object. <br>  Some "advanced beginners" manage to implement even such a "govnokod" <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> T := TObject.Create; <span class="hljs-comment"><span class="hljs-comment">//    finally T.Free; end;</span></span></code> </pre><br>  And once I met, and here with this implementation: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> T := TObject.Create; <span class="hljs-comment"><span class="hljs-comment">//    T.Free; end;</span></span></code> </pre><br>  Well, the man tried - immediately visible. <br>  However, let's still focus on the first version of the correct code. <br>  He has the following minus - if we need to work with several classes at the same time, we will have to significantly expand the code due to the multiple uses of the finalization sections: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> T1, T2, T3: TObject; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> T1 := TObject.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> T2 := TObject.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> T3 := TObject.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-comment"><span class="hljs-comment">//      1/2/3 finally T3.Free; end; finally T2.Free; end; finally T1.Free; end;</span></span></code> </pre><br>  There is, of course, an option that is somewhat dubious and not used by me, but recently quite often found on the Internet: <br><br><pre> <code class="delphi hljs">T1 := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; T2 := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; T3 := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> T1 := TObject.Create; T2 := TObject.Create; T3 := TObject.Create; <span class="hljs-comment"><span class="hljs-comment">//      1/2/3 finally T3.Free; T2.Free; T1.Free; end;</span></span></code> </pre><br>  Due to the initial initialization of each object, in this case, an error will not occur when calling Free an object that has not yet been created (if an exception is suddenly raised in the previous constructor), but still it looks too doubtful. <br><br>  And how do you look at that, if I say that calling the Free method can not be done at all? <br>  Yes, just create an object and forget about the fact that it needs to be destroyed. <br><br>  What does this look like?  Yes, like this: <br><br><pre> <code class="delphi hljs">T := TObject.Create; <span class="hljs-comment"><span class="hljs-comment">//   </span></span></code> </pre><br>  Well, of course, right in this form, this cannot be done without a memo - well, we don‚Äôt have a garbage collector and other things, but don‚Äôt rush to say: ‚ÄúSanya - you lost your mind!‚Äù ... because you can take an idea from other programming languages ‚Äã‚Äãand implement it in our , "Great and mighty." <br><br>  And we will take idea from SharedPtr: <a href="http://msdn.microsoft.com/en-US/en-en/library/bb982026.aspx">we watch documentation</a> . <br><br>  The logic of this class is simple - control the lifetime of an object by counting references to it.  Fortunately, we can do it - we have such a mechanism, we call interfaces. <br><br>  But not everything is so simple. <br><br>  Of course, with a swoop, you can roll out such an idea - we implement support for IUnknown in the class and everything, as soon as the reference count for an instance of the class reaches zero - it will collapse. <br>  But we can only do this with handwritten classes, and what to do with the same TMemoryStream, which has all the feng shui on the drum, because he doesn't know about the interfaces? <br><br>  The most logical thing is to write another proxy, which will keep a link to the object it controls and in itself will implement reference counting, and at its destruction it will bang the object entrusted to it for storage. <br><br>  But here, too, is not so rosy.  We will write a proxy, and what is there to write it? The idea has already been voiced, but there will be a large drawdown both in memory and in the speed of working with the class, if it uses the classic interface as a reference engine, with all its features. <br><br><div class="spoiler">  <b class="spoiler_title">Therefore, let us approach the solution of the problem from the technical side and look at the implementation minuses through the interface:</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">program</span></span> slowsharedptr; <span class="hljs-meta"><span class="hljs-meta">{$APPTYPE CONSOLE}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R *.res}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows, Classes, SysUtils; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TObjectDestroyer</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TInterfacedObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FObject: TObject; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AObject: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TSharedPtr = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FDestroyerObj: TObjectDestroyer; FDestroyer: IUnknown; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AValue: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TObjectDestroyer }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjectDestroyer</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AObject: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; FObject := AObject; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjectDestroyer</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FObject.Free; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TSharedPtr }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSharedPtr</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AValue: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FDestroyerObj := TObjectDestroyer.Create(AValue); FDestroyer := FDestroyerObj; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; T: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ReportMemoryLeaksOnShutdown := True; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> T := GetTickCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> $FFFFFF <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> TSharedPtr.Create(TObject.Create); Writeln(GetTickCount - T); <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> E: Exception <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Writeln(E.ClassName, <span class="hljs-string"><span class="hljs-string">': '</span></span>, E.<span class="hljs-keyword"><span class="hljs-keyword">Message</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Readln; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br></div></div><br>  The time spent on the execution of this code will be around 3525 milliseconds (remember this number). <br><br>  The bottom line: the main logic is released by the TObjectDestroyer class, which works with reference counting and destroys the object passed to it for storage.  TSharedPtr is a structure through which proper work with links occurs at the moment when it goes out of scope (of course, in this case, it can be done without this structure, but ...). <br>  If you run the example, you will see that the created objects will be destroyed before the application terminates (however, if this were not the case, you would be clearly informed about this, because the ReportMemoryLeaksOnShutdown flag is on). <br><br>  But let's take a closer look at where there may be an overhead that we do not need (both in terms of memory and speed of execution). <br><br>  Well, firstly - TObjectDestroyer.InstanceSize is equal to 20. <br>  Heh, we get an extra 20 bytes of memory for each object we control, and given that the granularity of the memory manager in Delphi is 12 bytes, then not all the 24 bytes are lost, but all 24. Do you think the little things?  Maybe so - but our version should go (and will be) exactly 12 bytes, because if you remove the overhead - so entirely. <br><br>  The second problem is the redundant overhead when calling interface methods. <br>  Let's remember what it looks like in the memory of a VMT object that implements the interface. <br>  The VMT of the object begins with the virtual methods of the object itself, including the overlapped methods of the interface, and these overlapped methods do not belong to the interface. <br>  And just behind them comes the VMT methods of the interface itself, which, when called, redirects (by means of the CompilerMagic constant, calculated for each interface at the compilation stage) to the real code. <br><br>  This can be seen visually by executing the following code: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSharedPtr</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AValue: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: IUnknown; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FDestroyerObj := TObjectDestroyer.Create(AValue); I := FDestroyerObj; I._AddRef; I._Release;</code> </pre><br>  If you look at the assembler listing, we will see the following: <br><br><pre> <code class="delphi hljs">slowsharedptr.dpr.<span class="hljs-number"><span class="hljs-number">51</span></span>: I._AddRef; <span class="hljs-number"><span class="hljs-number">004</span></span>D3C73 <span class="hljs-number"><span class="hljs-number">8</span></span>B45F4 mov eax,[ebp-$<span class="hljs-number"><span class="hljs-number">0</span></span>c] <span class="hljs-number"><span class="hljs-number">004</span></span>D3C76 <span class="hljs-number"><span class="hljs-number">50</span></span> push eax <span class="hljs-number"><span class="hljs-number">004</span></span>D3C77 <span class="hljs-number"><span class="hljs-number">8</span></span>B00 mov eax,[eax] <span class="hljs-number"><span class="hljs-number">004</span></span>D3C79 FF5004 call dword ptr [eax+$<span class="hljs-number"><span class="hljs-number">04</span></span>] <span class="hljs-comment"><span class="hljs-comment">//      slowsharedptr.dpr.52: I._Release; 004D3C7C 8B45F4 mov eax,[ebp-$0c] 004D3C7F 50 push eax 004D3C80 8B00 mov eax,[eax] 004D3C82 FF5008 call dword ptr [eax+$08] //    </span></span></code> </pre><br><br>  ... which lead to: <br><br><pre> <code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">004021</span></span>A3 <span class="hljs-number"><span class="hljs-number">83442404</span></span>F8 add dword ptr [esp+$<span class="hljs-number"><span class="hljs-number">04</span></span>],-$<span class="hljs-number"><span class="hljs-number">08</span></span> <span class="hljs-comment"><span class="hljs-comment">//   VMT  004021A8 E93FB00000 jmp TInterfacedObject._AddRef</span></span></code> </pre><br>  in the first case, and in the second on: <br><br><pre> <code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">004021</span></span>AD <span class="hljs-number"><span class="hljs-number">83442404</span></span>F8 add dword ptr [esp+$<span class="hljs-number"><span class="hljs-number">04</span></span>],-$<span class="hljs-number"><span class="hljs-number">08</span></span> <span class="hljs-comment"><span class="hljs-comment">//   VMT  004021B2 E951B00000 jmp TInterfacedObject._Release</span></span></code> </pre><br>  If we inherited in TObjectDestroyer not from IUnknown, but, for example, from IEnumerator, then the compiler would automatically correct the output addresses to the VMT object like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">004</span></span>D3A4B <span class="hljs-number"><span class="hljs-number">83442404</span></span>F0 add dword ptr [esp+$<span class="hljs-number"><span class="hljs-number">04</span></span>],-$<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">//  8,  16 004D3A50 E9CB97F3FF jmp TInterfacedObject._AddRef 004D3A55 83442404F0 add dword ptr [esp+$04],-$10 // ..     004D3A5A E9DD97F3FF jmp TInterfacedObject._Release</span></span></code> </pre><br>  It is through such a jump that the compiler makes a call to the _AddRef and _Release methods when the reference count changes (for example, when an interface is assigned to a new variable, or when it goes out of scope). <br><br>  Therefore, now we will defeat all this trouble and write our own interface. <br><br>  So we write: <br><br><pre> <code class="delphi hljs">PObjectDestroyer = ^TObjectDestroyer; TObjectDestroyer = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> VTable: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Pointer; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QueryInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Self: PObjectDestroyer; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IID: TGUID; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Obj)</span></span></span><span class="hljs-function">:</span></span> HResult; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Self: PObjectDestroyer)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Self: PObjectDestroyer)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassCreate</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FVTable: Pointer; FRefCount: Integer; FObj: TObject; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AObj: TObject)</span></span></span><span class="hljs-function">:</span></span> IUnknown; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Do you think this is a record structure? <br>  Noah is the very object itself, with its own VMT located in VTable and exactly 12 bytes in size: <br><br><pre> <code class="delphi hljs">FVTable: Pointer; FRefCount: Integer; FObj: TObject;</code> </pre><br>  Now the actual "magic". <br><br>  VMT initialization occurs in the following method: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjectDestroyer</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassCreate</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VTable[<span class="hljs-number"><span class="hljs-number">0</span></span>] := @QueryInterface; VTable[<span class="hljs-number"><span class="hljs-number">1</span></span>] := @_AddRef; VTable[<span class="hljs-number"><span class="hljs-number">2</span></span>] := @_Release; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  All according to the canons, and Delphi will not even suspect any trick here, because for her it will be an absolutely valid VMT, implemented according to all laws and rules. <br><br>  But the main constructor looks like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjectDestroyer</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AObj: TObject)</span></span></span><span class="hljs-function">:</span></span> IUnknown; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> P: PObjectDestroyer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> AObj = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); GetMem(P, SizeOf(TObjectDestroyer)); P^.FVTable := @VTable; P^.FRefCount := <span class="hljs-number"><span class="hljs-number">0</span></span>; P^.FObj := AObj; Result := IUnknown(P); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Via GetMem, we allocate a place under the InstanceSize of our ‚Äúsupposedly‚Äù class, despite the fact that it is actually a structure, after which we initialize the required fields as a pointer to VMT, a reference count and a pointer to an object controlled by the class. <br>  And with this we immediately bypass the overhead on the InitInstance call and the load that is associated with it. <br>  Pay attention - the result of the constructor call is the IUnknown interface. <br><br>  Hack  Of course. <br>  Works?  Of course. <br><br>  The implementation of the methods QueryInterface, _AddRef and _Release is taken from the standard TIntefacedObject and is not interesting.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, the QueryInterface in this approach is essentially redundant, but since we decided to do everything according to the classics, and we are laying on the fact that some kind of ‚Äúmad programmer‚Äù will still try to pull this method, then we will leave it in its proper place (especially since and so should go first in the VMT interface. Well, do not leave the junk pointer instead of it?). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's do a little over the structure with which we provided control over the links:</font></font><br><br><pre> <code class="delphi hljs">TSharedPtr&lt;T: <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>&gt; = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FPtr: IUnknown; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-function">:</span></span> T; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AObj: T)</span></span></span><span class="hljs-function">:</span></span> TSharedPtr&lt;T&gt;; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Null</span></span></span><span class="hljs-function">:</span></span> TSharedPtr&lt;T&gt;; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Value: T <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> GetValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unwrap</span></span></span><span class="hljs-function">:</span></span> T; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The designer has changed a little bit: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSharedPtr</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AObj: T)</span></span></span><span class="hljs-function">:</span></span> TSharedPtr&lt;T&gt;; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result.FPtr := TObjectDestroyer.Create(AObj); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, the essence of this has not changed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A new method has been added, through which it will be possible to gain access, to the object controlled by our shareholder:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSharedPtr</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-function">:</span></span> T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FPtr = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); Result := T(PObjectDestroyer(FPtr)^.FObj); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Well, two utilitarian procedures, the first of which simply reduces the number of links: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSharedPtr</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Null</span></span></span><span class="hljs-function">:</span></span> TSharedPtr&lt;T&gt;; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result.FPtr := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And the second one disables the object controlled by the class from this whole mechanism: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSharedPtr</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unwrap</span></span></span><span class="hljs-function">:</span></span> T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FPtr = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); Result := T(PObjectDestroyer(FPtr).FObj); PObjectDestroyer(FPtr).FObj := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; FPtr := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's see - why do we need all this? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the situation: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, for example, we created a certain instance of the class, which is monitored by TObjectDestroyer and given it outside, what happens in this case? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's right - as soon as the execution of the procedure code in which the object was created is completed, it will be immediately destroyed and the external code will work with the pointer that has already been killed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this purpose, the TSharedPtr class has been introduced, by means of which it is possible to ‚Äúprokidyvat‚Äù the data on the procedures of our application, without fear of premature destruction of the object. As soon as he really becomes useless to anyone - TObjectDestroyer will instantly crash him and everyone will be nirvana.</font></font><br><br>  But that is not all. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having twirled the TSharedPtr implementation, we nevertheless concluded that it was not entirely successful. </font><font style="vertical-align: inherit;">And you know why? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because such a constructor code seemed to us too redundant:</font></font><br><br><pre> <code class="delphi hljs">TSharedPtr&lt;TMyObj&gt;.Create(TMyObj.Create);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yeah - that's exactly what you need to call, but in order not to scare programmers who are unprepared for such happiness, we decided to add a small wrapper around this plan: </font></font><br><br><pre> <code class="delphi hljs"> TSharedPtr = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>&gt;(AObj: T): TSharedPtr&lt;T&gt;; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSharedPtr</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AObj: T)</span></span></span><span class="hljs-function">:</span></span> TSharedPtr&lt;T&gt;; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result.FPtr := TObjectDestroyer.Create(AObj); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After which everything became much more pleasant, and the call of the shareholder began to look much more familiar, and resemble the creation of a previously voiced proxy: </font></font><br><br><pre> <code class="delphi hljs">TSharedPtr.Create(TObject.Create)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But enough to rant and look at the drawdown time (and she, of course, will be): </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write the code:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">program</span></span> sharedptr_demo; <span class="hljs-meta"><span class="hljs-meta">{$APPTYPE CONSOLE}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R *.res}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows, System.SysUtils, StaredPtr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'StaredPtr.pas'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Count = $FFFFFF; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestObj</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; Start: Cardinal; Obj: TObject; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Start := GetTickCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Obj := TObject.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-comment"><span class="hljs-comment">// do nothing... finally Obj.Free; end; end; Writeln(PChar('TObject: ' + (GetTickCount - Start).ToString())); end; procedure TestAutoDestroy; var I: Integer; Start: Cardinal; begin Start := GetTickCount; for I := 0 to Count - 1 do TObject.Create.AutoDestroy; Writeln(PChar('AutoDestroy: ' + (GetTickCount - Start).ToString())); end; procedure TestSharedPtr; var I: Integer; Start: Cardinal; begin Start := GetTickCount; for I := 0 to Count - 1 do TSharedPtr.Create(TObject.Create); Writeln(PChar('SharedPtr: ' + (GetTickCount - Start).ToString())); end; begin try TestObj; TestAutoDestroy; TestSharedPtr; except on E: Exception do Writeln(E.ClassName, ': ', E.Message); end; Readln; end.</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And look what happened: </font></font><br><br><div style="text-align:center;"><img src="//habrastorage.org/files/aef/1e8/846/aef1e8846167420e946790b92e9a2519.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the first version of the shareholder, there was a delay of 3525 milliseconds, the new version would produce the number 2917 - no wonder they tried, it turns out. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, what is this AutoDestroy that has outrunned the chartrinter for a full second? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a helper, and this is bad. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bad, because this helper is implemented over TObject:</font></font><br><br><pre> <code class="delphi hljs"> TObjectHelper = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">helper</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> TObject <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AutoDestroy</span></span></span><span class="hljs-function">:</span></span> IUnknown; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-comment"><span class="hljs-comment">{ TObjectHelper }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjectHelper</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AutoDestroy</span></span></span><span class="hljs-function">:</span></span> IUnknown; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := TObjectDestroyer.Create(Self); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that, at least in XE4, the conflict with intersecting helpers is still not defeated, i.e. if you have your own helper above TStream and you try to connect to it in a pair of TObjectHelper - the project will not crash. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I don‚Äôt know if this problem is solved in XE7, but it is definitely present in the four, and for this reason we don‚Äôt use this piece of code, although it is much more productive than using the TSharedPtr structure. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's look at the penultimate moment I mentioned above, namely, about the implementation of the jump to VMT, for this we will write two simple procedures:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestInterfacedObjectVMT</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: IUnknown; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> I := TInterfacedObject.Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the very beginning I mentioned that using the simplest version of TSharedPtr in the very first example is a bit redundant. </font><font style="vertical-align: inherit;">Yes, this is so, in that case, you could just memorize the interface reference in a local variable (which TSharedPtr is essentially doing, though in a slightly different way); </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, see what happens in this version of the code: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Creating an object and initializing the interface:</font></font><br><br><pre> <code class="delphi hljs">sharedptr_demo.dpr.<span class="hljs-number"><span class="hljs-number">60</span></span>: I := TInterfacedObject.Create; <span class="hljs-number"><span class="hljs-number">004192</span></span>BB B201 mov dl,$<span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">004192</span></span>BD A11C1E4000 mov eax,[$<span class="hljs-number"><span class="hljs-number">00401</span></span>e1c] <span class="hljs-number"><span class="hljs-number">004192</span></span>C2 E899C5FEFF call TObject.Create <span class="hljs-number"><span class="hljs-number">004192</span></span>C7 <span class="hljs-number"><span class="hljs-number">8</span></span>BD0 mov edx,eax <span class="hljs-number"><span class="hljs-number">004192</span></span>C9 <span class="hljs-number"><span class="hljs-number">85</span></span>D2 test edx,edx <span class="hljs-number"><span class="hljs-number">004192</span></span>CB <span class="hljs-number"><span class="hljs-number">7403</span></span> jz $<span class="hljs-number"><span class="hljs-number">004192</span></span>d0 <span class="hljs-number"><span class="hljs-number">004192</span></span>CD <span class="hljs-number"><span class="hljs-number">83</span></span>EAF8 sub edx,-$<span class="hljs-number"><span class="hljs-number">08</span></span> <span class="hljs-number"><span class="hljs-number">004192</span></span>D0 <span class="hljs-number"><span class="hljs-number">8</span></span>D45FC lea eax,[ebp-$<span class="hljs-number"><span class="hljs-number">04</span></span>] <span class="hljs-number"><span class="hljs-number">004192</span></span>D3 E8C801FFFF call @IntfCopy</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2. Call the finalization section: </font></font><br><br><pre> <code class="delphi hljs">sharedptr_demo.dpr.<span class="hljs-number"><span class="hljs-number">61</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-number"><span class="hljs-number">004192</span></span>D8 <span class="hljs-number"><span class="hljs-number">33</span></span>C0 xor eax,eax <span class="hljs-number"><span class="hljs-number">004192</span></span>DA <span class="hljs-number"><span class="hljs-number">5</span></span>A pop edx <span class="hljs-number"><span class="hljs-number">004192</span></span>DB <span class="hljs-number"><span class="hljs-number">59</span></span> pop ecx <span class="hljs-number"><span class="hljs-number">004192</span></span>DC <span class="hljs-number"><span class="hljs-number">59</span></span> pop ecx <span class="hljs-number"><span class="hljs-number">004192</span></span>DD <span class="hljs-number"><span class="hljs-number">648910</span></span> mov fs:[eax],edx <span class="hljs-number"><span class="hljs-number">004192</span></span>E0 <span class="hljs-number"><span class="hljs-number">68</span></span>F5924100 push $<span class="hljs-number"><span class="hljs-number">004192</span></span>f5 <span class="hljs-number"><span class="hljs-number">004192</span></span>E5 <span class="hljs-number"><span class="hljs-number">8</span></span>D45FC lea eax,[ebp-$<span class="hljs-number"><span class="hljs-number">04</span></span>] <span class="hljs-number"><span class="hljs-number">004192</span></span>E8 E89B01FFFF call @IntfClear <span class="hljs-comment"><span class="hljs-comment">// &lt;&lt;&lt;      004192ED C3 ret</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3. After that, the control is transferred to @IntfClear, where the leap announced earlier awaits us: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">00401</span></span>DE1 <span class="hljs-number"><span class="hljs-number">83442404</span></span>F8 add dword ptr [esp+$<span class="hljs-number"><span class="hljs-number">04</span></span>],-$<span class="hljs-number"><span class="hljs-number">08</span></span> <span class="hljs-number"><span class="hljs-number">00401</span></span>DE6 E951770000 jmp TInterfacedObject._Release</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And what happens in the use of TObjectDestroyer? </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestSharedPtrVMT</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TObjectDestroyer.Create(TObject.Create); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Creating an object and creating the TObjectDestroyer itself: </font></font><br><br><pre> <code class="delphi hljs">sharedptr_demo.dpr.<span class="hljs-number"><span class="hljs-number">66</span></span>: TObjectDestroyer.Create(TObject.Create); <span class="hljs-number"><span class="hljs-number">004</span></span>D3C27 B201 mov dl,$<span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">004</span></span>D3C29 A184164000 mov eax,[$<span class="hljs-number"><span class="hljs-number">00401684</span></span>] <span class="hljs-number"><span class="hljs-number">004</span></span>D3C2E E89945F3FF call TObject.Create <span class="hljs-number"><span class="hljs-number">004</span></span>D3C33 <span class="hljs-number"><span class="hljs-number">8</span></span>D55FC lea edx,[ebp-$<span class="hljs-number"><span class="hljs-number">04</span></span>] <span class="hljs-number"><span class="hljs-number">004</span></span>D3C36 E8B5FBFFFF call TObjectDestroyer.Create</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, there is an overhead, an extra action, after all. </font><font style="vertical-align: inherit;">However, what about the destruction? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Everything is very simple:</font></font><br><br><pre> <code class="delphi hljs">sharedptr_demo.dpr.<span class="hljs-number"><span class="hljs-number">67</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-number"><span class="hljs-number">004</span></span>D3C3B <span class="hljs-number"><span class="hljs-number">33</span></span>C0 xor eax,eax <span class="hljs-number"><span class="hljs-number">004</span></span>D3C3D <span class="hljs-number"><span class="hljs-number">5</span></span>A pop edx <span class="hljs-number"><span class="hljs-number">004</span></span>D3C3E <span class="hljs-number"><span class="hljs-number">59</span></span> pop ecx <span class="hljs-number"><span class="hljs-number">004</span></span>D3C3F <span class="hljs-number"><span class="hljs-number">59</span></span> pop ecx <span class="hljs-number"><span class="hljs-number">004</span></span>D3C40 <span class="hljs-number"><span class="hljs-number">648910</span></span> mov fs:[eax],edx <span class="hljs-number"><span class="hljs-number">004</span></span>D3C43 <span class="hljs-number"><span class="hljs-number">68583</span></span>C4D00 push $<span class="hljs-number"><span class="hljs-number">004</span></span>d3c58 <span class="hljs-number"><span class="hljs-number">004</span></span>D3C48 <span class="hljs-number"><span class="hljs-number">8</span></span>D45FC lea eax,[ebp-$<span class="hljs-number"><span class="hljs-number">04</span></span>] <span class="hljs-number"><span class="hljs-number">004</span></span>D3C4B E8DC92F3FF call @IntfClear <span class="hljs-number"><span class="hljs-number">004</span></span>D3C50 C3 ret</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Almost identical to the first option. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the most interesting thing will happen when you call @IntfClear, it will skip redundant jumps on the VMT and transfer control to the class function TObjectDestroyer._Release right away. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, we saved on calling two instructions (add and jmp), but unfortunately this is for now the most minimal thing that can be done, since in the case of proxy use, the overhead is simply not unavoidable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In conclusion, it remains only to see how to use the mechanism of automatic destruction of an object in practice: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, create a file stream and write some constant in it:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestWriteBySharedPtr</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> F: TFileStream; ConstData: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ConstData := $DEADBEEF; F := TFileStream.Create(<span class="hljs-string"><span class="hljs-string">'data.bin'</span></span>, fmCreate); TObjectDestroyer.Create(F); F.WriteBuffer(ConstData, SizeOf(ConstData)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, this is all - the life of the stream is controlled, and excessive inclinations are not required. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the TSharedPtr structure is not used, since </font><font style="vertical-align: inherit;">there is no need to transfer the pointer between parts of the code and enough TObjectDestroyer functionality. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now we will read the value of the constant from the file and display it, and at the same time we will look at the transfer of data between the procedures. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is how we create an object controlled by a shareholder:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateReadStream</span></span></span><span class="hljs-function">:</span></span> TSharedPtr&lt;TFileStream&gt;; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := TSharedPtr.Create(TFileStream.Create(<span class="hljs-string"><span class="hljs-string">'data.bin'</span></span>, fmOpenRead <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> fmShareDenyWrite)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And so we will get data from this object: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestReadBySharedPtr</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> F: TSharedPtr&lt;TFileStream&gt;; ConstData: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> F := CreateReadStream; F.Value.ReadBuffer(ConstData, SizeOf(ConstData)); Writeln(IntToHex(ConstData, <span class="hljs-number"><span class="hljs-number">8</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, the code has practically not changed, if we compare it with the classical approach to software development. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pros</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the need to use TRY..FINALLY blocks has disappeared, the code has become less overloaded in volume. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The minuses</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are a small overhead in speed and the designers have slightly expanded, forcing us to call TSharedPtr.Create (in case of data transfer to the external) or TObjectDestroyer to control the lifetime. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is also an additional parameter Value, through which you can get access to the controlled object in the case of using TSharedPtr, but it‚Äôs enough just to get used to it, especially since this is all that Delphi is capable of in terms of syntactic sugar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Although I still dream that there will be a DEFAULT object method (or a property of not enumerated type) that can be called without specifying its name by simply referring to the class variable, then we would declare the Value property of the TSharedPtr class as default and work with the base object, even not knowing that he is under proxy control :) </font></font><br><br><h4>  findings </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Only one conclusion - I was tired of painting it all. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But seriously, all three approaches shown above are quite comfortable, in fact, and I use the first two almost everywhere. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With TSharedPtr, of course, I am cautious. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not think that he is bad - for another reason. </font><font style="vertical-align: inherit;">I still (for so many years of practice) are uncomfortable to observe the code without using the finalization sections, although I certainly understand that the posterior cerebellum will work as it should - but ... not usual.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, I use TSharedPtr only in a few special cases - when I need to release an object into the external code, which is not controlled by me, although my colleagues have a slightly different point of view and use it quite often (of course, not everywhere, because you can see that its main minus - double speed drawdown, as payment for usability). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And on this, perhaps, I round out. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Check your bins - share, because there definitely is something useful. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code of demos is available at </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/243569/">https://habr.com/ru/post/243569/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243559/index.html">Google will mark mobile sites in search results</a></li>
<li><a href="../243561/index.html">How the cloud makes life easier for startups</a></li>
<li><a href="../243563/index.html">Theoretical minimum * nix-based-systems for WebDev-padawan</a></li>
<li><a href="../243565/index.html">Using RequireJS in AngularJS Applications</a></li>
<li><a href="../243567/index.html">Ciklum iOS Practice Leaders Meet-Up // Architecture in iOS, Dnepropetrovsk, November 20</a></li>
<li><a href="../243571/index.html">My bike to reflection in c ++</a></li>
<li><a href="../243573/index.html">Check your website availability from Africa</a></li>
<li><a href="../243577/index.html">IBM launches a joint master‚Äôs program in the field of Big Data with leading Russian universities</a></li>
<li><a href="../243579/index.html">Eskimo - Node.js boilerplate to create prototypes</a></li>
<li><a href="../243581/index.html">Literal operator templates for strings</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>