<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Comparing D and C ++ and Rust with examples</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post is based on Rust and C ++ Comparison on examples and complements the examples given there with D code with a description of the differences....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Comparing D and C ++ and Rust with examples</h1><div class="post__text post__text-html js-mediator-article">  This post is based on <a href="http://habrahabr.ru/post/225003/">Rust and C ++ Comparison on examples</a> and complements the examples given there with D code with a description of the differences. <br><br>  All examples were compiled using the DMD v2.065 x86_64 compiler. <br><a name="habracut"></a><br><h4>  Check Template Types </h4><br><br><blockquote>  Templates in Rust are checked for correctness prior to their instantiation, so there is a clear separation between errors in the template itself (which should not be if you use someone else's / library template) and in the place of instantiation, where all that is required of you is to meet the requirements for type described in the template: <br><pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sortable</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort</span></span></span></span>&lt;T: Sortable&gt;(array: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [T]) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { sort(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]); }</code> </pre> <br></blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In D, a different approach is used: guard can be hung on the templates, functions, structures, which will not allow the function to be included in the overload set if the template parameter does not have a specific property. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.traits; <span class="hljs-comment"><span class="hljs-comment">// auto sort(T)(T[] array) {} -   guard  auto sort(T)(T[] array) if(isFloatingPoint!T) {} void main() { sort([1,2,3]); }</span></span></code> </pre><br><br>  The compiler will complain as follows: <br><blockquote>  source / main.d (27): Error: template main.sort cannot deduce function from argument types! () (int []), candidates are: <br>  source / main.d (23): main.sort (T) (T [] array) if (isFloatingPoint! T) <br></blockquote><br><br>  However, you can get almost identical ‚Äúresolving‚Äù behavior of Rust as follows: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sortable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,   ,    swap    enum Sortable = __traits(compiles, swap(T.init, T.init)); //       static assert(Sortable, "Sortable isn't implemented for "~T.stringof~". swap function isn't defined."); } auto sort(T)(T[] array) if(Sortable!T) {} void main() { sort([1,2,3]); }</span></span></code> </pre><br>  Compiler output: <br><blockquote>  source / main.d (41): Error: static assert ‚ÄúSortable is not implemented for int.  swap function not defined. " <br>  source / main.d (44): instantiated from here: Sortable! int <br>  source / main.d (48): instantiated from here: sort! () <br></blockquote><br><br>  The ability to display your error messages makes it possible in almost all cases to avoid the kilometer-long logs of the compiler about problems with templates, but the price of such freedom is high - you have to think over the limits of applicability of your templates and write clear (!) Messages with your hands.  Given that the template parameter T can be: type, lambda, another template (template template, etc., it allows you to simulate depended types), expression, list of expressions - often only a certain subset of <s>perverse user fantasies of</s> errors is processed. <br><br><h4>  Access to remote memory </h4><br>  In D, the default is <a href="http://dlang.org/garbage.html">GC</a> , which itself performs reference counting and deletes unnecessary objects.  Also in D there is a separation - the release of the object's resources and the removal of the object.  In the first case, use <a href="http://dlang.org/phobos/object.html">destroy ()</a> , in the second <a href="http://dlang.org/phobos/core_memory.html">GC.free</a> .  You can allocate memory managed by GC - <a href="http://dlang.org/phobos/core_memory.html">GC.malloc</a> .  Then the program itself will free up memory during GC startup, if a piece of memory is unreachable through links / pointers. <br><br>  It is also possible to allocate memory through the C-shny malloc family of functions: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.c.stdlib; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = cast(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       scope scope(exit) free(x); //       free(x); *x = 0; }</span></span></code> </pre><br><blockquote>  *** Error in `demo ': double free or corruption (fasttop): 0x0000000001b02650 *** </blockquote><br><br>  D allows you to program at different levels, up to the inline assembler.  We refuse GC - we take responsibility for the class of errors: leaks, access to remote memory.  The use of RAII (scope of expression in the example) can significantly reduce the headache with this approach. <br><br>  In the recently published book <a href="http://www.packtpub.com/discover-advantages-of-programming-in-d-cookbook/book">D Cookbook</a> there are chapters devoted to the development of custom arrays with manual memory management and writing a kernel module on D (without GC and without runtime).  The standard library does become practically useless with the complete abandonment of runtime and GC, but it was originally designed for using their features.  The place of the embedded-style library is still not occupied by anyone. <br><br><h4>  Lost pointer to local variable </h4><br><blockquote>  Rust version: <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> </pre><br></blockquote><br><br>  Analog on D (almost repeats the example in C ++ from a source post): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); writeln(*p1, <span class="hljs-string"><span class="hljs-string">","</span></span>, *p2); }</code> </pre><br>  Conclusion: <br><blockquote>  2.2 </blockquote><br><br>  Rust in this example has an advantage, I do not know of any such language in which such a powerful analyzer of the lifetime of variables was embedded.  The only thing I can say in defense D is that in safe mode the compiler does not compile the previous code: <br><blockquote>  Error: cannot be taken function safe </blockquote><br><br>  Also in 90% of the code, the D pointers are not used (low level - high responsibility), for most cases ref is suitable: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio; <span class="hljs-function"><span class="hljs-function">ref </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-function">ref </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(n); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); writeln(p1, <span class="hljs-string"><span class="hljs-string">","</span></span>, p2); }</code> </pre><br>  Conclusion: <blockquote>  1.2 </blockquote><br><br><h4>  Uninitialized variables </h4><br><blockquote>  C ++ <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</span></span></span></span></code> </pre><br></blockquote><br><br>  In D, all default values ‚Äã‚Äãare initialized with T.init, but it is possible to indicate to the compiler that, in a particular case, initialization is not required: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] A)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currmin = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-comment"><span class="hljs-comment">// undefined behavior foreach(a; A) if (a &lt; currmin) currmin = a; return currmin; } void main() { auto A = [1,2,3]; int min = minval(A); writeln(min); }</span></span></code> </pre><br><br>  A positive point: to shoot in the foot you need to <b>specifically</b> want this.  Accidentally uninitializing a variable in D is almost impossible (maybe using the copy-paste method). <br><br><blockquote>  A more idiomatic (and working) version of this function would look like this: <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> </pre><br></blockquote><br><br>  For comparison, the variant on D: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] A)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> A.reduce!<span class="hljs-string"><span class="hljs-string">"a &lt; b ? a : b"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  //return A.reduce!((a,b) =&gt; a &lt; b ? a : b); }</span></span></code> </pre><br><br><h4>  Implicit copy constructor </h4><br><blockquote>  C ++ <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *x; A(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v): x(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(v)) {} ~A() {<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> x;} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">A </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, b</span></span>=a; }</code> </pre><br></blockquote><br><br>  Similar version on D: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v) { x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>; *x = v; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = A(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> b = a; *bx = <span class="hljs-number"><span class="hljs-number">5</span></span>; assert(*ax == <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// fails }</span></span></code> </pre><br><br>  In D, structures support only copying semantics, and also do not have an inheritance mechanism (replaced by impurities), virtual functions, and other features of objects.  The structure is just a piece of memory, the compiler does not add anything extra.  For the correct implementation of the example, you need to define a postblit constructor (almost a copy constructor): <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-comment"><span class="hljs-comment">//        this { //        auto newx = new int; *newx = *x; x = newx; }</span></span></code> </pre><br><br>  There is a clear separation: if the object needs copying semantics ‚Äî like simple types of type int ‚Äî structures are used.  If passing by reference, then classes are used.  In the <a href="http://www.amazon.com/D-Programming-Language-Andrei-Alexandrescu/dp/0321635361">book Alexandrescu</a> (there is a <a href="http://www.books.ru/books/yazyk-programmirovaniya-d-827252/">translation</a> ) all these points are covered. <br><br><blockquote>  Rust will not do anything behind your back.  Want an automatic implementation of Eq or Clone?  Simply add the deriving property to your structure: <br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; }</code> </pre><br></blockquote><br>  There is no analog of this mechanism in D.  For structures, all such operations are overloaded via <a href="http://en.wikipedia.org/wiki/Structural_type_system">structual typing</a> (often confused with duck typing), if the structure has a suitable method, then it is used, if not, the default implementation. <br><br><h4>  Overlapping memory </h4><br><blockquote><pre> <code class="rust hljs">#include &lt;stdio.h&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span></span> { int a, b; }; void swap_from(X&amp; x, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp; y) { xa = yb; xb = ya; } int main() { X x = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}; swap_from(x,x); printf(<span class="hljs-string"><span class="hljs-string">"%d,%d\n"</span></span>, xa, xb); }</code> </pre><br><br>  Gives us: <br><blockquote>  2.2 </blockquote><br></blockquote><br><br>  Similar D code that also does not work: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap_from</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref X x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ref X y)</span></span></span><span class="hljs-function"> </span></span>{ xa = yb; xb = ya; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = X(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); swap_from(x, x); writeln(xa, <span class="hljs-string"><span class="hljs-string">","</span></span>, xb); }</code> </pre><br><br>  Rust in this case definitely wins.  I did not find a way to detect memory overlapping at compile time on D. <br><br><h4>  Spoiled iterator </h4><br>  In D, the iterator abstraction is replaced by <a href="http://ddili.org/ders/d.en/ranges.html">Ranges</a> , we try to change the container during the passage: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] v; v ~= <span class="hljs-number"><span class="hljs-number">1</span></span>; v ~= <span class="hljs-number"><span class="hljs-number">2</span></span>; foreach(val; v) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(val &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { v ~= <span class="hljs-number"><span class="hljs-number">5</span></span> - val; } } writeln(v); }</code> </pre><br>  Conclusion: <br><blockquote>  [1, 2, 4, 3] </blockquote><br><br>  If you change the range array, the previously received does not change, until the end of the foreach block, this range will point to the data of the ‚Äúold‚Äù array.  You may notice that all changes occur in the tail of the array, you can complicate the example and add to the beginning and to the end at the same time: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ DList!<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v; v.insert(<span class="hljs-number"><span class="hljs-number">1</span></span>); v.insert(<span class="hljs-number"><span class="hljs-number">2</span></span>); foreach(val; v[]) <span class="hljs-comment"><span class="hljs-comment">//  []  range { if(val &lt; 5) { v.insertFront(5 - val); v.insertBack(5 - val); } } writeln(v[]); }</span></span></code> </pre><br>  Conclusion: <br><blockquote>  [3, 4, 1, 2, 4, 3] </blockquote><br><br>  In this case, a doubly linked list from the standard library was used.  When using an array, adding to its beginning always leads to its re-creation, but it does not break the algorithm, the old range indicates the old array, and we work with new copies of the array, and thanks to GC we can not worry about stubs in memory.  And in the case of the list, it is not necessary to re-allocate the entire memory, only for new items. <br><br><h4>  Dangerous Switch </h4><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></span></span></code> </pre><br>  Gives us a "2".  In Rust zhy you are obliged to list all the options when comparing with the sample.  In addition, the code does not automatically jump to the next option unless it encounters a break. <br></blockquote><br><br>  In D, the switch may have the final keyword; the compiler will force you to write all the matching variants.  In the absence of a final, a default block is required.  Also in recent versions of the compiler, the implicit ‚Äúfailing‚Äù to the next label is marked as deprecated, an explicit goto case is required.  Example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Color {RED, BLUE, GRAY, UNKNOWN} Color color = Color.GRAY; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-function"><span class="hljs-function">final </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">switch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(color)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Color.GRAY: x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Color.RED: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Color.BLUE: x = <span class="hljs-number"><span class="hljs-number">2</span></span>; } writeln(x); }</code> </pre><br>  Compiler output: <br><blockquote>  source / main.d (227): Error: enum member UNKNOWN is not represented in final switch <br>  source / main.d (229): Warning: switch case fallthrough - use 'goto case;'  if intended <br>  source / main.d (229): Warning: switch case fallthrough - use 'goto case;'  if intended </blockquote><br><br><h4>  Random semicolon </h4><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pixels = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>; j++); pixels++; }</code> </pre><br><br>  In Rust, you must enclose the bodies of cycles and comparisons in braces.  A trifle, of course, but less a class error. <br></blockquote><br><br>  In D, the compiler will issue a warning (by default, warnings are errors) and suggest replacing;  on {}. <br><br><h4>  Multithreading </h4><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></span></span></code> </pre><br><br>  It spawns several resources instead of one: <br>  done <br><blockquote>  resource: 0x7f229c0008c0 <br>  resource: 0x7f22840008c0 <br>  resource: 0x7f228c0008c0 <br>  resource: 0x7f22940008c0 <br>  resource: 0x7f227c0008c0 <br></blockquote><br></blockquote><br><br>  In D, similarly to Rust, the compiler checks access to shared resources.  By default, all memory is indivisible, each thread works with its own copy of the environment (which is stored in <a href="http://en.wikipedia.org/wiki/Thread-local_storage">TLS</a> ), and all shared resources are marked with the keyword shared.  Let's try to write on D: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.concurrency; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resource</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* value; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acquire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!value) { value = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(shared Resource res)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Error: non-shared method main.Resource.acquire is not callable using a shared object writeln("resource ", res.acquire); } void main() { auto res = new shared Resource(); foreach(i; 0..5) { spawn(&amp;foo, res); } writeln("done"); }</span></span></code> </pre><br><br>  The compiler did not see explicit synchronization and did not allow compiling code with potential race condition.  In D, there are many synchronization primitives, but for simplicity, consider a Java-like monitor mutex for objects: <br><pre> <code class="cpp hljs">synchronized <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resource</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* value; shared(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*) acquire() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!value) { value = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } }</code> </pre><br><br>  Conclusion: <br><blockquote>  done <br>  resource 7FDED3805FF0 <br>  resource 7FDED3805FF0 <br>  resource 7FDED3805FF0 <br>  resource 7FDED3805FF0 <br>  resource 7FDED3805FF0 </blockquote><br><br>  Each time you call acquire, the object's monitor is captured by the stream and all other threads are blocked until the resource is released.  Pay attention to the return type of the acquire function, in D such modifiers as shared, const, immutable are transitive, if they mark a reference to a class, then all fields and returned pointers to fields are also marked with a modifier. <br><br><h4>  A bit about insecure code </h4><br>  Unlike Rust, all code in D by default is @ system, i.e.  unsafe.  The code marked @ safe restricts the programmer and does not allow to play with pointers, assembler inserts, unsafe type conversions and other dangerous features.  To use unsafe code, the @ trusted modifier in the safe code is key places that must be carefully covered with tests. <br><br>  Comparing with Rust, I very much wish such a powerful system for analyzing the lifetime of references for D. The ‚Äúcultural‚Äù exchange between these languages ‚Äã‚Äãwill only benefit them. <br><br>  Thanks to <a href="http://habrahabr.ru/users/reklatsmasters/" class="user_link">ReklatsMasters</a> for additional material on GC and structures. </div><p>Source: <a href="https://habr.com/ru/post/225507/">https://habr.com/ru/post/225507/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../225493/index.html">Phyode W / Me: sports bracelet with "health indicator"</a></li>
<li><a href="../225495/index.html">DevCon 2014: how it was (+ a lot of photos)</a></li>
<li><a href="../225499/index.html">Writing and processing music with Haskell</a></li>
<li><a href="../225501/index.html">Finally, full version control for designers!</a></li>
<li><a href="../225503/index.html">The use of two-factor authentication when connecting to 1C</a></li>
<li><a href="../225509/index.html">Know-how of the new Real Estate app for Android</a></li>
<li><a href="../225513/index.html">Own Node.js hosting on VPS</a></li>
<li><a href="../225515/index.html">Witty method of making elastic conductors with a sewing machine</a></li>
<li><a href="../225517/index.html">Creating a game on the engine Sprite Kit (Part 1)</a></li>
<li><a href="../225519/index.html">Installing Alfresco Community 4.2.f on a dedicated virtual server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>