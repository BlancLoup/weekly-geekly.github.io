<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fast, economical, steady ...</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you need an array sorting algorithm that: 


- Would work guaranteed for O (N * log (N)) operations (exchanges and comparisons); 
- Would require O...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fast, economical, steady ...</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/831/352/189/83135218915cfd683513e80636d7c999.png" align="right"><br>  If you need an array sorting algorithm that: <br><ul><li>  Would work guaranteed for O (N * log (N)) operations (exchanges and comparisons); </li><li>  Would require O (1) additional memory; </li><li>  Would be stable (that is, did not change the order of elements with the same keys) </li></ul><br>  then you will most likely be offered to limit to any two of these three points.  And, depending on your choice, you will receive, for example, either <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D1%2581%25D0%25BB%25D0%25B8%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5%25D0%25BC">merge sorting</a> (requires O (N) additional memory), or <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B8%25D1%2580%25D0%25B0%25D0%25BC%25D0%25B8%25D0%25B4%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0">pyramidal sorting</a> (unstable), or <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D0%25BF%25D1%2583%25D0%25B7%25D1%258B%25D1%2580%25D1%258C%25D0%25BA%25D0%25BE%25D0%25BC">bubble sorting</a> (works for O (N <sup>2</sup> )).  If you weaken the memory requirement to O (log (N)) (‚Äúfor recursion‚Äù), then you will find an <a href="http://thomas.baudel.name/Visualisation/VisuTri/inplacestablesort.html">algorithm with complexity O (N * (log (N) <sup>2</sup> )</a> - rather unknown, although it is its version that is used in the implementation method std :: stable_sort (). <br><br>  When asked whether it is possible to achieve the fulfillment of all three conditions at the same time, the majority will say ‚Äúhardly‚Äù.  Wikipedia does not know about such algorithms.  There are rumors among programmers that there seems to be something like that.  Some say that there is a ‚Äústable fast sorting‚Äù - but for the implementation I saw, the complexity was still the same O (N * (log (N) <sup>2</sup> ) (by timer). And only in one discussion on StackOverflow they gave a link article <a href="http://comjnl.oxfordjournals.org/content/35/6/643.full.pdf">BC. Huang and MA Langston, <i>Fast Stable Merging and Sorting in Constant Extra Space</i> (1989-1992)</a> , which describes an algorithm with all three properties. <br><br><a name="habracut"></a><br>  The authors say that their algorithm is not the first, and refer to the work of <a href="">L. Trabb Pardo, <i>Stable sorting and merging with</i> 1974</a> .  This is about 80 pages of scanned text, and I did not try to understand it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will immediately say for those who try to understand the article by Huang and Langston that I failed to implement the algorithm in the form in which it is described there.  The technique that they use in clause 4.3 does not work, because the statement <i>" right "</i> is not always true.  Fortunately, in some later works we managed to find a way to get around this trouble, and now I can say that an algorithm that satisfies all three conditions really exists. <br><br>  So, let's begin... <br><br><h2>  Basic operations </h2><br>  To work with an array, we need functions: <br><ul><li>  <i>SWAP1 (A, B)</i> - swap two elements.  The difficulty is 1. </li><li>  <i>SWAPN (A, B, K)</i> - swap K pairs of elements of arrays A and B. Difficulty is K. </li><li>  <i>ROTATE (A, K, L)</i> - rearrange two consecutive fragments of array A, the length of the first is K, the length of the second is L. The complexity does not exceed K + L. </li><li>  <i>BinSearchLeft (X, A, L)</i> - find the leftmost place to insert an element X into an ordered array A of length L. Valid result values ‚Äã‚Äãare from 0 to L. The complexity is log (L). </li><li>  <i>BinSearchRight (X, A, L)</i> - find the rightmost place for inserting an element X into an ordered array A of length L. Valid result values ‚Äã‚Äãare from 0 to L. The complexity is log (L). </li></ul><br><br><h2>  We are looking for a clipboard. </h2><br><br>  First, some terminology. <br>  About the elements for which the comparison function gave the result that they are equal, we will say that "they have the same keys," although physically no keys may exist.  Accordingly, it is possible to determine the number of different keys in the array and the elements with different keys. <br><br>  Two array states will be called equivalent if the elements with the same keys in them are in the same order.  The main problem of stable in-place sortings is not to lose this equivalence, or always be able to restore it. <br><br>  Let the length of the array be N. If N &lt;16, then we will not sort such an array, but call the insertion sort instead, this will not affect the overall asymptotics. <br><br>  Choose a number S equal to the power of two, close to sqrt (N).  Define K = [N / S].  And we will try to find pairs of different keys in the K + S array. <br><br>  The first idea is that if we take for each key the leftmost element of the array with this key, and collect all such elements at the beginning of the array (preserving the order of the other elements), the equivalence will not be broken, but this will give us the space in which we we can freely rearrange and compare with each other elements. <br><br>  During the search, we will keep the found keys in a continuous fragment of the array, and move it forward as new keys are found: going through the array elements, we will search the binary search for them in a fragment of the found keys, and if we haven‚Äôt found it, we will adjust the array with the keys to the found element, and for the second - put a new element in the right place in this fragment. <br><br>  Keys are collected in ascending order, which saves time by checking whether we already have an element with the same key as the current element.  The number of movements of a fragment with keys is not greater than the number of found keys, so the complexity of this stage is, in the worst case, N * log (NKeys) comparisons and 2 * N + NKeys <sup>2</sup> exchanges.  Since NKeys we have about 2 * sqrt (N), so far we have not gone abroad. <br><br>  Now we have two options.  Either we found the ordered K + S keys, or did not find them.  These cases are handled slightly differently.  In addition, there is a case when the number of different keys is less than 4 - it also has its own processing. <br><br><h2>  Case A. There are many different keys. </h2><br>  We have K + S different keys collected at the beginning of the array.  We will declare the first K of them "keys for marking fragments" and for now we will not touch them.  The remaining S will be the buffer for the merge.  All remaining elements of the original array are ‚Äúdata‚Äù, now they are at the end of the array. <br><br><h3>  A.1.  Stage of classical merge sorting. </h3><br>  Let's write two more functions.  One will be called MergeLeft, the other MergeRight.  They are fed to the input fragments of arrays, consisting of three parts.  In the case of MergeLeft, this is a buffer of length P, a sorted fragment of length Q and a sorted fragment of length R, where S‚â•R.  The function should merge the second and third fragments, put the result at the beginning, and the buffer elements in arbitrary order at the end of the fragment.  The MergeRight function works as a mirror ‚Äî it has two sorted fragments at the input, followed by a buffer, and the output, on the contrary, a buffer, and a sorted fragment after it.  It looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/429/674/d81/429674d8180b08e359622427f988a5fa.png"><br>  The complexity of both functions does not exceed Q + R - both by comparison and exchanges. <br>  Using the MergeLeft function, we can sort the data first by pairs, then by fours, ... up to fragments of length S (recall that S is a power of two).  Every time when sorting M elements we use a piece of buffer of length M / 2, which as a result leaves for the right side of the array.  At the pair sorting stage, we will use a piece of the buffer of length 2, so that by the time the sorted pieces are S, the data array will be pressed to the left, and S buffer elements will be on the right.  Now we can use MergeRight, sort the fragments of length 2 * S, and at the same time, return the buffer to the beginning. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4af/a39/4ec/4afa394ec92e343f9088e4d3b9f85a99.png"><br><br><h3>  A.2.  Stage block sorting. </h3><br>  Now we have sorted fragments of length G = 2 * S.  We will merge them in pairs, then again in pairs, etc., until we reach the size of the entire data array.  For this we have a buffer of length S and an array with keys of length K, where K ‚â§ L / S (L is the total length of the data array). <br>  So, the cycle ‚Äúfor now G ‚â§ L‚Äù. <br><br>  We want to merge two consecutive fragments of length G, and immediately before them is a buffer of length S (G and S are powers of two).  We divide our fragments into blocks of length S. Let them be K <sub>1</sub> .  The second fragment at the very end of the array could have a length less than G, and after dividing it may remain an incomplete block, we also consider it (although we will not move).  Take the first K <sub>1</sub> keys (they lie at the beginning of the original array), sort them (for example, inserts) and remember the key index with the number G / S (now it is equal to G / S, but then it will change) - let's call it midkey.  Each key has its own block.  We use them, firstly, to distinguish between the first and second merged fragments, and secondly, to maintain the order of blocks with the same elements.  Because now we will mix them as horrible. <br><br>  We sort the blocks.  The order will be determined by the first elements, and if they are equal, then the keys corresponding to these blocks.  The only sort we can use here is sorting by choosing the minimum element, since it requires no more than K <sub>1</sub> exchange (and K <sub>1</sub> 2/2 comparisons): exchanging two blocks is an expensive procedure, but since S is approximately sqrt (N) then the whole sorting stage fits into O (N) operations.  When we swap two blocks, we swap the corresponding keys, not forgetting to keep track of the midkey key.  Incomplete block (if any) with this sorting we do not touch! <br><br>  Blocks that previously belonged to the first fragment will be denoted by the letter A, and blocks that belonged to the second one - by the letter B. In our sorting, the order of the blocks corresponding to each fragment, <br>  preserved. <br><br>  An incomplete block always belongs to fragment B. We will look at the blocks in front of him to find out which block should be inserted before.  It is possible that you will have to insert it at the very beginning, or leave it in place - in the algorithm you need to pay special attention to these cases.  At the next stage, we will not touch the blocks that should be moved (all of them from fragment A). <br><br>  Now we start to merge the blocks.  The situation at each moment we will have this: <br><ul><li>  First, there is a number of complete merged blocks, about which it is known that we no longer touch them. </li><li>  Then a few (T, possibly, T = 0) elements of the next block, which are also already in place. </li><li>  Then S buffer elements </li><li>  Then ST elements, the place for which is not yet defined.  They all belong to the same fragment - A or B, and we know which one. </li><li>  Next are the raw blocks, the type of which we can determine by comparing the corresponding key with the midkey. </li></ul><br>  It looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/2cf/051/349/2cf05134962e75eae8f12cb3a61a4b59.png"><br>  Here A // B is the sorted section, A1 is the underprocessed block, A2, A3, B2 are unprocessed blocks, B3 is an incomplete block at the end (perhaps its real place is before A2 or A3). <br>  In the beginning, we have no merged blocks, T = 0, and the type of ST elements following the buffer is determined by the first key. <br><br>  To process the next block, we have to write another function SmartMergeLeft (and it is not the last!).  At the input, it, like MergeLeft, serves a buffer and two fragments, and the order of these fragments may be incorrect (then when merging it will be necessary in the case of equal elements to take an element from the second fragment).  The function should rearrange elements to the beginning only as long as both fragments are non-empty.  As soon as one of them ends, it must transfer the remaining elements of the other fragment to the end (if the second fragment ended earlier), report their number, and then in what fragment they were. <br>  Like that: <br><img src="https://habrastorage.org/getpro/habr/post_images/e13/075/f27/e13075f27267f1ac8a721502337469b4.png"><br>  In the first case, elements from B first ran out, and at the end there were the last elements from A, and in the second - the opposite. <br>  Using this function, we can easily move up one block.  If the type of the next block is the same as the last unprocessed elements, we change them with the buffer, and say that T = 0, and the new block is raw (the situation is the same as at the beginning).  If the types are different, we call SmartMergeLeft, and she does everything herself - the elements that will remain at the end of the block will be unprocessed. <br><br>  So, turning over the blocks, we will reach either the end, or to the place where there should be an incomplete block from the end of fragment B. Here we have several options. <br><br>  Either the last remaining unprocessed elements are from fragment B. Then the last of these elements is smaller than the first element from the next block A (if there is one), and we can safely exchange the raw elements with the buffer. <br><br>  Either these elements are from fragment A. Then we simply virtually paste them onto the blocks following them (again, if they exist). <br>  In both cases, we get the same situation - the buffer, followed by elements from fragment A, then no more than S elements from fragment B. Ready situation for the MergeLeft function.  Call it - and the fragments are merged, and the buffer was after them. <br><br>  We go through this procedure for all pairs of fragments of length G, until we reach the end of the data array.  Then we shift all the data to the right by S elements (returning the buffer to the beginning), and double the value of S. <br>  The end of the cycle. <br><br><h3>  A.3.  Completion. </h3><br>  We have a sorted array of data, before which the keys found at the beginning randomly go.  Sort them (again with inserts), and we will only have to merge two sorted fragments without using an additional buffer.  This time we will be saved by the fact that one of them is very short. <br><br>  The function MergeWithoutBuffer receives two sorted fragments of length P and Q as input. Suppose that P &lt;Q.  As long as the first element of the first fragment is not larger than the first element of the second fragment, we will decrease P by 1, shifting the beginning of the fragment to the right.  If P reaches zero - we won.  Otherwise, we will find with the help of BinSearchLeft the correct position k of the first element in the second fragment, and with the help of ROTATE we will change the first fragment and the first k elements of the second fragment.  Reduce Q by k, shift the beginning of the fragments.  If Q has reached zero, the function is executed, otherwise we repeat it from the beginning.  The complexity of this function is P ^ 2 + Q.  If initially P‚â•Q, then we do the same, but in a mirror order. <br><br>  To complete the sorting call MergeWithoutBuffer (Arr, K + S, NKS).  All is ready. <br><br><h2>  Case B. There are few different keys, but more than three. </h2><br><br>  In this situation, we do not have space for the buffer and the keys at the same time, we will use them in turn.  Let various keys be all M. We denote by K the maximal power of two that does not exceed M, and leave K keys to us (they are at the beginning of the array), let the rest go to the data. <br><br><h3>  B.1.  Stage of classical merge sorting. </h3><br>  This stage does not differ from A.1, but instead of a buffer of length S, we will use an array of keys of length K (this is a power of two).  Walking along the array forward and backward, we get sorted fragments of length G = 2 * K. <br><br><br><h3>  B.2.  Stage block sorting. </h3><br>  Suppose that fragments of length G are already merged with us, and we want to unite them in pairs.  Since we have no buffer, we can choose the block size ourselves.  The number of keys for marking blocks in our company does not exceed K. Take K <sub>1</sub> = min (K, K <sub>2</sub> ), where K <sub>2</sub> is a power of two, closest to (2 * G * M) <sup>1/3</sup> (recall that M is the number of different keys in the array).  The block size will be S = 2 * G / K <sub>1</sub> . <br><br>  We sort the keys and blocks as in A.2.  This buffer is not needed. <br>  Now we need to go through the array and merge the blocks.  Let's write the SmartMergeWithoutBuffer function, which is a hybrid of MergeWithoutBuffer and SmartMergeLeft.  It assumes that the first fragment is shorter than the second.  It works in the same way as MergeWithoutBuffer, but it takes into account that the order of the fragments could be incorrect, but also reports how many elements and from which fragment remained at the end of the array.  Calling this function instead of SmartMergeLeft, and the function MergeWithoutBuffer - instead of MergeLeft at the end, we get merged fragments. <br><br>  It would seem that here we lost - the maximum block length in the worst case (K = 4, G = N / 2) is N / 4, which means that the SmartMergeWithoutBuffer function may require O (N ^ 2) operations.  But we are saved by the fact that the number of different keys in the array is small - and it can be shown that the complexity of SmartMergeWithoutBuffer does not exceed P * m + Q, where m is the number of different keys in the first fragment.  And since the sum of the number of different keys across all K / 2 blocks of a fragment of length G (take a deep breath and reread - I can‚Äôt make it easier) does not exceed K / 2 + M, no more than O (G) will be spent on merging two fragments of length G operations. <br><br><h3>  B.3.  Completion. </h3><br>  This step is not different from A.3. <br><br><h2>  Case C. There are no more than three different keys. </h2><br><br>  Here we write the usual merge sort (without recursion, we sort by 2, then by 4 elements, etc.), and to merge the fragments we use MergeWithBuffers.  Since there are few different keys in the array, its complexity will be linear with the length of the merged fragments, which means that the total complexity is O (N * log (N)). <br><br><h2>  Implementation and conclusions. </h2><br>  The implementation turned out to be cumbersome - <a href="">almost 400 lines in C ++</a> (in fact, it is written in C - you just need to transfer the variable descriptions to the beginning of the functions).  The speed of work varies greatly for cases A and B. The worst situation is when there are a lot of different keys, but a little bit less than necessary to go to case A - in this situation the algorithm runs slower than in case A, about 3 times.  However, the estimated complexity of N * log (N) is preserved. <br><br>  On large arrays (from about 10 million), the algorithm almost always (except for the cases of a very small number of different keys) beats InPlaceStableSort (the one that is behind O (N * log (N) <sup>2</sup> )).  But it cannot with std :: stable_sort: there is always a little memory, and in this case, std :: stable_sort quickly switches to the usual MergeSort, and easily and naturally overtakes everyone, including quicksort :).  So the implemented algorithm has only theoretical value. <br><br>  But still, it exists :) <br><br>  PS The first picture is a slide from <a href="http://www.cs.princeton.edu/courses/archive/spr10/cos226/lectures/COS226firstHalf.pdf">the lecture course R.Sedgewick, <i>Algorithms and Data Structures</i> , Princeton University, Spring 2010</a> <br><br><br>  UPDATE: Phase B2 can be greatly accelerated.  As long as the number G is sufficiently small, it may happen that (K / 2) ^ 2&gt; = 2 * G.  In this case, we can divide the set of keys in half, and use half as a clipboard (and the other half as keys), and merge fragments using the faster method from A2.  And go to exchanges without a buffer at the very end, when G approaches the size of the array. <br>  The more keys we have, the longer the merge without a buffer works, but the longer we can do without it. <br>  Experiments show that in the worst case, the algorithm requires no more than 1.61 * N * log <sub>2</sub> N comparisons and 2.12 * N * log <sub>2</sub> N exchanges (with N‚â§1000000, on random data with a predetermined number of different keys). </div><p>Source: <a href="https://habr.com/ru/post/205290/">https://habr.com/ru/post/205290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../205268/index.html">Go GUI Notepad</a></li>
<li><a href="../205274/index.html">Simple masking of the Linux kernel module using DKOM</a></li>
<li><a href="../205280/index.html">Access Control System on Wiren Board</a></li>
<li><a href="../205284/index.html">UK e-government fix using Go language</a></li>
<li><a href="../205286/index.html">The digest of interesting news and materials from the world of PHP No. 31 (November 25 - December 8, 2013)</a></li>
<li><a href="../205294/index.html">Designer - project manager. Reality or Utopia?</a></li>
<li><a href="../205296/index.html">Today is a holiday for the guys</a></li>
<li><a href="../205298/index.html">Zoiper saves our passwords from SIP on their servers - and lost this base?</a></li>
<li><a href="../205300/index.html">The impact of the organization of the software development process on the quality of programs and on personal productivity in the Individual development process</a></li>
<li><a href="../205308/index.html">Continuous Integration for Android using Jenkins + Gradle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>