<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>All you need to know about detecting changes in Angular</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I stumbled upon a good article about the device Angular change detection mechanism. Since The topic is important enough, but it is not even deeply dis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>All you need to know about detecting changes in Angular</h1><div class="post__text post__text-html js-mediator-article">  I stumbled upon a good article about the device Angular change detection mechanism.  Since  The topic is important enough, but it is not even deeply disclosed on English-language resources, and it‚Äôs not possible to find Russian-language materials on this topic in general, I decided to translate this article. <br><a name="habracut"></a><br><h2>  A study of the underlying implementations and examples </h2><br>  If, like me, you want to fully understand the mechanism for detecting changes in Angular, you need to investigate the source code, since there is not enough information on the Internet about it.  Most of the articles mention that each component has its own change detector, which is responsible for checking components, but, in fact, this is limited by focusing on immunity and change detection strategies.  This article provides you with information that is sufficient to understand <i>why</i> application examples with immunity work and <i>how</i> a change detection strategy affects validation.  Also, the information obtained from this article will allow you to independently use various approaches in optimizing performance. <br><br>  The article is divided into two parts.  The first part is sufficiently technical and contains many references to the source code.  She explains in detail how the mechanism for detecting changes "under the hood."  Its content is based on the latest version of Angular - 4.0.1.  The implementation of the mechanism for detecting changes in this version differs from the previous 2.4.1.  If interested, you can read a little how the previous implementation works in <a href="http://stackoverflow.com/a/42807309/2545680">this response to stackoverflow</a> . <br><br>  The second part shows how to use the detection of changes in applications and its contents is applicable for the previous 2.4.1 and for the latest 4.0.1 versions of Angular, since  The public API has not changed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <hr><br>  The guide to Angular constantly mentions that an application is, in fact, a tree of components.  However, under the hood Angular uses a low-level abstraction called <a href="">view</a> (hereinafter the view will be used without translation).  There is a direct 1: 1 relationship between the component and the view - one view is associated with one component, and vice versa.  The views contain a <a href="">link</a> to the related component in the component property.  All operations, such as checking properties and updating the DOM, perform a view, so it‚Äôs technically more true to treat Angular as a view tree, while a component can be described as a high-level view.  Here is a description of the view can be found in the <a href="">source code</a> : <br><blockquote>  View is the main building block for a UI application.  This is the minimum group of items that are created and deleted together. <br><br>  The properties of the View elements may change, but the structure (number and order) of these elements is not.  Changing the structure of elements can only be done by inserting, moving or deleting an nested View through the ViewContainerRef.  Any View can contain many view containers. </blockquote><br>  In this article I will use the concept of a component and its view interchangeably. <br><br>  There are two important things about view in the context of change detection.  The first is that each view contains references to child views in the <a href="">nodes</a> property and, thus, can perform actions on child views.  The second is that each view has a state (the <a href="">state</a> property), which plays a big role, because it is based on its value that Angular decides whether to start detecting changes for this view and all its children, or to skip.  There are four <a href="">possible states</a> : <br><br><ol><li>  FisrtCheck </li><li>  ChecksEnabled </li><li>  Errored </li><li>  Destroyed </li></ol><br>  Changes are not detected for the view and its descendants if the status attribute of ChecksEnabled is set to false or if the view is in the Errored or Destroyed state.  By default, all views are initialized with ChecksEnabled, unless the onPush ChangeDetectionStrategy.OnPush strategy is applied.  By this point we will be back a bit later.  States can be combined, for example, the view can have the FisrtCheck and ChecksEnabled flags set at the same time. <br><br>  Angular has a number of high-level concepts for view manipulation.  I described some of them in this <a href="https://hackernoon.com/exploring-angular-dom-abstractions-80b3ebcfc02">article</a> .  One of these abstract entities is <a href="">ViewRef</a> .  It isolates the view of the component and has a very well- <a href="">known</a> method called <a href="">detectChanges</a> .  When an asynchronous event occurs, Angular <a href="">triggers the detection of changes</a> on the top-level ViewRef, which, after running the detection of changes within themselves, <b>trigger the detection of changes in their descendants</b> . <br><br>  The main logic that is responsible for starting the detection of changes for the view is located in the <a href="">checkAndUpdateView</a> function.  Basically, its functionality performs actions on the child views of the component.  When it is called for a specific view, it performs the following operations in the specified order: <br><br><ol><li>  <a href="">updates incoming properties</a> on instances of child components </li><li>  <a href="">updates the change detection status</a> of child views (as part of the implementation of the change detection strategy) </li><li>  calls the OnChanges hook on the child components, in case the connection has changed </li><li>  causes OnInit and ngDoCheck hooks on child components </li><li>  <a href="">calls the</a> AfterContentInit, AfterContentChecked, AfterViewInit and AfterViewChecked hooks on instances of child components </li><li>  calls the OnDestroy hook if the child / parent component is deleted </li><li>  <a href="">updates the DOM</a> for the <b>current view</b> if the properties of the instance of the <b>current view</b> have been changed. </li><li>  <a href="">launches change detection</a> for child views </li><li>  <a href="">Cancels change checks</a> for the current view (if provided by the strategy used) </li><li>  <a href="">sets the</a> state of the FirstCheck flag to false </li></ol><br>  Based on the above list of operations, I would like to draw attention to some points. <br><br>  The first is that the onChanges hook is called on the child component before the child view is checked, it will be called even if the detection of changes in this child view is skipped.  This is very important, and then we will see how we can use this knowledge in the second part of the article. <br><br>  The second point, the DOM update for the view, is part of the change detection mechanism and happens during the checkout.  This means that if a component is not checked, its DOM will not be updated even if the properties of this component are used in the display template. <br><br>  Another interesting observation is that the view state of the child component can be changed during the detection of changes.  Earlier, I mentioned that all view components are initialized with the ChecksEnabled flag set by default, but for all components that use the OnPush strategy, change detection will be disabled after the first check (the 9th operation in the list): <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.def.flags &amp; ViewFlags.OnPush) { <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.state &amp;= ~ViewState.&lt;ChecksEnabled; }</code> </pre> <br>  This means that during the next launch of the change detection, the check will be skipped for the view of this component and its descendants.  Documentation tells us that the component will be checked only in case of changes in its connections (input-parameters) using the OnPush strategy.  Thus, to perform a check, you should set the ChecksEnabled flag, which we see in the following code (clause 2): <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compView.<span class="hljs-keyword"><span class="hljs-keyword">def</span></span>.flags &amp; <span class="hljs-type"><span class="hljs-type">ViewFlags</span></span>.<span class="hljs-type"><span class="hljs-type">OnPush</span></span>) { compView.state |= <span class="hljs-type"><span class="hljs-type">ViewState</span></span>.<span class="hljs-type"><span class="hljs-type">ChecksEnabled</span></span>; }</code> </pre><br>  The state is updated only if the connections (input parameters) of the parent view have been changed and the child component has been initialized with the ChangeDetectionStrategy.OnPush strategy. <br><br>  Well, ultimately, the detection of changes for the current view is responsible for starting the detection of changes in the child view (paragraph 8).  Here the state of the view component is checked and, if it is in the status of ChecksEnabled, then a change is detected for this view.  This displays the code below: <br><br><pre> <code class="hljs objectivec">viewState = view.state; ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ViewAction.CheckAndUpdate: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((viewState &amp; ViewState.ChecksEnabled) &amp;&amp; (viewState &amp; (ViewState.Errored | ViewState.Destroyed)) === <span class="hljs-number"><span class="hljs-number">0</span></span>) { checkAndUpdateView(view); } }</code> </pre><br>  Now we know that the view state determines whether changes will be detected on this view and its descendants, or not.  This begs the question - can we control this state?  It turns out that yes - we can, and this is what the second part of this article will be about. <br><br><hr><br>  Suppose we have the following component tree: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c05/263/ef3/c05263ef38a14e4ca1fa73fd78da721c.png"></div><br>  As we found out earlier, each component is associated with a view.  Each view is initialized with the ViewState.ChecksEnabled flag set, which determines that when you start the change detection Angular, each component will be checked. <br><br>  Suppose we want to cancel change detection for the AComponent component and its descendants.  This is easy to do ‚Äî we just need to set the value of false to the state attribute of ViewState.ChecksEnabled.  State change is a low-level action, so Angular provides a number of public methods that are available to us in view.  Each component can access its associated view through a ChangeDetectorRef.  For Angular provides the following public interface of this class: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ChangeDetectorRef</span></span> { markForCheck() : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detach</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reattach</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detectChanges</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkNoChanges</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> }</span></span></code> </pre><br>  Let's see how much benefit we can get from it. <br><br><h3>  detach </h3><br>  The first method that allows us to manipulate the state is detach, which simply cancels checks on the current view: <br><br><pre> <code class="hljs objectivec">detach(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._view.state &amp;= ~ViewState.ChecksEnabled; }</code> </pre><br>  detach can be applied in the code as follows: <br><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> cd: ChangeDetectorRef) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cd.detach(); }</code> </pre><br>  This will ensure that the left branch is skipped by the AComponent at the time of the subsequent detection of changes (components marked in orange will not be checked): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/517/3ca/f06/5173caf06f8b49e6a2c43412731ed818.png"></div><br>  Here you should pay attention to a couple of points - firstly, even if we change the state of only AComponent, all its descendants will also not be subject to checks.  Second, until the change detection is done for the left branch, the DOM will also not be updated.  A small example to demonstrate: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'a-comp'</span></span></span><span class="hljs-meta">, template: `&lt;span&gt;See if I change: {{changed}}&lt;/span&gt;` })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> cd: ChangeDetectorRef) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.changed = <span class="hljs-string"><span class="hljs-string">'false'</span></span>; setTimeout(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cd.detach(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.changed = <span class="hljs-string"><span class="hljs-string">'true'</span></span>; }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }</code> </pre><br>  During the first component check, the contents of the span will be displayed as See if I change: false.  After two seconds, when the changed property is set to true, the text in the span will not change.  However, if we delete the line this.cd.detach (), everything will start working as expected. <br><br><h3>  reattach </h3><br>  As mentioned in the first part of the article, the OnChanges hook is still called for AComponent, if the incoming property aProp is changed in the AppComponent component.  This means that when the input parameter has been changed, we can activate the detector of the current component to start the change detection and disable it for the next pass.  This is what is displayed in the following code: <br><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> inputAProp; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> cd: ChangeDetectorRef) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cd.detach(); } ngOnChanges(values) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cd.reattach(); setTimeout(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cd.detach(); }) }</code> </pre><br>  Since, reattach simply <a href="">sets</a> the ViewState.ChecksEnabled flag: <br><br><pre> <code class="hljs objectivec">reattach(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._view.state |= ViewState.ChecksEnabled; }</code> </pre><br>  this is completely identical to what happens when we set the OnPush value for a ChangeDetectionStrategy: cancel checks after the first start of detection of changes, turn on when the related property of the parent component has been changed, and turn off again after starting <br><br>  It is important to note that the OnChanges hook works only on the top-level component of a disabled branch, and not on all components of this branch. <br><br><h3>  markForCheck </h3><br>  The reattach method allows you to check only the current component, but if change detection is disabled on the parent component, it will not have any effect.  This means that the reattach method is only useful for top-level components of a disabled branch. <br><br>  We need a way to enable detection for all parent components, right up to the root component.  <a href="">The method to do this</a> is called markForCheck. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currView: ViewData|<span class="hljs-literal"><span class="hljs-literal">null</span></span> = view; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (currView) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currView.def.flags &amp; ViewFlags.OnPush) { currView.state |= ViewState.ChecksEnabled; } currView = currView.viewContainerParent || currView.parent; }</code> </pre><br>  Looking at the implementation, we see that it just iteratively goes up the tree and includes checks for change detection for each parent component, right up to the root component. <br><br><h3>  detectChanges </h3><br>  And can we <b>one-time</b> run the change detection for the current component and its descendants?  Yes, for this we just need to use <a href="">the</a> detectChanges <a href="">method</a> .  This method starts detecting changes for the view of the current component, regardless of its state, i.e.  the detection may remain disabled for the current view and the component will not be checked during subsequent regular launches of detection.  Here is a sample code: <br><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> inputAProp; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> cd: ChangeDetectorRef) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cd.detach(); } ngOnChanges(values) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cd.detectChanges(); }</code> </pre><br>  When input properties change, the DOM is updated, even if the change detector remains disabled. <br><br><h3>  checkNoChanges </h3><br>  This is the last method presented, which guarantees the absence of changes on the current launch of the detector.  In essence, it performs 1, 7, and 8 list items from the first part of this article and throws an exception if the links (incoming properties) have been changed, or there is a need to update the DOM. <br><br>  ‚Üí <a href="https://medium.com/hacker-daily/everything-you-need-to-know-about-change-detection-in-angular-8006c51d206f">Link to the original article</a> </div><p>Source: <a href="https://habr.com/ru/post/327004/">https://habr.com/ru/post/327004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326994/index.html">Guide for a novice project manager: drive a bike that burns</a></li>
<li><a href="../326996/index.html">Logical replication in PostgreSQL 10</a></li>
<li><a href="../326998/index.html">Extreme migration to PostgreSQL: without stopping, losing and testing</a></li>
<li><a href="../327000/index.html">... And Justice for All</a></li>
<li><a href="../327002/index.html">LinqToSolr - use LINQ to get data from Solr</a></li>
<li><a href="../327008/index.html">GeekUniversity is Russia's first online university with guaranteed employment.</a></li>
<li><a href="../327010/index.html">Analysis of the entrance exam ShAD-2015 and memories of the graduate of 2017</a></li>
<li><a href="../327012/index.html">We reach the level of expert! 50 shades of exam 1Z0-047 (Oracle Database SQL Certified Expert)</a></li>
<li><a href="../327014/index.html">How to automate order confirmation if you are not Yulmart (spoiler: just like Yulmart)</a></li>
<li><a href="../327016/index.html">DeclarativeCOS - Cach√© Declarative Programming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>