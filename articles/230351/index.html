<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple websocket chat on Dart</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 In this article, I want to describe the creation of a simple websocket chat on Dart in order to show how to work with websockets in Dart. Ap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple websocket chat on Dart</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  In this article, I want to describe the creation of a simple websocket chat on Dart in order to show how to work with websockets in Dart.  Application code is available on <a href="https://github.com/rudart/simple-chat">github</a> , and an example of its work can be found here: <a href="http://simplechat.rudart.in/">http://simplechat.rudart.in</a> . <br><br>  The application will consist of two parts: the server and the client.  We will analyze the server part in great detail, and from the client we will consider only what is responsible for working with the connection. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The requirements for the application are very simple - sending messages from the user to all or just to selected chat participants. <br><a name="habracut"></a><br><h2>  Application settings </h2><br>  All application settings and constants will be stored in the file <code>common/lib/common.dart</code> .  This file contains the definition of the library <code>simplechat.common</code> . <br><br><pre> <code class="javascript hljs">library simplechat.common; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> ADDRESS = <span class="hljs-string"><span class="hljs-string">'simplechat.rudart.in'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> int PORT = <span class="hljs-number"><span class="hljs-number">9224</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> SYSTEM_CLIENT = <span class="hljs-string"><span class="hljs-string">'Simple Chat'</span></span>;</code> </pre><br>  We will connect the file itself as a package, since  if we use relative paths, then when building the application ( <code>pub build</code> ) we can get an error from the <code>pub</code> : <strong>Exception: Can not read {build}</strong> . <br><br>  In order to connect the package, located somewhere on our machine, we will use the <a href="https://www.dartlang.org/tools/pub/dependencies.html">pub path dependency</a> .  To do this, we simply <code>pubspec.yaml</code> definition of our package to the <code>dependencies</code> section of the <code>pubspec.yaml</code> file: <br><br><pre> <code class="javascript hljs">dependencies: simplechat.common: path: ./common</code> </pre><br>  I will not give all the contents of the <code>pubspec.yaml</code> file (but you can look at it on <a href="https://github.com/rudart/simple-chat">github</a> ).  You will also need to add the <code>pubspec.yaml</code> file to the <code>common</code> directory in which you simply specify the name of our package: <br><br><pre> <code class="javascript hljs">name: simplechat.common</code> </pre> <br><h2>  Server </h2><br>  Server files are located in the <code>bin</code> folder.  The <code>main.dart</code> file <code>main.dart</code> the entry point to the server, and the <code>server.dart</code> file <code>server.dart</code> class of our server.  Let's start by looking at the contents of the <code>main.dart</code> file. <br><br><h3>  General scheme of the server </h3><br>  Let's talk about how our server will work.  The first thing we will do with the server is to launch it.  During startup, it will start listening to port <code>9224</code> . <br><br>  When a new user sends a request to this port, the server opens a websocket connection for it, generates a name and saves the name and connection in a hash with open connections.  After that, the client will be able to send messages via this connection.  The server will be able to send these messages to other users, as well as send notifications about the connection and disconnection of clients. <br><br>  If the user closes the connection, the server will remove it from the hash with active connections. <br><br><h3>  Server entry point </h3><br>  At the very beginning of the file <code>bin/main.dart</code> we will determine that this is the library <code>simplechat.bin</code> .  For the server to work, we will need to connect the <code>dart:async</code> libraries <code>dart:async</code> , <code>dart:convert</code> , <code>dart:io</code> , the <code>route</code> package (set via <code>pub</code> ) and the file with the application settings.  Also in <code>bin/main.dart</code> we include the file <code>bin/server.dart</code> , which contains the main code of our server (consider it a bit later). <br><br>  In the <code>main()</code> function, we create an instance of the server and start it. <br><br><pre> <code class="javascript hljs">library simplechat.bin; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'dart:async'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'dart:convert'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'dart:io'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:route/server.dart'</span></span> show Router; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:simplechat.common/common.dart'</span></span>; part <span class="hljs-string"><span class="hljs-string">'server.dart'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Entry point */</span></span> main() { Server server = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Server(ADDRESS, PORT); server.bind(); }</code> </pre><br><br><h3>  Server base class, port listening </h3><br>  Below is the basic server code that will simply bind to the correct port. <br><br><pre> <code class="javascript hljs">part <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> simplechat.bin; <span class="hljs-comment"><span class="hljs-comment">/** * Class [Server] implement simple chat server */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Server</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Server bind port */</span></span> int port; <span class="hljs-comment"><span class="hljs-comment">/** * Server address */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> address; <span class="hljs-comment"><span class="hljs-comment">/** * Current server */</span></span> HttpServer _server; <span class="hljs-comment"><span class="hljs-comment">/** * Router */</span></span> Router _router; <span class="hljs-comment"><span class="hljs-comment">/** * Active connections */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, WebSocket&gt; connections = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, WebSocket&gt;(); int generalCount = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Server constructor * param [address] * param [port] */</span></span> Server([ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.address = <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.port = <span class="hljs-number"><span class="hljs-number">9224</span></span> ]); <span class="hljs-comment"><span class="hljs-comment">/** * Bind the server */</span></span> bind() { HttpServer.bind(address, port).then(connectServer); } <span class="hljs-comment"><span class="hljs-comment">/** * Callback when server is ready */</span></span> connectServer(server) { print(<span class="hljs-string"><span class="hljs-string">'Chat server is running on "$address:$port"'</span></span>); _server = server; bindRouter(); } }</code> </pre><br>  At the end of the <code>connectServer()</code> function, the function for setting up the router is <code>bindRouter()</code> , which we will discuss below. <br><br><h3>  Setting up a router and creating a websocket connection </h3><br>  To configure the router, create the <code>bindRouter()</code> function.  The incoming stream to <code>/</code> we will change using <code>WebSocketTransformer</code> and listen in the <code>createWs()</code> function. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Bind routes */</span></span> bindRouter() { _router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(_server); _router.serve(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) .transform(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocketTransformer()) .listen(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createWs); } createWs(WebSocket webSocket) { <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> connectionName = <span class="hljs-string"><span class="hljs-string">'user_$generalCount'</span></span>; ++generalCount; connections.putIfAbsent(connectionName, () =&gt; webSocket); }</code> </pre><br>  In the <code>createWs()</code> function, we generate a name for the connection using the <code>user_{counter}</code> scheme and save this connection as <code>connections</code> . <br><br><h3>  Message structure from the server and message creation function </h3><br>  The server sends messages in the form of a Map object (or rather its representations in json) with the following keys: <br><br><ul><li>  <strong>from</strong> - from whom the message; </li><li>  <strong>message</strong> - <strong>message</strong> text; </li><li>  <strong>online</strong> - the number of users online. </li></ul><br>  Here is the function that builds such a message: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Build message */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> buildMessage(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> message) { <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; data = { <span class="hljs-string"><span class="hljs-string">'from'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-string"><span class="hljs-string">'message'</span></span>: message, <span class="hljs-string"><span class="hljs-string">'online'</span></span>: connections.length }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.encode(data); }</code> </pre><br><h3>  Sending messages from the server </h3><br>  In order to send a message to the client, you need to use the <a href="https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/dart-io.WebSocket">add ()</a> method of the <a href="https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/dart-io.WebSocket">WebSocket</a> class.  Below is a function that will send messages to the user: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Sending message */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> send(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> to, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> message) { connections[to].add(message); }</code> </pre><br>  Our server can send notifications to all active clients about connecting or disconnecting a user.  Let's look at the function for this.  The function <code>notifyAbout(String connectionName, String message)</code> accepts the name of the connection and the message (about connecting or disconnecting).  This feature notifies all active clients in addition to whom this notification is made.  Those.  if <strong>user_3 has</strong> joined us, then all users will receive a notification except him.  In order to filter clients by a certain condition (in our case we need to get the names of all clients that do not match the current one), we will use the <a href="https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/dart-core.Iterable">where ()</a> method of the abstract class <a href="https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/dart-core.Iterable">Iterable</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Notify users */</span></span> notifyAbout(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> connectionName, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> message) { <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> jdata = buildMessage(SYSTEM_CLIENT, message); connections.keys .where(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">String</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">) =&gt;</span></span> name != connectionName) .forEach((<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> name) { send(name, jdata); }); }</code> </pre><br>  Also, after joining a new user, we will greet him: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Sending welcome message to new client */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> sendWelcome(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> connectionName) { <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> jdata = buildMessage(SYSTEM_CLIENT, <span class="hljs-string"><span class="hljs-string">'Welcome to chat!'</span></span>); send(connectionName, jdata); }</code> </pre><br>  Let's now take a look at the function that processes incoming messages from the user and sends them to all (or just the specified) chat participants.  The function <code>sendMessage(String from, String message)</code> takes the name of the sender and his message.  If the message body ( <code>message</code> ) specifies the names of the recipients by the mask <code>@{user_name}</code> , then the message will be delivered only to them.  Let's look at the <code>sendMessage</code> function <code>sendMessage</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Sending message to clients */</span></span> sendMessage(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> message) { <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> jdata = buildMessage(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, message); <span class="hljs-comment"><span class="hljs-comment">// search users that the message is intended RegExp usersReg = new RegExp(r"@([\w|\d]+)"); Iterable&lt;Match&gt; users = usersReg.allMatches(message); // if users found - send message only them if (users.isNotEmpty) { users.forEach((Match match) { String user = match.group(0).replaceFirst('@', ''); if (connections.containsKey(user)) { send(user, jdata); } }); send(from, jdata); } else { connections.forEach((username, conn) { conn.add(jdata); }); } }</span></span></code> </pre><br>  When the user closes the connection, we must remove it from the list of active connections.  The <code>closeConnection(String connectionName)</code> function takes the name of the connection that was closed and removes it from the list of connections: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Close user connections */</span></span> closeConnection(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> connectionName) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connections.containsKey(connectionName)) { connections.remove(connectionName); } }</code> </pre><br><h3>  Adding Opportunities to the Connection Listener </h3><br>  Let's summarize everything that we have now.  The <code>createWs</code> function <code>createWs</code> on the user's connection.  <code>send</code> - sends a message to the specified user.  <code>sendWelcome</code> - sends a message with a greeting to a new user.  <code>notifyAbout</code> - notifies chat participants (except the initiator) about any actions of the initiator (enable / disable).  <code>sendMessage</code> - sends a message to all or only specified users. <br><br>  Let's now change the <code>createWs</code> function so that we can use it all.  Last time, we stopped at adding a connection to the list.  After that, we need to notify all other members of the chat about the new user, and send the message to the new user with a greeting. <br><br>  Then we will need to listen to the user's websocket connection to messages from him and send messages to participants.  We will also add a handler to close the websocket connection, in which we will remove it from the list and notify all participants to disconnect. <br><br><pre> <code class="javascript hljs">createWs(WebSocket webSocket) { <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> connectionName = <span class="hljs-string"><span class="hljs-string">'user_$generalCount'</span></span>; ++generalCount; connections.putIfAbsent(connectionName, () =&gt; webSocket); <span class="hljs-comment"><span class="hljs-comment">//      notifyAbout(connectionName, '$connectionName joined the chat'); //     sendWelcome(connectionName); webSocket .map((string) =&gt; JSON.decode(string)) .listen((json) { sendMessage(connectionName, json['message']); }).onDone(() { closeConnection(connectionName); notifyAbout(connectionName, '$connectionName logs out chat'); }); }</span></span></code> </pre><br>  That's it, a simple server is ready.  We now turn to the client side. <br><br><h2>  Customer </h2><br>  Here I will not talk <em>about the layout of the client part</em> and the <em>display of messages</em> .  In this part we will talk only about how we open a websocket-connection to the server, send and receive messages. <br><br><h3>  Client Application Entry Point </h3><br>  The entry point to the client application is in the <code>web/dart/index.dart</code> file.  Let's look at its contents: <br><br><pre> <code class="javascript hljs">library simplechat.client; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'dart:html'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'dart:convert'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:simplechat.common/common.dart'</span></span>; part <span class="hljs-string"><span class="hljs-string">'./views/message_view.dart'</span></span>; part <span class="hljs-string"><span class="hljs-string">'./controllers/web_socket_controller.dart'</span></span>; main() { WebSocketController wsc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocketController(<span class="hljs-string"><span class="hljs-string">'ws://$ADDRESS:$PORT'</span></span>, <span class="hljs-string"><span class="hljs-string">'#messages'</span></span>, <span class="hljs-string"><span class="hljs-string">'#userText .text'</span></span>, <span class="hljs-string"><span class="hljs-string">'#online'</span></span>); }</code> </pre><br>  In the first line we declare the library.  Then we include the necessary files and parts of libraries.  The file <code>./views/message_view.dart</code> contains the definition of the class <code>MessageView</code> , which deals with the display of messages.  We will not consider it (the code can be viewed on <a href="https://github.com/rudart/simple-chat">github</a> ).  The file <code>./controllers/web_socket_controller.dart</code> contains the definition of the class <code>WebSocketController</code> , which we will focus on in more detail. <br><br>  The <code>main()</code> function permanently creates an instance of this controller. <br><br><h3>  WebSocketController - class constructor and connection creation </h3><br>  Let's take a look at the properties and constructor of the <code>WebSocketController</code> class: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSocketController</span></span></span><span class="hljs-class"> </span></span>{ WebSocket ws; HtmlElement output; TextAreaElement userInput; DivElement online; WebSocketController(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> connectTo, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> outputSelector, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> inputSelector, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> onlineSelector) { output = querySelector(outputSelector); userInput = querySelector(inputSelector); online = querySelector(onlineSelector); ws = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(connectTo); ws.onOpen.listen((e){ showMessage(<span class="hljs-string"><span class="hljs-string">'onnection is established'</span></span>, SYSTEM_CLIENT); bindSending(); }); ws.onClose.listen((e) { showMessage(<span class="hljs-string"><span class="hljs-string">'Connection closed'</span></span>, SYSTEM_CLIENT); }); ws.onMessage.listen((MessageEvent e) { processMessage(e.data); }); ws.onError.listen((e) { showMessage(<span class="hljs-string"><span class="hljs-string">'Connection error'</span></span>, SYSTEM_CLIENT); }); } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  From the code it is clear that <code>WebSocketController</code> has the following properties: <br><br><ul><li>  <code>WebSocket ws</code> - here we store our websocket connection; </li><li>  <code>HtmlElement output</code> - the element to which we will display messages; </li><li>  <code>TextAreaElement userInput</code> - the text area in which the user enters messages; </li><li>  <code>DivElement online</code> - an element in which the number of active users is displayed. </li></ul><br>  The class constructor takes an address at which you can open a websocket connection, selectors for the <code>output</code> , <code>userInput</code> and <code>online</code> elements.  At the very beginning he finds the elements in the tree.  Then a websocket connection to the server is created using the <code>WebSocket</code> constructor: <br><br><pre> <code class="javascript hljs">ws = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(connectTo);</code> </pre> <br>  Then we assign event handlers for our connection. <br><br>  The <code>onOpen</code> event <code>onOpen</code> triggered when the connection is successfully established.  Its handler displays a message indicating that the connection has been established and sets up a listener of keystroke events on the message input element so that when you press <code>Enter</code> , the message is sent.  Here is the <code>bindSending()</code> function code: <br><br><pre> <code class="javascript hljs">bindSending() { userInput.onKeyUp.listen((KeyboardEvent key) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key.keyCode == <span class="hljs-number"><span class="hljs-number">13</span></span>) { key.stopPropagation(); sendMessage(userInput.value); userInput.value = <span class="hljs-string"><span class="hljs-string">''</span></span>; } }); }</code> </pre><br>  In the body of the <code>keyUp</code> event <code>keyUp</code> you can notice the call to the function <code>sendMessage(String message)</code> , which deals with sending a message.  Sending a message via a websocket connection is performed using the <a href="https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/dart-dom-html.WebSocket">send ()</a> method of the <a href="https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/dart-dom-html.WebSocket">WebSocket</a> class.  Here is the code for this function: <br><br><pre> <code class="javascript hljs">sendMessage(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> message) { <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span> data = { <span class="hljs-string"><span class="hljs-string">'message'</span></span>: message }; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> jdata = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.encode(data); ws.send(jdata); }</code> </pre><br>  The <code>onClose</code> event <code>onClose</code> triggered when the connection is closed.  The handler for this event simply displays a message indicating that the connection has been dropped. <br><br>  The <code>onMessage</code> event fires when a message is received from the server.  The listener is passed the <a href="https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/dart-dom-html.MessageEvent">MessageEvent</a> object.  The event handler for this event passes the data received from the server to the <code>processMessage</code> function, which simply displays the message.  Here is its code: <br><br><pre> <code class="javascript hljs">processMessage(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> message) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.decode(message); showOnline(data[<span class="hljs-string"><span class="hljs-string">'online'</span></span>]); showMessage(data[<span class="hljs-string"><span class="hljs-string">'message'</span></span>], data[<span class="hljs-string"><span class="hljs-string">'from'</span></span>]); }</code> </pre><br>  I will not give the code for <code>showOnline</code> and <code>showMessage</code> , since  nothing particularly interesting happens in them.  But if you are interested in their content, then you can always find the full controller code on <a href="https://github.com/rudart/simple-chat">github</a> . <br><br>  That's all.  This is all the main functionality of the client part. <br><br>  You can see the working application here: <a href="http://simplechat.rudart.in/">http://simplechat.rudart.in</a> . <br><br>  If I made any mistakes and inaccuracies, then report, and I will try to fix everything quickly. </div><p>Source: <a href="https://habr.com/ru/post/230351/">https://habr.com/ru/post/230351/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../230341/index.html">Google has launched an API to monitor the data of its cloud services.</a></li>
<li><a href="../230343/index.html">Firmware Intel Integrated RAID Module RMS25JB080 in IT mode</a></li>
<li><a href="../230345/index.html">Browser Browser - empowering file sharing, as well as a way to survive pirated sites with anti-piracy laws</a></li>
<li><a href="../230347/index.html">How PolyITAN-1 was born in KPI laboratories</a></li>
<li><a href="../230349/index.html">Lock-free data structures. Queue dissection</a></li>
<li><a href="../230353/index.html">Squeryl - simplicity and grace</a></li>
<li><a href="../230355/index.html">Measure temperature: TEMPer + Python + Windows</a></li>
<li><a href="../230357/index.html">Parallel non-parallel or search for prime numbers on the GPU</a></li>
<li><a href="../230359/index.html">SASM - IDE for assembler</a></li>
<li><a href="../230361/index.html">LG G3: outside and inside the clearest smartphone in the world</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>