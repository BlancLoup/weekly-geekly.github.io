<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Choosing the right error handling strategy (parts 3 and 4)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parts 1 and 2: link 


 In the first part, we talked about different error handling strategies and when they are recommended for use. In particular, I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Choosing the right error handling strategy (parts 3 and 4)</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/c91/cb4/3ae/c91cb43ae6d746348b8382f26c3f8826.jpg" alt="image"></p><br><p>  Parts 1 and 2: <a href="https://habrahabr.ru/company/mailru/blog/322416/">link</a> </p><br><p>  In the first part, we talked about different error handling strategies and when they are recommended for use.  In particular, I said that the preconditions of functions should be checked using debug statements (debug assertions), i.e. only in debug mode. </p><br><p> To check the condition, the C library provides the <code>assert()</code> macro, but only if <code>NDEBUG</code> not defined.  However, as is the case with many other things in C, this is a simple, but sometimes ineffective solution.  The main problem I faced is the <strong>globality of the</strong> solution: you have statements either everywhere or nowhere.  Badly, this is because you cannot disable statements in the library, leaving them only in your own code.  Therefore, many authors of libraries write macros of statements independently, time after time. </p><a name="habracut"></a><br><p>  Let's create our own, better solution instead, so that part of it can be reused. </p><br><p>  <a href="https://github.com/foonathan/debug-assert">Source code</a> </p><br><h2 id="problema-s-assert">  Problem with <code>assert()</code> </h2><br><p>  Although <code>assert()</code> does its job well, this solution has a number of problems: </p><br><ol><li>  It is not possible to set an additional message providing more information about the failed condition.  Only the expression converted to a string is displayed.  This allows you to do hacks like <code>assert(cond &amp;&amp; !"my message")</code> .  An additional message might be useful if the condition alone does not provide enough information, like <code>assert(false)</code> .  Moreover, sometimes you need to pass additional parameters. </li><li>  Global: either <strong>all</strong> statements are active, or <strong>none</strong> is active.  Assertions cannot be managed for any particular module. </li><li>  The content of the message and the way it is output is determined by the implementation.  But you may want to manage it, or even integrate logging into your code. </li><li>  Claim levels are not supported.  Some of the statements are more expensive than others, so sometimes finer control is required. </li><li>  It uses macros, and one is even in lower case (lower-case)!  Macros are not the best thing, their use is best minimized. </li></ol><br><p>  Let's write a universal advanced <code>assert()</code> . </p><br><h2 id="pervyy-podhod">  First approach </h2><br><p>  It looks like the first double.  Probably in the same way you write your own assertion macros: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">source_location</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* file_name; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> line_number; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* function_name; }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CUR_SOURCE_LOCATION source_location{__FILE__, __LINE__, __func__} void do_assert(bool expr, const source_location&amp; loc, const char* expression) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!expr) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// handle failed assertion std::abort(); } } #if DEBUG_ASSERT_ENABLED #define DEBUG_ASSERT(Expr) \ do_assert(expr, CUR_SOURCE_LOCATION, #Expr) #else #define DEBUG_ASSERT(Expr) #endif</span></span></span></span></code> </pre> <br><p>  I have defined an auxiliary <code>struct</code> that contains the source location information.  In this case, the work itself is performed by the <code>do_assert()</code> function, and the macro simply redirects. </p><br><p>  <em>This avoids tricks with <code>do ... while(0)</code> .</em>  <em>Macro size should be as small as possible.</em> </p><br><p>  Now we have a macro that simply gets the current location in the code (source location) used in the approval macro.  <code>DEBUG_ASSERT_ENABLED</code> can enable and disable assertions using the <code>DEBUG_ASSERT_ENABLED</code> macro setting. </p><br><h2 id="vozmozhnaya-problema-preduprezhdenie-o-neispolzuemoy-peremennoy">  Possible problem: warning about unused variable </h2><br><p>  If you have ever compiled a release build with warnings enabled, then you know that because of any variable that was used only in a statement, the warning ‚Äúunused variable‚Äù will appear. </p><br><p>  You can try to prevent this by writing a non-assertion like: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEBUG_ASSERT(Expr) (void)Expr</span></span></code> </pre> <br><p>  Do not do this! </p><br><p>  I made a terrible mistake like that.  In this case, the expression will be evaluated even with assertions disabled.  And if it is rather complicated, then this will lead to large performance losses.  Take a look at the code: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">iterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binary_search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(iterator begin, iterator end, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ assert(is_sorted(begin, end)); <span class="hljs-comment"><span class="hljs-comment">// binary search }</span></span></code> </pre> <br><p>  <code>is_sorted()</code> is a linear operation, while <code>binary_search()</code> has a time complexity of <code>O(log n)</code> .  Even with the assertions disabled, <code>is_sorted()</code> can still be computed by the compiler, because there is no evidence of the absence of its side effects! </p><br><p>  <em>When I made such a mistake, I got a <a href="http://foonathan.net/blog/2016/04/13/boosting-pools-3.html">very similar situation</a> .</em>  <em>Performance has fallen dramatically.</em> </p><br><p>  But in any case, <code>DEBUG_ASSERT()</code> not much better than <code>assert()</code> , so <code>DEBUG_ASSERT()</code> stop on it. </p><br><h2 id="vnedryaem-nastraivaemost-i-modulnost">  Implement customizability and modularity </h2><br><p>  Problems number 2 and 3 can be solved with the help of a policy (policy).  This is an additional template parameter that controls the activation of the statement and the way the message is displayed on the screen.  In each module in which you want to provide separate management of assertions, you need to define your own <code>Handler</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handler</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_assert</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expr</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">source_location</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">loc</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expression</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">noexcept</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Handler::value &amp;&amp; !expr) { <span class="hljs-comment"><span class="hljs-comment">// handle failed assertion Handler::handle(loc, expression); std::abort(); } } #define DEBUG_ASSERT(Expr, Handler) \ do_assert&lt;Handler&gt;(Expr, CUR_SOURCE_LOCATION, #Expr)</span></span></code> </pre> <br><p>  Instead of hard writing in the code for the method of evaluating the expression, we call the <code>static handle()</code> function with reference to a specific <code>Handler</code> . </p><br><p>  <em>To prevent throwing <code>Handler</code> exceptions when leaving a function, I made <code>do_assert() noexcept</code> , and for return functions, the handler made a call to <code>std::abort()</code> .</em> </p><br><p>  The function also controls expression checking with the value constant ( <code>std::true_type/std::false_type</code> ).  Now the assertion macro will unconditionally redirect to <code>do_assert()</code> . </p><br><p>  However, this code has the same drawback as described above: the expression is always calculated when the branch <code>Handler::value</code> ! Is executed! </p><br><p>  The second problem is easily solved: <code>Handler::value</code> is a constant, so we can use <code>constexpr if</code> emulation.  But how to prevent expression evaluation?  Let's go to the trick - use lambda: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handler</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_assert</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:true_type, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Expr&amp; e, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> source_location&amp; loc, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* expression) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!e()) { Handler::handle(loc, expression); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); } } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handler</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_assert</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:false_type, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Expr&amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> source_location&amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handler</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_assert</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">source_location</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">loc</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expression</span></span></span><span class="hljs-class">) {</span></span> do_assert&lt;Handler&gt;(Handler{}, e, loc, expression); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEBUG_ASSERT(Expr, Handler) \ do_assert</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Handler&gt;([&amp;] { return Expr; }, CUR_SOURCE_LOCATION, #Expr)</span></span></span></span></code> </pre> <br><p>  <em>Now this code assumes that <code>Handler</code> inherits from <code>std::true_type</code> or <code>std::false_type</code> .</em> </p><br><p>  To implement static dispatching (static dispatch), we do here the ‚Äúclassic‚Äù <a href="http://foonathan.net/blog/2015/11/16/overload-resolution-3.html">tag dispatching</a> (tag dispatching).  But more importantly, we changed the processing of the expression: instead of a direct transfer of the expression <code>bool</code> (which means evaluating the expression), the macro creates a lambda that <strong>returns an</strong> expression.  Now it will be calculated only when calling the lambda. </p><br><ul><li>  This is done only with assertions enabled. </li></ul><br><p>  The lambda wrapping trick to put off the calculation is useful in all situations where you have only optional checks, and you do not want to use macros.  For example, in <a href="https://github.com/foonathan/memory">memory,</a> I use this approach to check for double release of resources (double deallocation). </p><br><h2 id="est-li-zdes-kakie-to-izderzhki">  Are there any costs here? </h2><br><p>  The macro is always active, so it will always call the <code>do_assert()</code> function.  For comparison, when conditional compiling (conditional compilation), the macro runs idle.  So are there any costs? </p><br><p>  I have carefully analyzed several compilers.  When compiling with optimizations off, we only have a call to <code>do_assert()</code> , which is redirected to a non-optimized version.  The expression remains intact, and already at the initial level of optimizations the challenge is completely eliminated. </p><br><p>  I wanted to improve code generation with optimizations disabled, so I turned on <a href="http://foonathan.net/blog/2015/11/30/overload-resolution-4.html">SFINAE</a> to select overload instead of tag dispatch.  This eliminates the need for a springboard function that inserts a tag.  Now the macro directly calls the non-optimized version.  I also marked it to be force-inline, so the compiler will do this even without optimizations.  All it does is create the <code>source_location</code> object. </p><br><p>  But, as before, for any optimizations, the macro seems to be idling. </p><br><h2 id="dobavlenie-urovney-utverzhdeniy">  Adding Approval Levels </h2><br><p>  With this approach, it is very easy to add other levels of statements: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handler</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unsigned</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Level</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_assert</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expr</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">source_location</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">loc</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expression</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">noexcept</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:enable_if&lt;Level &lt;= Handler::level&gt;::type { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(Level &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"level of an assertion must not be 0"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!expr()) { Handler::handle(loc, expression); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); } } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handler</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unsigned</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Level</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_assert</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span><span class="hljs-class">&amp;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">source_location</span></span></span><span class="hljs-class">&amp;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">*) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">noexcept</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:enable_if&lt;(Level &gt; Handler::level)&gt;::type {} <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEBUG_ASSERT(Expr, Handler, Level) \ do_assert</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Handler, Level&gt;([&amp;] { return Expr; }, CUR_SOURCE_LOCATION, #Expr)</span></span></span></span></code> </pre> <br><p>  <em>Also, SFINAE is used instead of tags.</em> </p><br><p>  When determining whether assertions are activated, instead of <code>Handler::value</code> the <code>Level &lt;= Handler::level</code> condition is now included.  The higher the level, the more affirmations are activated.  Level 0 means that no statements are true. </p><br><p>  <em>Note: this also means that the minimum level of partial approval is 1.</em> </p><br><h2 id="posledniy-shag-dobavlyaem-soobschenie">  Last step: add a message </h2><br><p>  It is very simple to do this: we enter an additional parameter that will be passed to the handler.  But sometimes we don‚Äôt need the statements to contain a message, because the conditions already give enough information.  So it is good to overload the macro.  Alas, there is no such possibility.  It‚Äôs the same with levels: maybe you don‚Äôt want to define them every time.  Moreover, since the handler is a generic, it is able to take additional arguments. </p><br><p>  So we need an assertion macro that can process any number of arguments.  That is, a macro with a variable number of arguments (variadic): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Level&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> level = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>, Level&gt;; <span class="hljs-comment"><span class="hljs-comment">// overload 1, with level, enabled template &lt;class Expr, class Handler, unsigned Level, typename ... Args&gt; auto do_assert(const Expr&amp; expr, const source_location&amp; loc, const char* expression, Handler, level&lt;Level&gt;, Args&amp;&amp;... args) noexcept -&gt; typename std::enable_if&lt;Level &lt;= Handler::level&gt;::type { static_assert(Level &gt; 0, "level of an assertion must not be 0"); if (!expr()) { Handler::handle(loc, expression, std::forward&lt;Args&gt;(args)...); std::abort(); } } // overload 1, with level, disabled template &lt;class Expr, class Handler, unsigned Level, typename ... Args&gt; auto do_assert(const Expr&amp;, const source_location&amp;, const char*, Handler, level&lt;Level&gt;, Args&amp;&amp;...) noexcept -&gt; typename std::enable_if&lt;(Level &gt; Handler::level)&gt;::type {} // overload 2, without level, enabled template &lt;class Expr, class Handler, typename ... Args&gt; auto do_assert(const Expr&amp; expr, const source_location&amp; loc, const char* expression, Handler, Args&amp;&amp;... args) noexcept -&gt; typename std::enable_if&lt;Handler::level != 0&gt;::type { if (!expr()) { Handler::handle(loc, expression, std::forward&lt;Args&gt;(args)...); std::abort(); } } // overload 2, without level, disabled template &lt;class Expr, class Handler, typename ... Args&gt; auto do_assert(const Expr&amp;, const source_location&amp;, const char*, Handler, Args&amp;&amp;...) noexcept -&gt; typename std::enable_if&lt;Handler::level == 0&gt;::type {} #define DEBUG_ASSERT(Expr, ...) \ do_assert([&amp;] { return Expr; }, CUR_SOURCE_LOCATION, #Expr, __VA_ARGS__)</span></span></code> </pre> <br><p>  We have two parameters that need to be specified: an expression and a handler.  Since a macro variad cannot be empty, we name only the first required parameter.  All parameters of the variadic are passed as parameters to the function call. </p><br><p>  This makes some changes to the nature of the use: the type name and the <code>Level</code> constant can come before the <code>Handler</code> , and now they need to be adjusted, because they are parameters of a regular function.  <code>Handler</code> must be an object of handler type, and Level, and an object of type <code>level&lt;N&gt;</code> .  This allows you to make an argument deduction (argument deduction) to calculate the appropriate parameters. </p><br><p>  Also, the above code supports any number of additional arguments that are simply forwarded to the handler function.  I want to allow the following call options: </p><br><ol><li>  <code>DEBUG_ASSERT(expr, handler{})</code> - no level, no additional arguments. </li><li>  <code>DEBUG_ASSERT(expr, handler{}, level&lt;4&gt;{})</code> - with a level, but without additional arguments. </li><li>  <code>DEBUG_ASSERT(expr, handler{}, msg)</code> - without a level, but with an additional argument (message). </li><li>  <code>DEBUG_ASSERT(expr, handler{}, level&lt;4&gt;{}, msg)</code> - with a level and an additional argument (message). </li></ol><br><p>  To do this, we need two overloads of <code>do_assert()</code> .  The first handles all overloads with the level (2 and 4), the second - without (1 and 3). </p><br><h2 id="no-eto-vsyo-eschyo-makros">  But it is still a macro! </h2><br><p>  One of the problems with <code>assert()</code> is that it is a macro.  Yes, still a macro! </p><br><p>  But there is a major improvement to be noted: we no longer need a macro to turn off the statement.  Now it is needed only for three things.  To: </p><br><ol><li>  Get current location in code (source location). </li><li>  Convert expression to string. </li><li>  Convert the expression to lambda to enable deferred evaluation. </li></ol><br><p>  As for 1, then Library Fundamentals V2 has <a href="https://en.cppreference.com/w/cpp/experimental/source_location">std :: experimental :: source_location</a> .  This class represents the location of the source code, as I wrote a <code>struct</code> .  But for its extraction at compile time, it's not the macros that are responsible, but the static class function ‚Äî <code>current()</code> .  Moreover, if you use this class like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::source_location loc = </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::source_location::current())</span></span></span></span>;</code> </pre> <br><p>  then loc will get the location of the calling code fragment, not the parameter!  This is exactly what is needed for assertion macros. </p><br><p>  Unfortunately, in the second and third variants we cannot replace the macro with anything.  This must be done manually through the calling code snippet.  So we will not get rid of the macro, as long as we need the flexibility of use. </p><br><h2 id="promezhutochnoe-zaklyuchenie">  Interim conclusion </h2><br><p>  We created a simple assertion utility, flexible in use, generic, and supporting separate assertion levels for each module.  At the time of this writing, I decided to publish the code as a library header-only: <a href="https://github.com/foonathan/debug-assert">debug-assert</a> . </p><br><p>  In it, you will find additional code, for example, easily generated modular handlers: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_module</span></span></span><span class="hljs-class"> :</span></span> debug_assert::set_level&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;, <span class="hljs-comment"><span class="hljs-comment">// set the level, normally done via buildsystem macro debug_assert::default_handler // use the default handler {};</span></span></code> </pre> <br><p>  Just copy the title to your project and start using the new, improved macro statements.  I hope he will save you from writing macros for each of the projects in which you will need to manage the statements separately.  At the moment this is a very small and quickly created library, so if you have any ideas about upgrading it, let me know! </p><br><p>  Assertions are a useful tool for testing preconditions for functions.  But the right type architecture can prevent situations in which statements need to be used.  In C ++, there is a beautiful type system, so let's use it for our own benefit. </p><br><h2 id="motivaciya">  Motivation </h2><br><p>  I am working on <a href="https://github.com/foonathan/standardese">standardese</a> , a C ++ documentation generator.  And there I have to deal with a large number of string values.  In particular, I constantly remove spaces at the end of lines.  Since this is a very simple task, and the definition of a space varies depending on the situation, I did not care to write a separate function for this. </p><br><p>  <em>Looking back, I can say that it should.</em> </p><br><p>  I use similar code: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (is_whitespace(str.back()) str.pop_back();</code> </pre> <br><p>  I‚Äôm writing two lines, commits, pushing, and, as usual waiting for CI to work, I get an email with a message about a crash in the Windows build.  I am at a loss: everything worked on my machine, as in all Linux and MacOS builds!  Watching the log: the test execution ended with a timeout. </p><br><p>  I start Windows and I collect the project there.  When I run the tests, I get a surprisingly arranged conversation about debugging assertion failures. </p><br><p>  <em>The one in which Retry means Debug.</em> </p><br><p>  Watching the error message.  Hand face.  Fix fix: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!str.empty() &amp;&amp; is_whitespace(str.back()) str.pop_back();</code> </pre> <br><p>  Sometimes the string is empty.  In libstdc ++, in such cases, assertions are not included by default, which leads to a natural result.  But the MSVC claims <strong>are included</strong> , and he notices such cases. </p><br><p>  <em>I made this mistake three times.</em>  <em>Still, I had to write a function.</em> </p><br><p>  There were also several other problems: I didn‚Äôt follow the DRY principle, libstdc ++ didn‚Äôt check preconditions by default, Appveyor didn‚Äôt like graphical statements dialogs, and MSVC doesn‚Äôt exist under Linux. </p><br><p>  But I think the <code>std::string::back()</code> architecture played a major role in what happened.  If this class were made according to the mind, then the code would not compile and the system would not remind me of the fact that the string may be empty.  This would save 15 minutes of my life and one download to Windows. </p><br><p>  How could this be avoided?  Using the type system. </p><br><h2 id="reshenie">  Decision </h2><br><p>  The function in question has the following simplified signature (signature): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">back</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p>  It returns the last character of the string.  If the string is empty, then it simply does not contain the last character, which means that invoking it in any case is an indefinite behavior.  How do we know about this?  If you think about it, everything is clear: what <code>char</code> should be returned in the case of an empty string?  There is no ‚Äúwrong‚Äù <code>char</code> , so which one will not return. </p><br><p>  <em>It is actually <code>\0</code> , but at the same time it is the last character of <code>std::string</code> , and you cannot distinguish between them.</em> </p><br><p>  But I did not think about it.  My head was busy with a complex comment parsing algorithm and the problem that some developers leave spaces at the end of comments, breaking all subsequent parsing markup! </p><br><p>  <code>back()</code> has a narrow contract (precondition).  Without a doubt, it is more difficult to work with functions with a narrow contract than with a wide contract.  So one of the possible tasks could be this: make as few narrow contracts as possible. </p><br><p>  One of the problems with the <code>back()</code> function is that it does not provide for a valid return character in case of an empty string.  But in C ++ 17 there is a potentially useful addition: <code>std::optional</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; back();</code> </pre> <br><p>  <code>std::optional</code> may or may not contain a value.  If the string is not empty, then <code>back()</code> returns an optional containing the last character.  But if the string is empty, the function can return optional, which is null.  That is, we have modeled the function so that now we no longer need preconditions. </p><br><p>  <em>Note that we lost the ability to use <code>back()</code> as an l-value, because now you can‚Äôt use <code>std::optional&lt;T&amp;&gt;</code> .</em>  <em>So <code>std::optional</code> is not the best solution, but more on that below.</em> </p><br><p>  Suppose that <code>std::string::back()</code> has such a signature.  I again focused on the code for parsing comments and writing a couple of lines to quickly erase the "hanging" spaces: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (is_whitespace(str.back()) str.pop_back();</code> </pre> <br><p>  <code>is_whitespace()</code> takes <code>char</code> , but <code>back()</code> returns std :: optional, so I immediately get a compile error on my machine.  The compiler caught a possible bug for me, and statically, using only the type system!  I was automatically reminded that the string could be empty and that I needed to make extra effort to get the character. <br></p><p>  Of course, I can still be mistaken, because <code>std::optional</code> is not really intended for this task: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (is_whitespace(*str.back())</code> </pre> <br><p>  This code behaves in the same way, and, probably, a debugging statement will appear in MSVC.  <code>std::optional&lt;T&gt;::operator*</code> should not be called with optional = null, it returns the value contained in it.  So it will be a little better: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (is_whitespace(str.back().value())</code> </pre> <br><p>  At least, <code>std::optional&lt;T&gt;::value()</code> intended to throw an exception with optional = null, so at least it will fail to fail steadily during runtime.  But both of these solutions have absolutely no advantages over the code with the same signature.    (member functions)   ,      ,     !      ,       .   ,   ,   -  (non-member functions)  ,  ,    , ‚Äî      ! </p><br><p> <em><code>std::optional</code>     .      <code>std::unique_ptr&lt;T&gt;</code> ,    ,     .  - (pointer type),    ¬´ ¬ª (Maybe),     . -       ,   . ,  .</em> </p><br><p>    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (is_whitespace(str.back().value_or(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>))</code> </pre> <br><p> <code>std::optional&lt;T&gt;::value_or()</code>   ,   .    optional   ,      . , ,      .         <code>is_whitespace()</code> ,    <code>std::optional&lt;char&gt;</code> . </p><br><h2 id="rukovodstvo-1-ispolzuyte-pravilnyy-tip-vozvraschaemogo-znacheniya">  1:      </h2><br><p>   ,   - ,     .      <code>back()/front()</code> .    ,      (optional type)  <code>std::optional&lt;T&gt;</code> .     ,        ,       . </p><br><p> ,     <code>std::optional&lt;T&gt;</code> ,      .       .         -   <code>std::expected&lt;T, E&gt;</code> ,        (error type).     - ,       ,      . </p><br><h2 id="parametricheskie-predusloviya-parameter-preconditions">   (parameter preconditions) </h2><br><p>       ,       . ,   ,        . </p><br><p>  : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T* ptr)</span></span></span><span class="hljs-function"> </span></span>{ assert(ptr); ‚Ä¶ }</code> </pre> <br><p>   : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; ref)</span></span></span></span>;</code> </pre> <br><p>          (null pointer value).      ,          (dereferencing)    (callers). </p><br><p>        : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ assert(value &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); ‚Ä¶ }</code> </pre> <br><p>   : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span></span>;</code> </pre> <br><p>           (underflow).  , ++             ,     . </p><br><h2 id="rukovodstvo-2-ispolzuyte-pravilnye-tipy-argumentov">  2:     </h2><br><p>     ,           .    ,     null?  .  ,     ?   .  ,        ?   (enumeration). </p><br><p>          (general wrapper type),  ‚Äî ! ‚Äî  ,   ¬´¬ª (raw)    , : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">non_empty_string</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">non_empty_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">str_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(str))</span></span></span><span class="hljs-function"> </span></span>{ assert(!str_.empty()); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str_; } ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// other functions you might want private: std::string str_; };</span></span></code> </pre> <br><p>      .             .       , ,  ,         . </p><br><p> ,     .       -  .  ,        :         ,       ? </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>    C++  ,     . </p><br><p>            -   .    ,      .     ,        . </p><p></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/322804/">https://habr.com/ru/post/322804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322794/index.html">The unpleasant truth about Apple Pay</a></li>
<li><a href="../322796/index.html">How Virtual Reality Transforms Customer Experience</a></li>
<li><a href="../322798/index.html">31 facts about the early history of the US dollar</a></li>
<li><a href="../322800/index.html">Starbucks should open public access to its API.</a></li>
<li><a href="../322802/index.html">How I got into the PayPal server through a bug in downloading files and got access to remote code execution</a></li>
<li><a href="../322806/index.html">A bit about functors and higher order functions in Swift</a></li>
<li><a href="../322812/index.html">The real hero in the programming world: who is he?</a></li>
<li><a href="../322814/index.html">Updating the application code on a running server</a></li>
<li><a href="../322816/index.html">Automated testing of bots for Telegram</a></li>
<li><a href="../322818/index.html">Announcement of HolyJS 2017 Piter: More JavaScript, good and different</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>