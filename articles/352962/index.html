<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learn OpenGL. Lesson 4.10 - Instancing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instancing 
 Imagine that you have conceived a scene containing a huge number of object models, mostly these models contain the same vertex data, only...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learn OpenGL. Lesson 4.10 - Instancing</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="Ogl3" align="left" width="300"><h1>  Instancing </h1><br>  Imagine that you have conceived a scene containing a huge number of object models, mostly these models contain the same vertex data, only the transformation matrices applied to them differ.  For example, a scene with a grass field, where each blade of grass is represented by a small model composed of literally a pair of triangles.  Of course, to achieve the desired effect, you will have to render this model not once, but a thousand, ten thousand times per frame.  Since each leaf contains literally a pair of triangles, its render will be almost instantaneous.  But here thousands of repeated calls of the render functions together will hit the performance very significantly. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  Part 1. Start <br><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br>  Part 2. Basic lighting <br><br><ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Texture Cards</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple light sources</a> </li></ol><br>  Part 3. Loading 3D Models 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp library</a> </li><li>  <a href="https://habrahabr.ru/post/338436/">Mesh mesh class</a> </li><li>  <a href="https://habrahabr.ru/post/338998/">Model class</a> </li></ol><br>  Part 4. OpenGL advanced features <br><br><ol><li>  <a href="https://habrahabr.ru/post/342610/">Depth test</a> </li><li>  <a href="https://habrahabr.ru/post/344238/">Stencil test</a> </li><li>  <a href="https://habrahabr.ru/post/343096/">Mixing colors</a> </li><li>  <a href="https://habrahabr.ru/post/346964/">Face clipping</a> </li><li>  <a href="https://habrahabr.ru/post/347354/">Frame buffer</a> </li><li>  <a href="https://habrahabr.ru/post/347750/">Cubic cards</a> </li><li>  <a href="https://habrahabr.ru/post/350008/">Advanced data handling</a> </li><li>  <a href="https://habrahabr.ru/post/350156/">Advanced GLSL</a> </li><li>  <a href="https://habrahabr.ru/post/350782/">Geometric Shader</a> </li><li>  Instancing </li></ol><br></div></div><br>  If we really planned to display a lot of objects in the scene in the described way, then in the code it would look something like this: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ix = <span class="hljs-number"><span class="hljs-number">0</span></span>; ix &lt; model_count; ++ix) { <span class="hljs-comment"><span class="hljs-comment">//  VAO, ,  , ... DoSomePreparations(); glDrawArrays(GL_TRIANGLES, 0, vertex_count); }</span></span></code> </pre> <br>  When rendering multiple <i>instances of</i> the same model, we will quickly reach the bottleneck in terms of performance - they will be many calls to the primitive rendering functions.  Compared to the time spent on direct rendering, transferring data to the GPU that you want to render something using functions like <i>glDrawArrays</i> or <i>glDrawElemenets</i> takes quite a lot of time.  This time is spent on the preparation required by OpenGL before directly outputting vertex data: transferring to the GPU data about the current data reading buffer, location and format of the vertex attribute data, and so on.  And all this exchange is carried out on a relatively slow bus connecting CPU and GPU.  A paradoxical situation arises: the rendering of vertex data is lightning-fast, but the transfer of commands for rendering the rendering is rather slow. <br><br>  It would be great to be able to send the necessary data to the video card once, and then just one call to ask OpenGL to render a variety of objects using this data.  Welcome to the world of <i><b>instansing</b></i> ! <br><br>  Instancing is a technology that allows you to display a lot of objects using a single call to the drawing function, which saves us from unnecessary exchange of CPU -&gt; GPU when rendering.  All you need to do to start using instancing is to change the <i>glDrawArrays</i> and <i>glDrawElemenets calls</i> to <i>glDrawArraysInstanced</i> and <i>glDrawElementsInstanced,</i> respectively.  Versions that support instance take one additional parameter, in addition to functions already familiar with regular versions.  This parameter is the number of instancing instances, i.e.  the number of instantiated model instances.  Thus, we once feed the GPU all the data necessary for the rendering, and then tell it how to render the desired number of object instances in just one special function call.  And the video card will draw the entire set of objects without constant access to the CPU. <br>  By itself, this possibility is not very useful: by outputting thousands of objects in the same way, in the same position, we end up with an image of a single object ‚Äî all the copies will be superimposed on each other.  To solve this problem in vertex shaders, the available built-in GLSL variable <i>gl_InstanceID</i> . <br>  When using functions for instance rendering, the value of this variable will increase by one for each displayed instance, starting with zero.  Thus, rendering the 43rd instance of the object, in the vertex shader, we get <i>gl_InstanceID</i> equal to 42. Having a unique index corresponding to the instance, we could, for example, use it to select from a large array of position vectors in order to render each instance in a certain place of the scene . <br><br>  To get a better sense of the essence of instancing, let's try to figure out a simple example that renders hundreds of quads (rectangles) in normalized coordinates of a device (NDC) using a single draw call.  The offset is determined by sampling from a uniform, which is an array containing one hundred displacement vectors.  The result is a nice grid of rectangles that fill the entire area of ‚Äã‚Äãthe window: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qp/wi/n8/qpwin8wvk2wivww1tiewhav0jte.png"></div><br>  Each quad is made up of two triangles, which gives us six vertices.  Each vertex contains a two-component position vector in NDC and a color vector.  Below are the vertex data from the example - the size of the triangles is chosen small enough to correctly fill the screen in large quantities: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> quadVertices[] = { <span class="hljs-comment"><span class="hljs-comment">//  //  -0.05f, 0.05f, 1.0f, 0.0f, 0.0f, 0.05f, -0.05f, 0.0f, 1.0f, 0.0f, -0.05f, -0.05f, 0.0f, 0.0f, 1.0f, -0.05f, 0.05f, 1.0f, 0.0f, 0.0f, 0.05f, -0.05f, 0.0f, 1.0f, 0.0f, 0.05f, 0.05f, 0.0f, 1.0f, 1.0f };</span></span></code> </pre> <br>  The quad color sets the fragment shader, which simply redirects the interpolated vertex color obtained from the vertex shader directly to the output variable: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec3 fColor; void main() { FragColor = vec4(fColor, 1.0); }</span></span></code> </pre> <br>  Nothing new for us.  But in the vertex shader, things are different: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec2 aPos; layout (location = 1) in vec3 aColor; out vec3 fColor; uniform vec2 offsets[100]; void main() { vec2 offset = offsets[gl_InstanceID]; gl_Position = vec4(aPos + offset, 0.0, 1.0); fColor = aColor; }</span></span></code> </pre> <br>  Here we declared a uniforms-array <i>offsets</i> , containing a hundred displacement vectors.  In the shader code, we get the offset value by sampling from the array by the value of the variable <i>gl_InstanceID</i> .  As a result, using this shader, we can render a hundred quads located in different positions on the screen. <br><br>  However, additional work is required - the displacement array itself will not fill up.  Fill it in our application, before entering the main draw cycle: <br><br><pre> <code class="cpp hljs">glm::vec2 translations[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> offset = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">-10</span></span>; y &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; y += <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">-10</span></span>; x &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; x += <span class="hljs-number"><span class="hljs-number">2</span></span>) { glm::vec2 translation; translation.x = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)x / <span class="hljs-number"><span class="hljs-number">10.0f</span></span> + offset; translation.y = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)y / <span class="hljs-number"><span class="hljs-number">10.0f</span></span> + offset; translations[index++] = translation; } }</code> </pre> <br>  A hundred of transfer vectors are created here that define a uniform 10x10 grid. <br><br>  Do not forget to transfer the generated data to the uniform array of shader: <br><br><pre> <code class="cpp hljs">shader.use(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) { <span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> ss; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> index; ss &lt;&lt; i; index = ss.str(); shader.setVec2((<span class="hljs-string"><span class="hljs-string">"offsets["</span></span> + index + <span class="hljs-string"><span class="hljs-string">"]"</span></span>).c_str(), translations[i]); }</code> </pre> <br>  In this piece of code, we will convert the loop variable <i>i</i> into a variable of type <i>string</i> so that we can dynamically set the string of the name of the uniform and get the location of the uniform of that name.  For each element from the offsets array, we pass the corresponding generated offset vector. <br><blockquote>  If C ++ 11 and newer is available, better use std :: to_string ().  <i>Approx.</i> </blockquote>  Now that the preparatory work is finished, you can finally proceed to the render.  Remember, you must use <i>glDrawArraysInstanced</i> or <i>glDrawElementsInstanced</i> to invoke the instantiated render.  Since we do not use the index buffer in the example, the following code is used: <br><br><pre> <code class="cpp hljs">glBindVertexArray(quadVAO); glDrawArraysInstanced(GL_TRIANGLES, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br>  The parameters passed to the drawing function are identical to those passed to <i>glDrawArrays</i> , with the exception of the last parameter specifying the desired number of instances to the renderer.  Since we want to output 100 quads in a 10x10 grid, we are passing the number 100. Execution of the code should lead to the derivation of an already familiar picture with a hundred colorful rectangles. <br><br><h3>  Instance Arrays </h3><br>  The previous example is quite a hard worker and does its job.  But there is a problem: if our appetites grow, and we want to withdraw much more than 100 copies, then very soon we will rest on the <a href="http://www.opengl.org/wiki/Uniform_(GLSL)">ceiling of the</a> allowed volume of uniforms sent to the shader.  An alternative to transmitting data through uniforms is <i>instantiated arrays</i> ( <i>instanced arrays</i> ), which are specified as vertex attributes, the selection of which occurs only when the current index of the object being rendered is changed.  In the end, this allows you to transfer much larger amounts of data in a more convenient way. <br><br>  For normal vertex attributes, GLSL fetches new vertex data values ‚Äã‚Äãwith each successive execution of the vertex shader code.  However, by specifying the vertex attribute as an instantiated array, we force GLSL to fetch a new attribute value for each successive instance of the object, rather than the next vertex of the object.  As a result, you can use the usual vertex attributes for the data represented by the vertex, and instantiated arrays for the data unique to the object instance. <br><br>  To better understand how this works, we modify the example code to use an instantiated array instead of a uniform array.  We'll have to update the shader code by specifying a new vertex attribute: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec2 aPos; layout (location = 1) in vec3 aColor; layout (location = 2) in vec2 aOffset; out vec3 fColor; void main() { gl_Position = vec4(aPos + aOffset, 0.0, 1.0); fColor = aColor; }</span></span></code> </pre> <br>  Here we no longer use the <i>gl_InstanceID</i> variable and can directly access the <i>offset</i> attribute, without having to fetch from an array. <br><br>  Since the implementation of an instantiated array is essentially based on vertex attributes, such as <i>position</i> or <i>color</i> , it is necessary to save the data in the vertex buffer object and configure the vertex attribute pointer.  First, save the data of the <i>translations</i> array in the new buffer object: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> instanceVBO; glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;instanceVBO); glBindBuffer(GL_ARRAY_BUFFER, instanceVBO); glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(glm::vec2) * <span class="hljs-number"><span class="hljs-number">100</span></span>, &amp;translations[<span class="hljs-number"><span class="hljs-number">0</span></span>], GL_STATIC_DRAW); glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Also configure the pointer of the vertex attribute and activate the attribute: <br><pre> <code class="cpp hljs">glEnableVertexAttribArray(<span class="hljs-number"><span class="hljs-number">2</span></span>); glBindBuffer(GL_ARRAY_BUFFER, instanceVBO); glVertexAttribPointer(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-number"><span class="hljs-number">0</span></span>); glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>); glVertexAttribDivisor(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  The code is familiar, except for the last line calling <i>glVertexAttribDivisor</i> .  This function tells OpenGL when to fetch a new element from a vertex attribute.  The first parameter is the index of the attribute of interest, and the second is the <i>attribute separator</i> ( <i>attribute divisor</i> ).  By default, it is set to 0, which corresponds to an attribute update for each new vertex processed by the vertex shader.  By setting this parameter to 1, we tell OpenGL to update the attribute when rendering each subsequent instance.  By setting the delimiter to 2, we will provide an update every two instances, and so on.  In fact, setting the separator to 1, we indicate that the attribute with this separator is represented by an instantiated array. <br><br>  If we now draw the scene using <i>glDrawArraysInstanced</i> , we get the following picture: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qp/wi/n8/qpwin8wvk2wivww1tiewhav0jte.png"></div><br>  Exactly the same as last time, but implemented using an instantiated array, which allows you to transfer much more data to the vertex shader to provide an instantiated render. <br><br>  Purely from prank, we try to gradually reduce each quad, starting from the upper right corner in the direction of the lower left corner.  Again, use the variable <i>gl_InstanceID</i> , because why not? <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec2 pos = aPos * (gl_InstanceID / <span class="hljs-number"><span class="hljs-number">100.0</span></span>); gl_Position = vec4(pos + aOffset, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); fColor = aColor; }</code> </pre> <br>  As a result, we get a picture where the first copies are rendered tiny, but as the number of the sample approaches 100, the size of each rectangle tends to the original.  This sharing of instantiated arrays and <i>gl_InstanceID is</i> completely valid. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4w/gg/ir/4wggir8wfgwa74_49prmmitqcsm.png"></div><br>  If you doubt that you have learned how to work with an instantiated renderer, or if you just want to study the structure of the entire example code, the source code is available <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/4.advanced_opengl/10.1.instancing_quads/instancing_quads.cpp">here</a> . <br>  All this, of course, is good, but these examples give a faint idea of ‚Äã‚Äãthe real usefulness of instancing.  Of course, the technical details are shown here, but the very essence of the instancing is revealed only when rendering a crazy amount of similar objects - something that we haven‚Äôt reached yet.  That is why in the next section we will have to go into outer space to see firsthand the true power of instancing. <br><br><h2>  Asteroid field </h2><br>  Imagine a scene where a huge planet is surrounded by a massive asteroid belt.  Such a belt may well contain thousands, or even tens of thousands of stony formations.  The output of such a scene will very quickly become almost impossible on any good video card.  But it is precisely in this scenario that the use of instancing suggests itself, since all the belt asteroids may well be represented by a single model.  Each asteroid will be slightly different from its neighbors due to the unique transformation matrix. <br><br>  To show the positive effect of instancing, we first try to bring this scene out without using it.  The scene will contain a large planet, the model of which can be downloaded <a href="">here</a> , as well as a large set of asteroids, located in a special way around the planet.  The asteroid model can be downloaded <a href="">here</a> . <br><br>  In the application code, we load the model data using the bootloader, which was analyzed in <a href="https://habrahabr.ru/post/338436">modeling</a> lessons. <br><br>  To achieve the required scene configuration, we will create a transformation matrix that is unique for each asteroid, which will be used as a model matrix for rendering each of them.  The matrix is ‚Äã‚Äãformed in several stages.  First, a transfer transform is applied to place the asteroid somewhere within the ring.  We also use a small random offset to add realism to the distribution of asteroids.  Next, a random scaling and rotation around the rotation vector is added.  As a result, we obtain a transformation matrix, which places each asteroid somewhere in the vicinity of the planet, at the same time providing its unique look.  And the asteroid belt is filled with a bunch of dissimilar stone blocks. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = <span class="hljs-number"><span class="hljs-number">1000</span></span>; glm::mat4 *modelMatrices; modelMatrices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> glm::mat4[amount]; srand(glfwGetTime()); <span class="hljs-comment"><span class="hljs-comment">//  seed   .  float radius = 50.0; float offset = 2.5f; for(unsigned int i = 0; i &lt; amount; i++) { glm::mat4 model(1.0f); // 1. :     'radius' //      [-offset, offset] float angle = (float)i / (float)amount * 360.0f; float displacement = (rand() % (int)(2 * offset * 100)) / 100.0f - offset; float x = sin(angle) * radius + displacement; displacement = (rand() % (int)(2 * offset * 100)) / 100.0f - offset; //     ,     XZ float y = displacement * 0.4f; displacement = (rand() % (int)(2 * offset * 100)) / 100.0f - offset; float z = cos(angle) * radius + displacement; model = glm::translate(model, glm::vec3(x, y, z)); // 2. :     (0.05, 0.25f) float scale = (rand() % 20) / 100.0f + 0.05; model = glm::scale(model, glm::vec3(scale)); // 3. :      float rotAngle = (rand() % 360); model = glm::rotate(model, rotAngle, glm::vec3(0.4f, 0.6f, 0.8f)); // 4.     modelMatrices[i] = model; }</span></span></code> </pre> <br>  This code snippet may seem daunting, but here we just place each asteroid in the XZ plane along a circle defined by the <i>radius</i> , and also add a small random offset within (- <i>offset</i> , <i>offset</i> ) relative to that circle.  We change the Y coordinate to a lesser degree, in order to give the asterodia ring the shape of the ring itself.  In addition, scaling and rotation is applied, and the result is stored in an array of <i>modelMatrices</i> of the amount of amount.  In this example, 1000 model matrices are created, one per asteroid. <br><br>  After loading the models of the planet and the asteroid, as well as compiling the shaders, you can proceed to the rendering code: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   shader.use(); glm::mat4 model(1.0f); model = glm::translate(model, glm::vec3(0.0f, -3.0f, 0.0f)); model = glm::scale(model, glm::vec3(4.0f, 4.0f, 4.0f)); shader.setMat4("model", model); planet.Draw(shader); //   for(unsigned int i = 0; i &lt; amount; i++) { shader.setMat4("model", modelMatrices[i]); rock.Draw(shader); }</span></span></code> </pre> <br>  First, we draw a model of the planet, which has to be slightly shifted and scaled to fit into the scene.  Then we render asteroids in an amount equal to the amount of the prepared array of transformations.  Before the withdrawal of each asteroid, we have to transfer the corresponding data to the uniforms containing the model matrix. <br><br>  It turns out a picture resembling a picture from space, with a fairly believable looking planet, surrounded by an asteroid belt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/89/uh/9j/89uh9jiz4bb2-htif2fijwih3e8.png"></div><br>  This scene performs 1001 calls to render functions per frame, 1000 of which fall on an asteroid model.  Sources are <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/4.advanced_opengl/10.2.asteroids/asteroids.cpp">here</a> . <br>  If we begin to increase the number of asteroids that we have extracted, we will quickly notice that the scene ceases to redraw smoothly, and the number of frames per second drops sharply.  As soon as we reach the attempt to bring out 2000 asteroids, the render becomes so irresponsive that simply moving in the scene is almost impossible. <br><br>  Now, try to do the same, but using instancing.  First, let's tweak the vertex shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec3 aPos; layout (location = 2) in vec2 aTexCoords; layout (location = 3) in mat4 instanceMatrix; out vec2 TexCoords; uniform mat4 projection; uniform mat4 view; void main() { gl_Position = projection * view * instanceMatrix * vec4(aPos, 1.0); TexCoords = aTexCoords; }</span></span></code> </pre> <br>  We no longer use uniforms containing a model matrix.  Instead, we declare a new vertex attribute that stores the matrix, in which we will place an instantiated array of transformation matrices.  It should be noted that when specifying a vertex attribute with a type size greater than the size of <i>vec4</i> , one particular feature must be taken into account.  Since <i>mat4</i> is essentially four connected <i>vec4</i> , as many as four indexes of the <i>location of the</i> vertex attribute will be reserved for this attribute.  Here, we assigned an allocation index to the attribute equal to 3, which means that the columns of the matrix receive the placement indexes 3, 4, 5 and 6. <br><br>  In the client code, we will have to set pointers to vertex attributes for each of these implicitly defined location indices.  And do not forget to initialize each of them as an instantiated array: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  VBO unsigned int buffer; glGenBuffers(1, &amp;buffer); glBindBuffer(GL_ARRAY_BUFFER, buffer); glBufferData(GL_ARRAY_BUFFER, amount * sizeof(glm::mat4), &amp;modelMatrices[0], GL_STATIC_DRAW); for(unsigned int i = 0; i &lt; rock.meshes.size(); i++) { unsigned int VAO = rock.meshes[i].VAO; glBindVertexArray(VAO); //   GLsizei vec4Size = sizeof(glm::vec4); glEnableVertexAttribArray(3); glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)0); glEnableVertexAttribArray(4); glVertexAttribPointer(4, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(vec4Size)); glEnableVertexAttribArray(5); glVertexAttribPointer(5, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(2 * vec4Size)); glEnableVertexAttribArray(6); glVertexAttribPointer(6, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(3 * vec4Size)); glVertexAttribDivisor(3, 1); glVertexAttribDivisor(4, 1); glVertexAttribDivisor(5, 1); glVertexAttribDivisor(6, 1); glBindVertexArray(0); }</span></span></code> </pre> <br>  I note that here we have flipped a little bit by declaring <i>VAO</i> as a public and not a private variable of the <i>Mesh</i> class - this allowed us to simplify access to the object of the vertex array.  Let not the most elegant and clean solution, but for the needs of a simple example will fit.  In addition to this small hack, the rest of the code should be clear.  Here we simply indicate how OpenGL should interpret the contents of the buffer for each element of the vertex attribute represented by the matrix.  We also indicate that each of these attributes is an instantiated array. <br><br>  Next, we again turn to the <i>VAO of the</i> prepared models and call the render: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// draw meteorites instanceShader.use(); for(unsigned int i = 0; i &lt; rock.meshes.size(); i++) { glBindVertexArray(rock.meshes[i].VAO); glDrawElementsInstanced( GL_TRIANGLES, rock.meshes[i].indices.size(), GL_UNSIGNED_INT, 0, amount ); }</span></span></code> </pre> <br>  Here the render is performed with the same number of asteroids as in the previous example, but now instancing is used.  Visually, the result will be similar.       .             1000  1500 .           100000 .  ,      576     57     -  ! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9m/qe/ll/9mqelllpw7ur9bqkh2dqtsymhii.png"></div><br><br>      100000    <i>radius = 150.0f</i>  <i>offset = 25.0f</i> .   ‚Äì <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/4.advanced_opengl/10.3.asteroids_instanced/asteroids_instanced.cpp"></a> . <br><blockquote>      ,    100000    .        ,     . </blockquote>  ,          .  ,      , ,     ,      ‚Äì    ,      . <br><br> <b>PS</b> :    <a href="https://t.me/joinchat/Cpb05A46UPpMWdNVVCb4Vg">-</a>   .       ,   ! </div><p>Source: <a href="https://habr.com/ru/post/352962/">https://habr.com/ru/post/352962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352948/index.html">Macro for Autodesk Revit that trim walls</a></li>
<li><a href="../352950/index.html">Be careful with copy-paste: fingerprinting text with unprintable characters</a></li>
<li><a href="../352952/index.html">System Shock source code is publicly available under the GPL</a></li>
<li><a href="../352954/index.html">Spring Boot. Background tasks and not only</a></li>
<li><a href="../352958/index.html">MBO, OKR, PPR: mix but not shake</a></li>
<li><a href="../352964/index.html">Issue # 17: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../352966/index.html">Program less, think more ... incrementally</a></li>
<li><a href="../352968/index.html">Conference DEFCON 22. ‚ÄúArming Your Pets. Fighting Kitty and Dog for denial of service. " Jen Brensfield</a></li>
<li><a href="../352970/index.html">How 64k intro is created today: immersion immersion</a></li>
<li><a href="../352972/index.html">From the Baltic Sea to the Indian Ocean</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>