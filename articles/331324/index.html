<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Oracle I / O Life: Tracing logical and physical I / O using SystemTap</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We invite all specialists to take part in the section dedicated to commercial databases at PG Day'17 Russia! Alexander Khalukhin from Deutsche Bank is...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Oracle I / O Life: Tracing logical and physical I / O using SystemTap</h1><div class="post__text post__text-html js-mediator-article">  <i>We invite all specialists to take part in the section dedicated to commercial databases at PG Day'17 Russia!</i>  <i>Alexander Khalukhin from Deutsche Bank is preparing an intensive master class on <a href="http://pgday.ru/ru/2017/papers/125%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dsystemtap2"><b>diagnosing the performance of the Oracle Database</b></a> .</i>  <i>Full list of speeches, see the program on the <b><a href="https://pgday.ru/ru/2017/schedule%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dsystemtap2">site</a></b> !</i> <i><br><br></i>  <i>And we continue to publish translations of articles from database specialists from CERN.</i>  <i>Today‚Äôs material is the second part of a series of articles on tracing and debugging Oracle DB performance using SystemTap.</i> <br><br><img src="https://habrastorage.org/web/025/44f/f65/02544ff65a7141a784b18e7de75d1a7b.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This article focuses on tracking logical and physical reads in Oracle using SystemTap.  Here you will find a few examples illustrating the basic mechanisms used by Oracle to perform physical and logical I / O operations, and learn how to create SystemTap scripts for later diagnosis and troubleshooting of Oracle I / O. <br><a name="habracut"></a><br>  <b>Introduction</b> <br><br>  Performing input / output from and to media, i.e.  <b>Physical I / O</b> is one of the most important tasks underlying all database engines.  When accessing data stored in an in-memory database cache, we can talk about <b>logical I / O.</b>  Physical I / O is performed by the database using OS kernel system calls.  The type of system calls used depends on the parameters of the database, OS and type of storage.  Logical I / O is performed by database processes using Oracle core functions.  Oracle provides the measurement of physical I / O call times using the <b>wait event</b> interface, and logical I / O time is generally counted as CPU time.  The I / O tracing performed by Oracle processes and supplemented by the details provided by the Oracle wait event interface is a powerful method for exploring the <b>internal</b> Oracle I / O device.  With a few real-life examples, we‚Äôll find out which mechanisms Oracle uses to access the repository, how I / O operations correlate to the wait event interface, and find out the time limit for the most common I / O wait events. <br><br>  <b>Creating a trace tool</b> <br><br>  Operations research that Oracle and OS perform when performing an I / O operation requires special tools.  <b>SystemTap</b> is a dynamic trace tool designed specifically for Linux that allows you to monitor both OS and Oracle functions (Linux kernel functions, system calls, and Oracle database engine functions).  The following is a description of a systemtap script that can be used to track the logical and physical I / O of Oracle: it consists of probes that can join interesting function calls and <b>read function parameters, memory, and processor registers</b> . <br><br>  Systemtap requires relatively recent kernel versions to be able to profile userspace: utrace or uprobe_events functionality must be available.  For example, RHEL / OL 6.5 and higher is suitable, but not RHEL 5. In addition, the <b>debuginfo</b> kernel package must be installed for the trace system calls. <br><br>  You can read more about this and how to create a test environment in <a href="https://habrahabr.ru/company/pgdayrussia/blog/330024/">this article</a> .  The script that we use in this post to trace the logical and physical I / O of Oracle, as well as the interface of wait events, looks like this: <a href="">trace_oracle_logicalio_wait_events_physicalio_12102.stp</a> (for Oracle 12.1.0.2).  An option for version 11.2.0.4 is also available: <a href="">trace_oracle_logicalio_wait_events_physicalio_11204.stp</a> .  Before turning to the Oracle I / O study examples, I would like to look at three main parts of the script: tracking physical I / O, logical I / O, and wait events. <br><br>  <b>Physical I / O tracking</b> <br><br>  Ultimately, Oracle makes system calls to perform I / O operations.  The type of calls depends on the parameters of the database, the type of OS and the type of storage.  In this article, you can find examples for Oracle on <b>Linux</b> , using <b>ASM</b> storage on block devices.  Please note that direct NFS, local storage and ASM with asmlib were not included in the article and may be considered in future studies.  System calls can be traced including using the <b>strace</b> (1) utility on Linux.  However, in this article you will see how probes SystemTap can be created to collect information about system calls of interest: <b>pread, pwrite, io_submit, and io_getevents</b> .  The following SystemTap probes can be useful for the ‚Äúunderlying‚Äù block I / O layer: ioblock.request, ioblock_trace.request and ioblock.end (note that these are not system calls, but trace points for function calls inside the Linux kernel). <br><table><tbody><tr><td>  <b>Probe name</b> </td><td>  <b>Function</b> </td><td>  <b>Selected parameters</b> </td></tr><tr><td>  <b>syscall.pread / pwrite</b> </td><td>  Synchronous I / O: read / write from / to the file descriptor </td><td>  fd (file descriptor number), offset, number. <br>  Return value: read / written byte </td></tr><tr><td>  <b>syscall.io_submit</b> </td><td>  Asynchronous I / O: sending blocks for processing </td><td>  nr (number of I / O operations).  For each operation: file descriptor, offset, bytes, operation code (0 for reading, 1 for writing) <br>  Return value: the number of I / O operations performed </td></tr><tr><td>  <b>syscall.io_getevents</b> </td><td>  Asynchronous I / O: reading events from a run queue </td><td>  min_nr (minimum number of I / O operations for reading), timeout waiting for an event. <br>  Return value: the number of collected I / O operations, <br>  For each operation: file descriptor, offset, bytes. </td></tr><tr><td>  <b>ioblock.request, ioblock_trace.request</b> </td><td>  I / O requests sent to the block device interface level </td><td>  devname, sector, size, rw, address of block_io structure </td></tr><tr><td>  <b>ioblock.end</b> </td><td>  Returning from the kernel level of the block device interface </td><td>  devname, sector, rw, address of block_io structure </td></tr></tbody></table><br>  Note added in August 2015: Systemtap probes for <b>kernel.trace ('block_rq_issue')</b> and <b>kernel.trace ('block_rq_complete')</b> can also be used to examine the block I / O interface with the added advantage: they do not require a kernel debuginfo.  Examples of such probes can be found on the <a href="http://canali.web.cern.ch/canali/resources.htm">downloads</a> page or on <a href="https://github.com/LucaCanali/Linux_tracing_scripts/tree/master/SystemTap_Linux_IO">GitHub</a> . <br><br>  <b>Logical I / O Tracking</b> <br><br>  This is the history and details of logical I / O operations when Oracle reads a block of data from memory (buffer cache).  <b>Logical I / O</b> operations include a subset of physical I / O operations: if Oracle does not find the data in memory ( <b>buffer cache</b> ), it performs a physical read.  You can find several examples of this mechanism in action later in this article. <br><br>  The Oracle toolkit provides extensive information about logical readings in several V $ views, such as <b>V $ SYSSTAT</b> , V $ SESSTAT, V $ SYSMETRIC.  Also data on logical readings are available from sql * plus with the ‚Äúset autotrace on‚Äù parameter and with tkprof reports on <b>event traces 10046</b> .  Logical readings are of two main types: consistent and current.  Oracle will use consistent reads when reading data with a given system change number SCN, current reads are used when performing DML operations on a block.  Consistent reads can be traced to Oracle using <b>events 10200 and 10201</b> .  More information can be found in the <a href="http://www.juliandyke.com/Presentations/Presentations.html">Julian Dyke</a> presentation <a href="http://www.juliandyke.com/Presentations/Presentations.html">on logical I / O.</a> <br><br>  In this article, we will show how to track logical I / O by connecting the SystemTap probes to the Oracle kernel feature set.  The role of the <b>kcbgtcr</b> and <b>kcbgcur functions</b> for the consistent and current reads tracing has already been discussed by Alexander Anokhin in his excellent articles on <a href="http://alexanderanokhin.wordpress.com/2012/03/19/dtrace-lio-new-features/">Dtrace LIO</a> .  Most recently, I researched this topic and found it useful to also trace the functions <b>kcbzib, kcbzgb, kcbzvb</b> . <br><br>  A summary of what I found out about these functions is given in the table below.  Note: the expressions% rdi,% rsi,% r8 indicate the values ‚Äã‚Äãof the corresponding <b>processor registers</b> .  Using SystemTap, the register value can be read using the register function, for example: register ('rdi').  CPU registers are used to retrieve <a href="http:">function call arguments</a> .  Systemtap does not provide function call arguments when there are no debug symbols for the executable file.  In particular, <b>the calling conventions</b> for x86-64, as described at <a href="http://www.x86-64.org/documentation/abi.pdf">www.x86-64.org/documentation/abi.pdf</a> , indicate that the integer parameters for the function call are available in the following registers (in order):% rdi,% rsi ,% rdx,% rcx,% r8 and% r9. <br><table><tbody><tr><td width="120">  <b>Function name</b> </td><td width="300">  <b>Task to be performed</b> </td><td>  <b>Selected parameters</b> </td></tr><tr><td>  <b>kcbgtcr</b> </td><td>  Kernel Cache Buffers Get Consistent Read <br>  Used for consistent reads </td><td>  tbs # = user_int32 (% rdi) <br>  rel file n # = user_int32 (% rdi + 4) &gt;&gt; 22 &amp; 0x003FFFFF <br>  block # = user_int32 (% rdi + 4) &amp; 0x003FFFFF <br>  data_object_id # = user_int32 (% rdi + 8) <br>  object_id # = user_int32 (% rdi + 12) <br><br>  Note: for bigfile tablespaces: <br>  block # = user_int32 (% rdi + 4) </td></tr><tr><td>  <b>kcbgcur</b> </td><td>  Kernel Cache Buffers Current <br>  Used for current reads </td><td>  tbs # = user_int32 (% rdi) <br>  rel file n # = user_int32 (% rdi + 4) &gt;&gt; 22 &amp; 0x003FFFFF <br>  block # = user_int32 (% rdi + 4) &amp; 0x003FFFFF <br>  data_object_id # = user_int32 (% rdi + 8) <br>  object_id # = user_int32 (% rdi + 12) <br><br>  Note: for bigfile tablespaces: <br>  block # = user_int32 (% rdi + 4) </td></tr><tr><td>  <b>kcbzib</b> </td><td>  kcbZIB stands for: Z (kcbz.o is a module for auxiliary functions of physical input-output), IB: Input Buffer <br>  Oracle will perform the physical read (s) in the buffer cache </td><td></td></tr><tr><td>  <b>kcbzgb</b> </td><td>  The suffix GB in kcbZGB stands for: Get (space for) Buffer <br>  Oracle allocates space in the buffer cache for a given block (usually before I / O operations). </td><td>  tbs n # =% rsi <br>  rel file n # =% rdx &gt;&gt; 22 &amp; 0x003FFFFF <br>  block # =% rdx &amp; 0x003FFFFF <br>  data_object_id # =% r8 <br>  object_id # =% r9 <br><br>  Note: for bigfile tablespaces: <br>  block # =% rdx </td></tr><tr><td>  <b>kcbzvb</b> </td><td>  Called after Oracle read a given block <br>  This is part of the call chain for checking blocks managed by the db_block_checking parameter.  Alleged decryption: Kernel cache buffer verify block.  Thank you @FritsHoogland for this clarification. <br><br>  This function is used for both reads in the buffer cache and direct reads. </td><td>  tbs n # =% rsi <br>  rel file n # =% rdx &gt;&gt; 22 &amp; 0x003FFFFF, <br>  block # =% rdx &amp; 0x003FFFFF <br>  data_object_id = user_int32 (% rdi + 24) <br>  Note: for bigfile tablespaces: <br>  block # =% rdx </td></tr></tbody></table><br>  <b>Note</b> : at the time of this writing, only uprobes for kernels of version 3.10 and above support returned probes for userspace functions.  Therefore, this functionality is not available in RHEL or OL 6.x, but is available in RHEL 7.x cores. <br><br>  <b>Tracking wait events</b> <br><br>  The <b>wait-event</b> interface is probably one of the <b>best features</b> in Oracle performance tuning, as it provides a quantitative method for identifying performance problems and bottlenecks.  <a href="https://twitter.com/CaryMillsap">Cary Millsap has</a> published an <a href="http://www.amazon.com/s/ref%3Ddp_byline_sr_book_1%3Fie%3DUTF8%26field-author%3DCary%2BMillsap%26search-alias%3Dbooks%26text%3DCary%2BMillsap%26sort%3Drelevancerank">inspiring work</a> on this topic. <br><br>  For our purposes, it is enough to indicate that wait events are control points (instrumentation points) in which the selected actions of the Oracle core are measured.  In particular, Oracle will mark the initial and final calls for most physical I / O operations, thus allowing you to understand well <b>how much time is spent</b> in the physical I / O process (some limitations of this mechanism are discussed later in this post).  There are <b>restrictions</b> on using the wait event interface to study <b>I / O latency</b> , in particular, in the examples section you can find interesting problems related to measuring the duration of <b>asynchronous</b> I / O events. <br><br>  Tracing wait events is usually activated in Oracle using <a href="http://oracle-base.com/articles/misc/sql-trace-10046-trcsess-and-tkprof.php">event 10046</a> or by calling DBMS_MONITOR.SESSION_TRACE_ENABLE.  In this article, we get the details of the wait event by attaching the probes SystemTap to the corresponding functions of the Oracle kernel, namely <b>kskthbwt</b> and <b>kskthewt</b> , to collect information at the beginning and at the end of each wait event, respectively.  Enabling the tracing of wait events using event 10046 at level 8 and other methods is a way to retrieve information about the time of a wait event (as well as other details about SQL processing), rather than a way to include wait information.  This, in turn, is done using the TIMED_STATISTICS database parameter, and in modern Oracle databases it should be set to TRUE.  The key part of the information that the Oracle kernel kskthbwt and kskthewt functions give us is a <b>pointer to the X $ KSUSE utility table</b> (or rather, the ‚Äúunderlying‚Äù memory structure in the SGA), which is the ‚Äúunderlying‚Äù table for V $ SESSION and, therefore, it allows you to match wait events with a wealth of useful information about a session executing SQL  Pointer dereferencing in the <b>register r13</b> to the base value X $ KSUSE and calculating the offset for the fields of interest requires additional work, described <a href="https://habrahabr.ru/company/pgdayrussia/blog/330024/">in</a> detail <a href="https://habrahabr.ru/company/pgdayrussia/blog/330024/">in the previous article</a> (see also the script: <a href="">ksuse_find_offsets.sql</a> ). <br><table><tbody><tr><td width="120">  <b>Function name</b> </td><td width="300">  <b>Task to be performed</b> </td><td>  <b>Selected parameters</b> </td></tr><tr><td>  <b>kskthbwt</b> </td><td>  Kernel service Kompile thread begin wait. <br>  This function is called at the beginning of the Oracle wait event. <br>  kslwtbctx is a call to its parent function and marks the start of a wait event. </td><td>  Useful information for profiling function: <br>  register r13 -&gt; points to a segmented X $ KSUSE array (V $ SESSION) in the SGA <br>  register rsi -&gt; timestamp start waiting (in microseconds) <br>  register rdx -&gt; number of wait events </td></tr><tr><td>  <b>kskthewt</b> </td><td>  Kernel service Kompile thread end wait. <br>  This function is called at the end of the Oracle wait event. <br>  kslwtectx is a parent function call that marks the end of a wait event. <br>  The ‚Äúewt‚Äù suffix most likely means ‚Äúend wait‚Äù. </td><td>  Useful information for profiling function: <br>  register r13 -&gt; points to a segmented X $ KSUSE array (V $ SESSION) in the SGA <br>  register rdi -&gt; wait timestamp (in microseconds) <br>  register rsi -&gt; number of wait events </td></tr></tbody></table><br>  <b>Running script</b> <br><br>  Below you will find several trace examples for common Oracle I / O access patterns.  <b>Traces</b> were obtained by the command <b>stap -v trace_oracle_logicalio_wait_events_physicalio_12102.stp -x _pid_</b> , where _pid_ is the process identifier of the monitored session.  The result is sent to <b>sed -f eventsname.sed</b> , where the translation of the event number into its associated name is provided.  The eventsname.sed file is created by running the eventsname.sql script.  It is important to restart the script to generate event names before testing, as wait event numbers may change without warning, for example, after migrating to newer versions or after installing a patch.  The system used to collect traces in the following examples is Oracle 12.1.0.2, running on OEL 7.0 with UEK3 under Virtualbox. <br><br>  <b>Example 1: single-block random reads</b> <br><br>  This example is categorized as single block random reads.  This way of accessing data is very important for many <b>OLTP workloads</b> , since it is used to access a table through an index key.  In Figure 1 below, you can see a fragment of the trace file for the <i>select</i> query type <i>col_list from table tab where indexed_col = val</i> . <br><br><img src="https://habrastorage.org/web/08a/b65/5a3/08ab655a365b4aa889a505964322af8b.png"><br>  Fig.  1: Oracle Single-block random read and sequential read wait event from db file <br><br>  <b>Key points</b> : <br><br><ul><li>  <b>Oracle performs a logical read of</b> one of the blocks needed to retrieve data for SQL in this example: <br><ul><li>  the logical read call contains additional information, which shows that Oracle wants to read block # = 2505675 from tbs # = 7, belonging to obj # = 32174 (which is a table segment in this example); </li></ul></li><li>  the block was not found in the cache, so a new block is allocated in the buffer cache and a physical read is initiated; </li><li>  The database marks the start of the wait event for 'db file sequential read'; </li><li>  <b>the physical read request for the block becomes a pread call to the OS:</b> <br><ul><li>  IO request is sent to the kernel through a system call;  any function that occurs after the system call is a kernel function (for example, ioblock.request) until the system call is completed and, thus, it does not again end up in userland (in this case, the Oracle executable file). </li></ul></li><li>  This read function call is passed to <b>the block I / O interface for reading 8192 bytes</b> (1 database block) from the block device (/ dev / sdl in the example in Figure 1); </li><li>  the block interface and then the OS call return the read data to the Oracle kernel; </li><li>  The Oracle wait interface marks the end of the wait and calculates the elapsed time: <br><ul><li>  wait event - ‚Äúdb file sequential read‚Äù, parameters: p1 ‚Äî file number, p2 ‚Äî block number, p3 ‚Äî number of blocks read (1 block); </li><li>  from the timestamp values ‚Äã‚Äãin the trace, you can see that the <b>wait time for a sequential read db file depends on the time taken to complete the pread call</b> at a low cost (note that the overhead could be more significant if we had a high load CPU on the database server, for example, due to workload from other Oracle sessions). </li></ul></li><li>  We can conclude that in this example, the <b>measured wait time for the sequential read of the db file corresponds to the delay associated with the physical reading</b> . </li></ul><br>  <b>Example 2: Sequential I / O Buffer Cache with Synchronous I / O</b> <br><br>  In this example, we are talking about <b>multi-block reads</b> in the cache.  This is the access method that is used, for example, when Oracle performs a <b>full table scan</b> .  There are several ways in which Oracle can access the repository to perform a full table scan, in this example you see a case where Oracle uses synchronous I / O (i.e., pread) to perform OS read operations, examples 3 and 4 encompass sequential reads with asynchronous I / O.  In Figure 2 below, you can see the workload tracking snippet of the <i>select</i> type of the <i>col_list form table tab</i> , Oracle performs a full scan of the tab table. <br><br><img src="https://habrastorage.org/web/042/7e2/540/0427e25403db4e6ebf5924b366b4b8a9.png"><br>  Fig.  2: Oracle Sequential I / O when reading is performed using pread OS calls <br><br>  <b>Key points of the</b> trace in Figure 2: <br><br><ul><li>  Oracle performs a sequential read for tbs # = 7 block # = 2621443 and finds it in the cache. </li><li>  Oracle performs consistent read for the next block, does not find it in the cache, so it <b>prepares to read the list of blocks from the repository in one physical read</b> .  This list consists of 124 blocks (it was shortened in this example for simplicity). </li><li>  The database marks the start of the wait event <b>‚Äúdb file scattered read‚Äù</b> . </li><li>  Physical read requests become a single pread call to the OS to get 1015808 bytes (124 blocks). </li><li>  This query moves down the I / O chain to <b>block I / O interfaces, which divide it by 2 reads</b> from the ‚Äúunderlying‚Äù block device, since the system used for tests has a maximum I / O size of 524288 bytes. <br><ul><li>  According to the Fritz Hoogland study, the submitted I / O request is placed on the I / O scattered / gather list, where it is broken down to the I / O sizes declared by the block device. </li></ul></li><li>  The I / Os are performed by the block I / O interface. </li><li>  Callback pread. </li><li>  The wait event interface marks the wait time. <br><ul><li>  The wait event is db file scattered read, and the parameters are: p1 is the file number, p2 is the block number, p3 is the number of blocks. </li><li>  From the timestamp values ‚Äã‚Äãin the trace, it can be seen that the <b>duration of waiting for the scattered read db file is mainly due to the time it takes to complete the pread call</b> , at low cost. </li></ul></li><li>  From the trace of the Oracle kernel kcbzvb function calls, we get additional confirmation of blocks that have been read. </li><li>  It can be concluded that <b>in this example, the db scattered read timeout corresponds to an I / O delay</b> . </li></ul><br>  <b>Example 3: Sequential I / O to the buffer cache with calls to the asynchronous I / O functions of the OS</b> <br><br>  In Figure 3, you can see the SQL trace fragment <i>select col_list from table tab</i> , where Oracle performs a full scan of the tab table.  This is the same query that was used in Example 2, the difference is that the trace in Figure 3 was made at a later stage of the query when the Oracle process switched from using synchronous I / O using pread calls to using <b>the asynchronous</b> I / O <b>interface.</b> .  Asynchronous I / O is implemented in Linux by calling <b>io_submit</b> and <b>io_getevents</b> to send I / O requests and get results.  Despite the fact that in this example, Oracle uses an asynchronous interface to perform read operations, the end result is very similar to the result presented in example 2 (that is, using synchronous I / O).  The same Oracle wait event, <b>‚Äúdb file scattered read,‚Äù</b> reads are also performed in the buffer cache, and the I / O results are collected using blocking calls, which actually makes the process synchronous.  A more ‚Äúaggressive use‚Äù of the interface for asynchronous I / O occurs in Oracle when performing direct reads, which are discussed in Example 4 below. <br><br><img src="https://habrastorage.org/web/8f8/802/870/8f8802870e26410d8140127e3e9b196c.png"><br>  Fig.  3: Oracle performing sequential I / O reads to buffer cache using asynchronous I / O calls <br><br>  <b>Key points</b> : <br><br><ul><li>  Oracle performs a consistent read for tbs # = 7 block # = 2522760, does not find it in the cache, so it prepares to read the list of blocks in the buffer cache.  This list consists of 128 blocks and is abbreviated in this example. </li><li>  The database marks the start of the wait event for <b>‚Äúdb file scattered read‚Äù</b> . </li><li>  Requests for physical reading are transmitted to the OS as a call to io_submit with two requests with a total size of 1 MB (that is 128 blocks): the first request is for reading (opcode 0) of 65536 bytes, the second for the read operation of 983040 bytes (that is, 1 MB - 64 KB). </li><li>  These requests <b>are sent to the block I / O interface</b> , which separates the largest request by 2 reads from the ‚Äúunderlying‚Äù block device (/ dev / sdi in this example).  A 64 KB read is passed to / dev / sdr without any change in size. </li><li>  Oracle calls <b>io_getevents to get the results of the</b> asynchronous I / O requests it has just sent, and waits.  The timeout.tv_sec field is set to 600, which indicates that this <b>blocking wait</b> (this means that io_getevents expects 600 seconds (tv_sec) and 0 nanoseconds (tv_nsec)) to complete min_nr = 2 IO operations. </li><li>  The block device interface returns data up the call chain. </li><li>  Calling io_getevents returns two reads. </li><li>  The wait event interface marks the end of the wait.  The wait event in this case is the scattered read of the db file. <br><ul><li>  Parameters of the wait event: p1 is the file number, p2 is the block number, p3 is the number of blocks. </li><li>  The duration of a wait event is basically the time spent on io_submit and io_getevents calls, plus a small overhead. </li><li>  Notice that while Oracle used an asynchronous interface, it also waited for all I / O operations to complete, <b>so I / O operations are, in fact, synchronous</b> . </li></ul></li><li>  From calls to kcbzvb we get additional confirmation of the read blocks. </li><li>  Conclusion: The <b>db scattered read</b> timeout in this example is <b>not an accurate measure of I / O delays</b> , since <b>two reads on two different devices were requested in parallel</b> , and the total time was reflected as if it were one read. </li></ul><br>  <b>Example 4: full scans using direct reads and asynchronous I / O</b> <br><br>  In this section, you will find two examples of Oracle I / O in the case of <b>direct reads</b> in block storage configured with <b>ASM</b> .  It uses the same query that performs the <b>full table scan</b> as examples 2 and 3. In this example, unlike examples 2 and 3, Oracle uses the serial direct read to access the data.  <b>Serial direct read is a function that appeared in 11gR2</b> to optimize full segment scan operations and <b>bypass the buffer cache layer</b> , similar to what happens with parallel queries.  Oracle chooses when to use serial direct reads instead of cached reads based on several parameters.  In the first approximation, direct reads are preferable when the table is ‚Äúlarge‚Äù compared to the size of the buffer cache, but the actual mechanism is more complicated and could potentially change depending on the version of Oracle.  You can find out more about this topic in the <a href="http://blog.tanelpoder.com/2012/09/03/optimizer-statistics-driven-direct-path-read-decision-for-full-table-scans-_direct_read_decision_statistics_driven/">article by Tanel Poder</a> . <br><br>  To run these tests, I had to force the use of serial direct reads before launching the request, this was done using <i>alter session set "_serial_direct_read" = always;</i>  . <br><br>  Note that the request <i>alter session set "_serial_direct_read" = never;</i>  can be used to disable serial direct reads and force Oracle to use cached reads (that is, the type of I / O that you saw in examples 2 and 3 above).  The default value for the ‚Äú_serial_direct_read‚Äù parameter is ‚Äúauto‚Äù. <br><br>  For research in this example, we can use a slightly different SystemTap probe than the previous ones.     -   -   ,     probe   <b>userspace io_getevents_0_4  libaio</b> (libaio ‚Äî   Linux,    -).    ,  serial direct reads        -,         libaio  ,  <a href="http://fritshoogland.wordpress.com/2014/03/11/linux-strace-doesnt-lie-after-all/">  (Frits Hoogland)   </a> .  SystemTap,   . 4a  4,   : <a href="">trace_oracle_wait_events_asyncio_libaio_12102.stp</a> (  11.2.0.4    <a href="">trace_oracle_wait_events_asyncio_libaio_11204.stp</a> ). <br><br><img src="https://habrastorage.org/web/a49/d56/afa/a49d56afab7643a3b2960e2ad9cabf5d.png"><br>  Fig. 4a:      Oracle I/O   full table scan  serial direct read   -.  ,      full scan <br><br> <b> </b>  4a: <br><br><ul><li> Oracle  -      1 .        , ,  readahead,   . <br><ul><li>  1         db_file_multiblock_read_count=128,     ‚Äî 8 . </li></ul></li><li> Oracle    -  1    <b>io_submit</b> ,    <b>io_getevents_0_4</b>   libiao,   ,    .   ,  - .  Oracle      1   4         -  ( -   ). </li><li>         io_getevents,      -,       (   600 ). <br><ul><li>       <b>¬´direct path read¬ª</b> . </li><li> Oracle     -     <b>io_getevents</b> . </li></ul></li><li>    - Oracle    . </li><li>     2 ,  1  . </li><li> <b>         -</b> : <br><ul><li>  ¬´direct path read¬ª        128  (1 MB),    2 MB. </li></ul></li><li> <b>     ¬´direct path read¬ª    -</b> . <br><ul><li> Oracle     io_getevents,      -. </li><li> Oracle   2  . </li></ul></li></ul><br>  <b>serial direct reads</b>  Oracle <b></b> ,   ,   . 4a.      <a href="http://fritshoogland.files.wordpress.com/2013/02/about-multiblock-reads-v3-as43.pdf">  direct reads  Oracle   </a> .  , Oracle  <b></b>   direct reads        ,   .         -     -.     I/O slots.  ,      <b> Oracle 10353</b>         : ¬´ (slots) ‚Äî   -,        -¬ª. <br><br>       ,  <b>  -,   direct reads,       </b> .   ,  Oracle    io_getevents  timeout=0,    -  .           .  4b.      full scan,     4,     ,   adaptive serial direct reads  <b> Oracle I/O,    ¬´ ¬ª</b>    . <br><br><img src="https://habrastorage.org/web/fea/64c/2b1/fea64c2b14cb47419c31ee77fbb29f5e.png"><br>  Fig.  4b.      Oracle I/O    full table scan   serial direct read   -.   ,  ,        -     <br><br> <b> </b>  4: <br><br><ul><li>    full scan,    . 4a.   ,     4         full scan (  1  ),  adaptive serial direct reads    - (   -). </li><li>   ,    io_submit       . </li><li> Oracle        -:      -     4,           4a (..   full scan)   2 . </li><li>     -    io_getevents   Oracle      : <br><ul><li> <b>  ,  1  ,    io_getevents      ,          </b> . </li><li>  ,   Oracle  -     io_getevents (    io_getevents_0_4  libaio,    -  -)  0,   ,  Oracle  ,   -  ,       ,   . </li></ul></li><li>  ,  Oracle     " <b>direct path read</b> ",       3  io_getevents ( -,   600,      ),      9 ,  1  . <br><ul><li> <b>         -</b> : <br><ul><li>           1  (128 ),       9 . </li><li>      2    instrumentation  . </li></ul></li><li> <b>   ¬´db file direct read¬ª      -</b> , , ,      -,     4. </li></ul></li></ul><br> <b> 5:  -  random reads</b> <br><br> Oracle  single-block reads  ,       /   -.    random I/O     -,  Oracle     -    io_submit,       ,    1,    pread OS.   . 5    <a href="https://kevinclosson.net/slob/"> SLOB   (Kevin Closson)</a>    12c.     3  ,  Oracle   ¬´TABLE ACCESS BY INDEX ROWID BATCHED¬ª     . <br><br><img src="https://habrastorage.org/web/032/300/8a0/0323008a0c984111ab5ce8a0c6646e19.png"><br>  Fig. 5:    SLOB,    (batch access)   <br><br>   6       Oracle I/O     SLOB.   ,   -    random I/O.  ,   . 6, 126      io_submit,        io_getevents,    .      ‚Äî ¬´db file parallel read¬ª,     ‚Äî      126 .  <b>  db file parallel read      -  single block random reads</b> . <br><br><img src="https://habrastorage.org/web/5d6/2f2/32c/5d62f232c2fd4d48a3b9f39d19d81ad3.png"><br>  Fig. 6: Oracle,  -      -,    batched reads.           ( 126 ,    block#)  "..." <br><br> <b> 6:  DML</b> <br><br>   7     Oracle logical I/O        ,    .      -   (   ).   ,          current read,     DML.  ,      (      7   tbs#=11),   rollback segments (      7   tbs#=2).  ,          . <br><br><img src="https://habrastorage.org/web/773/5d2/827/7735d28272454d7796dd031f83c7592b.png"><br>  Fig. 7: Oracle logical I/O,     commit <br><br> <b> 7:  log writer</b> <br><br>   8     log writer    commit.     commit,     6 (.  . 7 ).   ‚Äî ¬´log file parallel write¬ª,     Oracle        -. ,     <b>¬´log file parallel write¬ª       ,        </b> .  ,    8,   ,  log writer       ,     1 redo-  ,   ASM-    normal: log writer  2   -  ‚Äî       - ‚Äî     . <br><br><img src="https://habrastorage.org/web/e87/773/231/e877732319084a7b98985c35cad8d593.png"><br>  Fig. 8:  log writer    commit <br><br>  <b>Conclusion</b> <br><br>   ,  , <b>SystemTap</b>  <b></b>      Oracle I/O,       <b>  Oracle I/O</b>     Oracle     Linux.      ,    ,      . <br><br>      Oracle         Oracle I/O  <b>       OS</b> ,   Oracle.    Oracle      <b>  -</b>     <b>  -</b> .    random reads,      ¬´db file sequential read¬ª.  ,   ,   <b> -,   </b> :          -.  ,     ,      -  Oracle direct reads     . <br><br> <b></b> :      <b> </b>  <b> </b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for original ideas that inspired this work. </font><font style="vertical-align: inherit;">Special thanks to Fritz Hugland, who generously shared with me his deep expertise on this issue. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Download scripts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : The </font><b><font style="vertical-align: inherit;">scripts</font></b><font style="vertical-align: inherit;"> discussed in this article can be found on the webpage with </font></font><a href="http://canali.web.cern.ch/canali/resources.htm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">downloads</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or on </font></font><a href="https://github.com/LucaCanali/Linux_tracing_scripts"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/331324/">https://habr.com/ru/post/331324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331310/index.html">LSTM ‚Äî Long Short-Term Memory Networks</a></li>
<li><a href="../331312/index.html">How to win in Vkontakte repost contests?</a></li>
<li><a href="../331314/index.html">An example of the synthesis of asynchronous SI circuits in a two-way element base: C-element</a></li>
<li><a href="../331316/index.html">CSS: introduction to the unit of length 'fr'</a></li>
<li><a href="../331318/index.html">Announcement DotNext 2017 Moscow: a double portion of .NET</a></li>
<li><a href="../331326/index.html">How to protect your data with the blockchain</a></li>
<li><a href="../331328/index.html">How to improve legacy code</a></li>
<li><a href="../331330/index.html">UNIGINE C ++ School: a free online course for advanced</a></li>
<li><a href="../331332/index.html">Virtual Reality at the White Nights Game Devils Conference</a></li>
<li><a href="../331334/index.html">Technological trends and current SDN solutions for data centers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>