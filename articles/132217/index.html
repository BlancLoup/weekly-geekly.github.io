<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pseudorandom number generation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quite often, programmers in their work are faced with the need to work with random numbers. Most often, random numbers are required in problems of mod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pseudorandom number generation</h1><div class="post__text post__text-html js-mediator-article">  Quite often, programmers in their work are faced with the need to work with random numbers.  Most often, random numbers are required in problems of modeling, numerical analysis and testing, but there are many other very specific tasks. <br>  Of course, in all modern programming languages ‚Äã‚Äãthere is a function random or its analogs.  These functions most often give really good pseudo-random numbers, but I always wondered how these functions work. <br>  In this topic, I will try to explain how the linear congruent method works (which is most often used in the random function) and the method for obtaining random numbers using a polynomial counter (which is often used to test hardware). <a name="habracut"></a><br><h4>  Introduction </h4><br>  It should immediately be said that it makes sense to generate random numbers only with a uniform distribution law, since  all other distributions can be obtained from the uniform by transformations known from probability theory. <br>  For those who have forgotten or have not yet studied probability theory, let me remind you that in a uniformly distributed sequence of zeroes and ones, zeroes on average (!) Will occur in 50% of cases.  But this does not mean that in a sequence of 1000 digits there will be exactly 500 zeros.  Moreover, in a sequence of 1000 digits there can be 999 zeros, and the probability that the thousandth element will be zero still remains equal to 0.5.  At first glance, this seems paradoxical, but it is important to understand that all sequences are equally probable.  If we consider a sufficiently large set of such sequences, then on average (!) In each of them there will be 500 zeros. <br>  Having a little remembered the theory, we will pass to history.  In precomputer times, random numbers were obtained by pulling colored balls out of bags, pulling cards, throwing dice.  It is clear that serious studies could not be conducted this way, so in 1927 Tippett published the first table of random numbers.  A little later, people tried to somehow automate this process.  Random number machines began to appear.  Now such devices are also used and are called entropy sources (generators).  It is worth noting that only such devices can give truly random numbers.  But, unfortunately, entropy generators are quite expensive, and it is not possible to install them in each PC.  That is why there was a need for algorithms for obtaining random numbers. <br><h4>  First attempt to obtain a memory bandwidth </h4><br>  Some people think that getting random numbers is easy.  In their opinion, it is enough for this to do random complex mathematical operations on the original number.  If we open the second volume of the well-known Knut, we will learn that in 1959 Knut also tried to build a generator based on such an idea.  His algorithm looked like this: <br>  K1.  [Select the number of iterations.] Assign Y to the largest significant digit of X. (We will perform steps K2-K13 exactly Y + 1 times, i.e., apply randomized transformations a random number of times.) <br>  K2.  [Select a random step] Assign the next most significant digit X. Go to step K (3 + Z), i.e., to a randomly selected step in the program. <br>  KZ  [Provide&gt; 5 x 109] If X &lt;5000000000, assign X the value X + 5000000000. <br>  K4.  [The middle of the square.] Replace X with the middle of the square X. <br>  K5.  [Multiply.] Replace X with the number (1001001001 X) mod 1010. <br>  K6.  [Pseudo-completion.] If X &lt;100000000, then assign X the value X + 9814055677;  otherwise, assign X to the value 1010- X. <br>  K7.  [Rearrange the halves.] Swap the five lower-order characters with the older ones. <br>  K8.  [Multiply.] Perform step K5. <br>  K9.  [Shrink digits.] Shrink each non-zero decimal number of X by one. <br>  K10.  [Modify to 99999.] If A '&lt;105, assign the X value to X 2 +99999;  otherwise, assign X to X - 99999. <br>  K11.  [Normalize.] (At this step, A 'cannot be zero.) If X &lt;109, then multiply X by 10. <br>  K12.  [Modification of the center square method.] Replace X with the average 10 digits of the number X (X - 1). <br>  K13  [Repeat?] If Y&gt; 0, decrease Y by 1 and return to step K2.  If Y = 0, the algorithm is complete.  The value of the number X obtained in the previous step will be the desired "random" value. <br>  Despite the apparent complexity, this algorithm quickly came down to the number 6065038420, which in a small number of steps was transformed into itself.  The moral of this story is that you cannot use a random algorithm to get random numbers. <br><h4>  Linear congruential method </h4><br>  In most programming languages, this method is used in the standard function for obtaining random numbers.  This method was first proposed by Lehmer in 1949.  Choose 4 numbers: <br><ol><li>  Module m (m&gt; 0); </li><li>  The factor a (0 &lt;= a &lt;m); </li><li>  Increment c (0 &lt;= c &lt;m); </li><li>  The initial value of X <sub>0</sub> (0 &lt;= X <sub>0</sub> &lt;m) </li></ol><br>  The sequence is obtained using the following recurrent formula: X <sub>n + 1</sub> = (a * X <sub>n</sub> + c) mod m. <br>  This method gives really good pseudo-random numbers, but if we take the numbers m, a, c arbitrarily, the result will most likely disappoint us.  When m = 7, X <sub>0</sub> = 1, a = 2, c = 4, we get the following sequence: 1,6,2,1,6,2,1, ... <br>  Obviously, this sequence does not quite fit the definition of random.  However, this failure allowed us to draw two important conclusions: <br><ol><li>  The numbers m, a, c, X <sub>0</sub> should not be random; </li><li>  The linear congruential method gives us repeated sequences. </li></ol><br>  In fact, any function that maps a finite set of X to X will produce cyclically repeated values.  So  our task is to maximize the unique part of the sequence (by the way, it is obvious that the length of the unique part cannot be greater than m). <br>  Without going into details of the evidence, let's say that the period of the sequence will be equal to m only if the following three conditions are met: <br><ol><li>  The numbers c and m are coprime; </li><li>  a-1 is a multiple of p for each simple p that is a divisor of m; </li><li>  If m is a multiple of 4, then a-1 must be a multiple of 4. </li></ol>  At the end of the story about the linear congruent method, it must be said that the sequences obtained with its help, although they are quite random, nevertheless, are not cryptographically stable.  Because  Knowing 4 consecutive numbers, a cryptanalyst can make a system of equations from which you can find a, c, m. <br><br><h4>  Getting pseudo-random numbers based on a polynomial counter (shift register) </h4><br>  The algorithm that we are going to consider is based on the operation of the exclusive OR (the sum modulo two).  Just in case, let me remind you what the truth table looks like for this function: <br><img src="https://habrastorage.org/storage1/cc6bf68c/f582e4d2/d0dcc322/f48d5c7b.png"><br>  The schemes shown in the figure below are the simplest polynomial counters.  The zero bit in such schemes is calculated based on the exclusive OR function, and all other bits are obtained by a simple shift.  Discharges from which the signal goes to the exclusive OR are called bends. <br><img src="https://habrastorage.org/storage1/8aba73c2/badc4df3/7a171cb1/f33907c1.png"><br>  Consider how the values ‚Äã‚Äãin these registers will change with the initial value 001: <br><img src="https://habrastorage.org/storage1/179c48f4/cdf43ebd/b397f8bf/34dbbe2a.png"><br><br>  Both registers start working from the same value, but then the values ‚Äã‚Äãgenerated by the registers begin to diverge quickly.  But after 6 steps, both registers are returned to their original state. <br>  It is easy to show that both of these registers generated the longest possible sequence that contains all the combinations except the zero one.  Those.  when the register is m, you can get a sequence of length 2 <sup>m</sup> -1. <br>  A polynomial counter of any digit capacity has a number of combinations of taps, which will ensure a sequence of maximum length, the use of incorrect combinations will lead to the generation of short sequences.  A separate and rather difficult task is to search for these combinations of taps. <br>  It is worth noting that these combinations are not always unique.  For example, for a 10-bit counter there are two of them: [6; 9] and [2; 9]; for a six-digit counter there are twenty-eight such combinations. <br>  In order to find these combinations, it is necessary to present the counter as a polynomial.  The counters from the example will look like this: x <sup>2</sup> XOR 1 and x <sup>2</sup> XOR x XOR 1. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is known from theory that a necessary and sufficient condition for the generation of a complete sequence is the primitiveness of the characteristic polynomial.  It means that: <br><ul><li>  The characteristic polynomial cannot be represented as a product of polynomials of a lower degree; </li><li>  The characteristic polynomial is a divisor of the polynomial z <sup>Œ¥</sup> XOR 1, with (Œ¥ = 2 <sup>m</sup> -1, and is not a divider with any other values ‚Äã‚ÄãŒ¥ &lt;2 <sup>m</sup> -1. </li></ul><br>  The advantages of a polynomial counter are simplicity, both software and hardware implementation, speed and cryptographic strength. <br><br>  Hope this article was helpful to you. </div><p>Source: <a href="https://habr.com/ru/post/132217/">https://habr.com/ru/post/132217/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../132209/index.html">Adobe stops developing mobile Flash Player</a></li>
<li><a href="../132211/index.html">Symfony2. Pitfalls caching</a></li>
<li><a href="../132212/index.html">Adobe will stop developing Flash for mobile devices.</a></li>
<li><a href="../132214/index.html">Asimo just got better</a></li>
<li><a href="../132216/index.html">A couple of news about the working group on the preparation of proposals for the conditions of the competition for the provision of communication services of LTE standard</a></li>
<li><a href="../132218/index.html">HackDay # 20 in St. Petersburg, November 19-20</a></li>
<li><a href="../132219/index.html">TEL Hosting Monitoring System</a></li>
<li><a href="../132220/index.html">Layout pages in 5 seconds</a></li>
<li><a href="../132221/index.html">Payonline.ru now in Windows Azure</a></li>
<li><a href="../132222/index.html">Opera Software. Modern development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>