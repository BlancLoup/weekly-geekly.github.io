<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write real Pointer Analysis for LLVM. Part 1: Introducing or first meeting with the world of program analysis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 This article will be introductory in my short series of notes on a program analysis technique such as pointer analysis. Algorithms of poi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write real Pointer Analysis for LLVM. Part 1: Introducing or first meeting with the world of program analysis</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/solarsecurity/blog/317002/"><img align="right" src="https://habrastorage.org/files/472/3c8/229/4723c8229b824cc980223ffa40ecd873.jpg" width="250"></a>  Hi, Habr! <br><br>  This article will be introductory in my short series of notes on a program analysis technique such as pointer analysis.  Algorithms of pointer analysis allow with a given accuracy to determine which parts of the memory a variable or an expression can indicate.  Without knowledge of information about pointers, the analysis of programs that actively use pointers (that is, programs in any modern programming language ‚Äî C, C ++, C #, Java, Python, and others) ‚Äîis virtually impossible.  Therefore, in any more or less optimizing compiler or <a href="http://solarsecurity.ru/products/solar_inCode/">serious static code analyzer,</a> pointer analysis techniques are used to achieve accurate results. <br><br>  In this series of articles, we will focus on writing an effective interprocedural pointer analysis algorithm, consider the main modern approaches to the problem, and, of course, we will write our very serious pointer analysis algorithm for the wonderful language of the internal presentation of LLVM programs.  I ask all those who are interested under the cat, we will analyze the program and much more! <br><a name="habracut"></a><br><h3>  Algorithms for optimization and analysis of programs </h3><br>  Imagine for a moment that you are writing a compiler for your favorite programming language.  Behind the writing of lexical and syntactic analyzers, the syntax tree of the translation module has already been built and the source program is written in terms of some internal representation (for example, in the form of JVM bytecode or LLVM).  What's next?  You can, for example, try to interpret the received representation on some virtual machine, or translate this representation further, already into machine code.  And you can first try to optimize this presentation, and then do a boring broadcast, right?  In addition, the program will work faster! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What optimizations can we apply?  Consider, for example, such a code snippet. <br><br><pre><code class="cpp hljs">k = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (complexComputationsOMG()) { a = k + <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { a = k * <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt; a) { callUrEx(); } k = complexComputationsAgain(); print(a); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>();</code> </pre> <br>  Note that the variable <code>a</code> takes a value of <code>4</code> , regardless of what value the <code>complexComputationsOMG</code> function <code>complexComputationsOMG</code> , which means that the call to this function can be safely removed from the program view (assuming that all the functions are clean in particular, do not have side effects).  Moreover, since at the point of the program where the variable <code>a</code> is compared with the unit, the variable <code>a</code> always takes the value <code>4</code> , the <code>callUrEx</code> can be called unconditionally, that is, it can get rid of unnecessary branching. <br><br>  In addition, the value of the variable <code>k</code> , assigned in the line <code>k = complexComputationsAgain()</code> not used anywhere, so this function can not be called!  This is what we get after all the transformations. <br><br><pre> <code class="cpp hljs">callUrEx(); print(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>();</code> </pre><br>  In my opinion, not bad!  All we have to do is to teach our optimizer to perform such code transformations automatically.  Here we are helped by all the variety of dataflow analysis algorithms, and very cool guy <a href="https://en.wikipedia.org/wiki/Gary_Kildall">Gary Kildall</a> , who in his monumental manuscript ‚ÄúA unified approach to global program optimization‚Äù presented a universal framework for analyzing programs, more precisely the so-called dataflow problems. <br><br>  Descriptively, an iterative solution to the dataflow problems, sounds very simple.  All we need is to define a set of properties of variables that we want to monitor during the analysis (for example, possible values ‚Äã‚Äãof variables), functions for interpreting such sets for each <a href="https://en.wikipedia.org/wiki/Basic_block">base block,</a> and the rules by which we will distribute these properties between base blocks (for example, the intersection sets).  During the iterative algorithm, we calculate the values ‚Äã‚Äãof these variable properties at different points in the control flow graph ( <a href="https://en.wikipedia.org/wiki/Control_flow_graph">CFG</a> ), usually at the beginning and end of each base unit.  Iteratively spreading these properties, we must eventually reach a fixed point (fixpoint), in which the algorithm finishes its work. <br><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/files/88c/10a/f31/88c10af31ec04d6a86d9f37d7f72e9a4.jpg"></div><br>  Of course, it‚Äôs better to see once than to hear a hundred times, so let's back up the words with an example.  Consider the following code snippet and try to track the possible values ‚Äã‚Äãof variables at various points in the program. <br><br><pre> <code class="cpp hljs">b = <span class="hljs-number"><span class="hljs-number">3</span></span>; y = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (...) { y = b * <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { println(<span class="hljs-string"><span class="hljs-string">"Here we go!"</span></span>); }</code> </pre><br>  The box below solves the classical problem of program analysis, namely, the propagation of constants (constant propagation) for the considered code fragment. <br><br><div class="spoiler">  <b class="spoiler_title">Iterative algorithm of constant propagation</b> <div class="spoiler_text">  At the beginning, all sets of possible values ‚Äã‚Äãof variables are empty. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8fb/19c/0ba/8fb19c0baa1b42adb31e31dcc6e56107.png"></div><br>  Interpreting the input block <code>B1</code> , we find that the output of this block is <code>b=3</code> and <code>y=5</code> .  The function <code>f1</code> (similar functions are defined for the remaining blocks) is the function of the interpretation of the block. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/463/737/e6c/463737e6c4674af8aadf1b1b52749b44.png"></div><br>  The loop entry block in <code>while</code> <code>B2</code> has two ancestors - the input block <code>B1</code> and the block <code>B3</code> .  Since the <code>B3</code> block does not yet contain the possible values ‚Äã‚Äãof the variables, at the current stage of the algorithm we assume that <code>b=3</code> and <code>y=5</code> at the input and output of the block.  The function <code>U</code> is the rule of propagation of sets of properties of variables (usually the exact lower bound of a partially ordered set, or more precisely, a <a href="https://en.wikipedia.org/wiki/Complete_lattice">complete lattice</a> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/449/6c1/8e0/4496c18e04da402e8924bbc35dcb65c7.png"></div><br>  At the output of the base unit <code>B3</code> - <code>b=3</code> and <code>y=6</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0dd/e62/bb0/0dde62bb06e846ffa7581407f543fd5d.png"></div><br>  Since the information about the possible values ‚Äã‚Äãof the variables has been changed (compared to the initial state, that is, as if by the 0th iteration of the algorithm), we start the next iteration of the algorithm.  The new iteration repeats the previous one except for the step of calculating the input set of block <code>B2</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/432/b32/568/432b3256848c4d56883ef4fd72394d2f.png"></div><br>  As we see, this time we are forced to ‚Äúcross‚Äù the output sets of blocks <code>B1</code> and <code>B3</code> .  These sets have a common part <code>b=3</code> that we leave and the different parts <code>y=5</code> and <code>y=6</code> , which we have to drop. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3ab/56c/554/3ab56c5540804248b552a3195e6d2847.png"></div><br>  Since continuing the calculations further we do not get any new values, the work of the algorithm can be considered complete.  This means that we have reached a fixed point. <br></div></div><br>  In his work, Gary Kildall showed that such an iterative algorithm will always complete its work and, moreover, give the fullest possible results if the following conditions are met: <br><br><ol><li>  the domain of tracked variable properties is a complete lattice; </li><li>  the block interpretation function has the property of distributivity on the lattice; </li><li>  for the ‚Äúmeeting‚Äù of the base blocks of the precedents, the exact lower bound operator is used (that is, the meet function of the partially ordered set). </li></ol><br><div class="spoiler">  <b class="spoiler_title">Anecdote from the world of big science</b> <div class="spoiler_text">  The funny thing is that the example that Kildall used in his work (constant propagation) does not satisfy the requirements that he also makes to the dataflow problem - the interpretation functions for constant propagation do not have the distributivity property on the lattice, but are only monotonic. <br></div></div><br>  Thus, to optimize programs, we can use the full power of dataflow analysis algorithms, using, for example, an iterative algorithm.  Returning to our first example, we used constant propagation and liveness analysis (live variable analysis) to perform dead code elimination optimization. <br><br>  Moreover, dataflow analysis algorithms can be used when performing static code analysis in the context of information security.  For example, in the process of searching for vulnerabilities of the SQL-injection class, we can mark with a special flag all variables that could be affected in any way by an attacker (for example, HTTP request parameters, etc.).  If it turns out that a variable marked with such a flag participates in the formation of a SQL query without proper processing - we most likely found a serious security hole in the application!  It will only <a href="https://habrahabr.ru/company/solarsecurity/blog/312056/">show a message about possible vulnerabilities</a> and <s>beautifully go to the horizon to</s> provide the user with recommendations on how to diagnose and fix such vulnerabilities. <br><br><h3>  Multiply grief </h3><br><blockquote>  Ivan nods at Peter, and Peter at Ivan </blockquote><br>  Summing up the previous paragraph, dataflow analysis algorithms are the daily bread (and butter!) Of any compiler.  So where is the pointer analysis, and why is it really needed? <br><br>  I hasten to spoil your mood with the following example. <br><br><pre> <code class="cpp hljs">x = <span class="hljs-number"><span class="hljs-number">1</span></span>; *p = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { killTheCat(); }</code> </pre><br>  Obviously, not knowing where the variable <code>p</code> points to, we cannot say with certainty what the value of the expression <code>x &lt; 3</code> in the conditional <code>if</code> will equal.  The answer to this question we can give only by finding out the context in which the given code fragment appears.  For example, <code>p</code> can be a global variable from another module (which in the C programming languages ‚Äã‚Äãcan point to anything and anytime) or a local variable pointing somewhere in the heap.  Even knowing the context, we still need to know the many locations (abstract memory cells) that this variable can point to.  If, for example, before the specified code fragment, the variable <code>p</code> initialized as <code>p = new int</code> , then we must remove the conditional <code>killTheCat</code> from the optimized program and call the <code>killTheCat</code> method unconditionally. <br><br>  If so, we will not be able to apply any optimization to this code until we find any way to find out once and for all where the variables in the analyzed program can point! <br><br>  I think it has already become obvious that we cannot do without the use of pointer analysis (and for what reason did it become necessary to solve this complex, or rather, algorithmically unsolvable task).  Pointer analysis is a static code analysis method that determines information about the values ‚Äã‚Äãof pointers or expressions of the pointer type.  Depending on the tasks being solved, pointer analysis can determine information for each point of the program or for the program as a whole (flow-sensitivity) or depending on the context of the function call (context-sensitivity).  I will tell you more about pointer analysis types in one of the following articles in the series. <br><br>  The result of the analysis is usually represented as a mapping from a set of pointers to a set of locations to which these pointers can refer.  That is, simply put, each pointer <code>p</code> assigned a set of objects to which it can point.  For example, in the code snippet below, the result of the analysis will be the mapping <code>p -&gt; {a, b}, q -&gt; {p}</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, b, c, *p, **q; p = &amp;a; q = &amp;p; *q = &amp;b;</code> </pre><br>  It is important to note that the mapping calculated by pointer analysis must meet the security criterion, that is, be as conservative as possible.  Otherwise, we can simply spoil the semantics of the source program by our optimizations.  For example, a safe approximation of the pointer analysis result for the program fragment above may be <code>p -&gt; {a, b, c}, q -&gt; {unknown}</code> .  The value <code>unknown</code> used to indicate that the pointer can refer to all available program objects. <br><br>  For example, in the code snippet considered below, dereferencing the variable <code>p</code> can potentially change the value of any program object! <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">offensiveFoo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; p = offensiveFoo(); *p = <span class="hljs-number"><span class="hljs-number">77</span></span>;</code> </pre><br>  We do not know anything about the <code>offensiveFoo</code> function, since it was imported from another broadcast module, and therefore we have to assume that <code>p</code> can indicate absolutely anything! <br><br>  In the following, we will assume that all the functions and global variables under consideration belong to the broadcast module being analyzed, unless the reverse is explicitly discussed with words. <br><br><h3>  Poor Man's Pointer Analysis </h3><br><img align="right" src="https://habrastorage.org/files/389/4f0/3c2/3894f03c2d4c429b830a0327a1b0cbc9.jpg" width="350">  Having faced the problem of aliasing pointers for the first time, I, without hesitation, decided to try to solve the problem using the already known iterative algorithm on the grid (then I had no idea that I was solving the same problem as the pointer analysis algorithms solve).  Indeed, what prevents us from tracking objects that pointers can refer to as a set of properties of these pointers?  Let's try to track the work of the algorithm on a simple example.  Let the rules for the propagation of sets of objects correspond to the ‚Äúnatural‚Äù semantics of the program (for example, if <code>p = &amp;a</code> , then <code>p -&gt; {a}</code> ), and distribute these sets between the basic blocks we will be simply joining sets (for example, if <code>q -&gt; {a, b}</code> and <code>q -&gt; {c}</code> are input to some base unit, then the input set for such a block will be <code>q -&gt; {a, b, c}</code> ). <br><br>  Consider the work of the algorithm on a simple example. <br><br><pre> <code class="cpp hljs">x = &amp;a; a = &amp;z; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (...) { x = &amp;b; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { c = &amp;x; }</code> </pre><br>  Wait until the iterative algorithm finishes and look at the results. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/489/23f/453/48923f4539ce410a9e6765d6a83d4f12.png"></div><br>  Works!  Despite the simplicity of the algorithm, the presented approach has the right to life.  I would say more precisely that it was (of course, with significant improvements) that the aliasing of pointers was solved before the appearance of Andersen‚Äôs Program Analysis and Specialization for the C Programming Language.  By the way, the next article of the cycle will be devoted to this work! <br><br>  The main disadvantages of the described approach are poor scalability and too conservative results, since the analysis of real programs must take into account the challenges of other functions (that is, the analysis must be interprocedural) and, often, the context of the function call.  The essential advantage of this approach is that the information about the pointers is available for each point of the program (that is, the flow-sensitive algorithm), while the algorithms of Andersen and his followers calculate the result for the program as a whole (flow-insensitive). <br><br><h3>  Instead of conclusion </h3><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/files/4f2/2e0/730/4f22e073078543fbaeb1c1d86a191e3b.jpg"></div><br>  This concludes the first piece of my cycle of notes about pointer analysis algorithms.  Next time we will write a simple and efficient interprocedural pointer analysis algorithm for LLVM! <br><br>  Thank you all very much for your time! </div><p>Source: <a href="https://habr.com/ru/post/317002/">https://habr.com/ru/post/317002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316986/index.html">Tuning Swift compiler. Part 1</a></li>
<li><a href="../316988/index.html">Nonlinear regression in Apache Spark. We develop with our own hands</a></li>
<li><a href="../316990/index.html">STM32: FreeRTOS and Piezo Ceramic Emitter</a></li>
<li><a href="../316994/index.html">Bad advice or how to become a terrible leader.</a></li>
<li><a href="../316996/index.html">Creating a blog engine with Phoenix and Elixir / Part 5. Connecting ExMachina</a></li>
<li><a href="../317004/index.html">RubyMine 2016.3: Debugging in attach mode, updated support for Puppet, SDK synchronization via rsync</a></li>
<li><a href="../317008/index.html">Productivity is my ecommerce site evaluation method</a></li>
<li><a href="../317010/index.html">History of programming languages: Algol - a victim of a conflict of interest</a></li>
<li><a href="../317012/index.html">Choosing a hosting: speed and reliability</a></li>
<li><a href="../317016/index.html">Benefits of a three-level backup storage scheme</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>