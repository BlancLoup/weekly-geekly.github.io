<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>UFCS in the programming language D</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Surely you have already seen some posts about D. Templates, pseudo-members, streams ... Today I will tell you about a feature of the language like UFC...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>UFCS in the programming language D</h1><div class="post__text post__text-html js-mediator-article">  Surely you have already seen some posts about D. Templates, pseudo-members, streams ... Today I will tell you about a feature of the language like UFCS, or Universal Function Call Syntax.  Let's start with the simple. <br><br>  Consider a class A and a function that takes a pointer to its instance: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A a)</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br>  Ask any C programmer how he would call her.  You will probably hear something like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A; foo(b); }</code> </pre><br>  The point is that in D the first argument can act as a basic identifier, whose method is this function, i.e.  function can be called as follows: <br><br><pre> <code class="cpp hljs">b.foo();</code> </pre><br>  This opens up a lot of room for building very interesting, consistent (and even fast) structures. <br><br>  <b>Caution: at the end of the color image!</b> <br><a name="habracut"></a><br>  And if arguments are more than 1?  2? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bar, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var = <span class="hljs-number"><span class="hljs-number">42</span></span>; b.foo(var, <span class="hljs-string"><span class="hljs-string">"This police box inside than outside"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ! }</span></span></code> </pre><br>  It should be noted that the usual form of calling a function is preserved, and from the point of view of machine code, these forms are almost identical ... Practically ... <i>But this is a completely different story.</i> <br><br>  Further more!  We can parameterize the function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T a, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Second argument\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ writeln(T.stringof); writeln(a); writeln(text); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var = <span class="hljs-number"><span class="hljs-number">42</span></span>; var.foo!(typeof(var))(); <span class="hljs-comment"><span class="hljs-comment">//int //42 //! var.foo("For this view this string is first argument!");//     }</span></span></code> </pre><br>  With a simple built-in type, it rolls easily.  What about arrays?  Of course!  After all, the code is the same for both cases! <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T[] a)</span></span></span><span class="hljs-function"> </span></span>{ writeln(T.stringof); writeln(a); writeln(a[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] vars = [<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>]; vars.foo(); <span class="hljs-comment"><span class="hljs-comment">//int[] //[42, 15, 8] //42 }</span></span></code> </pre><br>  Now we come to the most delicious ... But first, a small digression. <br><br>  The standard language library has a huge number of functions that work with arrays.  In our case, consider the map function.  This function takes as a parameter a certain function and data array, performs an action on the elements provided by this function and forms a new array of new data.  It lies in the std.algorithm module. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] vars = [<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> output = <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>!((a) =&gt; a.foo())(vars); writeln(output); }</code> </pre><br><br>  Here we see our map function.  In brackets after the sign!  We describe a functional literal that will be executed on all elements.  In our case, this is (a) =&gt; a.foo ().  The first brackets symbolically represent the ‚Äúdeclaration‚Äù of a function and describe how its argument will be named.  Here, it will be an element of the array.  The symbols =&gt; signify the beginning of the function body, and the last part I, I think, is understandable.  After working out the program, we will see what we expect: <br><br><pre> <code class="bash hljs">[44, 17, 10]</code> </pre><br>  Let's use the UFCS style, so how is it here to place, and there is no third-party use of intermediate results of the functional chain. <br><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">property </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addTwo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] vars = [<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>]; vars .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>!((a) =&gt; a.addTwo) .writeln; <span class="hljs-comment"><span class="hljs-comment">// ! }</span></span></code> </pre><br>  You may notice that the writeln function has no brackets that indicate its functional nature.  The fact is that initially it was declared with the @property attribute.  This means that a function that takes no explicit arguments can be called without parentheses, and often looks like a field of a class or structure.  In classes, this allows you to perform actions when accessing this field, and in the UFCS style, this helps emphasize the role of the function as a command.  I attributed the same attribute to our function and changed its name in order to transfer its command nature. <br><br>  Now take a look at this piece of code, and without looking further try to answer what is wrong with this parameterized class Container?  As a hint, I will give you a piece of his ad: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Container</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>() { vars = [<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>]; } <span class="hljs-comment"><span class="hljs-comment">//‚Ä¶. T[] vars; } @property int addTwo(T)(T a) { return a + 2; } void main() { auto container = new Container!(int); //       ,                container .map!((a) =&gt; a.addTwo) .writeln; }</span></span></code> </pre><br>  Guess?  Right?  Ok, open the cards. <br><br>  In fact, the standard language library does not use such a concept as an array.  A more abstract concept is used, such as <b>Range</b> .  In the concept of D, a range is a kind of abstract type capable of storing and providing access to some ordered elements.  In other words, this is what unites both arrays, and stack, and a singly-connected list ... One work scheme for the entire set of containers!  Whether it is a class, or a structure, it will work everywhere.  But here's the problem ... How do you determine that the type of argument is a range? <br><br>  Template contracts come to the rescue!  They are designed to check the conditions on the incoming types, so that users do not shove <s>fingers into an outlet</s> that you do not need to shove. <br><br>  Thus, the map function has its own template contract, which determines whether the type of the argument is a range. <br><br>  auto map (Range) (Range r) <br>  if (isInputRange! (Unqual! Range)); <br><br>  Namely, the type is checked for the so-called input ranges (I'm not sure which analogue can be used in Russian).  Thus, types, for their use in a map, must have all the attributes of input ranges, and these are: <br><br>  - have the function empty, to determine the emptiness of the range <br>  - have the front function to return the top item <br>  - have the popFront function to remove the top item <br><br>  That is what I missed in the class code!  But especially attentive ones will notice that arrays do not have these built-in methods that define them as input ranges.  True, no. <br><br>  But there is a UFCS!  Thanks to him, we can use the functions empty, front and popFront (and many others, defined in the module std.range.primitives) with respect to arrays and use them along with other containers! <br><br>  It should be said that it is useful for functions that will be called through UFCS to return a result for later use by other functions.  This can be seen, if you look at the code courtesy of the user aquaratixc: <br><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">property </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayGav</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Range)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Range c)</span></span></span><span class="hljs-function"> </span></span>{ writeln(<span class="hljs-string"><span class="hljs-string">"Gav!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> img = load(`Lenna.png`); img .takeArea(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>!(a =&gt; toNegative(a, Color4f(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>,<span class="hljs-number"><span class="hljs-number">1.0f</span></span>,<span class="hljs-number"><span class="hljs-number">1.0f</span></span>)).front) .<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> .toSurface(<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>) .drawPoint(Color4f(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>,<span class="hljs-number"><span class="hljs-number">1.0f</span></span>,<span class="hljs-number"><span class="hljs-number">1.0f</span></span>), <span class="hljs-number"><span class="hljs-number">125</span></span>, <span class="hljs-number"><span class="hljs-number">125</span></span>) .createImage(<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>) .sayGav .savePNG(<span class="hljs-string"><span class="hljs-string">"testing.png"</span></span>); }</code> </pre><br>  As a result of the work, the program displays ‚ÄúGav!‚Äù In the terminal and converts the image, as shown in the figure below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1e/378/d40/b1e378d402e396c926942e2dd12df788.png" alt="image"><br><br>  <b>PS</b> Habravchanin <a href="https://habrahabr.ru/users/vintage/" class="user_link">vintage</a> noticed that the line of the form <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> output = <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>!((a) =&gt; a.foo())(vars);</code> </pre><br>  can be written like this: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> output = <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>!q{a.foo}(vars);</code> </pre><br>  We tell him for this special thanks! </div><p>Source: <a href="https://habr.com/ru/post/277097/">https://habr.com/ru/post/277097/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277085/index.html">CodingFuture + Puppet. Part I: network and network filter (cfnetwork + cffirehol)</a></li>
<li><a href="../277087/index.html">Angular 1.5: Components</a></li>
<li><a href="../277089/index.html">Google refuses to flash in advertising</a></li>
<li><a href="../277091/index.html">Security Week 06: bank robbery on the stream, breaking the grid, Poseidon / Amebey / Kianokhet</a></li>
<li><a href="../277093/index.html">Working with USB devices in Android</a></li>
<li><a href="../277099/index.html">Katya, Go, Dcoin and Android</a></li>
<li><a href="../277101/index.html">Fix MySQL dump (in less than 30 lines)</a></li>
<li><a href="../277103/index.html">Machine Learning Revolution: General Principles and Effects on SEO</a></li>
<li><a href="../277105/index.html">Bear, the dismemberment and February 14</a></li>
<li><a href="../277107/index.html">Sandy Metz and Object-Oriented Design in Ruby</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>