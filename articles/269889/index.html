<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL Evangelist Memo: Replicants vs. Replication</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the continuation of the series of publications, ‚ÄúThe PostgreSQL Evangelist Memo ...‚Äù ( 1 , 2 ), the expensive edition again contacts, this time wit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL Evangelist Memo: Replicants vs. Replication</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/64a/4e1/9e6/64a4e19e610d4f5aa344d3cff44823aa.jpg" align="left"><br><br>  In the continuation of the series of publications, ‚ÄúThe PostgreSQL Evangelist Memo ...‚Äù ( <a href="http://habrahabr.ru/post/268949/">1</a> , <a href="http://habrahabr.ru/post/269463/">2</a> ), the expensive edition again contacts, this time with the promised review of replication mechanisms in PostgreSQL and MySQL.  The main reason for writing was the frequent criticism of MySQL replication.  As is often the case, a typical criticism is a strong mixture of truth, half-truths, and <i>evangelism</i> .  All this is repeatedly <i>replicated by</i> different people without special attempts to understand what was heard.  And since this is a fairly extensive topic, I decided to make the analysis in a separate publication. <br><a name="habracut"></a><br>  So, within the framework of <i>cultural exchange</i> and in anticipation of HighLoad ++, where there will certainly be as usual a lot of criticism of MySQL, consider the mechanisms of replication.  For a start, some boring basic things for those who haven't. <br><br><h1>  Types of replication </h1><br>  Replication is logical and physical.  Physical is a description of changes at the level of data files (simplified: write such bytes on such a displacement on such a page).  Logical, on the other hand, describes changes at a higher level without reference to a specific representation of data on disk, and variants are possible here.  You can describe changes in terms of the rows of the tables, for example, the <code>UPDATE</code> can be reflected as a sequence of pairs <b>(old values, new values)</b> for each modified row.  In MySQL, this type is called row-based replication.  And you can simply write the text of all SQL queries that modify the data.  This type in MySQL is called statement-based replication. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Physical replication is often called binary (especially in the PostgreSQL community), which is not true.  The data format of both logical and physical replication can be either text (that is, human-readable) or binary (requiring processing for human reading).  In practice, all formats in both MySQL and PostgreSQL are binary.  Obviously, in the case of statement-based replication in MySQL, query texts can be read with the naked eye, but all the service information will still be in binary form.  Therefore, the log used in replication is called binary regardless of the replication format. <br><br><h2>  Features of logical replication: </h2><br><ul><li>  <b>independence of data storage format:</b> master and slave can have different representations of data on disk, different processor architectures, different table structures (provided that the schemes are compatible), different configurations and location of data files, different storage engines (for MySQL), different server versions, and in general, the master and the slave can be different DBMS (and such solutions for "cross-platform" replication exist).  These properties are used frequently, especially in large-scale projects.  For example, in rolling schema upgrade. </li><li>  <b>readability:</b> you can read data from every node in replication without any restrictions.  With physical replication, this is not so easy (see below) </li><li>  <b>multi-source capability</b> : merging changes from different masters on the same slave.  Example of use: data aggregation from several shards for building statistics and reports.  The same Wikipedia uses multi-source for exactly this purpose. </li><li>  <b>multi-master feature:</b> for any topology, you can have more than one server available for recording, if necessary </li><li>  <b>partial replication: the</b> ability to replicate only individual tables or schemas </li><li>  <b>compactness: the</b> amount of data transmitted over the network is less.  In some cases, much less. </li></ul><br><br><h2>  Features of physical replication: </h2><br><ul><li>  <b>easier to configure and use:</b> By itself, the task of byte-based mirroring of one server to another is much simpler than logical replication with its numerous usage scenarios and topologies.  Hence, the famous ‚Äúset up and forget‚Äù in all the MySQL vs PostgreSQL holivors. </li><li>  <b>low resource consumption:</b> Logical replication requires additional resources, because the logical description of changes still needs to be ‚Äútranslated‚Äù into physical, i.e.  understand what exactly and where to burn </li><li>  <b>the requirement of 100% node identity:</b> physical replication is possible only between exactly identical servers, up to the processor architecture, paths to the tablespace files, etc.  This can often be a problem for large-scale replication clusters, since  a change in these factors entails a complete stop of the cluster. </li><li>  <b>no entry on the slave:</b> derived from the preceding paragraph.  Even a temporary table cannot be created. </li><li>  <b>reading from the slave is problematic:</b> reading from the slave is possible, but not without problems.  See ‚ÄúPhysical Replication in PostgreSQL‚Äù below. </li><li>  <b>limited topologies:</b> no multi-source and multi-master impossible.  At best, cascading replication. </li><li>  <b>no partial replication:</b> everything follows from the same requirement of 100% data file identity </li><li>  <b>large overheads:</b> all changes to the data files need to be transferred (operation with indexes, vacuum and other internal accounting).  So the load on the network is higher than with logical replication.  But everything as usual depends on the number / type of indexes, load and other factors. </li></ul><br>  And still replication can be synchronous, asynchronous and semi-synchronous, regardless of format.  But this fact has little relevance to the things discussed here, so we leave it behind the brackets. <br><br><h1>  Physical replication in MySQL </h1><br>  It does not exist as such, at least built into the server itself.  There are architectural reasons for this, but this does not mean that it is impossible in principle.  Oracle could implement physical replication for InnoDB with relatively little effort, and that would cover the needs of most users.  A more complex approach would require creating some API, implementing which alternative engines could support physical replication, but I do not think it will ever happen. <br><br>  But in some cases, physical replication can be implemented by external means, for example using <a href="https://en.wikipedia.org/wiki/Distributed_Replicated_Block_Device">DRBD</a> or <a href="https://fghaas.wordpress.com/2009/09/16/alternatives-to-drbd/">hardware solutions</a> .  The pros and cons of this approach <a href="https://www.percona.com/blog/2008/04/28/mysql-replication-vs-drbd-battles/">have</a> been <a href="https://www.percona.com/blog/2008/04/28/mysql-replication-vs-drbd-battles/">discussed</a> repeatedly and in detail. <br><br>  In the context of comparison with PostgreSQL, it should be noted that the use of DRBD and similar solutions for the physical replication of MySQL is most similar to warm standby in PostgreSQL.  But the amount of data transmitted over the network in DRBD will be higher, because DRBD operates at the block device level, which means that not only REDO log records (transaction log) are replicated, but also file system meta-information updates to the data files and updates. <br><br><h1>  Logical replication in MySQL </h1><br>  This topic is the most disturbing.  And most of the criticism is based on the report ‚ÄúAsynchronous replication of MySQL without censorship or why PostgreSQL will conquer the world‚Äù by Oleg Tsarev <a href="https://habrahabr.ru/users/zabivator/" class="user_link">zabivator</a> , as well as the accompanying <a href="http://habrahabr.ru/company/mailru/blog/248845/">article</a> on Habr√©. <br><br><img src="https://habrastorage.org/files/389/4cb/bbf/3894cbbbf3234ddc94f1d373bf167c1d.jpg" align="left">  I would not single out one specific report if I were not referred to in approximately every tenth comment to previous articles.  Therefore, we have to answer, but I would like to emphasize that there are no perfect reports (I personally get bad reports), and all criticism is directed not at the speaker, but at technical inaccuracies in the report.  I would be glad if this helps to improve its future versions. <br><br>  In general, the report contains quite a lot of technically inaccurate or simply incorrect statements, some of which I addressed in the <a href="http://habrahabr.ru/post/268949/">first part of the evangelist's memo</a> .  But I do not want to drown in the details, so I will analyze the main points. <br><br>  So, in MySQL, logical replication is represented by two subtypes: statement-based and row-based. <br><br>  Statement-based is the most naive way to organize replication (‚Äúlet's just send SQL commands to the slave!‚Äù), Which is why it appeared first in MySQL and it was a long time ago.  It even works as long as the SQL commands are strictly deterministic, i.e.  result in the same changes regardless of runtime, context, triggers, etc.  Tons of articles have been written about this; I will not dwell here in detail. <br><br>  In my opinion, statement-based replication is a MyISAM style hack and ‚Äúlegacy‚Äù.  Surely someone somewhere else finds her application, but <i>if possible avoid it</i> . <br><br><img src="https://habrastorage.org/files/c12/a84/eaa/c12a84eaabc24739bdbda93a7dca6de2.jpg" align="right">  Interestingly, Oleg also talks about the use of statement-based replication in his report.  The reason - row-based replication would generate terabytes of information per day.  What is generally logical, but how is this consistent with the statement ‚ÄúPostgreSQL conquers the world‚Äù if there is no asynchronous statement-based replication in PostgreSQL at all?  That is, PostgreSQL would generate terabytes of updates per day, a disk or a network would be expected to become a disk or a network, and with the conquest of the world <i>would have to wait</i> . <br><br>  Oleg notes that logical replication is usually CPU-bound, that is, rests on the processor, and physical replication is usually I / O-bound, that is, rests on the network / disk.  I‚Äôm not quite sure about this statement: CPU-bound load in one hand turns into an elegant I / O bound as soon as the active data set stops being stored in memory (typical situation for the same Facebook, for example).  And along with this, most of the difference between logical and physical replication is leveled.  But in general, I agree: logical replication requires relatively more resources (and this is its main drawback), and physical is less (and this is practically its only advantage). <br><br>  There can be many reasons to ‚Äúslow down‚Äù replication: it‚Äôs not only single streaming or processor deficiency, it can be a network, a disk, inefficient requests, inadequate configuration.  The main damage from the report is that it ‚Äúrows all one size fits all‚Äù, explaining all the problems with a certain ‚Äúarchitectural error of MySQL‚Äù, and leaving the impression that there are no solutions to these problems.  That is why he was gladly adopted by the evangelists of <i>all stripes</i> .  In fact, I am sure that 1) most of the problems have a solution and 2) all these problems exist in the implementations of logical replication for PostgreSQL, perhaps even more severely (see ‚ÄúLogical Replication for PostgreSQL‚Äù). <br><br><img src="https://habrastorage.org/files/3c8/a2d/a0e/3c8a2da0edf84b8db105aea3f371d78e.gif" align="left">  From Oleg's report it is very difficult to understand what actually became a problem in his tests: there is no attempt to analyze, there are no metrics, neither at the OS level, nor at the server level.  For comparison: the <a href="http://blog.booking.com/evaluating_mysql_parallel_replication_3-benchmarks_in_production.html">publication of</a> engineers from Booking.com on the same topic, but with detailed analysis and without the "evangelical" conclusions.  I especially recommend to read the section <a href="http://blog.booking.com/evaluating_mysql_parallel_replication_3-under_the_hood.html">Under the Hood</a> .  That's the way to do and show benchmarks.  In Oleg's report, 3 slides are set aside for benchmarks. <br><br>  I just briefly list possible problems and their solutions.  I foresee a lot of comments in the spirit of "and everything works fine in the elephant and without any shamanism!"  I will answer them once and I will not do it again: physical replication is easier to set up than logical replication, but not everyone is happy with its capabilities.  There are more logical possibilities, but there are also disadvantages.  Here are ways to minimize flaws for MySQL. <br><br><h2>  If we rest against the disk </h2><br>  Often, weak machines are allocated to the slave for reasons of "well, this is not the main server, this old wash will come down."  In the old basin is usually a weak disk, in which everything rests. <br><br>  If the disk is a bottleneck during replication, and it is not possible to use something more powerful, you need to reduce the disk load. <br><br>  First, it is possible to regulate the amount of information that master writes to the binary log, and therefore is sent over the network and written / read on the slave.  Settings worth watching: <code>binlog_rows_query_log_events</code> , <code>binlog_row_image</code> . <br><br>  Secondly, you can disable the binary log on the slave.  It is needed only if the slave itself is a master (in a multi-master topology or as an intermediate master in cascade replication).  Some keep the binary log enabled in order to speed up the slave switch to master mode in case of failover.  But if there is a problem with disk performance, it can and should be disabled. <br><br>  Thirdly, you can weaken the durability settings on the slave.  A slave is, by definition, irrelevant (due to asynchronous) and not a single copy of the data, which means that if it falls it can be recreated either from a backup, or from a master, or from another slave.  Therefore, there is no point in keeping the strict settings of durability, keywords: <code>sync_binlog</code> , <code>innodb_flush_log_at_trx_commit</code> , <code>innodb_doublewrite</code> . <br><br>  Finally, the InnoDB general setting for intensive recording has not been canceled.  Keywords: <code>innodb_max_dirty_pages_pct</code> , <code>innodb_stats_persistent</code> , <code>innodb_adaptive_flushing</code> , <code>innodb_flush_neighbors</code> , <code>innodb_write_io_threads</code> , in the <code>innodb_io_capacity</code> <code>innodb_adaptive_flushing</code> , <code>innodb_flush_neighbors</code> , <code>innodb_write_io_threads</code> , <code>innodb_io_capacity</code> , <code>innodb_purge_threads</code> , <code>innodb_log_file_size</code> , <code>innodb_log_buffer_size</code> , <code>innodb_stats_persistent</code> , <code>innodb_adaptive_flushing</code> , <code>innodb_flush_neighbors</code> , <code>innodb_write_io_threads</code> , <code>innodb_io_capacity</code> , <code>innodb_purge_threads</code> , <code>innodb_log_file_size</code> , <code>innodb_log_buffer_size</code> , <code>innodb_stats_persistent</code> , <code>innodb_adaptive_flushing</code> , <code>innodb_flush_neighbors</code> , <code>innodb_write_io_threads</code> , <code>innodb_io_capacity</code> , <code>innodb_purge_threads</code> , <code>innodb_log_file_size</code> , <code>innodb_log_buffer_size</code> . <br><br>  If nothing helps, you can look towards the TokuDB engine, which is, firstly, optimized for intensive writing, especially if the data does not fit in memory, and secondly, it provides the ability to organize <a href="https://github.com/percona/tokudb-engine/wiki/Read-Free-Replication-with-TokuDB">read-free replication</a> .  This can solve the problem in both IO-bound and CPU-bound loads. <br><br><h2>  If we run into the processor </h2><br>  With a fairly intensive recording on the master and no other bottlenecks on the slave (network, disk), you can rest against the processor.  This is where parallel replication comes to the rescue, it‚Äôs a multi-threaded slave (MTS). <br><br>  At 5.6, MTS was made in a very limited form: only updates to different databases were performed in parallel (schemes in PostgreSQL terminology).  But surely there is a non-empty multitude of users in the world for whom this is quite enough (hello, hosters!). <br><br>  In 5.7, MTS was extended to perform arbitrary updates in parallel.  In early pre-release versions 5.7, concurrency was limited by the number of simultaneously committed transactions within a group commit.  This limited parallelism, especially for systems with fast disks, which most likely led to insufficiently effective results for those who tested these early versions.  It is quite normal for them to have earlier versions so that interested users can test and scold.  But not all users guess to make a report of this with the conclusion ‚ÄúPostgreSQL will conquer the world.‚Äù <br><br>  Nevertheless, <a href="http://mysqlhighavailability.com/multi-threaded-replication-performance-in-mysql-5-7/">here are the results of the same sysbench tests</a> that Oleg used for the report, but already on the GA release 5.7.  What we see in the bottom line: <br><img src="https://habrastorage.org/files/77f/2e7/522/77f2e75225ac40f6880b43080b6eb1a9.png"><br><ul><li>  MTS on the slave achieves a 10-fold increase in performance compared to single-threaded replication </li><li>  using <code>slave_parallel_workers=4</code> already results in more than 3.5 times the throughput of the slave </li><li>  Row-based replication performance is almost always better than statement-based.  But MTS has a greater effect on statement-based, which somewhat equalizes both formats in terms of performance on OLTP loads. </li></ul><br>  Another important conclusion from Booking.com testing is: the smaller the transaction size, the more parallelism can be achieved.  Before group commit in 5.6, developers tried to make transactions as much as possible, often unnecessarily from an application point of view.  Starting from 5.6, this is not necessary, and for parallel replication in 5.7 it is better to revise transactions and break them into smaller ones where possible. <br><br>  In addition, you can adjust the <code>binlog_group_commit_sync_delay</code> and <code>binlog_group_commit_sync_no_delay_count</code> on the wizard, which can lead to additional parallelism on the slave, even in the case of long transactions. <br><br>  On this topic with replication in MySQL and a popular report, I think it is closed, go to PostgreSQL. <br><br><h1>  Physical replication in PostgreSQL </h1><br>  In addition to all the advantages and disadvantages of physical replication listed above, the implementation in PostgreSQL has another significant drawback: replication compatibility is not guaranteed between major releases of PostgreSQL, since WAL compatibility is not guaranteed.  This is really a serious drawback for loaded projects and large clusters: you need to stop the wizard, upgrade, then complete re-creation of the slaves.  For comparison: problems with replication from old versions to new ones occur in MySQL, but they are fixed and in most cases it works, no one refuses compatibility.  This is what is used when updating large-scale clusters - the advantages of ‚Äúflawed‚Äù logical replication. <br><br>  PostgreSQL provides the ability to read data from a slave (the so-called Hot Standby), but this is not nearly as easy as with logical replication.  From the <a href="http://www.postgresql.org/docs/current/static/hot-standby.html">Hot Standby documentation</a> , we found out that: <br><br><ul><li> <code>SELECT ... FOR SHARE | UPDATE</code>  <code>SELECT ... FOR SHARE | UPDATE</code> not supported because it requires modification of data files. </li><li>  2PC commands are not supported for the same reasons. </li><li>  explicit indication of ‚Äúread write‚Äù transaction status ( <code>BEGIN READ WRITE</code> , etc.), LISTEN, UNLISTEN, NOTIFY, sequence updates are not supported.  Which is generally explicable, but this means that some applications will have to be rewritten during migration to Hot Standby, even if they do not modify any data. </li><li>  Even read-only requests can cause conflicts with DDL and vacuum operations on the wizard (hello to ‚Äúaggressive‚Äù vacuum settings!) In this case, requests can either delay replication or be forcibly interrupted and there are configuration parameters that control this behavior. </li><li>  the slave can be configured to provide ‚Äúfeedback‚Äù to the master (the <code>hot_standby_feedback</code> parameter).  What is good, but the overhead costs of this mechanism in loaded systems are interesting. </li></ul><br>  In addition, I found a wonderful warning in the same documentation: <br><ul><li>  <b>"Operations on hash indexes are not presently WAL-logged, so do not replay these indexes"</b> - uh, but this is generally how?  And with physical backups, what? </li></ul><br><br>  There are some features with <a href="http://www.postgresql.org/docs/9.4/static/warm-standby-failover.html">failover</a> that may seem strange to the MySQL user, such as the inability to return to the old master after failover without re-creating it.  I quote the documentation: <br><blockquote>  Once there is a single server in operation.  This is known as a degenerate state.  Stay down and stay down.  If it comes to a third time, it may be new. </blockquote><br><br>  There is one more specific feature of physical replication in PostgreSQL.  As I wrote above, the overhead for traffic for physical replication is generally higher than in logical.  But in the case of PostgeSQL, in WAL, full images of the pages updated after checkpoint ( <code>full_page_writes</code> ) are recorded (and therefore transmitted over the network).  I can easily imagine the load, where this behavior can be a disaster.  Here, for sure, several people will rush to explain the meaning of <code>full_page_writes</code> to me.  I know, just in InnoDB this is implemented somewhat differently, not through a transactional log. <br><br>  <b>Updated 09/28/2016:</b> The same problems with replication, but with English words in the article by Uber engineers on the reasons for switching from PostgreSQL to MySQL: <a href="https://eng.uber.com/mysql-migration/">eng.uber.com/mysql-migration</a> <br><br>  <b>Updated 10/30/2017:</b> A curious problem that arose from the fact that replication in PostgreSQL is physical: <a href="http://thebuild.com/blog/2017/10/27/streaming-replication-stopped-one-more-thing-to-check/">thebuild.com/blog/2017/10/27/streaming-replication-stopped-one-more-thing-to-check</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otherwise, physical replication in PostgreSQL is probably a really reliable and easy-to-configure mechanism for those to whom physical replication is generally suitable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But users of PostgreSQL are </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also people</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and nothing human is alien to them. </font><font style="vertical-align: inherit;">Someone sometimes wants multi-source. </font><font style="vertical-align: inherit;">And someone really likes multi-master or partial replication. </font><font style="vertical-align: inherit;">Perhaps that is why there is ...</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Logical replication in PostgreSQL </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I tried to understand the state of logical replication in PostgreSQL and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">something was despondent</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . There is no built-in, there are a lot of third-party solutions ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">who said ‚Äúconfusion‚Äù?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): Slony-I (by the way, where is Slony-II?), Bucardo, Londiste, BDR, pgpool 1/2, Logical Decoding, and that's not counting the dead or proprietary projects. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everyone has their own problems - some look familiar ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for them replication in MySQL is often criticized</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), some look strange to the MySQL user. Some kind of total disaster with DDL replication that is not supported even in Logical Decoding (I wonder why?). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BDR requires a patched version of PostgreSQL ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">who says fork?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have some doubts about performance. </font><font style="vertical-align: inherit;">I'm sure that someone in the comments will begin to explain that replication on triggers and scripts in Perl / Python is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but I will believe in it only when I see comparative load tests with MySQL on the same hardware. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logical decoding looks interesting.</font></font> But: <br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is not replication per se, but a constructor / framework / API for creating third-party logical replication solutions. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using Logical Decoding requires recording additional information in WAL (required to install </font></font><code>wal_level=logical</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Hello to the critics of the binary log in MySQL!</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Some of the third-party solutions have already moved to Logical Decoding, and some have not. </font></font></li><li>       ,    row-based   MySQL,    :    ,  GTID (     failover/switchover   ?),    . </li><li>     <a href="http://www.slideshare.net/8kdata/postgresql-logical-decoding"> </a> SQL   Logical Decoding  Poll    ,      Push .    ,          Push ,  -   ? </li><li>    ,  .   <a href="http://yoshinorimatsunobu.blogspot.ru/2014/04/semi-synchronous-replication-at-facebook.html"> </a> ,      ? </li><li>        <code>REPLICA IDENTITY</code>  .     <code>binlog_row_image</code>  MySQL.    MySQL ,      ,      .     PostgreSQL? </li><li>  , <i>    ¬´    PostgreSQL  ¬ª?</i>  .       . </li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I said, I do not pretend to anything in terms of knowledge of PostgreSQL. If any of this is wrong, or inaccurate - let me know in the comments and I will correct it. It would also be interesting to get answers to questions that I had on the go. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But my overall impression is that logical replication in PostgreSQL is in its early stages of development. In MySQL, logical replication has been </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">around</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for a long time; all of its pros, cons, and pitfalls are well known, studied, discussed, and shown in </font><i><font style="vertical-align: inherit;">various reports</font></i><font style="vertical-align: inherit;"> . In addition, it has changed a lot in recent years.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since this publication contains some criticism of PostgreSQL, I predict another explosion of comments in the style: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúbut my friend and I worked on a muscle and everything was bad, but now we are working on an elephant and life has improved‚Äù</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">I believe. </font><font style="vertical-align: inherit;">No seriously. </font><font style="vertical-align: inherit;">But I do not urge anyone to go somewhere or even change anything at all. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The article pursues two goals: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) the answer to the not completely correct criticism of MySQL and </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) an attempt to systematize the numerous differences between MySQL and PostgreSQL. </font><font style="vertical-align: inherit;">Such comparisons require tremendous work, but this is what is often expected of me in the comments. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the next post I‚Äôm going to continue the comparison, this time in the light of performance.</font></font></div><p>Source: <a href="https://habr.com/ru/post/269889/">https://habr.com/ru/post/269889/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269875/index.html">Sort without if</a></li>
<li><a href="../269879/index.html">The future of the Web is very much like Bitcoin</a></li>
<li><a href="../269883/index.html">User Documentation and GitHub</a></li>
<li><a href="../269885/index.html">Pony is a killer ...?</a></li>
<li><a href="../269887/index.html">Code Generation in Go</a></li>
<li><a href="../269893/index.html">Pure architecture in a go app. Part 1</a></li>
<li><a href="../269895/index.html">How I did the web version of KeePass</a></li>
<li><a href="../269897/index.html">Automatic generation of microcontroller software code based on event-oriented model</a></li>
<li><a href="../269899/index.html">Lua 5.3 Reference Guide</a></li>
<li><a href="../269901/index.html">Pitfalls Entity Framework and Performance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>