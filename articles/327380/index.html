<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why Apache Ignite is a good microservice platform</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note Translator. The article may be of interest to architects and developers who are planning to build a solution based on microservices, or who are l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why Apache Ignite is a good microservice platform</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/2d2/f59/21d/2d2f5921dc8142f9a0a7ddcd6f65c722.jpg"><br><br>  <i>Note</i>  <i>Translator.</i>  <i>The article may be of interest to architects and developers who are planning to build a solution based on microservices, or who are looking for ways to optimize the current solution, especially if the work comes with large amounts of data.</i>  <i>The translation is made on the basis of <a href="https://www.gridgain.com/resources/blog/running-microservices-top-memory-data-grid-part-i">part 1</a> and <a href="https://www.gridgain.com/resources/blog/microservices-top-memory-data-grid-part-ii">part 2 of the</a> cycle of articles on microservices on Apache Ignite.</i>  <i>General familiarity with the Java ecosystem is assumed (Apache Ignite also works with .NET, C ++, and with REST and with other languages, but the examples in the article will appeal to Java), it is recommended that you have a basic knowledge of Spring.</i> <br><br>  Today <i>microservice architecture</i> is one of the most popular approaches, on the basis of which many companies build their solutions.  One of the key advantages of this approach is that it involves splitting the solution into a set of weakly related components ‚Äî microservices ‚Äî each of which can have its own life and release cycles, development team, etc.  These components always have at least one data exchange mechanism, through which microservices interact with each other.  Moreover, they can be created using different languages ‚Äã‚Äãand technologies that are most appropriate for a specific module of the system. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you use solutions based on microservice architecture where there is a high load and you need to work with actively growing data arrays, most likely, you have encountered or will encounter problems of classical approaches: <br><a name="habracut"></a><br><ul><li>  disk databases do not cope with increasing volumes of information that must be stored and processed;  databases become a bottleneck in which your decision rests; </li><li>  The high availability requirements that were once the ‚Äúcherry on the cake‚Äù are now the necessary minimum for a product that wants to compete successfully in the market. </li></ul><br>  The purpose of this article is to explain how you can solve these problems in your product using Apache Ignite (or GridGain In-Memory Data Fabric) to build a fault tolerant and scalable solution in the microservice paradigm. <br><br><h2>  Analysis of solutions based on Apache Ignite </h2><br>  Let's look at a typical microservice solution architecture that uses Apache Ignite, shown in the figure below. <br><br><img src="https://habrastorage.org/files/348/2fd/c94/3482fdc94c2c409093b3341919191ebf.png"><br><br><h3>  Apache Ignite Cluster Layer </h3><br>  Apache Ignite cluster is used to achieve 2 goals. <br><br>  First, it is the main data repository in which they are contained in RAM.  Since the data is in memory, microservice does not need indirectly through the DBMS to perform many expensive disk accesses, which significantly improves the overall system performance. <br><br>  " <i>Data nodes</i> " ( <b>data nodes</b> ) - a special group in the cluster, which is responsible for storing data.  These are the ‚Äúserver‚Äù Apache Ignite nodes that store data patches and allow execution of data retrieval and calculation requests on these sites.  There is no need to deploy data and computation classes: Apache Ignite relies on its own cross-platform binary format, and also has mechanisms for exchanging classes with logic between cluster nodes (peer class loading). <br><br>  Apache Ignite binary format is used to serialize objects and support the dynamic exchange of classes between nodes.  The possibility of such an exchange of logic within the cluster allows you to flexibly manage computations by loading the necessary code on demand from a separate layer of service nodes containing business logic. <br><br>  Secondly, the cluster manages the life cycle of microservices and provides all the necessary APIs for interaction between them and the data nodes. <br><br>  For this solution, based on the Apache Ignite cluster, use <b>Service nodes</b> (service nodes).  These are the nodes where the microservice code is deployed containing the necessary business logic.  A separate node may contain one or more microservice, depending on the particular solution. <br><br>  Each microservice implements the Service interface, and also is registered in the Apache Ignite node, after which the internal cluster mechanisms allow for fault tolerance and provide a convenient mechanism for calling microservice from other parts of the cluster.  Apache Ignite takes care of deploying one or more copies of microservice on the service nodes.  Cluster internal mechanics also provide load balancing and fault tolerance. <br><br>  In the above figure, microservices are labeled MS &lt;N&gt; (MS1, MS2, etc.).  Due to the separation of logic between service nodes and data nodes, there is no need to restart the entire cluster, if the MS1 microservice needs to be updated.  All you need to do is update the MS1 classes on the service nodes where it is deployed.  Further, it will be necessary to restart only a certain subset of nodes, minimizing the potential impact on the system. <br><br>  All nodes (services and data) are interconnected in a single cluster, which allows MS1, deployed on one node to interact with any other microservice, deployed on another (or the same) node, and also to receive or send data and calculations to any nodes data. <br><br><h3>  Data storage layer </h3><br>  This layer is optional and can be used in scenarios where: <br><br><ul><li>  there is no sense or it is impossible to keep all data in memory; </li><li>  you must be able to recover data from a copy on disk in case the entire cluster falls or you need to restart it. </li></ul><br>  To use the persistent data storage layer, you need to specify for Apache Ignite the implementation of the CacheStore interface.  Among the default implementations, you can find various relational DBMSs, as well as MongoDB, Cassandra, etc. <br><br><h3>  External application interaction layer </h3><br>  This is the ‚Äúclients‚Äù layer of your microservices, various execution branches are initiated from this layer by calling one or more microservices. <br><br>  This layer can communicate with your microservices using protocols specific to that microservice.  At the same time, within the framework of this architectural solution, microservices will communicate with each other using Apache Ignite mechanisms. <br><br>  This architecture provides the possibility of horizontal scaling, allows you to store data in memory and ensures high availability of microservices. <br><br><h2>  Implementation example </h2><br>  The following is a possible implementation of the first layer of the Apache Ignite cluster.  The code that will work with, you can look at: <a href="https://github.com/dmagda/MicroServicesExample">https://github.com/dmagda/MicroServicesExample</a> . <br><br>  In particular, it will be shown how you can: <br><br><ul><li>  configure and run data nodes; </li><li>  implement services using the Apache Ignite Service Grid API; </li><li>  configure and run service nodes; </li><li>  create an application (in its simplest form) that connects to the cluster and initiates the execution of the service. </li></ul><br><h3>  Data nodes </h3><br>  As it was written above, the data node is the Apache Ignite server node, which contains part of the data and allows you to perform queries and calculations initiated by the business logic of the application.  Data nodes are decoupled from business logic and encapsulate only the data storage and processing mechanisms in themselves, accepting specific requests for them from outside. <br><br>  Let's look at the creation of such nodes by example.  To do this, you will need to download the <a href="https://github.com/dmagda/MicroServicesExample">GitHub project</a> that was mentioned earlier. <br><br>  Locate the <a href="">data-node-config.xml</a> file in the project.  This file is used to launch new data nodes.  In it you can see the definition of caches that should be deployed on the cluster, as well as other settings specific to data nodes.  Consider the main ones. <br><br>  <i>Note</i>  <i>translator.</i>  <i>Apache Ignite XML configuration uses Spring to build a tree of objects.</i>  <i>If the reader is not familiar with the Spring configuration, the necessary information can be obtained, for example, from <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/">official documentation</a> (English) or from any <a href="http://www.k-press.ru/cs/2004/3/Spring/Spring.asp">training materials</a> .</i>  <i>Naturally, it is possible to create IgniteConfiguration directly, and also, since Spring mechanisms are used, configuration creation based on annotations or Groovy dialect.</i> <br><br>  First, in this configuration, for each cache, a filter is set, which determines which Apache Ignite nodes will contain information.  This filter will be applied every time the topology changes, when nodes join or leave the cluster.  The filter implementation must be deployed on the classpath of all cluster nodes, including nodes that are not data nodes, and be available on the classpath. <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.apache.ignite.configuration.CacheConfiguration"</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"nodeFilter"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"common.filters.DataNodeFilter"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Secondly, the filter class is implemented, which we defined above.  In this example, one of the simplest approaches is used, when the criterion of whether the node will be responsible for storing data is the attribute of the ‚Äúdata.node‚Äù node.  If this attribute is set and is true, the node will be considered a data node and will contain caches on the network.  Otherwise, the node will be ignored when distributing data across the cluster. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClusterNode node)</span></span></span><span class="hljs-function"> </span></span>{ Boolean dataNode = node.attribute(<span class="hljs-string"><span class="hljs-string">"data.node"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataNode != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; dataNode; }</code> </pre> <br>  Third, the configuration defines the value of the ‚Äúdata.node‚Äù parameter for each node that will use this configuration at startup. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"userAttributes"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">map</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key-type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"java.lang.String"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value-type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"java.lang.Boolean"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">entry</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"data.node"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">map</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Try using the DataNodeStartup class to start a data node, or use ignite.sh or ignite.bat scripts, passing them the configuration specified in data-node-config.xml as an argument.  In the latter case, do not forget to pre-compile the JAR file that will contain the classes from java / app / common, and put this JAR file on the classpath of each data node. <br><br><h3>  Service nodes </h3><br>  In terms of configuration, the service nodes are not much different from the data nodes from the previous section.  Similarly, it is necessary to determine the criterion according to which a subset of Apache Ignite nodes will be allocated, but this subset will no longer be responsible for storing data, but for the operation of microservices. <br><br>  First, you need to define microservice using the <a href="https://apacheignite.readme.io/docs/service-grid">Apache Ignite Service Grid API</a> .  The article will look at the <a href="">MaintenanceService</a> example attached to the repository on GitHub. <br><br>  The service interface looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MaintenanceService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Date </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scheduleVehicleMaintenance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vehicleId)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Maintenance&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMaintenanceRecords</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vehicleId)</span></span></span></span>; }</code> </pre> <br>  The service allows you to plan machine maintenance, as well as receive a list of assigned services.  The implementation, in addition to business logic, contains a definition of Service Grid-specific methods, such as init (...), execute (...) and cancel (...). <br><br>  There are several ways to publish this microservice on a subset of the cluster.  One of them, which will be used in the example, is to define the configuration file maintenance-service-node-config.xml, and start the service nodes with this configuration file and the necessary classes on the classpath.  In this case, the configuration will be as follows. <br><br>  For a start, a filter is defined that allows the service nodes to be distinguished from the rest. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.apache.ignite.services.ServiceConfiguration"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"nodeFilter"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"common.filters.MaintenanceServiceFilter"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  The implementation of the filter is as follows: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClusterNode node)</span></span></span><span class="hljs-function"> </span></span>{ Boolean dataNode = node.attribute(<span class="hljs-string"><span class="hljs-string">"maintenance.service.node"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataNode != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; dataNode; }</code> </pre> <br>  In this implementation, the criterion is that the node has the attribute ‚Äúmaintenance.service.node‚Äù set to true. <br><br>  Finally, nodes will receive this attribute due to the following configuration portion <a href="">maintenance-service-node-config.xml</a> : <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"userAttributes"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">map</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key-type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"java.lang.String"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value-type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"java.lang.Boolean"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">entry</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"maintenance.service.node"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">map</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  <i>Note</i>  <i>translator.</i>  <i>The very fact of placing the service is specified by the code below from the configuration.</i>  <i>The serviceConfiguration lists the services that can theoretically be deployed on this node.</i> <i><br><br></i>  <i>The name property of the service is responsible for the unique name within the cluster, by which, for example, the service can be accessed through a service proxy, the service property refers to the class that implements the service logic, and the totalCount and maxPerNodeCount properties denote the total number of instances that must be maintained and the maximum number of instances on a particular node, respectively.</i>  <i>In this case, the cluster singleton is configured: within the non-segmented cluster there will always be only 1 instance of the service.</i> <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"serviceConfiguration"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  MaintenanceService.          --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.apache.ignite.services.ServiceConfiguration"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--       --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MaintenanceService"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- ,   --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"service"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"services.maintenance.MaintenanceServiceImpl"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--       --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"totalCount"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--   ,      --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"maxPerNodeCount"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag">/&gt;</span></span> ‚Ä¶ <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Try running multiple instances of service nodes using <a href="">MaintenanceServiceNodeStartup</a> or by passing <a href="">maintenance-service-node-config.xml</a> to ignite.sh or ignite.bat, first we put all the necessary classes from java / app / common and java / services / maintenance to the classpath of each of the nodes . <br><br>  In the repository on GitHub you can also find an example of the <a href="">VehicleService</a> service.  You can start instances of this service using the <a href="">VehicleServiceNodeStartup</a> class, or by transferring the <a href="">vehicle-service-node-config.xml</a> file to ignite.sh or ignite.bat, having previously placed all the necessary classes on the classpath. <br><br><h3>  Sample application </h3><br>  Once we have the data nodes configured and ready to start, as well as the service nodes with the MaintenanceService and VehicleService services, we can launch our first application that will use the distributed microservice infrastructure. <br><br>  To do this, run the <a href="">TestAppStartup</a> file from the GitHub repository.  The application will join the cluster, fill the caches with data and perform operations on the deployed microservices. <br><br>  The code for performing operations on the service is as follows: <br><br><pre> <code class="java hljs">MaintenanceService maintenanceService = ignite.services().serviceProxy( MaintenanceService.SERVICE_NAME, MaintenanceService.class, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vehicleId = rand.nextInt(maxVehicles); Date date = maintenanceService.scheduleVehicleMaintenance(vehicleId);</code> </pre> <br>  As you can see, the application works with services using a service proxy.  The beauty of this approach is that the node playing the role of a client does not have to have service implementation classes deployed locally on the classpath ‚Äî only interface classes are enough ‚Äî and it does not need to have the service started locally: the proxy will provide transparent interaction with the remote implementation. <br><br><h2>  Conclusion </h2><br>  In this article, the architecture was considered, which implies the use of microservices on top of Apache Ignite, and an example application that implements this architecture was considered.  The following articles will discuss how to associate a cluster with a persistent data storage layer, as well as how to isolate the interaction layer with external applications. </div><p>Source: <a href="https://habr.com/ru/post/327380/">https://habr.com/ru/post/327380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327370/index.html">I want to know everything: business analysis. Part 2</a></li>
<li><a href="../327372/index.html">Creating a game on the Unreal Engine 4 for 150 hours (video + source)</a></li>
<li><a href="../327374/index.html">Multichannel communication against skimming</a></li>
<li><a href="../327376/index.html">A healthy programmer is a happy programmer.</a></li>
<li><a href="../327378/index.html">Kali Linux 2017.1</a></li>
<li><a href="../327384/index.html">Second webinar on SAP Cloud Platform: a detailed overview of services</a></li>
<li><a href="../327386/index.html">New Intel NUC 7th Generation - Review, Comparison, Testing</a></li>
<li><a href="../327388/index.html">Video about static code analysis</a></li>
<li><a href="../327390/index.html">Video of the reports of the conference AI & BigDataLab over the past three years</a></li>
<li><a href="../327394/index.html">Where did unreliable tests go to Google</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>