<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Profiling already running programs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We all use profilers. The traditional scheme of working with them is such that you have to initially launch the program ‚Äúunder the profiler‚Äù and then,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Profiling already running programs</h1><div class="post__text post__text-html js-mediator-article">  We all use profilers.  The traditional scheme of working with them is such that you have to initially launch the program ‚Äúunder the profiler‚Äù and then, after the end of its work, analyze the raw dump using additional utilities. <br>  And what to do if we, without having root, want to profile an already running program that has been working ‚Äúproperly‚Äù for a long time, but now something has gone wrong.  And we want to do it quickly.  Common situation? <br>  Then consider the most popular profilers and how they work.  And then the profiler, which solves exactly the specified task. <br><br><a name="habracut"></a><br><h1>  Popular Profilers </h1>  If you know fundamentally different - write about him in the comments.  For now, consider these 4: <br><br><h3>  I. gprof </h3>  A good old UNIX profiler that, according to Kirk McKuzick, was written by Bill Joy to analyze the performance of BSD subsystems.  Actually, the profiler is ‚Äúprovided‚Äù by the compiler - it must place control points at the beginning and at the end of each function.  The difference between these two points will be the time of its execution. <br>  It is worth noting that in this case, gprof accurately "knows" and <i>how many</i> times each function was called.  And although it may be necessary in some situations, it also has a negative effect - the overhead of the measurements may be comparable or even more than the function body itself.  Therefore, for example, when compiling C ++ code, optimizations are used resulting in inline. <br>  One way or another, gprof does not work with programs that are already running. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Ii.  Callgrind </h3>  Callgrind is part of Valgrind, an excellent framework for building dynamic code analysis tools.  Valgrind runs the sandboxed program, actually using virtualization.  Callgrind performs profiling based on breakpoint based on <b>call</b> and <b>ret</b> instructions.  It significantly slows down the analyzed code, as a rule, from 5 to 20 times.  Thus, it is usually not suitable for analyzing large data at runtime. <br>  However, the tool is very popular, and the simple <a href="http://valgrind.org/docs/manual/cl-format.html">format of the call graph is</a> supported by excellent visualization tools, for example, kcachegrind. <br><br><h3>  Iii.  OProfile </h3><blockquote>  It is a system-wide profile for Linux systems that is capable of profiling all running at low overhead. </blockquote>  OProfile is a system-wide profiler.  Those.  it is not aimed at working with individual processes, profiling the entire system instead.  OProfile collects metrics by reading not a system timer, like gprof or callgrind, but CPU counters.  Therefore, it requires privileges to run the daemon. <br>  However, this is an indispensable tool when you need to deal with the work of the entire system, the entire server at once.  And especially indispensable when profiling the core area. <br><div class="spoiler">  <b class="spoiler_title">New version OProfile 0.9.8</b> <div class="spoiler_text">  For versions 0.9.7 and earlier, the profiler consisted of a kernel driver and a daemon for data collection.  Since version 0.9.8, this method has been replaced by the use of Linux Kernel Performance Events (requires kernel 2.6.31 or later).  The 0.9.8 release also includes the 'operf' program, which allows unprivileged users to profile individual processes. <br></div></div><br><br><h3>  Iv.  Google perftools </h3>  This profiler is part of the Google perftools suite.  I did not find his review in Habr√©, so I will describe it very briefly. <br>  The kit includes a series of libraries aimed at accelerating and analyzing C / C ++ applications.  The central part is the tcmalloc <a href="http://gperftools.googlecode.com/svn/trunk/doc/tcmalloc.html">allocator</a> , which, in addition to speeding up the allocation of memory, carries the means for analyzing classical problems - memory leaks and heap profile. <br><br>  The second part is <a href="http://gperftools.googlecode.com/svn/trunk/doc/cpuprofile.html">libprofiler</a> , which allows you to collect CPU usage statistics.  It is important to focus on how he does it.  Several times per second (the default is 100), the program is interrupted by a timer signal.  In the handler of this signal, the stack is unwound and all instruction pointers are remembered.  At the end, the raw data is reset to a file, according to which you can already build statistics and call graphs. <br><div class="spoiler">  <b class="spoiler_title">Here are some details of how this is done.</b> <div class="spoiler_text"> 1. By default, the timer signal selects the ITIMER_PROF timer, which ticks only when using the CPU program.  After all, as a rule, we are not very interested where the program was <i>waiting for</i> keyboard input or receipt of data on the socket.  And if it's still interesting, use <code>env CPUPROFILE_REALTIME=1</code> <br><br>  2. The call stack is spun either using libunwind or manually (which requires --fno-omit-framepointer, always works on x86). <br>  3. Function names are subsequently recognized using addr2line (1) <br>  4. Like other Google perftools tools, the profiler can be linked explicitly, or it can be preloaded with <code>LD_PRELOAD</code> . <br></div></div><br>  The principle of operation is interesting - the program is interrupted only N times per second, where N is small enough.  This is the so-called.  sampling profiler.  Its advantage is that it does not have a significant impact on the program being analyzed, no matter how many minor functions there are called.  Due to the nature of the work, he, however, does not allow to answer the question ‚Äúhow many times has this function been called‚Äù. <br>  In the case of the google profiler there are a few more troubles: <br><br><ul><li>  This profiler is also not designed to work with already running programs. </li><li>  latest versions do not work with fork (2), sometimes making it difficult to use it in demons </li></ul><br><br><hr><h1>  Crxprof </h1>  As promised, now about another profiler that is written specifically to solve the problem outlined above - <i>easy</i> profiling of <i>already running</i> processes. <br><br>  He collects the call stack and displays the hottest parts in the console by pressing ENTER.  He also can save the call graph in the above-mentioned callgrind format.  It works quickly and, like any other sampling profiler, does not depend on the complexity of the calls in the program being profiled. <br><div class="spoiler">  <b class="spoiler_title">Some details of the work</b> <div class="spoiler_text">  In general, crxprof also works like perftools, but uses external profiling through <a href="http://man7.org/linux/man-pages/man2/ptrace.2.html">ptrace (2)</a> .  Like perftools, it uses <a href="http://www.nongnu.org/libunwind/">libunwind</a> to unwind the stack, and instead of the hard work of converting to function names, <a href="http://en.wikipedia.org/wiki/Binary_File_Descriptor_library">libbfd is</a> used instead of <a href="http://linux.die.net/man/1/addr2line">addr2line (1)</a> . <br><br>  Several times per second, the program stops (SIGSTOP) and the call stack is ‚Äúremoved‚Äù using libunwind.  Having loaded the map of the functions of the program being profiled and its associated libraries at the start of the crxprof, we can quickly find out which function each instruction pointer belongs to. <br><br>  The call graph is being built in parallel, assuming that there is some central function - the entry point.  This is usually __libc_start_main from the libc library. <br></div></div><br>  <a href="https://github.com/dkrotx/crxprof">Source code</a> is available on github.  Since  The utility was created for me and my colleagues, I fully admit that it may not correspond to your use-case.  One way or another, ask. <br><br>  Collect crxprof and look at an example of its use. <br><br><h3>  Assembly </h3><br>  What is needed: Linux (2.6+), autoconf + automake, binutils-dev (includes libbfd), libunwind-dev (I have it called libunwind8-dev). <br>  To build perform: <br><pre> <code class="bash hljs">autoreconf -fiv ./configure make sudo make install</code> </pre><br>  If libunwind is installed in a nonstandard place, use: <br><pre> <code class="bash hljs">./configure --with-libunwind=/path/to/libunwind</code> </pre><br><br><h3>  Profiling </h3><br>  To do this, just run <br><pre> <code class="bash hljs">crxprof pid</code> </pre><br>  And that's it!  Now use ENTER to display the profile in the console, and ^ C to complete.  Crxprof also displays the profile and the output of the program. <br><div class="spoiler">  <b class="spoiler_title">crxprof: ptrace (PTRACE_ATTACH) failed: Operation not permitted</b> <div class="spoiler_text">  If you see this error, then ptrace on your system is ‚Äúlimited‚Äù.  (Ubuntu?) <br>  Read more <a href="http://askubuntu.com/questions/41629/after-upgrade-gdb-wont-attach-to-process">here.</a> <br>  In short, either start with sudo, or (better) execute in the console: <br><br><pre> <code class="hljs dos">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> | sudo tee /proc/sys/kernel/yama/ptrace_scope</code> </pre><br></div></div><br>  Like all unix utilities, crxprof prints usage when called with the key --help.  See <code>man crxprof</code> . <br><div class="spoiler">  <b class="spoiler_title">crxprof --help</b> <div class="spoiler_text"><pre> Usage: crxprof [options] pid
 Options are:
  -t | --threshold N: n% of time (default: 5.0)
  -d | --dump FILE: save callgrind dump to given FILE
  -f | --freq FREQ: set profile frequency to FREQ Hz (default: 100)
  -m | --max-depth N: show at most N levels while visualizing (default: no limit)
  -r | --realtime: use realtime profile instead of CPU
  -h | --help: show this help
 
  --full-stack: print full stack while visualizing
  --print-symbols: just print funcs and addrs (and quit)
</pre><br></div></div><br><h3>  Real example </h3><br>  In order to give a real, but not complicated, example, I use <a href="">this code</a> in C. Compile, run it and ask crxprof to save the function call graph (4054 - pid of the program being profiled): <br><br><pre> <code class="bash hljs">$ crxprof -d /tmp/test.calls 4054 Reading symbols (list of <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>) reading symbols from /home/dkrot/work/crxprof/<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/a.out (exe) reading symbols from /lib/x86_64-linux-gnu/libc-2.15.so (dynlib) reading symbols from /lib/x86_64-linux-gnu/ld-2.15.so (dynlib) Attaching to process: 6704 Starting profile (interval 10ms) Press ENTER to show profile, ^C to quit 1013 snapshot interrputs got (0 dropped) main (100% | 0% self) \_ heavy_fn (75% | 49% self) \_ fn (25% | 25% self) \_ fn (24% | 24% self) Profile saved to /tmp/test.calls (Callgrind format) ^C--- Exit since ^C pressed</code> </pre><br><br>  According to the statistics displayed on the console, it can be seen that: <br><ul><li>  <b>main ()</b> calls <b>heavy_fn ()</b> (and this is the ‚Äúhardest‚Äù way) </li><li>  <b>heavy_fn ()</b> calls <b>fn ()</b> </li><li>  <b>main ()</b> also calls <b>fn ()</b> directly </li><li>  <b>heavy_fn ()</b> takes half the CPU time </li><li>  <b>fn ()</b> takes remaining CPU time </li><li>  <b>main ()</b> by itself does not consume anything </li></ul><br><br><img src="https://habrastorage.org/storage2/9a8/fa0/0e5/9a8fa00e51bbf6e48b08de17e24dad34.png" align="right"><br>  The visualization is done according to the ‚Äúlargest subtrees first‚Äù scheme.  Thus, even for large real-world programs, you can use simple visualization in the console, which should be convenient on the servers. <br><br>  To visualize complex call graphs, it is convenient to use KCachegrind: <br><br><pre> <code class="bash hljs">$ kcachegrind /tmp/test.calls</code> </pre><br>  The picture that I got is on the right. <br>  Instead of concluding, let me remind you that only a few of my colleagues and myself use the profiler.  I hope it will also be useful to you. </div><p>Source: <a href="https://habr.com/ru/post/167837/">https://habr.com/ru/post/167837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../167827/index.html">How we did our last amateur translation</a></li>
<li><a href="../167829/index.html">The study of the puzzle game "Minesweeper" (continued)</a></li>
<li><a href="../167831/index.html">Library morelinq: what is missing in LINQ to Objects out of the box</a></li>
<li><a href="../167833/index.html">A hybrid airship successfully passed the first tests</a></li>
<li><a href="../167835/index.html">Google patented a smartphone with 8 flashes</a></li>
<li><a href="../167839/index.html">Delivery - or the ‚Äúquickest way to go bankrupt on Kickstarter‚Äù</a></li>
<li><a href="../167843/index.html">Flight - a new js-framework from Twitter</a></li>
<li><a href="../167847/index.html">Why do we continue to break deadlines</a></li>
<li><a href="../167849/index.html">A little philosophical post about how we looked into the eyes</a></li>
<li><a href="../167851/index.html">The end of another era: Philips is leaving the consumer electronics market</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>