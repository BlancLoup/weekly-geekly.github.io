<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SSLR: Screen Space Local Reflections in AAA Games</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello Friend! This time I will again raise the question of the schedule in AAA games. I already sorted out the HDRR technique (not to be confused with...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SSLR: Screen Space Local Reflections in AAA Games</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12d/b8e/fbd/12db8efbda5056ebd86437f1a08396ec.jpg" alt="image"></div><br>  Hello Friend!  This time I will again raise the question of the schedule in <i>AAA</i> games.  I already sorted out the <b>HDRR</b> technique (not to be confused with HDRI) <a href="http://habrahabr.ru/post/238425/">here</a> and talked a little bit about color correction.  Today I‚Äôll tell you what is <b>SSLR</b> (also known as SSPR, SSR): <i>Screen Space Local Reflections</i> .  Who cares - under cat. <a name="habracut"></a><br><br><h4>  Introduction to Deferred Rendering </h4><br>  To begin, I will introduce such a thing as <b>Deferred Rendering</b> (not to be confused with <b>Deferred Shading</b> , as the latter refers to lighting).  What is the essence of <i>Deferred Rendering</i> ?  The fact is that all effects (such as lighting, global shading, reflections, <i>DOF</i> ) can be separated from the geometry and these effects can be implemented as a special kind of post-processing.  For example, what do you need to apply <b>DOF</b> ( <i>Depth Of Field</i> , blur over long distances) to our scene?  Have the scene itself ( <i>Color Map</i> ) and have information about the position of the texel (in other words, how many pixels away from the camera).  Further - everything is simple.  Apply <i>Blur</i> to the <i>Color Map</i> , where the blur radius will depend on the pixel depth (from <i>Depth Map</i> ).  And if you look at the result - the farther the object, the stronger it will be blurred.  So what does the <i>Deferred Rendering</i> technique do?  It builds the so-called <b>GBuffer</b> , which usually includes three textures ( <i>RenderTarget</i> ): <br><br><ul><li>  <b>Color map</b> (information about the diffuse component or just the color of the pixel) <br><img src="https://habrastorage.org/getpro/habr/post_images/ab6/821/7c4/ab68217c496ab3bd0f037c7442972a03.jpg" alt="image"></li><li>  <b>Normal map</b> (pixel normal information) <br><img src="https://habrastorage.org/getpro/habr/post_images/820/97f/879/82097f8799a9f906abceab4d10f138b5.jpg" alt="image"></li><li>  <b>Depth map</b> (information about the position of the "pixel", then store only the depth) <br><img src="https://habrastorage.org/getpro/habr/post_images/60b/74f/d6c/60b74fd6cd2fbab0d7943cf18b9e7924.jpg" alt="image"></li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the case of the <i>Color map</i> , the <i>Normal map</i> seems to be all clear, these are regular <i>Surface.Color</i> textures: perhaps, except that the normal vector can lie within <b>[-1, 1]</b> (using simple vector packaging in the format <b>[0, 1]</b> ). <br><br>  But the situation with the <i>Depth map</i> becomes incomprehensible.  How does the <i>Depth map</i> store information about the position of a pixel, and even with a single number?  If to speak strongly simplified, the transformation of the primitive: <br><br><pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> vertexWVP = mul(vertex, World*<span class="hljs-keyword"><span class="hljs-keyword">View</span></span>*Projection);</code> </pre> <br><br>  Gives us screen coordinates: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float2</span></span> UV = vertexWVP.xy;</code> </pre> <br><br>  And some information about how far the pixel is from the camera: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> depth = vertexWVP.z / vertexWVP.w;</code> </pre> <br><br>  Based on this, we do not need <i>UV</i> , because  when drawing a conventional quad on full screen, it is already known.  Therefore, it is worth storing in the depth map not the pixel position, but only the depth. <br><br>  In the future, we will be able to reconstruct the pixel position in a very simple way: <br><br><pre> <code class="hljs pgsql">float3 GetPosition(float2 UV, <span class="hljs-type"><span class="hljs-type">float</span></span> depth) { <span class="hljs-type"><span class="hljs-type">float4</span></span> position = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f; position.x = UV.x * <span class="hljs-number"><span class="hljs-number">2.0</span></span>f - <span class="hljs-number"><span class="hljs-number">1.0</span></span>f; position.y = -(UV.y * <span class="hljs-number"><span class="hljs-number">2.0</span></span>f - <span class="hljs-number"><span class="hljs-number">1.0</span></span>f); position.z = depth; //<span class="hljs-keyword"><span class="hljs-keyword">Transform</span></span> Position <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Homogenous Space <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> World Space position = mul(position, InverseViewProjection); position /= position.w; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position.xyz; }</code> </pre> <br><br>  Let me remind you that to build <b>GBuffer</b> you need such a technique as <b>MRT</b> ( <i>Multiple Render Targets</i> ), which draws the model in several <i>Render Target</i> at once (and each <i>RT</i> contains different information).  One of the rules of <i>MRT</i> - the dimension of all <i>Render Target</i> should be the <u>same</u> .  In the case of <i>Color Map</i> , <i>Normal Map</i> - <i>Surface.Color</i> : 32 bit <i>RT</i> , where each <i>ARGB</i> channel has 8 bits, i.e.  256 gradations from 0 to 1. <br><br>  Thanks to this approach, we can apply complex effects to any geometry, for example, the most popular Screen Space effect: SSAO (Screen Space Ambient Occlusion).  This algorithm analyzes the depth and normal buffers, considering the level of shading.  I will not describe the whole algorithm, it has already been <a href="http://habrahabr.ru/post/204260/">described</a> on Habr√©, I‚Äôll just say that the algorithm‚Äôs task is to trace the depth map: we have a set of random vectors directed from the counted ‚Äúpixel‚Äù and we need to find the number of intersections with the geometry. <br><br>  Example effect (left without SSAO, right with SSAO): <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56c/0e5/f42/56c0e5f42ef1412afaa43cdedc86587f.jpg" alt="image"></div><br><br>  <b>Deferred Shading</b> is also a <b>Screen Space</b> effect.  Those.  for each light on the screen (without any optimizations) we draw a quad in <i>Additive</i> mode in the so-called <i>RenderTarget</i> : <i>Light Map</i> .  And knowing the world position of the ‚Äúpixel‚Äù, its normal, the position of the light source - we can calculate the illumination of this pixel. <br><br>  <i>Deferred Shading</i> example (lighting is postponed, after geometry has been drawn): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca1/11d/a7b/ca111da7be411812d34b999f1c22c4fb.jpg" alt="image"></div><br><br><h5>  Advantages and problems Screen Space effects </h5><br>  <u>The most important advantage of</u> <i>Screen Space</i> effects is the independence of the complexity of the effect on geometry. <br><br>  <u>The main disadvantage</u> is the locality of all effects.  The fact is that we will constantly encounter <b>Information Lost</b> , in many cases this is highly dependent on the review, since <i>SSE</i> depends on the adjacent depths of texels that can be generated by any geometry. <br><br>  Well, it is worth canceling that <b>Screen Space effects</b> are performed completely on the GPU and are post-processing. <br><br><h4>  Finally SSLR </h4><br>  After the whole theory, we came to the effect of <b>Screen Space Local Reflections</b> : local reflections in screen space. <br><br>  First, let's look at the perspective projection: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fb/4e3/603/9fb4e3603836f19a3c05f230b03c2ef7.jpg" alt="image"></div><br><br>  The horizontal and vertical angle of view is set to <i>FOV</i> (usually 45 degrees, I prefer 60 degrees), in the virtual camera they are different.  <i>Aspect Ratio</i> (aspect ratio) is also taken into account. <br><br>  The projection window (where we operate with <i>UV-space</i> data) is what we see, we project our scene. <br>  The front and rear cut-off planes are, respectively, <i>Near Plane, Far Plane</i> , also set in projection as parameters.  In the case of <i>Deferred Rendering, doing</i> too far <i>Far Plane is</i> worth <i>doing</i> , because  The accuracy of the <i>Depth Buffer</i> will drop a lot: it all depends on the scene. <br><br>  Now, knowing the projection matrix and position on the projection window (as well as the depth) for each pixel, we calculate its position as follows: <br><br><pre> <code class="hljs go">float3 GetPosition(float2 UV, float depth) { float4 position = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; position.x = UV.x * <span class="hljs-number"><span class="hljs-number">2.0f</span></span> - <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; position.y = -(UV.y * <span class="hljs-number"><span class="hljs-number">2.0f</span></span> - <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); position.z = depth; position = mul(position, InverseViewProjection); position /= position.w; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position.xyz; }</code> </pre> <br><br>  After we need to find a vector of a look at this pixel: <br><br><pre> <code class="hljs lisp">float3 viewDir = normalize(<span class="hljs-name"><span class="hljs-name">texelPosition</span></span> - CameraPosition)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  The CameraPosition is the camera position. <br>  And find the reflection of this vector from the normal in the current pixel: <br><br><pre> <code class="hljs lisp">float3 reflectDir = normalize(<span class="hljs-name"><span class="hljs-name">reflect</span></span>(<span class="hljs-name"><span class="hljs-name">viewDir</span></span>, texelNormal))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Next, the task is reduced to tracing the depth map.  Those.  we need to find the intersection of the reflected vector with any geometry.  It is clear that any tracing is done through iteration.  And we are very limited in them.  Since  each <i>Depth Map</i> sample is worth the time.  In my version, we take some initial approximation <b>L</b> and dynamically change it based on the distance between our texel and the position that we ‚Äúrestored‚Äù: <br><br><pre> <code class="hljs pgsql">float3 currentRay = <span class="hljs-number"><span class="hljs-number">0</span></span>; float3 nuv = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">float</span></span> L = LFactor; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { currentRay = texelPosition + reflectDir * L; nuv = GetUV(currentRay); //     <span class="hljs-type"><span class="hljs-type">float</span></span> n = GetDepth(nuv.xy); //    DepthMap  UV float3 newPosition = GetPosition2(nuv.xy, n); L = length(texelPosition - newPosition); }</code> </pre> <br><br>  Auxiliary functions, the translation of the world point on the screen space: <br><br><pre> <code class="hljs go">float3 GetUV(float3 position) { float4 pVP = mul(float4(position, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>), ViewProjection); pVP.xy = float2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) + float2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>) * pVP.xy / pVP.w; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float3(pVP.xy, pVP.z / pVP.w); }</code> </pre> <br><br>  After the completion of the iterations, we have the position of ‚Äúintersection with the reflected geometry‚Äù.  And our nuv value will be the projection of this intersection onto the screen, i.e.  <b>nuv.xy</b> is the <b>UV</b> coordinates in our screen space, and <b>nuv.z</b> is the restored depth <i>(i.e. abs (GetDepth (nuv.xy) -nuv.z) must be very small)</i> . <br><br>  At the end of the iterations, <b>L</b> will show the distance of the reflected pixel.  The last step is actually adding a reflection to the <b>Color Map</b> : <br><br><pre> <code class="hljs pgsql">float3 cnuv = GetColor(nuv.xy).rgb; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">float4</span></span>(cnuv, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><br>  Let's dilute the theory with illustrations, the original image (the contents of the Color Map from the GBuffer): <br><div style="text-align:center;"><img src="http://habrastorage.org/files/c5c/aaa/033/c5caaa03385f4090a139d72688f9733b.png"></div><br><br>  After compiling the shader (reflection) we get the following picture (Color Map from GBuffer + SSLR shader result): <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/170/8cc/7c1/1708cc7c107d4b9db774594537bf7a74.png"></div><br><br>  <b>Not a lot</b> .  And here it is worth recalling once again that <b>Space-Screen</b> effects are solid <b>Information Lost</b> (examples are highlighted in red frames). <br><br>  The fact is that if the reflection vector goes beyond the limits of the <b>Space-Screen</b> , the information on the <b>Color</b> card becomes inaccessible and we see <i>Clamping of</i> our <i>UV</i> . <br><br>  To partially fix this problem, you can enter an additional factor that will reflect the ‚Äúrange‚Äù of reflection.  And further on this coefficient we will shade the reflection, the problem is partially solved: <br><br><pre> <code class="hljs lisp">L = saturate(<span class="hljs-name"><span class="hljs-name">L</span></span> * LDelmiter); float error *= (<span class="hljs-number"><span class="hljs-number">1</span></span> - L)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><br>  The result, a reflection multiplied by <i>error</i> (an attempt to remove the SSLR artifact - information lost): <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/4b6/bdf/bf3/4b6bdfbf34944e328ce53207a28b8f99.png"></div><br><br>  Already better, but we notice another problem, what happens if the vector is reflected in the direction of the camera?  <i>Clamping</i> 'and <i>UV</i> will not occur, however, despite the relevance of UV (x&gt; 0, y&gt; 0, x &lt;1, y &lt;1) it will be incorrect: <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/28c/e70/3be/28ce703be6a943e38fc8ba6b1925b9da.png"></div><br><br>  This problem can also be partially solved, if you somehow limit the angles of permissible reflections.  A chip with angles from <i>the Fresnel effect is</i> ideal for this: <br><br><pre> <code class="hljs lisp">float fresnel = dot(<span class="hljs-name"><span class="hljs-name">viewDir</span></span>, texelNormal)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Slightly modify the formula: <br><br><pre> <code class="hljs lisp">float fresnel = <span class="hljs-number"><span class="hljs-number">0.0</span></span> + <span class="hljs-number"><span class="hljs-number">2.8</span></span> * pow(<span class="hljs-number"><span class="hljs-number">1</span></span>+dot(<span class="hljs-name"><span class="hljs-name">viewDir</span></span>, texelNormal), <span class="hljs-number"><span class="hljs-number">2</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Fresnel values, taking into account the Normal-mapping (values ‚Äã‚Äãof the fresnel variable for the SSLR algorithm): <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/003/ce4/e5a/003ce4e5a3644be1bd9429d9c3ef9cf7.png"></div><br><br>  Those areas that are reflected in the ‚Äúcamera‚Äù will be black, and we do not take them into account (in return, you can make a fade into a cubic texture). <br><br>  Reflection multiplied by <i>error</i> and <i>fresnel</i> (attempting to remove most of the SSLR artifacts): <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/1c5/60e/826/1c560e826a7a42eb905fc93d1b8932d5.png"></div><br><br>  By the way, the value of <i>Fresnel</i> should be limited by any parameter, since  due to the ‚Äúroughness‚Äù of the normals, the value will be an order of magnitude greater than one (or another limiter number). <br><br>  And the final stage of today's article is a blur of reflections, because  perfect reflection only at the mirror.  The degree of blurring can be considered as <b>1-error</b> (the farther the reflected pixel is, the more blurry it is).  This will be a kind of weight blur and you can store it in the alpha channel <i>RT-</i> reflections. <br><br>  Result (final image with harvested artifacts and blurred reflections): <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/a34/7ae/cff/a347aecffc114e46adba1e09e635ebb1.png"></div><br><br><h4>  Conclusion </h4><br>  Also, it is worth adding some information about the reflectivity: how much a clear reflection, how much the surface is generally able to reflect, in those places where SSLR does not work - add a static reflection of the cube texture. <br><br>  Of course, the <b>Space-Screen</b> effects are not honest, and the developers are trying to hide the artifacts, but now in real-time this cannot be done (with complex geometry).  And without such effects, the game starts to look somehow wrong.  I described the general method of <b>SSLR</b> : I brought the main points from the shader.  The code, unfortunately, can not attach, because  There are too many dependencies in the project. <br><br>  <i>Successful developments!</i>  <i>;)</i> </div><p>Source: <a href="https://habr.com/ru/post/244367/">https://habr.com/ru/post/244367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244357/index.html">10 universal tips for visitors to any IT conference</a></li>
<li><a href="../244359/index.html">How we did the polar graph in DevExtreme</a></li>
<li><a href="../244361/index.html">Protothread and cooperative multitasking</a></li>
<li><a href="../244363/index.html">Wind of Change: ARM Server Expansion Continues</a></li>
<li><a href="../244365/index.html">Integration of a computer information system into a business</a></li>
<li><a href="../244371/index.html">Unsuccessful experience in restoring pre-installed Windows 8.1 on an HP Pavilion laptop</a></li>
<li><a href="../244373/index.html">Raising the ‚Äúvirtualka‚Äù chroot with ubuntu to build packages</a></li>
<li><a href="../244375/index.html">IBM invites to the IBM SolutionsConnect 2014 conference</a></li>
<li><a href="../244379/index.html">Interview with Rudi Hein: bestseller developer shares the secrets of the success of their applications</a></li>
<li><a href="../244381/index.html">The first experience in game development. Errors and conclusions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>