<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cache Theory (Part Two, Practical, Augmented)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the second, additional (upd: supplemented) part of my article on caching information in web development. The first is called Cache Theory . 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cache Theory (Part Two, Practical, Augmented)</h1><div class="post__text post__text-html js-mediator-article">  This is the second, additional (upd: supplemented) part of my article on caching information in web development.  The first is called <a href="http://habrahabr.ru/blogs/webdev/38771/">Cache Theory</a> . <br><br>  <b>UPD:</b> After numerous comments, I strongly reworked the article, added more specifics and examples to it, and also removed controversial points (for example, regarding memcached).  Thank you all for your constructive criticism. <br><br>  In this article I will try to describe the practical aspects of caching, focused primarily on sites and content management systems.  <b>Immediately I warn you, this is my personal opinion, which does not pretend to the ultimate truth.</b>  <b>Most terminology is mine; you can use it if you see fit at your discretion.</b>  <b>Constructive criticism is welcome.</b> <br><a name="habracut"></a><br>  So. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  What to cache </h4><br>  No matter how strange it may seem, caching is not everything.  Caching mechanisms themselves consume resources, and if we say information changes as often as it is output, then there is no sense in caching this information (for example, a statistics system).  It is also not worth caching processes that are already fast. <br><br>  <i>For example: Data is changed every 1 second.</i>  <i>There is a request to receive this data every 2 seconds.</i>  <i>The data is cached for 0.1 seconds, and 0.2 seconds is sent from the cache.</i>  <i>Then, when accessing data, there will always be a situation when we need to rebuild the data - which will take 1 + 0.1 seconds.</i>  <i>And data from a cache practically will not be given.</i>  <i>We lose this 0.1 sec because of the cache.</i> <br><br>  The first thing that needs to be cached is information that is calculated extremely long and resource-intensive, and is used very often.  Applicable to sites are the results of the execution of modules (or applications) that use complex database queries.  In addition, resource-intensive processes include calls to external resources using the connection setup (sockets, curl, etc.), as well as working with a large amount of complex data (parsing templates, working with images, etc.). <br><br><h4>  Where to cache </h4><br>  Further, in descending order of cache access speed: <br><br>  <b>Memory.</b>  These are memcached, APC, XCache and other similar technologies in the same vein.  They (as a rule) provide the maximum access speed, but the volume is very limited.  Memory is not suitable for big data, but it is well suited for relatively small amounts of the most frequently used data, such as say templates, etc. <br><br>  <i>For example, we use a SAX parser.</i>  <i>It slowly parses the patterns.</i>  <i>We do the following:</i> <i><br><br></i>  <i>When requesting a template, it is first checked whether it is in memory.</i>  <i>If so, it is pulled out, made <a href="http://ru.php.net/manual/ru/function.unserialize.php">unserialize</a> and given.</i>  <i>If not, we create an object (parse the template), serialize it ( <a href="http://ru.php.net/manual/ru/language.oop.serialization.php">serialize</a> ) and store it in memory (we denote the name as a hash code from the file path).</i>  <i>It remains only to decide on what basis we will update the cache data.</i>  <i>This can be done in 2 ways:</i> <i><br><br></i>  <i>1. We will not check changes at all, and the cache will exist for some time, say, updated once an hour.</i>  <i>Accordingly, with a physical change in the pattern, they will take effect a maximum of an hour later.</i> <i><br><br></i>  <i>2. We will monitor changes to the template by the time it was last saved.</i>  <i>To do this, we need another variable in memory - the time the data is written to the cache (can be called as the name of the template variable in memory with the prefix time).</i>  <i>Accordingly, we will have to set it equal to the current time when the template object is in memory.</i>  <i>Further, when referring to the template, we first compare the time of the template file change ( <a href="http://ru.php.net/manual/ru/function.filemtime.php">filemtime</a> ) with the time cached in memory.</i>  <i>And if the time for changing the template is longer than the cache time, then we update it.</i>  <i>With this approach, the cache can exist forever if the template itself never changes.</i>  <i>But as soon as it changes, the cache will be rebuilt.</i> <i><br></i> <br><br>  <b>File system.</b>  The most commonly used method.  But there are some pitfalls here too.  Access to files is significantly slowed down, there are a lot of them in the directory (the more files, the slower the speed), and on some file systems there are generally restrictions on the number (ext2 - 32768 files in a directory).  This must be strictly followed.  For example, it is impossible to dump some tabular data in one directory and make the names equal to the primary keys.  You just have such a scheme ever overflow. <br><br>  <i>This is how you can do this in php:</i> <br> <code>&lt;? <br> function saveCache($name, $data) <br> { <br> $hash = sha1($name); <br> $chunks = str_split($hash, 4); <br> $cache_dir = CACHE_DIR.'/'.$chunks[0].'/'.$chunks[1]; <br> if (!is_dir($cache_dir)) mkdir($cache_dir, 0775, true); <br> return file_put_contents($cache_dir.'/'.$hash, serialize($data)); <br> } <br> ?&gt; <br></code> <br><br>  <b>Database.</b>  Can also be used for cache.  The database has a strong advantage ‚Äî sampling through SELECT.  If there is little data, but they depend on a huge number of conditions, then using the database is justified, especially if you correctly create indexes in the table.  For example, a table in a database can be used as a repository of the result of sampling a complex query with the union of many large tables using a large number of conditions.  The query itself can be placed in a temporary table, and data is already selected from it.  The sampling conditions will also be complicated, but there will be no more numerous JOINs, which will increase the speed <i>(especially if you use <a href="http://dev.mysql.com/doc/refman/4.1/en/memory-storage-engine.html">ENGINE MEMORY</a> applicable to MySQL)</i> . <br><br>  Another advantage of caching in the database is proactive cache preparation.  For example, the first and only request can be to pull out all the data for caching on a specific page and then use it if necessary.  Caching in the database is of course slow, but competent organization can seriously improve the efficiency of using the cache.  And yet - there is SQLite, which is also well suited for this.  A special exclusive is the creation of the SQLite database itself in memcached. <br><br>  <i>Using a database for cache seems to me a rare option.</i>  <i>This is more an opportunity than a practical application.</i>  <i>Simply, do not lose sight of it.</i> <br><br><h4>  How to cache </h4><br>  Caching is usually used to hash a string containing all the parameters on which the cache depends.  If at least some parameter has changed, then the hash code itself will change.  For storage in the file system, the first few characters are ‚Äúcut off‚Äù from the hash and corresponding directories are created so that the file system does not overflow.  The change time for the file system is the file modification time, for the database a separate field is needed, for the memory - a separate parameter <i>(see the example above)</i> . <br><br>  Without a hash code, your dependency string can swell up a lot, especially if there are a lot of them. <br><br>  <b>Expanded example:</b> <br><br>  For example, in the database of 50,000 articles.  A request to the base for one article works for a long time, which is not surprising with such volume.  Just be lucky - we do not have JOIN other talits. <br><br>  We do the following - we write some dependencies in the dependency table.  The table we can have is a simple array that is serialized and put into a file.  This is necessary to check the relevance of the cache, to decide to rebuild the cached data due to their change, or you can use the existing in the cache.  With any change in our table in the database, we update this dependency in the table, i.e.  we set the time equal to the current one.  We have large volumes, so it is better to use caching in the file system. <br><br>  Put the result of the execution in the cache.  When re-requesting, we compare the cache file change time with the time from the dependency table.  If the time of the cache file is less, rebuild - otherwise we give what is in the cache. <br><br>  Now.  If we have changed one letter in one of the 50,000 articles, the cache will drop for everyone, which is not effective.  Let's try to avoid this: <br><br>  Suppose we have for each article a place where it is displayed in full.  There is also a tape of articles, which displays summary information for all, which is also cached as described above.  If one article changes, then the place where it is displayed in full will change, as well as the tape (because it is present in it).  Then we will create a separate cache for each article and a separate cache for the feed: <br><br>  The tape cache <i>obviously</i> depends on the dependency grid (and <i>implicitly depends</i> on each individual article), i.e.  the time of the last change to the table with the articles in the database.  But a single article <i>conditionally depends</i> on this time, i.e.  it depends on it, <i>provided</i> that this particular article has changed.  Therefore, when showing a separate article, we will not use this time: if there is an article cache, we will show it.  If not, then build the article and put in the cache.  But, an important condition for this is that when editing a single article, we must delete its cache. <br><br>  In summary: When editing an article, we update the time in the dependency table and destroy the cache of this article.  When a tape is shown, the decision to update it is made based on a dependency table.  When displaying a separate article, if there is a cache, then it is shown.  thus, when the article is changed, the list cache and this article are restructured, but the cache of other articles is not affected. <br><br><h4>  What else you need to pay attention </h4><br>  When caching into the file system, you cannot push the entire cache into one place.  That is, for each individual objects it is better to use your own directory, for example, for pages / cache / pages, for users / cache / users, and so on.  It is necessary that the data do not coincide by chance.  Suppose you have 2 different entities with the same id.  It so happened that you need to save the cache of both only for this id.  The hash in both cases will be the same, thereby causing a conflict.  But if for each entity will be allocated its place, it will not. <br><br>  When deleting an item, you must not forget to delete the cache itself.  Otherwise, it will swell over time due to the large amount of irrelevant data.  As an option - periodic physical removal of the entire cache. <br><br>  There is still such a thing as a ‚Äúfast‚Äù cache (FastCache, my terminology).  The idea behind FastCache is to cache the most frequently used objects in the fastest way, sweeping aside everything else.  For example, you can put a completely created home page in memory and give it, if nothing has changed, to non-logged users.  The main load goes to the main page, so it can greatly relieve resources. <br><br><h4>  Conclusion </h4><br><br>  As correctly noted in one of the comments of the previous article, caching is part of website optimization, which is especially effective with high-load systems.  Site performance does not consist of the effectiveness of the cache alone.  Moreover, sometimes it can be generally superfluous, so you should think well before ‚Äúscrewing up the cache.‚Äù  If, for example, site traffic of less than 1000 people per day, you can not think about caching.  Although of course, depending on which site. <br><br>  Thanks for reading! <br></div><p>Source: <a href="https://habr.com/ru/post/38911/">https://habr.com/ru/post/38911/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../38905/index.html">Acapela Alyona Voice Engine</a></li>
<li><a href="../38906/index.html">Augmented Reality Barcode</a></li>
<li><a href="../38907/index.html">MySQL Performance real life Tips and Tricks</a></li>
<li><a href="../38909/index.html">"Death March" Volume 2. Yordon's Second Coming</a></li>
<li><a href="../38910/index.html">End of CSS expressions</a></li>
<li><a href="../38912/index.html">Available for download ReSharper 4.1</a></li>
<li><a href="../38914/index.html">Where better to keep a blog?</a></li>
<li><a href="../38915/index.html">Chrome & Mouse gestures</a></li>
<li><a href="../38917/index.html">Million</a></li>
<li><a href="../38918/index.html">The problem of choosing the future path of a young specialist.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>