<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Auto registration of tests on C language tools</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="More recently, there was an article ‚ÄúSemi-automatic registration of unit tests on pure C‚Äù in which the author demonstrated the solution of the problem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Auto registration of tests on C language tools</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/3d3/aed/597/3d3aed597f8645ed9d1502e4532642ee.png" alt="Testing in C" align="left">  More recently, there was an article <a href="http://habrahabr.ru/post/240565/">‚ÄúSemi-automatic registration of unit tests on pure C‚Äù</a> in which the author demonstrated the solution of the problem using counters from Boost.  Following the same principle, a (successful) attempt was made to repeat this experience without using Boost for reasons of the illogicality of having a C dependence on Boost in a project, and also in such a small amount.  At the same time, there were a lot of preprocessor support directives in the tests.  And everything would have remained so, but practically at the final stage an alternative method of registration was found, which allows completely get rid of additional actions.  This is a C89 solution for registering tests and a slightly more system-demanding solution for registering test suites. <a name="habracut"></a><br><br>  The motivation of all this is simple and clear, but for the sake of completeness it is worth briefly identifying it.  In the absence of auto-registration, one has to deal with either typing / inserting a repeating code, or generators external to the compiler.  The first is reluctant to do plus the exercise itself is error prone, the second adds unnecessary dependencies and complicates the build process.  The idea of ‚Äã‚Äãusing C ++ in tests only for the sake of this opportunity, when everything else is written in C, evokes a feeling of firing from a cannon at sparrows.  To all this, in principle, it is interesting to solve the problem at the same level at which it arose. <br><br>  We define the final goal as something like the code below with the additional condition that test names are not repeated anywhere except where they are defined, i.e.  they are dialed once and only once and then not copied by any oscillator. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs">TEST(test1) { <span class="hljs-comment"><span class="hljs-comment">/* Do the test. */</span></span> } TEST(test2) { <span class="hljs-comment"><span class="hljs-comment">/* Do the test. */</span></span> }</code> </pre> <br>  After a small digression to introduce certainty in the terminology, it will be possible to start searching for a solution. <br><br><h3>  Terminology and proposed test structure </h3><br>  Different test frameworks are inconsistently using words to designate individual tests or their groups.  Therefore, we will define some words explicitly, and at the same time we will show their meaning using the example of a fairly common test structure. <br><br>  A <i>collection of tests</i> (‚Äúsuite‚Äù) will be understood as a group <i>of test suites</i> (‚Äúfixture‚Äù).  This is the largest structural unit of the hierarchy.  The sets in turn group the tests inside the collection.  Tests by themselves.  The number of elements of each type is arbitrary. <br><br>  This is graphically: <br><br><img src="https://habrastorage.org/files/ffb/91e/49c/ffb91e49c7e14dacab0c3c956e9e413a.png"><br><br>  Each higher level combines elements of smaller ones and optionally adds preparation procedures (‚Äúsetup‚Äù) and completion (‚Äúteardown‚Äù) tests. <br><br><h3>  Registration of tests in sets </h3><blockquote>  <i>Never let you know your mind.</i> <br>  - ISAAC ASIMOV, <i>Foundation</i> </blockquote><br>  Separate tests are added more often than whole sets, therefore auto-registration is more relevant for them.  Also, they are all located within the same translation unit, which simplifies the solution of the problem. <br><br>  So, it is necessary to organize the repository of the list of tests by means of the language, without using the preprocessor as the main control element.  Failure to preprocessor means that we remain without explicit counters.  But the presence of a counter is almost mandatory if it is necessary to uniquely identify tests and, in general, to somehow contact them, and not just declare them.  At the same time, there is always a built-in macro <code>__LINE__</code> at hand, <code>__LINE__</code> you need to figure out how to apply it in this situation.  There is one more limitation: some explicit assignments to the elements of a global array for the similarity <br><br><pre> <code class="cpp hljs">test_type tests[]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Do the test. */</span></span> } tests[__LINE__] = &amp;test;</code> </pre><br>  they are not suitable, since outside the functions such operations are simply not supported at the language level.  The initial situation does not look very rosy: <br><br><ol><li>  There is no possibility to store either intermediate or final state. </li><li>  There is no way to identify disconnected elements, and then assemble them together. </li><li>  As a result, there is no possibility to define a coherent structure (basically an array, but the list is also suitable, there would be a way), due to the inability to refer to the previous entity. </li></ol><br>  But not everything is as hopeless as it may seem.  Imagine the ideal option, as if we have something that is missing.  In this case, the code after the expansion of the auxiliary macros could look something like this: <br><br><pre> <code class="cpp hljs">MagicDataStructure MDS; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Do the test. */</span></span> } MDS[__LINE__] = &amp;test1; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Do the test. */</span></span> } MDS[__LINE__] = &amp;test2; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fixture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MDS.length; ++i) { MDS.func[i](); } }</code> </pre><br>  Things are easy: implement a ‚Äúmagic‚Äù structure, which, by the way, is suspiciously similar to an array of predetermined size.  It makes sense to think about how we would work if it were an array in reality: <br><br><ol><li>  You would define an array by initializing all <code>NULL</code> elements. </li><li>  Assign values ‚Äã‚Äãto individual elements. </li><li>  Bypass the entire array and call each non- <code>NULL</code> element. </li></ol><br>  This set of operations is all that we need and does not look too unreal, perhaps arrays will really come in handy here.  By definition, an array is a collection of similar elements.  Usually this is some kind of single entity with support for the indexing operation, but it makes sense to treat the same array as a group of separate elements.  Let's say whether this <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre><br>  either <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr0, arr1, arr2, arr3;</code> </pre><br>  At the moment and in light of the mention of the macro <code>__LINE__</code> above, it should already be clear where the author is <code>__LINE__</code> .  It remains to understand how you can implement a pseudo-array with support for assignment at the compilation stage.  This seems to be an interesting exercise, so you should wait a little more with the demonstration of the ready-made solution and ask the following questions: <br><br><ol><li>  Which entity in C can appear more than once and not cause a compilation error? </li><li>  What can be interpreted by the compiler in different ways depending on the context? </li></ol><br>  Think of header files.  After all, what is in them is usually present somewhere else in the code.  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* file.h */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-comment"><span class="hljs-comment">/* file.c */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"file.h"</span></span></span><span class="hljs-meta"> int a = 4; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ... */</span></span></span></span></code> </pre><br>  In this case, everything works fine.  Here is an example closer to the problem: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ run(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre><br>  Quite a mediocre code that can be slightly extended to achieve the desired functionality: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; static void (*run_func)(void); int main(int argc, char *argv[]) { if (run_func) run_func(); return 0; } static void run(void) { puts("Run!"); } static void (*run_func)(void) = &amp;run;</span></span></span></span></code> </pre><br>  The reader is invited to independently verify that changing the order or commenting on the last mention <code>run_func</code> is consistent with expectations, i.e.  if <code>run_func</code> not <code>run_func</code> , then the only element of the ‚Äúone-element array‚Äù ( <code>run_func</code> ) is <code>NULL</code> , otherwise it points to the <code>run()</code> function.  The lack of dependence on the order is an important property that allows you to hide all the "magic" in the header file. <br><br>  From the example above, it is easy to make a macro for auto-registration, which declares a function and stores a pointer to it in a variable numbered using the value of the macro <code>__LINE__</code> .  In addition to the macro itself, it is necessary to list all possible names of pointer variables and call them one by one.  Here is an almost complete solution, not counting the presence of "extra" code, which should be hidden in the header file, but these are details: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* test.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CAT(X, Y) CAT_(X, Y) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CAT_(X, Y) X##Y typedef void test_func_type(void); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TEST(name) \ static test_func_type CAT(name, __LINE__); \ static test_func_type *CAT(test_at_, __LINE__) = &amp;CAT(name, __LINE__); \ static void CAT(name, __LINE__)(void) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* test.c */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"test.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; TEST(A) { puts("Test1"); } TEST(B) { puts("Test2"); } TEST(C) { puts("Test3"); } typedef test_func_type *test_func_pointer; static test_func_pointer test_at_1, test_at_2, test_at_3, test_at_4, test_at_5, test_at_6; int main(int argc, char *argv[]) { /*     ,      *   . */ if (test_at_1) test_at_1(); if (test_at_2) test_at_2(); if (test_at_3) test_at_3(); if (test_at_4) test_at_4(); if (test_at_5) test_at_5(); if (test_at_6) test_at_6(); return 0; }</span></span></span></span></code> </pre><br>  For clarity, it may be useful to look at the result of a macro substitution, which implies that it is impossible to place more than one test in a row, which, however, is more than acceptable. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> test_func_type A4; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> test_func_type *test_at_4 = &amp;A4; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Test1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> test_func_type B5; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> test_func_type *test_at_5 = &amp;B5; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Test2"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> test_func_type C6; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> test_func_type *test_at_6 = &amp;C6; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C6</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Test3"</span></span>); }</code> </pre><br>  A link to the full implementation will be provided below. <br><br><h4>  Why does it work </h4><br>  Now it's time to understand what is happening here, in more detail and answer the question why it works. <br><br>  If we recall the example with headers, we can distinguish several possible variants of how data members can be represented in the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* (1) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data; <span class="hljs-comment"><span class="hljs-comment">/* (2) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data; <span class="hljs-comment"><span class="hljs-comment">/* (3) */</span></span></code> </pre><br>  <code>(1)</code> unambiguously a definition (and therefore a declaration too) due to the presence of an initializer. <br><br>  <code>(2)</code> is an ad only. <br><br>  <code>(3)</code> (our case) is an ad and, <code></code> , a definition.  The absence of the <code>extern</code> keyword and initializer leaves the compiler no choice but to postpone the decision on what this statement is (‚Äústatement‚Äù).  It is this ‚Äúoscillation‚Äù of the compiler that is used to emulate auto-registration. <br><br>  Just in case, a few examples with comments to finally clarify the situation: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data1; <span class="hljs-comment"><span class="hljs-comment">/* ,      . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* , - . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data2; <span class="hljs-comment"><span class="hljs-comment">/* ,     . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data3; <span class="hljs-comment"><span class="hljs-comment">/* , ,      *  ,  . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* , - . */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   static      . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data4; <span class="hljs-comment"><span class="hljs-comment">/* , ,     *   ,  . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data4 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* , - . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data4; <span class="hljs-comment"><span class="hljs-comment">/* ,     . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data5; <span class="hljs-comment"><span class="hljs-comment">/* ,      . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data5; <span class="hljs-comment"><span class="hljs-comment">/* ,   ""   . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data6 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* , - . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data6 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ,  . */</span></span></code> </pre><br>  Two cases are important for us: <br><br><ul><li>  There are only ads.  In this case, the variable is initialized with zeros, which can be used to determine the absence of a test in the corresponding line. </li><li>  There is at least one ad and exactly one definition.  The address of the function with the test is entered into the corresponding variable. </li></ul><br>  That, in fact, is all that is needed to implement the required operations and get a working automatic registration.  This duality of some operators in the text allows you to expand the array element by element and ‚Äúassign‚Äù the values ‚Äã‚Äãof a part of the array. <br><br><h4>  Features and disadvantages </h4><br>  It is clear that if we do not want to insert a macro at the end of each test file that would serve as a marker for the last line, then it is necessary to initially lay down on some maximum number of lines.  Not the best option, but not the worst.  For example, a single test file is unlikely to contain more than a thousand lines, and you can opt for this upper boundary.  There is one not very pleasant moment: if in this case the tests are defined on the line with the number greater than 1000, then they will lie dead weight and will never be called.  Fortunately, there is a simple ‚Äúsolution‚Äù option: it is enough to compile tests with the <code>-Werror</code> flag (a less rigid option: with <code>-Werror=unused-function</code> ) and similar files will not compile.  ( <b>UPD2:</b> <a href="http://habrahabr.ru/post/252439/">in the comments suggested</a> how to solve this issue easier and with automatic interruption of compilation using <code>STATIC_ASSERT</code> . Enough in each <code>TEST</code> macro insert a check for a valid value of <code>__LINE__</code> .) <br><br>  The sufficiency of the approach with a fixed array is generally not the only reason why it is better to fix the maximum number of rows in advance.  If this is not done, the corresponding declarations (in the place where the tests are called) must be generated at compile time, which can significantly slow it down (this is not a guess, but the result of attempts).  It's easier not to complicate things here, the benefits of being able to compile files of arbitrary size do not seem to be worth it. <br><br>  In the example with the <code>TEST()</code> macro above, you can see the use of a function pointer; this is just one test record, but you probably want to add more.  The wrong way to do this is to add parallel pseudo-arrays.  This will only increase compile time.  The correct way: to use the structure, in this case adding new fields is almost free. <br><br>  For real processing (not copying code) of pseudo-array elements, it is necessary to form a real array.  It is not the best solution to place the same function pointers in this array (or copy structures with information about tests), since this will make the initializer not constant.  But placing pointers to pointers will make the array static, which frees the compiler from having to generate code to assign values ‚Äã‚Äãto the stack during execution, as well as shorten the compilation time. <br><br>  Initially, this solution was born to implement transparent registration of the <code>setup()</code> / <code>teardown()</code> functions and only then was applied to the tests themselves.  In principle, this is suitable for any functionality that can be overridden.  Simply insert the pointer declaration and provide a macro to override it, if the macro was not used, the pointer will be zero, otherwise it will be a user-defined value. <br><br>  Compiler messages about top-level errors in tests may surprise with their volume, but this will happen in rather rare cases of the absence of a terminating semicolon and similar syntax errors. <br><br>  Finally, you can evaluate the result of effort: <br><table><tbody><tr><td>  Test suite to: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">teardown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_adds_fine_first_time</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_errors_on_second_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addition_tests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ test_fixture_start(); fixture_teardown(teardown); run_test(test_adds_fine_first_time); run_test(test_errors_on_second_addition); test_fixture_end(); }</code> </pre></td><td>  Test suite after: <br><pre> <code class="cpp hljs">TEARDOWN() { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } TEST(adds_fine_first_time) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } TEST(errors_on_second_addition) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre></td></tr></tbody></table><h3>  Register test suites in collections </h3><blockquote>  <i>It can be used once, while it can be used at least twice.</i> <br>  - D. KNUTH, <i>The Art Of Computer Programming 4A</i> </blockquote><br>  Close to something in the previous task, but there are a couple of significant differences: <br><br><ol><li>  Interesting characters (functions / data) are defined in different compilation units. </li><li>  And, as a result, there is no counter similar <code>__LINE__</code> . </li></ol><br>  By virtue of the first item, the trick from the previous section in its pure form will not work here, but the basic idea will remain the same, while the means of its implementation will change a bit. <br><br>  As mentioned at the beginning, in this part there are some additional requirements for the medium, namely the assembly system, which should be able to assign identifiers to files in the range <code>[0, N)</code> , where <code>N</code> is the maximum number of test sets.  Again, the border is at the top, but, let's say, a hundred sets in each collection of tests should be enough for many. <br><br>  If last time the compiler did all the ‚Äúdirty work‚Äù for us, then this time it was the turn of the compiler to work (aka ‚Äúlinker‚Äù).  In each translation unit, you must define the entry point using the same file identifier, and in the main file of the test collection, check the characters for presence and call them. <br><br>  One possible option is to use <a href="https://en.wikipedia.org/wiki/Weak_symbol">"weak characters</a> . <a href="https://en.wikipedia.org/wiki/Weak_symbol">"</a>  In this case, functions are almost always defined as usual, but in the main file they are marked with the <a href="http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html"><code>weak</code></a> attribute (something like this: <code>__attribute__((weak))</code> ).  An obvious disadvantage is the requirement for the support of weak characters on the part of the compiler and linker. <br><br>  If you think a little about the structure of weak symbols, then their similarity with the function pointers becomes noticeable: undefined weak symbols are zero.  It turns out that you can do without them: it is enough to define function pointers as before, but without the <code>static</code> .  The use of pointers in explicit form also brings additional benefit in the form of the absence of an automatically generated name in the list of stack frames. <br><br>  On this the first difference from the test suites can be considered reduced to the already known solution.  The definition of the order relation between translation units remains.  The file itself does not have enough information to accomplish this task, so information from outside is needed.  Here, for each build system, there will be its own implementation details, below is an example for <a href="https://www.gnu.org/software/make/">GNU / Make</a> . <br><br>  Determining the order itself is rather trivial, let it be the position of the file name in the sorted list of all the files that make up the test collection.  Do not worry about the auxiliary files without tests, they will not interfere, as a maximum, will create gaps in the numbering, which is insignificant.  This information will be transmitted through the macro definition using the compiler flag ( <code>-D</code> in this case). <br><br>  Actually, the function to determine the identifier: <br><br><pre> <code class="bash hljs">pos = $(strip $(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> T := ) \ $(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> i := 0) \ $(foreach elem, <span class="hljs-variable"><span class="hljs-variable">$1</span></span>, \ $(<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $(filter <span class="hljs-variable"><span class="hljs-variable">$2</span></span>,$(elem)), \ $(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> i := $(words <span class="hljs-variable"><span class="hljs-variable">$T</span></span>)), \ $(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> T := <span class="hljs-variable"><span class="hljs-variable">$T</span></span> $(elem)))) \ <span class="hljs-variable"><span class="hljs-variable">$i</span></span>)</code> </pre><br>  The first argument is a list of all file names, and the second is the name of the current file.  Returns the index.  The function is not the most trivial in appearance, but it does its job regularly. <br><br>  Adding <code>TESTID</code> (here <code>$(OBJ)</code> stores the list of object files): <br><br><pre> <code class="bash hljs">%.o: %.c $(CC) -DTESTID=$(call pos, $(OBJ), <span class="hljs-variable"><span class="hljs-variable">$@</span></span>) -c -o <span class="hljs-variable"><span class="hljs-variable">$@</span></span> $&lt;</code> </pre><br>  On this, almost all difficulties are overcome and it remains only to use an identifier in the code, for example, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FIXTURE() \ static void fixture_body(void); \ void (*CAT(fixture_number_, TESTID))(void) = &amp;fixture_body; \ static void fixture_body(void)</span></span></code> </pre><br>  In the main file of the test collection there should be appropriate declarations and their bypass. <br><br><h4>  Remaining difficulties </h4><br>  If the number of files increases above the set limit, some of them may ‚Äúfall out‚Äù of our field of vision as it could have happened with the tests.  This time, the solution will require additional verification of the compile time.  With a pre-known number of files in the collection, it is easy to check whether they will not be redundant.  In fact, it is enough to provide each translation unit with access to this information using another macro: <br><br><pre> <code class="bash hljs"> ... -DMAXTESTID=$(words $(OBJ)) ...</code> </pre><br>  It remains only to add a check for a sufficient number of ads using something like: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#define STATIC_ASSERT(msg, cond) \ typedef int msg[(cond) ? 1 : -1]; \ /* Fake use to suppress "Unused local variable" warning. */ \ enum { CAT(msg, _use) = (size_t)(msg *)0 }</span></span></code> </pre><br>  There is a somewhat less obvious problem of conflict (duplicate definition) of functions when adding / removing test suite files.  Such changes cause an offset of the indices and require recompilation of all files affected by this.  Here it is worth remembering checking the dates of modification of files by systems of the assembly and updating the date of the directory when its composition changes, i.e.  in fact, each compiled file must be added depending on the directory in which it is located. <br><br>  As a result, the rule for compiling a file with tests takes a similar form: <br><br><pre> <code class="bash hljs">%.o: %.c $(dir %.c)/. $(CC) -DTESTID=$(call pos, $(OBJ), <span class="hljs-variable"><span class="hljs-variable">$@</span></span>) -DMAXTESTID=$(words $(OBJ)) -c -o <span class="hljs-variable"><span class="hljs-variable">$@</span></span> $&lt;</code> </pre><br>  Putting it all together, you can observe the following transformation of the test collection definition: <br><table><tbody><tr><td>  Test collection before: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addition_tests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deletion_tests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expansion_tests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">all_tests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ addition_tests(); deletion_tests(); expansion_tests(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ suite_setup(setup); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> run_tests(all_tests) == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre></td><td>  A collection of tests after: <br><pre> <code class="cpp hljs">DEFINE_SUITE(); SETUP() { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre></td></tr></tbody></table><h3>  Additional optimizations </h3><br>  The need for periodic recompilation and a slight slowdown in the processing of each file make you think about ways to compensate for these costs.  Recall some of the available features. <br><br>  <i>Precompiled header.</i>  Once complex code is long processed by the compiler, it will be logical to prepare the result of processing once and reuse it. <br><br>  <i>Use <a href="https://en.wikipedia.org/wiki/Ccache">ccache</a> to speed up recompilation.</i>  A good idea by itself, for example, allows you to switch between repository branches an unlimited number of times and not wait for a complete recompilation: the total time will be determined first of all by the speed of pulling data from the cache. <br><br>  <i>-pipe compiler flag</i> (if supported).  Reduce the number of file operations through the use of additional RAM. <br><br> <i>     .</i>           ,     . <br><br>     ?               ,       : <br><br><ul><li>                 . </li><li>       ,     (  )     6,5 .  ‚Äî   13 .,             ,    5,5 .          5,7 .,  ( )       . </li></ul><br><h3>  Links </h3><br>      <a href="https://code.google.com/p/seatest/">seatest</a> ,     ,   -.       seatest   <a href="https://github.com/xaizek/stic">stic</a> (   C99,        ),      .        ,      <a href="">stic.h</a> .      <a href="https://github.com/xaizek/c-test-auto-reg"> </a> .        <a href="https://github.com/vifm/vifm/blob/839e21393a04035e014bd3343a3162404e98de60/tests/Makefile">Makefile</a> (     ). <br><br><h3>  Results </h3><br>   <a href="https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks">  Wikipedia</a> , stic       -  C (,     ).         ( <b>UPD:</b>  <a href="http://habrahabr.ru/post/252439/"></a>             C++, , ,         ,      ).         ,     (    - <code>#ifdef</code> ,     )        . ,         : <br><br><pre> <code class="cpp hljs">TEST(os_independent) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } TEST(unix_only, IF(not_windows)) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre><br>      ,     ,   ,     seatest,           3911 ,    16%    . </div><p>Source: <a href="https://habr.com/ru/post/252439/">https://habr.com/ru/post/252439/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../252421/index.html">A hundred lines of code for the beloved</a></li>
<li><a href="../252429/index.html">DICOM Viewer from the inside. Voxel render</a></li>
<li><a href="../252433/index.html">HSTS-based super cookies will track you even in private mode</a></li>
<li><a href="../252435/index.html">Configuring Amazon Elastic Load Balancing: with email forwarding and redirects</a></li>
<li><a href="../252437/index.html">Unexpected exception filter behavior in C # 6</a></li>
<li><a href="../252441/index.html">Reconnect - Facebook Login Vulnerability</a></li>
<li><a href="../252443/index.html">Documentation in Doxygen</a></li>
<li><a href="../252445/index.html">Fragmented video stream compression method</a></li>
<li><a href="../252447/index.html">Overview of the video on Go c FOSDEM 2015</a></li>
<li><a href="../252449/index.html">Freemium vs. Free: why we got rid of the free subscription</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>