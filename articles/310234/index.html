<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to futures-rs: asynchronous on Rust [translation]</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This document will help you learn about the container for the programming language Rust - futures , which provides the implementation of futures and f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to futures-rs: asynchronous on Rust [translation]</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/867/e83/06f/867e8306fa7849dea356c6f5d92c5c6e.jpg"></p><br><p> This document will help you learn about the container for the programming language Rust - <code>futures</code> , which provides the implementation of futures and flows with zero cost.  Futures are available in many other programming languages, such as <code>C++</code> , <code>Java</code> , and <code>Scala</code> , and the <code>futures</code> container draws inspiration from the libraries of these languages.  However, it is ergonomic, and also adheres to the zero-cost abstraction philosophy inherent in Rust, namely, to create and compose futures no memory allocations are required, and for <code>Task</code> , which controls them, only one allocation is needed.  Futures should be the basis of asynchronous composable high-performance I / O in Rust, and early performance measurements show that a simple HTTP server built on futures is really fast. </p><br><a name="habracut"></a><br><p>  This publication is a translation of the official <a href="">futures-rs tutorial</a> . </p><br><p>  This documentation is divided into several sections: </p><br><ul><li>  "Hello, world!"; </li><li>  Type future; </li><li>  Description <code>Stream</code> ; </li><li>  Specific futures and stream ( <code>Stream</code> ); </li><li>  Return futures; </li><li>  <code>Task</code> and future; </li><li>  Local task data. </li></ul><br><h1>  Hello world! </h1><br><p>  Container <code>futures</code> requires Rust version 1.10.0 or higher, which can be easily installed using <code>Rustup</code> .  The container is tested and works fine on Windows, macOS and Linux, but PRs for other platforms are always welcome.  You can add <code>futures</code> to your project's <code>Cargo.toml</code> as follows: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">dependencies</span></span>] futures = { git = <span class="hljs-string"><span class="hljs-string">"https://github.com/alexcrichton/futures-rs"</span></span> } tokio-core = { git = <span class="hljs-string"><span class="hljs-string">"https://github.com/tokio-rs/tokio-core"</span></span> } tokio-tls = { git = <span class="hljs-string"><span class="hljs-string">"https://github.com/tokio-rs/tokio-tls"</span></span> }</code> </pre><br><blockquote>  Note: this library is in active development and requires getting source code from git directly, but later the container <br>  will be published on crates.io. </blockquote><p>  Here we add three containers depending: </p><br><ul><li>  <a href="https://github.com/alexcrichton/futures-rs">futures</a> - definition and core implementation of <code>Future</code> and <code>Stream</code> ; </li><li>  <a href="https://github.com/tokio-rs/tokio-core">tokio-core</a> - binding to the <code>mio</code> container, providing specific <br>  <code>Future</code> and <code>Stream</code> implementations for TCP and UDP; </li><li>  <a href="https://github.com/tokio-rs/tokio-tls">tokio-tls</a> is an SSL / TLS implementation based on futures. </li></ul><br><p>  The <a href="https://github.com/alexcrichton/futures-rs">futures</a> container is a low-level implementation of futures that does not carry any runtime or I / O layer.  For the examples below, we will use the specific implementations available in <a href="https://github.com/tokio-rs/tokio-core">tokio-core</a> to show how futures and streams can be used to perform complex I / O operations with zero overhead. </p><br><p>  Now that we have everything we need, we will write the first program.  As a hello-world example, download the homepage. <br>  Rust page: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> futures; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> tokio_core; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> tokio_tls; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::net::ToSocketAddrs; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> futures::Future; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> tokio_core::reactor::Core; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> tokio_core::net::TcpStream; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> tokio_tls::ClientContext; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> core = Core::new().unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> addr = <span class="hljs-string"><span class="hljs-string">"www.Rust-lang.org:443"</span></span>.to_socket_addrs().unwrap().next().unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> socket = TcpStream::connect(&amp;addr, &amp;core.handle()); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tls_handshake = socket.and_then(|socket| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cx = ClientContext::new().unwrap(); cx.handshake(<span class="hljs-string"><span class="hljs-string">"www.Rust-lang.org"</span></span>, socket) }); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = tls_handshake.and_then(|socket| { tokio_core::io::write_all(socket, <span class="hljs-string"><span class="hljs-string">"\ GET / HTTP/1.0\r\n\ Host: www.Rust-lang.org\r\n\ \r\n\ "</span></span>.as_bytes()) }); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response = request.and_then(|(socket, _)| { tokio_core::io::read_to_end(socket, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new()) }); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (_, data) = core.run(response).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from_utf8_lossy(&amp;data)); }</code> </pre><br><p>  If you create a file with such content along the path <code>src/main.rs</code> and run the <code>cargo run</code> command, the HTML of the Rust home page is displayed. </p><br><blockquote>  Note: Rustc 1.10 compiles this example slowly.  From 1.11 compilation is faster. </blockquote><p>  This code is too big to figure it out right away, so let's go through line by line. <br>  Take a look at the <code>main()</code> function: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> core = Core::new().unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> addr = <span class="hljs-string"><span class="hljs-string">"www.Rust-lang.org:443"</span></span>.to_socket_addrs().unwrap().next().unwrap();</code> </pre><br><p>  <a href="https://tokio-rs.github.io/tokio-core/tokio_core/reactor/struct.Core.html">This creates a cycle of events</a> in which all I / O will be executed.  Then we convert the host name <a href="https://www.rust-lang.org/">"www.Rust-lang.org"</a> using the <code>to_socket_addrs</code> method from the standard library. </p><br><p>  Further: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> socket = TcpStream::connect(&amp;addr, &amp;core.handle());</code> </pre><br><p>  <a href="https://tokio-rs.github.io/tokio-core/tokio_core/reactor/struct.Core.html">We get</a> the event loop <a href="https://tokio-rs.github.io/tokio-core/tokio_core/reactor/struct.Core.html">handle</a> and connect to the host using <a href="https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpStream.html">TcpStream :: connect</a> .  Notably, <a href="https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpStream.html">TcpStream :: connect</a> returns the future.  In fact, the socket is not connected, but the connection will occur later. </p><br><p>  After the socket becomes available, we need to follow three steps to load the Rust-lang.org home page: </p><br><ol><li><p>  Run TLS handshake.  You can work with this homepage only via HTTPS, so we have to connect to port 443 and follow the TLS protocol. </p><br></li><li><p>  Send HTTP <code>GET</code> request.  As part of this guide, we will write a request manually, however, in combat programs you should use an HTTP client built on <code>futures</code> . </p><br></li><li>  Finally, download the answer by reading all the data from the socket. </li></ol><br><p>  Consider each of these steps in detail. <br>  First step: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tls_handshake = socket.and_then(|socket| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cx = ClientContext::new().unwrap(); cx.handshake(<span class="hljs-string"><span class="hljs-string">"www.Rust-lang.org"</span></span>, socket) });</code> </pre><br><p>  Here, the <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">and_then</a> type of the future is used, calling it on the result of executing the <a href="https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpStream.html">TcpStream :: connect</a> method.  The <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">and_then</a> method accepts a closure that gets the value of the previous future.  In this case, the <code>socket</code> will be of type <a href="https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpStream.html">TcpStream</a> . </p><br><p>  It is worth noting that the closure passed to <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">and_then</a> will not be executed if <a href="https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpStream.html">TcpStream :: connect</a> returns an error. </p><br><p>  Once the <code>socket</code> received, we create the client TLS context using the <a href="https://tokio-rs.github.io/tokio-tls/tokio_tls/struct.ClientContext.html">ClientContext :: new</a> .  This type from the <code>tokio-tls</code> represents the client part of the TLS connection.  Next, call the <a href="https://tokio-rs.github.io/tokio-tls/tokio_tls/struct.ClientContext.html">handshake</a> method to perform a TLS <a href="https://tokio-rs.github.io/tokio-tls/tokio_tls/struct.ClientContext.html">handshake</a> .  The first argument is the domain name to which we are connecting, the second is the input / output object (in this case, the <code>socket</code> object). </p><br><p>  Like <a href="https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpStream.html">TcpStream :: connect</a> earlier, the <a href="https://tokio-rs.github.io/tokio-tls/tokio_tls/struct.ClientContext.html">handshake</a> method returns the future.  TLS handshake can take some time, because the client and server need to do some I / O, confirmation of certificates, etc.  After completing the future, it will return <a href="https://tokio-rs.github.io/tokio-tls/tokio_tls/struct.TlsStream.html">TlsStream</a> , similar to the one <a href="https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpStream.html">TcpStream</a> examined above. </p><br><p>  The combinator <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">and_then</a> do a lot of hidden work, ensuring that futures are executed in the correct order and tracked on the fly.  In this case, the value returned by <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">and_then</a> realizes the <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">Future</a> type, so we can make chains of calculations. </p><br><p>  Next, send an HTTP request: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = tls_handshake.and_then(|socket| { tokio_core::io::write_all(socket, <span class="hljs-string"><span class="hljs-string">"\ GET / HTTP/1.0\r\n\ Host: www.Rust-lang.org\r\n\ \r\n\ "</span></span>.as_bytes()) });</code> </pre><br><p>  Here we got the future from the previous step ( <code>tls_handshake</code> ) and used <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">and_then</a> again to continue the calculation.  The <a href="https://tokio-rs.github.io/tokio-core/tokio_core/io/fn.write_all.html">write_all combinator</a> completely writes an HTTP request, producing multiple entries as necessary. </p><br><p>  The future returned by the <a href="https://tokio-rs.github.io/tokio-core/tokio_core/io/fn.write_all.html">write_all</a> method will be executed as soon as all data has been written to the socket.  It is noteworthy that <a href="https://tokio-rs.github.io/tokio-tls/tokio_tls/struct.TlsStream.html">TlsStream</a> covertly encrypts all the data we recorded before sending it to the socket. </p><br><p>  The third and last part of the query looks like this: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response = request.and_then(|(socket, _)| { tokio_core::io::read_to_end(socket, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new()) });</code> </pre><br><p>  The previous future <code>request</code> again linked, this time with the result of the <a href="https://tokio-rs.github.io/tokio-core/tokio_core/io/fn.read_to_end.html">read_to_end</a> combinator.  This future will read all the data from the socket and put it in the provided buffer and return the buffer when the connection to be processed sends EOF. </p><br><p>  As before, reading from the socket is in fact hidden decrypts data received from the server, so we read the decrypted version. </p><br><p>  If the execution is interrupted at this place, you will be surprised, since nothing will happen.  This is because everything we did was based on future calculations, and we actually didn‚Äôt run them.  Up to this point, we have not done any I / O and did not perform HTTP requests, etc. </p><br><p>  To truly run futures and manage them until completion, you need to start the event loop: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (_, data) = core.run(response).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from_utf8_lossy(&amp;data));</code> </pre><br><p>  Here, the future <code>response</code> is placed in the event loop, <a href="https://tokio-rs.github.io/tokio-core/tokio_core/reactor/struct.Core.html">requesting it to fulfill the future</a> .  The event loop will run until a result is received. </p><br><p>  Notably, calling <code>core.run(..)</code> blocks the calling thread until the future can be returned.  This means that <code>data</code> is of type <code>Vec&lt;u8&gt;</code> .  Then we can type it in stdout as usual. </p><br><p>  Whew!  We looked at futures that <a href="https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpStream.html">initialize TCP connections</a> , <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">create chains of computations</a> and <a href="https://tokio-rs.github.io/tokio-core/tokio_core/io/fn.read_to_end.html">read data from a socket</a> .  But this is only an example of the possibilities of futures, then we consider the nuances. </p><br><h1>  Description Future </h1><br><p>  The future is the core of the container <code>futures</code> .  This type represents asynchronous calculations and their result. </p><br><p>  Take a look at the following code: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Future</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poll</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Poll&lt;Self::Item, Self::Error&gt;; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><p>  I am sure that the definition contains a number of points causing questions: </p><br><ul><li>  <code>Item</code> and <code>Error</code> ; </li><li>  <code>poll</code> ; </li><li>  combinators of the future. </li></ul><br><p>  We analyze them in detail. </p><br><h2>  <code>Item</code> and <code>Error</code> </h2><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span></span>;</code> </pre><br><p>  The first feature of the future type, as you probably noticed, is that it contains two associated types.  They are the types of values ‚Äã‚Äãthat the future can get.  Each <code>Future</code> instance can be processed as <code>Result&lt;Self::Item, Self::Error&gt;</code> . </p><br><p>  These two types will be used very often in <code>where</code> conditions when passing futures and in type signatures when futures will be returned. </p><br><p>  For example, when returning future, you can write: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Future&lt;Item = <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, Error = io::Error&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><p>  Or, when we accept the future: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;F&gt;(future: F) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: Future&lt;Error = io::Error&gt;, F::Item: <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><h2> <code>poll</code> </h2> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poll</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Poll&lt;Self::Item, Self::Error&gt;;</code> </pre><br><p>  Work type <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">Future</a> built on this method.  The <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">poll</a> method is the only entry point for retrieving a value calculated in the future.  As a future user, you rarely need to call this method directly.  Most likely, you will interact with futures through combinators, which create high-level abstractions around futures.  However, knowing how futures work under the hood will be useful. </p><br><p>  Consider the <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">poll</a> method in more detail. </p><br><p>  Pay attention to the argument <code>&amp;mut self</code> , which causes a number of restrictions and properties: </p><br><ul><li>  futures can only be polled by one thread at a time; </li><li>  during the execution of the <code>poll</code> method, futures can change their state; </li><li>  after <code>poll</code> ownership of futures can be transferred to another entity. </li></ul><br><p>  In fact, the type <a href="http://alexcrichton.com/futures-rs/futures/type.Poll.html">Poll</a> is a pseudonym: </p><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Poll</span></span></span></span>&lt;T, E&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;Async&lt;T&gt;, E&gt;;</code> </pre><br><p>  Just take a look at what the <a href="http://alexcrichton.com/futures-rs/futures/enum.Async.html">Async</a> enumeration is: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Async</span></span></span></span>&lt;T&gt; { Ready(T), NotReady, }</code> </pre><br><p>  Through this enumeration, futures can interact when the future value is ready for use.  If an error occurs, then <code>Err</code> will be returned immediately.  Otherwise, the <a href="http://alexcrichton.com/futures-rs/futures/enum.Async.html">Async</a> enumeration displays when the value of the Future is fully received or is not yet ready. </p><br><p>  The <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">Future</a> type, like <code>Iterator</code> , does not define what happens after calling the <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">poll</a> method, if the future has already been processed.  This means that those who implement the <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">Future</a> type do not need to maintain state in order to check whether the <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">poll</a> method successfully returned the result. </p><br><p>  If the <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">poll</a> call returns <code>NotReady</code> , the future still needs to know when to execute again.  To achieve this goal, the future must provide the following mechanism: when receiving <code>NotReady</code> current task must be able to receive a notification when the value becomes available. </p><br><p>  The <a href="http://alexcrichton.com/futures-rs/futures/task/fn.park.html">park</a> method is the main entry point for notification delivery.  This function returns a <a href="http://alexcrichton.com/futures-rs/futures/task/struct.Task.html">Task</a> , which implements the <code>Send</code> and <code>'static</code> types, and has the main method, <a href="http://alexcrichton.com/futures-rs/futures/task/struct.Task.html">unpark</a> .  Calling the <a href="http://alexcrichton.com/futures-rs/futures/task/struct.Task.html">unpark</a> method indicates that the future can perform calculations and return a value. </p><br><p>  More detailed documentation can be found <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">here</a> . </p><br><h2>  Combinators future </h2><br><p>  Now it seems that the <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">poll</a> method can add a little pain to your workflow.  What if you have a future that has to return a <code>String</code> , and you want to convert it into a future, returning <code>u32</code> ?  For such compositions, the future provides a large number of <em>combinators</em> . </p><br><p>  These combinators are similar to combinators from the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator</a> type, and they all accept the future and return the new future. </p><br><p>  For example, we could write: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>&lt;F&gt;(future: F) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Future&lt;Item=<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, Error=F::Error&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: Future&lt;Item=<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>, { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(future.map(|string| { string.parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>&gt;().unwrap() })) }</code> </pre><br><p>  Here, for a future transformation that returns a <code>String</code> type, in the future that returns a <code>u32</code> , a <a href="http://alexcrichton.com/futures-rs/futures/struct.Map.html">map is</a> used.  Packing in <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">Box is</a> not always necessary and will be discussed in more detail in the <a href="">futures returns</a> section. </p><br><p>  Combinators allow you to express the following concepts: </p><br><ul><li>  change the type of future ( <a href="http://alexcrichton.com/futures-rs/futures/struct.Map.html">map</a> , <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">map_err</a> ); </li><li>  starting another future when the source is executed ( <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">then</a> , <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">and_then</a> , <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">or_else</a> ); </li><li>  continuation of execution, when at least one of the futures is executed ( <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">select</a> ); </li><li>  waiting for two future ( <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">join</a> ); </li><li>  determining the behavior of <code>poll</code> after calculations ( <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">fuse</a> ). </li></ul><br><p>  The use of combinators is similar to using the type of <code>Iterator</code> in Rust or <code>futures</code> in Scala.  Most futures manipulations end up using these combinators.  All combinators have zero cost, which means there is no memory allocation, and that the implementation will be optimized as if you wrote it manually. </p><br><h1>  Description <code>Stream</code> </h1><br><p>  Previously, we considered the type of <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">Future</a> , which is useful in the case of calculating just one value for the entire time.  But sometimes calculations are better presented as a <em>stream of</em> values.  For example, a TCP listener produces many TCP connections during its lifetime.  Let's see which entities from the standard library are equivalent to <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">Future</a> and <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">Stream</a> : </p><br><table><thead><tr><th>  # items </th><th>  Sync </th><th>  Async </th><th>  Common operations </th></tr></thead><tbody><tr><td>  one </td><td>  [Result] </td><td>  [Future] </td><td>  [map], [and_then] </td></tr><tr><td>  ‚àû </td><td>  [Iterator] </td><td>  [Stream] </td><td>  [map] [stream-map], [fold], [collect] </td></tr></tbody></table><br><p>  Let's take a look at the <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">Stream</a> type: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stream</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poll</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Poll&lt;<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::Item&gt;, Self::Error&gt;; }</code> </pre><br><p>  You may have noticed that the <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">Stream</a> type is very similar to the <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">Future</a> type.  The main difference is that the <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">poll</a> method returns <code>Option&lt;Self::Item&gt;</code> , not <code>Self::Item</code> . </p><br><p>  <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">Stream</a> produces many optional values ‚Äã‚Äãover time, signaling the end of the stream by returning <code>Ready(None)</code> .  At its core, <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">Stream</a> is an asynchronous stream that produces values ‚Äã‚Äãin a specific order. </p><br><p>  In fact, <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">Stream</a> is a special copy of the <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">Future</a> type, and it can be converted into the future using the <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">into_future</a> method. </p><br><p>  <a href="http://alexcrichton.com/futures-rs/futures/stream/struct.StreamFuture.html">The returned future</a> gets the next value from the stream plus the stream itself, which allows to get more values ‚Äã‚Äãlater.  It also allows you to compose streams and other arbitrary futures using the basic combinators of the future. </p><br><p>  Like the <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">Future</a> type, the <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">Stream</a> type provides a large number of combinators.  In addition to future-like combinators (for example, <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">then</a> ), stream-specific combinators are supported, such as <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">fold</a> . </p><br><h2>  Example of using <code>Stream</code> type </h2><br><p>  An example of using futures was considered at the beginning of this tutorial, and now let's look at an example of using streams using the <a href="https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpListener.html">incoming</a> method implementation.  This simple server that accepts connections writes the word "Hello!"  and closes the socket: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> futures; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> tokio_core; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> futures::stream::Stream; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> tokio_core::reactor::Core; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> tokio_core::net::TcpListener; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> core = Core::new().unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> address = <span class="hljs-string"><span class="hljs-string">"127.0.0.1:8080"</span></span>.parse().unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> listener = TcpListener::bind(&amp;address, &amp;core.handle()).unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> addr = listener.local_addr().unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Listening for connections on {}"</span></span>, addr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> clients = listener.incoming(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> welcomes = clients.and_then(|(socket, _peer_addr)| { tokio_core::io::write_all(socket, <span class="hljs-string"><span class="hljs-string">b"Hello!\n"</span></span>) }); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> server = welcomes.for_each(|(_socket, _welcome)| { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(()) }); core.run(server).unwrap(); }</code> </pre><br><p>  As before, let's go through the lines: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> core = Core::new().unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> address = <span class="hljs-string"><span class="hljs-string">"127.0.0.1:8080"</span></span>.parse().unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> listener = TcpListener::bind(&amp;address, &amp;core.handle()).unwrap();</code> </pre><br><p>  Here we initialized the event loop by calling <a href="https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpListener.html">LoopHandle's TcpListener :: bind</a> <a href="https://tokio-rs.github.io/tokio-core/tokio_core/reactor/struct.Core.html">method</a> to create a TCP listener that will accept sockets. </p><br><p>  Next, take a look at the following code: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> server = listener.and_then(|listener| { <span class="hljs-comment"><span class="hljs-comment">// ... });</span></span></code> </pre><br><p>  Here you can see that <code>TcpListener::bind</code> , like <code>TcpStream::connect</code> , does not return <code>TcpListener</code> , rather, the future calculates it.  We then use the <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">Future's</a> <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">and_then</a> method to determine what happens when the TCP listener becomes available. </p><br><p>  We got a TCP listener and can determine its state: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> addr = listener.local_addr().unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Listening for connections on {}"</span></span>, addr);</code> </pre><br><p>  Call the <a href="https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpStream.html">local_addr</a> method to print the address to which the listener was associated.  From this point on, the port is successfully connected, so that clients can connect. </p><br><p>  Next, create a <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">stream</a> . </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> clients = listener.incoming();</code> </pre><br><p>  Here, the <a href="https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpListener.html">incoming</a> method returns the <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">Stream</a> pairs <a href="https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpListener.html">TcpListener</a> and <a href="https://doc.rust-lang.org/std/net/enum.SocketAddr.html">SocketAddr</a> .  This is similar to the <a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">TcpListener from the standard library</a> and <a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">the accept method</a> ; only in this case, we rather receive all events as a stream, rather than accepting sockets manually. </p><br><p>  The stream of <code>clients</code> produces sockets constantly.  This reflects the work of the servers - they take clients in a loop and direct <br>  them to the rest of the system for processing. </p><br><p>  Now, having a stream of client connections, we can manipulate it using standard <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">Stream</a> type methods: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> welcomes = clients.and_then(|(socket, _peer_addr)| { tokio_core::io::write_all(socket, <span class="hljs-string"><span class="hljs-string">b"Hello!\n"</span></span>) });</code> </pre><br><p>  Here we use the <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">Stream</a> method <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">and_then</a> to perform an action on each element of the stream.  In this case, we form a chain of calculations for each element of the stream ( <code>TcpStream</code> ).  We saw the <a href="https://tokio-rs.github.io/tokio-core/tokio_core/io/fn.write_all.html">write_all</a> method earlier; it writes the transferred data buffer to the passed socket. </p><br><p>  This block means that <code>welcomes</code> now a stream of sockets that <code>welcomes</code> a string of "Hello!" Characters.  In this tutorial, we complete the work with the connection, so we convert the entire flow of <code>welcomes</code> to the future using the <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">for_each</a> method: </p><br><pre> <code class="rust hljs">welcomes.for_each(|(_socket, _welcome)| { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(()) })</code> </pre><br><p>  Here we take the results of the previous future, <a href="https://tokio-rs.github.io/tokio-core/tokio_core/io/fn.write_all.html">write_all</a> , and discard them, causing the socket to close. </p><br><p>  It should be noted that an important limitation of this server is the lack of parallelism.  Streams are ordered data processing, and in this case, the order of the original stream is the order in which the sockets were received, and the <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">and_then</a> and <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">for_each</a> methods <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">preserve</a> this order.  Thus, chaining creates an effect when each socket is taken from a stream and all related operations on it are processed before proceeding to the next socket. </p><br><p>  If, instead, we want to manage all clients in parallel, we can use the <a href="https://tokio-rs.github.io/tokio-core/tokio_core/reactor/struct.Handle.html">spawn</a> method: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> clients = listener.incoming(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> welcomes = clients.map(|(socket, _peer_addr)| { tokio_core::io::write_all(socket, <span class="hljs-string"><span class="hljs-string">b"hello!\n"</span></span>) }); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> handle = core.handle(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> server = welcomes.for_each(|future| { handle.spawn(future.then(|_| <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(()))); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(()) });</code> </pre><br><p>  Instead of the <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">and_then</a> method, the <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">map</a> method is used, which converts a stream of clients into a futures stream.  Then we change the closure passed in <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">for_each</a> using the <a href="https://tokio-rs.github.io/tokio-core/tokio_core/reactor/struct.Handle.html">spawn</a> method, which allows the future to be launched in parallel in the event loop.  Note that <a href="https://tokio-rs.github.io/tokio-core/tokio_core/reactor/struct.Handle.html">spawn</a> requires future c item / error of the type <code>()</code> . </p><br><h1>  Specific implementations of futures and streams </h1><br><p>  At this stage, there is a clear understanding of the types of <code>Future</code> and <code>Stream</code> , how they are implemented and how to combine them.  But where did all these futures originally come from? </p><br><p>  Take a look at a few specific implementations of futures and threads. </p><br><p>  First of all, any available value of the future is in the "ready" state.  For this, the <a href="http://alexcrichton.com/futures-rs/futures/fn.done.html">done</a> , <a href="http://alexcrichton.com/futures-rs/futures/fn.failed.html">failed,</a> and <a href="http://alexcrichton.com/futures-rs/futures/fn.finished.html">finished</a> functions are sufficient.  The <a href="http://alexcrichton.com/futures-rs/futures/fn.done.html">done</a> function accepts <code>Result&lt;T,E&gt;</code> and returns <code>Future&lt;Item=T, Error=E&gt;</code> .  For the <a href="http://alexcrichton.com/futures-rs/futures/fn.failed.html">failed</a> and <code>finished</code> functions, you can specify <code>T</code> or <code>E</code> and leave the other associated type as a wildcard. </p><br><p>  For streams, the equivalent concept of a ‚Äúfinished‚Äù stream value is the <a href="http://alexcrichton.com/futures-rs/futures/stream/fn.iter.html">iter</a> function, which creates a stream that provides elements of the resulting iterator.  In situations where the value is not in the ‚Äúfinished‚Äù state, there are also many common implementations of <code>Future</code> and <code>Stream</code> , the first of which is the <a href="http://alexcrichton.com/futures-rs/futures/fn.oneshot.html">oneshot</a> function: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> futures; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::thread; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> futures::Future; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expensive_computation</span></span></span></span>() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... 200 } fn main() { let (tx, rx) = futures::oneshot(); thread::spawn(move || { tx.complete(expensive_computation()); }); let rx = rx.map(|x| x + 3); }</span></span></code> </pre><br><p>  ,   <a href="http://alexcrichton.com/futures-rs/futures/fn.oneshot.html">oneshot</a>     , , , <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html">mpsc::channel</a> .   <code>tx</code> ("transmitter")   <a href="http://alexcrichton.com/futures-rs/futures/struct.Complete.html">Complete</a>     <code>oneshot</code> ,   future   .  <a href="http://alexcrichton.com/futures-rs/futures/struct.Complete.html">Complete::complete</a>    . </p><br><p>   ,  <code>rx</code> ("receiver"),   <a href="http://alexcrichton.com/futures-rs/futures/struct.Oneshot.html">Oneshot</a> ,     <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">Future</a> . <code>Item</code>   <code>T</code> ,   <code>Oneshot</code> . <code>Error</code>   <code>Canceled</code> ,  ,   <a href="http://alexcrichton.com/futures-rs/futures/struct.Complete.html">Complete</a>     . </p><br><p>    future    (  )     .     <code>Send</code>      .    ,  ,  ,    future  ,    . </p><br><p>   <a href="http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html">Stream</a>    <a href="http://alexcrichton.com/futures-rs/futures/stream/fn.channel.html">channel</a> .      ,       ,  ,  <code>Stream</code> ,   . </p><br><p>   <a href="http://alexcrichton.com/futures-rs/futures/stream/struct.Sender.html">Sender</a>      :     ,   ,  future, ,   ,         .   ,           . </p><br><h1>  futures </h1><br><p>       futures ‚Äî   <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">Future</a> .      <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator</a> ,       . </p><br><p>   : </p><br><ul><li> <a href="">-</a> ; </li><li> <a href=""> </a> ; </li><li> <a href=""> </a> ; </li><li> <a href="">impl Trait</a> . </li></ul><br><h2> - </h2><br><p> ,   ,    <a href="http://rurust.github.io/Rust_book_ru/src/trait-objects.html">-</a> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Future&lt;Item = <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, Error = io::Error&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><p>        .         future,     future     ,  . </p><br><p>  ,   <a href="http://alexcrichton.com/futures-rs/futures/trait.Future.html">boxed</a>  <code>BoxFuture</code> ,          <code>Box&lt;Future + Send&gt;</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() -&gt; BoxFuture&lt;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>&gt; { finished(<span class="hljs-number"><span class="hljs-number">1</span></span>).boxed() }</code> </pre><br><p>         ,  future . <code>Box</code>    ,  future   . ,  ,     ,     future    .  ,         ,      future (.  ,  ,    ),        <code>Box</code> . </p><br><h2>   </h2><br><p>      <code>Box</code> ,   future      . </p><br><p>  Example: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFuture</span></span></span></span> { inner: Oneshot&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() -&gt; MyFuture { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (tx, rx) = oneshot(); <span class="hljs-comment"><span class="hljs-comment">// ... MyFuture { inner: tx } } impl Future for MyFuture { // ... }</span></span></code> </pre><br><p>       <code>MyFuture</code>      <code>Future</code> .    future <code>Oneshot&lt;i32&gt;</code> ,      future  . </p><br><p>    , ,        <code>Box</code>  -  .   <code>MyFuture</code> ,        . </p><br><p>     ,       .         ,     futures    . </p><br><h2>   </h2><br><p>    ‚Äî    : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_10</span></span></span></span>&lt;F&gt;(f: F) -&gt; Map&lt;F, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: Future&lt;Item = <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_map</span></span></span></span>(i: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { i + <span class="hljs-number"><span class="hljs-number">10</span></span> } f.map(do_map) }</code> </pre><br><p>     ,    .  <a href="http://alexcrichton.com/futures-rs/futures/struct.Map.html">map</a>   <a href="http://alexcrichton.com/futures-rs/futures/struct.Map.html">map</a> ,    future  ,     <code>map</code> . </p><br><p>            future,           <code>Box</code> ,    . </p><br><p>         .     - .      ( <code>fn(i32) -&gt; i32</code> ),       .  ,           . </p><br><h2> <code>impl Trait</code> </h2> <br><p>     Rust,  <a href="">impl Trait</a> ,      future. </p><br><p>  Example: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_10</span></span></span></span>&lt;F&gt;(f: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Future&lt;Item = <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, Error = F::Error&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: Future&lt;Item = <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;, { f.map(|i| i + <span class="hljs-number"><span class="hljs-number">10</span></span>) }</code> </pre><br><p>   ,    ‚Äî  ",   <code>Future</code> "     .     future   . </p><br><p>      :     <code>Box</code> ,   ,    future         ,       <code>Box</code> . </p><br><p>   ,    <a href="">impl Trait</a>       Rust.    ,        ,  ,  futures,    .    -,       <code>Box</code>  <code>impl Trait</code> . </p><br><h1> <code>Task</code>  <code>Future</code> </h1><br><p>       ,      futures,      ,   . ,      <code>poll</code> ,  ,   <code>poll</code>  <code>NotReady</code> ,     ,      ?  ,  <code>poll</code>   ? </p><br><p>  <a href="http://alexcrichton.com/futures-rs/futures/task/struct.Task.html">Task</a> . </p><br><p>  <a href="http://alexcrichton.com/futures-rs/futures/task/struct.Task.html">Task</a>  ,  futures.    future     ,    .   ", !"    future,       .      <a href="http://alexcrichton.com/futures-rs/futures/task/struct.Task.html">Task</a> ,    " "   ,    future    . </p><br><p>  future <a href="https://tokio-rs.github.io/tokio-core/tokio_core/reactor/struct.Handle.html"></a>             .       (poll),    ,   future.      <a href="https://tokio-rs.github.io/tokio-core/tokio_core/reactor/struct.Handle.html">spawn</a> ,   <a href="http://alexcrichton.com/futures-rs/futures_cpupool/struct.CpuPool.html">puPool::spawn</a>     <a href="https://tokio-rs.github.io/tokio-core/tokio_core/reactor/struct.Handle.html">Handle::spawn</a>   .    <a href="https://tokio-rs.github.io/tokio-core/tokio_core/reactor/struct.Handle.html">spawn</a>     <code>poll</code>  . </p><br><p>     <code>Task</code>    <code>futures</code> :  <code>Task</code> ,  <code>Future</code>             .    ,       <code>futures</code> .   <code>Task</code>    ,        ,     . </p><br><h1>    </h1><br><p>     ,    future     .  ,  futures   ,    ,       ,        . </p><br><p> Futures  <code>'static</code> ,            futures: </p><br><ul><li><p>       future   ,         future,     ; </p><br></li><li>       ,         ( <code>Arc / Rc</code> ) ,   ,     ( <code>Arc&lt;Mutex&gt;</code> ),     . </li></ul><br><p>     ,  ,     . </p><br><p>   <code>Task</code>  <code>Future</code>  ,       <code>Task</code>     ,     <code>poll</code>  ,    . API <code>Task</code>         <code>Task</code> .    <code>Task</code>       : </p><br><ul><li><p>  <code>task_local!</code> ,     <code>thread_local!</code>   . ,    ,        <code>Task</code> ,    ,  <code>Task</code>  ; </p><br></li><li>  <a href="http://alexcrichton.com/futures-rs/futures/task/struct.TaskRc.html">TaskRc</a>       ,      .    ,     <code>Rc</code> . </li></ul><br><p> ,          ,      ,     . </p><br><h1>  Translator's Note </h1><br><p>             ! </p><br><p>     ""     ‚Äî  - "",   .             ""   .       ‚Äî   . </p><br><p>   :       "future"   ? </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/310234/">https://habr.com/ru/post/310234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310216/index.html">The subtleties of building network models in Python</a></li>
<li><a href="../310218/index.html">IF (programmer's profession. Exists () = FALSE) THEN ...?</a></li>
<li><a href="../310220/index.html">Vitaliy Yanko (ISDEF): Is it too late to enter the market for developing software for robotics?</a></li>
<li><a href="../310224/index.html">The cruel reality of creating FPS for mobile devices</a></li>
<li><a href="../310232/index.html">Paul Graham: What you need to do in high school to become a good hacker</a></li>
<li><a href="../310236/index.html">Creating a menu for playing on Unity3D based on states</a></li>
<li><a href="../310238/index.html">Apple released iOS 10.0.1</a></li>
<li><a href="../310242/index.html">Shaper for Linux in user space (NFQUEUE-based)</a></li>
<li><a href="../310244/index.html">Users of the Tor web browser are encouraged to update it as soon as possible.</a></li>
<li><a href="../310252/index.html">Five promising programming languages ‚Äã‚Äãwith a bright future</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>