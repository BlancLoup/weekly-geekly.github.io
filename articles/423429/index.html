<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Database update and zero-downtime deployment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A lot of articles have been written about updating systems ‚Äúon the fly‚Äù without stopping them (zero-downtime deployment), and many aspects of this app...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Database update and zero-downtime deployment</h1><div class="post__text post__text-html js-mediator-article">  A lot of articles have been written about updating systems ‚Äúon the fly‚Äù without stopping them (zero-downtime deployment), and many aspects of this approach are quite obvious.  In my opinion, the most difficult part of deployment in this case is the update of data warehouses, in case their contract (scheme) has changed.  This is the aspect I would like to consider in this article. <br><a name="habracut"></a><br>  Whatever the database - with an explicit data schema as relational or arbitrary, like NoSQL - the data schema is still present, even at the application level.  The data read from the database should be clear to the client, even if the repository itself does not impose any restrictions on their structure. <br><br>  Suppose a system with a certain data structure and terabytes of data in the database is already running in production.  In the new version of the system, we need to change the structure slightly to implement new features or improve performance.  Consider what changes in the scheme can occur: <br><br><ul><li>  Adding a new field </li><li>  Deleting a field </li><li>  Rename field </li><li>  Field type changes </li><li>  Field transfer to another data structure (for example, in case of denormalization) </li></ul><br>  Adding a new field as well as adding any other database object is a backward-compatible change and does not require any additional steps in terms of implementing a zero-downtime deployment (with one disclaimer - if this new field or object is functionally dependent on others already stored in the database data).  It is enough just to apply the changes in the database ‚Äúon the fly‚Äù, after which the new version of the code that uses the new database objects is applied. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Deleting a field or any other database object is not a backward-compatible change, but the approach to its implementation is very simple - unnecessary database objects should be removed only after the new version of the system is complete. <br><br>  The remaining three types of changes are more complex in terms of providing a zero-downtime deployment.  In general, all of them can be performed by copying data to other fields / entities, and deleting the ‚Äúold‚Äù data after successfully completing data migration: to rename, you can copy data from the old field to the field with the new name, then delete the old field, change the data type can be done along with renaming, etc.  Anyway, for some period of time, the database should support both old and new contracts.  There are at least two ways to make these changes on the fly: <br><br><h3>  If the database supports triggers </h3><br><ol><li>  Create triggers that copy data from the old place to the new one on any change / addition and set them on production. </li><li>  Apply a data conversion utility that does the same thing, but for all records in the database.  Since the triggers are already installed, the utility can do nothing more complicated than just a ‚Äúdummy‚Äù update of each record (UPDATE table SET field = field ...).  A very important point here is that the action of reading data from the old place and writing to the new should be atomic and protected from lost changes.  Depending on the structure of the database, you can use either pessimistic locking via SELECT FOR UPDATE or its analogs, or optimistic if the tables have a field with the record version. </li><li>  After the utility finishes its work (depending on the amount of data and the complexity of the update, the execution time can be calculated in days) you can already install a new version of the system that supports the new data scheme.  By this time, all the records in the database that existed at the time of launching the utility will be successfully converted, and all new ones that appeared during its operation will also be converted by triggers. </li><li>  Delete triggers and all fields (or other database objects) that are no longer needed. </li></ol><br><h3>  If it is not possible to use triggers (as is the case with many NoSQL solutions) </h3><br><img src="https://habrastorage.org/webt/y2/09/6c/y2096cri-hcwq7p5caokazzy6dq.png"><br><br><ol><li>  Create and close a new version of the application (temporary version 1 in the figure), which always reads from the old field, but when writing in this field, it updates both the old and the corresponding new place (in the figure ‚ÄúC‚Äù, the old one, ‚ÄúH‚Äù - new).  Apply this version to all nodes on which application instances run. </li><li>  Apply a utility that copies data from the old place to the new.  As in the case of triggers, measures must be taken to prevent lost changes. </li><li>  Create another version of the application (temporary version 2), which reads data from the new field, but still writes in two places.  This step is necessary, because during the sequential update of each of the nodes there will still be a gap when instances of a previous version of the application reading the old field work simultaneously with the new one. </li><li>  Create and at the end of the full scan of the previous one, finalize the final version, which already does not interact with the old field. </li><li>  Delete old fields. </li></ol><br>  The second approach requires the creation and installation of three different versions of the application, which can be very inconvenient and cumbersome.  Instead, you can use feature toggling - lay the logic of all three versions into one, but switch the mode depending on the configuration parameter, which ideally could be switched on the fly.  Thus, instead of installing each subsequent version, it will be enough to change the value of the parameter (and restart the service if the configuration update is not provided on the fly).  After successfully completing the installation of the final version, all the code related to ensuring data migration should be completely removed from the working branch, even if it will be ‚Äúlive‚Äù on production until the next system update. <br><br>  It is easy to see that ensuring zero downtime when updating the system is a cumbersome and fragile procedure, so it makes sense to bother with it only if there is a corresponding requirement from the business.  But even if the requirements for system availability are rather low (for example, 99% per year and the window of the planned system update is 24 hours), the data conversion required to install the new version may still take more.  Therefore, you need to be prepared in advance for the use of such solutions, if you intend to store large amounts of data. <br><br>  An alternative approach would be to deliberately abandon the back-incompatible changes in the database schema, but, unfortunately, in practice it is not always achievable, since often the most effective way to improve the performance of data access is to restructure the scheme. </div><p>Source: <a href="https://habr.com/ru/post/423429/">https://habr.com/ru/post/423429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423419/index.html">HTML5 client for VMware vSphere coming out this fall - what you need to know</a></li>
<li><a href="../423421/index.html">Why for indie before the grass was greener</a></li>
<li><a href="../423423/index.html">MIT course "Computer Systems Security". Lecture 8: "Model of network security", part 3</a></li>
<li><a href="../423425/index.html">Old school: what were the games on - we are discussing unusual carriers</a></li>
<li><a href="../423427/index.html">IndieVisible - an online community of indie developers built on an open source platform.</a></li>
<li><a href="../423431/index.html">SIEM depths: out-of-box correlations. Part 1: Pure marketing or unsolvable problem?</a></li>
<li><a href="../423437/index.html">The digest of interesting materials for mobile developer # 270 (September 10 - 16)</a></li>
<li><a href="../423439/index.html">Report of the Club of Rome 2018, Chapter 2.6: ‚ÄúPhilosophical Errors of Market Doctrine‚Äù</a></li>
<li><a href="../423441/index.html">Exonum first buyding: why we chose Java</a></li>
<li><a href="../423445/index.html">Creating an online store structure: category map</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>