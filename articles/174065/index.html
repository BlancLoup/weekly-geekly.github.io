<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Switch subtleties</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yes, this is a whole article on the most common switch in JDK 7. It so happens that the accumulated material seems interesting and little known, and t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Switch subtleties</h1><div class="post__text post__text-html js-mediator-article">  Yes, this is a whole article on the most common switch in JDK 7. It so happens that the accumulated material seems interesting and little known, and then it turns out that every grandmother at the entrance for 50 years knows about the features of the switch implementation.  But I'll try.  For starters, I suggest 3 questions: <br><br><ol><li>  (Simple) What is the result of this code? <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: System.out.print(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: System.out.print(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: System.out.print(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: System.out.print(<span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br></li><li>  The following 2 options are almost the same.  Little different literals. <br><table><tbody><tr><td><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 switch("BBBBBB"){ case "AaAaAa": break; case "AaAaBB": break; case "AaBBAa": break; case "AaBBBB": break; case "BBAaAa": break; case "BBAaBB": break; case "BBBBAa": break; case "BBBBBB": break; }</span></span></code> </pre> </td><td><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 2 switch("BBBBBB_8"){ case "AaAaAa_1": break; case "AaAaBB_2": break; case "AaBBAa_3": break; case "AaBBBB_4": break; case "BBAaAa_5": break; case "BBAaBB_6": break; case "BBBBAa_7": break; case "BBBBBB_8": break; }</span></span></code> </pre> </td></tr></tbody></table>  Why is the first switch performed several times slower, at least with JIT disabled <nobr>(-Djava.compiler = NONE)?</nobr>  <nobr>Check yourself in a loop!</nobr>  JIT such a code can not catch, but if a little poshamanit, then a small difference will be noticeable. </li><li>  What is the computational complexity of the algorithm for finding the same value among n case s (at least in JDK 7)? <br></li></ol><a name="habracut"></a><br>  Answers: <br><ol><li>  01 </li><li>  The hashCode () method returns the same value for all lines of the first switch.  Details below. </li><li>  Depending on the case, it can be O (1), O (log n) and even reach O (n). </li></ol><br>  Let's figure it out.  Case values, for short, I will call keys. <br><br><h4>  Table switch </h4><br>  Take an example from the first task.  Compile it and disassemble the resulting bytecode. <br><pre> <code class="bash hljs">javap -c Main.class</code> </pre> <br><pre> <code class="java hljs"> <span class="hljs-number"><span class="hljs-number">0</span></span>: iconst_5 <span class="hljs-comment"><span class="hljs-comment">//  5   1: tableswitch { // 1 to 4 //  3       1: 39 // 39, 56, 32, 49 ‚Äì    2: 56 3: 32 4: 49 default: 32 } 32: getstatic #27 // Field java/lang/System.out:Ljava/io/PrintStream; 35: iconst_0 36: invokevirtual #33 // Method java/io/PrintStream.print:(I)V 39: getstatic #27 // Field java/lang/System.out:Ljava/io/PrintStream; 42: iconst_1 43: invokevirtual #33 // Method java/io/PrintStream.print:(I)V 46: goto 63 // break 49: getstatic #27 // Field java/lang/System.out:Ljava/io/PrintStream; 52: iconst_4 53: invokevirtual #33 // Method java/io/PrintStream.print:(I)V 56: getstatic #27 // Field java/lang/System.out:Ljava/io/PrintStream; 59: iconst_2 60: invokevirtual #33 // Method java/io/PrintStream.print:(I)V 63: return</span></span></code> </pre><br>  We are especially interested in the instruction with label 1. It means that the compiler has created a table (array) containing the jump addresses for all key values ‚Äã‚Äãfrom smallest to largest, with no exceptions.  The switch execution algorithm is something like this (pseudocode): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val&lt;low || val&gt;high){ jump <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ jump table[val - low]; }</code> </pre><br>  In our case: low == 1, high == 4, table == {39, 56, 32, 49}.  Since all keys from low to high must be consistently in the table, the compiler had to add key 3 and set the same behavior for it as for default. <br><br>  Starting with instruction 32, the code of all cases and default is in the order of their location in the source code.  Roughly speaking, here the compiler generates a solid code of key handlers.  I think it is now clear why, after a match was found, execution continues until the first break occurred. <br><br><h4>  LookupSwitch </h4><br>  A reasonable question appears: what if the values ‚Äã‚Äãof the keys are very sparse?  If we have only two of them: 1 and 1000000, then it is extremely unwise to create an array with a million elements.  Replace the key in our example 4 by 10, this will be enough (if suddenly there is no - increase).  We look at the byte code (the byte code of the handlers remained almost the same, therefore it is not given): <br><br><pre> <code class="java hljs"> <span class="hljs-number"><span class="hljs-number">1</span></span>: lookupswitch { <span class="hljs-comment"><span class="hljs-comment">// 3 1: 43 2: 60 10: 53 default: 36 }</span></span></code> </pre><br>  Here, too, the table is set, but for pairs: key is a transition label.  The JVM specification says that although the search may be linear, the keys must be sorted for a faster search, although the search method itself is not specified.  Perhaps in some implementations a linear search is used.  This is the first case I know (albeit a theoretical one) with the complexity of switch O (n).  Next we will see another, more tangible. <br><br>  Real boys and girls ask: how does the compiler decide what to choose - tableswitch or lookupswitch?  And the most realistic source code for OpenJDK is downloaded (note that in other JDK implementations the selection method may differ) and study the visitSwitch method of com.sun.tools.javac.jvm.Gen.java class in openjdk / langtools / src / share / classes. <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">// Determine whether to issue a tableswitch or a lookupswitch // instruction. long table_space_cost = 4 + ((long) hi - lo + 1); // words long table_time_cost = 3; // comparisons long lookup_space_cost = 3 + 2 * (long) nlabels; long lookup_time_cost = nlabels; int opcode = nlabels &gt; 0 &amp;&amp; table_space_cost + 3 * table_time_cost &lt;= lookup_space_cost + 3 * lookup_time_cost ? tableswitch : lookupswitch;</span></span></code> </pre><br>  <b>table_space_cost</b> - this size includes the number of all values ‚Äã‚Äãof the range, plus one value for lo, hi, default_address and a marker for the selected switch method (tableswitch). <br>  <b>table_time_cost</b> - 3 operations: checking the entry into the range (minimum and maximum) and extracting the address label from the table. <br>  <b>lookup_space_cost</b> - 2 values ‚Äã‚Äãfor each key-address pair, plus a value for the table size, default_address, and a handle for the selected switch method (lookupswitch). <br>  <b>lookup_time_cost</b> - the worst case is assumed - linear search. <br><br>  And the algorithm itself, as you can see, is simple.  The magic number 3 (‚ÄúAnd these people forbid us to poke around in the nose‚Äù (c)) is most likely empirical. <br><br><h4>  String comparison </h4><br>  "String.hashCode can easily have collisions, String.equals is too slow, maybe the strings are interned?" - I thought so, until I learned bytecode. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"AA"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"BB"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br><pre> <code class="java hljs"> <span class="hljs-number"><span class="hljs-number">0</span></span>: ldc #<span class="hljs-number"><span class="hljs-number">27</span></span> <span class="hljs-comment"><span class="hljs-comment">// String 2: dup 3: astore_0 4: invokevirtual #29 // Method java/lang/String.hashCode:()I 7: lookupswitch { // 2 2080: 32 2112: 44 default: 73 } 32: aload_0 33: ldc #35 // String AA 35: invokevirtual #37 // Method java/lang/String.equals:(Ljava/lang/Object;)Z 38: ifne 56 41: goto 73 44: aload_0 45: ldc #41 // String BB 47: invokevirtual #37 // Method java/lang/String.equals:(Ljava/lang/Object;)Z 50: ifne 66 53: goto 73 56: getstatic #43 // Field java/lang/System.out:Ljava/io/PrintStream; 59: iconst_1 60: invokevirtual #49 // Method java/io/PrintStream.println:(I)V 63: goto 73 66: getstatic #43 // Field java/lang/System.out:Ljava/io/PrintStream; 69: iconst_2 70: invokevirtual #49 // Method java/io/PrintStream.println:(I)V 73: return</span></span></code> </pre><br>  That is, at the compilation stage, the hash code of all keys is calculated.  LookupSwitch is always executed for strings, even if the hashes are consistent.  When executed, the hash code of the conditional expression is calculated and it is compared with the hash key.  If the string matches, they are also compared (addresses 32‚Äì53) with the String.equals () method to prevent possible collisions.  And, if successful, the transition to the execution of the corresponding expression (56-70). <br><br>  And if we have several keys with the same hashes? <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Aa"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"BB"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br><pre> <code class="java hljs"> <span class="hljs-number"><span class="hljs-number">7</span></span>: lookupswitch { <span class="hljs-comment"><span class="hljs-comment">// 1 2112: 24 default: 62 } 24: aload_0 25: ldc #35 // String Aa 27: invokevirtual #37 // Method java/lang/String.equals:(Ljava/lang/Object;)Z 30: ifne 45 33: aload_0 34: ldc #41 // String BB 36: invokevirtual #37 // Method java/lang/String.equals:(Ljava/lang/Object;)Z 39: ifne 55 42: goto 62 45: getstatic #43 // Field java/lang/System.out:Ljava/io/PrintStream; 48: iconst_1 49: invokevirtual #49 // Method java/io/PrintStream.println:(I)V 52: goto 62 55: getstatic #43 // Field java/lang/System.out:Ljava/io/PrintStream; 58: iconst_2 59: invokevirtual #49 // Method java/io/PrintStream.println:(I)V 62: return</span></span></code> </pre><br>  Then these keys are combined under one hash key in the lookupswitch, and, if the key matches, all the strings with this hash are searched and compared with String.equals ().  The example from the 2nd question performs as many as 8 comparisons.  Here you have the second case with complexity O (n). <br><br><h4>  findings </h4><br>  If it were not for the JIT, it would be possible to speculate about the optimization of the switch.  But I was not able to find a good example in which the tableswitch would have been noticeably faster than the lookupswitch (with JIT enabled).  Well, except that this: <br>  1. Suppose we have N keys with values ‚Äã‚Äãfrom 1 to N. In this case, tableswitch will be used. <br>  2. The same keys, but plus one more, with a value much larger than N. In this case, the lookupswitch will be used. <br>  (With JIT disabled, everything is clear, the difference is palpable.) <br>  With jit no difference.  Perhaps he breaks all the keys into several ranges and deals with them in the same way as the tableswitch.  However, starting with N = 721, I experienced a sharp drop in the performance of the second example. <br><br>  Finally, only wild advice suggests itself, consider them a joke: ‚ÄúGuys, if you have 1000 case with consecutive keys besides a few, if you have a cycle that must be performed one hundred million times per second, then handle these several keys outside the switch.  And if in this cycle a bunch of string keys with the same hashes, then think about other ways to implement. " </div><p>Source: <a href="https://habr.com/ru/post/174065/">https://habr.com/ru/post/174065/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../174051/index.html">Simple-Science - Simple Experiments (Digest # 19)</a></li>
<li><a href="../174053/index.html">UX-Medium Open Micro-Conference # 15</a></li>
<li><a href="../174055/index.html">MacBANG journal notepad! in your evernote</a></li>
<li><a href="../174057/index.html">How browsers work: how modern web browsers work</a></li>
<li><a href="../17406/index.html">TZ VS XP and their legal registration</a></li>
<li><a href="../174067/index.html">Sun and Cloud - a digital camera that does not need an external charger</a></li>
<li><a href="../174069/index.html">Table for selecting the screen diagonal and resolution</a></li>
<li><a href="../17407/index.html">Americans have chosen the word of the year</a></li>
<li><a href="../174075/index.html">Drawing lessons or how the film ‚ÄúThe Second of Free Fall‚Äù was made</a></li>
<li><a href="../174077/index.html">Using drivers from the Android application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>