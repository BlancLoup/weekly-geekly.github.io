<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Experiment: How irrational is exchange trading at short intervals (scalping)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The developer and trader Joan Christian Lotter, the creator of the Financial Hacker blog, wrote an interesting material in which he spoke about his ex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Experiment: How irrational is exchange trading at short intervals (scalping)</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/itinvest/blog/277337/"><img src="https://habrastorage.org/files/34b/4b0/471/34b4b0471df64020b5d855952cbcbe40.jpg"></a> <br><br>  The developer and trader Joan Christian Lotter, the creator of the Financial Hacker blog, wrote an interesting <a href="http://www.financial-hacker.com/is-scalping-irrational/">material</a> in which he spoke about his experiment to find out whether it makes sense to trade using short and ultrashort intervals for making deals.  We bring to your attention the main thoughts of this article. <a name="habracut"></a><br><br>  Novice traders often want to work at very short time intervals.  Some of them are inspired by stories about how someone earned $ 2,000 in five minutes - there is a lot of such good on financial companies.  Others have heard of high-frequency trading and are now confident that the higher the frequency of transactions, the better the final result.  Is this completely useless activity or does such short-term trading have any quantitative advantages?  The experiment, the purpose of which was to find out, showed unexpected results. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The temptation to receive income for some minutes is very great.  In addition, when trading on short time intervals (timeframes), more deals are made and there are more bars to analyze and improve the strategy.  The quality of tests and training depends on the amount of data available.  Nevertheless, scalping - that is, opening and closing deals in minutes or even seconds - among algo-traders is considered by many to be nonsense and irrational.  There are several reasons for this: <br><br><ol><li>  Short timeframes lead to increased costs - slippage, spread, commission - in relation to the expected income. </li><li>  With short intervals in <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25B2%25D0%25B0%25D1%258F_%25D1%2581%25D0%25BF%25D1%2580%25D0%25BE%25D1%2581%25D0%25B0">the demand curve</a> more noise, randomness and artifacts - all this reduces income and increases risk. </li><li>  Each trading algorithm needs to be adapted to work with a specific broker or financial data provider, since high-quality work with the price data stream is extremely important for successful trading. </li><li>  Algorithmic strategies usually just stop working on timeframes below a certain value. </li></ol><br>  High costs, less profit, greater risk, dependence on data feed, non-working algorithms are quite good arguments against scalping (HFT is a completely different story).  Despite the fact that the above may be true, and for example, experiments show that when backing up strategies on timeframes for less than 10 minutes on data from different brokers, the results are very different.  But this does not mean that this way of trading on the stock exchange makes no sense, maybe working with small timeframes simply requires a special approach? <br><br>  To find out, Lotter conducted an experiment that included the creation of a real scalping strategy. <br><br><h4>  Impact of collateral costs </h4><br>  The first part of the experiment was to analyze the statistical impact on the final financial result of the associated costs.  Logically, higher costs require more revenue to somehow offset them.  How many successful trades need to be made in order for the profit to exceed the cost of trading on different timeframes?  A small script below answers this question: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ BarPeriod = <span class="hljs-number"><span class="hljs-number">1</span></span>; LookBack = <span class="hljs-number"><span class="hljs-number">1440</span></span>; Commission = <span class="hljs-number"><span class="hljs-number">0.60</span></span>; Spread = <span class="hljs-number"><span class="hljs-number">0.5</span></span>*PIP; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> duration = <span class="hljs-number"><span class="hljs-number">1</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!is(LOOKBACK)) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(duration &lt;= <span class="hljs-number"><span class="hljs-number">1440</span></span>) { var Return = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(priceClose(<span class="hljs-number"><span class="hljs-number">0</span></span>)-priceClose(duration))*PIPCost/PIP; var Cost = Commission*LotAmount/<span class="hljs-number"><span class="hljs-number">10000.</span></span> + Spread*PIPCost/PIP; var Rate = ifelse(Return &gt; Cost, Cost/(<span class="hljs-number"><span class="hljs-number">2</span></span>*Return) + <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>); plotBar(<span class="hljs-string"><span class="hljs-string">"Min Rate"</span></span>,i++,duration,<span class="hljs-number"><span class="hljs-number">100</span></span>*Rate,AVG+BARS,RED); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(duration &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) duration += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(duration &lt; <span class="hljs-number"><span class="hljs-number">60</span></span>) duration += <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(duration &lt; <span class="hljs-number"><span class="hljs-number">180</span></span>) duration += <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> duration += <span class="hljs-number"><span class="hljs-number">60</span></span>; } Bar += <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-comment"><span class="hljs-comment">// hack! }</span></span></code> </pre> <br>  The script calculates the minimum degree of success of transactions, which is needed in order to offset the costs of trading at different time intervals.  It is assumed that there is a spread of 0.5 pips (the minimum value of the change in the price of a currency pair) and a total commission of 60 cents per 10,000 contracts - the average value of transactions in the financial market.  PIPCost / PIP in the code above is a factor in the conversion from price difference to an increase or loss of money in the account.  It is also assumed the absence of the influence of psychological factors on trade: all traders should, on average, make a profit or lose in the same way.  This allows you to split the value of the Return of the transaction on its profitability or loss, which are determined by the WinRate.  That is, if the transaction is profitable, then we will get WinRate * Return, and if it is unprofitable, then (1-WinRate) * Return.  To reach a return on investment, it is necessary that the difference between successful transactions and unprofitable costs be covered.  The success rate in this case should be as follows: <br><br> <code>WinRate = Cost/(2*Return) + 0.5</code> <br> <br>  This indicator is averaged over all bars and is depicted as a histogram of the duration of transactions from 1 minute to 1 day.  The increment timeframe is 1, 5, 30 and 60 minutes.  A deal for any duration is made every 101 minutes (Bar + = 100 in the script is a trick to start the simulation at the step starting from the 101st, while keeping the bar period equal to 1 minute). <br><br>  The script takes a few seconds, and then it issues the following histogram for the EUR / USD currency pair in 2015: <br><br><img src="https://habrastorage.org/files/85c/92e/73b/85c92e73bcf548c890a978755ba079aa.png"><br><br>  To cover the costs of trading in the interval of 1 day (the rightmost bar) you need a success rate of 53%, and for 1-minute trades it already grows to 90%.  That is, the ratio of reward to risk is 9: 1 for a success rate of 50%.  This greatly exceeds the real income generated by trading systems.  It would seem that the first punt from the list above is confirmed, and it becomes clear that the stories of ‚Äúsuccessful scalpers‚Äù from the trading forums should be taken with an occasional degree of skepticism. <br><br>  But what about the second thesis that on short timeframes there is more noise and randomness?  Or is there some way to work with them that will allow for greater predictability.  Find out is more difficult. <br><br><h4>  Measure randomness </h4><br>  ‚ÄúNoise‚Äù is often described using a high frequency trading component called a signal.  Usually, short time intervals generate more hft components than longer timeframes.  They can be found with a <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%25B2%25D0%25B5%25D1%2580%25D1%2585%25D0%25BD%25D0%25B8%25D1%2585_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D1%2582">high-pass filter</a> and eliminated with a <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%25BD%25D0%25B8%25D0%25B6%25D0%25BD%25D0%25B8%25D1%2585_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D1%2582">low-pass filter</a> .  But there is a problem: the noise of the demand curve is not always associated with high frequencies.  Noise is just a part of a curve that does not carry information about trading signals.  For cyclical trading, high frequencies are signals, and low frequency trends are noise.  In other words, what is noise depends on a specific strategy ‚Äî there is no ‚Äúuniversal‚Äù noise. <br><br>  Thus, to determine the ‚Äútradeability‚Äù of the demand curve, some other criterion is needed.  This is randomness.  It can be measured using the informational fullness of the demand curve.  A good measure of content is <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%258D%25D0%25BD%25D1%2582%25D1%2580%25D0%25BE%25D0%25BF%25D0%25B8%25D1%258F">Shannon's entropy</a> .  It is defined as: <br><br><img src="https://habrastorage.org/files/dbf/149/bb0/dbf149bb002b4e83b29b7f91198b5f0e.png"><br><br>  This formula measures the disorder.  In the case of an ordered, predictable signal, the entropy will be low.  Random, unpredictable signal has a high entropy.  In the formula, P (s <sub>i</sub> ) is the relative frequency of occurrence of a particular pattern s <sub>i</sub> in the signal s.  Entropy will be maximized when all patterns are evenly distributed, and all P (s <sub>i</sub> ) are approximately equal.  If some patterns occur more often than others, the entropy decreases.  In this case, the signal will be less random and more predictable.  Shannon entropy is measured in bits. <br><br>  Below is the code of the Shannon entropy indicator, depicted as a sequence of characters: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">var </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShannonEntropy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *S,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> var Hist[<span class="hljs-number"><span class="hljs-number">256</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(Hist,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(var)); var Step = <span class="hljs-number"><span class="hljs-number">1.</span></span>/Length; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;Length; i++) Hist[S[i]] += Step; var H = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">256</span></span>;i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Hist[i] &gt; <span class="hljs-number"><span class="hljs-number">0.</span></span>) H -= Hist[i]*log2(Hist[i]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> H; }</code> </pre><br>  The character is 8 bits, so the line can be 2 <sup>8</sup> = 256 characters.  The frequency of each character is calculated and stored in the Hist array.  This array contains P (s <sub>i</sub> ) from the entropy formula above.  Then these values ‚Äã‚Äãare multiplied by the binary logarithm and summed.  The result is H (S) - this is Shannon's entropy. <br><br>  In the code above, the symbol is a patten of the signal.  Thus, it is necessary to convert the demand curve into character patterns.  This can be done using the <code>ShannonEntropy</code> function, which calls the previous one: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">var </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShannonEntropy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var *Data,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Length,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PatternSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> S[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// hack! int i,j; int Size = min(Length-PatternSize-1,1024); for(i=0; i&lt;Size; i++) { int C = 0; for(j=0; j&lt;PatternSize; j++) { if(Data[i+j] &gt; Data[i+j+1]) C += 1&lt;&lt;j; } S[i] = C; } return ShannonEntropy(S,Size); }</span></span></code> </pre><br>  <code>PatternSize</code> determines the segmentation of the demand curve.  The pattern is determined by the number of price changes.  Each new price is either higher than the previous one or not - this is binary information describing one bit of the pattern.  A pattern can include up to 8 bits, which is equivalent to 256 combinations of price changes.  Patterns are also stored in a character string.  Their entropy is determined by calling the <code>ShannonEntropy</code> function for a particular string (as you can see, both functions have the same name, but the compiler distinguishes them by parameters).  Patterns are generated based on price and subsequent <code>PatternSize</code> prices.  Then the procedure is repeated for the subsequent price, thus the imposition of patterns. <br><br><h4>  Unexpected result </h4><br>  Now it only remains to draw the Shannon entropy histogram, as we did above with the success rate: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ BarPeriod = <span class="hljs-number"><span class="hljs-number">1</span></span>; LookBack = <span class="hljs-number"><span class="hljs-number">1440</span></span>*<span class="hljs-number"><span class="hljs-number">300</span></span>; StartWeek = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Duration = <span class="hljs-number"><span class="hljs-number">1</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(Duration &lt;= <span class="hljs-number"><span class="hljs-number">1440</span></span>) { TimeFrame = frameSync(Duration); var *Prices = series(price(),<span class="hljs-number"><span class="hljs-number">300</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!is(LOOKBACK) &amp;&amp; <span class="hljs-number"><span class="hljs-number">0</span></span> == (Bar%<span class="hljs-number"><span class="hljs-number">101</span></span>)) { var H = ShannonEntropy(Prices,<span class="hljs-number"><span class="hljs-number">300</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); plotBar(<span class="hljs-string"><span class="hljs-string">"Randomness"</span></span>,i++,Duration,H,AVG+BARS,BLUE); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Duration &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) Duration += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Duration &lt; <span class="hljs-number"><span class="hljs-number">60</span></span>) Duration += <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Duration &lt; <span class="hljs-number"><span class="hljs-number">240</span></span>) Duration += <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Duration &lt; <span class="hljs-number"><span class="hljs-number">720</span></span>) Duration += <span class="hljs-number"><span class="hljs-number">120</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Duration += <span class="hljs-number"><span class="hljs-number">720</span></span>; } }</code> </pre><br>  Entropy is calculated for all timeframes on every 101st bar (this number is chosen to avoid synchronization problems).  You can‚Äôt just skip a hundred bars, as in the previous script, as this will not allow you to adequately handle the price series.  Therefore, the script needs to examine every trading minute in the last three years, which takes a few minutes. <br><br>  There are two lines in the code that are important to explain - they are important for measuring the entropy of day candles using bars for periods of less than a day: <br><br> <code>StartWeek = 10000;</code> <br> <br>  The week starts at midnight on Monday (1 = Monday, 00 00 = midnight), instead of 11 pm Sunday.  If you select the last value, the script will consider this one Sunday hour as a full day, which increases the randomness of the daily candles. <br><br> <code>TimeFrame = frameSync(Duration);</code> <br> <br>  This line is needed to synchronize the timeframe with the clock during the day.  If it is removed, then the entropy of Shannon day candles will be too great. <br><br>  Shannon entropy is calculated for a pattern with a size of 3 price changes, which results in 8 different patterns.  The maximum entropy for 8 patterns is 3 bits.  Since the price changes are not completely random, one would assume that the entropy will be less than 3, increasing with a decrease in the timeframe.  However, for the data on the trading of the EUR / USD currency pair in 2013-2015, the following histogram is obtained: <br><br><img src="https://habrastorage.org/files/3a6/3f5/16b/3a63f516b0e54ad39900699277c5a231.png"><br><br>  Entropy is almost 3 bits.  This confirms the thesis that price is not completely random.  As can be seen, Shannon's entropy will be the smallest for the 1440 timeframe the size of minutes - it is about 2.9.  This is an expected result, since daily cycles seriously affect the demand curve, so daily candles are more predictable.  Therefore, price pattern algorithms often use daily candles.  Entropy increases with decreasing timeframe, but this happens only up to ten minute timeframes.  And even shorter time intervals are actually less random. <br><br>  And this is a surprise.  The smaller the timeframe, the lower the price quotes it contains, this should increase the element of randomness.  But the opposite happens - this happens for different time intervals (even ultrashort 2, 5, 10, 15, 30, 45 and 60 seconds) and even for different assets. <br><br><img src="https://habrastorage.org/files/1ad/844/f3c/1ad844f3cf4a4a3aaf1b24097adc9952.png"><br><br>  <i>Entropy vs timeframe (in seconds)</i> <br><br>  Now the x axis is seconds, not minutes.  Still, chance decreases with a decrease in the timeframe. <br><br>  There may be several explanations for this.  Price granularity is higher on small timeframes, since they contain fewer ticks (minimum price fluctuations).  Large deals are often broken up into <a href="https://habrahabr.ru/company/itinvest/blog/271059/">many small parts</a> (‚ÄúIceberg-orders‚Äù), which can lead to the appearance of sequences of similar price quotes at short time intervals.  All this reduces the price entropy of short timeframes, but does not necessarily lead to the emergence of trading opportunities. <br><br>  The sequence of identical quotes has zero entropy, they are 100% predictable, but cannot be used for trading.  Iceberg transactions represent a certain market inefficiency that can theoretically be used - but this is hampered by the high costs of the transaction.  If there were no brokerage commissions, then this would be possible, but not in the current situation. <br><br><h4>  findings </h4><br><ul><li>  Scalping is not complete craziness.  Even very small timeframes have some kind of regularity. </li><li>  However, this regularity is difficult for a private trader to use due to the high transaction costs. </li><li>  For timeframes above 60 minutes, prices become less random and more predictable.  This means that such timeframes are good to use for algorithmic trading. </li><li>  The most predictable prices for day bars.  When trading with their use will also be the minimum cost. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/277337/">https://habr.com/ru/post/277337/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277323/index.html">I am a web developer and for 10 days I can not write the simplest application</a></li>
<li><a href="../277329/index.html">Reflection and code generation in C ++</a></li>
<li><a href="../277331/index.html">DoS on your own: What causes the uncontrolled growth of tables in the database</a></li>
<li><a href="../277333/index.html">Copy elision, or how to shoot the leg to the neck ...</a></li>
<li><a href="../277335/index.html">Using functions in PostgreSQL as parameterized views</a></li>
<li><a href="../277339/index.html">Theory of restrictions in interfaces (who killed the old graph?)</a></li>
<li><a href="../277341/index.html">NetSkills Online Networking School</a></li>
<li><a href="../277343/index.html">Building Android applications step by step, part two</a></li>
<li><a href="../277345/index.html">In-depth training in the garage - Two networks</a></li>
<li><a href="../277349/index.html">Ireland is a tasty morsel for building a data center</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>