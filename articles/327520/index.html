<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>UE4 for Unity developers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! My name is Alexander, and today we compare Unity and Unreal Engine 4. 


 I think many developers tried the Unity engine and saw the games m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>UE4 for Unity developers</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/8df/543/ad4/8df543ad43804afe9ed0914258229d22.jpg" alt="image"></p><br><p>  Hi, Habr!  My name is Alexander, and today we compare Unity and Unreal Engine 4. </p><br><p>  I think many developers tried the Unity engine and saw the games made on it, projects, some demos.  Its main competitor is the Unreal Engine.  It originates in Epic Games projects, such as the Unreal Tournament shooter.  Let's take a look at how to get started with the Unreal engine after Unity and what obstacles might lie in our way. </p><a name="habracut"></a><br><p>  It happens that 3D-engines compare very superficially, or focus only on one of the features, for example, on the graph.  We will not holivarit and consider both engines as equal tools.  Our goal is to compare the two technologies and help you understand the Unreal Engine 4. Let's compare the basic systems of the engines with specific examples of the <a href="http://github.com/asd-firelight/UShooter">UShooter</a> demo project <a href="http://github.com/asd-firelight/UShooter">code</a> (Unreal + Unity Shooter) specially made for this purpose.  The project uses Unity version 5.5.0 and Unreal Engine 4.14.3. </p><br><h2 id="sistema-komponentov-unity">  Component System (Unity) </h2><br><p>  When we run the project on Unreal, we see that the character in the scene is just one object.  There are no familiar model nodes (embedded objects, meshes), skeleton bones, etc. in the World Outliner window. This is a consequence of the differences in the systems of the Unity and Unreal components. </p><br><p>  In Unity, a scene consists of <strong>Game Object</strong> objects.  This is an empty universal object to which the components implemented by the behavior scripts <strong>(MonoBehaviour)</strong> and the engine's built-in components are added.  Sometimes they are left empty, as a marker object, in the place of which, for example, a game character or effect will be created. </p><br><p> All these objects we see in the <strong>Hierarchy</strong> window in the engine editor.  They have a built-in <code>Transform</code> component with which we can control the position of an object in the space of a 3D scene.  For example, an object's movement script changes the coordinates in the <code>Update</code> function, and the object moves.  Two clicks are enough to add a similar script to a <strong>Game Object</strong> .  Having created an object ‚Äî a character or object ‚Äî we set it up, add scripts, and save it to <strong>prefab</strong> (the file that stores the <strong>Game Object</strong> and its child objects).  Subsequently, we can change the prefab itself, and these changes will affect all such objects. </p><br><p>  Here is the <code>RocketProjectile</code> class, which is a rocket in the UShooter project. </p><br><div class="spoiler">  <b class="spoiler_title">Fragment RocketProjectile.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RocketProjectile</span></span>: <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Damage = <span class="hljs-number"><span class="hljs-number">10.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> FlySpeed = <span class="hljs-number"><span class="hljs-number">10.0f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.transform.position += gameObject.transform.forward * FlySpeed * Time.deltaTime; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCollisionEnter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collision collision</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } }</span></span></code> </pre> </div></div><br><p>  We set the parameters of the projectile in the editor, if desired, change the speed of movement ( <code>FlySpeed</code> property) and damage ( <code>Damage</code> ).  Collision handling occurs in the <code>OnCollisionEnter</code> function.  Unity calls it itself, since the object has a <strong>Rigid Body</strong> component. </p><br><h2 id="sistema-komponentov-ue4">  Component System (UE4) </h2><br><p>  In Unreal Engine 4, game objects are represented by Actors and their components.  <code>AActor</code> (‚Äúactor‚Äù) is the main class of an object that fits in a scene.  We can create it in the game scene (both from the editor and the code), change its properties, etc. There is also a class from which all engine entities are inherited: <code>UObject</code> . </p><br><p><img src="https://habrastorage.org/files/e28/588/528/e285885282034703a424f919bd56b317.png" alt="image"></p><br><p>  Components are added to Actor, the game object.  It can be a weapon, a character, anything.  But these components are conventionally hidden from us in the analogue of <strong>Prefab</strong> 'a - <code>Blueprint Class</code> . </p><br><p>  In the Actor object, unlike Unity, there is the concept of <code>Root Component</code> .  This is the root component of the object to which the other components are attached.  In Unity, just drag and drop an object to change its nesting hierarchy.  In Unreal, this is done by binding the components to each other ("attachment"). </p><br><p>  In Unity, there are <code>Start</code> , <code>Update</code> and <code>LateUpdate</code> for updating or starting <strong>MonoBehaviour</strong> scripts.  Their counterparts in Unreal are the functions of <code>BeginPlay</code> and <code>Tick</code> in Actor.  The Actor components ( <code>UActorComponent</code> ) have the <code>InitializeComponent</code> and <code>ComponentTick</code> functions for this, so you cannot make an Actor component in one click and vice versa.  Also, unlike Unity, Transform does not have all the components, but only the <code>USceneComponent</code> and those inherited from it. </p><br><p>  In Unity, we can write <code>GameObject.Instantiate</code> almost anywhere in the code and get the object created from <strong>Prefab</strong> 'a.  In Unreal, we are ‚Äúasking‚Äù the world object ( <code>UWorld</code> ) to create an instance of the object.  Creating an object is called spawn in the enriale, from the word spawn.  For this, the <code>World-&gt;SpawnActor</code> function is used. </p><br><h2 id="personazhi-i-ih-controllery">  Characters and their Controllers </h2><br><p>  In Unreal, for characters, there are special classes <code>APawn</code> and <code>ACharacter</code> , they are inherited from the class <code>AActor</code> . </p><br><p>  <code>APawn</code> is a character class that can be controlled by a player or AI.  In Unreal, there is a controller system for controlling characters.  We create a <code>Player Controller</code> or <code>AI Controller</code> .  They receive a control command from the player or internal logic, if it is AI, and they transfer movement commands to the character class itself, <code>APawn</code> or <code>ACharacter</code> . </p><br><p>  <code>ACharacter</code> is based on <code>APawn</code> and has advanced movement mechanisms, an embedded skeletal mesh component, the basic logic of moving a character, and its representation for a multiplayer game.  For optimization, you can create a character based on <code>APawn</code> and implement only the necessary project functionality. </p><br><h2 id="opisanie-igrovogo-klassa-actora">  Description of the game class (Actor'a) </h2><br><p>  Now, having learned a bit about Unreal components, we can take a look at the rocket class in the Unreal version of <strong>UShooter</strong> . </p><br><div class="spoiler">  <b class="spoiler_title">Fragment RocketProjectile.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs">UCLASS() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">USHOOTER_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARocketProjectile</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Sets default values for this actor's properties ARocketProjectile(); // Called when the game starts or when spawned virtual void BeginPlay() override; // Called every frame virtual void Tick( float DeltaSeconds ) override; // Rocket fly speed UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Rocket") float FlySpeed; // Rocket damage UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Rocket") float Damage; // Impact (collsion) handling UFUNCTION() void OnImpact(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult&amp; Hit); private: /** Collision sphere */ UPROPERTY(VisibleDefaultsOnly, Category = "Projectile") USphereComponent* CollisionComp; };</span></span></code> </pre> </div></div><br><p>  The interaction of the editor and scripts, which in Unity does not require special code, works in Unreal through code generation.  This special Unreal code generates when building.  So that the editor can show the properties of our object, we make special wrappers: <code>UCLASS</code> , <code>GENERATED_BODY</code> and <code>UPROPERTY</code> .  We also decorate properties and describe how the editor should work with them.  For example, <strong><em>EditDefaultsOnly</em></strong> means that we can change the properties of only the default object, the blueprint class ( <strong>prefab</strong> 'a, if we draw an analogy with Unity).  Properties can be grouped into different categories.  This allows us to quickly find the properties of the object that interest us. </p><br><p>  The <code>OnImpact</code> function is an analogue of <code>OnCollisionEnter</code> in Unity.  But to work with it, you need to subscribe to events of the <code>USphereComponent</code> component in the constructor or even during the game.  It does not work automatically, as in Unity, but there is the possibility of optimization.  If we no longer need to respond to a collision, we can unsubscribe from the event. </p><br><h2 id="bluprinty-blueprint">  Blueprint </h2><br><p>  A typical action after creating a C ++ class in Unreal is to create <code>Blueprint Class</code> on its basis.  This is an extension of the object that Unreal gives us.  Unreal's Blueprint system is used for visual programming.  We can create visual schemes, connect events with some reactions to them.  Through the blueprints, the engine simplifies the interaction of programmers and designers.  We can write in C ++ a part of the game logic and give designers access to it. </p><br><p>  At the same time, Unreal allows you to separate, if required, C ++ project source codes from its binaries and content.  Designers or outsourcers can work with compiled dll-libraries and never know what is happening inside the C ++ part of the project.  This is an additional degree of freedom provided by the engine. </p><br><p><img src="https://habrastorage.org/files/e2d/c62/bd4/e2dc62bd4a67421e90ecdef866e7e0b6.png" alt="image"></p><br><p>  Unreal is good because it has almost everything related to Blueprints.  We can extend C ++ classes with them, create Blueprint heirs from them, etc. This system is closely connected with all components of the engine, from its internal logic to visual components, collision, animation, etc. </p><br><p>  Unity has similar visual programming systems, such as <a href="https://www.assetstore.unity3d.com/en/">Antares Universe</a> .  They are not part of the engine and are created on top of it, so at any moment something may break (for example, when updating the engine version).  The system of visual scripting in Unity is not provided.  In my opinion, this is a serious drawback compared to Unreal.  Indeed, thanks to such systems, even people far from programming can draw up a diagram of the interaction of objects or relate some sequence of actions.  By the way, in Unreal all project templates have two versions: both on the basis of C ++ code, and entirely on Blueprints.  Thus, to create a simple project without using code, entirely on blueprints, is quite realistic. </p><br><h2 id="demka-shutera-ushooter">  Demo shooter (UShooter) </h2><br><p>  In Unity, we write a demo from scratch, and in Unreal we rely on templates.  In the template, we select the control and camera view, and Unreal will generate a project with the specified settings.  This is a good basis from which you can build on to speed up the development and creation of a prototype project. </p><br><p><img src="https://habrastorage.org/files/a56/9f6/105/a569f61050cc4c5ab96826cbea312661.png" alt="image"></p><br><p>  On top of the Side Scroller pattern, we add our own HUD interface, barrels, several weapons and sounds.  Let's give the player a rocket launcher and a railgun, let him heroically shoot at exploding barrels. </p><br><h2 id="sistema-vvoda-unity">  Input system (unity) </h2><br><p>  Manage the character will be using the input system.  In Unity, we usually set up input through <strong>Input Manager</strong> , create virtual named axes.  For example, "go ahead" or "shoot."  We give them names and then we get the value of any axis or the state of the virtual button.  Usually, scripts that manage objects, get the status of the axes in the <code>Update</code> function.  In each frame, the status of the axis and a number of control buttons is polled. </p><br><h2 id="sistema-vvoda-ue4">  Input system (UE4) </h2><br><p><img src="https://habrastorage.org/files/a34/1dd/66f/a341dd66f4a642cc927a3466c9ba8c3c.png" alt="image"></p><br><p>  Unreal also has virtual axes, but there is a separation on the axis itself (values ‚Äã‚Äãobtained from the joystick, etc.) and the action buttons.  Unlike Unity, we bind the axes and buttons to the functions of a class that implements character control.  The link is created through the <code>UInputComponent</code> component.  Such an input component is in the character class <code>ACharacter</code> . </p><br><p>  <code>BindAxis("MoveRight", this, &amp;AUShooterCharacter::MoveRight)</code> in the <strong>Input Component,</strong> we assign the click of the MoveRight button to the call of the motion function of the same name.  Each frame is not required to poll the button. </p><br><p>  Also in Unreal is not limited to the number of alternative buttons.  In Unity, the Input Manager has only a main button and an alternative one.  The more input devices in your game, the more acute this problem may be. </p><br><h2 id="rabota-s-3d-modelyami">  Work with 3D-models </h2><br><p>  As already mentioned, in Unreal we do not see the structure of the character's skeleton in the scene.  The fact is that the components of the skeleton are not Actors or something like that.  These are the internal properties of the skeleton and animation.  How then to tie a weapon to a character or hide one of its parts?  Maybe we want to put a fashionable cap on him or attach a weapon to his arm. </p><br><p>  In Unity, we will select the weapon model in the editor, drag it to the desired bone, we can even hang a separate control script on it.  In Unreal, we will use sockets (Socket) - attachment points on game objects.  Sockets are part of the skeleton in models with skeletal animation (in Unity, such models are called <strong>Skinned Mesh</strong> , in Unreal they are called <strong>Skeletal Mesh</strong> ).  You can also add sockets to static meshes ( <strong>Static Mesh</strong> ). </p><br><p><img src="https://habrastorage.org/files/924/739/441/9247394419764f1b92611ef1fce9e242.png" alt="image"></p><br><p>  Select the bone to which the socket is attached, and set the name of the socket, for example <strong><code>S_Weapon</code></strong> , if a weapon is attached to a point.  After creating a socket, you can create (‚Äúshoot‚Äù) an object at the position of this socket or bind it to the socket via the binding mechanism ( <code>AttachTo</code> function).  The system is a bit confusing, unlike Unity, but more universal.  We can once set up the names of points, thereby separating the game logic from the settings of the models.  And if we have several models with one skeleton, then we will only need to add sockets to the skeleton.  In the shooter demo, sockets are used to create shells and the effects of a shot. </p><br><h2 id="sistema-animacii-unity">  Animation system (Unity) </h2><br><p>  We have a character, we know how to work with input, now we need to play the animation.  In Unity, there is an <strong>Animation Controller</strong> for this, we describe certain states of a character in it.  For example, run, jump or die.  Each block has its own animation clip, and we set up this transition graph: </p><br><p><img src="https://habrastorage.org/files/e0a/ac1/ac3/e0aac1ac359747f2b32a666b7228b501.png" alt="image"></p><br><p>  Although this scheme is called the <strong>Animation Controller</strong> , it has no internal logic.  This is just a circuit for switching animations depending on the state.  In order for it to work, we declare in advance in this controller the names of variables corresponding to the state of the character.  The script that controls the animation often sends these states to the controller itself every frame. </p><br><p>  In transitions between states (shown in the diagram by arrows), we set up transition conditions.  You can customize the blending (crossfade) animation, i. E.  the time during which one animation dies out and the other continues, for their smooth alignment. </p><br><h2 id="sistema-animacii-ue4">  Animation System (UE4) </h2><br><p>  In Unreal, everything is done by Blueprints, animation is no exception.  Create an animation <code>Animation Blueprint</code> that will control the animation.  It is also a state graph.  It looks like a state machine, it controls the final animation of the character depending on the movement or state of death. </p><br><p><img src="https://habrastorage.org/files/cfa/f0c/572/cfaf0c5727c44300b6c2abf84507e2ff.png" alt="image"></p><br><p>  Here we see the already familiar states of <strong>Idle / Run, Jump, Dead</strong> .  But one node combines <strong>Idle</strong> and <strong>Run</strong> .  Inside it is the so-called <strong>Blend Space 1D</strong> , it is used for a smooth transition of animation, depending on the value of one or several variables.  With <strong>Blend Space,</strong> you can tie a character‚Äôs speed to the transition between the <strong>Idle</strong> and <strong>Run</strong> animations.  In addition, you can configure multiple transition points.  For example, from zero to one meter per second, the character goes slowly - it will be a movement interpolated between the <strong>Idle</strong> and <strong>Walk</strong> animations.  And after a certain threshold value, run is activated.  And all this will be in one Animation Blueprint node, which refers to <strong>Blend State</strong> . </p><br><p>  The arrows show transitions between states, but, unlike Unity, we can create a Blueprint that implements the internal logic of these transitions.  In <strong>Animation Blueprint,</strong> there is access to the character on which it is used, so the Blueprint itself refers to its parameters (speed of movement, etc.).  This can be considered as an additional optimization, since it allows not to calculate parameters that are not used for the current state of the character. </p><br><p>  In Unreal, there are many tools for animation.  <strong>Montage</strong> is a subsystem and editor that allows you to combine animated clips and their fragments. </p><br><p>  Here is a combination of the state machine of motion with the attack animation, which we lose through the <strong>Montage</strong> tool. </p><br><p><img src="https://habrastorage.org/files/4b6/8b9/531/4b68b95314054e589e8b31a5f00c1962.png" alt="image"></p><br><p>  At the bottom of the picture is a fragment of the <strong>Animation Blueprint</strong> scheme, which is responsible for the reaction to the shot from the weapon.  The <strong>Montage Play</strong> team turns on the animation of the shot, then the <strong>Delay</strong> waits until it ends, and the animation is turned off by the <strong>Montage Stop</strong> command.  This is done, because in the animation states machine we cannot set to play the animation clip once.  If the animation is looped and corresponds to some state of the character, we can control the animation through the state machine.  And if you want to play a single animation clip on the event, we can do it through <strong>Montage</strong> . </p><br><h2 id="problema-vlozhennyh-prefabov">  Nested Prefabs Problem </h2><br><p>  The big problem in Unity is nested <strong>prefabs</strong> .  In case the problem is not familiar to you, consider an example. </p><br><p>  Suppose that the ‚Äútable with laptop‚Äù object was saved in prefab table1, and then a second similar object was needed, but with the green color of the laptop screen.  Create a new prefab - table2, drag the old laptop into it, change the screen color to green, save.  As a result, table2, the second prefab, becomes a completely new object, it has no references to the original.  If we change the source prefab, it will not affect the second prefab in any way.  The simplest case, but even it is not supported by the engine. </p><br><p>  In Unreal, due to <strong>Blueprint's</strong> inheritance, there is no such problem: changing the original object will affect all child objects.  This is useful not only for game objects, characters, some kind of logic or even static objects on the stage, but also for a system of interfaces. </p><br><p>  On the other hand, you can try to defeat this problem in Unity using assets in the Asset Store.  In Unity there are plugins, engine extensions, which are called - <a href="https://www.assetstore.unity3d.com/en/">Nested Prefabs</a> .  There are several similar systems, but they are a bit crutch, made on top of the engine, there is no support.  They are trying to preserve the internal state of the object.  When the game scene starts, they try to restore the internal structures, their fields, properties, etc., delete obsolete objects in the scene and replace them with instances from the prefabs.  As a result, we get not only the convenience of nested prefabs, but also unnecessary brakes, unnecessary data copying and object creation.  And if something changes in the engine, then these systems may even fall off for unknown reasons. </p><br><h2 id="sistemy-ui">  UI systems </h2><br><p>  In Unity, you cannot save window elements or any widgets to <strong>prefab</strong> .  We can try, but the same problem of prefabs will arise: the engine will forget about old objects.  Therefore, we often create controls in Unity, add scripts and then copy them without creating a prefab.  If you have to add something new to such ‚Äúwidgets‚Äù, the required changes need to be repeated manually. </p><br><p>  In Unreal, we can save interface elements in widgets (Widget Blueprint), quickly make new ones based on some controls.  Make a button and an inscription, let it be our status bar widget.  Based on standard and new widgets, it is quick and convenient to build interface windows.  By the way, widgets are also expanded by Blueprints, you can describe the logic of their work on visual schemes. </p><br><p>  In Unreal, the system for editing interfaces and all widgets is opened in a separate tab of the editor.  In Unity, the interface is edited through a special <strong>Canvas</strong> object, located directly in the 3D scene, and often even interfering with its editing. </p><br><h2 id="preimuschestva-i-nedostatki">  Advantages and disadvantages </h2><br><p>  For a beginner, the Unity engine is much simpler, it has an established community, many ready-made solutions.  You can extend the editor with scripts, add new menus, expand the Property inspector, etc. </p><br><p>  In Unreal, you can also write your windows and tools for the editor, but this is a bit more complicated, since you need to make a plugin, and this is a topic for a separate article.  This is more complicated than in Unity, you cannot write a small script here so that a useful button appears that expands the functionality of the editor. </p><br><p>  Of the advantages of Unreal, it is worth noting the visual programming, the inheritance of blueprints, UI widgets, an animation system with many features and much more.  In addition, in Unreal Engine 4 there is a whole set of classes and components designed to create games: <a href="https://docs.unrealengine.com/latest/INT/Gameplay/Framework/">Gameplay Framework</a> .  Gameplay Framework is part of the engine, all project templates are created on it.  Classes Gameplay Framework open up many possibilities - from the description of the game modes ( <strong>Game Mode</strong> ) and the state of the player ( <strong>Player State</strong> ) to save the game ( <strong>Save Game</strong> ) and control characters ( <strong>Player Controller</strong> ).  A special feature of the engine is an advanced network subsystem, a dedicated (dedicated) server and the ability to launch a network game in the editor. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  We compared the Unity 5 and Unreal Engine 4 engines with specific examples and problems that you may encounter when you start working with the Unreal engine.  Part of the complexity inherent in Unity, is solved in the Unreal Engine 4. Of course, it is impossible to make a comprehensive review of these technologies in one report.  However, we hope that this material will help you in studying the engine. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/327520/">https://habr.com/ru/post/327520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327508/index.html">Install NativeScript on Mac OS</a></li>
<li><a href="../327510/index.html">How to run servlets from Eclipse on the SAP Cloud Platform</a></li>
<li><a href="../327514/index.html">DevConf 2017 will be held in Moscow on June 17</a></li>
<li><a href="../327516/index.html">"Now there is a shortage of" native "developers": Mikhail Samarin on mobile development in a European company</a></li>
<li><a href="../327518/index.html">Let's talk about Teams</a></li>
<li><a href="../327522/index.html">Functional JavaScript programming with practical examples</a></li>
<li><a href="../327524/index.html">Troubleshooting using WinDbg, Sos and Sosex</a></li>
<li><a href="../327526/index.html">‚ÄúCubes‚Äù for stores: why hyper-convergence is really needed, and why it is not just a buzzword</a></li>
<li><a href="../327528/index.html">School data: is it possible to influence the election with the help of Big Data</a></li>
<li><a href="../327530/index.html">Bash scripts, part 7: sed and word processing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>