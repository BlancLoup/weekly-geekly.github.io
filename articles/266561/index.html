<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We develop a monitoring system for 55,000 RTP video streams</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! 

 Recently I read a very interesting article about processing 50 gigabits / s on the server and remembered that I have an article in drafts...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We develop a monitoring system for 55,000 RTP video streams</h1><div class="post__text post__text-html js-mediator-article">  Good day! <br><br>  Recently I read a <a href="http://habrahabr.ru/company/odnoklassniki/blog/266005/">very interesting article about processing 50 gigabits / s</a> on the server and remembered that I have an article in drafts about how we developed a system for monitoring video streams with a total traffic volume up to 100 Gbit / s a ‚Äã‚Äãyear ago.  Once again, ‚Äúread‚Äù it and decided to submit to the developers.  The article is more devoted to the analysis of protocols and the search for an architectural solution, rather than tuning of various linux subsystems, because we have taken the path of load distribution between the server and network probes that are connected to 10 Gigabit Ethernet traffic flows. <br><br><img src="https://habrastorage.org/files/903/10f/c5d/90310fc5d5e140738bda047011fe8e2d.JPG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you are interested in how we could measure the characteristics of network streams from 55 thousand video cameras, I ask for cat. <br><br><a name="habracut"></a><br><br>  In this article I plan to tell about: <br><ul><li>  what is monitored, how to connect to it; </li><li>  parameters of video streams to be measured; </li><li>  nuances ... understandably: there are nuances in every task; </li><li>  flour choice of suitable architecture; </li><li>  RTP protocol and its properties that allow the receiver to analyze the quality of the stream; </li><li>  identification of RTP packets in the trunk traffic; </li><li>  final system architecture; </li><li>  advantages and disadvantages of the chosen solution. </li></ul><br><br><h4>  What are we monitoring? <br></h4><br><br>  You need to monitor several 10G Ethernet transport links, which are transmitted by tens of thousands of video streams.  The first installation - 22 thousand cameras, the second - 55 thousand.  The average bit rate of the camera is 1 megabit / s.  There are cameras with 2 megabits / s and 500 kilobits / s. <br><br>  The video is transmitted using the RTP-over-UDP and RTP-over-RTSP-over-TCP protocols, and the connection is established via RTSP.  At the same time, there can be one stream from one IP address (one address ‚Äî one camera) or several (one address ‚Äî one encoder, that is, from 1 to 16 streams). <br><br>  Connection to ethernet links is possible only in the monitoring mode, using optical taps, in other words - in the non-intrusive mode.  Such a connection is preferable, since in this case the traffic does not pass through the equipment and, therefore, it can in no way affect the quality of the services provided (the drop in the optical signal level on the splitter is considered quite insignificant).  For operators, this is an extremely important argument.  And for developers, an important nuance follows from such a connection - you will always have to watch the flows ‚Äúfrom the side‚Äù, since  packets cannot be transmitted to the network (for example, you cannot send a ping and get a response).  It means that we will have to work in conditions of lack of information. <br><br><h4>  What are we measuring? <br></h4><br><br>  The stream quality assessment is based on the analysis of the RTP transport headers and the h.264 NAL-unit headers.  Image quality is not measured.  Instead, the transport stream of video frames is analyzed by the following criteria: <br><ul><li>  packets are not lost; </li><li>  Packages do not change their order; </li><li>  the number of frames corresponds to the SLA; </li><li>  bit rate corresponds to SLA; </li><li>  packet jitter is normal; </li><li>  and, finally, that the camera generally transmits packets. </li></ul><br><br>  RTP can ‚Äúgo‚Äù both over UDP, and (mostly, in 90% of cases) over RTSP / TCP in the ‚ÄúInterleaving data‚Äù mode.  Yes, despite the fact that the RFC for RTSP says that it is better not to use the Interleaving Data mode - see <a href="https://tools.ietf.org/html/rfc2326">10.12, rfc2326</a> ). <br><br>  Total: the monitoring system is a complex that is connected in a non-intrusive mode to the nth number of 10-gigabit Ethernet links, which continuously ‚Äúwatches‚Äù the transfer of all RTP video streams present in the traffic and takes measurements with a certain time interval in order to save them to the base.  According to data from the database, reports are regularly generated for all cameras. <br><br><h4>  And what's so complicated? <br></h4><br><br>  In the process of finding a solution, several problems were immediately fixed: <br><ul><li>  Non-intrusive connection.  The monitoring system connects to the already working channels, in which most of the connections (via RTSP) are already established, the server and the client already know which ports are exchanged, but this is not known to us in advance.  The well-known port is only for the RTSP protocol, but UDP streams can go through arbitrary ports (besides, it turned out that they often violate the SHOULD requirement for port parity / oddity, see <a href="https://tools.ietf.org/html/rfc3550">rfc3550</a> ).  How to determine that a particular package from some IP-address belongs to the video stream?  For example, the BitTorrent protocol behaves similarly - at the stage of establishing a connection, the client and the server agree on the ports, and then all the UDP traffic looks like ‚Äújust a bitstream‚Äù. </li><li>  In the connected links can be not only video streams.  There may be HTTP, BitTorrent, SSH, and any other protocols that we use today.  Consequently, the system must correctly identify video streams in order to separate them from the rest of the traffic.  How to do this in real time with 8 ten-gigabit links?  Of course, they are usually not filled up to 100%, so the total traffic will not be 80 Gbps, but about 50-60, but this is not so little. </li><li>  Scalable.  Where there are already a lot of video streams, there can be even more of them, since video surveillance has long since justified itself as an effective tool.  This suggests that there should be a performance margin and reserve for links. </li></ul><br><br><h4>  We are looking for a suitable solution ... <br></h4><br><br>  We, naturally, sought to make the most of our own experience.  By the time we made the decision, we already had the implementation of processing ethernet packets on an FPGA-powered <a href="http://metrotek.spb.ru/bmx.html">Bercut-MX</a> device (easier, MX).  With the help of Bercut-MX we were able to get the necessary fields for analysis from the Ethernet packet headers.  We didn‚Äôt have the experience of handling such traffic volume by means of ‚Äúordinary‚Äù servers, so we were wary of this decision with some caution ... <br><br>  It would seem that it remained to simply apply the method to the RTP packets and the golden key would be in our pocket, but MX can only handle traffic, it does not include the possibility of accounting and storing statistics.  There are not enough memory for storing the found connections (IP-IP-port-port combinations) in the FPGA, because there can be about 15 thousand video streams in the 2x10-gigabit link that comes in for each input , the number of lost packets, and so on ... Moreover, searching at this speed and for that amount of data under the condition of lossless processing becomes a non-trivial task. <br><br>  To find a solution, we had to ‚Äúdig a little deeper‚Äù and figure out what algorithms we would use to measure quality and identify video streams. <br><br><h4>  What can be measured by the fields of the RTP packet? <br></h4><br><br>  The format of the RTP packet is described in <a href="https://tools.ietf.org/html/rfc3550">rfc3550</a> . <br><br><img src="https://habrastorage.org/files/626/cdb/a57/626cdba5792f446dbb715e30b8a95de4.png"><br><br>  From the description it is clear that in terms of quality measurements in the RTP package, we are interested in the following fields: <br><ul><li>  sequence number - 16-bit counter, increasing with each packet sent; </li><li>  timestamp - timestamp, for h.264, the sampling rate is 1/90000 s (i.e., corresponding to a frequency of 90 KHz); </li><li>  Marker-bit.  In rfc3550, it is generally described that this bit is <a href="https://tools.ietf.org/html/rfc3550">intended to denote ‚Äúsignificant‚Äù events</a> , and in fact this bit most often cameras mark the beginning of a video frame and specialized packages with SPS / PPS information. </li></ul><br><br>  Obviously, the sequence number allows you to define the following stream parameters: <br><ul><li>  packet loss (frame loss); </li><li>  repeated packet sending (duplicate); </li><li>  changing the order of arrival (reordering); </li><li>  rebooting the camera, with a large "gap" in the sequence. </li></ul><br><br>  Timestamp allows you to measure: <br><ul><li>  delay variation (also called jitter).  At the same time, a 90 kHz counter should be operated on the receiving side; </li><li>  in principle, the delay in passing the packet.  But for this you need to synchronize the camera time with the timestamp, and this is possible if the camera transmits sender reports (RTCP SR), which is generally wrong, because  in real life, many cameras ignore the RTCP SR package (about half of the cameras we've worked with). </li></ul><br><br>  Well, M-bit allows you to measure the frame rate.  True, SPS / PPS frames of the h.264 protocol introduce an error, since  video frames are not.  But it can be leveled by using the information from the NAL-unit header, which always follows the RTP header. <br><br>  Detailed algorithms for measuring parameters are beyond the scope of the article, I will not go deeper.  If interested, then rfc3550 has an example of <a href="https://tools.ietf.org/html/rfc3550">loss calculation</a> code and <a href="https://tools.ietf.org/html/rfc3550">formulas for calculating jitter</a> .  The main conclusion is that for measuring the basic characteristics of the transport stream, only a few fields from the RTP packets and NAL units are sufficient.  And the rest of the information is not involved in the measurements and it can and should be discarded! <br><br><img src="https://habrastorage.org/files/f0c/88f/4f7/f0c88f4f77eb4641b083915609cc18b1.png"><br><br><h4>  How to identify RTP streams? <br></h4><br><br>  To keep statistics, information obtained from the RTP header must be ‚Äútied‚Äù to some camera identifier (video stream).  The camera can be uniquely identified by the following parameters: <br><ul><li>  Source and destination IP addresses </li><li>  Source and destination ports </li><li>  SSRC.  It is of particular importance when several streams are broadcast from the same IP, i.e.  in the case of multiport encoder. </li></ul><br><br>  Interestingly, we first made camera identification only by IP source and SSRC, relying on the fact that the SSRC should be random, but in practice it turned out that many cameras set the SSRC to a fixed value (say, 256).  Apparently, this is due to resource savings.  As a result, we had to add more ports to the camera ID.  This solved the problem of uniqueness completely. <br><br><h4>  How to separate RTP packets from the rest of the traffic? <br></h4><br><br>  The question remains: how does the Bercut-MX, having accepted the packet, understand that this is an RTP?  The RTP header does not have such an explicit identification as IP, it does not have a checksum, it can be transmitted via UDP with port numbers that are dynamically selected when a connection is established.  And in our case, most of the connections have been established for a long time and you can wait a long time for reinstallation. <br><br>  To solve this problem in <a href="https://tools.ietf.org/html/rfc3550">rfc3550 (Appendix A.1)</a> it is recommended to check the bits of the RTP version - these are two bits, and the Payload Type (PT) field is seven bits, which in the case of the dynamic type accepts a small range.  We found out in practice that for the multitude of cameras we work with, PT fits in the range from 96 to 100. <br><br>  There is one more factor - the port's parity, but as practice has shown, it is not always respected, so it had to be abandoned. <br><br>  Thus, the behavior of the Bercut-MX is as follows: <br><ol><li>  we receive a package, we sort into fields; </li><li>  if the version is 2 and the payload type is within the specified limits, then send the headers to the server. </li></ol><br><br>  It is obvious that with this approach there are false positives, since  Under such simple criteria not only RTP packets can fall.  But for us it is important that we definitely will not miss the RTP packet, and the ‚Äúwrong‚Äù packets will be filtered out by the server. <br><br>  To filter out false cases, the server uses a mechanism that registers the source of video traffic over several consecutively received packets (in the packet, there is a sequence number!).  If several packets come with consecutive numbers, then this is not a coincidence and we start working with this stream.  This algorithm turned out to be very reliable. <br><br><h4>  Moving on ... <br></h4><br><br>  Realizing that all the information going in the packets is not needed for measuring the quality and identifying flows, we decided to take all the highload &amp; time-critical work on receiving and isolating the RTP packet fields on Bercut-MX, I mean FPGA.  It ‚Äúfinds‚Äù the video stream, parses the packet, leaves only the required fields and sends it to a regular server in the UDP tunnel.  The server measures each camera and saves the results to a database. <br><br>  As a result, the server does not work with 50-60 Gigabit / s, but with a maximum of 5% (this is exactly the proportion of the data sent to the average packet size).  That is, at the input of the entire system 55 Gigabit / s, and the server gets only 3 Gigabits per second! <br><br>  As a result, we got this architecture: <br><br><img src="https://habrastorage.org/files/3bf/39f/f4e/3bf39ff4ec0742039926f89120bc1874.png"><br><br>  And we received the first result in this configuration two weeks after the initial TZ was set! <br><br><h4>  What is the result of the server busy? <br></h4><br><br>  So, what does the server do in our architecture?  His tasks: <br><ul><li>  listen to a UDP socket and read fields with packed headers; </li><li>  parse incoming packets and retrieve the RTP header fields along with the camera IDs; </li><li>  to correlate the received fields with those that were received before, and to understand whether the packets were lost, whether the packets were sent again, the order of arrival changed, what was the variation in packet delay (jitter), etc .; </li><li>  fix measured in the base with reference to time; </li><li>  analyze the database and generate reports, send traps on critical events (high packet loss, loss of packets from some camera, etc.). </li></ul><br><br>  Given that the total traffic at the server's input is about 3 Gigabit / s, the server copes even if we do not use any DPDK, but work simply via a linux socket (after increasing the buffer size for the socket, of course).  Moreover, it will be possible to connect new links and MXs, because the performance margin remains. <br><br>  Here is the top of the server (this is the top of only one lxc container, reports are generated in another): <br><br><img src="https://habrastorage.org/files/deb/c86/8c5/debc868c584a41ff930d39c1b034e866.png"><br><br>  It shows that the entire load on the calculation of quality parameters and statistics is distributed over four processes evenly.  We managed to achieve such a distribution due to the use of hashing in the FPGA: the IP hash is considered a hash function, and the low bits of the received hash determine the UDP port number that the statistics will go to.  Accordingly, each process listening to its port receives approximately the same amount of traffic. <br><br><h4>  Cons and pros <br></h4><br><br>  It is time to boast and admit the shortcomings of the solution. <br><br>  I'll start with the pros: <br><ul><li>  no loss at the junction with 10G-links.  Since the FPGA takes the whole ‚Äúhit‚Äù, we can be sure that every packet will be analyzed; </li><li>  monitoring 55,000 cameras (and more) requires only one server with one 10G card.  We are currently using a 2x Xeon based server with 4 cores of 2400 MHz each.  Enough with a margin: in parallel with the collection of information reports are generated; </li><li>  monitoring of 8 ‚Äúdozen‚Äù (10G links) fits into only 2-3 units: there is not always a lot of space and power in a rack for a monitoring system; </li><li>  when connecting links from MXs through the switch, you can add new links without stopping monitoring, since  no fee to insert the server is not necessary and for this you do not need to turn it off; </li><li>  the server is not overloaded with data, it receives only what is needed; </li><li>  headers from MX come in a jumbo Ethernet package, which means the processor will not get choked up by interrupts (besides, we do not forget about interrupt coalescing). </li></ul><br><br>  For the sake of justice, I will consider the disadvantages: <br><ul><li>  because of the rigid optimization for a specific task, the addition of support for new fields or protocols requires changes in the FPGA code.  This leads to more time consuming than if we did the same on the processor.  Both in development and testing, and at deploy; </li><li>  video information is not analyzed at all.  The camera can shoot an icicle hanging in front of it, or be turned in the wrong direction.  This fact will go unnoticed.  We, of course, made it possible to record video from the selected camera, but not to go through the operator with all 55,000 cameras! </li><li>  server and FPGA-powered devices - this is more expensive than just one or two servers;) </li></ul><br><br><h4>  Summary </h4><br><br>  In the end, we have a software and hardware complex in which we can control both the part that parses the packets on the interfaces and the one that keeps the statistics.  Full control over all nodes of the system literally saved us when the cameras began to translate to RTSP / TCP interleaved mode.  Because in this case, the RTP header is no longer located in the packet at a fixed offset: it can be anywhere, even on the border of two packets (the first half in one, the second in the other).  Accordingly, the algorithm for obtaining the RTP header and its fields has undergone dramatic changes.  We had to do TCP reassembling on the server for all 50,000 connections - hence the rather high load on top. <br><br>  We have never worked before in the field of high-loaded applications, but we managed to solve the problem at the expense of our skills in FPGA and it turned out pretty good.  There is even a reserve - for example, another 20-30 thousand streams can be connected to a system with 55000 cameras. <br><br>  Tuning linux subsystems (queuing by interrupts, increasing receive buffers, directive allocation of cores to specific processes, etc.) I left behind the article, since  This topic is already very well covered. <br><br>  I described not everything, the rake was collected a lot, so do not hesitate to ask questions :) <br><br>  Many thanks to all who read to the end! <br><br><h4>  Links <br></h4><br><br><ul><li>  <a href="http://metrotek.spb.ru/files/doc/bmx-rtp/bmx-rtp-booklet_ru.pdf">booklet of the monitoring system Bercut-MX / RTP</a> </li><li>  Probably the most promoted company engaged in similar tasks - <a href="http://www.bridgetech.tv/">bridgetech</a> </li><li>  Network Accelerator Cards in PC for traffic processing - <a href="http://www.napatech.com/">napatech</a> .  One of the techniques - Frame Classification - is similar to the approach we used.  However, it will not cope with the heuristic search for the RTP header anywhere in the TCP packet. </li><li>  <a href="https://tools.ietf.org/html/rfc3550">rfc3550</a> - RTP is described here </li><li>  <a href="https://tools.ietf.org/html/rfc2326">rfc2326</a> - the RTSP is described here </li><li>  <a href="http://habrahabr.ru/company/odnoklassniki/blog/266005">Mega-article about processing 50 gigabits on the server</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/266561/">https://habr.com/ru/post/266561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266549/index.html">Healthcare IT: or how to throw out $ 34 million</a></li>
<li><a href="../266551/index.html">Recognize cannot be left a picture, or something about difficult cases of optical character recognition</a></li>
<li><a href="../266553/index.html">Determine that the user has Wikipedia blocked.</a></li>
<li><a href="../266557/index.html">Sorting integers when memory is low</a></li>
<li><a href="../266559/index.html">Smart and Stupid React Components</a></li>
<li><a href="../266563/index.html">Profit about the printer</a></li>
<li><a href="../266565/index.html">GPS service ViaLatM - scripting language (part 2)</a></li>
<li><a href="../266567/index.html">Expand the Ghost blog in InfoboxCloud</a></li>
<li><a href="../266569/index.html">Configuring a ZTE AD3700 CDMA Modem for Intertelecom on Linux</a></li>
<li><a href="../266571/index.html">Generating PDF files in a web project: wkhtmltopdf program</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>