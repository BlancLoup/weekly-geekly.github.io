<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Docker in work. A look at its use in Badoo (a year later)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anton Turetsky ( Badoo ) 


 Today, I will invite you to such an internal Badoo kitchen to tell you whether we need a Docker. You will try to draw con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Docker in work. A look at its use in Badoo (a year later)</h1><div class="post__text post__text-html js-mediator-article"><h2>  Anton Turetsky ( <a href="https://habrahabr.ru/company/badoo/">Badoo</a> ) </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/a9a/38f/d42/a9a38fd42412b39a290506612b5a5bc9.jpg" alt="Anton Turetsky"><br><br>  Today, I will invite you to such an internal Badoo kitchen to tell you whether we need a Docker.  You will try to draw conclusions for yourself, do you need it.  This information on the Internet, respectively, is not, because it is all like this - in our close narrow circle. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2af/8ee/bd0/2af8eebd0bc4cc19e1546dee98d514cd.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      During the report, I will tell you about the most significant thing that concerns where to start the execution of any task.  We must decide why you do it, why do you take it? <br><br>  For ourselves, we answered these questions, without problems we would have no implementation.  Some of the problems we solve.  I selected the main ones, I will tell you about them and how we dealt with them.  In the end, I will advertise how wonderful we are, how we love all sorts of different bikes, how we make them, look, invent.  I will show them to you, I will tell you about them, you will form some opinion of yourself.  So let's go! <br><a name="habracut"></a><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/150059803" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The reason why we need a service of exploitation, why, in general, we need some kind of business, why we need, in particular, admins. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89b/d8c/49f/89bd8c49fa020f0f60001a8e5c94c1fa.png"><br><br>  Our main key unit is service.  If the service does not work, then why are we all here gathered?  In a remote view, the service looks something like this.  This is a piece of intellectual property of a programmer who writes some business logic and wants to get something.  There are layers of some network settings on the machine, a bunch of RPM packages related and not related to the directory service.  In general, this represents such a tangle, which the operation service receives to itself, and the system ticket, or how else the transfer of service from the developer to production is carried out.  Our main task is that we need to take one large and powerful server and cram some services on it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54b/f48/76c/54bf4876c451f75e53004631b0aded40.png"><br><br>  Everything looks great.  Over the past few years, the situation has not changed in any way.  We both rolled out services in the form of a ball, and rolled out. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a5f/f6a/4f7/a5ff6a4f7ce11726df6dde26b6970e9a.png"><br><br>  The problem that we have is when we need to take and for some reason settle our services, because the machine cannot cope, a new iron has arrived, we just want to take it and migrate.  And the first thing that we get during the migration, if we don‚Äôt use, for example, Docker, is that we drag the service onto a clean machine; on a clean new machine, everything is fine, great, the directories are pulled, but one problem ... Who uses a configuration management system like Chef and Puppet, and who rolls them out?  And who writes, reverse manifestos on taking everything and everything?  In the hall - only three people.  Accordingly, everyone who does not write this, I think, knows that in your server eventually there are some holes and pieces of the heritage of what lives there, and depending on the frequency of these migrations, the server grows sooner or later turns into some kind of trash.  If we take Docker and do the same migration, then we, like a brick, took out and put it in another place, and nothing old was left there.  Wonderful. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/842/5d7/e92/8425d7e92a20f8153315772ae8eabaab.png"><br><br>  Thus, the first reason that we, in general, began to look at Docker from the exploitation side is the task of untiing the application, collecting it in a ball, from the operating system. <br><br>  Next moment.  Since  we are not programmers at all, but still engineers and operators, then thinking about our resources, we always think about hardware.  Those.  iron is physical some kind of boxes that stand in large rooms, there is cool cooling, we hope that the cleaner does not come there. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d26/2ea/435/d262ea435a4224d7d1deef0b6a3b90fb.png"><br><br>  And since  we place our equipment in dedicated data centers, removing some kind of cage, at a certain point in time we begin to think that the equipment needs to be changed.  For a number of reasons, the equipment is newer, it gives us more parrots and units in performance, sooner or later we need to change. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf3/406/6ce/cf34066ce4b206591f9983a1acab7f75.png"><br><br>  Accordingly, the first problem related to capacity planning, more precisely, is not a problem, but even a task, is that we need to make the most efficient use of space in our racks, because the rack is some kind of return from it, it is a box rental, This is the cost of electricity and in the first place, this is money. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a6/1c2/f31/6a61c2f3114c1cbe4a0c3345416c6dd4.png"><br><br>  The next conclusion from the first point is that we also want to use the ports on the network equipment as much as possible, because the network equipment is also unit, it also takes up space, it also eats electricity. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2fc/aea/0ee/2fcaea0eede13759d010aebb2698f0f9.png"><br><br>  We are smoothly approaching the fact that we save electricity, respectively, we saved money, did great for the environment, great.  This does not concern us much, but here is a beautiful and wonderful such a positive bonus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89c/8da/cb0/89c8dacb0c30e0da0986dc55413116a9.png"><br><br>  But if we say that we bundle services on a more powerful server, then we get the next item, which I have marked ‚Äú¬±‚Äù - we come to a situation where, like, we have more options abstracted, more single points of failure. .  When you have one service lives on the same physical machine, everything is fine, most likely, we lose less if our server goes down.  In this case, this is too philosophical question, because if we are talking about replacing old equipment with new, new, most likely, the system will be less likely to fail than the old one.  And many have heard how many problems arise in the process of deployment.  Those.  in fact, according to statistics, it can be said that getting this Single point of failure, it is much less pianous on your production, than the curve is some kind of calculation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/07d/10f/9d5/07d10f9d5546a91b05ba719dea084e4b.png"><br><br>  The third point, why and why we started to look at Docker - this is a thrilling and acute problem; it is to plant your application from the time it was written by the programmer until rolling out into production, without changing anything that the application can be tied to.  In case of using Docker, since  We initially set up our applications in a certain environment with some kind of libs, packages, even with something, we have it planted with the build process conditionally in the team city.  Then we have it in the same original form goes to the Q &amp; A testing process, then we have, through staging, development, our finished application in the container can already go to production.  Those.  at this stage, we are discarding some changes ... If you have a problem with the application, and the different environment of this application is on development, on staging and on Q &amp; A testing, then it‚Äôs pretty hard to understand what affects our application in general, that it does not work, i.e.  We have solved this problem here 100%. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb0/762/010/eb0762010be96d18e844d03edc7d40af.png"><br><br>  And the last item that I marked as an item with an asterisk, because initially, when I saw the Dockerfile, it seemed to me that this was some kind of return 10 years ago.  Incomprehensible bash, no bash, something needs to be written when there is a puppet, why write these txt files?  But in fact, plus of this is that always, looking at the neighbor's config, you can see what the person was doing and why, what he might have thought about, and knowing how the Docker works and looking at such Docker files. , you can sometimes change this file to optimize the process of overlaying layers, doing something, using caching.  Those.  in fact, Dockerfile is a good, up-to-date documentation for your application. <br><br>  So, we answered the question for ourselves, why we wanted Docker and, introducing it, we always return to these letters and see: decided, not decided, applies, does not apply? <br><br>  Next is an interesting point that began with the process of implementing Docker with us.  Of course, we faced problems.  Some of these issues were discussed at Github Docker, etc.  The part is solved, the part we have not caught yet.  I think they will come after us. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc0/606/675/cc060667525e0840ffc144ac61df38c4.png"><br><br>  The first interesting problem was that we want to collect the logs of our application, at least somehow centrally.  We faced the challenge: ‚Äúmake us some syslog, programmers want to write to / dev / log, then we will send it somewhere, process it, etc.‚Äù. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b52/d2d/90d/b52d2d90de85e54a8cb25860d0c860cf.png"><br><br>  We sat and thought: how can we get the second service in the container?  The initial idea: one container - one service working in it.  Wrong.  Dilemma arises.  What to do? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a1e/7ed/3a7/a1e7ed3a70e70854c11bbcd4e6385749.png"><br><br>  It turns out +1 service which should be pushed into each container, to guarantee its work because they ask from us if logs were not delivered there.  This is a sub-clause that justifies laziness that something must be taken and done.  And the task, which, as usual, we need yesterday.  We need to already collect logs from the programmers.  The part of processing these logs is ready, we just need to take and do it.  Accordingly, the first thing that was invented and what we began to use was we took the dev / log socket inside the container and started writing there.  Cool! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1e/e20/06e/f1ee2006e882d642eeebebf23eb3acaf.png"><br><br>  We decided, agreed, rolled out, works fine.  Messages go.  Before the first problem, when we had to change the config'i and syslog on the hosts and reload it.  So  containers continue to hold the old socket, write something there, messages do not go anywhere, they remain there.  What to do? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3a/e14/e5f/d3ae14e5f515487c216fe55dd8e38c9d.png"><br><br>  This problem is a good case, which suggests that you do not forget about the first calls of your decisions, which were at the first stage.  In this case, we had to go back, back to the idea that "let's make a syslog inside the container, God bless her, with this idea that one service is one container."  And nobody told us physically about one service, that is, perhaps, the functionality of one service works there, and there are more processes.  We pushed syslog into the container, the config of this syslog doesn‚Äôt change, in fact we don‚Äôt need to support anything except the current version, because from syslog we send a helmet to the local host of the machine where it starts up, and then we‚Äôve got it from syslog 'and this machine is sending data to some of our central repository with logs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e6/2bf/025/1e62bf0254f81b3601dacd996447590b.png"><br><br>  The next interesting problem that concerned the fact that in the container we need some kind of directory, relatively speaking, to add or some kind of block device.  It seems to be simple, there is a -v key, which you prescribe, add, everything works for you.  And there is a feature in our company that we use some loop devices to distribute our code, and then we mount it with the -o loop.  We have an abstract block device, we start the container, map some device there under the directory from this loop-device.  Everything works fine and due to the features of Docker, that every directory, every file that he tries to put inside himself, he goes through the entire chain of mount points and drags the entire proc / mount, which he now needs to run in that state. about which you speak to it, all proc / mount drags behind itself. <br><br>  Further, the very essence of the problem, I think, for everyone it becomes clear and obvious that we want to unmount this loop-device so that we don‚Äôt have 12-20-50 on the machine, we don‚Äôt need the old weekly code.  And what do we get here?  We get a situation where we have a process holding a block device, and we cannot unmount it.  To do this, we need to go, go into the container and try to unmount it there.  But since  we start the container in the ‚Äúno privileges‚Äù mode, we cannot make umount from the host system there. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8a2/d49/bd7/8a2d49bd755ce70b51e0e04e63f91d2a.png"><br><br>  And we have a rather interesting problem, which suggests that with the container we can only do a restart.  This is not a solution, it is really a big problem, in principle, the solution of which may not be a technical one, but in the form of some kind of agreements within the organization. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/106/ab2/007/106ab2007fda71f5e669273eb8f54c90.png"><br><br>  Accordingly, the first solution that can come up, it basically works - it is to take and run the container in privileged mode.  We do not do that. <br><br>  The second is to sit down and think, with different departments, with programmers, with the release team, with someone else about what and how we can do to prevent us from arranging these dynamic mount points, let us somehow refuse them. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ed/6d6/232/7ed6d62321f7dd1b3208576c8a07f3a3.png"><br><br>  Those.  This is one of those cases when you just need to sit down and think about what is possible to do.  Any structural internal arrangements and changes that will solve this problem.  Those.  It did not make sense to fight about the problem from the technical position.  In the case of Docker containers, we simply stopped using such dynamic loop devices. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/249/e45/30a/249e4530a4816ea491c6c242e47c3f68.png"><br><br>  The following interesting rakes are related to iptables, with nf_conntrack.  What does Docker give us when we read about it?  He says that we can run as many containers as we want, we can use a huge number of ports, we can arrange connections between containers inside, we get some kind of isolation.  Everyone says that it will be, of course, through iptables, there are such rules that you can register if you forgot to specify them at the start in the container.  But no one speaks explicitly about one thing - that in this case we are obliged to use the linux module nf_conntrack, which I myself would not call fast. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/308/691/afc/308691afcf8b351707a0a621ea7ebd01.png"><br><br>  There are two ways in which we can solve this problem. <br><br>  The first way, if your application is not very loaded on the network, it is to live as it is.  Everything is fine, everything works, until you hit the nf_conntrack table overflow.  What can we do to prolong our life?  Enlarge the nf_conntrack table. <br><br>  Further, this is such a causal link - if we increase the conntrack table itself, then we must increase the hash table of connections so that there are more of them than they are by default in the Linux kernel. <br><br>  It is worth remembering about the third item, which by default in Linux stores about 10 minutes, all connections are established, already worked out.  In fact, for modern service, I think that more than 30 seconds.  after creating a connection, if something did not happen, then either the service is bad or the connection is simply not needed.  Therefore, 10 minutes is a real overkil. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad5/a5a/475/ad5a5a4759c8a37185c30f2c7f4668f4.png"><br><br>  With this approach, as practice has shown, we can sit and wait.  But sooner or later the problem will arise, and it will arise for sure.  And at some point, these increases simply will not help, due to the fact that due to the slow work of conntrack, nothing will be done better. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/060/a69/418/060a6941835a3226c6a8f02a1bdd96d6.png"><br><br>  How did we solve this problem for ourselves?  The first thing I want to say is that we do not use conntrack, we try not to use it in the production environment, in our services.  We use it in the part of the dev, we use it on staging, because there the amount of network exchange is much less. <br><br>  From what I would suggest to look at, this is a wonderful Weave project that allows you to build network interactions bypassing network equipment, i.e.  This is a more software solution between your Docker-hosts.  The simplest solution is to use the default bridge, which, when launched, can generate Docker.  You can also use the built-in Linux bridge configurator.  And if you want beauty and a little more flexibility, there is a great joke - Open vSwitch.  At the moment in the list of plugins for Docker there is no control for Open vSwitch, which is a pity, they promised last year. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/433/12d/a76/43312da76547ecbdc1d9cdad03c2ff2a.png"><br><br>  As I said earlier, for ourselves we decided it in such a way that we practically use the launching of the network device from the host system into the container and we get rid of conntrack when we start all our containers.  I didn‚Äôt put a stamp on the problem that I solved, because this is such a problem that is worth thinking about.  For ourselves, we solved it this way, someone, maybe, will solve it differently. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/049/cb7/429/049cb7429a04549936fbf5069ce280b3.png"><br><br>  The next interesting moment that most of those who had to deal with at least Docker had to deal with was the choice of the Storage Driver in order to store files.  Because everyone has pros, everyone has disadvantages.  There are AuFSs with which they entered the market and offered them, but which never entered the mainline and never will.  There is a cool solution to the problem when you take logical devices, mount them, i.e.  This is a Device Mapper plus some kind of built-in file system, conditionally X3.  You are engaged in this mounting - remounting ... All this grows into such a generally huge chain of these layers and logical devices.  There is BTRFS, which is half the functionality needed for Docker, supports by default precisely as the underlying functionality of the file system.  And there are several other pieces that are implemented by some plugins, some are cool, some are not.  Here I noted the three things that I had to work with, and among which I had to choose. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/270/12e/de5/27012ede59cceef435825aa0c94fae78.png"><br><br>  And we also look at the problems that BTRFS can cause.  BTRFS requires you to keep some kind of block device that will be the rootdir for Docker on BTRFS.  Not every partition partition table on our server contained BTRFS, respectively, this obliged us to deal with the re-release or re-sniping of LWM and highlighting this partition. <br><br>  Secondly, no one hid the fact that BTRFS never makes a resink directly to disk, he never writes directly to a block device, he first keeps some kind of his own journal, writes information to the journal, then the nuclear process of BTRFS itself starts, which looks at this queue makes some gestures and writes something down somewhere.  In practice, according to our measurements, the performance of using BTRFS turned out.  Somewhere we have a block device on the 10th raid, and we got from it somewhere divided in half - this is what BTRFS gave us. <br><br>  A very urgent problem for the monitoring service, the operations department is how to understand how much space is occupied by BTRFS, how much is free?  And the biggest problem is when you have a place, it seems, but there‚Äôs no place like it - it has gone somewhere, and you understand that your meta-date is swollen, files are busy, like, a little, and you need to run rebalance, and you are close to the peak and IO and so suffers, but also rebalance.  Sadness <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b61/91d/743/b6191d743edd771eb00939bdbd7d7a27.png"><br><br>  Of the benefits of BTRFS over the past year or two - this is the only storage driver that is normal and, at least, expectedly worked with Docker.  It seems like the problem was solved, BTRFS is our choice.  Let's buy SSD, we will live, God bless him with performance, let's figure it out. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/470/525/b96/470525b965537e498dcfba90b99fb58c.png"><br><br>  And here not so long ago we looked towards the new Storage Driver - OverlayFS.  Looking ahead, I will say that we are engaged in its implementation, we have already passed the testing stage, we received some tests, the tests are quite good. <br><br>  Why did I leave the FS gray and Overlay reddish it?  Since version 3.18, it entered the kernel under a different name, it entered the kernel under the module name just Overlay.  Does anyone know what the OverlayFS module is built into for a long time already in the core?  I do not know either.  There will be no new slides about Overlay, I will tell you the information that was ready just last week.  According to our tests, the speed of response using OverlayFS based on EX4, in percentage terms, we have Docker overhead within an error of up to 3-5%, not more, i.e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for ourselves, we consider it the next point and the next point where we will begin to migrate and do. The only minus that it imposes on itself is, again, the kernel 3.18, at least, i.e. need to be updated, we must go ahead.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Overlay FS works relative to BTRFS in order to arrange these read-only layers, it uses hard links. There is one more plus in comparison with BTRFS, which is that your operating system can use the file cache in RAM. But if you use BTRFS, because there are subvolums and even if the file is, like, deduplicated, and, like, you understand that the file is one file, from the Linux OS point of view, the file is different. And if from the same container and from the other container we request the same file, it seems, it will most likely not remain in the cache or two different caches will appear for this file. Overlay saves us from this. As I said, performance is obtained in read / write very similar to the capabilities of the native file system, why not? And for exploitation,and for monitoring, and for all the old DF continues to work. We know how much we have there, how much is free. Cool.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there is no this puzzle, no rebalance is needed, great! I believe that this is our future solution to the problem and those who have not tried it, I urge you to at least just look at this driver. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/587/b6a/42a/587b6a42ae2eb0400a4e30b03d9fb7c7.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further generalized non-highlighted problems encountered. They consist in the fact that we have moved away from the idea that only one service or one service can be launched in one container. But then the question arose of choosing how to run more than one, i.e. there is a cmd, but what levers do we still have to run something else? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first thing we decided was to write a crutch for the Entrypoint, where we start up some crowns, etc., prepare our container before launching, start some background services and then transfer control to the Docker cmd instruction and start our basic service.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad5/021/25e/ad502125e68bacc6b494d42c9757a33a.png"><br><br>  Since<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it all looked like some kind of crutch, and it was scary to support him, and every entry from the operation team wrote an entrypoint on their own ‚Äî they were very different depending on their mood. It was necessary to look for some more unified approach. And from what we saw, the choice fell on the S6, and we are using it now. I left the coordinates of the project, this is a kind of init-manager to work inside the Docker-containers. It allows all the basic things that, at a minimum, we need, i.e. It allows you to start, make a stop. Depending on the stop, you can complete the container or not, you can execute some set of commands before starting the container and before stopping it. Everything is pretty good. For those who are interested in the tasks and problems of running more than one service in a container, I recommend looking at this.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such a semi-problem, half-no, and the question also arises - is it possible to use several From in Dockerfile. </font><font style="vertical-align: inherit;">The answer to this question during the year changed three times.</font></font> Moreover, dramatically.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, no, no, yes - depending on the Docker version. </font><font style="vertical-align: inherit;">In our experience, I can say that you can use it until the first problem, when you have a hierarchy of layers of one image that does not intersect with the hierarchy of another, and you suddenly lose some file.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you will think that he is there, and he is not there. </font><font style="vertical-align: inherit;">And you will lose some amount of time in search of why he is not there, and he should be.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I would recommend not to use. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another interesting problem that we have recently encountered is that we recently learned about it. This is such a cool feature in Docker from version 1.6, in my opinion. They took and did the docker.exec command where you can take and execute something, unload the container from the host system, and look at the result. Everything is cool, but not so long ago it turned out that this exec was made, in general, for debugging, development-mode, i.e. he didn‚Äôt assume that you could run some monitoring things from the host system that find there worked something like that, looked for it, cut it. And the problem was that in Docker inspect, if you look at the name-space of a specific container, all the execs, all their urls, by which you could look at their result, they lived as long as you the container will not reload. Starting from 1.7, or rather from version 1.8, they made some garbage collector, which looks in the old manner, if there are dead dead unnecessary execs, and cleans them. This was a really big problem, because if you look at memory consumption, over the course of days, weeks, the memory just grew and grew, it is not clear why.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/737/2a8/d2b/7372a8d2b1b401b23adc2c66d3fad803.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">General advice, if you have any problem, try to ask somewhere and look for a solution to this problem, because the Docker, by itself, is developing very quickly, and there a lot of things change. It happens when you try to decide what others have already decided a week ago or in a previous release, or simply something else did not enter the master. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f2/814/e05/0f2814e05d16426cc7b03f1e56742a21.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main point in our company is the basic image, against which we are rolling out our application with some instructions. Accordingly, it is not just a problem area for us, but it is the only point in all of this containerization that it makes sense to follow.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/40d/fca/498/40dfca4983901a132cb083204a3a9b0e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How are we following her right now? We need to check that all the packages, necessary patch sets for our basic image are present, so that we don‚Äôt roll out a well-known hole, for example, to production. How do we solve this problem? We take on some crown or launch our container interactively for some time and, using zypper or what else we can think of for some other OS, we simply check for any updates on all our repositories. and, if they are, we pass this information in the form of a ticket to the team of service operators, who decide whether to update it further or not. If you update, we update the base image and roll it out to where we are building. If there is a need, and some serious patch, we need a fix, we go, we update the container we need.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/932/a2b/f08/932a2bf089fb5d0265e624d3c3de7acf.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And before we, in general, roll our application to production, we make a comparison of our, let's say, the current RPM-list of packages and their versions, which should be with what is present in our newly created container. </font><font style="vertical-align: inherit;">If something does not converge, we go back to the branch at the time of assembly, testing, etc.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">until we get here the conformity of the fact that we agree with such a set of production versions, we accept it. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/20d/659/e23/20d659e23df95aa08c5ef5c79abf2ddc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to somehow assemble our applications, it is clear that we will not write with our hands every time and change the Dockerfile version of our basic image. </font><font style="vertical-align: inherit;">We need some kind of automation. </font><font style="vertical-align: inherit;">We made this automatics by resorting to the use of puppet. </font><font style="vertical-align: inherit;">We called it just docker_build.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/342/057/4b5/3420574b51ba04ca961cbc8780fde19b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What requirements did we put on our automation? We wanted to generate a directory and configs structure for a particular service. We wanted to teach and taught him to do the Dockerfile instruction automatically. We wanted to deliver / pull out the executable files of the application itself from our systems, assemblies of our services, and put them side by side. We wanted, of course, that he perform the assembly. Send the result to the Registry, and with the ability to either send or not send, because there something may go wrong, we just wanted to locally see what it will collect there. And the necessary functionality was that we wanted to allow the one who collects the container to do it by hand.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f87/a9f/bee/f87a9fbee62904afde8e35d62e7787b5.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Services we roll out as follows. The JIRA receives the problem that our developers have decided that they have assembled a new version, and they want it for production. They set us the task. The container is automatically collected at that time, he says that the status is ‚Äúcollected‚Äù, everything is fine. In this interface, we have the functionality, if we changed some configs in puppet, we want to rebuild.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if we need a container, not the one that we collected, sent, and with other config'ami, we can do it here. The next, second step (on the slide) is to make sure that the reassembly team is sent, and if everything went well, we get some success with the address and link of our new container in the registry, from where we can pick it up. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c78/f43/1ad/c78f431ad5cbc0632904ee4a9eb51ba8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docker host and container running on it, there is a need to monitor. To solve this problem, we in this case wrote down the first bike, which is the image of the container on each docker host in which we collect some information. The general scheme is as follows; we collect information on the container, send it to Graphite once in a while, and there we draw a beautiful interface.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/df0/f02/241/df0f022416995ece31f78c98297ffef0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What does this monitoring container look like? We have a Docker CLI inside, because we need to collect statistics through docker stats, on the CPU and on memory for each container. And we default on our SAR servers and run our monitoring container. We diru SAR'om pull up. Once in a while, our docker monitoring container starts a stat aggregator, which needs to be sent to Graphite. Sticks her there. Couldn't send? Next pass. He will check if there were any impressions on the FS, will send the second run. Then we draw it on Graphite. The container itself, that it is running, that it, in general, is on the Docker host, we monitor with Zabbix.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3d/228/535/b3d228535c1362e0a05c1775faea6802.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, the graphs are approximately as follows. There are many of them, they are not very readable, but, I think, the graphs saw everything. This is how we see information on the memory host, we can look at each container and information, in general, about the host on the CPU. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d7/33f/b54/6d733fb5401a6511f5e69aff6c74c214.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can watch the use of the network, etc ... </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb0/207/196/cb0207196971162f2d9d3f4c84b82945.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On this slide, the picture is already about what is happening with the container itself, getting rid of the host itself. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/54f/615/f61/54f615f613c0a68f1b70ccd359d90f11.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same can be said about the CPU.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b7e/ca8/3aa/b7eca83aa02e1e9798b8a4d3ced0879f.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the last moment I would like to touch on is the invention of another bicycle for orchestration, for managing our containers, because, choosing, we did not choose any of the ready-made solutions. </font><font style="vertical-align: inherit;">I will not dwell on the decisions that we have considered, if it is interesting to someone, it will ask later. </font><font style="vertical-align: inherit;">I will say which set of requirements we expressed to our baDocker in order to start developing it.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a0/e54/9b2/7a0e549b20b2651da89b71a26b2fd8f3.png"><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first thing I didn‚Äôt like when we looked at ready-made solutions was the presence of another container that needs to be run on each host </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that will collect something there and manage it. </font><font style="vertical-align: inherit;">The first trick is Clientless. </font><font style="vertical-align: inherit;">We do not need any client, we have a Docker API, why </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do we need something else?</font></font><br></li><li>    Registry   ‚Äì   .          1  2,     Registry.  AND <br>      Docker,    Registry v2. <br></li><li>  ,    -   ,   (     ).  ,    ,  <br> . <br></li><li>      ,    -    ,  ¬´   ,   ,  <br>    ,   ¬ª.     ,    . <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the last thing I would like to see is the Dashboard, which says that "you have so many hosts, there are possible problems there, impossible there, if </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necessary, go see."</font></font><br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/706/7ba/75b/7067ba75b73689edefd78b39a0195fe1.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> At the current time, it looks something like this. </font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we can see Summary for our hosts, for each site, how much memory is there, how much is occupied, how many containers are there, how much is stalled, how many works. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c72/2cb/4ff/c722cb4ff39cc74fc24564fc98598d02.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can go in and see in detail which containers, from which images we are running. We can also tick, see which version a particular service works for us. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/18b/7b4/cea/18b7b4ceacfff16df3881df9e22f0074.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can go from this interface to any container, write something there, get some kind of output, for example, ‚Äúdo not connect anywhere through the shell‚Äù ... </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c06/282/3d1/c062823d15dd8edd4c5cef191f917a72.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In our services we can see what types of this service are, what versions there are, on which servers are running one or another version of this service.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f6/267/f0c/1f6267f0c97bbf600d2ba8b4c43a817e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And we can use such hints in the form of templates, how can we launch the container for this service, i.e. </font><font style="vertical-align: inherit;">we click on the type we need and see - here‚Äôs a hint: ‚Äúgo, run like this, if you need to do it with your hands‚Äù. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca9/530/79a/ca953079a884c8c78520550729f67967.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In conclusion, I would like to say the following: using any tool, in this case Docker, I would recommend using a certain approach, look at the box outside the box on some things and, while doing this, take into account the problems of other people who solved these problems or advise how they decide. </font><font style="vertical-align: inherit;">And, of course, I wanted to say that reinventing bicycles is not a shame, it is cool and interesting, if only the wheels are not square on your bicycle.</font></font><br><br><h3>  Contacts </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ª </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A.turetsky@corp.badoo.com</font></font></a> <br>  <a href="https://twitter.com/tyrchenok">Twitter</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ª </font></font><a href="https://habrahabr.ru/company/badoo/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Badoo company blog</font></font></a> <br><br><blockquote> <font color="gray">  ‚Äî           <a href="http://highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad++</a> .      2016  ‚Äî    HighLoad++   , 7  8 . <br><br>  HighLoad++ 2016     DevOps,      docker',    : <br></font> <ul><li> <a href="http://www.highload.ru/2016/abstracts/2264.html">5   PHP-   </a> /  ; </li><li> <a href="http://www.highload.ru/2016/abstracts/2275.html">Aviasales:     docker</a> /  ; </li><li> <a href="http://www.highload.ru/2016/abstracts/2397.html"> Docker-   </a> /   </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, some of these materials are used by us in an online training course on the development of high-load systems </font></font><a href="http://highload.guide/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HighLoad.Guide</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a chain of specially selected letters, articles, materials, videos. </font><font style="vertical-align: inherit;">Already, in our textbook more than 30 unique materials. </font><font style="vertical-align: inherit;">Get connected!</font></font><br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/311830/">https://habr.com/ru/post/311830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311818/index.html">Barrier control with Arduino UNO and 433 MHz radio transmitter</a></li>
<li><a href="../311820/index.html">Meet the dictator! Small and kind</a></li>
<li><a href="../311822/index.html">Universal data management system based on scaffolding technology and the .NET Core platform</a></li>
<li><a href="../311824/index.html">Founder's advice. Evgeny Luchinin, Lokals</a></li>
<li><a href="../311826/index.html">Errors in the project of the data center that you feel only during the operation phase</a></li>
<li><a href="../311832/index.html">How to become a super-mega-pro machine learning in 15 minutes</a></li>
<li><a href="../311834/index.html">CompTIA certifications for IT professionals. Part 3 of 7. CompTIA Cloud +</a></li>
<li><a href="../311836/index.html">Creating plugins for vSphere using HTML Client SDK Fling</a></li>
<li><a href="../311838/index.html">Buttons in interface design: style evolution and recommendations</a></li>
<li><a href="../311842/index.html">Google fixed Android vulnerabilities</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>