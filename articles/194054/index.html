<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Another article about caching web traffic</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction, or why another WCCP article? 
 Much has been written about organizing transparent caching of web traffic using the WCCP protocol, includ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Another article about caching web traffic</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction, or why another WCCP article? </h4><br>  Much has been written about organizing transparent caching of web traffic using the WCCP protocol, including a good article on <a href="http://habrahabr.ru/post/150221/">Habr√©</a> .  Usually in these articles a scheme similar to that shown in the figure to the left is considered. <br><br><img src="https://habrastorage.org/storage3/41e/d31/469/41ed314693c8b6bb900ed452e3cd240c.png"><br><br>  At first glance, the solution has solid advantages: the implementation is simple, caching is performed completely transparently to users, and if the proxy server fails, requests will automatically be redirected directly. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But does WCCP implementation always go smoothly?  And if not, how to deal with emerging issues? <br><br>  For example, in almost all articles it is mentioned that the caching server must be located in the same segment as the users, but the reasons for this are not specified.  And what if the security policy requires all servers to be in the demilitarized zone and protected by a firewall (ME)? <br><br>  Recently, we had to deal with a similar requirement when installing a caching server in a carrier network, a simplified diagram of which is shown in the title picture on the right. <br><br>  If readers are interested in what problems they encounter when implementing such schemes, and how you can get around the limitations - welcome. <br><a name="habracut"></a><br><h4>  Theory - standards and implementation features </h4><br>  First, a little theory.  <a href="http://en.wikipedia.org/wiki/Web_Cache_Communication_Protocol">WCCP is</a> designed to redirect traffic (not just the web) in real time.  Initially, the protocol was developed by Cisco, then became an open standard used by most vendors. <br><br>  To date, version 2, which is in the status of Internet-Draft and described by the document <a href="http://tools.ietf.org/html/draft-mclaggan-wccp-v2rev1-00">draft-mclaggan-wccp-v2rev1-00, is relevant</a> . <br><br>  Let us dwell on several important points in the operation of this protocol (see figure). <br><br><img src="https://habrastorage.org/storage3/242/04c/963/24204c96316c723411b43fad116c1b89.png"><br><br>  All WCCP messages are UDP packets with a destination port number of 2048. The messaging order is as follows: <br><ol><li>  If the server is ready to handle traffic caching requests, it sends WCCP2_HERE_I_AM messages. </li><li>  The router sends to the server a WCCP2_I_SEE_YOU message containing information about the settings, in particular, the ‚ÄúReceive ID‚Äù field. </li><li>  The server in response sends another WCCP2_HERE_I_AM message, which contains the ‚ÄúReceive ID‚Äù field with the same value as in the previous step, thereby confirming that it is ready to work with the router. </li><li>  The router, having received such a message, understands that from now on, user requests to websites should be redirected to the caching server. </li></ol><br><br>  The system is ready to go.  The WCCP2_HERE_I_AM and WCCP2_I_SEE_YOU messaging process is repeated periodically (by default - once every 10 seconds), and if the router does not receive a response from the caching server, the latter is excluded from the process. <br>  In reality, the protocol is somewhat more complicated, it provides for authentication, various redirection algorithms, etc., but we will deliberately omit details that are not important for further understanding.  Interested readers can find them in the corresponding draft, the link to which is given above. <br><br>  This implementation contributes to the fault tolerance of the solution ‚Äî if the caching server fails and stops sending WCCP2_HERE_I_AM messages, the router stops trying to forward packets and starts sending them to the Internet directly.  After the service is restored, the message exchange process of WCCP2_HERE_I_AM / WCCP2_I_SEE_YOU will repeat and the caching scheme will start working again. <br><br>  For users, such a refusal is either completely imperceptible, or it may look like a one-time ‚ÄúUnable to connect‚Äù message, which will disappear after reloading the page in the browser. <br><br>  In Wireshark, the WCCP messaging process looks like the following figure.  Note the Time column.  The traffic image is taken from a real-life system, therefore IP addresses are shown in a truncated form for security purposes. <br><br><img src="https://habrastorage.org/storage3/74b/d5b/294/74bd5b294b4d5befd221bbdaca585e58.png"><br><br>  Let's see what happens when a client tries to get data from a web server.  For clarity, we will assign specific IP addresses to the hosts using the special ranges <a href="http://tools.ietf.org/html/rfc5737">allocated for use in the examples</a> , and for simplicity, we will exclude from consideration all the extra functionality (NAT, firewalling, etc.). <br><br><img src="https://habrastorage.org/storage3/415/a8b/913/415a8b9135145d7c245ea11224f21f7d.png"><br><ol><li>  The user browser initiates a TCP session by sending a packet with SRC IP 198.51.100.150, DST IP 192.0.2.20, DST TCP port 80, with the TCP SYN flag. </li><li>  The router, having received such a packet, does not send it further to the Internet, but packs it entirely into a GRE packet and sends it to the caching server.  The GRE package has SRC IP 192.51.100.1 and DST IP 198.51.100.100, respectively.  In Wireshark, it looks like the following figure. <br><img src="https://habrastorage.org/storage3/365/72c/19b/36572c19b16314e23c3e355bc1d7d62b.png"></li><li>  The caching server, upon receiving such a packet, first of all decides whether it will process this packet.  If not, the packet is sent back to the router for normal forwarding through the same GRE tunnel, and the algorithm ends.  If so, the server proceeds to the next step. </li><li>  The cache server on its own behalf establishes a connection with the web server, for which it sends a packet with SRC IP 198.51.100.100, DST IP 192.0.2.20, DST TCP port 80, with the TCP SYN flag. </li><li>  In response, the web server sends a packet with SRC IP 192.0.2.20, SRC TCP port 80, DST IP 198.51.100.100, TCP SYN / ACK flags, i.e., so far everything goes according to the usual beginning of a TCP session using the three- way handshake. </li><li>  The caching server, after receiving a response from the web server, does two things: <br><ul><li>  sends to the web server a packet with SRC IP 198.51.100.100, DST IP 192.0.2.20, DST TCP port 80, ACK flag, i.e., it continues normal TCP session, which looks to the web server as if it were normal client with IP address 198.51.100.100. <br></li><li>  sends to the web client a packet with SRC IP 192.0.2.20, SRC TCP port 80, DST IP 198.51.100.150, TCP SYN / ACK flags, i.e. the situation for the client looks as if the web server responded directly to it.  Remember this moment, it is key to further understanding. </li></ul><br></li><li>  So, we have two established TCP sessions, one between the client and the caching server, the other between the caching server and the web server.  The caching server receives the content from the web server in the usual way, transmits it to the client, simultaneously storing it in memory or (and) on disk. <br>  Upon subsequent access to the same content, the caching server, under certain conditions, will not be able to download it again to the web server, but give it to the web client on its own. <br></li></ol><br><br>  The described algorithm is shown schematically in the figure. <br><br><img src="https://habrastorage.org/storage3/5c1/451/527/5c145152718542ed384b972f1d2bbc81.png"><br><br>  Pay attention to several important points: <br><ol><li>  Packets within the GRE tunnel are sent primarily from the router to the cache server (except when the cache server cannot process the packet, and sends it back to the router for normal forwarding). </li><li>  In the opposite direction, that is, from the caching server to the web client, the packets are sent directly, bypassing the router altogether. </li><li>  The caching server sets for packages in the direction of the web client not its address, but the address of the website to which the request was made. </li></ol><br><br>  This implementation of the protocol significantly reduces the load on the router, since it only has to redirect traffic from the web client to the web server, which is usually small.  Traffic from a web server, which is usually quite large, is not subjected to any complicated processing ‚Äî it is simply routed. <br><br>  But such an implementation creates asymmetric traffic, which, in turn, generates the difficulties discussed in the next section. <br><br><h4>  Practice - fighting routers and firewalls </h4><br>  Modifying the previous scheme - let's place the caching server behind the firewall: <br><br><img src="https://habrastorage.org/storage3/b1a/496/e1f/b1a496e1f058d4e7fc0a89296acfa8fc.png"><br><br>  We will assume that we use popular hardware ‚Äî a Cisco router with Cisco IOS software version 12.3 and higher, a Cisco ASA firewall with software version 8.2 and higher, a Linux-based caching server (RHEL or CentOS distribution), and Squid caching software. <br>  How in this case to set everything up?  Suppose that the basic functionality is already configured, that is, the web client and the caching server are able to access resources on the Internet.  We start by setting up WCCP on Cisco. <br><br>  We will carry out the preparatory work, for which we will create two access lists: <br><br><pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">ip</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">access-list</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">standard</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">l_wccp_service</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">permit</span></span> 203<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.113</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.100</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ip</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">access-list</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">extended</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">l_wccp_redirect</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">permit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tcp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">host</span></span> 198<span class="hljs-selector-class"><span class="hljs-selector-class">.51</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.100</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.150</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">any</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">www</span></span></code> </pre> <br><br>  The first determines which caching servers are allowed to receive WCCP2_HERE_I_AM messages. <br>  The second determines what traffic needs to be routed to the caching server. <br><br>  Configure WCCP and enable it on the interface, looking in the direction of internal users, ie, having the address 198.51.100.1.  For definiteness, let it be FastEthernet0 / 0): <br><br><pre> <code class="hljs sql">ip wccp web-<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span> redirect-<span class="hljs-keyword"><span class="hljs-keyword">list</span></span> l_wccp_redirect <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">list</span></span> l_wccp_service <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> FastEthernet0/<span class="hljs-number"><span class="hljs-number">0</span></span> ip wccp web-<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span> redirect <span class="hljs-keyword"><span class="hljs-keyword">in</span></span></code> </pre><br><br>  On the firewall, we allow the exchange of WCCP and GRE packets between the router and the cache server. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">access-list</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">l_wccp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">extended</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">permit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">gre</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">host</span></span> 198<span class="hljs-selector-class"><span class="hljs-selector-class">.51</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.100</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">host</span></span> 203<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.113</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.100</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">access-list</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">l_wccp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">extended</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">permit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">udp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">host</span></span> 198<span class="hljs-selector-class"><span class="hljs-selector-class">.51</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.100</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">host</span></span> 203<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.113</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.100</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">access-group</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">l_wccp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">interface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">outside</span></span></code> </pre><br><br>  Now configure the caching server.  First, install and configure squid, for which, using your favorite text editor, open the /etc/squid/squid.conf file and make sure that it contains the following lines: <br><br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta"># /etc/squid/squid.conf http_port 3128 transparent wccp2_router 198.51.100.1 wccp2_forwarding_method 1 wccp2_return_method 1 wccp2_assignment_method hash wccp2_service standard 0</span></span></code> </pre><br><br>  Let's create a tunnel interface, for which, again in our favorite editor, create the file / etc / sysconfig / network-scripts / ifcfg-tun0 with the following contents: <br><br><pre> <code class="hljs pgsql"># /etc/sysconfig/network-scripts/ifcfg-tun0 DEVICE=tun0 BOOTPROTO=<span class="hljs-keyword"><span class="hljs-keyword">none</span></span> ONBOOT=yes <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span>=GRE PEER_OUTER_IPADDR=<span class="hljs-number"><span class="hljs-number">198.51</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> PEER_INNER_IPADDR=<span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.168</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> MY_INNER_IPADDR=<span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.168</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span></code> </pre><br><br>  The PEER_INNER_IPADDR and MY_INNER_IPADDR IP addresses can be absolutely any ‚Äî nothing will be routed through this tunnel in the normal way.  Instead, all incoming TCP traffic from DST port 80 will be wrapped on squid using iptables.  Assuming that squid is responding on port 3128, we will raise the tunnel interface and wrap the necessary traffic on squid: <br><br><pre> <code class="hljs swift">/etc/sysconfig/network-scripts/ifup tun0 iptables -t nat -<span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-type"><span class="hljs-type">PREROUTING</span></span> -i tun0 -p tcp -m tcp --dport <span class="hljs-number"><span class="hljs-number">80</span></span> -j <span class="hljs-type"><span class="hljs-type">DNAT</span></span> --to-destination <span class="hljs-number"><span class="hljs-number">203.0</span></span>.<span class="hljs-number"><span class="hljs-number">113.100</span></span>:<span class="hljs-number"><span class="hljs-number">3128</span></span> /etc/<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>.d/iptables save</code> </pre><br><br>  Check that the caching server is registered on the router: <br><br><pre> <code class="hljs pgsql">cisco# <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> ip wccp <span class="hljs-keyword"><span class="hljs-keyword">Global</span></span> WCCP information: Router information: Router Identifier: <span class="hljs-number"><span class="hljs-number">198.51</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">Version</span></span>: <span class="hljs-number"><span class="hljs-number">2.0</span></span> Service Identifier: web-<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span> Number of Service Group Clients: <span class="hljs-number"><span class="hljs-number">1</span></span> Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Service <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Routers: <span class="hljs-number"><span class="hljs-number">1</span></span> Total Packets s/w Redirected: <span class="hljs-number"><span class="hljs-number">175623</span></span> Process: <span class="hljs-number"><span class="hljs-number">0</span></span> Fast: <span class="hljs-number"><span class="hljs-number">0</span></span> CEF: <span class="hljs-number"><span class="hljs-number">175623</span></span> Redirect <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-list: l_wccp_redirect Total Packets Denied Redirect: <span class="hljs-number"><span class="hljs-number">113892411</span></span> Total Packets Unassigned: <span class="hljs-number"><span class="hljs-number">20590</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-list: l_wccp_service Total Messages Denied <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span>: <span class="hljs-number"><span class="hljs-number">26558</span></span> Total Authentication failures: <span class="hljs-number"><span class="hljs-number">0</span></span> Total Bypassed Packets Received: <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><br>  Here we can expect an unpleasant ambush: the router usually has several interfaces with different IP addresses.  And nothing prevents him from sending WCCP2_I_SEE_YOU packets from the SRC IP of one interface, and GRE packets from the SRC IP of another interface. <br>  Some, but not all, firmware versions of Cisco IOS routers have a ‚Äúip wccp source-interface‚Äù command that allows you to hard-code an interface whose IP address will be used as the SRC IP for all packets related to the WCCP subsystem . <br><br>  If your router supports this command, you're in luck.  Run it: <br><br><pre> <code class="hljs kotlin">ip wccp source-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FastEthernet</span></span></span><span class="hljs-class"> 0/0</span></span></code> </pre><br><br>  If, in response to such a command, the router issues something like ‚ÄúSyntax error‚Äù, we proceed as follows - we run diagnostics on the ME, and on the caching server some kind of network analyzer (at least tcpdump) and find out which IP addresses come from WCCP packets, and with what ‚Äî GRE packets. <br><br>  Next, in the squid settings, we register the first IP address, in the settings of the tunnel interface and iptables - the second one.  We modify accordingly the access lists on the ME. <br><br>  To prevent the IP address from which WCCP packets come from between the interfaces during subsequent reconfiguration of the router, you can create a loopback interface on the last one.  In this case, WCCP will use the largest IP address among all loopback interfaces to send its packets. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">interface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lo0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ip</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">address</span></span> 198<span class="hljs-selector-class"><span class="hljs-selector-class">.51</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.100</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.20</span></span> 255<span class="hljs-selector-class"><span class="hljs-selector-class">.255</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.255</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.255</span></span></code> </pre><br><br>  Check that the redirect works.  First, make sure that the package counters in the access lists created earlier grow: <br><br><pre> <code class="hljs pgsql">cisco# <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-list l_wccp_redirect Extended IP <span class="hljs-keyword"><span class="hljs-keyword">access</span></span> list l_wccp_redirect <span class="hljs-number"><span class="hljs-number">10</span></span> permit tcp host <span class="hljs-number"><span class="hljs-number">198.51</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span><span class="hljs-number"><span class="hljs-number">.150</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> eq www (<span class="hljs-number"><span class="hljs-number">2399</span></span> matches)</code> </pre><br><br>  Then open an arbitrary web page in the browser of the client machine.  And surely we will not succeed.  When trying to figure it out, we will surely find messages in the firewall logs of the following form: <br><br><pre> <code class="hljs pgsql">%ASA<span class="hljs-number"><span class="hljs-number">-4</span></span><span class="hljs-number"><span class="hljs-number">-313004</span></span>: Denied ICMP <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-number"><span class="hljs-number">192.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> interface dmz <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">198.51</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span><span class="hljs-number"><span class="hljs-number">.150</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> matching <span class="hljs-keyword"><span class="hljs-keyword">session</span></span></code> </pre><br><br>  If we try to google it, the first link will tell us something about asymmetric routing.  We will understand what this means. <br>  The Cisco ASA Firewall is a device running in <a href="http://en.wikipedia.org/wiki/Stateful_firewall">Stateful Inspection</a> mode, i.e., in order to pass a packet with TCP SYN / ACK flags from the caching server to the client, it is necessary that the corresponding packet with the TCP SYN flag from the client went to the website in the forward direction through the same ME. <br><br>  In this case, the DOE will understand that the client has initiated a TCP session, will create appropriate internal structures and will begin to correctly monitor the status of this TCP session. <br><br>  In our scheme, the initiating SYN packet passes through ME a) inside the GRE tunnel and b) ‚Äúin the wrong direction‚Äù. <br>  Accordingly, the ME does not start a TCP session in its table of connections and cannot understand that the session has started and its packets must be skipped. <br><br>  What to do in this situation?  If you can‚Äôt connect the caching server bypassing MEs, all that remains is to disable the check for an open TCP session for packets coming from the DMZ. <br><br>  In Cisco ASA, the disable check feature is called <a href="http://www.cisco.com/en/US/products/ps6120/products_configuration_example09186a0080b2d922.shtml">TCP bypass</a> .  The function has limitations: <br><br><ol><li>  Does not work on Cisco ASA with software version younger than 8.2. </li><li>  Unknown (at least, we were not able to find) a way to organize both the client zone and the DMZ on the same ME model of the Cisco ASA at the same time ‚Äî predictably, IP address translation does not work. </li></ol><br><br>  So, turn on the TCP bypass function: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-list l_bypass extended permit tcp <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> eq www host <span class="hljs-number"><span class="hljs-number">198.51</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span><span class="hljs-number"><span class="hljs-number">.150</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>-map c_bypass match <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-list l_bypass <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span>-map p_bypass <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> c_bypass <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection</span></span> advanced-<span class="hljs-keyword"><span class="hljs-keyword">options</span></span> tcp-state-bypass service-<span class="hljs-keyword"><span class="hljs-keyword">policy</span></span> p_bypass interface dmz</code> </pre><br><br>  You must put a range of client IP addresses in the l_bypass access list. <br><br>  Now everything should work.  At least it worked for us. <br><br><h4>  Conclusion </h4><br>  The article is based on the experience of introducing the function of caching web traffic in a small carrier network, and once again illustrates two old principles in the work of a network engineer: <br><ul><li>  Do not neglect the standards and descriptions of the protocol; </li><li>  you do not understand what is happening - do not be lazy, connect the network analyzer. </li></ul><br><br>  Happy testing and implementation!  And let now and always your channels transport as little extra traffic as possible. </div><p>Source: <a href="https://habr.com/ru/post/194054/">https://habr.com/ru/post/194054/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../194044/index.html">Do not miss! Today, September 17th. Webinar "Software Testing with Visual Studio and Windows Azure"</a></li>
<li><a href="../194046/index.html">In the Tor Bundle found a vulnerability that allows to de-anonymize users, which was used by FBI agents</a></li>
<li><a href="../194048/index.html">Overview of task management software in Outlook</a></li>
<li><a href="../194050/index.html">How Google Adwords considers cost per click, and how to reduce it</a></li>
<li><a href="../194052/index.html">Paypal. Have waited</a></li>
<li><a href="../194056/index.html">Connecting SlidingMenu to the Support Library and avoiding potential problems</a></li>
<li><a href="../194058/index.html">Transmitting "hidden" radio signal</a></li>
<li><a href="../194062/index.html">Flask Mega-Tutorial, Part 3: Forms</a></li>
<li><a href="../194064/index.html">3D printing of human organs</a></li>
<li><a href="../194068/index.html">Tradinno: the world's largest walking robot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>