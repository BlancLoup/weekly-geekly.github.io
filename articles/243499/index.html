<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Electronic Cake in your pocket: development diary</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About a year ago, when I was playing with the official Arduino Starter Kit , I had the idea to make a ‚Äúcircuit cake‚Äù as a gift for my wife, namely, a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Electronic Cake in your pocket: development diary</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2aa/ef1/4ee/2aaef14eee265914d196ce6bdb2a33b8.jpg" alt="electronic cake in the autumn range"></div><br>  About a year ago, when I was playing with the official <b>Arduino Starter Kit</b> , I had the idea to make a ‚Äúcircuit cake‚Äù as a gift for my wife, namely, a board with LED candles that can be blown out.  This task seemed to me a good educational project for understanding how to program microcontrollers and how to implement programs into matter (after all, I began to get involved in electronics relatively recently, and started programming at school, so I felt a huge gap in my education). <br><br>  I would like to share my experience of developing such a simple device from scratch, and at the same time lay out its scheme and program, so that you can reproduce it at home. <br><a name="habracut"></a><br><h1>  Story </h1><br>  The first prototype was made on <b>Arduino Uno</b> and the piezo element attached to it as a candle blowing detector: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/fa0/edb/02bfa0edb6ba58042b92447d7354b940.jpg" alt="prototype electronic cake on Arduino Uno"></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Reading the voltage on the piezo-element, the device was expecting the slightest change in readings.  But even at the maximum resolution of the ADC, it was necessary to blow very well so that the candles began to fade.  But they were extinguished well: at first they began to flicker with a different frequency and phase, and then in turn they were extinguished depending on the given random lifetime of each candle. <br><br>  The next step I decided to make the cake more elegantly than a board with protruding wires.  And I also wanted to show my wife that the cake works from a small microcontroller.  Somewhere on the Internet, I found an article that the <b>Arduino</b> can be run on an <b>ATTiny85</b> controller, I decided to use it as a brain.  The problem was that this controller has only five general purpose legs that could be used for candles and a sensor, so it turned out that I could only use four candles if I put each LED on a separate leg.  I did not know about charliplexing at that time, and decided to duplicate the candles with a delay circuit on the inverter: when the LEDs are flashing, it is unlikely that anyone will notice that they are duplicated with a phase delay.  In addition, the additional elements fit well into the circular pattern of placement of candles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33d/bba/0ef/33dbba0efb6e37dd60ea85738541eb9f.jpg" alt="prototype electronic cake on ATTiny85 with delay circuit"></div><br><br>  I used four AAA batteries as power, which disrupted the brevity of the appearance.  In addition, I wanted more honest candles and greater sensitivity.  I rustled according to the specifications of the <b>ATTiny</b> series <b>microcontrollers</b> , and found an excellent analogue - <b>ATTiny84</b> with 11 common legs of general purpose.  In addition, it has an ADC input with a differential amplifier 20 times!  So a new prototype appeared: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60b/6c6/42f/60b6c642f398c1679c3e921bdfee420a.jpg" alt="prototype of electronic cake on ATTiny44 with two AA batteries"></div><br><br>  I was hoping to shove two AAA batteries between floors, but miscalculated with the size of the racks and the piezo-element, which should not fit close to the board, so I had to stick the batteries under the board.  As the signal was amplified, the cake became much more sensitive, and noise appeared, so I needed to change the algorithm: I measured the standard deviation of the signal and turned on the blowing logic when this deviation exceeded some empirically found threshold.  The program turned out to be small, less than 4 KB, so I took <b>ATTiny44</b> , which has half the memory. <br><br>  I didn‚Äôt like the power of the circuit and the empty space between the floors, I rummaged about the specifications of the batteries and found that there are AAAA batteries.  They are quite small and provide a current of hundreds of milliamps.  They are difficult to buy, but if you take a type <b>9LR61</b> nine-volt batteries, they inside consist of six AAAA batteries! <br><br>  I also found an interesting <b>HT7750</b> switching power supply <b>microcircuit</b> , which increases the supply voltage to +5 V by increasing the battery current, and decided to make a cake of such a size that one AAAA battery fit diagonally, which will power it.  This is the result of this prototype: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2be/e02/7b1/2bee027b16a7f9e3f466ef62544724a2.jpg" alt="prototype of electronic cake on ATTiny44 with one AAAA battery"></div><br><br>  The use of wide-angle LEDs not only improved the aesthetics of the cake, but also increased the viewing angle.  I ordered the boards in China, which improved the quality of the finished device.  But what I did not expect, so it is a sharp increase in noise when determining blowing.  The fact is that the switching power supply itself is noisy, and here also the dependence of the output voltage on the current when a different number of LEDs is lit.  The old algorithm stopped working, and I had to approach the task more thoroughly: read the readings from the piezo-sensor onto the computer and analyze the amplitude-frequency characteristic of the signal.  I recorded one minute of silence, one minute of blowing and a minute of rustling friction against the hull.  It turned out that the piezo-element has a resonance of about 1 kHz, by which one can quite reliably determine that the candles are now being blown out. <br><br>  So, to determine the moment of blowing out the candles, I began to consider the fast Fourier transform with a Hanning window for a frequency of 1 kHz.  <b>ATTiny44</b> does not have a built-in multiplication command, and the memory is very limited (256 bytes of RAM, 4 KB per program), because all multiplications had to be replaced with shifts and additions, and in general, to significantly optimize the program so that everything fits.  As a result of the program change, the cake exceeded all other prototypes in sensitivity.  Then I began to remove the extra components in the signal path, which I naively considered a high-pass filter, and the cake began to react even better.  Replacing the <b>HT7750</b> with the <b>HT7733</b> , i.e.  replacing the output from +5 V to +3.3 V, I got a more economical use of the battery. <br><br>  The last thing that confused me was that the power supply in off mode consumed approximately 17 ¬µA, which meant emptying the battery in a year.  But I remembered that this microcircuit has one version in the <b>SOT-25</b> package, in which there is a permissive input, and made a small switch-on circuit, which, when the reset button was pressed, charged the capacitor to supply a high level at the permissive chip input with subsequent slow discharge within three minutes through a ten megohm resistor.  After this timeout, the cake is turned off and begins to consume less than 1 ¬µA, which is comparable to the self-discharge current of the battery. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/731/314/747/731314747c8c08f1929b22ed9a29ebce.jpg" alt="electronic cake on the background of the hand to compare sizes"></div><br><br><br><h1>  Schematic diagram </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/d41/9ff/30cd419ff7d511e72e304c4ce11e5bb4.png" alt="concept of cake"></div><br>  <b>The HT7733</b> is a switching power supply that increases the input supply voltage to +3.3 V. The 20-mm piezo element is connected to the differential AD converter of the microcontroller with a gain of 20 times.  Each LED is connected to one leg of the microcontroller. <br><br>  When you press the <b>RESET,</b> a transistor is opened, through which a 10 ŒºF capacitor is charged and a high level is applied to the enable input of the power supply chip.  The microcircuit turns on and starts producing a +3.3 V output for three minutes while the 10 ŒºF capacitor discharges through a ten megohm resistor. <br><br><br><h1>  Program </h1><br><div class="spoiler">  <b class="spoiler_title">C ++ program for Arduino IDE</b> <div class="spoiler_text"><pre><code class="hljs dos">///////////////////////////////////////////////////////////////////////////////////////////////// // BitCake v1.<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span> / November <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">2014</span></span> // by Maksym Ganenko &lt;buratin.barabanus <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> Google Mail&gt; ///////////////////////////////////////////////////////////////////////////////////////////////// #include &lt;avr/interrupt.h&gt; #include &lt;avr/pgmspace.h&gt; #include &lt;avr/power.h&gt; #include &lt;avr/sleep.h&gt; #include &lt;<span class="hljs-built_in"><span class="hljs-built_in">time</span></span>.h&gt; #include &lt;util/delay.h&gt; ///////////////////////////////////////////////////////////////////////////////////////////////// // <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> fixed delta loop <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> milliseconds // <span class="hljs-number"><span class="hljs-number">0</span></span> to use internal timer const uint8_t DELTA_LOOP_TIME_MS = <span class="hljs-number"><span class="hljs-number">14</span></span>; // amplify intermediate values to get better calculation accuracy const uint8_t SAMPLES_GAIN_ORDER = <span class="hljs-number"><span class="hljs-number">5</span></span>; // x32 const uint8_t RESULT_GAIN_ORDER = <span class="hljs-number"><span class="hljs-number">2</span></span>; // x4 // LEDs encoded by ports ID const prog_int8_t LEDS[] PROGMEM = { <span class="hljs-number"><span class="hljs-number">0</span></span>xA6, <span class="hljs-number"><span class="hljs-number">0</span></span>xA7, <span class="hljs-number"><span class="hljs-number">0</span></span>xB2, <span class="hljs-number"><span class="hljs-number">0</span></span>xB1, <span class="hljs-number"><span class="hljs-number">0</span></span>xB0, <span class="hljs-number"><span class="hljs-number">0</span></span>xA2, <span class="hljs-number"><span class="hljs-number">0</span></span>xA3, <span class="hljs-number"><span class="hljs-number">0</span></span>xA4, <span class="hljs-number"><span class="hljs-number">0</span></span>xA5 }; const uint8_t LEDS_NUM = sizeof(LEDS) / sizeof(LEDS[<span class="hljs-number"><span class="hljs-number">0</span></span>]); // ADMUX register code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ADC const uint8_t PIEZO_ADMUX = <span class="hljs-number"><span class="hljs-number">0</span></span>b10101001; // Vref = <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>V, (A1 - A0) x <span class="hljs-number"><span class="hljs-number">20</span></span> // MCU prescaler const uint8_t MCU_PRESCALER = <span class="hljs-number"><span class="hljs-number">0</span></span>b000; // <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> Mhz CPU clock // ADC prescaler const uint8_t ADC_PRESCALER = <span class="hljs-number"><span class="hljs-number">0</span></span>b100; // <span class="hljs-number"><span class="hljs-number">16</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">512</span></span> kHz ADC clock =&gt; <span class="hljs-number"><span class="hljs-number">38</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>k reads per sec // number of piezo reads to average per sample (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> noise reduction) const uint8_t SUBSAMPLE_BUF_ORDER = <span class="hljs-number"><span class="hljs-number">4</span></span>; // =&gt; <span class="hljs-number"><span class="hljs-number">16</span></span> const uint8_t SUBSAMPLE_BUF_SIZE = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; SUBSAMPLE_BUF_ORDER); // FFT samples number - can't be changed without changing FFT calculation code const uint8_t SAMPLE_BUF_ORDER = <span class="hljs-number"><span class="hljs-number">5</span></span>; // =&gt; <span class="hljs-number"><span class="hljs-number">32</span></span> const uint8_t SAMPLE_BUF_SIZE = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; SAMPLE_BUF_ORDER); // FFT signal threshold to activate blowing logic // this value defines the sensitivity of device // depends on electronic components noise const uint8_t BLOWING_THRESHOLD = <span class="hljs-number"><span class="hljs-number">3</span></span>; // timeouts <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> milliseconds const uint32_t SETUP_TIME_MS = <span class="hljs-number"><span class="hljs-number">750</span></span>; // timeout before activating of cake logic const uint32_t DELAY_BLOWING_MS = <span class="hljs-number"><span class="hljs-number">0</span></span>; // delay LEDs flickering when blowing detected const uint32_t PROLONG_BLOWING_MS = <span class="hljs-number"><span class="hljs-number">150</span></span>; // prolong blowing logic when no blowing detected const uint32_t NO_ACTIVITY_MS = <span class="hljs-number"><span class="hljs-number">60000</span></span>; // turn off cake <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> no blowing detected const uint32_t TIME_LIMIT_MS = <span class="hljs-number"><span class="hljs-number">150000</span></span>; // <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> limit <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cake to work // LEDs blinking periods when blowing logic is activated const uint8_t LEDS_PERIOD_MIN_MS = <span class="hljs-number"><span class="hljs-number">100</span></span>; const uint8_t LEDS_PERIOD_MAX_MS = <span class="hljs-number"><span class="hljs-number">150</span></span>; // LEDs <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>-to-live timeouts const uint16_t LEDS_TTL_MIN_MS = <span class="hljs-number"><span class="hljs-number">200</span></span>; const uint16_t LEDS_TTL_MAX_MS = <span class="hljs-number"><span class="hljs-number">1000</span></span>; ///////////////////////////////////////////////////////////////////////////////////////////////// volatile uint8_t samplePos = SAMPLE_BUF_SIZE; // FFT10 specific accumulators int16_t sampleAccA [<span class="hljs-number"><span class="hljs-number">5</span></span>]; int16_t sampleAccB [<span class="hljs-number"><span class="hljs-number">5</span></span>]; // LEDs state variables uint16_t ledsActivity; uint8_t ledsPeriod [LEDS_NUM]; uint8_t ledsPhase [LEDS_NUM]; uint8_t ledsTTL [LEDS_NUM]; // blowing logic state uint8_t blowing = false; uint32_t lastBlowingTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; int16_t totalBlowingTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; uint32_t globalTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; uint32_t lastLoopTime; uint32_t setupPhaseTime; // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> compatibility with other Atmel MCUs uint8_t portA, portB, portC, portD; ///////////////////////////////////////////////////////////////////////////////////////////////// // fast distance approximation uint32_t approxDist(int32_t dx, int32_t dy) { uint32_t min, max; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dx &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) dx = -dx; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dy &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) dy = -dy; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dx &lt; dy) { min = dx; max = dy; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { min = dy; max = dx; } // coefficients equivalent to (<span class="hljs-number"><span class="hljs-number">123</span></span>/<span class="hljs-number"><span class="hljs-number">128</span></span> * max) and (<span class="hljs-number"><span class="hljs-number">51</span></span>/<span class="hljs-number"><span class="hljs-number">128</span></span> * min) return (((max &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + (max &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) - (max &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) - (max &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) + (min &lt;&lt; <span class="hljs-number"><span class="hljs-number">7</span></span>) - (min &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) + (min &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) - (min &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>)) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>); } const uint8_t FFT_DIVIDER_ORDER = <span class="hljs-number"><span class="hljs-number">8</span></span>; // =&gt; <span class="hljs-number"><span class="hljs-number">256</span></span> // approximate multiplication int32_t mul256(int32_t x) { return x &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; } int32_t mul240(int32_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) - (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>); } int32_t mul208(int32_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">7</span></span>) + (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span>) + (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>); } int32_t mul176(int32_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">7</span></span>) + (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) + (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>); } int32_t mul144(int32_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">7</span></span>) + (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>); } int32_t mul96(int32_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span>) + (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); } int32_t mul48(int32_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) + (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>); } typedef int32_t (*fmul32)(int32_t); const fmul32 fmulVec[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { mul96, mul176, mul240, mul256 }; // calculate FFT[<span class="hljs-number"><span class="hljs-number">10</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> samples uint8_t fft10() { int32_t a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint8_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { a += fmulVec[i](sampleAccA[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } int32_t b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint8_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { b += fmulVec[i](sampleAccB[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } uint32_t result = approxDist(a &lt;&lt; RESULT_GAIN_ORDER, b &lt;&lt; RESULT_GAIN_ORDER); result &gt;&gt;= FFT_DIVIDER_ORDER; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>xff) return <span class="hljs-number"><span class="hljs-number">0</span></span>xff; return result; } ///////////////////////////////////////////////////////////////////////////////////////////////// // fft10 specific coefficients const prog_int8_t sampleAccDestA[SAMPLE_BUF_SIZE / <span class="hljs-number"><span class="hljs-number">2</span></span>] PROGMEM = { +<span class="hljs-number"><span class="hljs-number">4</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>, -<span class="hljs-number"><span class="hljs-number">2</span></span>, +<span class="hljs-number"><span class="hljs-number">3</span></span>, +<span class="hljs-number"><span class="hljs-number">0</span></span>, -<span class="hljs-number"><span class="hljs-number">3</span></span>, +<span class="hljs-number"><span class="hljs-number">2</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>, -<span class="hljs-number"><span class="hljs-number">4</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>, +<span class="hljs-number"><span class="hljs-number">2</span></span>, -<span class="hljs-number"><span class="hljs-number">3</span></span>, +<span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">3</span></span>, -<span class="hljs-number"><span class="hljs-number">2</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span> }; const prog_int8_t sampleAccDestB[SAMPLE_BUF_SIZE / <span class="hljs-number"><span class="hljs-number">2</span></span>] PROGMEM = { +<span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">3</span></span>, -<span class="hljs-number"><span class="hljs-number">2</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>, +<span class="hljs-number"><span class="hljs-number">4</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>, -<span class="hljs-number"><span class="hljs-number">2</span></span>, +<span class="hljs-number"><span class="hljs-number">3</span></span>, +<span class="hljs-number"><span class="hljs-number">0</span></span>, -<span class="hljs-number"><span class="hljs-number">3</span></span>, +<span class="hljs-number"><span class="hljs-number">2</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>, -<span class="hljs-number"><span class="hljs-number">4</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>, +<span class="hljs-number"><span class="hljs-number">2</span></span>, -<span class="hljs-number"><span class="hljs-number">3</span></span> }; const uint8_t HANNING_DIVIDER_ORDER = <span class="hljs-number"><span class="hljs-number">6</span></span>; // =&gt; <span class="hljs-number"><span class="hljs-number">64</span></span> // hanning window coefficients int16_t mul0(int16_t x) { return <span class="hljs-number"><span class="hljs-number">0</span></span>; } int16_t mul1(int16_t x) { return x; } int16_t mul3(int16_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) - x; } int16_t mul6(int16_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) - (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>); } int16_t mul10(int16_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) + (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>); } int16_t mul15(int16_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) - x; } int16_t mul21(int16_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) + x; } int16_t mul27(int16_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) - (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) - x; } int16_t mul34(int16_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) + (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>); } int16_t mul40(int16_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) + (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>); } int16_t mul46(int16_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) + (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) - (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>); } int16_t mul52(int16_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span>) - (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) - (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>); } int16_t mul56(int16_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span>) - (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>); } int16_t mul60(int16_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span>) - (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>); } int16_t mul63(int16_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span>) - x; } int16_t mul64(int16_t x) { return (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span>); } // hanning window coefficients typedef int16_t (*fmul16)(int16_t); const fmul16 hanningVec[] = { mul0, mul1, mul3, mul6, mul10, mul15, mul21, mul27, mul34, mul40, mul46, mul52, mul56, mul60, mul63, mul64 }; // ADC interrup routine // we average SUBSAMPLE_BUF_SIZE reads from ADC to reduce noise // and apply the calculated value on fft10 specific accumulators ISR(ADC_vect) { static uint8_t subsampleCtr = <span class="hljs-number"><span class="hljs-number">0</span></span>; static int16_t subsampleSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; // read ADC uint8_t low = ADCL, high = ADCH; int16_t subsample = (high &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | low; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (samplePos &lt; SAMPLE_BUF_SIZE) { subsampleSum += subsample; ++subsampleCtr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (subsampleCtr == SUBSAMPLE_BUF_SIZE) { // average of subsamples int16_t sample = (subsampleSum &gt;&gt; SUBSAMPLE_BUF_ORDER) &lt;&lt; SAMPLES_GAIN_ORDER; uint8_t halfPos = samplePos &amp; (SAMPLE_BUF_SIZE / <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>); uint8_t mulPos = halfPos; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (halfPos != samplePos) { mulPos = SAMPLE_BUF_SIZE / <span class="hljs-number"><span class="hljs-number">2</span></span> - mulPos; } // multiply by hanning window coefficient sample = hanningVec[mulPos](sample) &gt;&gt; HANNING_DIVIDER_ORDER; int8_t destA = pgm_read_byte_near(sampleAccDestA + halfPos); int8_t destB = pgm_read_byte_near(sampleAccDestB + halfPos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destA &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) sampleAccA[destA] += sample; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sampleAccA[-destA] -= sample; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destB &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) sampleAccB[destB] += sample; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sampleAccB[-destB] -= sample; ++samplePos; subsampleSum = subsampleCtr = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } ///////////////////////////////////////////////////////////////////////////////////////////////// void powerDown() { // all pins to low portA = portB = portC = portD = <span class="hljs-number"><span class="hljs-number">0</span></span>; portsUpdateFinish(); // disable ADC ADCSRA &amp;= ~_BV(ADEN); // power down set_sleep_mode(SLEEP_MODE_PWR_DOWN); sleep_mode(); } void portsUpdateStart() { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(PORTA) portA = PORTA; #endif #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(PORTB) portB = PORTB; #endif #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(PORTC) portC = PORTC; #endif #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(PORTD) portD = PORTD; #endif } void portsUpdateFinish() { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(PORTA) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PORTA != portA) { PORTA = portA; } #endif #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(PORTB) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PORTB != portB) { PORTB = portB; } #endif #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(PORTC) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PORTC != portC) { PORTC = portC; } #endif #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(PORTD) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PORTD != portD) { PORTD = portD; } #endif } void writeLed(uint8_t anIndex, uint8_t aValue) { uint8_t led = pgm_read_byte_near(LEDS + anIndex); uint8_t code = _BV(led &amp; <span class="hljs-number"><span class="hljs-number">0</span></span>x0F); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (aValue &amp;&amp; bitRead(ledsActivity, anIndex)) { switch(led &amp; <span class="hljs-number"><span class="hljs-number">0</span></span>xF0) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(PORTA) case <span class="hljs-number"><span class="hljs-number">0</span></span>xA0: portA |= code; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; #endif #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(PORTB) case <span class="hljs-number"><span class="hljs-number">0</span></span>xB0: portB |= code; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; #endif #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(PORTC) case <span class="hljs-number"><span class="hljs-number">0</span></span>xC0: portC |= code; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; #endif #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(PORTD) case <span class="hljs-number"><span class="hljs-number">0</span></span>xD0: portD |= code; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; #endif } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { switch(led &amp; <span class="hljs-number"><span class="hljs-number">0</span></span>xF0) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(PORTA) case <span class="hljs-number"><span class="hljs-number">0</span></span>xA0: portA &amp;= ~code; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; #endif #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(PORTB) case <span class="hljs-number"><span class="hljs-number">0</span></span>xB0: portB &amp;= ~code; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; #endif #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(PORTC) case <span class="hljs-number"><span class="hljs-number">0</span></span>xC0: portC &amp;= ~code; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; #endif #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(PORTD) case <span class="hljs-number"><span class="hljs-number">0</span></span>xD0: portD &amp;= ~code; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; #endif } } } ///////////////////////////////////////////////////////////////////////////////////////////////// void setup() { portsUpdateStart(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint8_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEDS_NUM; ++i) { bitSet(ledsActivity, i); uint8_t led = pgm_read_byte_near(LEDS + i); uint8_t code = _BV(led &amp; <span class="hljs-number"><span class="hljs-number">0</span></span>x0F); switch (led &amp; <span class="hljs-number"><span class="hljs-number">0</span></span>xF0) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(DDRA) case <span class="hljs-number"><span class="hljs-number">0</span></span>xA0: DDRA |= code; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; #endif #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(DDRB) case <span class="hljs-number"><span class="hljs-number">0</span></span>xB0: DDRB |= code; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; #endif #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(DDRC) case <span class="hljs-number"><span class="hljs-number">0</span></span>xC0: DDRC |= code; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; #endif #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>(DDRD) case <span class="hljs-number"><span class="hljs-number">0</span></span>xD0: DDRD |= code; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; #endif } writeLed(i, HIGH); } portsUpdateFinish(); // <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> MCU prescaler CLKPR = <span class="hljs-number"><span class="hljs-number">0</span></span>b10000000; CLKPR = MCU_PRESCALER; // <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> ADC prescaler ADCSRA = (ADCSRA &amp; ~<span class="hljs-number"><span class="hljs-number">0</span></span>b111) | ADC_PRESCALER; // activate ADC auto-triggering ADCSRA |= _BV(ADATE) | _BV(ADIE); ADMUX = PIEZO_ADMUX; ADCSRA |= _BV(ADSC); // disable all digital inputs DIDR0 = <span class="hljs-number"><span class="hljs-number">0</span></span>xff; // disable analog comparator ACSR |= _BV(ACD); // disable timer <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> delta loop <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> is <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DELTA_LOOP_TIME_MS) { power_timer0_disable(); power_timer1_disable(); set_sleep_mode(SLEEP_MODE_ADC); } _delay_ms(<span class="hljs-number"><span class="hljs-number">100</span></span>); lastLoopTime = DELTA_LOOP_TIME_MS ? <span class="hljs-number"><span class="hljs-number">0</span></span> : millis(); setupPhaseTime = lastLoopTime + SETUP_TIME_MS; } void loop() { uint32_t <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> = DELTA_LOOP_TIME_MS ? globalTime : millis(); uint16_t loopDeltaTime = <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> - lastLoopTime; uint8_t setupPhase = <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> &lt; setupPhaseTime; rand(); // update random seed // wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ADC routine to read all samples <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> FFT memset(sampleAccA, <span class="hljs-number"><span class="hljs-number">0</span></span>, sizeof(sampleAccA)); memset(sampleAccB, <span class="hljs-number"><span class="hljs-number">0</span></span>, sizeof(sampleAccB)); samplePos = <span class="hljs-number"><span class="hljs-number">0</span></span>; while (samplePos != SAMPLE_BUF_SIZE) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DELTA_LOOP_TIME_MS) { sleep_mode(); } } portsUpdateStart(); // calculate FFT[<span class="hljs-number"><span class="hljs-number">10</span></span>] uint8_t signal = fft10(); // blowing detection <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (signal &gt; BLOWING_THRESHOLD) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!blowing) { // generate LEDs flickering values <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint8_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEDS_NUM; ++i) { ledsPeriod[i] = LEDS_PERIOD_MIN_MS + rand() % (LEDS_PERIOD_MAX_MS - LEDS_PERIOD_MIN_MS); ledsTTL[i] = (LEDS_TTL_MIN_MS + rand() % (LEDS_TTL_MAX_MS - LEDS_TTL_MIN_MS)) &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ledsPhase[i] = rand() % ledsPeriod[i]; } } blowing = !setupPhase; lastBlowingTime = <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (blowing &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> - lastBlowingTime &gt; PROLONG_BLOWING_MS) { blowing = false; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (blowing) { totalBlowingTime += loopDeltaTime; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (totalBlowingTime &gt;= DELAY_BLOWING_MS) { // prolong startup <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> until noise stabilizes <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (setupPhase) { setupPhaseTime += SETUP_TIME_MS; } // update LEDs state <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint8_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEDS_NUM; ++i) { uint8_t level = ((<span class="hljs-built_in"><span class="hljs-built_in">time</span></span> + ledsPhase[i]) % ledsPeriod[i] &lt; (ledsPeriod[i] &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>)) ? LOW : HIGH; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (signal &lt;= BLOWING_THRESHOLD) { level = !level; } writeLed(i, level); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!setupPhase &amp;&amp; totalBlowingTime &gt; (ledsTTL[i] &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>)) { bitClear(ledsActivity, i); } } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { totalBlowingTime = max(<span class="hljs-number"><span class="hljs-number">0</span></span>, totalBlowingTime - loopDeltaTime); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (totalBlowingTime &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) totalBlowingTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint8_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEDS_NUM; ++i) { writeLed(i, HIGH); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (setupPhase) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">time</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">1500</span></span>) { // show busy state int lowLed = (<span class="hljs-built_in"><span class="hljs-built_in">time</span></span> &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) % LEDS_NUM; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint8_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEDS_NUM; ++i) { writeLed(i, (i == lowLed) ? LOW : HIGH); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { const bool DEBUG_MODE = false; // trace debug value using LEDs const bool INVERT_LEVELS = true; // LOW level means <span class="hljs-number"><span class="hljs-number">1</span></span>, HIGH level means <span class="hljs-number"><span class="hljs-number">0</span></span> const bool MEASURE_TIME = false; // measure <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ms (minus offset, see code) const bool SHOW_ORDER = false; // show value as binary order <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DEBUG_MODE) { int value = signal; // value to show <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (MEASURE_TIME) { static uint32_t totalLoopTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; static uint32_t loopCtr = <span class="hljs-number"><span class="hljs-number">0</span></span>; totalLoopTime += loopDeltaTime; ++loopCtr; // <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> offset here value = totalLoopTime / loopCtr - <span class="hljs-number"><span class="hljs-number">10</span></span>; } int dbgValue = value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SHOW_ORDER) { dbgValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; value &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; ++dbgValue, value &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint8_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEDS_NUM; ++i) { bitSet(ledsActivity, i); writeLed(i, (dbgValue &gt; i) ? (INVERT_LEVELS ? LOW : HIGH) : (INVERT_LEVELS ? HIGH : LOW)); } // the last LED shows blowing state writeLed(LEDS_NUM - <span class="hljs-number"><span class="hljs-number">1</span></span>, blowing ? HIGH : LOW); } } portsUpdateFinish(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ledsActivity == <span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> - lastBlowingTime &gt; NO_ACTIVITY_MS || <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> &gt; TIME_LIMIT_MS) { powerDown(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DELTA_LOOP_TIME_MS) { globalTime += DELTA_LOOP_TIME_MS; } lastLoopTime = <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>; } /////////////////////////////////////////////////////////////////////////////////////////////////</code> </pre> </div></div><br>  To program the controller, you need an <b>ICSP</b> programmer such as <b>USBTiny</b> or an <b>Arduino</b> board that is programmed to be a programmer (look for <i>‚ÄúArduino as a programmer‚Äù</i> ).  The program can be downloaded directly from the <b>Arduino IDE</b> , but before that you need to put special libraries for <b>ATTiny</b> and select <b>ATTiny44 8MHz</b> as the controller. <br><br><br><h1>  Links </h1><br>  <a href="http://bitcake.eu/">http://bitcake.eu</a> - site dedicated to this project (eng.) </div><p>Source: <a href="https://habr.com/ru/post/243499/">https://habr.com/ru/post/243499/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243487/index.html">Installing, configuring and using chkrootkit vulnerability scanner</a></li>
<li><a href="../243489/index.html">How important commercial information flows away. Infographics</a></li>
<li><a href="../243493/index.html">Adora Cheung (part 1): product and honesty curve</a></li>
<li><a href="../243495/index.html">Universe npm</a></li>
<li><a href="../243497/index.html">Computer Science Classic</a></li>
<li><a href="../243501/index.html">Repair of a loop of LEGO NXT</a></li>
<li><a href="../243503/index.html">Express Course "Project Planning"</a></li>
<li><a href="../243505/index.html">Calendar of birthdays and anniversaries of Outlook contacts</a></li>
<li><a href="../243509/index.html">Add self-registration by users in ownCloud 6</a></li>
<li><a href="../243511/index.html">IOS Masque Vulnerability Check</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>