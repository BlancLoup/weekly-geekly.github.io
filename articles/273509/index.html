<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Immersion in ASP.NET 5 Runtime</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction from the translator 
 This article is a translation of ASP.NET 5 - A Deep Dive into the ASP.NET 5 Runtime - an introduction to the archit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Immersion in ASP.NET 5 Runtime</h1><div class="post__text post__text-html js-mediator-article"><h1>  Introduction from the translator </h1><br>  This article is a translation of <a href="https://msdn.microsoft.com/en-us/magazine/dn913182.aspx">ASP.NET 5 - A Deep Dive into the ASP.NET 5 Runtime</a> - an introduction to the architecture of DNX and built on it ASP.NET 5. Since the original article was written in March 2015, at the time when ASP. NET 5 was still under active development (roughly beta 3), much of it is outdated.  Therefore, when translating all the information was updated to the current version of ASP.NET 5 (RC1), links to related resources were also added (mainly to docs.asp.net) and the source code on GitHub (see only in cases if you are interested in the implementation ).  Have a nice dive! <br><br><h1>  .NET Runtime Environment (DNX) </h1><br>  ASP.NET 5 is based on a flexible, cross-platform runtime that can work with different .NET CLRs (.NET Core CLR, Mono CLR, .NET Framework CLR).  You can run ASP.NET 5 using the full .NET Framework, or you can run it using the new <a href="https://docs.asp.net/en/latest/conceptual-overview/dotnetcore.html">.NET Core</a> <sup><font color="orange">docs</font></sup> , which allows you to simply copy all the necessary libraries along with the application to the existing environment, without changing anything else on your machine.  Using .NET Core you can also run ASP.NET 5 cross-platform on <a href="https://docs.asp.net/en/latest/getting-started/installing-on-linux.html">Linux</a> <sup><font color="orange">docs</font></sup> and <a href="https://docs.asp.net/en/latest/getting-started/installing-on-mac.html">Mac OS</a> <sup><font color="orange">docs</font></sup> . <br><br>  The infrastructure to run and execute ASP.NET 5 applications is called <a href="https://docs.asp.net/en/latest/dnx/overview.html">.NET Runtime Environment</a> <sup><font color="orange">docs</font></sup> or DNX for short.  DNX provides everything you need to run .NET applications: host process, CLR hosting logic, detection of Entry Point, etc. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Logically, the DNX architecture has five layers.  I will describe each of these layers along with their responsibilities. <br>  Image taken from <a href="https://github.com/aspnet/Home/wiki/DNX-structure">DNX-structure</a> <sup>wiki</sup> article <br><div style="text-align:center;"><img src="https://habrastorage.org/files/289/5ba/820/2895ba82031b40e88c258864ef96230e.jpg" alt="ASP.NET 5 and DNX Architecture"></div><br><a name="habracut"></a><br><h2>  Layer One: Native Process </h2><br>  A native process (meaning the operating system process) is a very thin layer with the obligation to find and call the native CLR host, passing in the arguments passed to the process itself.  On Windows, this is dnx.exe (located in% YOUR_PROFILE% /. Dnx / runtimes /% CHOOSEN_RUNTIME%).  On Mac and Linux, this is a running bash script (also called dnx). <br><br>  <a href="https://docs.asp.net/en/latest/publishing/iis.html">Starting on IIS</a> <sup><font color="orange">docs</font></sup> takes place using the native HTTP module installed on IIS: <a href="httpplatformhandler-module-for-iis-8/">HTTPPlatformHandler</a> (which eventually also runs dnx.exe).  Using HTTPPlatformHandler allows you to run a web application on IIS without any dependencies on the .NET Framework (of course, when launching web applications aimed at .NET Core, and not on the full .NET Framework). <br><blockquote>  <i>Note: DNX applications (both ASP.NET 5 console and web applications) run in the address space of this native process.</i>  <i>From now on, by "native process", I will mean dnx.exe and its analogues in other operating systems.</i> <br></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/files/70d/f85/334/70df853348e64fa2b3ddd64331df411e.JPG" alt="dnx"></div><br><h2>  Layer two and three: Native CLR host and CLR </h2><br>  Have three main responsibilities: <br><ol><li>  Run CLR.  The ways to achieve this differ depending on the CLR version used, but the result will be the same. </li><li>  Start executing the fourth layer code (Managed Entry Point) in the CLR. </li><li>  When the native CLR host returns control, it will "clean up after itself" and turn off the CLR. </li></ol><br><h2>  Layer Four: Entry Point Driven </h2><br><blockquote>  <i>Note: In general, the logic of this layer is in the <a href="">Microsoft.DNX.Host</a> <sup><font color="blue">github</font></sup> assembly.</i>  <i>Entry Point of this layer can be considered as <a href="">RuntimeBootstrapper</a> <sup><font color="blue">github</font></sup> .</i> <br></blockquote><br>  This is the first layer in which the work of the DNX application proceeds to the execution of the managed code (hence its name).  He is responsible: <br><ol><li>  For the <a href="">creation of LoaderContainer</a> <sup><font color="blue">github</font></sup> , a container for ILoaders.  ILoaders are responsible for loading assemblies.  When the CLR asks the LoaderContainer to provide an assembly, it will do it using its ILoaders. </li><li> <a href="">Creating</a> <sup><font color="blue">github</font></sup> <a href="">root ILoader</a> , which will load the required assemblies from the bin folder of the selected dnx runtime:% YOUR_PROFILE% /. Dnx / runtimes /% CHOOSEN_RUNTIME% / bin / and additional paths provided during the launch of the native process using the <code>--lib</code> parameter : <code>dnx --lib &lt;LIB_PATHS&gt;</code> ). </li><li>  <a href="">Configure</a> <sup><font color="blue">github</font></sup> IApplicationEnvironment and the core infrastructure of the Dependency Injection system. </li><li><a name="4-layer-call-entry-point"></a>  <a href="">Call entry point</a> <sup><font color="blue">github of a</font></sup> specific application or <a href="">Microsoft.DNX.ApplicationHost</a> <sup><font color="blue">github</font></sup> , depending on the parameters passed to the native process during the launch of the application. </li></ol><br><h2>  Layer Five: Application Host </h2><br>  <a href="https://github.com/aspnet/dnx/tree/1.0.0-rc1-final/src/Microsoft.Dnx.ApplicationHost">Microsoft.DNX.ApplicationHost</a> <sup><font color="blue">github</font></sup> is the application host that comes with DNX.  His duties include: <br><ol><li>  <a href="">Adding</a> <sup><font color="blue">github</font></sup> additional assembly loaders (ILoaders) to the LoaderContainer, which can download assemblies from various sources, such as installed NuGet packages and sources compiled at runtime using Roslyn, etc. </li><li>  View the dependencies specified in project.json and download them.  The dependency bypass logic is described in more detail in the <a href="https://github.com/aspnet/Home/wiki/Dependency-Resolution">Dependency-Resolution</a> article <sup>wiki</sup> . </li><li>  <a href="">Call the entry point</a> <sup><font color="blue">github of</font></sup> your assembly, in the case of a console application or the <a href="">entry point of Microsoft.AspNet.Hosting</a> <sup><font color="blue">github</font></sup> in the case of a web application.  An assembly can be anything with an entry point, which ApplicationHost <a href="">knows how to call</a> <sup><font color="blue">github</font></sup> .  Coming along with DNX, ApplicationHost <a href="">knows how to find the</a> <sup><font color="blue">github</font></sup> <code>public static void Main</code> method. </li></ol><br><h2>  Cross-platform SDK Tools </h2><br>  DNX comes with an SDK containing everything you need to build cross-platform .NET applications. <br><br>  <a href="https://github.com/aspnet/Home/wiki/Version-Manager"><strong>DNVM</strong> - DNX Version Manager</a> <sup>wiki</sup> .  Allows you to view the DNX installed on your computer, install new ones and select the one you will use. <br>  <a href="https://docs.asp.net/en/latest/getting-started/installing-on-windows.html">After installing</a> <sup><font color="orange">docs,</font></sup> you can use DNVM from the command line, just type <code>dnvm</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/files/59d/636/2f5/59d6362f58dc4f439a55b89bf335496a.JPG" alt="dnvm"></div><br>  DNVM sets DNXs from NuGet feed configured to use the DNX_FEED environment variable.  DNXs are not NuGet packages in the traditional sense - packages that you can refer to as dependencies.  NuGet is a convenient way to deliver and manage DNX versions.  By default, DNX is set by copying and unpacking the archive with DNX to "% USERPROFILE% /. Dnx". <br><br>  <a href="https://github.com/aspnet/Home/wiki/DNX-utility"><strong>DNU</strong> - DNX Utility</a> <sup>wiki</sup> .  A tool for installing, restoring and creating NuGet packages.  By default, packages are installed in "% USERPROFILE% /. Dnx / packages", but you can change this by setting a different path in your global.json file (located in the Solution Items folder of your project). <br>  To use DNU, type <code>dnu</code> on the command line. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/136/352/3bf/1363523bf08a41e7b774d04f015d15bd.JPG" alt="dnu"></div><br><br><h2>  Cross-platform console application on .NET </h2><br>  Now I will show you how, using DNX, to create a simple cross-platform console application on .NET. <br>  We need to create a DLL with an entry point and we can do this using the "Console Application (Package)" template in Visual Studio 2015. <br><br>  Our application code: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleApp</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>); Console.ReadLine(); } } }</code> </pre> <br>  The code looks absolutely identical to a regular console application. <br>  You can run this application from Visual Studio or from the command line by typing <code>dnx run</code> on the command line, being in the folder with the project.json file (project root) of the application being launched. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/ca1/61e/149/ca161e14978749f0811342948c949f1e.JPG" alt="dnx run"></div><br>  <code>dnx run</code> is just an abbreviation, the native process, in fact, will expand it into a command: <br><pre> <code class="bash hljs">dnx.exe --appbase . Microsoft.DNX.ApplicationHost run</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/43c/b56/981/43cb569813004b87af826fe9ef0e46ad.JPG" alt="dnx run full"></div><br>  What will fit the pattern: <br><pre> <code class="bash hljs">dnx.exe --appbase &lt;   &gt; &lt;,  entry point&gt; &lt;,    &gt;</code> </pre> <br>  Let's analyze the expanded command: <br><ul><li>  <code>dnx.exe</code> is a native process. </li><li> <code>--appbase .</code>  - Sets the path to the folder of the project being launched.  Its value " <code>.</code> " - indicates the current directory. </li><li>  <code>Microsoft.DNX.ApplicationHost</code> - Any assembly having an entry point.  The default is Microsoft.DNX.ApplicationHost, it is his entry point that will cause the fourth layer (Layer Four: Managed Entry Point, <a href="https://habr.com/ru/post/273509/">fourth responsibility</a> ).  The fourth layer has no special knowledge of Microsoft.DNX.ApplicationHost.  It simply searches for the entry point in the assembly provided to it and calls it, passing parameters to it (in our example, " <code>run</code> " will be passed as a parameter). </li><li>  <code>run</code> - Parameter passed to the assembly having an entry point.  Microsoft.DNX.ApplicationHost interprets the <code>run</code> as a command that tells the project to find the entry point of the path provided via the <code>--appbase</code> parameter and call it.  Instead of the <code>run</code> command, you can pass the name of any assembly with an entry point and ApplicationHost will call it.  Below in the Web Application Hosting section, we will look at this example. </li></ul><br>  If you do not want to use ApplicationHost.  You can call the native layer by passing it your application directly.  To do this: <br><ol><li>  Generate a DLL by running the build of your application (make sure that you check the box "Produce outputs on build" in the "Build" section of the properties of your project).  You can find the results in the artifacts directory in the root of your solution folder (you can also use the <code>dnu build</code> command <code>dnu build</code> than Visual Studio, typing it in the folder with the project.json file of your project). </li><li>  Type the command: <code>dnx &lt;_______&gt;</code> . </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/files/da0/142/9eb/da01429eb1e04c29aab0ef59039692d5.JPG" alt="Dll call directly"></div><br>  Calling a DLL directly is a rather low-level approach to writing applications.  You do not use Microsoft.DNX.ApplicationHost, so you also refuse to use the project.json file and the improved NuGet-based dependency management mechanism.  Instead, any libraries you depend on will be loaded from the directories specified during the launch of the native process using the <code>--lib</code> parameter.  Before the end of this article, I will use Microsoft.DNX.ApplicationHost. <br><br>  Microsoft.DNX.ApplicationHost is the last DNX layer, everything above can be considered ASP.NET 5. <br><br><h1>  ASP.NET 5 </h1><br><h2>  Web application hosting </h2><br>  In ASP.NET 5 web applications, the <sup><font color="orange">docs</font></sup> <a href="https://docs.asp.net/en/latest/fundamentals/hosting.html">hosting layer</a> runs on top of Microsoft.DNX.ApplicationHost.  It is represented by the <a href="https://github.com/aspnet/Hosting/tree/1.0.0-rc1/src/Microsoft.AspNet.Hosting">Microsoft.AspNet.Hosting</a> <sup><font color="blue">github</font></sup> assembly.  This layer is responsible for finding the web server, running the web application on it and "cleaning up after itself" when the web application is turned off.  It also <a href="">provides the</a> <sup><font color="blue">github</font></sup> <a href="">application with</a> some additional services related to the hosting layer. <br><br>  To run the Microsoft.DNX.ApplicationHost web application, you must call the <a href="">entry point</a> <sup><font color="blue">github</font></sup> Microsoft.AspNet.Hosting <a href="">method</a> . <br><br>  The web server used by the hosting server can be selected by specifying the <code>--server</code> option or using other hosting configuration methods, such as the hosting.json file or environment variables.  The hosting layer loads the selected web server and starts it.  A commonly used web server should be listed in a list of dependencies in the project.json file so that it can be downloaded. <br><br>  Typically, a web application is started from the command line <code>dnx web</code> command. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/7c5/a9a/a1a/7c5a9aa1a5224330a82b00033f06a4ca.JPG" alt="dnx web"></div><br>  The ASP.NET 5 web application template includes a set <a href="https://docs.asp.net/en/latest/dnx/commands.html">of</a> <sup><font color="orange">docs</font></sup> <a href="https://docs.asp.net/en/latest/dnx/commands.html">commands</a> defined in the project.json file and the <code>web</code> command is one of them: <br><pre> <code class="javascript hljs"> <span class="hljs-string"><span class="hljs-string">"commands"</span></span>: { <span class="hljs-string"><span class="hljs-string">"web"</span></span>: <span class="hljs-string"><span class="hljs-string">"Microsoft.AspNet.Server.Kestrel"</span></span>, <span class="hljs-string"><span class="hljs-string">"ef"</span></span>: <span class="hljs-string"><span class="hljs-string">"EntityFramework.Commands"</span></span> },</code> </pre> <br>  Commands, in fact, only set additional arguments for <code>dnx.exe</code> and when you type <code>dnx web</code> to launch a web application, in reality this translates into: <br><pre> <code class="bash hljs">dnx.exe --appbase . Microsoft.DNX.ApplicationHost Microsoft.AspNet.Server.Kestrel</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/dd3/d2d/6c8/dd3d2d6c8b804c4f95b587f347b007e8.JPG"></div><br>  In turn, the <a href="">entry point</a> call <a href="">Microsoft.AspNet.Server.Kestrel</a> <sup><font color="blue">github is</font></sup> converted into a call: <br><pre> <code class="bash hljs">Microsoft.AspNet.Hosting --server Microsoft.AspNet.Server.Kestrel</code> </pre> <br>  So the final team will be: <br><pre> <code class="bash hljs">dnx.exe --appbase . Microsoft.DNX.ApplicationHost Microsoft.AspNet.Hosting --server Microsoft.AspNet.Server.Kestrel</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/87d/099/e95/87d099e95699435bb6a549b5f32caf6c.JPG"></div><br>  As a result of which, Microsoft.DNX.ApplicationHost will call the entry point method Microsoft.AspNet.Hosting (remember in the section about the cross-platform console application I said that if you pass the name of the assembly instead of run, then ApplicationHost will call its entry point?). <br><blockquote>  <i>While the article about hosting in the docs.asp.net documentation is not ready, you can read about the keys used to configure the hosting <a href="https://github.com/aspnet/Announcements/issues/108">here</a></i> . <br></blockquote><br><h3>  Web application start logic </h3><br>  The hosting layer is also responsible for <a href="">running the</a> <sup><font color="blue">github of the</font></sup> <a href="https://docs.asp.net/en/latest/fundamentals/startup.html">starting logic of the</a> web application <sup><font color="orange">docs</font></sup> .  It used to be in the Global.asax file, now by default it is in the Startup class and consists of the Configure method used to build the query processing pipeline and the ConfigureServices method used to configure the services of the web application. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">WebApplication1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Startup</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureService</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceCollection services</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//       } public void Configure(IApplicationBuilder app) { //      } } }</span></span></code> </pre> <br>  The <a href="">IApplicationBuilder</a> <sup><font color="blue">github</font></sup> interface is used to build the request processing pipeline in the Configure method.  IApplicationBuilder allows you to register the request delegate ("Use" method) and register the middleware ("UseMiddleware" method) in the request processing pipeline. <br><br>  Request delegate is the core concept of ASP.NET 5. Request delegate is an incoming request handler, it accepts HttpContext and asynchronously does something useful with it: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RequestDelegate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpContext context</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  Processing a request in ASP.NET 5 is a call through a chain of registered request delegate.  But the decision to call the next request delegate in the chain remains for the author, so each request delegate can stop processing the request and return a response to the user. <br><br>  To simplify the registration in the request delegate request processing pipeline that does not call the following request delegate, you can use the IAAPlicationBuilder Run extension method. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IApplicationBuilder app</span></span></span><span class="hljs-function">)</span></span> { app.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> context =&gt; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> context.Response.WriteAsync(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>)); }</code> </pre> <br>  The same can be achieved using the Use extension method and without calling the following request delegate: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IApplicationBuilder app</span></span></span><span class="hljs-function">)</span></span> { app.Use(next =&gt; <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> context =&gt; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> context.Response.WriteAsync(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>)); }</code> </pre> <br>  And an example with calling the following in the request delegate chain: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IApplicationBuilder app</span></span></span><span class="hljs-function">)</span></span> { app.Use(next =&gt; <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> context =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> context.Response.WriteAsync(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> next.Invoke(context); }); }</code> </pre> <br>  To make the request delegate convenient to reuse, you can arrange it in the form of <a href="https://docs.asp.net/en/latest/fundamentals/middleware.html">ASP.NET 5 middleware</a> <sup><font color="orange">docs</font></sup> . <br><br><h3>  Middleware </h3><br>  Middleware ASP.NET 5 is a regular class following a specific convention: <br><ol><li>  The next request delegate in the chain (as well as the necessary services and additional parameters) is passed to the middleware constructor. </li><li>  The HttpContext processing logic must be implemented in the asynchronous Invoke method. </li></ol><br>  Example middleware: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.AspNet.Builder; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.AspNet.Http; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">XHttpHeaderOverrideMiddleware</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> RequestDelegate _next; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XHttpHeaderOverrideMiddleware</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RequestDelegate next</span></span></span><span class="hljs-function">)</span></span> { _next = next; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpContext httpContext</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> headerValue = httpContext.Request.Headers[<span class="hljs-string"><span class="hljs-string">"X-HTTP-Method-Override"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queryValue = httpContext.Request.Query[<span class="hljs-string"><span class="hljs-string">"X-HTTP-Method-Override"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(headerValue)) { httpContext.Request.Method = headerValue; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(queryValue)) { httpContext.Request.Method = queryValue; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _next.Invoke(httpContext); } }</code> </pre> <br>  Calling the next (if you want to call the next) in the request delegate chain must be made inside the Invoke method.  If you put any logic below the call to the next request delegate, it will be executed after all the incoming request handlers following your request have completed. <br><br>  In the query processing pipeline, you can include the following middleware with this agreement using the <code>UseMiddleware&lt;T&gt;</code> extension method IApplicationBuilder: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IApplicationBuilder app</span></span></span><span class="hljs-function">)</span></span> { app.UseMiddleware&lt;XHttpHeaderOverrideMiddleware&gt;(); }</code> </pre> <br>  Any parameters passed to this method will be embedded in the middleware constructor after <code>RequestDelegate next</code> and the requested services. <br>  A middleware constructor that additionally accepts services and parameters: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XHttpHeaderOverrideMiddleware</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RequestDelegate next, SomeServise1 service1, SomeServise2 service2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> param1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> param2</span></span></span><span class="hljs-function">)</span></span> { _next = next; }</code> </pre> <br>  Inclusion of middleware in the request processing pipeline and passing parameters to it: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IApplicationBuilder app</span></span></span><span class="hljs-function">)</span></span> { app.UseMiddleware&lt;XHttpHeaderOverrideMiddleware&gt;(param1, param2); }</code> </pre> <br>  By convention, the inclusion of middleware in the call chain should be framed in the "Use ..." extension method of the IApplicationBuilder: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BuilderExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IApplicationBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UseXHttpHeaderOverride</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IApplicationBuilder builder</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> builder.UseMiddleware&lt;XHttpHeaderOverrideMiddleware&gt;(); } }</code> </pre> <br>  To enable this middleware in the request processing pipeline, you need to call this extension method in the Configure method: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IApplicationBuilder app</span></span></span><span class="hljs-function">)</span></span> { app.UseXHttpHeaderOverride(); }</code> </pre> <br>  ASP.NET 5 comes with a large set of embedded middleware.  There are middleware for working with <a href="https://docs.asp.net/en/latest/fundamentals/static-files.html">files</a> <sup><font color="orange">docs</font></sup> , <a href="https://docs.asp.net/en/latest/fundamentals/routing.html">routing</a> <sup><font color="orange">docs</font></sup> , error handling, <a href="https://docs.asp.net/en/latest/fundamentals/diagnostics.html">diagnostics</a> <sup><font color="orange">docs</font></sup> and security.  Middleware are delivered as NuGet packages via nuget.org. <br><br><h3>  Services </h3><br>  ASP.NET 5 introduces the concept of Services - "common" components, access to which may be required in several places in an application.  Services are available to the application through a dependency injection system.  ASP.NET 5 comes with a simple <a href="https://docs.asp.net/en/latest/fundamentals/dependency-injection.html">IoC container</a> <sup><font color="orange">docs</font></sup> that supports dependency injection in the designer, but you can easily <a href="https://docs.asp.net/en/latest/fundamentals/dependency-injection.html">replace the</a> <sup><font color="orange">docs</font></sup> with another container. <br><br>  The Startup class also supports dependency injection; all you need to do is to query them as constructor parameters. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Startup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IApplicationEnvironment appEnv</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  By default, the following services are available to you: <br>  <b>Microsoft.Extensions.PlatformAbstractions.IApplicationEnvironment</b> - information about the application (physical path to the application folder, its name, version, configuration (Release, Debug), used by the Runtime framework). <br>  <b>Microsoft.Extensions.PlatformAbstractions.IRuntimeEnvironment</b> - information on the DNX runtime and OS. <br>  <b>Microsoft.AspNet.Hosting.IHostingEnvironment</b> - access to your application's web root (usually the wwwroot folder), as well as information about the current environment (dev, stage, prod). <br>  <b>Microsoft.Extensions.Logging.ILoggerFactory</b> - factory for creating <sup><font color="orange">docs</font></sup> <a href="https://docs.asp.net/en/latest/fundamentals/logging.html">loggers</a> . <br>  <b>Microsoft.AspNet.Hosting.Builder.IApplicationBuilderFactory</b> is the factory for creating the IApplicationBuilder (used to build the request pipeline). <br>  <b>Microsoft.AspNet.Http.IHttpContextFactory</b> is a factory for creating an Http context. <br>  <b>Microsoft.AspNet.Http.IHttpContextAccessor</b> - provides access to the current Http context. <br><br>  You can add services to an application in the ConfigureServices method of the Startup class using the <a href="">IServiceCollection</a> <sup><font color="blue">github</font></sup> interface.  Typically, frameworks and libraries provide the "Add ..." extension method of an IServiceCollection to add their services to an IoC container.  For example, adding services used by ASP.NET MVC 6 is as follows: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceCollection services</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   MVC services.AddMvc(); }</span></span></code> </pre> <br>  You can add your own services to the IoC container.  Services to be added can be one of three types: transient (AddTransient method IServiceCollection), scoped (AddScoped method IServiceCollection) or singleton (AddSingleton method IServiceCollection). <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceCollection services</span></span></span><span class="hljs-function">)</span></span> { services.AddTransient&lt;CustomService1&gt;(); services.AddScoped&lt;CustomService2&gt;(); services.AddSingleton&lt;CustomService3&gt;(); }</code> </pre> <br>  Transient services are created each time they request from the container.  Scoped services are created only if they have not yet been created in the current scope.  In web applications, a scope container is created for each request, so you can think of them as services created for each http request.  Singleton services are created only once per application life cycle. <br><blockquote>  <i>In the console application, where access to dependency injection is not available, to access the services: IApplicationEnvironment and IRuntimeEnvironment, you must use the static <code>Microsoft.Extensions.PlatformAbstractions.PlatformServices.Default</code> object.</i> <br></blockquote><br><h3>  Application configuration </h3><br>  Web.config and app.config files are no longer supported.  Instead, ASP.NET 5 uses the new, simplified <a href="https://docs.asp.net/en/latest/fundamentals/configuration.html">Configuration API</a> <sup><font color="orange">docs</font></sup> .  It allows you to receive data from different sources.  The default configuration providers support JSON, XML, INI, command line arguments, environment variables, and setting parameters directly from the code (in-memory collection).  You can specify several sources, and they will be used in the order of their addition (the ones added last will override the settings added earlier).  You can also have different settings for each <a href="https://docs.asp.net/en/latest/fundamentals/environments.html">environment</a> <sup><font color="orange">docs</font></sup> : test, stage, prod.  Which makes it easy to publish applications in different environments. <br><br>  Sample appsettings.json file: <br><pre> <code class="cs hljs">{ <span class="hljs-string"><span class="hljs-string">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Stas"</span></span>, <span class="hljs-string"><span class="hljs-string">"Surname"</span></span>: <span class="hljs-string"><span class="hljs-string">"Boyarincev"</span></span> }</code> </pre> <br>  An example of getting the application configuration using the Configuration API: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConfigurationBuilder() .AddJsonFile(<span class="hljs-string"><span class="hljs-string">"appsettings.json"</span></span>) .AddJsonFile(<span class="hljs-string"><span class="hljs-string">$"appsettings.</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{env.EnvironmentName}</span></span></span><span class="hljs-string">.json"</span></span>, optional: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) .AddEnvironmentVariables(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Configuration = builder.Build();</code> </pre> <br>  You can request data using the GetSection method and the key name: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = Configuration.GetSection(<span class="hljs-string"><span class="hljs-string">"name"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> surname = Configuration.GetSection(<span class="hljs-string"><span class="hljs-string">"surname"</span></span>);</code> </pre> <br>  Or by contacting the index: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = Configuration[<span class="hljs-string"><span class="hljs-string">"name"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> surname = Configuration[<span class="hljs-string"><span class="hljs-string">"surname"</span></span>];</code> </pre> <br>  It is recommended to work with the Configuration API in the Startup class, and further divide the settings into small data sets corresponding to some functionality and transfer to other parts of the application using the <a href="https://docs.asp.net/en/latest/fundamentals/configuration.html">Options</a> <sup><font color="orange">docs</font></sup> mechanism. <br><br>  The Options mechanism allows you to use the Plain Old CLR Object (POCO) classes as objects with settings.  You can add it to your application by calling the AddOptions extension-method of the IServiceCollection in the ConfigureServices method: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceCollection services</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  Options   services.AddOptions(); }</span></span></code> </pre> <br>  In fact, the AddOptions call adds <code>IOptions&lt;TOption&gt;</code> to the dependency injection system.  This service can be used to get Options of various types wherever dependency injection is available (just request from it <code>IOption&lt;TOption&gt;</code> , where TOption POCO is the class with the settings you need). <br>  To register your options, you can use the <code>Configure&lt;TOption&gt;</code> extension IServiceCollection method: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceCollection services</span></span></span><span class="hljs-function">)</span></span> { services.Configure&lt;MvcOptions&gt;(options =&gt; options.Filters.Add( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyGlobalFilter())); }</code> </pre> <br>  In the example above, <a href="">MvcOptions</a> <sup><font color="blue">github</font></sup> is a class that the MVC framework uses to get its settings from the user. <br><br>  You can also easily transfer some configuration settings to options: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceCollection services</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Configuration -       services.Configure&lt;MyOptions&gt;(Configuration); }</span></span></code> </pre> <br>  In this case, the settings keys from the configuration will be mapped to the names of the POCO properties of the settings class. <br><br>  And in order to get MyOptions with the settings installed inside the application, it is enough to request from the deployment system <code>IOption&lt;MyOptions&gt;</code> dependencies, for example, through the controller's constructor. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HomeController</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IOptions&lt;MyOptions&gt; appOptions</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  The internal Options mechanism works by adding <code>IConfigureOptions&lt;TOptions&gt;</code> to the service container, where TOptions is the class with the settings.  The standard implementation of <code>IOptions&lt;TOption&gt;</code> will collect all <code>IConfigureOptions&lt;TOptions&gt;</code> same type and "summarize their properties" and then provide the final instance ‚Äî this happens because you can add an object with the same type of settings to the service container many times overriding settings. <br><br><h2>  Web server </h2><br>  As soon as the web server starts, it starts to expect incoming requests and start processing for each of them.  The web server level raises the request for the hosting level by sending it a set of feature interfaces.  There are feature interfaces for sending files, web sockets, session support, client certificates and <a href="https://docs.asp.net/en/latest/fundamentals/request-features.html">many other</a> <sup><font color="orange">docs</font></sup> . <br><br>  For example, feature interface for Http-request: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Microsoft.AspNet.Http.Features</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IHttpRequestFeature</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Protocol { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Scheme { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Method { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> PathBase { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> QueryString { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } IHeaderDictionary Headers { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } Stream Body { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre> <br>  The web server uses feature interfaces to expose low-level functionality to the hosting level.  And he, in turn, makes them available to the entire application via <code>HttpContext</code> .  This allows you to break the close links between the level of the web server and hosting and place the application on different web servers.  ASP.NET 5 comes with a wrapper over HTTP.SYS ( <a href="https://www.nuget.org/packages/Microsoft.AspNet.Server.WebListener">Microsoft.AspNet.Server.WebListener</a> ) and a new cross-platform web server called <a href="https://github.com/aspnet/KestrelHttpServer">Kestrel</a> <sup><font color="blue">github</font></sup> . <br><br>  Open Web Interface for .NET (OWIN) standard that shares the same goals.  OWIN standardizes how .NET servers and applications must communicate with each other.  ASP.NET 5 <a href="https://docs.asp.net/en/latest/fundamentals/owin.html">supports OWIN</a> <sup><font color="orange">docs</font></sup> using the <a href="">Microsoft.AspNet.Owin</a> <sup><font color="blue">github</font></sup> package.  You <a href="https://github.com/aspnet/Entropy/tree/dev/samples/Owin.Nowin.HelloWorld">can host</a> <sup><font color="blue">github</font></sup> ASP.NET 5 applications on OWIN-based web servers and you can <a href="https://github.com/aspnet/Entropy/tree/dev/samples/Owin.HelloWorld">use OWIN middleware</a> <sup><font color="blue">github</font></sup> in ASP.NET 5 pipeline. <br><br> <a href="http://katanaproject.codeplex.com/">Katana Project</a>    Microsoft   OWIN   ASP.NET           ASP.NET 5. Katana     pipeline  middleware     -. ,    Katana,     OWIN , ASP.NET 5     .        Katana middleware  ASP.NET 5   <a href="https://github.com/aspnet/Entropy/tree/dev/samples/Owin.IAppBuilderBridge">OWIN </a> <sup><font color="blue">github</font></sup> <br><br><h2>  Results </h2><br> ASP.NET 5 runtime       -. ASP.NET 5  ,  ,      .NET Framework, .NET Core    Mono.       ,  middleware,     -,            . <br><br><h2>  Links </h2><br> <a href="https://github.com/aspnet/">github.com/aspnet</a> ‚Äî   ASP.NET 5. <br> <a href="https://docs.asp.net/en/latest/index.html">docs.asp.net</a> ‚Äî  ASP.NET 5. <br> <a href="https://github.com/aspnet/Home/wiki">github.com/aspnet/Home/wiki</a> ‚Äî   DNX Runtime. </div><p>Source: <a href="https://habr.com/ru/post/273509/">https://habr.com/ru/post/273509/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273489/index.html">Juniper Firewall Backdoors</a></li>
<li><a href="../273491/index.html">Facebook threatens security specialist hacking Instagram</a></li>
<li><a href="../273493/index.html">Preparing ASP.NET 5, issue number 7: more about working with Gulp</a></li>
<li><a href="../273497/index.html">Taming UEFI SecureBoot</a></li>
<li><a href="../273505/index.html">Open lecture: the problem of the feasibility of Boolean formulas</a></li>
<li><a href="../273511/index.html">Paul Graham: The Word "Hacker"</a></li>
<li><a href="../273513/index.html">Why and how do we back up github</a></li>
<li><a href="../273517/index.html">Look in looking-glass</a></li>
<li><a href="../273519/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 22. "Enemies"</a></li>
<li><a href="../273523/index.html">Another "critical" "vulnerability" "VPN" and why Port Fail is nonsense</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>