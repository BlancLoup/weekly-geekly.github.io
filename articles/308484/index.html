<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Static and dynamic typing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article describes the difference between statically typed and dynamically typed languages, examines the concepts of "strong" and "weak" typing, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Static and dynamic typing</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>This article describes the difference between statically typed and dynamically typed languages, examines the concepts of "strong" and "weak" typing, and compares the power of typing systems in different languages.</em>  <em>Recently, there has been a clear movement towards stricter and more powerful typing systems in programming, so it is important to understand what is at stake when talking about types and typing.</em> </p><br><p><img src="https://habrastorage.org/files/f98/46c/348/f9846c3487a842158cd79db0608ab71c.jpg"></p><br><p>  A type is a collection of possible values.  An integer can have the values ‚Äã‚Äã0, 1, 2, 3, and so on.  Boolean can be true or false.  You can come up with your own type, for example, the type ‚ÄúDyPyat‚Äù, in which the values ‚Äã‚Äãof ‚Äúgive‚Äù and ‚Äú5‚Äù are possible, and nothing more.  This is not a string or a number, it is a new, separate type. </p><br><p> Statically typed languages ‚Äã‚Äãlimit the types of variables: a programming language can know, for example, that x is an Integer.  In this case, the programmer is forbidden to do <code>x = true</code> , it will be an incorrect code.  The compiler will refuse to compile it, so that we cannot even run such code.  Another statically typed language may have other expressive possibilities, and none of the popular type systems is able to express our type of DipAut (but many may express other, more sophisticated ideas). </p><br><p>  Dynamically typed languages ‚Äã‚Äãmark values ‚Äã‚Äãwith types: the language knows that 1 is an integer, 2 is an integer, but it cannot know that the variable x always contains an integer. </p><br><p>  The language runtime checks for these labels at different points in time.  If we try to add two values, it can check whether they are numbers, strings, or arrays.  Then it adds these values, sticks them together or gives an error, depending on the type. <a name="habracut"></a></p><br><h2>  Statically typed languages </h2><br><p>  Static languages ‚Äã‚Äãcheck types in the program at compile time, even before the program starts.  Any program in which types violate the rules of the language is considered incorrect.  For example, most static languages ‚Äã‚Äãwill reject the expression <code>"a" + 1</code> (the C language is an exception to this rule).  The compiler knows that "a" is a string, and 1 is an integer, and that <code>+</code> works only when the left and right parts are of the same type.  So he does not need to run the program to understand that there is a problem.  Each expression in a statically typed language is of a specific type that can be defined without running code. </p><br><p>  Many statically typed languages ‚Äã‚Äãrequire type designation.  A function in Java <code>public int add(int x, int y)</code> takes two integers and returns the third integer.  Other statically typed languages ‚Äã‚Äãcan automatically determine the type.  The same addition function in Haskell looks like this: <code>add xy = x + y</code> .  We do not communicate types to the language, but it can define them itself, because it knows that <code>+</code> works only on numbers, so <code>x</code> and <code>y</code> must be numbers, so the <code>add</code> function takes two numbers as arguments. </p><br><p>  This does not reduce the "static" type system.  The type system in Haskell is famous for its static nature, rigor and power, and in all these fronts Haskell is ahead of Java. </p><br><h2>  Dynamically typed languages </h2><br><p>  Dynamically typed languages ‚Äã‚Äãdo not require to specify the type, but do not define it themselves.  Variable types are unknown until they have specific values ‚Äã‚Äãat startup.  For example, a function in python </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y</code> </pre> <br><p>  can add two integers, glue strings, lists, and so on, and we cannot understand what is happening until we run the program.  It is possible that at some point the function f will be called with two lines, and with two numbers at another time.  In this case, x and y will contain values ‚Äã‚Äãof different types at different times.  Therefore, it is said that values ‚Äã‚Äãin dynamic languages ‚Äã‚Äãhave a type, but variables and functions are not.  A value of 1 is definitely an integer, but x and y can be anything. </p><br><h2>  Comparison </h2><br><p>  Most dynamic languages ‚Äã‚Äãwill give an error if the types are used incorrectly (JavaScript is a known exception; it tries to return a value for any expression, even when it does not make sense).  When using dynamically typed languages, even a simple error of the form <code>"a" + 1</code> can occur in the combat environment.  Static languages ‚Äã‚Äãprevent such errors, but, of course, the degree of prevention depends on the power of the type system. </p><br><p>  Static and dynamic languages ‚Äã‚Äãare built on fundamentally different ideas about the correctness of programs.  In the dynamic language <code>"a" + 1</code> this is the correct program: the code will be launched and an error will appear in the execution environment.  However, in most statically typed languages, the expression <code>"a" + 1</code> is <em>not a program</em> : it will not be compiled and will not run.  This is an incorrect code, just like the random character set <code>!&amp;%^@*&amp;%^@*</code> Is an incorrect code.  This additional concept of correctness and incorrectness has no equivalent in dynamic languages. </p><br><h2>  Strong and weak typing </h2><br><p>  The concepts of "strong" and "weak" are very ambiguous.  Here are some examples of their use: </p><br><ul><li><p>  Sometimes "strong" means "static." <br>  Everything is simple, but it is better to use the term "static", because most use and understand it. </p><br></li><li><p>  Sometimes "strong" means "does not do implicit type conversion". <br>  For example, JavaScript allows you to write <code>"a" + 1</code> , which can be called "weak typing."  But almost all languages ‚Äã‚Äãprovide one or another level of implicit conversion, which allows you to automatically switch from integers to floating-point numbers like <code>1 + 1.1</code> .  In reality, most people use the word ‚Äústrong‚Äù to define the boundary between an acceptable and unacceptable transformation.  There is no generally accepted border, they are all inaccurate and depend on the opinion of a particular person. </p><br></li><li><p>  Sometimes "strong" means that it is impossible to circumvent the strict typing rules in a language. </p><br></li><li>  Sometimes "strong" means memory-safe. <br>  C is an example of an unsafe language.  If <code>xs</code> is an array of four numbers, then C will happily execute the <code>xs[5]</code> or <code>xs[1000]</code> code, returning some value from the memory immediately after <code>xs</code> . </li></ul><br><p>  Let's stop.  Here is how some languages ‚Äã‚Äãmeet these definitions.  As you can see, only Haskell is consistently "strong" in all respects.  Most languages ‚Äã‚Äãare not so clear. </p><br><table><thead><tr><th>  Tongue </th><th>  Static? </th><th>  Implicit conversions? </th><th>  Strict rules? </th><th>  Safe for memory? </th></tr></thead><tbody><tr><td>  C </td><td>  Strong </td><td>  It depends </td><td>  Weak </td><td>  Weak </td></tr><tr><td>  Java </td><td>  Strong </td><td>  It depends </td><td>  Strong </td><td>  Strong </td></tr><tr><td>  Haskell </td><td>  Strong </td><td>  Strong </td><td>  Strong </td><td>  Strong </td></tr><tr><td>  Python </td><td>  Weak </td><td>  It depends </td><td>  Weak </td><td>  Strong </td></tr><tr><td>  Javascript </td><td>  Weak </td><td>  Weak </td><td>  Weak </td><td>  Strong </td></tr></tbody></table><br><p>  ("When as" in the column "Implicit conversions" means that the separation between the strong and the weak depends on what transformations we consider acceptable). </p><br><p>  Often the terms "strong" and "weak" refer to an indefinite combination of different definitions above, and other definitions not shown here.  This whole mess makes the words "strong" and "weak" almost meaningless.  When you want to use these terms, it is better to describe what exactly is meant.  For example, you can say that "JavaScript returns a value when a string is added to a number, but Python returns an error."  In this case, we will not spend our strength on trying to come to an agreement on the set of meanings of the word "strong."  Or, even worse: we will come to unresolved misunderstanding because of terminology. </p><br><p>  In most cases, the terms "strong" and "weak" on the Internet are unclear and poorly defined opinions of specific people.  They are used to call the language "bad" or "good", and this opinion turns into technical jargon. </p><br><p>  As <a href="https://cdsmith.wordpress.com/2011/01/09/an-old-article-i-wrote/">Chris Smith wrote</a> : </p><br><blockquote>  Strong typing: A type system that I love and feel comfortable with. <br><br>  Weak typing: A type system that bothers me or is not comfortable with me. </blockquote><br><h2>  Gradual typing </h2><br><p>  Can I add static types to dynamic languages?  In some cases, yes.  In others, it is difficult or impossible.  The most obvious problem is <code>eval</code> and other similar features of dynamic languages.  Running <code>1 + eval("2")</code> in Python gives 3. But what does <code>1 + eval(read_from_the_network())</code> give?  It depends on what is online at the time of execution.  If we get a number, the expression is correct.  If string, then no.  It is impossible to know before launch, so it is impossible to analyze the type statically. </p><br><p>  The unsatisfactory solution in practice is to set the expression <code>eval()</code> type Any, which resembles Object in some object-oriented programming languages ‚Äã‚Äãor <code>interface {}</code> in Go: a type that any value satisfies. </p><br><p>  Values ‚Äã‚Äãof type Any are not limited to anything, so the possibility of a type system that helps us in code with eval disappears.  Languages ‚Äã‚Äãin which both <code>eval</code> and type system exist must refuse type safety every time <code>eval</code> used. </p><br><p>  Some languages ‚Äã‚Äãhave optional or gradual typing: they are dynamic by default, but allow you to add some static annotations.  In Python recently added optional types;  TypeScript is an add-on to JavaScript that has optional types;  Flow performs static analysis of good old JavaScript code. </p><br><p>  These languages ‚Äã‚Äãprovide some advantages to static typing, but they never provide an absolute guarantee, like truly static languages.  Some functions will be statically typed, and some will be dynamically typed.  The programmer always needs to know and be wary of the difference. </p><br><h2>  Compiling statically typed code </h2><br><p>  When compiling statically typed code occurs, the syntax is first checked, as in any compiler.  Then types are checked.  This means that a static language may first complain about one syntax error, and after correcting it, complain about 100 typing errors.  A syntax error fix did not create these 100 typing errors.  The compiler simply did not have the ability to detect type errors until the syntax was fixed. </p><br><p>  Static language compilers can usually generate faster code than dynamic compilers.  For example, if the compiler knows that the add function accepts integers, then it can use the native ADD instruction of the central processor.  The dynamic language will check the type when executed, choosing one of the many add functions depending on the types (do we add integers or floats or glue strings or maybe lists?) Or we need to decide that an error has occurred and the types do not match each other.  All these checks take time.  Dynamic languages ‚Äã‚Äãuse different tricks for optimization, for example, JIT compilation (just-in-time), where the code is recompiled when executed after receiving all the necessary types of information.  However, no dynamic language can compare in speed with a neatly written static code in a language like Rust. </p><br><h2>  Arguments for static and dynamic types </h2><br><p>  Proponents of the static type system indicate that without a type system, simple mistakes can lead to production problems.  This, of course, is true.  Anyone who has used a dynamic language has experienced this. </p><br><p>  Proponents of dynamic languages ‚Äã‚Äãindicate that it seems easier to write code in such languages.  This is definitely true for some kinds of code that we occasionally write, like, for example, that code with <code>eval</code> .  This is a controversial decision for regular work, and here it makes sense to recall the indefinite word "easy."  Rich Hickey <a href="https://www.infoq.com/presentations/Simple-Made-Easy">talked well</a> about the word "easy," and his connection to the word "simple."  Looking at this report you will realize that it is not easy to correctly use the word "easy."  Be wary of "lightness." </p><br><p>  The pros and cons of static and dynamic typing systems are still poorly understood, but they definitely depend on the language and the specific problem being solved. </p><br><p>  JavaScript tries to continue, even if it means meaningless conversion (like <code>"a" + 1</code> , giving "a1").  Python in turn tries to be conservative and often returns errors, as is the case with <code>"a" + 1</code> . </p><br><p>  There are different approaches with different security levels, but Python and JavaScript are both dynamically typed languages. </p><br><p>  C will happily allow a programmer to read data from any place in memory, or to imagine that the value of one type has a different type, even if it does not make any sense and will cause the program to fall. </p><br><p>  Haskell will not allow to add integer and float without explicit conversion before it.  C and Haskell are both statically typed, despite such big differences. </p><br><p>  There are many variations of dynamic and static languages.  Any unqualified statement like "static languages ‚Äã‚Äãis better than dynamic when it comes to X" is almost guaranteed nonsense.  This may be true for specific languages, but then it is better to say "Haskell is better than Python when it comes to X". </p><br><h2>  Variety of static typing systems </h2><br><p>  Let's take a look at two famous examples of statically typed languages: Go and Haskell.  In the Go typing system there are no generic types, types with "parameters" from other types.  For example, you can create your own type for MyList lists, which can store any data we need.  We want to be able to create MyList integers, MyList strings, and so on, without changing the source code of MyList.  The compiler must follow the typing: if there is a MyList of integers, and we accidentally add a string there, then the compiler must reject the program. </p><br><p>  Go was specifically designed so that it was impossible to set types like MyList.  The best thing you can do is create a MyList of "empty interfaces": MyList may contain objects, but the compiler simply does not know their type.  When we retrieve objects from MyList, we need to tell the compiler their type.  If we say "I take out a string", but in reality the value is a number, then there will be an execution error, as in the case of dynamic languages. </p><br><p>  Go also lacks many other features that are present in modern statically typed languages ‚Äã‚Äã(or even in some systems of the 1970s).  The creators of Go had their own reasons for these decisions, but the opinions of people on this occasion can sometimes be harsh. </p><br><p>  Now let's compare with Haskell, which has a very powerful type system.  If you set the type to MyList, the type of "list of numbers" is just <code>MyList Integer</code> .  Haskell will not let us accidentally add a string to the list, and make sure that we do not put an element from the list into a string variable. </p><br><p>  Haskell can express much more complex ideas directly with types.  For example, <code>Num a =&gt; MyList a</code> means "MyList of values ‚Äã‚Äãthat refer to the same type of numbers."  This may be a list of integer, float or decimal numbers with fixed precision, but it will definitely never be a list of strings, which is checked when compiled. </p><br><p>  You can write an add function that works with any numeric types.  This function will have type <code>Num a =&gt; (a -&gt; a -&gt; a)</code> .  It means: </p><br><ul><li>  <code>a</code> can be any numerical type ( <code>Num a =&gt;</code> ). </li><li>  The function takes two arguments of type <code>a</code> and returns the type <code>a</code> ( <code>a -&gt; a -&gt; a</code> ). </li></ul><br><p>  Last example.  If the function type is <code>String -&gt; String</code> , then it takes a string and returns a string.  But if it is <code>String -&gt; IO String</code> , then it also performs some kind of input / output.  This can be a disk access, a network, a read from a terminal, and so on. </p><br><p>  If a function in a type has <em>no</em> IO, then we know that it does not perform any I / O operations.  In a web application, for example, you can see if a function changes a database by just looking at its type.  No dynamic and almost no static languages ‚Äã‚Äãare like that.  This is a feature of languages ‚Äã‚Äãwith the most powerful typing system. </p><br><p>  In most languages, we would have to deal with the function and all the functions that are called from there, and so on, in attempts to find something that changes the database.  This is a tedious process in which it is easy to make a mistake.  And the Haskell type system can answer this question simply and guaranteed. </p><br><p>  Compare this power with Go, which is not capable of expressing the simple idea of ‚Äã‚ÄãMyList, not to mention "a function that takes two arguments, and they are both numerical and of the same type, and that does input / output." </p><br><p>  The Go approach simplifies the writing of Go programming tools (in particular, the implementation of the compiler can be simple).  In addition, fewer concepts need to be explored.  How these advantages are comparable to significant limitations is a subjective question.  However, one cannot argue that Haskell is harder to learn than Go, and that Haskell's type system is much more powerful, and that Haskell can prevent many more types of bugs when compiling. </p><br><p>  Go and Haskell are so different languages ‚Äã‚Äãthat grouping them into one class of "static languages" can be misleading, despite the fact that the term is used correctly.  If you compare the practical benefits of security, then Go is closer to dynamic languages ‚Äã‚Äãthan to Haskell. </p><br><p>  On the other hand, some dynamic languages ‚Äã‚Äãare safer than some static languages.  (Python is generally considered much safer than C).  When you want to make generalizations about static or dynamic languages ‚Äã‚Äãas groups, do not forget about the huge number of differences between languages. </p><br><h2>  Specific examples of differences in the capabilities of typing systems </h2><br><p>  In more powerful typing systems, you can specify restrictions at smaller levels.  Here are a few examples, but don't dwell on them if the syntax is incomprehensible. </p><br><p>  In Go, you can say "the add function takes two integers and returns an integer": </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, y </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y }</code> </pre> <br><p>  In Haskell, you can say "the function accepts <em>any</em> numeric type and returns a number of the same type": </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> :: <span class="hljs-type"><span class="hljs-type">Num</span></span> a =&gt; a -&gt; a -&gt; a add xy = x + y</code> </pre> <br><p>  In Idris, you can say "the function takes two integers and returns an integer, but the first argument must be less than the second argument": </p><br><pre> <code class="hljs erlang-repl">add : (x : Nat) -&gt; (y : Nat) -&gt; {auto smaller : LT xy} -&gt; Nat add xy = x + y</code> </pre> <br><p>  If you try to call the function <code>add 2 1</code> , where the first argument is greater than the second, then the compiler will reject the program <em>at compile time</em> .  It is impossible to write a program where the first argument is more than the second.  Rare language has this feature.  In most languages, such a check occurs during execution: we would write something like <code>if x &gt;= y: raise SomeError()</code> . </p><br><p>  In Haskell, there is no equivalent to this type as in the example with Idris above, and in Go there is no equivalent to either the Haskell example or the Idris example.  As a result, Idris can prevent many bugs that Haskell cannot prevent, and Haskell can prevent many bugs that Go doesn‚Äôt notice.        ,     . </p><br><h2>      </h2><br><p>           .         ,         .           .       ,      . </p><br><ul><li> <strong>C (1972), Go (2009)</strong> :     ,    .    MyList,    "  ", " "  ..     "  ".     "  "  ,     ,        . </li><li> <strong>Java (1995), C# (2000)</strong> :     ,     <code>MyList&lt;String&gt;</code>    ,           .       String,        ,       . </li><li> <strong>Haskell (1990), Rust (2010), Swift (2014)</strong> :       ,     ,    (ADTs),     -  ( ,  (traits)  , ). Rust  Swift  ,  Haskell,      (Mozilla  Apple, ). </li><li> <strong>Agda (2007), Idris (2011)</strong> :     ,     ",        y,  y ,  x".   "y ,  x"   .   y       x,    .  ,           .     ,        . </li></ul><br><p>         ,      ,       .   ‚Äî  Go,  ,         . </p><br><p>   (Java  C#) ‚Äî   ,    . </p><br><p>        ,      Mozilla (Rust)  Apple (Swift). </p><br><p>   (Idris and Agda)   ,      .           . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/308484/">https://habr.com/ru/post/308484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308470/index.html">Linux is 25 years old</a></li>
<li><a href="../308472/index.html">How is network access control implemented within Cisco?</a></li>
<li><a href="../308474/index.html">Fujitsu World Tour 2016: Moving to Digital Transformation</a></li>
<li><a href="../308480/index.html">Instantly launch almost any OS under Linux using libvirt + qemu</a></li>
<li><a href="../308482/index.html">Blockchain and FINTECH-Hakaton at Innopolis University</a></li>
<li><a href="../308486/index.html">From the experience of using SObjectizer: are the actors in the form of finite automata - is it bad or good?</a></li>
<li><a href="../308488/index.html">Using trigrams for correcting recognition results</a></li>
<li><a href="../308490/index.html">Unexpected behavior of the WinAPI function IsWow64Process ()</a></li>
<li><a href="../308494/index.html">How to give an adequate estimate of the time when uncertainty hits the head</a></li>
<li><a href="../308498/index.html">Air Berlin: Progressive Web App Implementation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>