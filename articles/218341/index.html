<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Interpretation at compile time, or Alternative understanding of lambda in C ++ 11</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habré , another article about computing on C ++ templates from HurrTheDurr recently skipped . In the comments to her personally, I saw the challeng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Interpretation at compile time, or Alternative understanding of lambda in C ++ 11</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/7d6/4b7/f83/7d64b7f83b4d78f198856db9039c3978.jpg" alt="Yo dawg, I heard you like programming.  So you can program while you program" align="right">  On Habré <a href="http://habrahabr.ru/post/218229/">, another article</a> about computing on C ++ templates from <a href="https://habrahabr.ru/users/hurrthedurr/" class="user_link">HurrTheDurr recently skipped</a> .  In the comments to her personally, I saw the challenge: <br><br>  <font color="DimGray">&gt; With each new release, the number of ways to nontrivially dislocate your brain with C ++ continues to increase)</font> <font color="DimGray"><br></font>  <font color="DimGray">Quoted1&gt;&gt; Especially if you do not change the approach to the implementation of the playing field and continue to try to perform all calculations not on constants, but on types.</font> <br><br>  Is it so difficult to write a universal calculator on types, more convenient for programming than a cellular automaton?  As it turned out, easy;  I spent 30 times more time on this article than on writing and debugging the actual code of the calculator. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://habrahabr.ru/users/avenat/" class="user_link">AveNat</a> slightly earlier published an introduction to lambda calculus <a href="http://habrahabr.ru/post/215807/">in two</a> <a href="http://habrahabr.ru/post/215991">parts</a> , so the inspiration came instantly.  I wanted to be able to (figuratively) write like this: <pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;LC/kernel.h&gt; #include &lt;LC/church_numerals.h&gt; int main() { //      - typedef ChurchEncode&lt;2&gt; Two; // 2 = λfx.f (fx) typedef ChurchEncode&lt;3&gt; Three; // 3 = λfx.f (f (fx)) // * = λab.λf.a (bf) typedef Lambda&lt;'a', Lambda&lt;'b', Lambda&lt;'f', Apply&lt;Var&lt;'a'&gt;, Apply&lt;Var&lt;'b'&gt;, Var&lt;'f'&gt; &gt; &gt; &gt; &gt; &gt; Multiply; //  (* 2 3) typedef Eval&lt;Apply&lt;Apply&lt;Multiply, Two&gt;, Three&gt;&gt; Output; //    -    typedef ChurchDecode&lt;Output&gt; Result; std::cout &lt;&lt; Result::value; }</span></span></span></span></code> </pre> <br>  And at the output to receive such: <pre> <code class="hljs ruby">ilammy@ferocity ~ $ gcc cpp.cpp ilammy@ferocity ~ $ ./a.out <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br>  The article turned out to be somewhat large, as I wanted to tell you about all the interesting things that are used here.  And yet it requires a basic set of knowledge about lambda calculus.  The above reviews, average C ++ knowledge (with templates), and common sense should be enough to understand the content. <br><br>  Under the cut there is another commented constructive proof of the Turing completeness of the C ++ templates in the form of a compile-time interpreter of the typeless lambda calculus (plus cookies in the form of macros and recursion). <a name="habracut"></a><br><br>  (Since the C ++ 03 compilers require <code>&lt;</code> asymmetric <code>&lt;</code> angular <code>&lt;</code> brackets <code>&lt;</code> in <code>&lt;</code> templates&gt;&gt;&gt;&gt;&gt;, and in most cases I am confused by their appearance, then either C ++ 11 support or <abbr title="replace every pair >> with>> until there are no such"><code>sed ':l;s/&gt;&gt;/&gt; &gt;/g;tl'</code></abbr> necessary for compilation <abbr title="replace every pair >> with>> until there are no such"><code>sed ':l;s/&gt;&gt;/&gt; &gt;/g;tl'</code></abbr> . With the exception of the macro part, the code does not use any other C ++ 11 features.) <br><br><br><h3>  Syntax </h3><br>  Go.  As you know, terms in lambda calculus are of three types: <table><tbody><tr><td><img src="//habrastorage.org/files/2e8/950/db3/2e8950db36a441aa8eb02ee2cab7d60d.gif" alt="v"></td><td>  variable reference </td><td>  <i>v</i> - variable name </td></tr><tr><td><img src="//habrastorage.org/files/c83/435/632/c834356328534658a7df7ec0b73695bb.gif" alt="λv.B"></td><td>  abstraction </td><td>  <i>v</i> - variable name, <i>B</i> - term </td></tr><tr><td><img src="//habrastorage.org/files/7de/bb7/79b/7debb779b9d249cfb6f0f4653684262f.gif" alt="(fx)"></td><td>  application </td><td>  <i>f</i> and <i>x</i> - terms </td></tr></tbody></table>  All of these constructs must be represented using C ++ templates.  The values ​​in the template language are types.  Each of these types must carry information about its components.  Declaring them, we introduce the axiom "the following expressions exist": <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Var</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ref</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//  template &lt;class Var, class Exp&gt; struct Lam; //  template &lt;class Fun, class Arg&gt; struct App; // </span></span></code> </pre><br>  However, variables in lambda calculus are not full values.  The variable <i>v</i> does not make sense by itself, without an abstraction associating it with any value.  Therefore, a term is a <i>reference to a variable</i> , and not the variable itself.  So the definition can be slightly simplified, making it easier to write programs: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ref</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lam</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fun</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>  We used the possibility of templating using integer values.  That's just the values ​​of the <code>char</code> can also be written as strings, which is very convenient: you do not need to declare each variable used in the program in advance.  At the same time, this clearly shows that the variables themselves are not values ​​(that is, C ++ types). <div class="spoiler">  <b class="spoiler_title">Fun fact</b> <div class="spoiler_text">  Variable names can be made up of several characters: <code>'foo'</code> .  However, apologists for lambda calculus consider it a luxury.  Secondly, the value of such symbolic literals is left to the discretion of the compiler ( <abbr title="[lex.ccon]">2.14.3 / 1</abbr> ), which in rare cases can lead to name collisions. </div></div><br>  Now we can write with the help of templates any lambda terms! <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Lam&lt;<span class="hljs-string"><span class="hljs-string">'f'</span></span>, App&lt;Lam&lt;<span class="hljs-string"><span class="hljs-string">'x'</span></span>, App&lt;Ref&lt;<span class="hljs-string"><span class="hljs-string">'f'</span></span>&gt;, App&lt;Ref&lt;<span class="hljs-string"><span class="hljs-string">'x'</span></span>&gt;, Ref&lt;<span class="hljs-string"><span class="hljs-string">'x'</span></span>&gt;&gt;&gt;&gt;, Lam&lt;<span class="hljs-string"><span class="hljs-string">'x'</span></span>, App&lt;Ref&lt;<span class="hljs-string"><span class="hljs-string">'f'</span></span>&gt;, App&lt;Ref&lt;<span class="hljs-string"><span class="hljs-string">'x'</span></span>&gt;, Ref&lt;<span class="hljs-string"><span class="hljs-string">'x'</span></span>&gt;&gt;&gt;&gt;&gt;&gt; Y;</code> </pre><br><br><h3>  What's next? </h3><img src="//habrastorage.org/files/133/e49/0e2/133e490e269048ab9255293592d17f1b.png" alt="f (x)" align="right"><br>  Knowing how to write terms, you need to learn how to calculate them.  Here everything is not so simple, so let's apply a fairly well-known approach to writing hellish magic on templates: first write everything in some declarative programming language, then just fix the syntactic differences.  I personally prefer Scheme, so I will use it.  With equal success, any other functional language like Haskell can be applied.  (And even better - Prolog.) <br><br>  We will not reinvent the wheel to record the terms themselves, but use traditional lists: <pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">; Y = λf.(λx.f (xx)) (λx.f (xx)) (define Y '(lambda (f) ((lambda (x) (f (xx))) (lambda (x) (f (xx))) )))</span></span></code> </pre><br>  Fix the lambda calculus syntax: <pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;  —  , ,  . (define (term? exp) (or (ref? exp) (lam? exp) (app? exp)) ) ;   . (define (ref? exp) (symbol? exp)) ;  —     . (define (lam? exp) (and (list-of? 3 exp) ;   —   lambda. (eqv? 'lambda (first exp)) ;  —     . (list-of? 1 (second exp)) (symbol? (first (second exp))) ;   —  . (term? (third exp)) ) ) ;  —     . (define (app? exp) (and (list-of? 2 exp) (term? (first exp)) (term? (second exp)) ) )</span></span></code> </pre><br>  Next, we define the function <code>eval</code> , which will interpret the terms, distinguishing them by syntax: <pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">eval</span></span> exp) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">ref</span></span>? exp) (<span class="hljs-name"><span class="hljs-name">eval-ref</span></span> exp)) ((<span class="hljs-name"><span class="hljs-name">lam</span></span>? exp) (<span class="hljs-name"><span class="hljs-name">eval-lam</span></span> (<span class="hljs-name"><span class="hljs-name">first</span></span> (<span class="hljs-name"><span class="hljs-name">second</span></span> exp)) (<span class="hljs-name"><span class="hljs-name">third</span></span> exp))) ((<span class="hljs-name"><span class="hljs-name">app</span></span>? exp) (<span class="hljs-name"><span class="hljs-name">eval-app</span></span> (<span class="hljs-name"><span class="hljs-name">first</span></span> exp) (<span class="hljs-name"><span class="hljs-name">second</span></span> exp))) (<span class="hljs-name"><span class="hljs-name">else</span></span> (<span class="hljs-name"><span class="hljs-name">error</span></span> <span class="hljs-string"><span class="hljs-string">"eval: syntax error"</span></span> exp)) ) )</code> </pre><br>  Fine.  But how to implement <code>eval-ref</code> ?  Where does the interpreter know the value of a variable?  For this there is such a thing as <i>environment</i> .  Connections between variables and their values ​​are preserved in environments.  Therefore, <code>eval</code> actually looks like this - with an additional argument: <pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">eval</span></span> exp env) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">ref</span></span>? exp) (<span class="hljs-name"><span class="hljs-name">eval-ref</span></span> exp env)) ((<span class="hljs-name"><span class="hljs-name">lam</span></span>? exp) (<span class="hljs-name"><span class="hljs-name">eval-lam</span></span> (<span class="hljs-name"><span class="hljs-name">first</span></span> (<span class="hljs-name"><span class="hljs-name">second</span></span> exp)) (<span class="hljs-name"><span class="hljs-name">third</span></span> exp) env)) ((<span class="hljs-name"><span class="hljs-name">app</span></span>? exp) (<span class="hljs-name"><span class="hljs-name">eval-app</span></span> (<span class="hljs-name"><span class="hljs-name">first</span></span> exp) (<span class="hljs-name"><span class="hljs-name">second</span></span> exp) env)) (<span class="hljs-name"><span class="hljs-name">else</span></span> (<span class="hljs-name"><span class="hljs-name">error</span></span> <span class="hljs-string"><span class="hljs-string">"Syntax error"</span></span> exp)) ) )</code> </pre><br>  Now, the calculation of the reference to a variable is simply determined - this is a search for the value of a variable in the environment: <pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">eval-ref</span></span> var env) (<span class="hljs-name"><span class="hljs-name">lookup</span></span> var env) )</code> </pre><br>  The value of the abstraction must be an anonymous function of one argument.  This function will cause the application when the time comes.  The meaning of abstraction is to calculate your body <code>exp</code> in an environment where the abstraction variable <code>var</code> has the value of the argument passed to <code>arg</code> .  The <code>bind</code> function will take care of creating such an environment. <pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">eval-lam</span></span> var exp env) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">arg</span></span>) (<span class="hljs-name"><span class="hljs-name">eval</span></span> exp (<span class="hljs-name"><span class="hljs-name">bind</span></span> var arg env)) ) )</code> </pre>  The values ​​of the other variables may vary, but specifically in lambda calculus it is assumed that they remain the same as in the place where abstraction is defined (that is, they were taken from the <code>env</code> environment).  Because of the property of preserving the original environment, such functions are called <i>closures</i> . <br><br>  Finally, an application is the application of the value of the abstraction <code>fun</code> to the value of the argument <code>arg</code> . <pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">eval-app</span></span> fun arg env) ((<span class="hljs-name"><span class="hljs-name">eval</span></span> fun env) (<span class="hljs-name"><span class="hljs-name">eval</span></span> arg env)) )</code> </pre>  Here, first the abstraction and its argument are calculated, and then the call is made.  Accordingly, <code>eval</code> performs a reduction of lambda terms in the applicative order (with a call by value). <br><br>  It remains only to define a couple of functions for working with environments.  <code>lookup</code> to find the value of a variable in the environment and <code>bind</code> to create new environments: <pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">bind</span></span> var val env) <span class="hljs-comment"><span class="hljs-comment">;     : (cons (cons var val) env) ) ; (bind 'x 1 '((y . 2))) ===&gt; ((x . 1) (y . 1)) ; (lookup 'x '((x . 1) (y . 2))) ===&gt; 1 (define (lookup var env) ; (lookup 'y '((x . 1) (y . 2))) ===&gt; 2 (let ((cell (assq var env))) ; (lookup 'z '((x . 1) (y . 2))) ===&gt; #&lt;ERROR&gt; (if cell (cdr cell) (error "lookup: unbound variable" var) ) ) )</span></span></code> </pre><br>  Super!  We have a lambda calculator interpreter written in pure functional style.  ( <a href="https://gist.github.com/ilammy/0f12bbe9b15903dcdb06">All source</a> .) And it even works: <pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">eval</span></span> '((lambda (x) x) B) (<span class="hljs-name"><span class="hljs-name">bind</span></span> 'B <span class="hljs-number"><span class="hljs-number">42</span></span> '()) ) <span class="hljs-comment"><span class="hljs-comment">; ===&gt; 42</span></span></code> </pre><br><br><h3>  But what kind of brackets?  And where does C ++ come from? </h3><br><img src="//habrastorage.org/files/3a3/759/7a9/3a37597a9006475cbdb3e5d94712401c.png" alt="You are saying" align="left">  Looking at the source code of the interpreter in Scheme, it is relatively easy to guess how to write an interpreter of lambda terms on C ++ templates.  Let me remind you that the terms themselves are recorded in the following patterns: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ref</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lam</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fun</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class">;</span></span></code> </pre><br><h4>  Template functions (not those) </h4>  The interpreter function is called <code>Eval</code> .  Since there are no functions in templates, we will have to do with templates alone: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Eval</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>  The invocation of such a function is the instantiation of the template: <code>Eval&lt;Exp, Env&gt;</code> .  The return value of this call must be a C ++ type.  Let's agree that <code>Eval</code> defines inside of itself a type of <code>value</code> , if its value is defined for the arguments passed: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Eval&lt;Exp, Env&gt;::value</code> </pre>  Such code allows to get the value of the <code>Eval</code> call with <code>Exp</code> and <code>Env</code> arguments (in the form of the <code>value</code> type).  If a particular call is erroneous (does not make sense), then the <code>value</code> type will not be defined and we will get a compile-time error.  Other "template functions" are defined in the same way. <br><br><h4>  Eval and Apply </h4>  Now, using partial template specialization, we can declaratively describe the behavior of <code>Eval</code> .  For example, calculating a variable reference is a search for the value of a variable in the environment using the <code>Lookup</code> function (it returns a value in <code>result</code> ): <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Eval</span></span></span><span class="hljs-class">&lt;Ref&lt;Var&gt;, Env&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Lookup&lt;Var, Env&gt;::result value; };</code> </pre><br>  The result of the abstraction calculation is the closure represented by the <code>Closure</code> template type.  A closure stores in itself an (anonymous) function and the environment for defining this function: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Eval</span></span></span><span class="hljs-class">&lt;Lam&lt;Var, Exp&gt;, Env&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Closure&lt;Lam&lt;Var, Exp&gt;, Env&gt; value; };</code> </pre><br>  The result of the evaluation of the application is the application of the calculated closure to the calculated argument (performed by the <code>Apply</code> function): <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fun</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Eval</span></span></span><span class="hljs-class">&lt;App&lt;Fun, Arg&gt;, Env&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Apply&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Eval&lt;Fun, Env&gt;::value, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Eval&lt;Arg, Env&gt;::value&gt;::result value; };</code> </pre><br>  Thus, <code>Eval</code> defined only for <code>Ref</code> , <code>Lam</code> , <code>App</code> (and environments by the second argument).  <code>Eval</code> calls with other arguments are simply not compiled. <br><br>  Go ahead.  Closures are simply interpreter data structures that store two values ​​(a function and its definition environment).  Naturally, they are implemented by one more pattern: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Abs</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Closure</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>  The whole essence of lambda calculus is concentrated in the definition of the <code>Apply</code> function.  Closures are calculated in the environment of its definition, which <code>Bind</code> extends by binding the argument of the calculated function to its actual value: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fun</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Apply</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Apply</span></span></span><span class="hljs-class">&lt;Closure&lt;Lam&lt;Var, Exp&gt;, Env&gt;, Arg&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Eval&lt;Exp, Bind&lt;Var, Arg, Env&gt;&gt;::value result; };</code> </pre>  (Note that, in principle, <code>Apply</code> can be defined for anything at all, not just for the application of abstractions.) <br><br><h4>  Lookup and Bind </h4>  It remains to deal with environments.  For starters, it would be nice to have an empty environment: <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullEnv</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>  Next, you need to implement an environment extension mechanism using <code>Bind</code> .  This data type defines a new environment in which the variable <code>Var</code> is associated with the value of <code>Val</code> , and the values ​​of the other variables are determined by the environment <code>Env</code> : <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Val</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bind</span></span></span><span class="hljs-class">;</span></span></code> </pre>  Got a kind of coherent list on the templates. <br><br>  Finally, we need to be able to find the value of the desired variable in this list — it will be in the first element of the list with the same name.  The <code>Lookup</code> function performs the search: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lookup</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>  There is nothing in empty surroundings.  If the desired value is in the current environment, then return it.  Otherwise, we recursively scan other environments: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lookup</span></span></span><span class="hljs-class">&lt;Var, NullEnv&gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Val</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lookup</span></span></span><span class="hljs-class">&lt;Var, Bind&lt;Var, Val, Env&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Val result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> OtherVar, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Val</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lookup</span></span></span><span class="hljs-class">&lt;Var, Bind&lt;OtherVar, Val, Env&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Lookup&lt;Var, Env&gt;::result result; };</code> </pre><br><h4>  the end </h4>  So in 50 lines, we completely defined the syntax and semantics of lambda calculus using C ++ templates, which proves the Turing completeness of the C ++ template disclosure mechanism (assuming unlimited amount of available memory). <br><br>  <a href="http://ubietylab.net/ubigraph/content/Papers/pdf/CppTuring.pdf">The definition of a Turing machine</a> <font color="gray">( <i>English</i> )</font> can be crammed into about the same amount of strings, but it will still be more verbose due to a more complex structure.  <a href="http://wwwhome.math.utwente.nl/~mantheyb/journals/BotEATCS_BoehmeManthey_CompilingCPP.pdf">The definition of mu-recursive functions</a> <font color="gray">( <i>English</i> )</font> will probably be shorter, but not much.  It would be interesting to look at the implementation of the Markov algorithms, but I did not find it, it is difficult to estimate the size of the source code, but it’s too lazy to write. <br><br>  Okay, let's try to carry out the simplest calculation, using the obtained features ( <a href="https://gist.github.com/ilammy/4860e7743fd4fe9693a8/c0ca03b3731000e72c73470777b49c75b4a62ce3">full code</a> ): <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* ,   */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { // 1 = λfx.fx typedef Lam&lt;'f', Lam&lt;'x', App&lt;Ref&lt;'f'&gt;, Ref&lt;'x'&gt;&gt;&gt;&gt; One; // 2 = λfx.f (fx) typedef Lam&lt;'f', Lam&lt;'x', App&lt;Ref&lt;'f'&gt;, App&lt;Ref&lt;'f'&gt;, Ref&lt;'x'&gt;&gt;&gt;&gt;&gt; Two; // + = λab.λfx.af (bfx) typedef Lam&lt;'a', Lam&lt;'b', Lam&lt;'f', Lam&lt;'x', App&lt;App&lt;Ref&lt;'a'&gt;, Ref&lt;'f'&gt;&gt;, App&lt;App&lt;Ref&lt;'b'&gt;, Ref&lt;'f'&gt;&gt;, Ref&lt;'x'&gt;&gt;&gt; &gt;&gt;&gt;&gt; Plus; // Output := (+ 1 2) typedef Eval&lt;App&lt;App&lt;Plus, One&gt;, Two&gt;, NullEnv&gt;::value Output; // --...    ? Output::invalid_field; }</span></span></span></span></code> </pre><br><pre> <code class="hljs pgsql">ilammy@ferocity ~/dev/tlc $ g++ -std=c++<span class="hljs-number"><span class="hljs-number">11</span></span> lc.cpp lc.cpp:   «<span class="hljs-type"><span class="hljs-type">int</span></span> main()»: lc.cpp:<span class="hljs-number"><span class="hljs-number">79</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>: :   «Output {aka Closure&lt;Lam&lt;<span class="hljs-string"><span class="hljs-string">'f'</span></span>, Lam&lt;<span class="hljs-string"><span class="hljs-string">'x'</span></span>, App&lt;App&lt;<span class="hljs-keyword"><span class="hljs-keyword">Ref</span></span>&lt;<span class="hljs-string"><span class="hljs-string">'a'</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">Ref</span></span>&lt;<span class="hljs-string"><span class="hljs-string">'f'</span></span>&gt; &gt;, App&lt;App&lt;<span class="hljs-keyword"><span class="hljs-keyword">Ref</span></span>&lt;<span class="hljs-string"><span class="hljs-string">'b'</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">Ref</span></span>&lt;<span class="hljs-string"><span class="hljs-string">'f'</span></span>&gt; &gt;, <span class="hljs-keyword"><span class="hljs-keyword">Ref</span></span>&lt;<span class="hljs-string"><span class="hljs-string">'x'</span></span>&gt; &gt; &gt; &gt; &gt;, Bind&lt;<span class="hljs-string"><span class="hljs-string">'b'</span></span>, Closure&lt;Lam&lt;<span class="hljs-string"><span class="hljs-string">'f'</span></span>, Lam&lt;<span class="hljs-string"><span class="hljs-string">'x'</span></span>, App&lt;<span class="hljs-keyword"><span class="hljs-keyword">Ref</span></span>&lt;<span class="hljs-string"><span class="hljs-string">'f'</span></span>&gt;, App&lt;<span class="hljs-keyword"><span class="hljs-keyword">Ref</span></span>&lt;<span class="hljs-string"><span class="hljs-string">'f'</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">Ref</span></span>&lt;<span class="hljs-string"><span class="hljs-string">'x'</span></span>&gt; &gt; &gt; &gt; &gt;, NullEnv&gt;, Bind&lt;<span class="hljs-string"><span class="hljs-string">'a'</span></span>, Closure&lt;Lam&lt;<span class="hljs-string"><span class="hljs-string">'f'</span></span>, Lam&lt;<span class="hljs-string"><span class="hljs-string">'x'</span></span>, App&lt;<span class="hljs-keyword"><span class="hljs-keyword">Ref</span></span>&lt;<span class="hljs-string"><span class="hljs-string">'f'</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">Ref</span></span>&lt;<span class="hljs-string"><span class="hljs-string">'x'</span></span>&gt; &gt; &gt; &gt;, NullEnv&gt;, NullEnv&gt; &gt; &gt;}»      Output::invalid_field; ^</code> </pre><br>  In general, this way of executing programs is also quite good, but I would like to be more comfortable. <br><br><br><h3>  Expansion of multiple terms </h3><img src="//habrastorage.org/files/858/27a/187/85827a18778b4f5c9719beed9f85adf3.png" alt="Arecibo message" align="right"><br>  First, the closure of the pattern interpreter is its internal data structures.  Only C ++ types correspond to them, but not values.  It is necessary to work with them inside the interpreter itself and never take it beyond the limits of the template mechanism.  (Therefore, they are intentionally left undefined types.) <br><br>  Secondly, it is obvious that in the case of presenting the arguments in the form of Church numbers, the result of their addition will also be the Church number — a function of two arguments that applies the first argument to the second one N times.  (That's why we got the closure at the output, as gcc output says.) But what do we do with this function?  After all, as arguments, we can transfer only the same functions to it! <br><br>  Indeed, now our interpreter understands only <i>pure</i> lambda calculus, in which there are only abstractions, applications and variables (which refer to abstractions or applications).  The syntax makes it possible to compose lambda terms solely from these three components.  Any violation of this rule results in a compilation error. <br><br>  In order to be able to decipher the results of calculations, it is necessary to use the <i>applied</i> lambda calculus - in it the set of terms is extended by elements of some objective set.  In our case, this will be a set of C ++ data types. <br><br>  We introduce the corresponding term for them: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inj</span></span></span><span class="hljs-class">;</span></span></code> </pre>  It denotes an <i>injection of</i> type <code>T</code> in the set of terms of lambda calculus. <br><br>  After expanding the syntax, it is necessary to clarify the semantics of the language — define with the help of <code>Eval</code> value of the new syntactic structure.  Well ... since <code>T</code> is an <i>arbitrary</i> value, then <code>Eval</code> knows only that such a value exists.  The only meaning that can be given to functions in such conditions is the identity: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Eval</span></span></span><span class="hljs-class">&lt;Inj&lt;T&gt;, Env&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T value; };</code> </pre><br>  Now we can pass as arguments the numbers (represented by types): <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Zero</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interpretation = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre>  It remains to figure out how to pass a function, and we can turn Church numbers into normal <code>int</code> numbers.  After all, if you apply the increment function to zero N times, then you end up with a natural number N. <br><br>  Imagine that we somehow managed to do this by passing the <code>Succ</code> (successor) and <code>Zero</code> types to the interpreter.  Let us follow what happens when calling such a function: <pre> <code class="cpp hljs">Eval&lt;App&lt;Inj&lt;Succ&gt;, Inj&lt;Zero&gt;&gt;, Env&gt;::value Apply&lt;Eval&lt;Inj&lt;Succ&gt;, Env&gt;, Eval&lt;Inj&lt;Zero&gt;, Env&gt;&gt;::result Apply&lt;Succ, Zero&gt;::result</code> </pre>  Bingo!  To determine the behavior of <code>Succ</code> you need to specialize <code>Apply</code> for it!  (Such conversions are called <i>delta rules</i> .) <br><br>  For example, this is how the increment function is defined: <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Succ</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">N</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Apply</span></span></span><span class="hljs-class">&lt;Succ, N&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _ {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interpretation = N::interpretation + <span class="hljs-number"><span class="hljs-number">1</span></span>; } result; };</code> </pre>  The return value of the <code>Apply</code> must be a type declared as <code>result</code> .  Therefore, the result of the increment is a data type that is structurally identical to the <code>Zero</code> described above.  This allows natural numbers to be represented by non-template data types, while retaining the ability to get a regular <code>int</code> with the corresponding value. <br><br>  Now you can finally output the result of the addition!  ( <a href="https://gist.github.com/ilammy/4860e7743fd4fe9693a8/38dd91dd77fe3f09e8a3bf484b420a2af07b0852">Full code</a> .) <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* ,   */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { // 1 = λfx.fx typedef Lam&lt;'f', Lam&lt;'x', App&lt;Ref&lt;'f'&gt;, Ref&lt;'x'&gt;&gt;&gt;&gt; One; // 2 = λfx.f (fx) typedef Lam&lt;'f', Lam&lt;'x', App&lt;Ref&lt;'f'&gt;, App&lt;Ref&lt;'f'&gt;, Ref&lt;'x'&gt;&gt;&gt;&gt;&gt; Two; // + = λab.λfx.af (bfx) typedef Lam&lt;'a', Lam&lt;'b', Lam&lt;'f', Lam&lt;'x', App&lt;App&lt;Ref&lt;'a'&gt;, Ref&lt;'f'&gt;&gt;, App&lt;App&lt;Ref&lt;'b'&gt;, Ref&lt;'f'&gt;&gt;, Ref&lt;'x'&gt;&gt;&gt; &gt;&gt;&gt;&gt; Plus; // Sum = (+ 1 2) typedef App&lt;App&lt;Plus, One&gt;, Two&gt; Sum; // Result := (Sum +1 =0) typedef App&lt;App&lt;Sum, Inj&lt;Succ&gt;&gt;, Inj&lt;Zero&gt;&gt; Output; typedef Eval&lt;Output, NullEnv&gt;::value Result; std::cout &lt;&lt; Result::interpretation; }</span></span></span></span></code> </pre><br><pre> <code class="hljs ruby">ilammy@ferocity ~<span class="hljs-regexp"><span class="hljs-regexp">/dev/tlc</span></span> $ g++ -std=c++<span class="hljs-number"><span class="hljs-number">11</span></span> lc.cpp ilammy@ferocity ~<span class="hljs-regexp"><span class="hljs-regexp">/dev/tlc</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br><h4>  Global environment and free variables </h4>  I think you have already noticed that in <code>main()</code> we always call <code>Eval</code> with an empty environment, and all the necessary abstractions are inline.  But this is not at all necessary.  If we pass some environment to the first call of <code>Eval</code> , then it will play the role of a global one for the term being calculated: it is this that sets the values ​​of free variables - those that are not connected with anything by lambda abstractions. <br><br>  However, it is impossible to just take and put the function-type in the environment.  In the environments there are <i>values</i> , so first they need to be calculated ( <a href="https://gist.github.com/ilammy/4860e7743fd4fe9693a8/7bd3b13bcbbebcb26fd2bd2fa2c970ced2b68734">full code</a> ): <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { /*  One, Two, Plus  */ // Unchurch = λn.(n +1 =0),     int typedef Lam&lt;'n', App&lt;App&lt;Ref&lt;'n'&gt;, Ref&lt;'I'&gt;&gt;, Ref&lt;'O'&gt;&gt;&gt; Unchurch; // Result := (Unchurch (+ 1 2)) typedef Eval&lt;App&lt;Ref&lt;'U'&gt;, App&lt;App&lt;Ref&lt;'+'&gt;, Ref&lt;'1'&gt;&gt;, Ref&lt;'2'&gt;&gt;&gt;, Bind&lt;'+', typename Eval&lt;Plus, NullEnv&gt;::value, Bind&lt;'1', typename Eval&lt;One, NullEnv&gt;::value, Bind&lt;'2', typename Eval&lt;Two, NullEnv&gt;::value, Bind&lt;'U', typename Eval&lt;Unchurch, Bind&lt;'I', Succ, Bind&lt;'O', Zero, NullEnv&gt;&gt; &gt;::value, NullEnv&gt;&gt;&gt;&gt; &gt;::value Result; std::cout &lt;&lt; Result::interpretation; }</span></span></span></span></code> </pre><br>  Environments represent interpreter memory.  If it were a compiler with a linker, then there would have to be <i>compiled</i> functions.  In the case of the interpreter, they are in a “predicted” state — already passed through <code>Eval</code> . <br><br>  You should also pay attention to the free variables <code>Unchurch</code> .  They enter the environment without any <code>Inj</code> around.  This is also because in the memory of the interpreter these values ​​are represented in this way.  <code>Inj</code> needed only for recording them <i>in the text of programs</i> (in lambda terms). <br><br><br><h3>  Macros </h3><img src="//habrastorage.org/files/4b2/17b/8f1/4b217b8f158b48b18146d087eff74da5.png" alt="Alien Lisp logo" align="left"><br>  Has anyone not had enough to write the functions of several arguments manually to curry them?  And all these constant <code>Ref&lt;'foo'&gt;</code> ? <br><br>  And by the way, even in lambda calculus, convenient abbreviations have been adopted: <table><tbody><tr><th>  Before </th><th>  After </th></tr><tr><td><img src="//habrastorage.org/files/0a1/d91/134/0a1d91134ee34055b9eb7e19437a98df.gif" alt="λxyz.B"></td><td><img src="//habrastorage.org/files/870/8fc/f59/8708fcf59331433d9fb377568965d6a8.gif" alt="λx.λy.λz.B"></td></tr><tr><td><img src="//habrastorage.org/files/22a/081/c04/22a081c04cd94f218c5f6e5055f5f10e.gif" alt="(fxyz)"></td><td><img src="//habrastorage.org/files/a4f/31a/825/a4f31a825c77440fa854641bfb6f6527.gif" alt="(((fx) y) z)"></td></tr></tbody></table>  Let's implement the same. <br><br>  There are many approaches to the implementation of macros.  For our case, it is worth choosing the simplest one: an external preprocessor.  "External" means that macro definitions are outside the program being processed.  That is, we will not introduce any new syntax for lambda calculus to express macros inside it;  it would be too difficult.  The macro processor is simply “set off” on the program and the output produces a pure lambda term - for example, the <abbr title="Meta-Object Compiler">MOC also</abbr> works in Qt. <br><br><h4>  Two phases </h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Up to this point in the life of our programs there was only one important event - the determination of their meaning with the help </font></font><code>Eval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Now it will add more macro expansion with </font></font><code>Expand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">All that is served at the entrance </font></font><code>Eval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you must first pass through </font></font><code>Expand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We introduce a new convenient function </font></font><code>Compute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that combines these actions:</font></font><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expand</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Compute</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Eval&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Expand&lt;Exp&gt;::result, Env&gt;::value value; };</code> </pre><br> <code>Expand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accepts only one argument. </font><font style="vertical-align: inherit;">We assume that this is a black box: at the entrance a program with macros, at the exit - without them. </font><font style="vertical-align: inherit;">In our simple case, we do not need any macroenvironment.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implementation of macros </font></font></h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now macros obviously need to be implemented inside </font></font><code>Expand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We need some </font></font><code>Lam_</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>App_</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that are disclosed as follows:</font></font><table><tbody><tr><th>  Before </th><th>  After </th></tr><tr><td> <code>Lam_&lt;'x', 'y', ..., 'z', B&gt;</code> </td> <td> <code>Lam&lt;'x', Lam&lt;'y', ..., Lam&lt;'z', B&gt;...&gt;&gt;</code> </td> </tr><tr><td> <code>App_&lt;A, B, C, ..., Z&gt;</code> </td> <td> <code>App&lt;...App&lt;App&lt;A, B&gt;, C&gt;, ..., Z&gt;</code> </td> </tr><tr><td> <code>App_&lt;'a', ...&gt;</code> </td> <td> <code>App_&lt;Ref&lt;'a'&gt;, ...&gt;</code> </td> </tr></tbody></table><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In C ++ 11, templates of arbitrary arity appeared, which makes the task easier. </font><font style="vertical-align: inherit;">Owners of C ++ compilers can only suffer and write a thousand and one specializations: </font></font><code>Lam_2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for two arguments, </font></font><code>Lam_3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for three, </font></font><code>App_4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for four, etc. Well, or pervert even harder and repeat everything shown below with the help of the native C ++ preprocessor .</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lam_ </font></font></h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">True, even the C ++ 11 templates have their limitations, so the syntax will have to be cut a little more. </font><font style="vertical-align: inherit;">A bundle of arguments can only be the last argument of the template, so for this </font></font><code>Lam_</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you need to enter a special "argument holder":</font></font><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... Vars&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lam_</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expand</span></span></span><span class="hljs-class">&lt;Lam_&lt;Args&lt;Var&gt;, Exp&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Expand&lt;Lam&lt;Var, Exp&gt;&gt;::result result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... Vars, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expand</span></span></span><span class="hljs-class">&lt;Lam_&lt;Args&lt;Var, Vars...&gt;, Exp&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Lam&lt;Var, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Expand&lt;Lam_&lt;Args&lt;Vars...&gt;, Exp&gt;&gt;::result&gt; result; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pay attention to repeated calls </font></font><code>Expand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the process of disclosure. </font><font style="vertical-align: inherit;">They are necessary, as </font></font><code>Expand&lt;...&gt;::result</code> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> must </font><i><font style="vertical-align: inherit;">always</font></i><font style="vertical-align: inherit;"> be a pure lambda term </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">without</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> macros.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> App_ </font></font></h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, C ++ 11 templates do not allow to mix arguments-numbers and type-arguments in a bundle, so you </font></font><code>App_</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will have two corresponding options.</font></font> Pechalka. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementations </font></font><code>App_s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(for characters) and </font></font><code>App_i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(for types) are more voluminous, so the explanations and code are hidden under the spoiler.</font></font><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">      .       ,   -.     .    C++11   map  ,    ,        . ( <i> , map  ? Anyone?</i> ) <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nil</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">First</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rest</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RefList</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>    ,     .          <code>Ref</code> : <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... Vars&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToRefList_s</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToRefList_s</span></span></span><span class="hljs-class">&lt;Var&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> RefList&lt;Ref&lt;Var&gt;, Nil&gt; result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... Vars&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToRefList_s</span></span></span><span class="hljs-class">&lt;Var, Vars...&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> RefList&lt;Ref&lt;Var&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ToRefList_s&lt;Vars...&gt;::result&gt; result; };</code> </pre><br>      ,    .          . <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exps</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToRefList_i</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToRefList_i</span></span></span><span class="hljs-class">&lt;Exp&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> RefList&lt;Exp, Nil&gt; result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exps</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToRefList_i</span></span></span><span class="hljs-class">&lt;Exp, Exps...&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> RefList&lt;Exp, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ToRefList_i&lt;Exps...&gt;::result&gt; result; };</code> </pre><br>       .  <code>App_wrap</code>      —    !     <code>RefList</code>   «» <code>App</code> .    —   «» <code>App</code> ,   —     <code>RefList</code> . <br><br>    <code>RefList</code>    .        . ,    (  <code>Nil</code> ). <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Apps</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RefList</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App_wrap</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App_wrap</span></span></span><span class="hljs-class">&lt;Nil, RefList&lt;A, RefList&lt;D, R&gt;&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> App_wrap&lt;App&lt;A, D&gt;, R&gt;::result result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Apps</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App_wrap</span></span></span><span class="hljs-class">&lt;Apps, RefList&lt;A, Nil&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> App_wrap&lt;App&lt;Apps, A&gt;, Nil&gt;::result result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Apps</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App_wrap</span></span></span><span class="hljs-class">&lt;Apps, RefList&lt;A, D&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> App_wrap&lt;App&lt;Apps, A&gt;, D&gt;::result result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Apps</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App_wrap</span></span></span><span class="hljs-class">&lt;Apps, Nil&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Apps result; };</code> </pre><br>  ? ,   . </div></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ultimately, we write the following simple definitions. </font><font style="vertical-align: inherit;">They call the functions examined under the spoiler, which do all the dirty work, after which they themselves once again drive the result through </font></font><code>Expand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so that the output does not have undisclosed macros.</font></font><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... Exps&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App_s</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exps</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App_i</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... Exps&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expand</span></span></span><span class="hljs-class">&lt;App_s&lt;Exps...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Expand&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> App_wrap&lt;Nil, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ToRefList_s&lt;Exps...&gt;::result &gt;::result &gt;::result result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exps</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expand</span></span></span><span class="hljs-class">&lt;App_i&lt;Exps...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Expand&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> App_wrap&lt;Nil, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ToRefList_i&lt;Exps...&gt;::result &gt;::result &gt;::result result; };</code> </pre><br><h6>  Rest </h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And last, but important addition. </font><font style="vertical-align: inherit;">The expander must correctly handle embedded language constructs, expanding macros where they can meet:</font></font><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expand</span></span></span><span class="hljs-class">&lt;Ref&lt;Var&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Ref&lt;Var&gt; result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expand</span></span></span><span class="hljs-class">&lt;Lam&lt;Var, Exp&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Lam&lt;Var, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Expand&lt;Exp&gt;::result&gt; result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fun</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expand</span></span></span><span class="hljs-class">&lt;App&lt;Fun, Arg&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> App&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Expand&lt;Fun&gt;::result, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Expand&lt;Arg&gt;::result&gt; result; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Who noticed in the work </font></font><code>Expand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parallels with </font></font><code>Eval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that fellow. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href="https://gist.github.com/ilammy/4860e7743fd4fe9693a8/7ae4451a5378998bedd30988fb7918c00c28697a"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with macros support.)</font></font><br><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recursion </font></font></h3><img src="//habrastorage.org/files/80d/455/311/80d455311d334be7b0eea041948d222c.png" alt="Self description" title="The contents of any panel are dependent on each panel including itself.  Each node has a loop.  The mouseover has two hundred and forty-forty characters." align="right"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having said about the Turing completeness of the obtained calculator, we somehow avoided one moment, being satisfied with simple arithmetic. After all, Turing-complete system allows you to express </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cycles</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! Consider cyclic calculations on the example </font></font><font color="SlateGray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drum roll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> factorial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In lambda calculus, recursion cannot be expressed directly, since abstractions have no names. To record the recursion in its usual form, you need a magic operator </font></font><code>Rec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is similar to the usual abstraction </font></font><code>Lam</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but creates abstractions with an additional argument - a reference to the abstraction itself. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, clever mathematicians found a way around this limitation: the so-called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y-combinator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allows to express recursive functions as solutions of functional equations of fixed points. What is it and how the previous sentence is deciphered can be read elsewhere, but now it is important that the Y-combinator is written like this:</font></font><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Y = λf.(λx.f (xx)) (λx.f (xx)) typedef Lam&lt;'f', App&lt;Lam&lt;'x', App&lt;Ref&lt;'f'&gt;, App_s&lt;'x', 'x'&gt;&gt;&gt;, Lam&lt;'x', App&lt;Ref&lt;'f'&gt;, App_s&lt;'x', 'x'&gt;&gt;&gt;&gt;&gt; Y;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To express with its help the recursive function that calculates the factorial, you first need to determine the mathematical and logical operators necessary for it: multiplication, subtraction, comparison. Also, a more convenient way to write Church numbers does not hurt. All definitions can be viewed </font></font><a href="https://gist.github.com/ilammy/4860e7743fd4fe9693a8/1f4dcb66267c0790a284387e780c3a513de8e450"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (the last four sections), they are standard definitions of similar functions in lambda calculus. (If you have mastered reading up to this point, then there should be no problems with understanding their implementation.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ultimately, all the necessary definitions are associated with the appropriate symbols and fit into the environment </font></font><code>StandardLibrary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Now you can beautifully and conveniently write the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generating function</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for factorial:</font></font><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// F = λfn.if (= n 0) 1 // (* n (f (- n 1))) typedef Lam_&lt;Args&lt;'f', 'n'&gt;, App_i&lt;Ref&lt;'?'&gt;, App_s&lt;'=', 'n', '0'&gt;, Ref&lt;'1'&gt;, App_i&lt;Ref&lt;'*'&gt;, Ref&lt;'n'&gt;, App_i&lt;Ref&lt;'f'&gt;, App_s&lt;'-', 'n', '1'&gt;&gt;&gt; &gt; &gt; Fact_gen;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It differs from the usual unary one in that it takes an additional argument </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">— the function of calculating the factorial (already usual). </font><font style="vertical-align: inherit;">The role of the Y-combinator is to </font></font><code>Fact_gen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determine a function </font><font style="vertical-align: inherit;">from the generating function </font><font style="vertical-align: inherit;">so </font></font><code>Fact</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that </font></font><code>App&lt;Fact_gen, Fact&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">≡ </font></font><code>Fact</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is called: “find a fixed point”. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ok, let's try to apply all this together, calculating (YF 1) - factorial of one:</font></font><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { /*  Y  Fact_gen */ typedef Compute&lt;App&lt;Ref&lt;'U'&gt;, App_i&lt;Y, Fact_gen, MakeChurch(1)&gt; &gt;, StandardLibrary&gt;::value Result; std::cout &lt;&lt; Result::interpretation; }</span></span></span></span></code> </pre><br><pre> <code class="hljs ruby">ilammy@ferocity ~<span class="hljs-regexp"><span class="hljs-regexp">/dev/tlc</span></span> $ g++ -std=c++<span class="hljs-number"><span class="hljs-number">11</span></span> lc.cpp <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-params"><span class="hljs-params">| wc -c 64596</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Not compiled. </font><font style="vertical-align: inherit;">And the error log at 64 kilobytes.</font></font> Why? <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's all about calculation. A normal Y-combinator is written based on the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> calculation order. In it, a piece </font></font><code>f (xx)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will first cause a substitution </font></font><code>(xx)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the body </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and only then, if it is needed, the value </font></font><code>(xx)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be calculated (also with a lazy substitution). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case of an applicative order (call by value), this expression is evaluated immediately, which obviously leads to an infinite loop (if you look at what the argument x should be equal to). For example, the Scheme lambda interpreter, shown earlier, loops. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you decrypt the log spat out gcc, then it says there that:</font></font><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Apply</span></span></span><span class="hljs-class">&lt; Closure&lt; Lam&lt;'x', App&lt;Ref&lt;'f'&gt;, App&lt;Ref&lt;'x'&gt;, Ref&lt;'x'&gt;&gt;&gt;&gt;, Bind&lt;'f', Closure&lt;Fact_gen, StandardLibrary&gt;, StandardLibrary &gt; &gt;, Closure&lt; Lam&lt;'x', App&lt;Ref&lt;'f'&gt;, App&lt;Ref&lt;'x'&gt;, Ref&lt;'x'&gt;&gt;&gt;&gt;, Bind&lt;'f', Closure&lt;Fact_gen, StandardLibrary&gt;, StandardLibrary &gt; &gt; &gt;</span></span></code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not define the type </font></font><code>result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, this call does not make sense. The compiler saw and broke an infinite pattern substitution loop, which is undefined by the standard ( </font></font><abbr title="temp.inst"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14.7.1 / 15</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ templates also perform calculations in the applicative order, because the function call </font></font><code>typename Eval&lt;Exp, Env&gt;::value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is instantiation of the template. Instantiation </font></font><code>Eval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obviously requires instantiation </font></font><code>Exp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>Env</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In languages ​​with an applicative order of computation, a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z-combinator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> should be used </font><font style="vertical-align: inherit;">- a modification of the Y-combinator, in which the expression is </font></font><code>(xx)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wrapped in an abstraction, which prevents its premature calculation:</font></font><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Z = λf.(λx.f (λy.xxy)) (λx.f (λy.xxy)) typedef Lam&lt;'f', App&lt;Lam&lt;'x', App&lt;Ref&lt;'f'&gt;, Lam&lt;'y', App_s&lt;'x', 'x', 'y'&gt;&gt;&gt;&gt;, Lam&lt;'x', App&lt;Ref&lt;'f'&gt;, Lam&lt;'y', App_s&lt;'x', 'x', 'y'&gt;&gt;&gt;&gt;&gt;&gt; Z;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now compilation errors are not visible, as well as its end. </font><font style="vertical-align: inherit;">Obviously, this time we outwitted the compiler and made it infinitely recursively reveal something. </font><font style="vertical-align: inherit;">It is reasonable to assume that this can only be a recursive call of factorial.</font></font><br><br>  Stop!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And when does the compiler have to stop substituting factorial for itself? </font><font style="vertical-align: inherit;">I mean, when do we want him to stop doing that? </font><font style="vertical-align: inherit;">In theory, the operator is responsible for this </font></font><code>If</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: when the factorial argument is zero, you need to return one, and not try to make a recursive call. </font><font style="vertical-align: inherit;">How is it determined </font></font><code>If</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Lam_&lt;Args&lt;<span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'t'</span></span>, <span class="hljs-string"><span class="hljs-string">'f'</span></span>&gt;, App_s&lt;<span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'t'</span></span>, <span class="hljs-string"><span class="hljs-string">'f'</span></span>&gt;&gt; If;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As an abstraction. It seems to be all right, the standard definition for Boolean Church constants ... That's just it is also designed for the normal reduction order! In the applicative order, it </font></font><code>If</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calculates both branches immediately with the condition, and only after that does it make a choice. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem can be solved in a manner similar to the Z-combinator: wrap the deferred calculations into an abstraction. However, in the case of the </font></font><code>If</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">condition to wrap just not necessary. Therefore, unfortunately, If cannot be a convenient function in applicative languages. However, it can be made a macro!</font></font><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cond</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Then</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Else</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">If</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cond</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Then</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Else</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expand</span></span></span><span class="hljs-class">&lt;If&lt;Cond, Then, Else&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Expand&lt; App_i&lt;Cond, Lam&lt;<span class="hljs-string"><span class="hljs-string">'u'</span></span>, Then&gt;, Lam&lt;<span class="hljs-string"><span class="hljs-string">'u'</span></span>, Else&gt;, Lam&lt;<span class="hljs-string"><span class="hljs-string">'u'</span></span>, Ref&lt;<span class="hljs-string"><span class="hljs-string">'u'</span></span>&gt;&gt; &gt; &gt;::result result; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strictly speaking, a variable </font></font><code>'u'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must not coincide with any free variable </font></font><code>Then</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>Else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Our macrosystem does not provide such an opportunity (hygiene). </font><font style="vertical-align: inherit;">In general, we have a very limited number of variable names. </font><font style="vertical-align: inherit;">Therefore, we will reserve an identifier </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as a non-matching identifier:</font></font><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lookup</span></span></span><span class="hljs-class">&lt;Var, NullEnv&gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lookup</span></span></span><span class="hljs-class">&lt;0, Env&gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Var, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Val</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lookup</span></span></span><span class="hljs-class">&lt;Var, Bind&lt;Var, Val, Env&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Val result; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now finally factorial will work. </font><font style="vertical-align: inherit;">( </font></font><a href="https://gist.github.com/ilammy/4860e7743fd4fe9693a8/57b8ea15d5aa4d3ae3f8ecd16a0ca232838f920e"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .)</font></font><br><br><pre> <code class="hljs ruby">ilammy@ferocity ~<span class="hljs-regexp"><span class="hljs-regexp">/dev/tlc</span></span> $ time g++ -std=c++<span class="hljs-number"><span class="hljs-number">11</span></span> lc.cpp -DARG=<span class="hljs-number"><span class="hljs-number">6</span></span> real 0m12.<span class="hljs-number"><span class="hljs-number">630</span></span>s user 0m11.<span class="hljs-number"><span class="hljs-number">979</span></span>s sys 0m<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">466</span></span>s ilammy@ferocity ~<span class="hljs-regexp"><span class="hljs-regexp">/dev/tlc</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">720</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, I could not wait for the calculation of factorial seven, let alone that on 32-bit systems the compiler simply dies from a stack overflow. </font><font style="vertical-align: inherit;">But still!..</font></font><br><br><div style="text-align:center;"><img src="//habrastorage.org/files/ebd/8c8/5a5/ebd8c85a5938466e84afb89c5f53034b.jpg"></div><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is probably no practical engineering benefit from this interpreter, but the idea itself is amazing. C ++ templates are from “inadvertently turing-full” things in theoretical computer science. A similar feeling came to me only when I learned that the paging memory management subsystem of x86 processors is also Turing-complete. If this interpreter allows you to perform calculations without performing any C ++ operator, then the MMU allows you to perform calculations without performing any machine program instructions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, </font><font style="vertical-align: inherit;">I have finished reading </font></font><abbr title="Design Concepts in Programming Languages"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DCPL</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so far only up to the eighth chapter, therefore writing the interpreter of a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">typed</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lambda calculus is left to the readers as an exercise. I still have too weak mathematical preparation for this.</font></font><br><br> <i>PS  ,    ,    : «     ,      ».</i> </div><p>Source: <a href="https://habr.com/ru/post/218341/">https://habr.com/ru/post/218341/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../218329/index.html">GosLinux from the Federal Court Bailiff Service</a></li>
<li><a href="../218331/index.html">Remember all: neuroprogramming for preschoolers</a></li>
<li><a href="../218333/index.html">Google Project Ara Modular Smartphone: Project News</a></li>
<li><a href="../218335/index.html">Two scanners, oscilloscope, electric guitar: computer music Bit-52's</a></li>
<li><a href="../218339/index.html">ZX Spectrum Memories - homemade digital camera from RAM chip</a></li>
<li><a href="../218343/index.html">2ndb - notebook for records, which studies and then improves the person who writes in it</a></li>
<li><a href="../218345/index.html">Analysis paralysis: you know too much to just write code</a></li>
<li><a href="../218347/index.html">Create apps for Office 365 Developer Site</a></li>
<li><a href="../218351/index.html">A / B Analysis for beginners. How to understand exactly what works for you?</a></li>
<li><a href="../218353/index.html">History of space cooperation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>