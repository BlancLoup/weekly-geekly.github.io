<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Great review testing of programming languages</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, once again, I worked with the 2nd year students on a 2-semester discipline "Algorithmic Languages". A survey of several dozen programming la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Great review testing of programming languages</h1><div class="post__text post__text-html js-mediator-article">  Recently, once again, I worked with the 2nd year students on a 2-semester discipline "Algorithmic Languages".  A survey of several dozen programming languages.  One of the students, Vadim Shukalyuk, wanted to get to know them better, to get a clearer picture of each of them.  He advised him to do a little research.  Than and carried away.  I offer my report on the work done in a few months with him. <br><br>  Each programming language has its advantages and disadvantages.  One of the most important characteristics of a translator from any language is the speed of program execution.  It is very difficult or even impossible to get an accurate estimate of this speed of execution.  The resource <a href="http://benchmarksgame.alioth.debian.org/">http://benchmarksgame.alioth.debian.org/</a> offers a game form to test this speed for various tasks.  But the number of languages ‚Äã‚Äãrepresented on this resource is rather small.  The maximum capacity of the stack, the critical value for recursive calculations is easier to check, but it can vary in different versions of the translator and be dependent on the system settings. <br><br>  The following translators were tested: C (gcc, clang, icc), assembler (x86, x86-64), Java (OpenJDK), Pascal (fpc), Javascript (Google Chrome, Mozilla Firefox), Lisp (sbcl, clisp), Erlang, Haskel (ghc, hugs), dino [1], auk (gawk, mawk, busybox), lua, ruby, basic (gambas, libre office), python-2, pi-ah-pi, postscript (gs), prologue ( swipl, gprolog), pearl, metapost, T <sub>E</sub> X, tickle, bash.  We investigated the actual execution speed of several small, but time-consuming algorithms, and: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  quality optimization of some translators; </li><li>  features when working with Intel and AMD processors; </li><li>  limit number of recursive calls (stack capacity). </li></ul><br><a name="habracut"></a><br>  As the first task on which all the translators were tested, the calculation of the Fibonacci number by double recursion was chosen according to the definition: the numbers with numbers 1 and 2 are units, and the next ones are the sum of the two previous ones.  This algorithm has several attractive features: <br><br><ol><li>  If the calculation time of the nth number t, then (n + 1) -th - t * œÜ, where œÜ is the golden ratio equal to (‚àö 5 + 1) / 2; </li><li>  The number itself calculated by ne is equal to the value œÜ <sup>n</sup> / ‚àö5 rounded to the nearest integer; </li><li>  Calculating fib (n + 1) requires the nth call nesting. </li></ol><br>  The first feature allows for a short time to test translators, the speed of which differ hundreds of thousands of times.  The second feature allows you to quickly check the correctness of the calculations.  The third feature theoretically allows you to explore the capacity of the stack, but due to the fact that the calculation at n&gt; 50 becomes very slow even on a supercomputer, it is not possible to practically use this feature. <br><br>  The following table 1 in the second column indicates the name of the language, the name of the compiler and its version and, if used, the option to optimize the generated code.  The third column shows the relative computation time on an AMD Phenom II x4 3.2 GHz processor.  Tests were conducted on the AMD FX-6100 at the same frequency, but their results differ little from those given.  The calculation time in the Bash language is taken as a unit, so the calculation on the Erlang is about 20,000 times faster than Bash.  The 4th column shows the relative computation time on an Intel Core i3-2100 3.1 GHz processor.  Since the comparison of processors was not the purpose of the study, part of the translators were not tested on the Intel platform.  In the fifth, the upper estimate (accuracy 10%) of the maximum number of recursive calls supported by the compiler when calculating ack (1,1, n) on a computer with 8 GB of RAM with a system stack size (ulimit -s) is 8192 KB.  Some translators use their own settings, which determine the size of the stack used - the default values ‚Äã‚Äãfor the selected version of the translator are always used.  Measurements were carried out in the Linux system, but their results should not change when switching to another OS.  The data is sorted by the 3rd column.  All sources can be viewed <a href="http://litwr.atspace.com/compiler-test-sources.html">here</a> . <br><br>  Table 1 <br><table><tbody><tr><th>  N </th><th>  Tongue </th><th>  AMD </th><th>  Intel </th><th>  Stack </th></tr><tr><td>  one </td><td>  C / C ++ (gcc 4.7.2, -O5) </td><td>  354056 </td><td>  493533 </td><td>  790000 </td></tr><tr><td>  2 </td><td>  C / C ++ (clang 3.0-6.2, -O3) </td><td>  307294 </td><td></td><td>  270000 </td></tr><tr><td>  3 </td><td>  C / C ++ (icc 14.0.3, -fast) </td><td>  250563 </td><td>  232665 </td><td>  530000 </td></tr><tr><td>  four </td><td>  Assembler x86-64 </td><td>  243083 </td><td>  271443 </td><td>  350000 </td></tr><tr><td>  five </td><td>  Assembler x86 </td><td>  211514 </td><td>  301603 </td><td>  700,000 </td></tr><tr><td>  6 </td><td>  Java (OpenJDK 1.7.0_25) </td><td>  186401 </td><td>  239659 </td><td>  8,000 </td></tr><tr><td>  7 </td><td>  Pascal (fpc 2.6.0, -O3) </td><td>  170604 </td><td>  186401 </td><td>  180000 </td></tr><tr><td>  eight </td><td>  C / C ++ (gcc 4.7.2, -O0) </td><td>  159672 </td><td>  173261 </td><td>  180000 </td></tr><tr><td>  9 </td><td>  C / C ++ (clang 3.0-6.2, -O0) </td><td>  146726 </td><td></td><td>  110000 </td></tr><tr><td>  ten </td><td>  C / C ++ (icc 14.0.3, -O0) </td><td>  136862 </td><td>  156602 </td><td>  530000 </td></tr><tr><td>  eleven </td><td>  Javascript (Mozilla Firefox 25) </td><td>  121979 </td><td></td><td>  4200 </td></tr><tr><td>  12 </td><td>  Javascript (Google Chrome 31) </td><td>  92850 </td><td></td><td>  10,000 </td></tr><tr><td>  13 </td><td>  Lisp (sbcl 1.0.57) </td><td>  54925 </td><td>  51956 </td><td>  31,000 </td></tr><tr><td>  14 </td><td>  Erlang (5.9.1) </td><td>  19845 </td><td>  18589 </td><td>  there is no limit </td></tr><tr><td>  15 </td><td>  Haskell (ghc 7.4.1, -O) </td><td>  18589 </td><td>  22946 </td><td>  260000 </td></tr><tr><td>  sixteen </td><td>  Awk (mawk 1.3.3) </td><td>  6621 </td><td>  6306 </td><td>  44000 </td></tr><tr><td>  17 </td><td>  Lua (5.2) </td><td>  6420 </td><td>  7075 </td><td>  150000 </td></tr><tr><td>  18 </td><td>  Ruby (1.9.3) </td><td>  5297 </td><td>  6969 </td><td>  6600 </td></tr><tr><td>  nineteen </td><td>  Dino (0.55) </td><td>  5024 </td><td>  6420 </td><td>  190000 </td></tr><tr><td>  20 </td><td>  Basic (Gambas 3.1.1) </td><td>  3968 </td><td>  4373 </td><td>  26,000 </td></tr><tr><td>  21 </td><td>  Python (2.7.3) </td><td>  3678 </td><td>  4013 </td><td>  1000 </td></tr><tr><td>  22 </td><td>  PHP (5.4.4) </td><td>  2822 </td><td>  3720 </td><td>  there is no limit </td></tr><tr><td>  23 </td><td>  Awk (gawk 4.0.1) </td><td>  2648 </td><td>  2547 </td><td>  there is no limit </td></tr><tr><td>  24 </td><td>  Postscript (gs 9.05) </td><td>  2355 </td><td>  3246 </td><td>  5000 </td></tr><tr><td>  25 </td><td>  Prolog (swipl 5.10.4) </td><td>  1996 </td><td>  2407 </td><td>  2300000 </td></tr><tr><td>  26 </td><td>  Perl (5.14.2) </td><td>  1516 </td><td>  1670 </td><td>  there is no limit </td></tr><tr><td>  27 </td><td>  Prolog (gprolog 1.3.0) </td><td>  1116 </td><td>  1320 </td><td>  120,000 </td></tr><tr><td>  28 </td><td>  Lisp (clisp 2.49) </td><td>  998 </td><td>  1023 </td><td>  5500 </td></tr><tr><td>  29 </td><td>  Awk (busybox 1.20.2) </td><td>  981 </td><td>  1113 </td><td>  18,000 </td></tr><tr><td>  thirty </td><td>  T <sub>E</sub> X (3.1415926) </td><td>  239 </td><td>  333 </td><td>  3400 </td></tr><tr><td>  31 </td><td>  Metapost (1.504) </td><td>  235 </td><td>  470 </td><td>  &lt;4100 </td></tr><tr><td>  32 </td><td>  Tcl (8.5) </td><td>  110 </td><td>  123 </td><td>  1000 </td></tr><tr><td>  33 </td><td>  Haskell (hugs 98.200609.21) </td><td>  82 </td><td>  121 </td><td>  17,000 </td></tr><tr><td>  34 </td><td>  Basic (LibreOffice 3.5.4.2) </td><td>  20 </td><td>  35 </td><td>  6500 </td></tr><tr><td>  35 </td><td>  bash (4.2.37) </td><td>  one </td><td>  0.77 </td><td>  600 </td></tr></tbody></table><br><br>  The second task is the Ackermann function in the form, when all arithmetic operations are reduced to it, i.e. ack (1, x, y) = x + y, ack (2, x, y) = x * y, ack ( 3, x, y) = x <sup>y</sup> , ack (4, x, y) - tetration of x and y, etc. <br><br><img src="https://habrastorage.org/files/a4c/1d4/a26/a4c1d4a26171482eb372cff347c1e4c0.png"><br><br>  With the growth of n, this function grows very quickly (the number ack (5,5,5) is so large that the number of digits in the order of this number many times exceeds the number of atoms in the observable part of the Universe), but it is considered very slowly.  The latter property is theoretically convenient for testing performance.  However, the calculation of this function requires a significant number of recursive calls and most of the tested languages ‚Äã‚Äãwere not able to support them for calculations that have a noticeable duration.  It is known that the calculation of this function cannot be reduced to iteration.  The calculation for this problem allowed us to investigate the maximum capacity of the stack of the studied languages: calculating ack (1,1, n-1) requires the n-th call nesting and is very fast.  The following table 2 presents the results of the calculation of the ack (5,2,3) pentation, for those languages ‚Äã‚Äãwhose stack could withstand it (call nesting 65539) withstand.  Per unit of speed, the operating time of gcc with the option -O5 is chosen, that is, php is about 420 times slower. <br><br>  Table 2 <br><table border="1"><tbody><tr><td>  gcc -O5 </td><td>  one </td></tr><tr><td>  asm x86 </td><td>  2.15 </td></tr><tr><td>  icc -fast </td><td>  2.18 </td></tr><tr><td>  asm x86-64 </td><td>  2.36 </td></tr><tr><td>  clang -O3 </td><td>  2.76 </td></tr><tr><td>  fpc -O3 </td><td>  4.44 </td></tr><tr><td>  gcc -O0 </td><td>  7.75 </td></tr><tr><td>  icc -O0 </td><td>  8.36 </td></tr><tr><td>  clang -O0 </td><td>  9.64 </td></tr><tr><td>  Erlang </td><td>  18.51 </td></tr><tr><td>  ghc -O </td><td>  50.18 </td></tr><tr><td>  lua </td><td>  122.55 </td></tr><tr><td>  php </td><td>  423.64 </td></tr><tr><td>  gawk </td><td>  433.82 </td></tr><tr><td>  swipl </td><td>  766.55 </td></tr><tr><td>  dino </td><td>  915.64 </td></tr></tbody></table><br><br>  The idea of ‚Äã‚Äãusing these two problems was borrowed from the work of B. V. Kernigan and R. Paik ‚ÄúUnix - Universal Programming Environment‚Äù, where it was used to test the hoc language [2]. <br><br>  Of course, with more complex calculations, using mostly standard library tools, the difference in the speed of the translators would be much smaller. <br><br>  Time was measured by the standard time command, and when it was impossible (javascript, office BASIC), tools built into the language were used. <br><br>  According to the study, the following conclusions were made, some of which turned out to be somewhat unexpected: <br><br><ol><li>  The speed of the programs on the assembler may be more than 50% slower than programs in C / C ++ compiled with maximum optimizations; </li><li>  The speed of a virtual Java byte-code machine often exceeds the speed of hardware with codes received by translators from high-level languages.  Java machine is inferior in speed only to assembler and the best optimizing translators; </li><li>  The compilation and execution speed of javascript programs in popular browsers is only 2-3 times lower than the best translators and even surpasses some quality compilers, certainly much more (more than 10 times) overtaking most translators of other scripting languages ‚Äã‚Äãand similar programs; </li><li>  The speed of the codes generated by the Intel C language compiler turned out to be noticeably lower than the GNU compiler and sometimes LLVM; </li><li>  The speed of x86-64 assembler codes may be less than that of similar x86 codes, by about 10%; </li><li>  Code optimization works best on an Intel processor; </li><li>  The speed of execution on an Intel processor was almost always higher, with the exception of the languages ‚Äã‚ÄãLisp, Erlang, Auk (gawk, mawk) and Bash.  The difference in speed according to Bash is most likely caused by different environment settings on the systems under test, and not the translator itself or the hardware itself.  Intel's advantage is especially noticeable on 32-bit codes; </li><li>  The stack of most tested languages, in particular, Java and javascript, support only a very limited number of recursive calls.  Some translators (gcc, icc, ...) allow you to increase the size of the stack by changing the variables of the runtime environment or parameter; </li><li>  In the considered versions of gawk, php, perl, bash, a dynamic stack is implemented, allowing you to use all the computer's memory.  But perl and, especially, bash use the stack so extensively that 8-16 GB is not enough to calculate ack (5,2,3).  In version 5.4.20, the php stack was limited to about 200,000 calls. </li></ol><br><br>  In conclusion, a few words from a student starting to master the art of programming. <br><br>  To write programs for the required calculations in any language, it is first necessary to understand how variables are declared in a particular language, how to build an if-else type construct, and how to organize recursion.  I began my work with a simple Pascal language, because at that time I knew it better than anyone.  After Pascal, I took on C, Java and Dino, since their syntax is about the same.  S turned out to be quite interesting, simple, and at the same time with intuitive operators.  Java seemed less convenient than C / C ++ - you need to write a lot of irrelevant things, such as could be taken by default.  Also strained the moment the need for the same names of the class and file.  Haskell left only positive emotions.  Convenient, clear and powerful.  PHP, a language for developing web applications, is very similar to C: you can simply paste code on C with minimal changes and everything will work as it should.  Erlang is similar in syntax to Haskell and a bit to Prolog.  Also quite pleasant and understandable language, no difficulties have arisen.  JavaScript syntax is similar to Java or C syntax. Visual Basic in both the office and GAMBAS versions has a somewhat awkward and inconvenient syntax, but in general, it was not very difficult with it.  Then, after acquiring knowledge of the base syntax C and Java, it came out pretty quickly to write code in Python, since Python is similar to C. No problems arose with Lua and its fairly powerful and flexible designs.  Awk also has a similar structure with C, and managed to master it pretty quickly.  There were some difficulties with a lisp, like a person who had previously studied C-like languages, for example, with a basic understanding of prefix notation.  Which, after a small expenditure on development, seemed very convenient, logical and beautiful.  After that, I switched to the Prolog logic programming language, which turned out to be specific, but very interesting and fundamental.  Ruby - a language with powerful support for object-oriented programming and with a very beautiful bright red ruby ‚Äã‚Äãon the icon turned out to be an excellent language: no extra brackets, semicolons, or other unnecessary characters.  One of the most memorable.  Although the python, not counting the designs of the PLO, no less concise.  Perl - although it is called the ‚Äúpearl‚Äù, the symbol of the language is the camel, which apparently is a reference to the fact that the camel is not very beautiful, but very hardy animal, able to perform hard work.  After Ruby again, putting dollars, brackets and semicolons was not very pleasant.  The syntax is in some places similar to the syntax of the Bash terminal shell language.  Then I took the assembler.  There were certain difficulties and the need to understand the operation of the processor and its registers.  There was no limit to surprise when it turned out that C copes with calculations faster than assembler, machine code!  There were no problems with Bash, even though you need to put a lot of dollars there, and when calculating and brackets.  The Metapost / Metafont language caused some problems - only numbers that are not larger than 4096 are supported there. Although its syntax is quite traditional.  The tickle (TCL) is also quite a traditional syntax, but line-oriented is also similar to bash semantics at first very confusing.  PostScript seemed the most difficult.  In this language, the syntax is very specific and without preparation, it is impossible to write anything intuitively, so I had to study the relevant literature and begin to train with the simplest programs.  PostScript was a real challenge: writing a double recursion with a postfix notation using only the stack, after getting used to all the tools and capabilities of Ruby and C was problematic.  Writing and testing Ackermann's postscript is like trying to paint a wall with a toothbrush.  But the first place in complexity is definitely occupied by T <sub>E</sub> X. I have not seen anything more difficult.  And without the direct help of a teacher, it would not have been possible to overcome this language. <br><br>  Curious were data on the size of the stack of languages.  The larger the stack of language, the greater the likelihood that he will be able to cope with the function of Akkerman.  But if a program in some language could not cope with the calculation of ack (5,2,3), this does not mean that the language is bad and inconvenient.  It is likely that this language could be created for other useful purposes, such as Metapost or Postscript. <br><br>  In general, the work seemed to me very interesting and super-cognitive, for example, writing the same logical turn in 20 different ways.  Also, understanding the principle of the processor registers and writing a double recursive function only with the help of a stack and three operations: add, delete and scroll the stack greatly expanded my horizons. <br><br>  To the teacher, some of the conclusions of his student seemed too categorical, but he decided to keep them as more fresh than their own. <br><br><hr><br>  [1] - A <a href="http://cocom.sourceforge.net/dinopage.html">programming language</a> developed in Russia.  Now its author is an employee of the Red Hat company, working to improve the collection of gcc compilers.  The latest version of Dino was released in 2007. <br>  [2] - This language was also tested, showing a speed result between mawk and ghc. </div><p>Source: <a href="https://habr.com/ru/post/254121/">https://habr.com/ru/post/254121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254111/index.html">Winchester speaker</a></li>
<li><a href="../254113/index.html">How to create and earn SaaS | Part 16 | Own mobile network WI-FI</a></li>
<li><a href="../254115/index.html">Binding and xaml markup extensions using localization as an example</a></li>
<li><a href="../254117/index.html">Servers for business: energy efficiency matters</a></li>
<li><a href="../254119/index.html">The warden for the freelancer: choose the system of accounting of working time</a></li>
<li><a href="../254123/index.html">Why bash script or carriage return did not work</a></li>
<li><a href="../254127/index.html">The Legend of Temptation: How to use Python to automate iOS</a></li>
<li><a href="../254129/index.html">I will calculate you over the networks: use the API of the largest social networks for my own selfish purposes</a></li>
<li><a href="../254131/index.html">Dedovskoye UX design: coder - pest</a></li>
<li><a href="../254133/index.html">Prologue - a declarative language capable of solving any rebuses and proving theorems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>