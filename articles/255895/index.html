<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>10 major mistakes when developing on Node.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Since the advent of Node.js, they both criticize and extol it. Disputes about the advantages and disadvantages of this tool do not subside and probabl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>10 major mistakes when developing on Node.js</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/12f/0cf/a7a/12f0cfa7af444b7d8b5927c9c5944e79.jpg"><br><br>  Since the advent of Node.js, they both criticize and extol it.  Disputes about the advantages and disadvantages of this tool do not subside and probably will not subside in the near future.  However, we often lose sight of the fact that criticism of any language or platform is based on the problems that arise, depending on how we use these platforms.  Regardless of how much Node.js complicates writing safe code and facilitates its parallelization, the platform has been around for quite some time, and a huge number of reliable and complex web services have been created on it.  All of them are well scaled and have proved their stability in practice. <br><br>  But, like any platform, Node.js is not immune from the mistakes of the developers themselves.  In some cases, performance drops, in others - the system becomes almost unusable.  And in this post I would like to consider the 10 most frequent mistakes that developers make with insufficient experience with Node.js. <br><a name="habracut"></a><br><h1>  Error one: blocking the event loop </h1><br>  JavaScript in Node.js (as in the browser) provides a single-threaded environment.  This means that two or more parts of your application cannot run simultaneously.  Parallelization is carried out by asynchronous processing of I / O operations.  For example, a Node.js query to a database for a document allows Node.js to pay attention to another part of the application: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="html hljs xml">//       .    Node.js      .. db.User.get(userId, function(err, user) { // ..   ,        })</code> </pre> <br><img src="https://habrastorage.org/files/1b0/20f/105/1b020f1057484ef8af65f73f624d8356.jpg"><br><br>  However, a piece of processor-occupying code can block a cycle of events, forcing thousands of connected clients to wait for their execution to complete.  An example of such code is an attempt to sort a very large array: <br><br><pre> <code class="html hljs xml">function sortUsersByAge(users) { users.sort(function(a, b) { return a.age <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">b.age</span></span></span><span class="hljs-tag"> ? </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">-1</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span><span class="hljs-tag"> }) }</span></span></code> </pre><br>  A call to the sortUsersByAge function is unlikely to create problems in the case of a small array.  But when working with a large array, this will drastically reduce overall performance.  There may be no problems if this operation is urgently needed, and you are sure that no one else expects a cycle of events (say, if you are doing a tool launched from the command line, and no asynchronous execution is needed).  But for the Node.js server that serves thousands of clients at the same time, this approach is unacceptable.  If this array of users is retrieved directly from the database, then the best solution would be to extract it already sorted.  If the event cycle is blocked by the calculation cycle of the total result of a large number of financial transactions, then this work can be delegated to some external executor so as not to block the event cycle. <br><br>  Unfortunately, there is no silver bullet for solving problems of this type, and in each case an individual approach is needed.  The main thing is not to overload the processor as part of the execution of the Node.js instance, which works in parallel with several clients. <br><br><h1>  Error two: callback call more than once </h1><br>  The work of JavaScript is based on callbacks.  In browsers, events are handled by passing links to functions (often anonymous) that act as callbacks.  Previously, in Node.js, callbacks were the only way to connect the asynchronous parts of the code to each other, until promises were introduced.  However, callbacks are still in use, and many package developers still access them when designing their APIs.  A common mistake is calling the callback more than once.  Usually a method that does something asynchronously, expects the last argument of a function that it will call after completing its asynchronous task: <br><br><pre> <code class="html hljs xml">module.exports.verifyPassword = function(user, password, done) { if(typeof password !== 'string') { done(new Error('password should be a string')) return } computeHash(password, user.passwordHashOpts, function(err, hash) { if(err) { done(err) return } done(null, hash === user.passwordHash) }) }</code> </pre><br>  Notice the return statement after each done call, except for the last one.  The fact is that calling a callback does not interrupt the execution of the current function.  If you comment out the first ‚Äúreturn‚Äù, passing a password to this function that is not a string will result in a call to ‚ÄúcomputeHash‚Äù.  And depending on the further scenario of the work ‚ÄúcomputeHash‚Äù, ‚Äúdone‚Äù can be called repeatedly.  Any unauthorized user who has used this feature may be taken by surprise by calling the callback several times. <br><br>  To avoid this error, it is enough to be vigilant.  Some developers have made it a rule to add the ‚Äúreturn‚Äù keyword before each callback call: <br><br><pre> <code class="html hljs xml">if(err) { return done(err) }</code> </pre><br>  In many asynchronous functions, the return value is not important, so this approach often avoids a multiple callback. <br><br><h1>  Error Three: deeply nested callbacks </h1><br>  This problem is often called ‚ÄúCallback Hell‚Äù.  Although this in itself is not a mistake, it can cause the code to quickly get out of control: <br><br><pre> <code class="html hljs xml">function handleLogin(..., done) { db.User.get(..., function(..., user) { if(!user) { return done(null, 'failed to log in') } utils.verifyPassword(..., function(..., okay) { if(okay) { return done(null, 'failed to log in') } session.login(..., function() { done(null, 'logged in') }) }) }) }</code> </pre><br><img src="//habrastorage.org/files/ac4/950/a11/ac4950a11d904867950dc6f88e2838ee.jpg"><br><br>  The more complex the task, the deeper the nesting can be.  This leads to unstable and hard-to-read code that is difficult to maintain.  One way to solve this problem is to separate each task into a separate function, and then link them.  At the same time, many people think that it is best to use modules that implement asynchronous JavaScript patterns, such as <a href="https://github.com/caolan/async">Async.js</a> : <br><br><pre> <code class="html hljs xml">function handleLogin(done) { async.waterfall([ function(done) { db.User.get(..., done) }, function(user, done) { if(!user) { return done(null, 'failed to log in') } utils.verifyPassword(..., function(..., okay) { done(null, user, okay) }) }, function(user, okay, done) { if(okay) { return done(null, 'failed to log in') } session.login(..., function() { done(null, 'logged in') }) } ], function() { // ... }) }</code> </pre><br>  In addition to ‚Äúasync.waterfall‚Äù, Async.js contains a number of other functions that provide asynchronous execution of JavaScript.  For brevity, a rather simple example is presented here, but in reality, often, everything is much worse. <br><br><h1>  Error four: expect that callbacks will be executed synchronously </h1><br>  Asynchronous programming with callbacks is not unusual for JavaScript and Node.js.  Other languages ‚Äã‚Äãhave taught us the predictability of the order of execution, when two expressions are executed sequentially, one after another, if there are no special instructions for switching between them.  But even in this case, we are often limited to conditional operators, cycles, and function calls. <br><br>  However, in JavaScript, callbacks allow you to do so that a certain function may not be executed until some task is completed.  Here the function will be executed without stopping: <br><br><pre> <code class="html hljs xml">function testTimeout() { console.log(‚ÄúBegin‚Äù) setTimeout(function() { console.log(‚ÄúDone!‚Äù) }, duration * 1000) console.log(‚ÄúWaiting..‚Äù) }</code> </pre><br>  When calling the ‚ÄútestTimeout‚Äù function, ‚ÄúBegin‚Äù will be displayed first, then ‚ÄúWaitng‚Äù, and after about a second - ‚ÄúDone!‚Äù.  If something must be done after calling the callback, then it must be called in the callback itself. <br><br><h1>  Fifth error: assigning ‚Äúexports‚Äù instead of ‚Äúmodule.exports‚Äù </h1><br>  Node.js works with each file as with a small isolated module.  Suppose your package contains two files a.js and b.js.  In order for b.js to access the functionality from a.js, the latter must export this functionality by adding properties to the ‚Äúexports‚Äù object: <br><br><pre> <code class="html hljs xml">// a.js exports.verifyPassword = function(user, password, done) { ... }</code> </pre><br>  If this is done, then any a.js request will return an object with the verifyPassword function in the properties: <br><br><pre> <code class="html hljs xml">// b.js require('a.js') // { verifyPassword: function(user, password, done) { ... } }</code> </pre><br>  And if we need to export this function directly, and not as a property of any object?  We can do this by redefining the ‚Äúexports‚Äù variable, but the main thing is not to access it as a global variable: <br><br><pre> <code class="html hljs xml">/ a.js module.exports = function(user, password, done) { ... }</code> </pre><br>  Notice the ‚Äúexports‚Äù as a property of the ‚Äúmodule‚Äù object.  The difference between ‚Äúmodule.exports‚Äù and ‚Äúexports‚Äù is very large, and misunderstanding of this leads to difficulties for beginner Node.js developers. <br><br><h1>  Error Six: generation of errors inside callbacks </h1><br>  In JavaScript, there is such a thing as an exception.  Imitating the syntax of almost all traditional programming languages ‚Äã‚Äãthat also have exception handling, JavaScript can generate and catch exceptions using try-catch blocks: <br><br><pre> <code class="html hljs xml">function slugifyUsername(username) { if(typeof username === 'string') { throw new TypeError('expected a string username, got '+(typeof username)) } // ... } try { var usernameSlug = slugifyUsername(username) } catch(e) { console.log('Oh no!') }</code> </pre><br>  However, in asynchronous execution cases, try-catch will not work as expected.  For example, if using a large try-catch block you try to protect an impressive piece of code with multiple asynchronous segments, this may not work: <br><br><pre> <code class="html hljs xml">try { db.User.get(userId, function(err, user) { if(err) { throw err } // ... usernameSlug = slugifyUsername(user.username) // ... }) } catch(e) { console.log('Oh no!') }</code> </pre><br>  If the callback passed to db.User.get is called asynchronously, the try-catch block will not be able to catch the errors generated by the callback, since it will be executed in a different context than the try-catch context.  Errors in Node.js can be processed differently, but you need to stick to the same template for the arguments of all function callbacks (err, ...) - the first argument in each callback is to wait for an error, if one happens. <br><br><h1>  Error Seven: assume that all numbers are integers </h1><br>  In JavaScript, there is no integer data type, here all numbers are floating point.  You may find that this is not a problem, as it is not often that numbers are large enough to cause problems due to floating point restrictions.  It's a delusion.  Since floating-point numbers may contain integer representations only up to a certain value, exceeding it at any calculation immediately leads to problems.  Strangely enough, this expression in Node.js is regarded as true: <br><br><pre> <code class="html hljs xml">Math.pow(2, 53)+1 === Math.pow(2, 53)</code> </pre><br>  The oddities with numbers in javascript don't end there.  In spite of the fact that these are numbers with a floating point, operators working with integer data work with them: <br><br><pre> <code class="html hljs xml">5 % 2 === 1 // true 5 &gt;&gt; 1 === 2 // true</code> </pre><br>  However, unlike arithmetic, bitwise operators and shift operators work only with the last 32 bits of such large ‚Äúintegers‚Äù.  For example, if you shift ‚ÄúMath.pow (2, 53)‚Äù by 1, then the result will always be 0. If you apply the bitwise OR, it will also be 0. <br><br><pre> <code class="html hljs xml">Math.pow(2, 53) / 2 === Math.pow(2, 52) // true Math.pow(2, 53) &gt;&gt; 1 === 0 // true Math.pow(2, 53) | 1 === 0 // true</code> </pre><br>  Most likely, you rarely encounter large numbers, but when this happens, use one of the many libraries that perform exact mathematical operations with large numbers.  For example, <a href="https://www.npmjs.com/package/bignum">node-bigint</a> . <br><br><h1>  Error eight: ignoring the benefits of streaming APIs </h1><br>  Suppose you need to create a small proxy server that processes responses when you request any data from another server.  Say for working with images with Gravatar: <br><br><pre> <code class="html hljs xml">var http = require('http') var crypto = require('crypto') http.createServer() .on('request', function(req, res) { var email = req.url.substr(req.url.lastIndexOf('/')+1) if(!email) { res.writeHead(404) return res.end() } var buf = new Buffer(1024*1024) http.get('http://www.gravatar.com/avatar/'+crypto.createHash('md5').update(email).digest('hex'), function(resp) { var size = 0 resp.on('data', function(chunk) { chunk.copy(buf, size) size += chunk.length }) .on('end', function() { res.write(buf.slice(0, size)) res.end() }) }) }) .listen(8080)</code> </pre><br>  In this example, we take an image from Gravatar, read it in Buffer and send it as an answer to the request.  Not the worst scheme, because these images are small.  And if you need to proxy gigabyte content?  It is better to use this method: <br><br><pre> <code class="html hljs xml">http.createServer() .on('request', function(req, res) { var email = req.url.substr(req.url.lastIndexOf('/')+1) if(!email) { res.writeHead(404) return res.end() } http.get('http://www.gravatar.com/avatar/'+crypto.createHash('md5').update(email).digest('hex'), function(resp) { resp.pipe(res) }) }) .listen(8080)</code> </pre><br>  Here we take the image and simply broadcast as a response to the client, without reading the entire buffer. <br><br><h1>  Error Nine: Using Console.log for debugging </h1><br>  Console.log allows you to display anything on the console.  Pass the object to it, and it will output a JavaScript object literal to the console.  Console.log takes any number of arguments and displays them, neatly separated by spaces.  Many developers are happy to use this tool for debugging, but it is recommended not to use ‚Äúconsole.log‚Äù in real code.  Avoid ‚Äúconsole.log‚Äù even in commented lines.  It is better to use some library specially written for this, like <a href="https://www.npmjs.com/package/debug">debug</a> .  With the help of such libraries, you can easily enable and disable the debug mode when you start the application.  For example, when using ‚Äúdebug‚Äù, if you do not set the corresponding environment variable DEBUG, then debugging information will not get into the terminal: <br><br><pre> <code class="html hljs xml">// app.js var debug = require('debug')('app') debug('Hello, %s!', 'world')</code> </pre><br>  To enable debug mode, simply run this code by setting the DEBUG environment variable to ‚Äúapp‚Äù or ‚Äú*‚Äù: <br><br><pre> <code class="html hljs xml">DEBUG=app node app.js</code> </pre><br><h1>  Error ten: not using dispatcher programs </h1><br>  Regardless of whether your code is executed in production or in your local environment, it is highly recommended to use a dispatcher.  Many experienced developers believe that the code should ‚Äúfall‚Äù quickly.  If an unexpected error occurs, do not attempt to process it, let the program crash so that the dispatcher can restart it within a few seconds.  Of course, this is not all that dispatchers can do.  For example, you can configure the restart of the program in case of changes in some files, and much more.  This greatly simplifies the development process on Node.js.  The following dispatchers can advise: <br><br><ul><li>  <a href="https://www.npmjs.com/packages/pm2">pm2</a> </li><li>  <a href="https://www.npmjs.com/packages/forever">forever</a> </li><li>  <a href="https://www.npmjs.com/packages/nodemon">nodemon</a> </li><li>  <a href="https://www.npmjs.com/packages/supervisor">supervisor</a> </li></ul><br>  Each of them has its pros and cons.  Someone works well with multiple applications on the same machine at the same time, some are better at logging.  But if you want to start using the dispatcher, then choose any of the suggested ones. <br><br><h1>  Conclusion </h1><br>  Some of the errors described can have a destructive effect on your program, some can cause frustrations when implementing the simplest things.  Although Node.js is simple enough for a newbie to start working with him, there are many moments in which it's easy to screw up.  If you are familiar with other programming languages, then some of these errors may be known to you.  But these 10 errors are typical for beginner Node.js developers.  Fortunately, they are pretty easy to avoid.  I hope that this small article will help novice developers write stable and effective applications for all of us. </div><p>Source: <a href="https://habr.com/ru/post/255895/">https://habr.com/ru/post/255895/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255885/index.html">New javascript tutorial engine on IO.JS in open source</a></li>
<li><a href="../255887/index.html">Unity Day in Minsk</a></li>
<li><a href="../255889/index.html">The Foundation for Independent Studies at DevCon 2015: a master class from Dmitry Kalaev and Artem Azevich</a></li>
<li><a href="../255891/index.html">Deploying video surveillance in a hurry, or we do not need wires</a></li>
<li><a href="../255893/index.html">How to create a powerful game achievement system</a></li>
<li><a href="../255897/index.html">Why I could not switch from Firefox to Chrome and how I managed to do it</a></li>
<li><a href="../255899/index.html">Where to look if the site is constantly hacked, or how I caught the malware on the site of one of the clients</a></li>
<li><a href="../255903/index.html">Logiblocs Spytech kit overview</a></li>
<li><a href="../255913/index.html">Managing server disk space on the fly: 1cloud experience</a></li>
<li><a href="../255915/index.html">HP OpenStack Helion First Meet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>