<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Passing configuration parameters to Autofac modules in ASP.NET Core</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We started working with ASP.NET Core almost immediately after the release. Autofac was chosen as the IoC container, as there is no implementation of t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Passing configuration parameters to Autofac modules in ASP.NET Core</h1><div class="post__text post__text-html js-mediator-article">  We started working with ASP.NET Core almost immediately after the release.  Autofac was chosen as the IoC container, as there is no implementation of the Windsor we are used to under Core (not). <br><br>  Consider the various ways of registering dependencies that require configuration parameters, as well as the solution to which we have arrived and are now using. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c4a/68c/7bb/c4a68c7bbacf26e25a22b05aefb9b5ec.png" alt="image"><br><a name="habracut"></a><br><h2>  Brief introductory </h2><br>  We register dependencies by modules and then register them via RegisterAssemblyModules.  Everything is comfortable, everything is beautiful.  But as always there is a ‚ÄúBUT‚Äù.  This is convenient and perfectly smooth as long as our services do not require parameters from configuration files.  It‚Äôs quite difficult to imagine a situation in which you don‚Äôt need to put your application settings into configuration files.  At a minimum, you need to make connection lines in the configuration. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We collect IConfigurationRoot in the Startup class constructor and put it in the Configuration property.  Accordingly, it can be further used in the ConfigureServices method.  In general, the standard script. <br><br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Startup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IHostingEnvironment env</span></span></span><span class="hljs-function">)</span></span> { IConfigurationBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConfigurationBuilder() ... ... Configuration = builder.Build(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IConfigurationRoot Configuration { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; }</code> </pre> <br><h2>  How can I solve the problem with services that require configuration settings </h2><br>  <b>1. Do not make registration of such services into modules, but register them in ConfigureServices</b> <br><br>  Pros: <br><br><ul><li>  Most of the registrations are hidden in the modules and register in one line through RegisterAssemblyModules. </li></ul><br>  Minuses: <br><br><ul><li>  You have to clutter up with ConfigureServices with registrations of other services that require parameters; </li><li>  Registration of such services in fact relate to specific modules, but are not located in them, which is not always trivial. </li></ul><br>  As a result, the work with the container looks like this: <br><br><pre> <code class="hljs cs">ContainerBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContainerBuilder(); builder.RegisterAssemblyModules(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(SomeModule).GetTypeInfo().Assembly); builder.RegisterType&lt;SomeServiceWithParameter&gt;() .As&lt;ISomeServiceWithParameter&gt;() .WithParameter(<span class="hljs-string"><span class="hljs-string">"connectionString"</span></span>, Configuration.GetConnectionString(<span class="hljs-string"><span class="hljs-string">"SomeConnectionString"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//      builder.Populate(services); Container = builder.Build();</span></span></code> </pre><br>  <b>2. Add the modules for which there are parameter-dependent services, properties for each parameter and register each module separately</b> <br><br>  Pros: <br><br><ul><li>  All registrations are logically divided into modules and are where they should be. </li></ul><br>  Minuses: <br><br><ul><li>  There may be many registrations of modules and all this simply clutters up ConfigureServices (especially if a large number of parameters are required to be transferred to modules); </li><li>  When a new module appears, you need to remember to add registration to ConfigureServices. </li></ul><br>  As a result, the work with the container looks like this: <br><br><pre> <code class="hljs pgsql">ContainerBuilder builder = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ContainerBuilder(); builder.RegisterModule&lt;SomeModule&gt;(); //     builder.RegisterModule(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> SomeModuleWithParameters { ConnectionString = <span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>.GetConnectionString("SomeConnectionString") //   }); //     builder.Populate(services); Container = builder.Build();</code> </pre><br>  With this approach, it is quite possible to manage with one property of the IConfigurationRoot type and transfer it into parameter-specific modules as a whole Configuration. <br><br>  <b>3. Register parameter-dependent services as a delegate (via the Register method) in which to resolve IConfigurationRoot and other dependencies necessary for such services</b> <br><br>  Pros: <br><br><ul><li>  All registrations are logically divided into modules and lie where they should; </li><li>  Working with the container in ConfigureServices looks clean and does not require changes when new modules appear. </li></ul><br>  Minuses: <br><br><ul><li>  Terrible registrations of parameter-dependent services, especially if other services must be injected into them; </li><li>  The registration of parameter-dependent services needs to be changed if the composition of their dependencies changes. </li></ul><br>  As a result, the work with the container looks like this: <br><br><pre> <code class="hljs pgsql">//    IConfigurationRoot services.AddSingleton(<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>); ContainerBuilder builder = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ContainerBuilder(); builder.RegisterAssemblyModules(typeof(SomeModule).GetTypeInfo().Assembly); builder.Populate(services); Container = builder.Build();</code> </pre><br>  But at the same time, the registration of parameter-dependent services in modules looks like this: <br><br><pre> <code class="hljs pgsql">builder.Register(componentContext =&gt; { IConfigurationRoot <span class="hljs-keyword"><span class="hljs-keyword">configuration</span></span> = componentContext.Resolve&lt;IConfigurationRoot&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> SomeServiceWithParameter( componentContext.Resolve&lt;SomeOtherService&gt;(), //    <span class="hljs-keyword"><span class="hljs-keyword">configuration</span></span>.GetConnectionString("SomeConnectionString")); }) .<span class="hljs-keyword"><span class="hljs-keyword">As</span></span>&lt;ISomeServiceWithParameter&gt;();</code> </pre><br>  <b>4. Autofac configuration via JSON / XML</b> <br><br>  This option was not even considered because of an obvious problem - we want to give the opportunity to change only certain parameters, but not the dependencies themselves. <br><br>  In the end, which of the options is worse - a moot point.  It was obvious only that none of them did not suit us. <br><br><h2>  What did we do </h2><br>  Added IConfiguredModule interface: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IConfiguredModule</span></span> { IConfigurationRoot Configuration { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  Inherited the ConfiguredModule class from the Module and implemented the IConfiguredModule interface: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConfiguredModule</span></span> : <span class="hljs-title"><span class="hljs-title">Module</span></span>, <span class="hljs-title"><span class="hljs-title">IConfiguredModule</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IConfigurationRoot Configuration { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  Added here such an extension for ContainerBuilder: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ConfiguredModuleRegistrationExtensions { //  generic- TType  ,   ,      IModule- // +  IConfigurationRoot,     <span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>  ConfiguredModule- <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> RegisterConfiguredModulesFromAssemblyContaining&lt;TType&gt;( this ContainerBuilder builder, IConfigurationRoot <span class="hljs-keyword"><span class="hljs-keyword">configuration</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (builder == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArgumentNullException(nameof(builder)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">configuration</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArgumentNullException(nameof(<span class="hljs-keyword"><span class="hljs-keyword">configuration</span></span>)); //   ,    TType,  ,  IModule IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>&gt; moduleTypes = typeof(TType) .GetTypeInfo() .Assembly.DefinedTypes .<span class="hljs-keyword"><span class="hljs-keyword">Select</span></span>(x =&gt; x.AsType()) .<span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>(x =&gt; x.IsAssignableTo&lt;IModule&gt;()); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> moduleType <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> moduleTypes) { //     var module = Activator.CreateInstance(moduleType) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IModule; //    IConfiguredModule,     <span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>    IConfigurationRoot var configuredModule = module <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IConfiguredModule; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (configuredModule != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) configuredModule.<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">configuration</span></span>; //       builder.RegisterModule(module); } } }</code> </pre><br>  These ~ 40 lines of code give us the opportunity to work with the container like this: <br><br><pre> <code class="hljs pgsql">ContainerBuilder builder = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ContainerBuilder(); builder.RegisterConfiguredModulesFromAssemblyContaining&lt;SomeModule&gt;(<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>); builder.Populate(services); Container = builder.Build();</code> </pre><br>  If the module is parameter-independent, then we still inherit it from the Module - there are no changes. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SomeModule</span></span> : <span class="hljs-title"><span class="hljs-title">Module</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ContainerBuilder builder</span></span></span><span class="hljs-function">)</span></span> { builder.RegisterType&lt;SomeService&gt;().As&lt;ISomeService&gt;(); } }</code> </pre><br>  If parameter-dependent, then we inherit it from ConfiguredModule and we can retrieve parameters through the Configuration property. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SomeConfiguredModule</span></span> : <span class="hljs-title"><span class="hljs-title">ConfiguredModule</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ContainerBuilder builder</span></span></span><span class="hljs-function">)</span></span> { builder.RegisterType&lt;SomeServiceWithParameter&gt;() .As&lt;ISomeServiceWithParameter&gt;() .WithParameter(<span class="hljs-string"><span class="hljs-string">"connectionString"</span></span>, Configuration.GetConnectionString(<span class="hljs-string"><span class="hljs-string">"SomeConnectionString"</span></span>)); } }</code> </pre><br>  The very code for working with containers in ConfigureServices does not require any changes when changing the set of modules. <br><br>  We hope that someone will be useful.  We will be glad to any feedback. <br><br>  <b>UPD.</b>  Added a more concise solution from <a href="https://habrahabr.ru/users/mayorovp/" class="user_link">mayorovp</a> comments (only the use of the container was wrapped in using): <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ContainerBuilder RegisterConfiguredModulesFromAssemblyContaining&lt;TType&gt;( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ContainerBuilder builder, IConfigurationRoot configuration) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (builder == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(builder)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (configuration == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(configuration)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> metaBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContainerBuilder(); metaBuilder.RegisterInstance(configuration); metaBuilder.RegisterAssemblyTypes(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TType).GetTypeInfo().Assembly) .AssignableTo&lt;IModule&gt;() .As&lt;IModule&gt;() .PropertiesAutowired(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (IContainer metaContainer = metaBuilder.Build()) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (IModule module <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> metaContainer.Resolve&lt;IEnumerable&lt;IModule&gt;&gt;()) builder.RegisterModule(module); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> builder; }</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/325194/">https://habr.com/ru/post/325194/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325184/index.html">DevOps in the service of man</a></li>
<li><a href="../325186/index.html">Integrating XML data is another way.</a></li>
<li><a href="../325188/index.html">Fake promises, aggressive ads, trojan downloaders and other Google Play surprises</a></li>
<li><a href="../325190/index.html">I write as I want, or All for a meeting with ruHaskell in Kaspersky Lab</a></li>
<li><a href="../325192/index.html">Video review service HostTracker</a></li>
<li><a href="../325196/index.html">CAPWAP State Machine in the Cisco Unified Wireless Implementation: Discovery State</a></li>
<li><a href="../325198/index.html">Qt: Embedded World 2017 and roadmap</a></li>
<li><a href="../325200/index.html">Employee conversations with the company: how and why?</a></li>
<li><a href="../325202/index.html">Reincarnation of the PIX graphics debugger for DirectX 12</a></li>
<li><a href="../325204/index.html">Using code blocks from Objective-C to Delphi on macOS: how we built bridges</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>