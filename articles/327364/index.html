<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>React slow, React fast: React application optimization in practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! I want to share my translation of the article React is Slow, React is Fast: Optimizing Reactor Apps in Practice by Fran√ßois Zaninotto . I hope ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>React slow, React fast: React application optimization in practice</h1><div class="post__text post__text-html js-mediator-article"><p>  <b>Hello!</b>  I want to share my translation of the article <a href="https://medium.com/dailyjs/react-is-slow-react-is-fast-optimizing-react-apps-in-practice-394176a11fba">React is Slow, React is Fast: Optimizing Reactor Apps in Practice</a> by <a href="https://medium.com/%40francoisz">Fran√ßois Zaninotto</a> .  I hope this will be useful to someone. </p><br><p>  <b>Summary:</b> </p><br><ol><li>  <a href="https://habr.com/ru/post/327364/">React Performance Measurement</a> </li><li>  <a href="https://habr.com/ru/post/327364/">Why are you updated?</a> </li><li>  <a href="https://habr.com/ru/post/327364/">Optimization through component splitting</a> </li><li>  <a href="https://habr.com/ru/post/327364/">shouldComponentUpdate</a> </li><li>  <a href="https://habr.com/ru/post/327364/">Recompose</a> </li><li>  <a href="https://habr.com/ru/post/327364/">Redux</a> </li><li>  <a href="https://habr.com/ru/post/327364/">Reselect</a> </li><li>  <a href="https://habr.com/ru/post/327364/">Beware of object literals in JSX</a> </li><li>  <a href="https://habr.com/ru/post/327364/">Conclusion</a> </li></ol><br><p>  React can be slow.  I want to say that any React medium sized application can be slow.  But before looking for a replacement for it, you should know that any average application on Angular or Ember can also be slow. </p><br><p>  The good news is that if you really care about performance, then <b>making a React app very fast is pretty easy</b> .  <i>About this - further in the article.</i> <a name="habracut"></a></p><br><h2><a name="measuring"></a>  React Performance Measurement </h2><br><p>  What do I mean by slow?  Let me give you an example: </p><br><p>  I am working on one open-source project called <a href="https://github.com/marmelab/admin-on-rest">admin-on-rest</a> , using <a href="http://www.material-ui.com/">material-ui</a> and <a href="http://redux.js.org/">Redux</a> to provide a graphical user interface (GUI) admin panel for any API.  In this application there is a page that displays a list of records in a table.  When the user changes the sort order, or goes to the next page, or filters the output, the interface is not as responsive as we would like. </p><br><p>  The following animated screencast, slowed down 5 times, shows how the update occurs: </p><br><img src="https://habrastorage.org/files/791/550/d6d/791550d6db124f7b84735041b0ffd901.gif" alt="An animated screencast, slowed down 5 times, shows how the update occurs."><br><br><p> To understand what is happening, I add <strong><code>?react_perf</code></strong> at the end of the URL.  This activates <a href="https://facebook.github.io/react/blog/2016/11/16/react-v15.4.0.html">component profiling</a> capability, which is available from React 15.4.  First, I'm waiting for the initial loading of the data table.  Next, I open the Timeline tab in the Chrome developer tools, click on the "Record" button and click on the table title on the page to update the sorting order. </p><br><p>  After updating the data, I click on the record button again to stop it.  Chrome will display a yellow graph below the "User Timing" label. </p><br><img src="https://habrastorage.org/files/125/c12/932/125c12932c494fbba6f91e2e8d90202e.png" alt="Chrome displays a yellow graph under the label User Timing"><br><br><p>  If you have never seen this graph, it may seem daunting, but, in fact, it is very easy to use.  This graph shows the running time of each of your components.  It does not show the time of the internal React components (you still cannot optimize them), so it allows you to focus on optimizing your own code. </p><br><p>  The timeline displays the stages of recording the operation of the application and allows you to bring closer the moment when I clicked on the table header: </p><br><img src="https://habrastorage.org/files/dc5/87f/5ff/dc587f5ff4dc4e07b95f9e8482f2c1fb.png" alt="The timeline displays the stages of recording the operation of the application.">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  It seems that my application redraws the <code>&lt;List&gt;</code> component immediately after clicking on the sort button, and <em>before</em> retrieving data through REST.  It takes more than 500 ms.  The application simply updates the sorting icon in the table header and displays a gray screen indicating the data is loaded. </p><br><p>  In other words, the application takes 500 ms to visually display the response to the click.  Half a second is a significant figure - UI experts say that <a href="https://www.nngroup.com/articles/website-response-times/">users consider an application's response to be instant only when it is less than 100 ms</a> .  Application response over 100 ms is what I call ‚Äúslow‚Äù. </p><br><h2><a name="why_update"></a>  Why are you updated? </h2><br><p>  On the graph above you can see a lot of tiny holes.  This is a bad sign, as it means that many components are redrawn.  The graph shows that the <code>&lt;Datagrid&gt;</code> update takes the most time.  Why did the application update the entire data table before it received new data?  <i>Let's figure it out.</i> </p><br><p>  Attempts to understand the reasons for redrawing often involve adding <code>console.log()</code> to the <code>render()</code> function.  For functional components, you can use the following higher order component (HOC): </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// src/log.js const log = BaseComponent =&gt; props =&gt; { console.log(`Rendering ${BaseComponent.name}`); return &lt;BaseComponent {‚Ä¶props} /&gt;; } export default log; // src/MyComponent.js import log from './log'; export default log(MyComponent);</span></span></code> </pre> <br><blockquote>  <i><b>Tip:</b> It is also worth noting <a href="https://github.com/garbles/why-did-you-update">why-did-you-update</a> is another tool for the effectiveness of React.</i>  <i>This npm package causes React to display warnings to the console whenever the component is redrawn with the same props.</i>  <i>I warn you: the output in the console is quite detailed and it does not work with functional components.</i> </blockquote><br><p>  In the example, when the user clicks on the column header, the application performs an action that changes the state: the list sorting order ( <code>currentSort</code> ) is updated.  This state change triggers a redrawing of the <code>&lt;List&gt;</code> page, which in turn redraws the entire <code>&lt;Datagrid&gt;</code> component.  We want the table header to immediately draw the change of the sorting icon as a response to user actions. </p><br><p>  Usually, React becomes slow not because of one slow component (which will be displayed on the graph as one big hole).  <strong>In most cases, React becomes slow due to the useless redrawing of many components.</strong> </p><br><p>  You may have read that VirtualDOM in React is very fast.  This is true, but in a medium-sized application, a full redraw can easily contain hundreds of components.  Even the fastest VirtualDOM template engine cannot do it in less than 16 ms. </p><br><h2><a name="cutting_components"></a>  Optimization through component splitting </h2><br><p>  Here is the <code>render()</code> method of the <code>&lt;Datagrid&gt;</code> component: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Datagrid.js render() { const { resource, children, ids, data, currentSort } = this.props; return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; {Children.map(children, (field, index) =&gt; &lt;DatagridHeaderCell key={index} field={field} currentSort={currentSort} updateSort={this.updateSort} /&gt; )} &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; {ids.map(id =&gt; ( &lt;tr key={id}&gt; {Children.map(children, (field, index) =&gt; &lt;DatagridCell record={data[id]} key={`${id}-${index}`} field={field} resource={resource} /&gt; )} &lt;/tr&gt; ))} &lt;/tbody&gt; &lt;/table&gt; ); }</span></span></code> </pre> <br><p>  It seems that this is a very simple implementation of tabular data, but it is extremely inefficient.  Each <code>&lt;DatagridCell&gt;</code> causes a draw of at least two or three components.  As you can see on the animated screencast of the interface at the beginning of the article, the list contains 7 columns and 11 rows, and this means that 7 * 11 * 3 = 231 components are being redrawn.  And all this is a waste of time, since only <code>currentSort</code> subject to <code>currentSort</code> .  Although React does not update the real DOM (provided that VirtualDOM has not changed), it still takes about 500 ms to process all components. </p><br><p>  To avoid the useless redrawing of the table body, first I must * <i>extract</i> * it: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Datagrid.js render() { const { resource, children, ids, data, currentSort } = this.props; return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; {React.Children.map(children, (field, index) =&gt; &lt;DatagridHeaderCell key={index} field={field} currentSort={currentSort} updateSort={this.updateSort} /&gt; )} &lt;/tr&gt; &lt;/thead&gt; &lt;DatagridBody resource={resource} ids={ids} data={data}&gt; {children} &lt;/DatagridBody&gt; &lt;/table&gt; ); ); }</span></span></code> </pre> <br><p>  I created a new <code>&lt;DatagridBody&gt;</code> component by extracting logic from the table body: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// DatagridBody.js import React, { Children } from 'react'; const DatagridBody = ({ resource, ids, data, children }) =&gt; ( &lt;tbody&gt; {ids.map(id =&gt; ( &lt;tr key={id}&gt; {Children.map(children, (field, index) =&gt; &lt;DatagridCell record={data[id]} key={`${id}-${index}`} field={field} resource={resource} /&gt; )} &lt;/tr&gt; ))} &lt;/tbody&gt; ); export default DatagridBody;</span></span></code> </pre> <br><p>  In itself, the extraction of the body of the table does not affect the performance, but it opens up opportunities for optimization.  Large general purpose components are difficult to optimize.  It‚Äôs easier to handle small components that are responsible only for one thing. </p><br><h2><a name="shouldComponentUpdate"></a>  shouldComponentUpdate </h2><br><p>  <a href="https://facebook.github.io/react/docs/react-component.html">The React documentation</a> describes very clearly the way to avoid useless redrawing by using <code>shouldComponentUpdate()</code> .  By default, React <i>always displays the</i> component in VirtualDOM.  In other words, your job as a developer is to check whether the component props have changed, and if not, then skip its redrawing. </p><br><p>  In the case of the <code>&lt;DatagridBody&gt;</code> component, there should be no redrawing in it until the props changes. </p><br><p>  Therefore, the component should look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { Children, Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DatagridBody</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ shouldComponentUpdate(nextProps) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nextProps.ids !== </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.props.ids || nextProps.data !== </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.props.data</span></span></span><span class="hljs-function">); } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resource</span></span></span><span class="hljs-function">, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ids</span></span></span><span class="hljs-function">, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">children</span></span></span><span class="hljs-function"> } = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">this</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;tbody&gt; {ids.map(id =&gt; ( &lt;tr key={id}&gt; {Children.map(children, (field, index</span></span></span><span class="hljs-function">) =&gt;</span></span> &lt;DatagridCell record={data[id]} key={<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string">-</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${index}</span></span></span><span class="hljs-string">`</span></span>} field={field} resource={resource} /&gt; )} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/tr&gt; ))} &lt;/</span></span>tbody&gt; ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> DatagridBody;</code> </pre> <br><blockquote>  <i><b>Tip:</b> Instead of manually <b>setting shouldComponentUpdate ()</b> , I could inherit this class from <b>PureComponent</b> instead of <b>Component</b> .</i>  <i><b>PureComponent</b> will compare all <b>props</b> using a strict comparison ( <b>===</b> ) and redraw only if the props have changed.</i>  <i>But I know that <b>resource</b> and <b>children</b> cannot change in this context, so I don‚Äôt need to compare them.</i> </blockquote><br><p>  Due to this optimization, redrawing <code>&lt;Datagrid&gt;</code> after clicking on the table header skips its contents and all 231 components.  This reduced the update time from 500 ms to 60 ms.  This is a net performance increase of more than 400 ms! </p><br><img src="https://habrastorage.org/files/0be/97d/cab/0be97dcab99a48878626ca81de1c3789.png" alt="After optimization"><br><br><blockquote>  <i><b>Tip:</b> Do not be deceived by the width of the graph, it is even closer than on the previous graph.</i>  <i>It is definitely better!</i> </blockquote><br><p>  The method <code>shouldComponentUpdate</code> removed a lot of holes in the graph and reduced the total drawing time.  I can use the same method to avoid even large redraws (for example, do not redraw the sidebar, action buttons, unchanged table headers, pagination).  After about an hour of messing around with all this, the entire page is rendered in just 100 ms after clicking on the column header.  This is fast enough - even if there is still something left to optimize. </p><br><p>  Adding a method <code>shouldComponentUpdate</code> may seem cumbersome, but if you care about performance, most components should contain it. </p><br><p>  But do not insert it wherever you can - doing <code>shouldComponentUpdate</code> in fairly simple components can sometimes slow down its rendering.  Do not do this too early in the application life cycle.  Add this method only as your application grows, when you can identify performance problems in your components. </p><br><h2><a name="Recompose"></a>  Recompose </h2><br><p>  I am not particularly happy with the previous changes in <code>&lt;DatagridBody&gt;</code> : because of <code>shouldComponentUpdate</code> I had to transform a simple, functional component into a class.  This adds many lines of code, each of which has its price - in the form of writing, debugging and support. </p><br><p>  Fortunately, you can implement the logic of <code>shouldComponentUpdate</code> in a higher order component (HOC), thanks to <a href="https://github.com/acdlite/recompose">recompose</a> .  This is a functional tool for React that provides, for example, the <code>pure()</code> HOC function: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// DatagridBody.js import React, { Children } from 'react'; import pure from 'recompose/pure'; const DatagridBody = ({ resource, ids, data, children }) =&gt; ( &lt;tbody&gt; {ids.map(id =&gt; ( &lt;tr key={id}&gt; {Children.map(children, (field, index) =&gt; &lt;DatagridCell record={data[id]} key={`${id}-${index}`} field={field} resource={resource} /&gt; )} &lt;/tr&gt; ))} &lt;/tbody&gt; ); export default pure(DatagridBody);</span></span></code> </pre> <br><p>  The only difference between this code and the initial implementation is in the last line: I export <code>pure(DatagridBody)</code> instead of <code>DatagridBody</code> .  <code>pure</code> is similar to <code>PureComponent</code> , but without an extra boilerplate. </p><br><p>  I can even be more specific and focus only on those props, about which I know for sure that they can change, using <code>shouldUpdate()</code> instead of <code>pure()</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// DatagridBody.js import React, { Children } from 'react'; import shouldUpdate from 'recompose/shouldUpdate'; const DatagridBody = ({ resource, ids, data, children }) =&gt; ( ... ); const checkPropsChange = (props, nextProps) =&gt; (nextProps.ids !== props.ids || nextProps.data !== props.data); export default shouldUpdate(checkPropsChange)(DatagridBody);</span></span></code> </pre> <br><p>  <code>checkPropsChange</code> is a pure function, and I can even export it for unit testing. </p><br><p>  The recompose library offers more efficient HOCs, such as <code>onlyUpdateForKeys()</code> , which performs the same check that I did in my <code>checkPropsChange</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// DatagridBody.js import React, { Children } from 'react'; import onlyUpdateForKeys from 'recompose/onlyUpdateForKeys'; const DatagridBody = ({ resource, ids, data, children }) =&gt; ( ... ); export default onlyUpdateForKeys(['ids', 'data'])(DatagridBody);</span></span></code> </pre> <br><p>  I warmly recommend <code>recompose</code> .  In addition to optimizing performance, it helps you extract the logic of data sampling, compose HOC and work with props in a functional and tested style. </p><br><h2><a name="Redux"></a>  Redux </h2><br><p>  If you use <a href="http://redux.js.org/">Redux</a> to manage the state of the application ( <i>which I also recommend</i> ), then the components connected to it are already clean.  No need for any other HOC. </p><br><p>  Just remember, if only one property has changed, then the connected component will be redrawn - and all its descendants too.  Therefore, if you are using Redux for page components, you should use <code>pure()</code> or <code>shouldUpdate()</code> for the underlying components. </p><br><p>  But also remember that Redux uses strict comparison for props.  Since Redux binds the state with the props component, if you change the object in state, Redux will simply ignore this.  And for this reason you must use <b>immiability</b> in your reducers. </p><br><p>  For example, in admin-on-rest, click on the heading of the table dispatch <code>SET_SORT</code> action.  Reducer, which listens to this action, should replace the object in the state, and not <i>update</i> it: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// listReducer.js export const SORT_ASC = 'ASC'; export const SORT_DESC = 'DESC'; const initialState = { sort: 'id', order: SORT_DESC, page: 1, perPage: 25, filter: {}, }; export default (previousState = initialState, { type, payload }) =&gt; { switch (type) { case SET_SORT: if (payload === previousState.sort) { //    return { ...previousState, order: oppositeOrder(previousState.order), page: 1, }; } //   sort return { ...previousState, sort: payload, order: SORT_ASC, page: 1, }; // ... default: return previousState; } };</span></span></code> </pre> <br><p>  Following the code of this reducer, when Redux checks the state for changes using a triple comparison, it detects that the state object has changed and redraws the table with the data.  But if we mutated the state, Redux would have missed this change and accordingly would not redraw anything: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       export default (previousState = initialState, { type, payload }) =&gt; { switch (type) { case SET_SORT: if (payload === previousState.sort) { //     previousState.order= oppositeOrder(previousState.order); return previousState; } //      previousState.sort = payload; previousState.order = SORT_ASC; previousState.page = 1; return previousState; // ... default: return previousState; } };</span></span></code> </pre> <br><p>  To write an immutable reducers, some developers use the <a href="https://facebook.github.io/immutable-js/">immutable.js</a> library, which is also from Facebook.  But since ES6 has simplified the selective replacement in the component properties, I do not think that this library is necessary.  In addition, it is heavy (60 kB), so think twice before adding it depending on your project. </p><br><h2><a name="Reselect"></a>  Reselect </h2><br><p>  To prevent unnecessary rendering of components connected to Redux, you must also ensure that the <code>mapStateToProps</code> function <code>mapStateToProps</code> not return new objects each time it is called. </p><br><p>  Take, for example, the <code>&lt;List&gt;</code> component in admin-on-rest.  It takes from the state a list of entries for the current resource (for example, posts, comments, etc.) with the following code: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// List.js import React from 'react'; import { connect } from 'react-redux'; const List = (props) =&gt; ... const mapStateToProps = (state, props) =&gt; { const resourceState = state.admin[props.resource]; return { ids: resourceState.list.ids, data: Object.keys(resourceState.data) .filter(id =&gt; resourceState.list.ids.includes(id)) .map(id =&gt; resourceState.data[id]) .reduce((data, record) =&gt; { data[record.id] = record; return data; }, {}), }; }; export default connect(mapStateToProps)(List);</span></span></code> </pre> <br><p>  State contains an array of all previously loaded records indexed by the resource.  For example, <code>state.admin.posts.data</code> contains a list of posts: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-number"><span class="hljs-number">23</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: ‚ÄúHello, World‚Äù, <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> }, <span class="hljs-number"><span class="hljs-number">45</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">45</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: ‚ÄúLorem Ipsum‚Äù, <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> }, <span class="hljs-number"><span class="hljs-number">67</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">67</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: ‚ÄúSic dolor amet‚Äù, <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> }, }</code> </pre> <br><p>  The <code>mapStateToProps</code> function filters the state object and returns only those records that are actually displayed in the list.  Something like that: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-number"><span class="hljs-number">23</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: ‚ÄúHello, World‚Äù, <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> }, <span class="hljs-number"><span class="hljs-number">67</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">67</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: ‚ÄúSic dolor amet‚Äù, <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> },\ }</code> </pre> <br><p>  The problem is that each time the <code>mapStateToProps</code> function is <code>mapStateToProps</code> , it returns a new object, even if the internal objects have not changed.  As a result, the <code>&lt;List&gt;</code> component is redrawn every time when something changes in a state ‚Äî while, as the date or id changes, only the id should change. </p><br><p>  <a href="https://github.com/reactjs/reselect">Reselect</a> solves this problem through memoization.  Instead of calculating props directly in <code>mapStateToProps</code> , you use <i>selector</i> from reselect, which returns the same object if no changes were made to it. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { connect } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createSelector } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'reselect'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> List = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> ... const idsSelector = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, props</span></span></span><span class="hljs-function">) =&gt;</span></span> state.admin[props.resource].ids <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataSelector = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, props</span></span></span><span class="hljs-function">) =&gt;</span></span> state.admin[props.resource].data <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filteredDataSelector = createSelector( idsSelector, dataSelector (ids, data) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(data) .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> ids.includes(id)) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> data[id]) .reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data, record</span></span></span><span class="hljs-function">) =&gt;</span></span> { data[record.id] = record; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; }, {}) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, props</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resourceState = state.admin[props.resource]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">ids</span></span>: idsSelector(state, props), <span class="hljs-attr"><span class="hljs-attr">data</span></span>: filteredDataSelector(state, props), }; }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> connect(mapStateToProps)(List);</code> </pre> <br><p>  Now the <code>&lt;List&gt;</code> component will be redrawn only when the state subset changes. </p><br><p>  As for recompose, selectors are pure functions, easy to test and build.  Writing your selector for components connected to Redux is a good practice. </p><br><h2><a name="object_literal"></a>  Beware of object literals in JSX </h2><br><p>  One day your component will become even more ‚Äúclean‚Äù, and you may find bad patterns in your code that lead to useless redrawing.  The most common example of this is the use of object literals in JSX, which I like to call "The <b>infamous {{</b> ".  Let me give you an example: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MyTableComponent <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./MyTableComponent'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Datagrid = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyTableComponent</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{{</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">marginTop:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">10</span></span></span></span><span class="xml"><span class="hljs-tag"> }}&gt;</span></span></span><span class="xml"> ... </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyTableComponent</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> )</code> </pre> <br><p>  The <code>style</code> property of the <code>&lt;MyTableComponent&gt;</code> component gets a new value each time the <code>&lt;Datagrid&gt;</code> component is drawn.  Thus, even if <code>&lt;MyTableComponent&gt;</code> clean, it will still be redrawn when redrawing <code>&lt;Datagrid&gt;</code> .  In fact, every time you pass an object literal as a property to a child component, you violate purity.  The solution is simple: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MyTableComponent <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./MyTableComponent'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tableStyle = { <span class="hljs-attr"><span class="hljs-attr">marginTop</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Datagrid = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyTableComponent</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{tableStyle}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ... </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyTableComponent</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> )</code> </pre> <br><p>  It looks quite simple, but I have seen this error so many times that I developed a sense of finding the "infamous <code>{{</code> " in JSX.  I regularly replace them with constants. </p><br><p>  The next suspect to steal the purity of a component is <code>React.CloneElement()</code> .  If you pass the property as the value of the second parameter, the cloned element will receive new props with each drawing. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  const MyComponent = (props) =&gt; &lt;div&gt;{React.cloneElement(Foo, { bar: 1 })}&lt;/div&gt;; //  const additionalProps = { bar: 1 }; const MyComponent = (props) =&gt; &lt;div&gt;{React.cloneElement(Foo, additionalProps)}&lt;/div&gt;;</span></span></code> </pre> <br><p>  I burned it a couple of times with <a href="http://www.material-ui.com/">material-ui</a> using the following code: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { CardActions } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'material-ui/Card'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { CreateButton, RefreshButton } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'admin-on-rest'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Toolbar = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ basePath, refresh }</span></span></span><span class="hljs-function">) =&gt;</span></span> ( &lt;CardActions&gt; &lt;CreateButton basePath={basePath} /&gt; &lt;RefreshButton refresh={refresh} /&gt; &lt;/CardActions&gt; ); export default Toolbar;</code> </pre> <br><p>  Although the <code>&lt;CreateButton&gt;</code> component is clean, it is drawn every time the <code>&lt;Toolbar&gt;</code> drawn.  This is all because the <code>&lt;CardAction&gt;</code> component from material-ui adds a special style to the first descendant to be placed in the margins - and he does this with the help of the object literal.  Therefore, <code>&lt;CreateButton&gt;</code> gets a different <code>style</code> object every time.  I was able to solve this using the HOC function <code>onlyUpdateForKeys()</code> from recompose. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Toolbar.js import onlyUpdateForKeys from 'recompose/onlyUpdateForKeys'; const Toolbar = ({ basePath, refresh }) =&gt; ( ... ); export default onlyUpdateForKeys(['basePath', 'refresh'])(Toolbar);</span></span></code> </pre> <br><h2><a name="conclusion"></a>  Conclusion </h2><br><p>  There are many more things that need to be done to keep an application on React fast (use keys, lazy loading of heavy routes, <code>react-addons-perf</code> , ServiceWorkers package for caching application state, add isomorphism, etc.), but the correct implementation <code>shouldComponentUpdate</code> is the first and most effective step. </p><br><p>  By itself, React is not fast, but it offers all the tools to make an application of any size fast. </p><br><p>  This seems illogical, especially when many frameworks offer alternatives to React, arguing that they are N times faster than it.  But React focuses on the convenience and experience of the developer, not productivity.  This is the reason why developing large applications with React is a pleasant experience, without bad surprises and with a steady implementation rate. </p><br><p>  Remember to profile your application from time to time and devote some time to adding <code>pure()</code> calls if necessary.  But do not do it at the very beginning, and do not spend too much time optimizing each component - except if you don‚Äôt do it for mobile devices.  And do not forget to test on different devices in order to get a good impression of the responsiveness of your application from the user's point of view. </p><br><p>  <b>If you want to learn more about React performance optimization, here is a list of excellent articles on this topic:</b> </p><br><ul><li>  <a href="https://speakerdeck.com/vjeux/react-rally-animated-react-performance-toolbox">React Rally - Animated - React Performance Toolbox</a> - A stunning set of slides from Christopher Chedeau (Vjeux), one of the developers of React Native.  By the way, also a Frenchman. </li><li>  <a href="https://medium.com/%40addyosmani/progressive-web-apps-with-react-js-part-2-page-load-performance-33b932d97cf2">Progressive Web Apps with React.js - Part 2 - Page Load Performance</a> - An article from Addy Osmany that works for Google and writes many articles about performance. </li><li>  <a href="https://auth0.com/blog/optimizing-react/">Optimizing the Performance of Your React Application</a> - An article focused on the `react-addons-perf` package for more accurate profiling of the React application. </li><li> <a href="https://medium.com/%40franleplant/react-higher-order-components-in-depth-cf9032ee6c3e">React Higher Order Components in depth</a> ‚Äî    Render Hijacking. </li><li> <a href="http://benchling.engineering/deep-dive-react-perf-debugging/">A Deep Dive into React Perf Debugging</a> ‚Äî ,         Chrome Dev Tools. </li><li> <a href="https://www.mendix.com/tech-blog/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/">Making React reactive- the pursuit of high performing, easily maintainable React apps</a> ‚Äî   ,   ,  Observables. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/327364/">https://habr.com/ru/post/327364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327348/index.html">Personal experience: how we ordered advertising from video bloggers for our web studio</a></li>
<li><a href="../327352/index.html">Analysis of publications on Habrahabr over the past six months. Statistics, useful finds and ratings</a></li>
<li><a href="../327354/index.html">I want to know everything: business analysis. Part 1</a></li>
<li><a href="../327356/index.html">Simplify localization in iOS</a></li>
<li><a href="../327362/index.html">Testing: a simple IT track or a serious undertaking?</a></li>
<li><a href="../327368/index.html">Armor is strong and our tanks are fast.</a></li>
<li><a href="../327370/index.html">I want to know everything: business analysis. Part 2</a></li>
<li><a href="../327372/index.html">Creating a game on the Unreal Engine 4 for 150 hours (video + source)</a></li>
<li><a href="../327374/index.html">Multichannel communication against skimming</a></li>
<li><a href="../327376/index.html">A healthy programmer is a happy programmer.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>