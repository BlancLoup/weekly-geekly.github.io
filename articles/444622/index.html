<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>R package tidyr and its new features pivot_long and pivot_wide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The tidyr package is included in the core of one of the most popular libraries in the R - tidyverse language . 
 The main purpose of the package is to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>R package tidyr and its new features pivot_long and pivot_wide</h1><div class="post__text post__text-html js-mediator-article"><p>  The <strong>tidyr</strong> package is included in the core of one of the most popular libraries in the R - <strong>tidyverse language</strong> . <br>  The main purpose of the package is to bring data to a neat appearance. </p><br><p>  On Habr√© there is already a <a href="https://habr.com/ru/post/248741/">publication</a> dedicated to this package, but it dates back to 2015.  And I want to tell you about the most urgent changes, which the author Headley Wickham told about it a few days ago. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/21a/cf9/6f5/21acf96f56c9b005b125708f5b122a2b.png" alt="image"><br><blockquote>  <b>SJK</b> : <b>Will the</b> functions gather () and spread () be obsolete? <br><br>  <b>Hadley Wickham</b> : To some extent.  We will stop recommending the use of these functions and correct errors in them, but they will continue to be present in the package in the current state. </blockquote><a name="habracut"></a><br><h2 id="soderzhanie">  Content </h2><br><ul><li>  <a href="https://habr.com/ru/post/444622/">TidyData concept</a> </li><li>  <a href="https://habr.com/ru/post/444622/">Key features included in the tidyr package</a> </li><li>  <a href="https://habr.com/ru/post/444622/">New concept of converting data from wide format to long and vice versa</a> </li><li>  <a href="http://ustnovka-naibolee-aktualnoy-versii-tidyr-0839000/">Installing the most current version of tidyr 0.8.3.9000</a> </li><li>  <a href="https://habr.com/ru/post/444622/">Transition to new features</a> </li><li>  <a href="https://habr.com/ru/post/444622/">A simple example of converting data from wide format to long</a> </li><li>  <a href="https://habr.com/ru/post/444622/">Specs</a> </li><li>  <a href="https://habr.com/ru/post/444622/">Specification using multiple values ‚Äã‚Äã(.value)</a> </li><li>  <a href="https://habr.com/ru/post/444622/">Convert date frames from long format to wide</a> <br><ul><li>  <a href="https://habr.com/ru/post/444622/">The simplest example of converting a table to a wide format</a> </li><li>  <a href="https://habr.com/ru/post/444622/">Generating a column name from multiple source variables</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/444622/">Some advanced examples of working with the new tidyr concept</a> <br><ul><li>  <a href="https://habr.com/ru/post/444622/">Accurate data using the example of a census of income and rent census data in the United States</a> </li><li>  <a href="https://habr.com/ru/post/444622/">The World Bank</a> </li><li>  <a href="https://habr.com/ru/post/444622/">List of contacts</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/444622/">Conclusion</a> </li></ul><br><h2 id="koncepciya-tidydata">  TidyData concept </h2><br><p>  The goal of <strong>tidyr</strong> is to help you bring the data to a so-called accurate look.  Neat data is data, where: </p><br><ul><li>  Each variable is in a column. </li><li>  Each observation is a string. </li><li>  Each value is a cell. </li></ul><br><p>  With data that is provided to tidy data it is much easier and more convenient to work when conducting an analysis. </p><br><h2 id="osnovnye-funkcii-vhodyaschie-v-paket-tidyr">  Key features included in the tidyr package </h2><br><p>  tidyr contains a set of functions for transforming tables: </p><br><ul><li> <code>fill()</code> - filling in the missing values ‚Äã‚Äãin the column with previous values; </li><li>  <code>separate()</code> - splits one field into several through a separator; </li><li>  <code>unite()</code> - performs the operation of combining several fields into one, the inverse of the function <code>separate()</code> ; </li><li>  <code>pivot_long()</code> is a function that converts data from wide format to long; </li><li>  <code>pivot_wide()</code> is a function that converts data from a long format to a wide one.  The operation is the inverse of the one performed by the <code>pivot_long()</code> function. </li><li>  <code>gather()</code> <strong>obsolete</strong> - a function that converts data from wide format to long; </li><li>  <code>spread()</code> <strong>obsolete</strong> - a function that converts data from a long format to a wide one.  The operation is the reverse of the one that the <code>gather()</code> function performs. </li></ul><br><h2 id="novaya-koncepciya-preobrazovaniya-dannyh-iz-shirokogo-formata-v-dlinnyy-i-naoborot">  New concept of converting data from wide format to long and vice versa </h2><br><p>  Previously, for this kind of transformation, the functions <code>gather()</code> and <code>spread()</code> .  Over the years the existence of these functions, it became obvious that for most users, including the author of the package, the names of these functions and their arguments were not quite obvious, and caused difficulties in finding them and understanding which of these functions leads the frame from widely to long format, and vice versa. </p><br><p>  In this connection, two new, important functions have been added to <strong>tidyr</strong> , which are designed to transform date frames. </p><br><p>  The new functions <code>pivot_long()</code> and <code>pivot_wide()</code> were created under the impression of some of the functions from the <strong>cdata</strong> package created by John Mount and Nina Zumel. </p><br><h3 id="ustanovka-naibolee-aktualnoy-versii-tidyr-0839000">  Installing the most current version of tidyr 0.8.3.9000 </h3><br><p>  To install the new, most current version of the package * <em>tidyr</em> 0.8.3.9000, in which new functions are available, use the following code. </p><br><p> <code>devtools::install_github("tidyverse/tidyr")</code> </p> <br><p>  At the time of this writing, these functions are only available in the dev version of the package on GitHub. </p><br><h3 id="perehod-na-novye-funkcii">  Transition to new features </h3><br><p>  In fact, it is easy to translate old scripts to work with new functions, for more understanding, I will take an example from the documentation of old functions and show how the same operations are performed using new <code>pivot_*()</code> functions. </p><br><p>  Convert wide format to long. </p><br><div class="spoiler">  <b class="spoiler_title">Sample code from the gather function documentation</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># example library(dplyr) stocks &lt;- data.frame( time = as.Date('2009-01-01') + 0:9, X = rnorm(10, 0, 1), Y = rnorm(10, 0, 2), Z = rnorm(10, 0, 4) ) # old stocks_gather &lt;- stocks %&gt;% gather(key = stock, value = price, -time) # new stocks_long &lt;- stocks %&gt;% pivot_long(cols = -time, names_to = "stock", values_to = "price")</code> </pre></div></div><br><p>  Convert long format to wide. </p><br><div class="spoiler">  <b class="spoiler_title">Sample code from spread documentation</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># old stocks_spread &lt;- stocks_gather %&gt;% spread(key = stock, value = price) # new stock_wide &lt;- stocks_long %&gt;% pivot_wide(names_from = "stock", values_from = "price")</code> </pre></div></div><br><p>  Since  In the above examples of working with <code>pivot_long()</code> and <code>pivot_wide()</code> , there are no columns listed in the <em>names_to</em> and <em>values_to</em> arguments in their initial table <em>stocks</em> in quotes. </p><br><p>  The table with which you will most easily deal with how to move to work with the new concept of <strong>tidyr</strong> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/127/fc7/70a/127fc770a8175c98168864954e498199.png" alt="image"></p><br><h2 id="primechanie-ot-avtora">  Note from the author </h2><br><blockquote>  All the text below is adaptive, I would even say the free translation of the <a href="https://tidyr.tidyverse.org/dev/articles/pivot.html">vignette</a> from the official website of the tidyverse library. </blockquote><br><h2 id="prostoy-primer-preobrazovaniya-dannyh-iz-shirokogo-formata-v-dlinnyy">  A simple example of converting data from wide format to long </h2><br><p>  <code>pivot_long ()</code> - makes data sets longer by reducing the number of columns and increasing the number of rows. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/760/8bb/c5d/7608bbc5d0873682bb5cb8ad3fb9857e.png" alt="image"></p><br><p>  To perform the examples presented in the article, you need to include the necessary packages: </p><br><pre> <code class="plaintext hljs">library(tidyr) library(dplyr) library(readr)</code> </pre> <br><p>  Suppose we have a table with survey results in which (among other things) people were asked about their religion and annual income: </p><br><pre> <code class="plaintext hljs">#&gt; # A tibble: 18 x 11 #&gt; religion `&lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Agnostic 27 34 60 81 76 137 #&gt; 2 Atheist 12 27 37 52 35 70 #&gt; 3 Buddhist 27 21 30 34 33 58 #&gt; 4 Catholic 418 617 732 670 638 1116 #&gt; 5 Don't k‚Ä¶ 15 14 15 11 10 35 #&gt; 6 Evangel‚Ä¶ 575 869 1064 982 881 1486 #&gt; 7 Hindu 1 9 7 9 11 34 #&gt; 8 Histori‚Ä¶ 228 244 236 238 197 223 #&gt; 9 Jehovah‚Ä¶ 20 27 24 24 21 30 #&gt; 10 Jewish 19 19 25 25 30 95 #&gt; # ‚Ä¶ with 8 more rows, and 4 more variables: `$75-100k` &lt;dbl&gt;, #&gt; # `$100-150k` &lt;dbl&gt;, `&gt;150k` &lt;dbl&gt;, `Don't know/refused` &lt;dbl&gt;</code> </pre> <br><p>  This table contains data about the religion of the respondents in rows, and the income level is scattered by column names.  The number of respondents from each category is stored in cell values ‚Äã‚Äãat the intersection of religion and income level.  To bring the table to a neat, correct format, just use <code>pivot_long()</code> : </p><br><pre> <code class="plaintext hljs">pew %&gt;% pivot_long(cols = -religion, names_to = "income", values_to = "count")</code> </pre> <br><pre> <code class="plaintext hljs">pew %&gt;% pivot_long(cols = -religion, names_to = "income", values_to = "count") #&gt; # A tibble: 180 x 3 #&gt; religion income count #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Agnostic &lt;$10k 27 #&gt; 2 Agnostic $10-20k 34 #&gt; 3 Agnostic $20-30k 60 #&gt; 4 Agnostic $30-40k 81 #&gt; 5 Agnostic $40-50k 76 #&gt; 6 Agnostic $50-75k 137 #&gt; 7 Agnostic $75-100k 122 #&gt; 8 Agnostic $100-150k 109 #&gt; 9 Agnostic &gt;150k 84 #&gt; 10 Agnostic Don't know/refused 96 #&gt; # ‚Ä¶ with 170 more rows</code> </pre> <br><p>  Arguments for the <code>pivot_long()</code> function </p><br><ul><li>  The first argument, <em>cols</em> , describes which columns to merge.  In this case, all columns except <em>time</em> . </li><li>  The <em>names_to</em> argument gives the name of the variable that will be created from the names of the columns we merged. </li><li>  <em>values_to</em> gives the name of the variable that will be created from the data stored in the cell values ‚Äã‚Äãof the merged columns. </li></ul><br><h2 id="specifikacii">  Specs </h2><br><p>  This is a new <strong>tidyr</strong> package functionality that was previously unavailable when working with obsolete functions. </p><br><p>  The specification is a data frame, each row of which corresponds to one column in the new output date frame, and two special columns that begin with: </p><br><ul><li>  <em>.name</em> contains the original column name. </li><li>  <em>.value</em> contains the name of the column in which the cell values ‚Äã‚Äãwill be entered. </li></ul><br><p>  The remaining specification columns reflect how the name of the compressible columns from <em>.name</em> will be displayed in the new column. </p><br><p>  The specification describes the metadata stored in the column name, with one row for each column and one column for each variable combined with the column name. Probably now this definition seems confusing, but after considering a few examples, everything will become much clearer. </p><br><p>  The point of the specification is that you can extract, modify and set new metadata to the converted data frame. </p><br><p>  To work with specifications when converting a table from a wide format to a long one, use the <code>pivot_long_spec()</code> function. </p><br><p>  As this function works, it takes any date frame, and forms its metadata in the manner described above. </p><br><p>  For example, let's take the who dataset, which is provided with the <strong>tidyr</strong> package.  This data set contains information provided by the international health organization on the incidence of tuberculosis. </p><br><pre> <code class="plaintext hljs">who #&gt; # A tibble: 7,240 x 60 #&gt; country iso2 iso3 year new_sp_m014 new_sp_m1524 new_sp_m2534 #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Afghan‚Ä¶ AF AFG 1980 NA NA NA #&gt; 2 Afghan‚Ä¶ AF AFG 1981 NA NA NA #&gt; 3 Afghan‚Ä¶ AF AFG 1982 NA NA NA #&gt; 4 Afghan‚Ä¶ AF AFG 1983 NA NA NA #&gt; 5 Afghan‚Ä¶ AF AFG 1984 NA NA NA #&gt; 6 Afghan‚Ä¶ AF AFG 1985 NA NA NA #&gt; 7 Afghan‚Ä¶ AF AFG 1986 NA NA NA #&gt; 8 Afghan‚Ä¶ AF AFG 1987 NA NA NA #&gt; 9 Afghan‚Ä¶ AF AFG 1988 NA NA NA #&gt; 10 Afghan‚Ä¶ AF AFG 1989 NA NA NA #&gt; # ‚Ä¶ with 7,230 more rows, and 53 more variables</code> </pre> <br><p>  We construct its specification. </p><br><pre> <code class="plaintext hljs">spec &lt;- who %&gt;% pivot_long_spec(new_sp_m014:newrel_f65, values_to = "count")</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 56 x 3 #&gt; .name .value name #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 new_sp_m014 count new_sp_m014 #&gt; 2 new_sp_m1524 count new_sp_m1524 #&gt; 3 new_sp_m2534 count new_sp_m2534 #&gt; 4 new_sp_m3544 count new_sp_m3544 #&gt; 5 new_sp_m4554 count new_sp_m4554 #&gt; 6 new_sp_m5564 count new_sp_m5564 #&gt; 7 new_sp_m65 count new_sp_m65 #&gt; 8 new_sp_f014 count new_sp_f014 #&gt; 9 new_sp_f1524 count new_sp_f1524 #&gt; 10 new_sp_f2534 count new_sp_f2534 #&gt; # ‚Ä¶ with 46 more rows</code> </pre> <br><p>  The fields <em>country</em> , <em>iso2</em> , <em>iso3</em> are already variable.  Our task is to flip the columns from <em>new_sp_m014</em> to <em>newrel_f65</em> . </p><br><p>  The names of these columns store the following information: </p><br><ul><li>  The prefix <code>new_</code> says that the column contains data on new cases of tuberculosis, the current date frame contains information only on new diseases, therefore this prefix in the current context does not carry any meaning. </li><li>  <code>sp</code> / <code>rel</code> / <code>sp</code> / <code>ep</code> describes how to diagnose a disease. </li><li>  <code>m</code> / <code>f</code> gender of the patient. </li><li>  <code>014</code> age range of the patient. </li></ul><br><p>  We can split these columns using the <code>extract()</code> function using a regular expression. </p><br><pre> <code class="plaintext hljs">spec &lt;- spec %&gt;% extract(name, c("diagnosis", "gender", "age"), "new_?(.*)_(.)(.*)")</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 56 x 5 #&gt; .name .value diagnosis gender age #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 new_sp_m014 count sp m 014 #&gt; 2 new_sp_m1524 count sp m 1524 #&gt; 3 new_sp_m2534 count sp m 2534 #&gt; 4 new_sp_m3544 count sp m 3544 #&gt; 5 new_sp_m4554 count sp m 4554 #&gt; 6 new_sp_m5564 count sp m 5564 #&gt; 7 new_sp_m65 count sp m 65 #&gt; 8 new_sp_f014 count sp f 014 #&gt; 9 new_sp_f1524 count sp f 1524 #&gt; 10 new_sp_f2534 count sp f 2534 #&gt; # ‚Ä¶ with 46 more rows</code> </pre> <br><p>  Note that the <em>.name</em> column must remain unchanged, since this is our index in the column names of the original data set. </p><br><p>  Gender and age ( <em>gender</em> and <em>age</em> columns) have fixed and known values, so it is recommended to convert these columns into factors: </p><br><pre> <code class="plaintext hljs">spec &lt;- spec %&gt;% mutate( gender = factor(gender, levels = c("f", "m")), age = factor(age, levels = unique(age), ordered = TRUE) )</code> </pre> <br><p>  Finally, in order to apply the specification we created to the original date frame <em>who</em> we need to use the argument argument in the <code>pivot_long()</code> function. </p><br><p> <code>who %&gt;% pivot_long(spec = spec)</code> </p> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 405,440 x 8 #&gt; country iso2 iso3 year diagnosis gender age count #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;fct&gt; &lt;ord&gt; &lt;int&gt; #&gt; 1 Afghanistan AF AFG 1980 sp m 014 NA #&gt; 2 Afghanistan AF AFG 1980 sp m 1524 NA #&gt; 3 Afghanistan AF AFG 1980 sp m 2534 NA #&gt; 4 Afghanistan AF AFG 1980 sp m 3544 NA #&gt; 5 Afghanistan AF AFG 1980 sp m 4554 NA #&gt; 6 Afghanistan AF AFG 1980 sp m 5564 NA #&gt; 7 Afghanistan AF AFG 1980 sp m 65 NA #&gt; 8 Afghanistan AF AFG 1980 sp f 014 NA #&gt; 9 Afghanistan AF AFG 1980 sp f 1524 NA #&gt; 10 Afghanistan AF AFG 1980 sp f 2534 NA #&gt; # ‚Ä¶ with 405,430 more rows</code> </pre> <br><p>  Everything that we have just done can be schematically depicted as follows: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/90c/84b/16d/90c84b16d3e4c9860b8ced6e411757b3.png" alt="image"></p><br><h2 id="specifikaciya-s-ispolzovaniem-neskolkih-znacheniyvalue">  Specification using multiple values ‚Äã‚Äã(.value) </h2><br><p>  In the example above, the <em>.value</em> specification column contained only one value, in most cases this is the case. </p><br><p>  But occasionally there may be a situation when you need to collect data in values ‚Äã‚Äãfrom columns with different data types.  Using the outdated function <code>spread()</code> would be quite difficult to do this. </p><br><p>  The example below is borrowed from the <a href="https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reshape.html">vignette</a> to the <strong>data.table</strong> package. </p><br><p>  Let's create a training data frame. </p><br><pre> <code class="plaintext hljs">family &lt;- tibble::tribble( ~family, ~dob_child1, ~dob_child2, ~gender_child1, ~gender_child2, 1L, "1998-11-26", "2000-01-29", 1L, 2L, 2L, "1996-06-22", NA, 2L, NA, 3L, "2002-07-11", "2004-04-05", 2L, 2L, 4L, "2004-10-10", "2009-08-27", 1L, 1L, 5L, "2000-12-05", "2005-02-28", 2L, 1L, ) family &lt;- family %&gt;% mutate_at(vars(starts_with("dob")), parse_date)</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 5 x 5 #&gt; family dob_child1 dob_child2 gender_child1 gender_child2 #&gt; &lt;int&gt; &lt;date&gt; &lt;date&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1998-11-26 2000-01-29 1 2 #&gt; 2 2 1996-06-22 NA 2 NA #&gt; 3 3 2002-07-11 2004-04-05 2 2 #&gt; 4 4 2004-10-10 2009-08-27 1 1 #&gt; 5 5 2000-12-05 2005-02-28 2 1</code> </pre> <br><p>  The created date frame in each row contains data about children of the same family.  Families can have one or two children.  For each child, data about the date of birth and the field are provided, and the data for each child is in separate columns, our task is to bring this data to the correct format for analysis. </p><br><p>  Please note that we have two variables with information about each child: its gender and date of birth (columns with the <em>dop</em> prefix contain the date of birth, columns with the <em>gender</em> prefix contain the gender of the child).  In the expected result, they should go in separate columns.  We can do this by generating a specification in which the <code>.value</code> column has two different values. </p><br><pre> <code class="plaintext hljs">spec &lt;- family %&gt;% pivot_long_spec(-family) %&gt;% separate(col = name, into = c(".value", "child"))%&gt;% mutate(child = parse_number(child))</code> </pre><br><pre> <code class="plaintext hljs">#&gt; # A tibble: 4 x 3 #&gt; .name .value child #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 dob_child1 dob 1 #&gt; 2 dob_child2 dob 2 #&gt; 3 gender_child1 gender 1 #&gt; 4 gender_child2 gender 2</code> </pre> <br><p>  So, let's sort through the steps of the actions that are performed by the above code. </p><br><ul><li>  <code>pivot_long_spec(-family)</code> - create a specification that compresses all available columns, except the family column. </li><li>  <code>separate(col = name, into = c(".value", "child"))</code> - we divide the column <em>.name</em> , which contains the names of the original fields, by the underscore and enter the values ‚Äã‚Äãin the columns <em>.value</em> and <em>child</em> . </li><li>  <code>mutate(child = parse_number(child))</code> - convert the values ‚Äã‚Äãof the <em>child</em> field from text to numeric data type. </li></ul><br><p>  Now we can apply the received specification to the initial data frame and bring the table to the desired form. </p><br><pre> <code class="plaintext hljs">family %&gt;% pivot_long(spec = spec, na.rm = T)</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 9 x 4 #&gt; family child dob gender #&gt; &lt;int&gt; &lt;dbl&gt; &lt;date&gt; &lt;int&gt; #&gt; 1 1 1 1998-11-26 1 #&gt; 2 1 2 2000-01-29 2 #&gt; 3 2 1 1996-06-22 2 #&gt; 4 3 1 2002-07-11 2 #&gt; 5 3 2 2004-04-05 2 #&gt; 6 4 1 2004-10-10 1 #&gt; 7 4 2 2009-08-27 1 #&gt; 8 5 1 2000-12-05 2 #&gt; 9 5 2 2005-02-28 1</code> </pre> <br><p>  We use the argument <code>na.rm = TRUE</code> , because the current form of the data forces us to create extra rows for nonexistent observations.  Since  family 2 has only one child, <code>na.rm = TRUE</code> ensures that family 2 will have one line in the output. </p><br><h2 id="preobrazovanie-data-freymov-iz-dlinnogo-formata-k-shirokomu">  Convert date frames from long format to wide </h2><br><p>  <code>pivot_wide()</code> - is the inverse transformation, and vice versa increases the number of columns in the frame date by reducing the number of rows. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b0d/a51/f47/b0da51f47f968a49e485989eba044914.png" alt="image"></p><br><p>  This kind of transformation is extremely rarely used to bring data to a neat appearance; nevertheless, this technique can be useful for creating summary tables used in presentations, or for integrating with any other tools. </p><br><p>  In fact, the functions <code>pivot_long()</code> and <code>pivot_wide()</code> are symmetrical, and produce actions opposite to each other, that is: <code>df %&gt;% pivot_long(spec = spec) %&gt;% pivot_wide(spec = spec)</code> and <code>df %&gt;% pivot_wide(spec = spec) %&gt;% pivot_long(spec = spec)</code> returns the original df. </p><br><h3 id="prosteyshiy-primer-privedeniya-tablicy-k-shirokomu-formatu">  The simplest example of converting a table to a wide format </h3><br><p>  For the <code>pivot_wide()</code> function, we will use the <em>fish_encounters dataset</em> , which stores information on how various stations record the movement of fish along the river. </p><br><pre> <code class="plaintext hljs">#&gt; # A tibble: 114 x 3 #&gt; fish station seen #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 4842 Release 1 #&gt; 2 4842 I80_1 1 #&gt; 3 4842 Lisbon 1 #&gt; 4 4842 Rstr 1 #&gt; 5 4842 Base_TD 1 #&gt; 6 4842 BCE 1 #&gt; 7 4842 BCW 1 #&gt; 8 4842 BCE2 1 #&gt; 9 4842 BCW2 1 #&gt; 10 4842 MAE 1 #&gt; # ‚Ä¶ with 104 more rows</code> </pre> <br><p>  In most cases, this table will be more informative and easy to use if you present the information for each station in a separate column. </p><br><p> <code>fish_encounters %&gt;% pivot_wide(names_from = station, values_from = seen)</code> </p> <br><pre> <code class="plaintext hljs">fish_encounters %&gt;% pivot_wide(names_from = station, values_from = seen) #&gt; # A tibble: 19 x 12 #&gt; fish Release I80_1 Lisbon Rstr Base_TD BCE BCW BCE2 BCW2 MAE #&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 4842 1 1 1 1 1 1 1 1 1 1 #&gt; 2 4843 1 1 1 1 1 1 1 1 1 1 #&gt; 3 4844 1 1 1 1 1 1 1 1 1 1 #&gt; 4 4845 1 1 1 1 1 NA NA NA NA NA #&gt; 5 4847 1 1 1 NA NA NA NA NA NA NA #&gt; 6 4848 1 1 1 1 NA NA NA NA NA NA #&gt; 7 4849 1 1 NA NA NA NA NA NA NA NA #&gt; 8 4850 1 1 NA 1 1 1 1 NA NA NA #&gt; 9 4851 1 1 NA NA NA NA NA NA NA NA #&gt; 10 4854 1 1 NA NA NA NA NA NA NA NA #&gt; # ‚Ä¶ with 9 more rows, and 1 more variable: MAW &lt;int&gt;</code> </pre> <br><p>  This data set records information only in cases when the fish was detected by the station, i.e.  if any fish was not fixed by some station, then this data will not be in the table.  This means that the output will be filled with NA. </p><br><p>  However, in this case, we know that the absence of a record means that the fish was not noticed, so we can use the <em>values_fill</em> argument in the <code>pivot_wide()</code> function and fill these missing values ‚Äã‚Äãwith zeros: </p><br><pre> <code class="plaintext hljs">fish_encounters %&gt;% pivot_wide( names_from = station, values_from = seen, values_fill = list(seen = 0) )</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 19 x 12 #&gt; fish Release I80_1 Lisbon Rstr Base_TD BCE BCW BCE2 BCW2 MAE #&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 4842 1 1 1 1 1 1 1 1 1 1 #&gt; 2 4843 1 1 1 1 1 1 1 1 1 1 #&gt; 3 4844 1 1 1 1 1 1 1 1 1 1 #&gt; 4 4845 1 1 1 1 1 0 0 0 0 0 #&gt; 5 4847 1 1 1 0 0 0 0 0 0 0 #&gt; 6 4848 1 1 1 1 0 0 0 0 0 0 #&gt; 7 4849 1 1 0 0 0 0 0 0 0 0 #&gt; 8 4850 1 1 0 1 1 1 1 0 0 0 #&gt; 9 4851 1 1 0 0 0 0 0 0 0 0 #&gt; 10 4854 1 1 0 0 0 0 0 0 0 0 #&gt; # ‚Ä¶ with 9 more rows, and 1 more variable: MAW &lt;int&gt;</code> </pre> <br><h3 id="generaciya-imeni-stolbca-iz-neskolkih-ishodnyh-peremennyh">  Generating a column name from multiple source variables </h3><br><p>  Imagine that we have a table containing a combination of product, country and year.  To generate a test frame date, you can run the following code: </p><br><pre> <code class="plaintext hljs">df &lt;- expand_grid( product = c("A", "B"), country = c("AI", "EI"), year = 2000:2014 ) %&gt;% filter((product == "A" &amp; country == "AI") | product == "B") %&gt;% mutate(value = rnorm(nrow(.)))</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 45 x 4 #&gt; product country year value #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 A AI 2000 -2.05 #&gt; 2 A AI 2001 -0.676 #&gt; 3 A AI 2002 1.60 #&gt; 4 A AI 2003 -0.353 #&gt; 5 A AI 2004 -0.00530 #&gt; 6 A AI 2005 0.442 #&gt; 7 A AI 2006 -0.610 #&gt; 8 A AI 2007 -2.77 #&gt; 9 A AI 2008 0.899 #&gt; 10 A AI 2009 -0.106 #&gt; # ‚Ä¶ with 35 more rows</code> </pre> <br><p>  Our task is to extend the date frame so that one column contains data for each combination of product and country.  To do this, it is enough to transfer to the <em>names_from</em> argument a vector containing the names of the fields being combined. </p><br><pre> <code class="plaintext hljs">df %&gt;% pivot_wide(names_from = c(product, country), values_from = "value")</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 15 x 4 #&gt; year A_AI B_AI B_EI #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2000 -2.05 0.607 1.20 #&gt; 2 2001 -0.676 1.65 -0.114 #&gt; 3 2002 1.60 -0.0245 0.501 #&gt; 4 2003 -0.353 1.30 -0.459 #&gt; 5 2004 -0.00530 0.921 -0.0589 #&gt; 6 2005 0.442 -1.55 0.594 #&gt; 7 2006 -0.610 0.380 -1.28 #&gt; 8 2007 -2.77 0.830 0.637 #&gt; 9 2008 0.899 0.0175 -1.30 #&gt; 10 2009 -0.106 -0.195 1.03 #&gt; # ‚Ä¶ with 5 more rows</code> </pre> <br><p>  You can also apply specifications to the <code>pivot_wide()</code> function.  But when <code>pivot_wide()</code> to <code>pivot_wide()</code> specification performs the opposite transformation to <code>pivot_long()</code> : the columns specified in <em>.name</em> are created using values ‚Äã‚Äãfrom <em>.value</em> and other columns. </p><br><p>  For this dataset, you can generate a custom specification if you want each possible combination of country and product to have its own column, and not just those that are present in the data: </p><br><pre> <code class="plaintext hljs">spec &lt;- df %&gt;% expand(product, country, .value = "value") %&gt;% unite(".name", product, country, remove = FALSE)</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 4 x 4 #&gt; .name product country .value #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 A_AI A AI value #&gt; 2 A_EI A EI value #&gt; 3 B_AI B AI value #&gt; 4 B_EI B EI value</code> </pre> <br><pre> <code class="plaintext hljs">df %&gt;% pivot_wide(spec = spec) %&gt;% head()</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 6 x 5 #&gt; year A_AI A_EI B_AI B_EI #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2000 -2.05 NA 0.607 1.20 #&gt; 2 2001 -0.676 NA 1.65 -0.114 #&gt; 3 2002 1.60 NA -0.0245 0.501 #&gt; 4 2003 -0.353 NA 1.30 -0.459 #&gt; 5 2004 -0.00530 NA 0.921 -0.0589 #&gt; 6 2005 0.442 NA -1.55 0.594</code> </pre> <br><h2 id="neskolko-prodvinutyh-primerov-raboty-s-novoy-koncepciey-tidyr">  Some advanced examples of working with the new tidyr concept </h2><br><h3 id="privedenie-dannyh-k-akkuratnomu-vidu-na-primere-nabora-dannyh-o-perepisi-dohoda-i-arendnoy-platy-v-ssha">  Accurate data using the example of a census of income and rent census data in the United States </h3><br><p>  The <em>us_rent_income dataset</em> contains information on average income and rent for each state in the USA for 2017 (the dataset is available in the <strong>tidycensus</strong> package). </p><br><pre> <code class="plaintext hljs">us_rent_income #&gt; # A tibble: 104 x 5 #&gt; GEOID NAME variable estimate moe #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 01 Alabama income 24476 136 #&gt; 2 01 Alabama rent 747 3 #&gt; 3 02 Alaska income 32940 508 #&gt; 4 02 Alaska rent 1200 13 #&gt; 5 04 Arizona income 27517 148 #&gt; 6 04 Arizona rent 972 4 #&gt; 7 05 Arkansas income 23789 165 #&gt; 8 05 Arkansas rent 709 5 #&gt; 9 06 California income 29454 109 #&gt; 10 06 California rent 1358 3 #&gt; # ‚Ä¶ with 94 more rows</code> </pre> <br><p>  In the form in which data is stored in us_rent_income <em>dataset,</em> working with them is extremely inconvenient, so we would like to create a data set with columns: <em>rent</em> , <em>rent_moe</em> , <em>come</em> , <em>income_moe</em> .  There are many ways to create this specification, but the main thing is that we need to generate each combination of variable and <em>estimate / moe</em> values, and then generate the column name. </p><br><pre> <code class="plaintext hljs"> spec &lt;- us_rent_income %&gt;% expand(variable, .value = c("estimate", "moe")) %&gt;% mutate( .name = paste0(variable, ifelse(.value == "moe", "_moe", "")) )</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 4 x 3 #&gt; variable .value .name #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 income estimate income #&gt; 2 income moe income_moe #&gt; 3 rent estimate rent #&gt; 4 rent moe rent_moe</code> </pre> <br><p>  Providing this <code>pivot_wide()</code> specification gives us the result we are looking for: </p><br><p> <code>us_rent_income %&gt;% pivot_wide(spec = spec)</code> </p> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 52 x 6 #&gt; GEOID NAME income income_moe rent rent_moe #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 01 Alabama 24476 136 747 3 #&gt; 2 02 Alaska 32940 508 1200 13 #&gt; 3 04 Arizona 27517 148 972 4 #&gt; 4 05 Arkansas 23789 165 709 5 #&gt; 5 06 California 29454 109 1358 3 #&gt; 6 08 Colorado 32401 109 1125 5 #&gt; 7 09 Connecticut 35326 195 1123 5 #&gt; 8 10 Delaware 31560 247 1076 10 #&gt; 9 11 District of Columbia 43198 681 1424 17 #&gt; 10 12 Florida 25952 70 1077 3 #&gt; # ‚Ä¶ with 42 more rows</code> </pre> <br><h3 id="vsemirnyy-bank">  The World Bank </h3><br><p>  Sometimes casting a data set to the desired form requires several steps. <br>  Dataset <em>world_bank_pop</em> contains the data of the World Bank on the population of each country in the period from 2000 to 2018. </p><br><pre> <code class="plaintext hljs">#&gt; # A tibble: 1,056 x 20 #&gt; country indicator `2000` `2001` `2002` `2003` `2004` `2005` `2006` #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 ABW SP.URB.T‚Ä¶ 4.24e4 4.30e4 4.37e4 4.42e4 4.47e+4 4.49e+4 4.49e+4 #&gt; 2 ABW SP.URB.G‚Ä¶ 1.18e0 1.41e0 1.43e0 1.31e0 9.51e-1 4.91e-1 -1.78e-2 #&gt; 3 ABW SP.POP.T‚Ä¶ 9.09e4 9.29e4 9.50e4 9.70e4 9.87e+4 1.00e+5 1.01e+5 #&gt; 4 ABW SP.POP.G‚Ä¶ 2.06e0 2.23e0 2.23e0 2.11e0 1.76e+0 1.30e+0 7.98e-1 #&gt; 5 AFG SP.URB.T‚Ä¶ 4.44e6 4.65e6 4.89e6 5.16e6 5.43e+6 5.69e+6 5.93e+6 #&gt; 6 AFG SP.URB.G‚Ä¶ 3.91e0 4.66e0 5.13e0 5.23e0 5.12e+0 4.77e+0 4.12e+0 #&gt; 7 AFG SP.POP.T‚Ä¶ 2.01e7 2.10e7 2.20e7 2.31e7 2.41e+7 2.51e+7 2.59e+7 #&gt; 8 AFG SP.POP.G‚Ä¶ 3.49e0 4.25e0 4.72e0 4.82e0 4.47e+0 3.87e+0 3.23e+0 #&gt; 9 AGO SP.URB.T‚Ä¶ 8.23e6 8.71e6 9.22e6 9.77e6 1.03e+7 1.09e+7 1.15e+7 #&gt; 10 AGO SP.URB.G‚Ä¶ 5.44e0 5.59e0 5.70e0 5.76e0 5.75e+0 5.69e+0 4.92e+0 #&gt; # ‚Ä¶ with 1,046 more rows, and 11 more variables: `2007` &lt;dbl&gt;, #&gt; # `2008` &lt;dbl&gt;, `2009` &lt;dbl&gt;, `2010` &lt;dbl&gt;, `2011` &lt;dbl&gt;, `2012` &lt;dbl&gt;, #&gt; # `2013` &lt;dbl&gt;, `2014` &lt;dbl&gt;, `2015` &lt;dbl&gt;, `2016` &lt;dbl&gt;, `2017` &lt;dbl&gt;</code> </pre> <br><p>  Our goal is to create a neat data set, where each variable is in a separate column.  It is unclear exactly what steps are needed, but we will start with the most obvious problem: the year is divided into several columns. </p><br><p>  In order to fix this, you must use the <code>pivot_long()</code> function. </p><br><pre> <code class="plaintext hljs">pop2 &lt;- world_bank_pop %&gt;% pivot_long(`2000`:`2017`, names_to = "year")</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 19,008 x 4 #&gt; country indicator year value #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 ABW SP.URB.TOTL 2000 42444 #&gt; 2 ABW SP.URB.TOTL 2001 43048 #&gt; 3 ABW SP.URB.TOTL 2002 43670 #&gt; 4 ABW SP.URB.TOTL 2003 44246 #&gt; 5 ABW SP.URB.TOTL 2004 44669 #&gt; 6 ABW SP.URB.TOTL 2005 44889 #&gt; 7 ABW SP.URB.TOTL 2006 44881 #&gt; 8 ABW SP.URB.TOTL 2007 44686 #&gt; 9 ABW SP.URB.TOTL 2008 44375 #&gt; 10 ABW SP.URB.TOTL 2009 44052 #&gt; # ‚Ä¶ with 18,998 more rows</code> </pre> <br><p>  The next step is to consider the variable indicator. <br> <code>pop2 %&gt;% count(indicator)</code> </p> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 4 x 2 #&gt; indicator n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 SP.POP.GROW 4752 #&gt; 2 SP.POP.TOTL 4752 #&gt; 3 SP.URB.GROW 4752 #&gt; 4 SP.URB.TOTL 4752</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where SP.POP.GROW is population growth, SP.POP.TOTL is the total population, and SP.URB. </font><font style="vertical-align: inherit;">* same, but only for urban areas. </font><font style="vertical-align: inherit;">Let's divide these values ‚Äã‚Äãinto two variables: area - a location (total or urban) and a variable containing actual data (population or growth):</font></font></p><br><pre> <code class="plaintext hljs">pop3 &lt;- pop2 %&gt;% separate(indicator, c(NA, "area", "variable"))</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 19,008 x 5 #&gt; country area variable year value #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 ABW URB TOTL 2000 42444 #&gt; 2 ABW URB TOTL 2001 43048 #&gt; 3 ABW URB TOTL 2002 43670 #&gt; 4 ABW URB TOTL 2003 44246 #&gt; 5 ABW URB TOTL 2004 44669 #&gt; 6 ABW URB TOTL 2005 44889 #&gt; 7 ABW URB TOTL 2006 44881 #&gt; 8 ABW URB TOTL 2007 44686 #&gt; 9 ABW URB TOTL 2008 44375 #&gt; 10 ABW URB TOTL 2009 44052 #&gt; # ‚Ä¶ with 18,998 more rows</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we just have to divide the variable variable into two columns: </font></font></p><br><pre> <code class="plaintext hljs">pop3 %&gt;% pivot_wide(names_from = variable, values_from = value)</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 9,504 x 5 #&gt; country area year TOTL GROW #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 ABW URB 2000 42444 1.18 #&gt; 2 ABW URB 2001 43048 1.41 #&gt; 3 ABW URB 2002 43670 1.43 #&gt; 4 ABW URB 2003 44246 1.31 #&gt; 5 ABW URB 2004 44669 0.951 #&gt; 6 ABW URB 2005 44889 0.491 #&gt; 7 ABW URB 2006 44881 -0.0178 #&gt; 8 ABW URB 2007 44686 -0.435 #&gt; 9 ABW URB 2008 44375 -0.698 #&gt; 10 ABW URB 2009 44052 -0.731 #&gt; # ‚Ä¶ with 9,494 more rows</code> </pre> <br><h3 id="spisok-kontaktov"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> List of contacts </font></font></h3><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Last example, imagine that you have a contact list that you copied and pasted from a website: </font></font></p><br><pre> <code class="plaintext hljs">contacts &lt;- tribble( ~field, ~value, "name", "Jiena McLellan", "company", "Toyota", "name", "John Smith", "company", "google", "email", "john@google.com", "name", "Huxley Ratcliffe" )</code> </pre> <br><p>        ,    ,   ,     .    , ,          ("name"),      ,       ,    field   ‚Äúname‚Äù: </p><br><pre> <code class="plaintext hljs">contacts &lt;- contacts %&gt;% mutate( person_id = cumsum(field == "name") ) contacts</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 6 x 3 #&gt; field value person_id #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 name Jiena McLellan 1 #&gt; 2 company Toyota 1 #&gt; 3 name John Smith 2 #&gt; 4 company google 2 #&gt; 5 email john@google.com 2 #&gt; 6 name Huxley Ratcliffe 3</code> </pre> <br><p> ,         ,        : </p><br><pre> <code class="plaintext hljs">contacts %&gt;% pivot_wide(names_from = field, values_from = value)</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 3 x 4 #&gt; person_id name company email #&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 Jiena McLellan Toyota &lt;NA&gt; #&gt; 2 2 John Smith google john@google.com #&gt; 3 3 Huxley Ratcliffe &lt;NA&gt; &lt;NA&gt;</code> </pre> <br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>   ,    <strong>tidyr</strong>    ,        <code>spread()</code>  <code>gather()</code> .        <code>pivot_long()</code>  <code>pivot_wide()</code> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/444622/">https://habr.com/ru/post/444622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444598/index.html">The CD is 40 years old, and is it dead (does it?)</a></li>
<li><a href="../444600/index.html">Review 14 headless cms 2019</a></li>
<li><a href="../444602/index.html">Encapsulation in C ++ and C</a></li>
<li><a href="../444606/index.html">Oculus announces Rift S, the new successor to Rift</a></li>
<li><a href="../444612/index.html">Macro harm for C ++ code</a></li>
<li><a href="../444624/index.html">Electric cars on fire and bathing</a></li>
<li><a href="../444628/index.html">Volvo will install drunk drivers in their cars</a></li>
<li><a href="../444632/index.html">State services will be upgraded according to SCRUM methodology, officials will be replaced by software</a></li>
<li><a href="../444634/index.html">Epic Games distributes $ 100 million to developers</a></li>
<li><a href="../444638/index.html">QA on CodeFest. Automation, management, infrastructure, sale of dumplings in the store</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>