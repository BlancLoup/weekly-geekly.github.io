<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Revision of the USB stack in STM32 and TivaC microcontrollers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The presence of a USB port in modern microcontrollers opens up wide possibilities for the independent production of various devices controlled from a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Revision of the USB stack in STM32 and TivaC microcontrollers</h1><div class="post__text post__text-html js-mediator-article">  The presence of a USB port in modern microcontrollers opens up wide possibilities for the independent production of various devices controlled from a computer.  In practice, however, it turns out that the USB libraries supplied by the manufacturer need to be improved.  If you are interested in the experience of similar refinement for two popular families of MCs - welcome under cat. <br><a name="habracut"></a><br><br><h2>  Formulation of the problem </h2><br>  So, we want to make a device that exchanges messages of arbitrary length with a computer via a USB port.  The easiest way to do this is to use a USB character device (CDC) class, also known as a 'virtual serial port'.  Then on the host system to which you connect your device, a serial port will automatically be created, through which you can communicate with the device, working with it as with a regular file.  In practice, however, it turns out that some of the necessary functions for this in the manufacturer‚Äôs USB stack are either not implemented at all or are implemented with errors.  We will start by looking at the STM32 microcontrollers (the first case) and end with another popular family - Texas Instruments Tiva C (the second case).  Both families have the ARM Cortex M4 architecture. <br><br><h2>  STM32 - just add code </h2><br>  STM microcontrollers usually have a rich functionality at a very affordable price.  The manufacturer supplies a wide range of libraries for all occasions.  Among them there are libraries for USB support, and a library for working with other peripherals on the chip.  Recently, all of these libraries have been combined into one mega-package called the STM32Cube.  At the same time, however, they did not particularly care about compatibility and changed everything that they could change, including the names of the fields in the structures that describe the configuration of the I / O ports, while the very name of the structure remained the same.  It is interesting that there is also a third variant of examples and libraries, which can be found on the site <a href="http://stm32f4-discovery.com/">stm32f4-discovery.com</a> .  However, the author of this option likes to rename files borrowed from the STM in order to perpetuate its initials, which also does not add compatibility with all other code.  Considering all the above, I decided to take as a basis the last pre-cubic version of the libraries supplied by STM.  Now they can be found in the compiler distribution kit (I use IAR).  In order not to search for a long time, the libraries are included in the project, which you can take from the link below.  For experiments, I used the STM32F4DISCOVERY board <a href="http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/PF252419">www.st.com/web/catalog/tools/FM116/SC959/SS1532/PF252419</a> .  If you have another board and the code did not work right away, the case is most likely in the frequency of the external crystal oscillator.  Although libraries abound with all sorts of macros, and in the latest version of the libraries a macro for external clock frequency appeared among them, this parameter is still written in the code as a number without any comments, it seems that the developers did not lose their form and did not forget to read the manual.  You can find this number ‚Äî the clock frequency in megahertz ‚Äî in the system_stm32f4xx.c file in the definition of the macro PLL_M. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, we take as a basis a ready-made example that shifts the data from USB to the serial port of the microcontroller and back.  We will not need a serial port, and we will simply transfer the data from the input stream to the output stream, that is, we will implement the echo.  With the help of PuTTY we make sure that it works.  But this is not enough.  To exchange data with the device, we need to send a lot more than one character at a time.  We write a test program on python, which sends packages of random length and reads the answer.  And here we are in for a surprise.  The test works, but not for long, after which another reading attempt either hangs forever or ends on timeout if it is set.  The study of the problem using the debugger shows that the MC did send all the data, and the last parcel was 64 bytes long.  What happened? <br><br>  The USB stack on the host system has a multilayer structure.  At the driver level, the data was received, but remained in his cache.  The driver sends the cached data to the application when new data arrives and replaces the old data, or when the driver finds out that new data is not yet expected.  From where can he get this knowledge?  USB bus transfers data packets.  In our case, the maximum packet size is just 64 bytes.  If in the next data packet came less, then new data can not wait, and this is a signal in order to transfer to the application all the data received.  And if the data came exactly 64 bytes?  In this case, the protocol provides for sending a zero-length packet (ZLP), which is the stream interruption signal.  Having received it, the driver realizes that new data should not be expected yet.  In our case, he did not receive it because the developers of the USB stack for STM32 simply did not know anything about ZLP. <br><br>  The second problem that the developers of the USB stack undeservedly paid attention to - what to do with the data that was received via USB, if they have nowhere to go, because  input buffer overflowed.  By and large, they were not at all worried about the problem of the input buffer - they assumed that all the data obtained was immediately processed, which, of course, could not always be fulfilled.  In the USB protocol, in case the data cannot be received, a NAK response is provided - a negative acknowledgment.  After such a response, the host simply sends the data again.  If we want to avoid an overflow of the input buffer, we need, if there is no space for a full packet (64 bytes), to transfer the channel to the NAK state, which ensures that the NAK automatically responds to all incoming packets. <br><br><h2>  Tiva C - Layer Cake with Bugs </h2><br>  For the experiments, the EK-TM4C123GXL board was taken <a href="http://www.ti.com/tool/ek-tm4c123gxl">www.ti.com/tool/ek-tm4c123gxl</a> .  To compile, you need the TivaWare library package <a href="http://www.ti.com/tool/sw-ek-tm4c123gxl">www.ti.com/tool/sw-ek-tm4c123gxl</a> .  The study of libraries shows that the developers did not ignore either the ZLP or the problem of buffering - there are annular buffers in the input and output channels.  However, the automatic test gives the same result - the data exchange suddenly stops.  Using the debugger, it turns out that this time the data is stuck in the circular transfer buffer, and the size of the last packet, and therefore the ZLP, is not a problem. <br><br>  It is possible to identify the problem only by carefully studying the sources of the libraries.  It turns out that in order to send ZLP it is necessary to set a special flag, which is not set by default.  Perhaps this circumstance prompted other developers to add code that sends the ZLP in another place - at a lower level of the USB stack, and without the checkbox.  This change introduced a bug that caused the transfer to stop.  The problem arises as follows.  The transmitter receives the next packet when the transmission of the previous one ends, or if the previous one was not, and the application has added data to the transmission buffer.  The code that initiates the transfer receives a notification of the completion of the transfer of the previous packet from the lower level of the USB stack.  The problem is that if the lower level of the stack has initiated the transfer of the ZLP, then it does not send a completion notification, because  He initiated the transfer himself.  The upper level does not start data transmission while the transmitter is busy transmitting the ZLP packet, and does not start the transfer after it is completed, because it does not receive notifications - the transmission process stops.  To fix the problem is very simple - you need to remove the lower level code that sends the ZLP and give it to the upper level of the stack.  The second problem that needs to be solved is that the procedure that starts the transfer can be called both from the context of the interrupt handler (when the transfer is completed) and from the application context by adding data to the transfer buffer.  To serialize calls to this procedure from different contexts, you need to disable interrupts for the duration of its execution. <br><br><h2>  Source </h2><br>  It lies here <a href="https://github.com/olegv142/stm32tivc_usb_cdc">github.com/olegv142/stm32tivc_usb_cdc</a> . <br>  In the stm and ti folders there are 2 test projects each - usb_cdc_echo and usb_cdc_api.  The first simply sends all the data back, the second implements the packet protocol, which you can easily adapt to your needs.  In the tools folder - test python scripts. </div><p>Source: <a href="https://habr.com/ru/post/248729/">https://habr.com/ru/post/248729/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248719/index.html">Research projects on the Odesk freelance market through the eyes of a web developer</a></li>
<li><a href="../248721/index.html">PHP7 revolution: return types and artifact removal</a></li>
<li><a href="../248723/index.html">A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 4b of 6</a></li>
<li><a href="../248725/index.html">Getting vk.com community members in seconds</a></li>
<li><a href="../248727/index.html">Unauthorized access to more than 20,000 Moscow video surveillance cameras was obtained (now you too)</a></li>
<li><a href="../248733/index.html">Must-read books for 2014 on information security and programming</a></li>
<li><a href="../248735/index.html">Defining voice mail when calling</a></li>
<li><a href="../248737/index.html">Horizontal websocket scaling in Ruby</a></li>
<li><a href="../248741/index.html">Data tidying: Preparing Data Sets for Case-Based Analysis</a></li>
<li><a href="../248745/index.html">Lectures Technopark. 1 semester Web technologies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>