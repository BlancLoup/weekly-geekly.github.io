<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Expressive JavaScript: The Secret Life of Objects</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content 


- Introduction 
- Values, Types and Operators 
- Program structure 
- Functions 
- Data Structures: Objects and Arrays 
- Higher order func...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Expressive JavaScript: The Secret Life of Objects</h1><div class="post__text post__text-html js-mediator-article"><h4>  Content </h4><br><ul><li>  <a href="http://habrahabr.ru/post/240219/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/240223/">Values, Types and Operators</a> </li><li>  <a href="http://habrahabr.ru/post/240225/">Program structure</a> </li><li>  <a href="http://habrahabr.ru/post/240349/">Functions</a> </li><li>  <a href="http://habrahabr.ru/post/240813/">Data Structures: Objects and Arrays</a> </li><li>  <a href="http://habrahabr.ru/post/241155/">Higher order functions</a> </li><li>  <a href="http://habrahabr.ru/post/241587/">The secret life of objects</a> </li><li>  <a href="http://habrahabr.ru/post/241776/">Project: e-life</a> </li><li>  <a href="http://habrahabr.ru/post/242609/">Search and error handling</a> </li><li>  <a href="http://habrahabr.ru/post/242695/">Regular expressions</a> </li><li>  <a href="http://habrahabr.ru/post/243273/">Modules</a> </li><li>  <a href="http://habrahabr.ru/post/243277/">Project: programming language</a> </li><li>  <a href="http://habrahabr.ru/post/243311/">Javascript and browser</a> </li><li>  <a href="http://habrahabr.ru/post/243815/">Document Object Model</a> </li><li>  <a href="http://habrahabr.ru/post/244041/">Event handling</a> </li><li>  <a href="http://habrahabr.ru/post/244405/">Project: Platform Game</a> </li><li>  <a href="http://habrahabr.ru/post/244545/">Drawing on canvas</a> </li><li>  <a href="http://habrahabr.ru/post/245145/">HTTP</a> </li><li>  <a href="http://habrahabr.ru/post/245731/">Forms and form fields</a> </li><li>  <a href="http://habrahabr.ru/post/245767/">Project: Paint</a> </li><li>  <a href="http://habrahabr.ru/post/245775/">Node.js</a> </li><li>  <a href="http://habrahabr.ru/post/246331/">Project: website sharing experience</a> </li><li>  <a href="http://eloquentjavascript.net/code">Sandbox for code</a> </li></ul><br><br>  <i>The problem with object-oriented languages ‚Äã‚Äãis that they carry with them all their implicit surroundings.</i>  <i>You needed a banana - and you get a gorilla with a banana, and the whole jungle in addition.</i> <i><br><br></i>  <i>Joe Armstrong, in an interview with Coders at Work</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The term "object" in programming is heavily overloaded with values.  In my profession, objects are lifestyle, the theme of holy wars and a favorite spell that does not lose its magical power. <br><br>  To a stranger, all this is not clear.  Let's start with a brief history of objects as a concept in programming. <br><a name="habracut"></a><br><h4>  Story </h4><br>  This story, like most programming stories, begins with a problem of complexity.  One of the ideas says that complexity can be made manageable by dividing it into small parts isolated from each other.  These parts began to be called objects. <br><br>  The object is a hard shell that hides the sticky complexity inside, and instead offers us several setting knobs and contacts (like methods) representing the interface through which the object should be used.  The idea is that the interface is relatively simple, and when working with it allows you to ignore all the complex processes occurring inside the object. <br><br>  A simple interface can hide a lot of things. <br><br>  For example, imagine an object that provides an interface to a screen section.  With it, you can draw shapes or display text on this area, but all the details regarding the transformation of the text or shapes into pixels are hidden.  You have a set of methods, for example, drawCircle, and that's all you need to know to use such an object. <br><br>  Such ideas were developed in the 70-80s, and in the 90s they were brought to the surface by an advertising wave - the revolution of object-oriented programming.  Suddenly, a large clan of people declared that objects were the right way to program.  And everything that has no objects, is an outdated nonsense. <br><br>  Such fanaticism always leads to a pile of useless nonsense, and since then something like a counter-revolution has been going on.  In some circles, objects generally have an extremely bad reputation. <br><br>  I prefer to consider them from a practical rather than an ideological point of view.  There are several useful ideas, in particular, encapsulation (the difference between internal complexity and external simplicity) that have been popularized by object-oriented culture.  They are worth studying. <br><br>  This chapter describes a rather eccentric approach to JavaScript objects, and how they relate to the classical object-oriented techniques. <br><br><h4>  Methods </h4><br>  Methods - properties containing functions.  Simple method: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rabbit = {}; rabbit.speak = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">line</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"  '"</span></span> + line + <span class="hljs-string"><span class="hljs-string">"'"</span></span>); }; rabbit.speak(<span class="hljs-string"><span class="hljs-string">" ."</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí   ' .'</span></span></code> </pre> <br><br>  Usually the method has to do something with the object through which it was called.  When a function is called as a method ‚Äî as a property of an object, for example object.method () ‚Äîa special variable in its body will indicate the object that called it. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speak</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">line</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type + <span class="hljs-string"><span class="hljs-string">"   '"</span></span> + line + <span class="hljs-string"><span class="hljs-string">"'"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> whiteRabbit = {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">speak</span></span>: speak}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fatRabbit = {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">speak</span></span>: speak}; whiteRabbit.speak(<span class="hljs-string"><span class="hljs-string">"   , "</span></span> + <span class="hljs-string"><span class="hljs-string">"   !"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí     '    ,    !' fatRabbit.speak("   ."); // ‚Üí     '    .'</span></span></code> </pre><br><br>  The code uses the keyword this to display the type of talking rabbit. <br><br>  Recall that the apply and bind methods take the first argument that can be used to emulate a method call.  This first argument just gives the value of the variable this. <br><br>  There is a method similar to apply called call.  It also calls a function whose method it is, only accepts arguments as usual, and not as an array.  Like apply and bind, in the call you can pass the value of this. <br><br><pre> <code class="javascript hljs">speak.apply(fatRabbit, [<span class="hljs-string"><span class="hljs-string">"!"</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí     ' !' speak.call({type: ""}, " , ."); // ‚Üí     ', .'</span></span></code> </pre><br><br><h4>  Prototypes </h4><br>  Watch your hands. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> empty = {}; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(empty.toString); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí function toString(){‚Ä¶} console.log(empty.toString()); // ‚Üí [object Object]</span></span></code> </pre><br><br>  I got the property of an empty object.  Magic! <br><br>  Well, not magic, of course.  I simply did not tell everything about how objects work in JavaScript.  In addition to the property set, almost everyone also has a prototype.  A prototype is another object that is used as a spare source of properties.  When an object receives a request for a property that it does not have, this property is searched for in its prototype, then in the prototype prototype, and so on. <br><br>  Well, who is the prototype of an empty object?  This is the great ancestor of all objects, Object.prototype. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf({}) == <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true console.log(Object.getPrototypeOf(Object.prototype)); // ‚Üí null</span></span></code> </pre><br><br>  As you might expect, the Object.getPrototypeOf function returns the prototype of the object. <br><br>  Prototypical relationships in JavaScript look like a tree, and at its root is the Object.prototype.  It provides several methods that appear on all objects, such as toString, which converts an object into a string view. <br><br>  The prototype of many objects is not the Object.prototype itself, but some other object that provides its default properties.  Functions derive from Function.prototype, arrays from Array.prototype. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>) == <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>.prototype); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true console.log(Object.getPrototypeOf([]) == Array.prototype); // ‚Üí true</span></span></code> </pre><br><br>  Such prototypes will have their own prototype - often an Object.prototype, so it still, though not directly, provides them with methods of the type toString. <br><br>  The Object.getPrototypeOf function returns a prototype object.  You can use Object.create to create objects with a given prototype. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> protoRabbit = { <span class="hljs-attr"><span class="hljs-attr">speak</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">line</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type + <span class="hljs-string"><span class="hljs-string">"   '"</span></span> + line + <span class="hljs-string"><span class="hljs-string">"'"</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> killerRabbit = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(protoRabbit); killerRabbit.type = <span class="hljs-string"><span class="hljs-string">""</span></span>; killerRabbit.speak(<span class="hljs-string"><span class="hljs-string">"!"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí     ' !'</span></span></code> </pre><br><br>  The proto-rabbit works as a container of properties that all rabbits have.  A specific rabbit object, for example, deadly, contains properties that are applicable only to it ‚Äî for example, its type ‚Äî and inherits properties from the prototype that are shared with others. <br><br><h4>  Constructors </h4><br>  A more convenient way to create objects inherited from a certain prototype is the constructor.  In JavaScript, calling a function with the preceding new keyword causes the function to act as a constructor.  The constructor will have the variable this attached to the newly created object, and if it does not directly return another value containing the object, this new object will be returned instead. <br><br>  An object created with new is said to be an instance of a constructor. <br><br>  Here is a simple designer of rabbits.  The names of the designers decided to start with a capital letter to distinguish them from other functions. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rabbit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type = type; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> killerRabbit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rabbit(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> blackRabbit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rabbit(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(blackRabbit.type); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí </span></span></code> </pre><br><br>  Constructors (and, in fact, all functions) automatically receive a property called prototype, which by default contains a simple and empty object, derived from Object.prototype.  Each instance created by this constructor will have this object as a prototype.  Therefore, to add the speak method to rabbits created by the Rabbit constructor, we can simply do this: <br><br><pre> <code class="javascript hljs">Rabbit.prototype.speak = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">line</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type + <span class="hljs-string"><span class="hljs-string">"   '"</span></span> + line + <span class="hljs-string"><span class="hljs-string">"'"</span></span>); }; blackRabbit.speak(<span class="hljs-string"><span class="hljs-string">" ..."</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí     '  ...'</span></span></code> </pre><br><br>  It is important to note the difference between how a prototype is associated with a constructor (through the prototype property) and how objects have a prototype (which can be obtained through Object.getPrototypeOf).  In fact, the prototype of the constructor is Function.prototype, since constructors are functions.  His prototype property will be a prototype of instances created by it, but not its prototype. <br><br><h4>  Reloading Inherited Properties </h4><br>  When you add a property to an object, whether it is in the prototype or not, it is added directly to the object itself.  Now it is his property.  If in the prototype there is a property of the same name, it no longer affects the object.  The prototype itself does not change. <br><br><pre> <code class="javascript hljs">Rabbit.prototype.teeth = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(killerRabbit.teeth); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí  killerRabbit.teeth = ",    "; console.log(killerRabbit.teeth); // ‚Üí ,    console.log(blackRabbit.teeth); // ‚Üí  console.log(Rabbit.prototype.teeth); // ‚Üí </span></span></code> </pre><br><br>  The diagram shows the situation after the code is run.  The Rabbit and Object prototypes are behind the killerRabbit in the manner of the background, and they can be queried for properties that the object itself does not have. <br><br>  Reloading the properties that exist in a prototype often benefits.  As in the example with the rabbit's teeth, it can be used to express some exceptional characteristics of more general properties, while ordinary objects simply use standard values ‚Äã‚Äãtaken from prototypes. <br><br>  It is also used to assign different toString methods to functions and arrays. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.toString == <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.toString); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí false console.log([1, 2].toString()); // ‚Üí 1,2</span></span></code> </pre><br><br>  Calling the toString of the array displays a result similar to .join (",") - the list is separated by commas.  Calling Object.prototype.toString directly for an array results in a different result.  This function does not know anything about arrays: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.toString.call([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>])); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí [object Array]</span></span></code> </pre><br><br><h4>  Unwanted prototype interaction </h4><br>  The prototype helps to add new properties and methods to all objects that are based on it at any time.  For example, our rabbits may need a dance. <br><br><pre> <code class="javascript hljs">Rabbit.prototype.dance = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type + <span class="hljs-string"><span class="hljs-string">"   ."</span></span>); }; killerRabbit.dance(); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí     .</span></span></code> </pre><br><br>  It's comfortable.  But in some cases this leads to problems.  In previous chapters, we used an object as a way to associate values ‚Äã‚Äãwith names ‚Äî we created properties for these names, and gave them the appropriate values.  Here is an example from chapter 4: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">storePhi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event, phi</span></span></span><span class="hljs-function">) </span></span>{ map[event] = phi; } storePhi(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0.069</span></span>); storePhi(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-number"><span class="hljs-number">-0.081</span></span>);</code> </pre><br><br>  We can iterate all the phi values ‚Äã‚Äãin an object through a for / in loop, and check for the presence in it of a name through the in operator.  Unfortunately, we are hampered by the prototype object. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.nonsense = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> map) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí  // ‚Üí   // ‚Üí nonsense console.log("nonsense" in map); // ‚Üí true console.log("toString" in map); // ‚Üí true //    delete Object.prototype.nonsense;</span></span></code> </pre><br><br>  This is wrong.  There is no event called ‚Äúnonsense‚Äù.  And the more so there is no event called ‚ÄútoString‚Äù. <br><br>  It's interesting that toString did not get out in the for / in loop, although the in operator returns true to its account.  This is because JavaScript distinguishes between countable and uncountable properties. <br><br>  All properties that we create by assigning them a value are countable.  All standard properties in Object.prototype are uncountable, so they do not crawl out in for / in loops. <br><br>  We can declare our uncountable properties through the Object.defineProperty function, which allows us to specify the type of property being created. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype, <span class="hljs-string"><span class="hljs-string">"hiddenNonsense"</span></span>, {<span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> map) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí  // ‚Üí   console.log(map.hiddenNonsense); // ‚Üí </span></span></code> </pre><br><br>  Now the property is there, but in the cycle it does not crawl out.  Good.  But we are still hampered by the problem with the in operator, which states that the Object.prototype properties are present in our object.  To do this, we need the hasOwnProperty method. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(map.hasOwnProperty(<span class="hljs-string"><span class="hljs-string">"toString"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí false</span></span></code> </pre><br><br>  He says whether a property is a property of an object, without looking at the prototypes.  This is often more useful information than the in operator gives. <br><br>  If you are worried that someone else whose code you have loaded into your program has spoiled the main prototype of objects, I recommend writing for / in loops like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> map) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (map.hasOwnProperty(name)) { <span class="hljs-comment"><span class="hljs-comment">// ...     } }</span></span></code> </pre><br><br><h4>  Objects without prototypes </h4><br>  But the rabbit hole does not end there.  And if someone registered the name hasOwnProperty in the map object and assigned the value 42 to it?  Now the call to map.hasOwnProperty refers to a local property that contains a number, not a function. <br><br>  In this case, the prototypes only interfere, and we would like to have objects without any prototypes at all.  We have seen the Object.create function that allows you to create an object with a given prototype.  We can pass null for the prototype to create a fresh object without a prototype.  This is what we need for objects of type map, where there can be any properties. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); map[<span class="hljs-string"><span class="hljs-string">""</span></span>] = <span class="hljs-number"><span class="hljs-number">0.069</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"toString"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> map); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí false console.log("" in map); // ‚Üí true</span></span></code> </pre><br><br>  That's better!  We no longer need the hasOwnProperty pribluda, because all the properties of the object are set by us personally.  We calmly use for / in loops without regard to what people did with Object.prototype <br><br><h4>  Polymorphism </h4><br>  When you call a String function that converts a value to a string, for an object, it will call the toString method to create a meaningful string.  I mentioned that some standard prototypes declare their versions of toString to create strings more useful than just "[object Object]". <br><br>  This is a simple example of a powerful idea.  When a piece of code is written to work with objects through a specific interface ‚Äî in our case, through the toString method ‚Äî any object that supports this interface can be connected to the code ‚Äî and everything will just work. <br><br>  This technique is called polymorphism - although no one changes its shape.  Polymorphic code can work with values ‚Äã‚Äãof various forms, as long as they support the same interface. <br><br><h5>  Formatting the table </h5><br><br>  Let's look at an example in order to understand how polymorphism looks, and object-oriented programming in general.  The project is as follows: we will write a program that receives an array of arrays from table cells, and builds a row containing a beautifully formatted table.  That is, the columns and rows are aligned.  Like this: <br><br><pre> <code class="javascript hljs">name height country ------------ ------ ------------- Kilimanjaro <span class="hljs-number"><span class="hljs-number">5895</span></span> Tanzania Everest <span class="hljs-number"><span class="hljs-number">8848</span></span> Nepal Mount Fuji <span class="hljs-number"><span class="hljs-number">3776</span></span> Japan Mont Blanc <span class="hljs-number"><span class="hljs-number">4808</span></span> Italy/France Vaalserberg <span class="hljs-number"><span class="hljs-number">323</span></span> Netherlands Denali <span class="hljs-number"><span class="hljs-number">6168</span></span> United States Popocatepetl <span class="hljs-number"><span class="hljs-number">5465</span></span> Mexico</code> </pre><br><br>  It will work like this: the main function will ask each cell how wide and height it is, and then it uses this information to determine the width of the columns and the height of the rows.  Then she asks the cell to draw herself, and collects the results in one row. <br><br>  The program will communicate with the objects of the cells through a well-defined interface.  Cell types will not be hard coded.  We will be able to add new cell styles - for example, underlined cells in the header.  And if they support our interface, they will just work, without any changes in the program. <br>  <b>Interface:</b> <br><br>  <b>minHeight ()</b> returns a number indicating the minimum height the cell requires (expressed in lines) <br><br>  <b>minWidth ()</b> returns a number indicating the minimum width that the cell requires (expressed in characters) <br><br>  <b>draw (width, height)</b> returns an array of length height, containing sets of strings, each with a width of characters.  This is the contents of the cell. <br><br>  I will use higher order functions because they are very relevant here. <br><br>  The first part of the program calculates arrays of minimum widths of columns and row heights for the matrix of cells.  The rows variable will contain an array of arrays, where each internal array is a row of cells. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rowHeights</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rows</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rows.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> row.reduce(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">max, cell</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(max, cell.minHeight()); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">colWidths</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rows</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rows[<span class="hljs-number"><span class="hljs-number">0</span></span>].map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_, i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rows.reduce(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">max, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(max, row[i].minWidth()); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); }); }</code> </pre><br><br>  Using a variable whose name begins with (or consists entirely of) underscores (_), we show the person who will read the code that this argument will not be used. <br><br>  The rowHeights function should be straightforward.  It uses reduce to count the maximum height of the array of cells, and wraps it in map to pass through all the rows in the rows array. <br><br>  The situation with colWidths is more complicated, because the external array is an array of rows, not columns.  I forgot to mention that map (like forEach, filter and similar array methods) passes the second argument to the specified function ‚Äî the index of the current element.  Passing with the map elements of the first row and using only the second argument of the function, colWidths builds an array with one element for each index of the column.  The call to reduce goes through the external rows array for each index, and selects the width of the widest cell in that index. <br><br>  The code for the output table: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawTable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rows</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> heights = rowHeights(rows); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> widths = colWidths(rows); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawLine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">blocks, lineNo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> blocks.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">block</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> block[lineNo]; }).join(<span class="hljs-string"><span class="hljs-string">" "</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row, rowNum</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> blocks = row.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cell, colNum</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell.draw(widths[colNum], heights[rowNum]); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> blocks[<span class="hljs-number"><span class="hljs-number">0</span></span>].map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_, lineNo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> drawLine(blocks, lineNo); }).join(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rows.map(drawRow).join(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); }</code> </pre><br><br>  The drawTable function uses the internal drawRow function to draw all the rows, and connects them via newline characters. <br><br>  The drawRow function first turns the row cell objects into blocks, which are arrays of strings representing the contents of the cells, separated by lines.  A single cell containing the number 3776 can be represented by an array of one element [‚Äú3776‚Äù], and an underlined cell can take two lines and look like an array of [‚Äúname‚Äù, ‚Äú----‚Äù]. <br><br>  Blocks for rows that have the same height should be displayed next to each other.  The second map call in drawRow builds this line of output line by line, starting with the lines of the leftmost block, and then for each of them, complementing the line to the full width of the table.  These lines are then connected via a newline character, creating a whole row that drawRow returns. <br><br>  The drawLine function fetches lines that should appear next to each other from an array of blocks, and connects them separated by spaces to create a one character gap between the columns of the table. <br><br>  Let's write a constructor for cells that contain text that provides an interface for cells.  It breaks a string into an array of strings using the split method, which cuts the string every time it finds its argument, and returns an array of these chunks.  The minWidth method finds the maximum line width in the array. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">repeat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string, times</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; times; i++) result += string; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TextCell</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.text = text.split(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); } TextCell.prototype.minWidth = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.text.reduce(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">width, line</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(width, line.length); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); }; TextCell.prototype.minHeight = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.text.length; }; TextCell.prototype.draw = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">width, height</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; height; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> line = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.text[i] || <span class="hljs-string"><span class="hljs-string">""</span></span>; result.push(line + repeat(<span class="hljs-string"><span class="hljs-string">" "</span></span>, width - line.length)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; };</code> </pre><br><br>  The auxiliary function is used repeat, which builds a line with a given value, repeated a specified number of times.  The draw method uses it to indent lines so that they all have the required length. <br><br>  Let's draw for experience a 5x5 chessboard. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rows = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> row = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((j + i) % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) row.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextCell(<span class="hljs-string"><span class="hljs-string">"##"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> row.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextCell(<span class="hljs-string"><span class="hljs-string">" "</span></span>)); } rows.push(row); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(drawTable(rows)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí ## ## ## // ## ## // ## ## ## // ## ## // ## ## ##</span></span></code> </pre><br><br>  Works!  But since all cells have the same size, the table formatting code does not do anything interesting. <br><br>  The source data for the table of mountains that we are building is contained in the MOUNTAINS variable, you can <a href="">download it here</a> . <br><br>  We need to select the top row containing the column names with an underscore.  No problem - we just set the type of cell that does this. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnderlinedCell</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inner</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inner = inner; }; UnderlinedCell.prototype.minWidth = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inner.minWidth(); }; UnderlinedCell.prototype.minHeight = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inner.minHeight() + <span class="hljs-number"><span class="hljs-number">1</span></span>; }; UnderlinedCell.prototype.draw = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">width, height</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inner.draw(width, height - <span class="hljs-number"><span class="hljs-number">1</span></span>) .concat([repeat(<span class="hljs-string"><span class="hljs-string">"-"</span></span>, width)]); };</code> </pre><br><br>  The underlined cell contains another cell.  It returns the same size as the inner cell (via calls to its minWidth and minHeight methods), but adds one to the height because of the space occupied by the dashes. <br><br>  Drawing it is simple - we take the contents of the inner cell and add one line filled with dashes. <br><br>  Now that we have the main engine, we can write a function that builds a grid of cells from our data set. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataTable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keys = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(data[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> headers = keys.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnderlinedCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextCell(name)); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = data.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keys.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextCell(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(row[name])); }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [headers].concat(body); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(drawTable(dataTable(MOUNTAINS))); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí name height country // ------------ ------ ------------- // Kilimanjaro 5895 Tanzania // ‚Ä¶   </span></span></code> </pre><br><br>  The standard Object.keys function returns an array of object property names.  The top row of the table should contain underlined cells with column names.  The values ‚Äã‚Äãof all objects from the dataset look like normal cells under the heading - we extract them by passing the map function through the keys array to be sure that the same cell order is stored in each row. <br><br>  The summary table resembles the table from the example, only the numbers are not aligned to the right.  We will deal with this later. <br><br><h4>  Getters and Setters </h4><br>  When creating an interface, you can enter properties that are not methods.  We could just define minHeight and minWidth as variables for storing numbers.  But this would require us to write code to calculate their values ‚Äã‚Äãin the constructor ‚Äî which is bad, since the construction of the object is not directly related to them.  There could be problems when, for example, an internal cell or an underlined cell changes - and then their size must also change. <br><br>  These considerations have led to the fact that properties that are not methods, many do not include in the interface.  Instead of directly accessing property values, methods like getSomething and setSomething are used to read and write property values.  But there is also a minus - you have to write (and read) a lot of additional methods. <br><br>  Fortunately, JavaScript gives us a technique that uses the best of both approaches.  We can set properties that look ordinary from the outside, but secretly have methods associated with them. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pile = { <span class="hljs-attr"><span class="hljs-attr">elements</span></span>: [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>], get height() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elements.length; }, set height(value) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"    "</span></span>, value); } }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(pile.height); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 3 pile.height = 100; // ‚Üí     100</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the declaration of an object, a get or set entry allows you to specify a function that will be called when a property is read or written. </font><font style="vertical-align: inherit;">You can also add such a property to an existing object, for example, to prototype, using the Object.defineProperty function (we used it before, creating uncountable properties).</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(TextCell.prototype, <span class="hljs-string"><span class="hljs-string">"heightProp"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.text.length; } }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextCell(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(cell.heightProp); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 2 cell.heightProp = 100; console.log(cell.heightProp); // ‚Üí 2</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also set the property set in the object passed to defineProperty to set the setter method. </font><font style="vertical-align: inherit;">When there is a getter, and there is no setter, the attempt to write to the property is simply ignored.</font></font><br><br><h4>  Inheritance </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But we have not finished our table formatting exercise. It would be more convenient to read it if the numeric column were aligned to the right. We need to create another type of cell like TextCell, but instead of adding text with spaces on the right, it complements it on the left to align it with the right edge. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We could write a new constructor with all three methods in the prototype. But prototypes themselves can have prototypes, and therefore we can do smarter.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RTextCell</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ TextCell.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, text); } RTextCell.prototype = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(TextCell.prototype); RTextCell.prototype.draw = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">width, height</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; height; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> line = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.text[i] || <span class="hljs-string"><span class="hljs-string">""</span></span>; result.push(repeat(<span class="hljs-string"><span class="hljs-string">" "</span></span>, width - line.length) + line); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; };</code> </pre><br><br>       minHeight  minWidth   TextCell.  RTextCell     TextCell,   ,    draw   . <br><br>    .     -      ,    .      (  call,        ).     ,   ,      , .       ,           .  ,     ,     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If we slightly edit the dataTable function so that it uses RTextCells for the numerical cells, we will get the table we need. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataTable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keys = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(data[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> headers = keys.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnderlinedCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextCell(name)); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = data.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keys.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = row[name]; <span class="hljs-comment"><span class="hljs-comment">//  : if (typeof value == "number") return new RTextCell(String(value)); else return new TextCell(String(value)); }); }); return [headers].concat(body); } console.log(drawTable(dataTable(MOUNTAINS))); // ‚Üí ‚Ä¶   </span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inheritance is the main part of the object-oriented tradition, along with encapsulation and polymorphism. </font><font style="vertical-align: inherit;">But, while the last two are perceived as great ideas, the first is controversial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basically, because it is usually confused with polymorphism, they represent a more powerful tool than it actually is, and are misused. </font><font style="vertical-align: inherit;">While encapsulation and polymorphism are used to separate parts of the code and reduce the coherence of the program, inheritance binds the types together and creates greater coherence.</font></font><br><br>      .        ‚Äì       .         ,         ‚Äì        .       ‚Äì  UnderlinedCell      .              . <br><br><h4>  instanceof </h4><br>   ,      .   JavaScript     instanceof. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RTextCell(<span class="hljs-string"><span class="hljs-string">"A"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> RTextCell); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true console.log(new RTextCell("A") instanceof TextCell); // ‚Üí true console.log(new TextCell("A") instanceof RTextCell); // ‚Üí false console.log([1] instanceof Array); // ‚Üí true</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The operator passes through inherited types. RTextCell is an instance of TextCell, because RTextCell.prototype is derived from TextCell.prototype. The operator can also be applied to standard Array constructors. Almost all objects are Object instances.</font></font><br><br><h4>  Total </h4><br> ,     ,     .     ‚Äì   ,     ,      ,     ,      .     Object.prototype/ <br><br> ,‚Äì ,       ,-     new   .     ,    prototype .   ,  ,        ,   .  instanceof,      ,  ,      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For objects, you can make an interface and tell everyone to communicate with an object only through this interface. </font><font style="vertical-align: inherit;">The remaining details of the implementation of the object are now encapsulated, hidden behind the interface. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And after that, no one forbade the use of different objects using the same interfaces. </font><font style="vertical-align: inherit;">If different objects have the same interfaces, then the code working with them can work with different objects in the same way. </font><font style="vertical-align: inherit;">This is called polymorphism, and it is a very useful thing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Defining several types that differ only in small details, it is convenient to simply inherit the prototype of the new type from the prototype of the old type, so that the new constructor calls the old one. </font><font style="vertical-align: inherit;">This gives you an object type similar to the old one, but you can add properties to it or override old ones.</font></font><br><br><h4>  Exercises </h4><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vector type </font></font></h5><br>   Vector,     .    x  y (),     . <br><br>   Vector  , plus  minus,       ,    ,    x  y     ( this,  ‚Äî ) <br><br>   length  ,    ‚Äì   (0, 0)  (x, y). <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   console.log(new Vector(1, 2).plus(new Vector(2, 3))); // ‚Üí Vector{x: 3, y: 5} console.log(new Vector(1, 2).minus(new Vector(2, 3))); // ‚Üí Vector{x: -1, y: -1} console.log(new Vector(3, 4).length); // ‚Üí 5</span></span></code> </pre><br><br><h5>    </h5><br>    StretchCell(inner, width, height),       .      (  UnderlinedCell),  ,          ,       . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  . var sc = new StretchCell(new TextCell("abc"), 1, 2); console.log(sc.minWidth()); // ‚Üí 3 console.log(sc.minHeight()); // ‚Üí 2 console.log(sc.draw(3, 2)); // ‚Üí ["abc", " "]</span></span></code> </pre><br><br><h5>    </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Develop an interface that abstracts a set of values. </font><font style="vertical-align: inherit;">An object with this interface is a sequence, and the interface must allow the code to go through the sequence, work with the values ‚Äã‚Äãthat make it up, and somehow signal that we have reached the end of the sequence. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having set the interface, try to make a logFive function that accepts a sequence object and calls console.log for its first five elements ‚Äî or for a smaller number if there are less than five. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then create an ArraySeq object type that wraps the array and allows passage through the array using the interface you developed. </font><font style="vertical-align: inherit;">Create another type of object, RangeSeq, which goes through a range of numbers (its constructor must take arguments from and to).</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  . logFive(new ArraySeq([1, 2])); // ‚Üí 1 // ‚Üí 2 logFive(new RangeSeq(100, 1000)); // ‚Üí 100 // ‚Üí 101 // ‚Üí 102 // ‚Üí 103 // ‚Üí 104</span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/241587/">https://habr.com/ru/post/241587/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../241573/index.html">VMware broke the CBT mechanism for backing up virtual machines</a></li>
<li><a href="../241577/index.html">The book ‚ÄúGetting Started with LLVM Core Libraries‚Äù has been released.</a></li>
<li><a href="../241579/index.html">Deploy Django apps using Ansible for Dummies</a></li>
<li><a href="../241581/index.html">A brief excursion into the cooling server</a></li>
<li><a href="../241585/index.html">Differences between Windows Mobile and Windows CE in data collection terminals</a></li>
<li><a href="../241589/index.html">Overview of Microsoft Azure platform updates for September</a></li>
<li><a href="../241591/index.html">Web Application Development Basics</a></li>
<li><a href="../241593/index.html">Taming Interfaces or One Report on Wake Up Province</a></li>
<li><a href="../241595/index.html">Updated the maximum: What to invest their finances in the conditions of the devaluation of the ruble</a></li>
<li><a href="../241599/index.html">We connect the Chinese meteorological station</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>