<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We sort XML by means of Oracle database</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It would seem, why in general it may be necessary to parse XML on the side of the database? 

 But there may be many reasons, and each of them may hav...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We sort XML by means of Oracle database</h1><div class="post__text post__text-html js-mediator-article">  It would seem, why in general it may be necessary to parse XML on the side of the database? <br><br>  But there may be many reasons, and each of them may have their own.  Some, including me, do not hesitate to implement applied logic by means of a database, but for some it seems to be an archaic relic and the usefulness of tools for working with XML in a DBMS, it may seem doubtful to such people.  However, I believe that very few people will object to the usefulness of having such an opportunity during the operation phase of an application.  For example, the price list of the wholesaler did not accept the application from us ‚Äî it swirled a mess at the lack of recoding for some items.  More than 20k positions in XML - go and figure out where the dog rummaged, what exactly embarrassed the application.  Agree, because it would be great to be able to present a list of products listed in XML as a data set that can be connected to a transcoder table, in order to reveal in one fell swoop all positions that do not have transcoding?  And there can be many such examples.  I have been engaged in supporting an application that integrates with external systems through the exchange of XML messages, and despite the fact that the application did not use the tools provided by Oracle itself, it turned out to be very useful for me and my colleagues with the support of this product. <br><br>  In this article, I would like to demonstrate how easy and easy it is to parse XML of various degrees of complexity using the tools of the Oracle Database. <br><a name="habracut"></a><br>  I absolutely would not want to touch the DOM parser here.  Let me just say that it is, implemented by the DBMS_XMLDOM package.  At times, it can be extremely useful to the developer, and it will not be difficult for anyone who has previously encountered DOM parsers from other manufacturers to deal with it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      An innovative feature of the oracle is the XMLType type and the means of working with it.  This type is part of the XML DB technology, which has been included with the Oracle Database since version 9.2. <br><br>  The source text of the XML document can be passed to the XMLType constructor as values ‚Äã‚Äãof types CLOB, BLOB, VARCHAR2, BFILE.  Perhaps it is worth noting that BFILE allows you to download a file from the server's file system - not a client, so if our XML is on the client side and it is large enough to be passed as a string in the request, you should probably take care of the possibility of delivering the file from XML content on the server file system. <br><br>  An example of creating an instance of XMLType, with the content passed in a string: <br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">XMLType</span></span>( <span class="hljs-string"><span class="hljs-string">'&lt;hello-world&gt; &lt;word seq="1"&gt;Hello&lt;/word&gt; &lt;word seq="2"&gt;world&lt;/word&gt; &lt;/hello-world&gt; '</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">XML</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual</code> </pre> <br>  By creating an instance of XMLType, you can try to take the first tentative steps to parse our XML.  The XMLType type implements the Extract method, which, when accepting an XPatch expression, returns an XML fragment that matches this expression.  An XML fragment (XML Fragment), unlike a well-formed XML (whellformed XML), allows for the absence of a root element (or, in other words, allowing more than one root element in its composition). <br><br>  So in the example below, the three expressions return three pieces of XML.  The first one returns all occurrences of the word element, the second one returns only its first occurrence, the third one returns a fragment of the text content of the word element, for which the value of the seq attribute is two. <br><pre> <code class="sql hljs">SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> demo1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">XMLType</span></span>( <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;hello-world&gt; 4 &lt;word seq="1"&gt;Hello&lt;/word&gt; 5 &lt;word seq="2"&gt;world&lt;/word&gt; 6 &lt;/hello-world&gt; 7 '</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">xml</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-number"><span class="hljs-number">9</span></span> ) <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> t.xml.extract(<span class="hljs-string"><span class="hljs-string">'//word'</span></span>) case1 <span class="hljs-number"><span class="hljs-number">11</span></span> ,t.xml.extract(<span class="hljs-string"><span class="hljs-string">'//word[position()=1]'</span></span>) case2 <span class="hljs-number"><span class="hljs-number">12</span></span> ,t.xml.extract(<span class="hljs-string"><span class="hljs-string">'//word[@seq=2]/text()'</span></span>) case3 <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> demo1 t; CASE1 CASE2 CASE3 <span class="hljs-comment"><span class="hljs-comment">--------------------------- -------------------------- ------- &lt;word seq="1"&gt;Hello&lt;/word&gt; &lt;word seq="1"&gt;Hello&lt;/word&gt; world &lt;word seq="2"&gt;world&lt;/word&gt;</span></span></code> </pre><br>  Here, I think, it is worth putting a bold emphasis on the fact that in the third case it is the XML fragment that is returned, not the value of this element.  Differences will become noticeable only when this value contains wildcard (escaped) characters, such as &amp; amp; &amp; gt ;.  In order to get the value of an element, use the extractValue function.  Here I will mention that the main XMLType methods are duplicated by SQL functions, or vice versa, the main functions of working with XMLType are implemented in the form of its methods.  However, extractValue is an exception.  extractValue is represented only as a function.  XMLType, unfortunately, does not implement the extractValue method. <br><pre> <code class="sql hljs">SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> demo2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">xmltype</span></span>(<span class="hljs-string"><span class="hljs-string">'&lt;a&gt;&amp;lt;&amp;amp;hello&amp;amp;&amp;gt;&lt;/a&gt;'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">xml</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual) <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> t.xml.extract(<span class="hljs-string"><span class="hljs-string">'a/text()'</span></span>).getStringVal() case1 <span class="hljs-number"><span class="hljs-number">3</span></span> ,extractValue(t.xml,<span class="hljs-string"><span class="hljs-string">'a'</span></span>) case2 <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> demo2 t; CASE1 CASE2 <span class="hljs-comment"><span class="hljs-comment">--------------------------- -------------------------- &amp;lt;&amp;amp;hello&amp;amp;&amp;gt; &lt;&amp;hello&amp;&gt;</span></span></code> </pre><br>  Perhaps we should also mention the rules for working with namespaces.  Not all intuition leads to a correct understanding of these mechanisms of work.  The functions (and method) extract, extractValue, as one of the parameters, accept the namespace description.  The namespaces described in this parameter can be used in an XPath expression.  And that is what I want to emphasize.  Pay attention to the third case.  Namespaces in XML and XPatch expressions have different aliases, but they have the same URI, so parsing is successful. <br><pre> <code class="sql hljs">SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> extractValue(t.xml,<span class="hljs-string"><span class="hljs-string">'a'</span></span>) case1 <span class="hljs-number"><span class="hljs-number">2</span></span> ,extractValue(t.xml,<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'xmlns="foo"'</span></span>) case2 <span class="hljs-number"><span class="hljs-number">3</span></span> ,extractValue(t.xml,<span class="hljs-string"><span class="hljs-string">'y:a/@z:val'</span></span>,<span class="hljs-string"><span class="hljs-string">'xmlns:y="foo" xmlns:z="bar"'</span></span>) case3 <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">XMLType</span></span>(<span class="hljs-string"><span class="hljs-string">'&lt;a xmlns="foo" xmlns:x="bar" x:val="a-val"&gt;a-text&lt;/a&gt;'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">XMl</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual) t; CASE1 CASE2 CASE3 <span class="hljs-comment"><span class="hljs-comment">--------------------------- -------------------------- -------------------------- a-text a-val</span></span></code> </pre><br>  So, having learned to extract the values, now we should learn to separate them.  Let me remind you that in the first case, for the first example, we tried to select all word elements from XML, and we succeeded; we received two word elements, but we got them in one fragment.  In order to represent a fragment containing several root elements as a sequence of fragments, each of which contains one root element, there is a pipelined function XMLSeqence.  The function returns XMLSequenceType, which is a table of XMLType values. <br><br>  If suddenly someone forgot, I will remind that pipeline functions return as though collections, therefore by a call turn around expression of table.  The results of these functions are accessed using the virtual column column_value, or the value () expression, and therefore for a table expression (table collection excpression) you should define an alias.  If suddenly someone did not know this, I recommend memorizing it as a mantra, understanding will come with time, and then only if necessary. <br><br>  The simplest example of using XMLSequence is: <br><pre> <code class="sql hljs">SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> extractValue(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>(t),<span class="hljs-string"><span class="hljs-string">'b'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(XMLSequence(<span class="hljs-keyword"><span class="hljs-keyword">XMLType</span></span>(<span class="hljs-string"><span class="hljs-string">'&lt;a&gt;&lt;b&gt;b1&lt;/b&gt;&lt;b&gt;b2&lt;/b&gt;&lt;/a&gt;'</span></span>).extract(<span class="hljs-string"><span class="hljs-string">'a/b'</span></span>))) t; RESULT <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------- b1 b2</span></span></code> </pre><br>  I will try to say what is happening here, although I am afraid that in Russian this will turn out to be much more messy and much less clear than in SQL.  In the from expression, we first create an instance of XMLType, passing it a string containing the XML text.  Next, using the extract method, we extract in one fragment all the elements of b that element a contains.  The resulting XML fragment is passed by the parameter to the pipeline function XMLSequence, which is called using the table clause to call which, according to the rules of the grammar.  The record set described by this clause is assigned an alias t.  In select-list'e we get an instance of the object returned by the table expression t, it has the type XMLType.  For each row returned by a table expression, this instance contains one fragment of the source XML element b.  Pass this object as a parameter to the extractValue function.  The result - on the face. <br><br>  In fact, everything is not as difficult as it turns out in my presentation.  To this it is enough just to get used to it.  But brain violence is not yet fully completed.  What we did at this stage only works for one XML document.  If we have the source code of several XML in the table and we need to parse several of them at once, we will have to remember what left correlation is.  Here, too, there is nothing military.  This piece is thought up by Oraklom and especially for tabular expressions (table collection expression).  The bottom line is that values ‚Äã‚Äãin a table expression can be used (columns) from the data sets defined in the from expression before (to the left) of the table expression itself.  In practice, this does not look so terrible as it is heard: <br><pre> <code class="sql hljs">SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> demo3 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">XMLType</span></span>(<span class="hljs-string"><span class="hljs-string">'&lt;a&gt;&lt;b&gt;b1&lt;/b&gt;&lt;b&gt;b2&lt;/b&gt;&lt;/a&gt;'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">xml</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">XMLType</span></span>(<span class="hljs-string"><span class="hljs-string">'&lt;a&gt;&lt;b&gt;b3&lt;/b&gt;&lt;b&gt;b4&lt;/b&gt;&lt;/a&gt;'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">xml</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual) <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> xml_id <span class="hljs-number"><span class="hljs-number">4</span></span> ,extractValue(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>(t),<span class="hljs-string"><span class="hljs-string">'b'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> demo3 s,<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(XMLSequence(s.xml.extract(<span class="hljs-string"><span class="hljs-string">'a/b'</span></span>))) t; XML_ID RESULT <span class="hljs-comment"><span class="hljs-comment">---------- -------------------------------------------------- 1 b1 1 b2 2 b3 2 b4</span></span></code> </pre><br>  Here, in the table expression t, the xml value of the demo3 table is used.  The expression will be calculated for each row of the demo3 table.  This is the very thing called such an elaborate word - the left correlation. <br><br>  The described functionality is quite enough to parse the XML of almost any complexity.  These tools can not be parsed, perhaps, only the hierarchically presented data of a knowingly unknown depth of nesting.  To parse such structures will have to resort to XSLT, to bring XML to a more readable form.  The XSLT transformation is performed by the XMLTransform function, which takes the XMLType of the source document, the second XMLType of the XSL template, and returns the XMLType of the transformation result as the first parameter. <br><br>  In principle, this theory can be completed.  In conclusion, I‚Äôll only demonstrate an example of extracting elements from different levels of XML nesting.  For beginners it sometimes causes difficulties. <br><pre> <code class="sql hljs">SQL&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> demo4 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>( <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">XMLType</span></span>( <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;master&gt; 4 &lt;id&gt;mater id&lt;/id&gt; 5 &lt;details&gt; 6 &lt;detail&gt; 7 &lt;id&gt;detail 1 id&lt;/id&gt; 8 &lt;sub_details&gt; 9 &lt;sub_detail&gt; 10 &lt;id&gt;sub_detail 1.1 id&lt;/id&gt; 11 &lt;/sub_detail&gt; 12 &lt;sub_detail&gt; 13 &lt;id&gt;sub_detail 1.2 id&lt;/id&gt; 14 &lt;/sub_detail&gt; 15 &lt;/sub_details&gt; 16 &lt;/detail&gt; 17 &lt;detail&gt; 18 &lt;id&gt;detail 2 id&lt;/id&gt; 19 &lt;sub_details&gt; 20 &lt;sub_detail&gt; 21 &lt;id&gt;sub_detail 2.1 id&lt;/id&gt; 22 &lt;/sub_detail&gt; 23 &lt;sub_detail&gt; 24 &lt;id&gt;sub_detail 2.2 id&lt;/id&gt; 25 &lt;/sub_detail&gt; 26 &lt;/sub_details&gt; 27 &lt;/detail&gt; 28 &lt;detail&gt; 29 &lt;id&gt;detail 3 id&lt;/id&gt; 30 &lt;/detail&gt; 31 &lt;/details&gt; 32 &lt;/master&gt;'</span></span> <span class="hljs-number"><span class="hljs-number">33</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">xml</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual) <span class="hljs-number"><span class="hljs-number">34</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> extractValue(s.xml,<span class="hljs-string"><span class="hljs-string">'master/id'</span></span>) master_id <span class="hljs-number"><span class="hljs-number">35</span></span> ,extractValue(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>(dtl),<span class="hljs-string"><span class="hljs-string">'detail/id'</span></span>) detail_id <span class="hljs-number"><span class="hljs-number">36</span></span> ,extractValue(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>(subdtl),<span class="hljs-string"><span class="hljs-string">'sub_detail/id'</span></span>) sub_detail_id <span class="hljs-number"><span class="hljs-number">37</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> demo4 s <span class="hljs-number"><span class="hljs-number">38</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(XMLSequence(s.xml.extract(<span class="hljs-string"><span class="hljs-string">'master/details/detail'</span></span>))) dtl <span class="hljs-number"><span class="hljs-number">39</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(XMLSequence(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>(dtl).extract(<span class="hljs-string"><span class="hljs-string">'detail/sub_details/sub_detail'</span></span>)))(+) subdtl; MASTER_ID DETAIL_ID SUB_DETAIL_ID <span class="hljs-comment"><span class="hljs-comment">--------------------------- -------------------------- -------------------------- mater id detail 1 id sub_detail 1.1 id mater id detail 1 id sub_detail 1.2 id mater id detail 2 id sub_detail 2.1 id mater id detail 2 id sub_detail 2.2 id mater id detail 3 id</span></span></code> </pre><br>  As you can see, there is nothing new here.  All the same left correlation.  The only thing that I would like to draw attention to (+) at the end of the table expression is subdtl.  As probably not difficult to guess, it means that you should use an external connection.  If we didn‚Äôt specify it, we wouldn‚Äôt get lines with detail 3. <br><br>  So, what appeared before our eyes?  We have one object type, a relatively limited set of functions, which gives a practically unlimited set of possibilities.  I really like this implementation.  I am particularly impressed that Oracle corp did not have to align the semantics of their SQL in order to write XML into it.  All described features - objects, conveyor functions, table expressions are used by this technology, but not created specifically for it.  It turns out that anyone could implement such an implementation.  This implementation by the fat line underlines the power and flexibility of the Oracle SQL engine. <br><br>  On this note, I could have finished, however, the question that I anticipated, and with reproach, does not give me peace.  ‚ÄúMy friend, in what century do you live in general, did you look at the calendar for a long time?  The yard is nearing the end of 2011, the year is now far from being the first production raised at the 11-2 version of the database, and you are still chewing the ninth functional. ‚Äù  Yes, there is such a sin for me.  I know perfectly well that in the 10th version, we introduced a wonderful XMLTable, which completely pushes the functionality that I just described into the background.  Allowing it is even easier and no longer forced to parse XML.  However, with XMLTable, I still do not have enough experience to say anything beyond the already obvious.  Therefore I will confine myself to a simple demonstration. <br><br>  I will show on the same example: <br><pre> <code class="sql hljs"> 34 <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> master_id <span class="hljs-number"><span class="hljs-number">35</span></span> ,details_id <span class="hljs-number"><span class="hljs-number">36</span></span> ,sub_details_id <span class="hljs-number"><span class="hljs-number">37</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> demo4 s <span class="hljs-number"><span class="hljs-number">38</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">XMLTable</span></span>(<span class="hljs-string"><span class="hljs-string">'master'</span></span> <span class="hljs-number"><span class="hljs-number">39</span></span> <span class="hljs-keyword"><span class="hljs-keyword">passing</span></span> (s.xml) <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> master_id varchar2 (<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">path</span></span> <span class="hljs-string"><span class="hljs-string">'id'</span></span> <span class="hljs-number"><span class="hljs-number">41</span></span> ,details <span class="hljs-keyword"><span class="hljs-keyword">XMLType</span></span> <span class="hljs-keyword"><span class="hljs-keyword">path</span></span> <span class="hljs-string"><span class="hljs-string">'details/detail'</span></span>) mstr <span class="hljs-number"><span class="hljs-number">42</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">XMLTable</span></span>(<span class="hljs-string"><span class="hljs-string">'detail'</span></span> <span class="hljs-number"><span class="hljs-number">43</span></span> <span class="hljs-keyword"><span class="hljs-keyword">passing</span></span> (mstr.details) <span class="hljs-number"><span class="hljs-number">44</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> details_id varchar2 (<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">path</span></span> <span class="hljs-string"><span class="hljs-string">'id'</span></span> <span class="hljs-number"><span class="hljs-number">45</span></span> ,sub_details <span class="hljs-keyword"><span class="hljs-keyword">XMLType</span></span> <span class="hljs-keyword"><span class="hljs-keyword">path</span></span> <span class="hljs-string"><span class="hljs-string">'sub_details/sub_detail'</span></span>)(+) dtl <span class="hljs-number"><span class="hljs-number">46</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">XMLTable</span></span>(<span class="hljs-string"><span class="hljs-string">'sub_detail'</span></span> <span class="hljs-number"><span class="hljs-number">47</span></span> <span class="hljs-keyword"><span class="hljs-keyword">passing</span></span> (dtl.sub_details) <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> sub_details_id varchar2 (<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">path</span></span> <span class="hljs-string"><span class="hljs-string">'id'</span></span>)(+) sub_dtl; MASTER_ID DETAILS_ID SUB_DETAILS_ID <span class="hljs-comment"><span class="hljs-comment">--------------------------- -------------------- -------------------- mater id detail 1 id sub_detail 1.1 id mater id detail 1 id sub_detail 1.2 id mater id detail 2 id sub_detail 2.1 id mater id detail 2 id sub_detail 2.2 id mater id detail 3 id</span></span></code> </pre><br>  It would seem that there are many more letters, a fair question may arise ... what is the profit of innovation?  The profit is that the first parameter in the XMLTable is no longer an XPath expression, but an XQuery.  So, the union can be made by its means, and not by means of SQL.  XMLTable promises to be that same yummy, but, alas, I repeat, I still have nothing to say about it. </div><p>Source: <a href="https://habr.com/ru/post/129018/">https://habr.com/ru/post/129018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../129009/index.html">Soviet cartoons on the App Store</a></li>
<li><a href="../129010/index.html">Website creation on MODx CMS - video lesson</a></li>
<li><a href="../129011/index.html">About childhood and children</a></li>
<li><a href="../129014/index.html">Kitchen ABBYY Lingvo: conversations in the ranks!</a></li>
<li><a href="../129015/index.html">Double pleasure</a></li>
<li><a href="../129019/index.html">Developing a cross-platform editor with syntax highlighting based on wxStyledTextCtrl</a></li>
<li><a href="../129021/index.html">The cat in the bag of the company Samsung</a></li>
<li><a href="../129024/index.html">The existence of a malware business as proof of the incapacity of the security industry</a></li>
<li><a href="../129026/index.html">Canobuvosti, 110th edition</a></li>
<li><a href="../129027/index.html">Removing unused assemblies from a .NET project</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>