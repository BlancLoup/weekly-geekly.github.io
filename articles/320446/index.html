<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mapping in C # on the example of the serializer for AMF</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings, friends. Today we will discuss the implementation of mapping in C #, as well as the use of this implementation in solving real problems on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mapping in C # on the example of the serializer for AMF</h1><div class="post__text post__text-html js-mediator-article">  Greetings, friends.  Today we will discuss the implementation of mapping in C #, as well as the use of this implementation in solving real problems on the example of sending AMF data to the server.  All of the following does not pretend to any standards for the implementation of algorithms and patterns of code design, it is only a description of one of the many, not always obvious to beginners, solutions. <br><br>  In the process of studying the article, you will learn how to implement your own <b>attributes</b> and how to apply them, get acquainted with the <b>methods of type extensions</b> and the application of <b>reflection</b> in practice, learn about the <b>basics of MSIL</b> in general and <b>OpCodes</b> in particular, as well as how you can <b>serialize objects in AMF using threads</b> . <br><a name="habracut"></a><br><h2>  Formulation of the problem </h2><br>  To begin with, let's make an approximate list of tasks that we will need to solve in this article.  Let it look like this: <br><br><ul><li>  The ability to describe all types of server data in C # code and convenient to work with them; </li><li>  The ability to serialize / deserialize any type (as described by us or not); </li><li>  The mechanism itself is sending data to the server. </li></ul><br>  As part of this article, we will work with you with some kind of ready abstract server (in your case, this is a real working server, implemented without your participation).  Suppose we know that the server-side is written in Flex, so we have already received a direct link to which we need to send an AMF object.  To work directly with AMF itself, we have a wonderful <a href="https://www.nuget.org/packages/fluorinefx/">FluorineFX</a> framework, providing us with all the necessary tools to organize Flex support on both the server side and the client side.  But the trouble is, when it comes to the very long-awaited moment of sending an object to the server, it turns out that FluorineFX does not provide convenient means for mapping, and all our objects sent to the server will fly with the original type metadata.  In fact, this is absolutely not a problem if you are the author of the client- and server-pollack, but what about situations where you need to send data packets that have a custom structure?  Repeating 1 to 1 namespaces and type names is not always convenient (and sometimes impossible at all).  A little googling, we find quite a working <a href="https://habrahabr.ru/post/111041/">solution</a> nearby.  Immediately consider its main advantages and disadvantages: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Pros: <br><br><ul><li>  <b>Speed.</b>  Directly edit the source code FluorineFX, collect and rejoice. </li></ul><br>  Minuses: <br><br><ul><li>  <b>Support.</b>  If you work in a team, you will have to ensure that the source code for FluorineFX is always available to all team members and is always up to date.  This entails a larger amount of project code, and therefore more time to support it; <br><br></li><li>  <b>Update.</b>  If a new version of FluorineFX is released, you will have to re-update the entire source code and make changes to it, while maintaining maximum compatibility, which is not very convenient.  Here, perhaps, the only positive moments - it is not always possible to require new functionality from the updates, and the framework itself is rarely updated.  But for an optimal workflow (as well as for cases when a similar situation may occur when solving a different task) this moment is quite critical. </li></ul><br>  For those whom the cons of this solution do not confuse, all the material described below may not be needed.  For those who decided to go along with me to a detour and find a more flexible solution, the material below will be very interesting. <br><br><h2>  Work with attributes </h2><br>  In general, the approach described in the <a href="https://habrahabr.ru/post/111041/">solution</a> goes in the right direction.  Mapping itself implies some kind of binding at the level of type metadata, for this we need attributes. <br><br>  Let's first make a rough description of how our types should look like when preparing these for serialization in AMF.  Provide the following features: <br><br><ul><li>  Types for which an attribute is specified are serialized with the name specified in the attribute property; </li><li>  Types for which an attribute is not specified (or those attributes for which the property is null) are serialized with the original name of the type defined in the original assembly; </li><li>  Properties and fields of types for which an attribute is specified are serialized with the name specified in the attribute property; </li><li>  Properties and fields of types for which an attribute is specified, but the attribute property is null, are serialized with the original name of the type defined in the original assembly; </li><li>  Properties and fields of types for which an attribute is not specified are not involved in the serialization process and are not part of the members of the final type; </li><li>  Dictionaries must be serialized as AMF associative arrays. </li><li>  Any array types must be serialized as arrays of AMF objects. </li><li>  Built-in types must be serialized as AMF built-in types. </li></ul><br>  Let's start with the implementation of our attribute class.  We can write a single attribute for object types and field types and object properties (similar to the <a href="https://habrahabr.ru/post/111041/">solution</a> ), but I recommend implementing separate attributes for types and member types, which will be useful in the future for cases when it is necessary to separate the metadata processing logic of different instance types.  First, we implement the attribute class for object types: <br><br><pre><code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///      AMF. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; [AttributeUsage(AttributeTargets.<span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> | AttributeTargets.Struct)] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AmfObjectAttribute : <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> { /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///   . /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> string <span class="hljs-type"><span class="hljs-type">Name</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///     &lt;see cref="AmfObjectAttribute"/&gt;. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="name"&gt;  .&lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> AmfObjectAttribute(string <span class="hljs-type"><span class="hljs-type">name</span></span>) { <span class="hljs-type"><span class="hljs-type">Name</span></span> = <span class="hljs-type"><span class="hljs-type">name</span></span>; } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///     &lt;see cref="AmfObjectAttribute"/&gt;. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> AmfObjectAttribute() : this(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { } }</code> </pre> <br>  A couple of key points in the implementation of attributes: <br><br><ul><li>  Any attribute must inherit from the <b>System.Attribute</b> class; </li><li>  The AttributeUsageAttribute <b>attribute is</b> required to define the scope of an attribute.  With it, you can set and exclude the types of metadata to which the implemented attribute will be applicable; </li><li>  If you do not set the default constructor, you cannot explicitly assign values ‚Äã‚Äãto attribute properties when it is initialized, only through an overloaded constructor with parameters; </li><li>  When specifying the attribute type, the suffix <i>... Attribute</i> can be omitted. </li></ul><br>  The <b>AmfObjectAttribute</b> attribute will be applied to object types.  If this attribute is applied, the type name of the serialized object will match the value specified in the <b>AmfObjectAttribute</b> property <b>.</b>  <b><i>Name</i></b> , if the property value is null - the serialized object will have the original type name.  I deliberately did not make a check for the presence of an attribute on types in order to realize the possibility of serialization of type objects not marked with this attribute. <br><br>  Now we implement the attribute class for the properties and fields of the types: <br><br><pre> <code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///          AMF. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AmfMemberAttribute : <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> { /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///    . /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> string <span class="hljs-type"><span class="hljs-type">Name</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///     &lt;see cref="AmfMemberAttribute"/&gt;. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="name"&gt;   .&lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> AmfMemberAttribute(string <span class="hljs-type"><span class="hljs-type">name</span></span>) { <span class="hljs-type"><span class="hljs-type">Name</span></span> = <span class="hljs-type"><span class="hljs-type">name</span></span>; } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///     &lt;see cref="AmfMemberAttribute"/&gt;. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> AmfMemberAttribute() : this(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { } }</code> </pre><br>  With the implementation of the attributes figured out, now let's just write a simple class that describes a certain data model.  In the future we will use it for tests: <br><br><pre> <code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///   AMF-  .         "namespase.of.your.object". /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; [AmfObject("namespase.of.your.object")] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> CustomAmfObject { /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///    &lt;see cref="bool"/&gt;.       "bit_prop". /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; [AmfMember("bit_prop")] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> BooleanProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///    &lt;see cref="sbyte"/&gt;.       UnsignedByteProperty. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; [AmfMember] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> sbyte UnsignedByteProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } = <span class="hljs-number"><span class="hljs-number">2</span></span>; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///    &lt;see cref="string"/&gt;.    . /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> string StringProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } = "test"; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///    &lt;see cref="bool"/&gt;.       "bit_fld". /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; [AmfMember("bit_fld")] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> booleanField = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///    &lt;see cref="float"/&gt;.       singleField. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; [AmfMember] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> singleField = <span class="hljs-number"><span class="hljs-number">-5.00065</span></span>f; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///    &lt;see cref="string"/&gt;.    . /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> string stringField = "test2"; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///     &lt;see cref="CustomAmfObject"/&gt;. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> CustomAmfObject() { } }</code> </pre><br>  Attributes are written, the test class is implemented.  Now we need to start solving the problem of serialization itself.  If we plan to support the .NET 2.0 version, then we need to implement a serialization class that will work with instances of objects and carry out various manipulations with the metadata of their types.  We will write code with regard to the support of the .NET 3.5 version, because there appeared two very significant features for the C # engineer: LINQ and type extension methods.  We will apply them to solve our problem. <br><br><h2>  Extension methods and reflection </h2><br>  To implement the type extension method, simply declare a public static class and add the this modifier to the first parameter.  These conditions are mandatory, otherwise the compiler simply does not understand that the method is an extension of the type.  After implementation, the method can be applied to any object whose type matches or follows from the type of the first parameter of the extension method.  Create our own class of extension methods: <br><br><pre> <code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///       /  AMF. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Extensions { }</code> </pre><br>  First of all, we will need some auxiliary methods for code reuse.  In .NET 4.5, the <b>Attribute</b> <b>Type</b> <i>.GetCustomAttribute ( <b>Type</b> )</i> method appeared, which allows you to immediately get an attribute of a given type.  In .NET 3.5 there is no such thing yet, so let's implement a couple of extension methods for convenient work with attributes: <br><br><pre> <code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///    . /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;typeparam <span class="hljs-type"><span class="hljs-type">name</span></span>="T"&gt;  .&lt;/typeparam&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="sourceType"&gt;   .&lt;/param&gt; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt;&lt;/<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt; private static T GetAttribute&lt;T&gt;(this <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> sourceType) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] attributes = sourceType.GetCustomAttributes(typeof(T), <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); //   . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attributes == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || attributes.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T); //        -  <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T; } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///    . /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;typeparam <span class="hljs-type"><span class="hljs-type">name</span></span>="T"&gt;  .&lt;/typeparam&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="sourceMember"&gt;   .&lt;/param&gt; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt;&lt;/<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt; private static T GetAttribute&lt;T&gt;(this MemberInfo sourceMember) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] attributes = sourceMember.GetCustomAttributes(typeof(T), <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); //   . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attributes == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || attributes.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T); //        -  <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T; } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// ,     . /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;typeparam <span class="hljs-type"><span class="hljs-type">name</span></span>="T"&gt; .&lt;/typeparam&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="sourceType"&gt;  .&lt;/param&gt; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt;&lt;/<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt; private static <span class="hljs-type"><span class="hljs-type">bool</span></span> IsDefinedAttribute&lt;T&gt;(this <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> sourceType) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] attributes = sourceType.GetCustomAttributes(typeof(T), <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); //   . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; attributes.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  At each serialization procedure, the types will be generated for the specified attributes.  In order not to repeat a lot of operations with each call of the serialization method, let's immediately consider the possibility of storing metadata in a dynamic assembly after its creation: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;summary&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/summary&gt; private static ModuleBuilder moduleBuilder; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;summary&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    &lt;see cref="Extensions"/</span></span>&gt;. /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/summary&gt; static Extensions() { AssemblyName assemblyName = new AssemblyName("AmfDynamicAssembly"); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.RunAndSave); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . moduleBuilder = assemblyBuilder.DefineDynamicModule(assemblyName.Name, assemblyName.Name + ".dll"); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . }</span></span></code> </pre><br>  Now for all types we will have our own single dynamic assembly that will store their metadata.  It's time to implement an algorithm for generating types based on our attribute data.  First we will step through each step of the algorithm, then I will give a complete listing of the method. <br><br>  The very concept of ‚Äúreflection‚Äù (it is also ‚Äúreflection‚Äù, it is also a ‚Äúreflection‚Äù) is based on the manipulation of type metadata.  Here, in fact, everything is simple.  We need to repeat the process of creating the types described in the code by the compiler, but using our own code.  For the basis, we will take the metadata of the type of source object known to us, as well as the data from the attributes, if any.  We also need to implement a default constructor that initializes a reference to an instance of an object of the type being generated.  We can perform all the operations we need using the <b>ModuleBuilder.TypeBuilder</b> class. <br><br>  Determine the type using <b>TypeBuilder</b> : <br><br><pre> <code class="hljs vbscript">TypeBuilder typeBuilder = moduleBuilder.DefineType(<span class="hljs-built_in"><span class="hljs-built_in">typeName</span></span>, TypeAttributes.<span class="hljs-keyword"><span class="hljs-keyword">Public</span></span>);</code> </pre><br>  Defining a field with <b>FieldBuilder</b> : <br><br><pre> <code class="hljs cs">FieldBuilder fieldBuilder = typeBuilder.DefineField(<span class="hljs-string"><span class="hljs-string">$"m_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{propertyName}</span></span></span><span class="hljs-string">"</span></span>, propertyType, FieldAttributes.Private);</code> </pre><br>  We define a property using <b>PropertyBuilder</b> .  Here we need to define a private field, as well as an accessor and a mutator to access it: <br><br><pre> <code class="hljs pgsql">PropertyBuilder propertyBuilder = typeBuilder.DefineProperty(propertyName, PropertyAttributes.HasDefault, propertyType, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); //   . MethodAttributes getSetAttr = MethodAttributes.<span class="hljs-built_in"><span class="hljs-built_in">Public</span></span> | MethodAttributes.SpecialName | MethodAttributes.HideBySig; //      . MethodBuilder methodBuilderAccessor = typeBuilder.DefineMethod($"get_{propertyName}", getSetAttr, propertyType, <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>.EmptyTypes); //  . ILGenerator accessorIL = methodBuilderAccessor.GetILGenerator(); //     MSIL-  . accessorIL.Emit(OpCodes.Ldarg_0); //      . accessorIL.Emit(OpCodes.Ldfld, fieldBuilder); //           . accessorIL.Emit(OpCodes.Ret); //         . MethodBuilder methodBuilderSetter = typeBuilder.DefineMethod($"set_{propertyName}", getSetAttr, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>[] { propertyType }); //  . ILGenerator setterIL = methodBuilderSetter.GetILGenerator(); //     MSIL-  . setterIL.Emit(OpCodes.Ldarg_0); //      . setterIL.Emit(OpCodes.Ldarg_1); //      . setterIL.Emit(OpCodes.Stfld, fieldBuilder); //           . setterIL.Emit(OpCodes.Ret); //         . propertyBuilder.SetGetMethod(methodBuilderAccessor); //   . propertyBuilder.SetSetMethod(methodBuilderSetter); //   .</code> </pre><br>  Define a default constructor using <b>ConstructorBuilder</b> : <br><br><pre> <code class="hljs pgsql">ConstructorBuilder ctor = typeBuilder.DefineConstructor(MethodAttributes.<span class="hljs-built_in"><span class="hljs-built_in">Public</span></span>, CallingConventions.Standard, <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>.EmptyTypes); //  . ILGenerator ctorIL = ctor.GetILGenerator(); //     MSIL-  . ctorIL.Emit(OpCodes.Ldarg_0); //      . ctorIL.Emit(OpCodes.<span class="hljs-keyword"><span class="hljs-keyword">Call</span></span>, typeof(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>).GetConstructor(<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>.EmptyTypes)); //           . ctorIL.Emit(OpCodes.Ret); //         .</code> </pre><br>  Initialize a new instance of an object of the just-generated type using the <b>Activator</b> : <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">targetObject</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Activator</span></span>.<span class="hljs-type"><span class="hljs-type">CreateInstance</span></span>(typeBuilder.<span class="hljs-type"><span class="hljs-type">CreateType</span></span>());</code> </pre><br>  All method metadata collectors have a method <s>(almost pun</s> <i>intended</i> <s>)</s> <i>GetILGenerator ()</i> , which returns an instance of <b>ILGenerator</b> , which allows us to <b>push the</b> required sequence of statements to the MSIL computation stack.  The set of IL instructions that we transmit from <b>OpCodes</b> directly depends on how the logic of the described method behaves.  In this article, I only superficially touch on the topic of reflection, this is a reason for a separate article, in addition, you can always read the full list of instructions in the official MSDN documentation. <br><br>  Now we have everything necessary for writing the logic of dynamic generation of type metadata.  At the same time, we take into account the fact that the properties and fields of the generated type can also have our serialization attribute, for implementation we use recursion.  If the object does not have a type name matching attribute, we return it as is.  If the dynamic assembly already has metadata of our type, we collect an object instance based on them.  This is all useful for optimization.  The full listing of the generation method, with all the necessary checks and procedures, is as follows: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;summary&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/           &lt;see cref="AmfObjectAttribute"/</span></span>&gt;,   ,    &lt;see cref=<span class="hljs-string"><span class="hljs-string">"AmfMemberAttribute"</span></span>/&gt;. /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/summary&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;param name=<span class="hljs-string"><span class="hljs-string">"sourceObject"</span></span>&gt;  .&lt;<span class="hljs-regexp"><span class="hljs-regexp">/param&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;returns&gt;&lt;<span class="hljs-regexp"><span class="hljs-regexp">/returns&gt; private static object GenerateType&lt;T&gt;(T sourceObject) { Type sourceType = sourceObject.GetType(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . if (sourceType.IsDictionary()) return GenerateType(sourceObject as IEnumerable&lt;KeyValuePair&lt;string, object&gt;&gt;); if (!sourceType.IsDefinedAttribute&lt;AmfObjectAttribute&gt;()) return sourceObject; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        -   . string typeName = sourceType.GetAttribute&lt;AmfObjectAttribute&gt;().Name ?? sourceType.FullName; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . Type definedType = moduleBuilder.GetType(typeName); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       . TypeBuilder typeBuilder = null; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . Dictionary&lt;string, object&gt; properties = new Dictionary&lt;string, object&gt;(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . Dictionary&lt;string, object&gt; fields = new Dictionary&lt;string, object&gt;(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       ... if (definedType == null) { typeBuilder = moduleBuilder.DefineType(typeName, TypeAttributes.Public); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . ConstructorBuilder ctor = typeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . ILGenerator ctorIL = ctor.GetILGenerator(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     MSIL-  . ctorIL.Emit(OpCodes.Ldarg_0); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . ctorIL.Emit(OpCodes.Call, typeof(object).GetConstructor(Type.EmptyTypes)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/           . ctorIL.Emit(OpCodes.Ret); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . foreach (PropertyInfo propertyInfo in sourceType.GetProperties()) { AmfMemberAttribute attribute = propertyInfo.GetAttribute&lt;AmfMemberAttribute&gt;(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      AmfMemberAttribute. if (attribute == null) continue; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     -  . string propertyName = attribute.Name ?? propertyInfo.Name; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . object propertyValue = propertyInfo.GetValue(sourceObject, null); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . Type propertyType = propertyInfo.PropertyType; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        ... if (propertyInfo.PropertyType.IsDefinedAttribute&lt;AmfObjectAttribute&gt;() || propertyType.IsDictionary()) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,   . propertyValue = propertyType.IsDictionary() ? GenerateType(propertyValue as IEnumerable&lt;KeyValuePair&lt;string, object&gt;&gt;) : GenerateType(propertyValue); propertyType = propertyValue.GetType(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . } FieldBuilder fieldBuilder = typeBuilder.DefineField($"m_{propertyName}", propertyType, FieldAttributes.Private); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . PropertyBuilder propertyBuilder = typeBuilder.DefineProperty(propertyName, PropertyAttributes.HasDefault, propertyType, null); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . MethodAttributes getSetAttr = MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . MethodBuilder methodBuilderAccessor = typeBuilder.DefineMethod($"get_{propertyName}", getSetAttr, propertyType, Type.EmptyTypes); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . ILGenerator accessorIL = methodBuilderAccessor.GetILGenerator(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     MSIL-  . accessorIL.Emit(OpCodes.Ldarg_0); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . accessorIL.Emit(OpCodes.Ldfld, fieldBuilder); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/           . accessorIL.Emit(OpCodes.Ret); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         . MethodBuilder methodBuilderSetter = typeBuilder.DefineMethod($"set_{propertyName}", getSetAttr, null, new Type[] { propertyType }); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . ILGenerator setterIL = methodBuilderSetter.GetILGenerator(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     MSIL-  . setterIL.Emit(OpCodes.Ldarg_0); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . setterIL.Emit(OpCodes.Ldarg_1); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . setterIL.Emit(OpCodes.Stfld, fieldBuilder); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/           . setterIL.Emit(OpCodes.Ret); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         . propertyBuilder.SetGetMethod(methodBuilderAccessor); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . propertyBuilder.SetSetMethod(methodBuilderSetter); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . properties.Add(propertyName, propertyValue); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         . } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . foreach (FieldInfo fieldInfo in sourceType.GetFields()) { AmfMemberAttribute attribute = fieldInfo.GetAttribute&lt;AmfMemberAttribute&gt;(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      AmfMemberAttribute. if (attribute == null) continue; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     -  . string fieldName = attribute.Name ?? fieldInfo.Name; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . object fieldValue = fieldInfo.GetValue(sourceObject); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . Type fieldType = fieldInfo.FieldType; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        ... if (fieldInfo.FieldType.IsDefinedAttribute&lt;AmfObjectAttribute&gt;() || fieldType.IsDictionary()) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,   . fieldValue = fieldType.IsDictionary() ? GenerateType(fieldValue as IEnumerable&lt;KeyValuePair&lt;string, object&gt;&gt;) : GenerateType(fieldValue); fieldType = fieldValue.GetType(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . } typeBuilder.DefineField(fieldName, fieldType, FieldAttributes.Public); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . fields.Add(fieldName, fieldValue); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         . } } else { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . foreach (PropertyInfo propertyInfo in sourceType.GetProperties()) { AmfMemberAttribute attribute = propertyInfo.GetAttribute&lt;AmfMemberAttribute&gt;(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      AmfMemberAttribute. if (attribute == null) continue; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     -  . string propertyName = attribute.Name ?? propertyInfo.Name; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . object propertyValue = propertyInfo.GetValue(sourceObject, null); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . Type propertyType = propertyInfo.PropertyType; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . AmfObjectAttribute propertyAttribute = propertyInfo.PropertyType.GetAttribute&lt;AmfObjectAttribute&gt;(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        ... if (propertyAttribute != null || propertyType.IsDictionary()) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,   . propertyValue = propertyType.IsDictionary() ? GenerateType(propertyValue as IEnumerable&lt;KeyValuePair&lt;string, object&gt;&gt;) : GenerateType(propertyValue); propertyType = propertyValue.GetType(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . } properties.Add(propertyName, propertyValue); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         . } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . foreach (FieldInfo fieldInfo in sourceType.GetFields()) { AmfMemberAttribute attribute = fieldInfo.GetAttribute&lt;AmfMemberAttribute&gt;(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      AmfMemberAttribute. if (attribute == null) continue; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     -  . string fieldName = attribute.Name ?? fieldInfo.Name; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . object fieldValue = fieldInfo.GetValue(sourceObject); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . Type fieldType = fieldInfo.FieldType; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . AmfObjectAttribute fieldAttribute = fieldInfo.FieldType.GetAttribute&lt;AmfObjectAttribute&gt;(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        ... if (fieldAttribute != null || fieldType.IsDictionary()) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,   . fieldValue = fieldType.IsDictionary() ? GenerateType(fieldValue as IEnumerable&lt;KeyValuePair&lt;string, object&gt;&gt;) : GenerateType(fieldValue); fieldType = fieldValue.GetType(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . } fields.Add(fieldName, fieldValue); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         . } } object targetObject = Activator.CreateInstance(definedType ?? typeBuilder.CreateType()); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . foreach (KeyValuePair&lt;string, object&gt; property in properties) targetObject.GetType().GetProperty(property.Key).SetValue(targetObject, property.Value, null); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . foreach (KeyValuePair&lt;string, object&gt; field in fields) targetObject.GetType().GetField(field.Key).SetValue(targetObject, field.Value); return targetObject; }</span></span></code> </pre><br>  Now we need to take care that the metadata of the arrays of objects are correctly stored during serialization.  To do this, we write an elementary overload of the method of generating the type: <br><br><pre> <code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///            &lt;see cref="AmfObjectAttribute"/&gt;,   ,    &lt;see cref="AmfMemberAttribute"/&gt;. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="sourceObjects"&gt;  .&lt;/param&gt; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt;&lt;/<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt; private static <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] GenerateType(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] sourceObjects) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sourceObjects.Length; i++) sourceObjects[i] = GenerateType(sourceObjects[i]); //      . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sourceObjects; }</code> </pre><br>  Now we can already serialize any objects and arrays in AMF for further sending to the server.  But we still need the functionality that provides the sending of associative arrays AMF, which are simply not available in C #.  Associative arrays here are different implementations of <b>IEnumerable &lt;KeyValuePair &lt;TKey, TValue&gt; dictionaries</b> , as well as <b>Hashtable</b> hash tables, AMF recognizes each dictionary key as a field of Array type.  To implement the solution of this problem, we will write another overload that can correctly generate the AMF dictionary based on the keys and values ‚Äã‚Äãof the dictionary: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;summary&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,        .     ,             object,        ,    AMF. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/summary&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;param name=<span class="hljs-string"><span class="hljs-string">"sourceType"</span></span>&gt; .&lt;<span class="hljs-regexp"><span class="hljs-regexp">/param&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;returns&gt;&lt;<span class="hljs-regexp"><span class="hljs-regexp">/returns&gt; private static bool IsDictionary(this Type sourceType) { Type type0 = typeof(IEnumerable&lt;KeyValuePair&lt;string, object&gt;&gt;); Type type1 = typeof(IDictionary&lt;string, object&gt;); Type type2 = typeof(Dictionary&lt;string, object&gt;); return sourceType.FullName == type0.FullName || sourceType.IsSubclassOf(type0) || sourceType.FullName == type1.FullName || sourceType.IsSubclassOf(type1) || sourceType.FullName == type2.FullName || sourceType.IsSubclassOf(type2); } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;summary&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       "-", ,  -   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/summary&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;param name=<span class="hljs-string"><span class="hljs-string">"fields"</span></span>&gt;     <span class="hljs-string"><span class="hljs-string">"-"</span></span>&lt;<span class="hljs-regexp"><span class="hljs-regexp">/param&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;returns&gt;&lt;<span class="hljs-regexp"><span class="hljs-regexp">/returns&gt; private static object GenerateType(IEnumerable&lt;KeyValuePair&lt;string, object&gt;&gt; fields) { AssemblyName assemblyName = new AssemblyName("AmfDynamicAssemblyForDictionary"); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.RunAndSave); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(assemblyName.Name, assemblyName.Name + ".dll"); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . TypeBuilder typeBuilder = moduleBuilder.DefineType(typeof(Array).FullName, TypeAttributes.Public); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . ConstructorBuilder ctor = typeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . ILGenerator ctorIL = ctor.GetILGenerator(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     MSIL-  . ctorIL.Emit(OpCodes.Ldarg_0); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . ctorIL.Emit(OpCodes.Call, typeof(object).GetConstructor(Type.EmptyTypes)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/           . ctorIL.Emit(OpCodes.Ret); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . foreach (KeyValuePair&lt;string, object&gt; pair in fields) { object fieldValue = pair.Value; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . Type fieldType = fieldValue.GetType(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     ... if (fieldType.IsDefinedAttribute&lt;AmfObjectAttribute&gt;()) { fieldValue = GenerateType(fieldValue); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,   . fieldType = fieldValue.GetType(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . } typeBuilder.DefineField(pair.Key, fieldType, FieldAttributes.Public); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . } object targetObject = Activator.CreateInstance(typeBuilder.CreateType()); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . foreach (KeyValuePair&lt;string, object&gt; pair in fields) targetObject.GetType().GetField(pair.Key).SetValue(targetObject, pair.Value); return targetObject; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice, here I create a separate dynamic assembly, and each time I call the method I override the metadata in it. </font><font style="vertical-align: inherit;">This is necessary so that all the metadata of our dictionary is generated anew, otherwise after some time the copies of our dictionaries will have a whole bunch of undefined fields that should not exist in the type and which will take up space in the memory.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AMF Serialization </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now everything is exactly ready for the serialization of objects in AMF. </font><font style="vertical-align: inherit;">Let's start implementing the serializer:</font></font><br><br><pre> <code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///     AMF. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="sourceObject"&gt; .&lt;/param&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="version"&gt; AMF.&lt;/param&gt; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt;&lt;/<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static byte[] SerializeToAmf(this <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sourceObject, ushort <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (MemoryStream memoryStream = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MemoryStream()) //       . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (AMFSerializer amfSerializer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> AMFSerializer(memoryStream)) //    AMF. { AMFMessage amfMessage = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> AMFMessage(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>); //          AMF. AMFBody amfBody = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> AMFBody(AMFBody.OnResult, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, GenerateType(sourceObject)); //     AMF. amfMessage.AddBody(amfBody); //  body   AMF. amfSerializer.WriteMessage(amfMessage); //  . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoryStream.ToArray(); //       . } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///     AMF3. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="sourceObject"&gt; .&lt;/param&gt; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt;&lt;/<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static byte[] SerializeToAmf(this <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sourceObject) =&gt; sourceObject.SerializeToAmf(<span class="hljs-number"><span class="hljs-number">3</span></span>); /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///     *.amf. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="sourceObject"&gt; .&lt;/param&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="path"&gt; .&lt;/param&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="version"&gt;  AMF.&lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> SerializeToAmf(this <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sourceObject, string <span class="hljs-type"><span class="hljs-type">path</span></span>, ushort <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>) =&gt; File.WriteAllBytes($"{path}.amf", sourceObject.SerializeToAmf(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>)); /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///     *.amf.  AMF  <span class="hljs-number"><span class="hljs-number">3.</span></span> /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="sourceObject"&gt; .&lt;/param&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="path"&gt; .&lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> SerializeToAmf(this <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sourceObject, string <span class="hljs-type"><span class="hljs-type">path</span></span>) =&gt; sourceObject.SerializeToAmf(<span class="hljs-type"><span class="hljs-type">path</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The implementation is almost trivial. </font><font style="vertical-align: inherit;">The only caveat is that I intentionally created an overload with the AMF version number equal to three by default. </font><font style="vertical-align: inherit;">When we work with Flex, this is almost always AMF3, which means there‚Äôs no point in passing an additional argument to the calls to the serialization method. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For deserialization, it is necessary to do all the above procedures, only in the reverse order:</font></font><br><br><pre> <code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///      AMF. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;typeparam <span class="hljs-type"><span class="hljs-type">name</span></span>="T"&gt;  .&lt;/typeparam&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="sourceBuffer"&gt;   .&lt;/param&gt; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt;&lt;/<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static T DeserializeFromAmf&lt;T&gt;(this byte[] sourceBuffer) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (MemoryStream memoryStream = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MemoryStream(sourceBuffer)) //       . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (AMFDeserializer amfDeserializer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> AMFDeserializer(memoryStream)) //    AMF. { AMFMessage amfMessage = amfDeserializer.ReadAMFMessage(); //   AMF. AMFBody amfBody = amfMessage.GetBodyAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); //  body   AMF. <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> amfObject = amfBody.Content; //    body AMF. <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> amfObjectType = amfObject.GetType(); //     AMF. //            . IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Assembly.GetExecutingAssembly().GetTypes() <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span>.IsDefined(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, typeof(AmfObjectAttribute)) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> currentType = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; //       . //        . <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>) { AmfObjectAttribute <span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>.GetAttribute&lt;AmfObjectAttribute&gt;(); //   . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span>.Name != amfObjectType.FullName) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; //       -  . currentType = <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>; //     . break; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T); //     -  <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> targetObject = Activator.CreateInstance(currentType); //    . //     . <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (PropertyInfo propertyInfo <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> currentType.GetProperties()) { AmfMemberAttribute <span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> = propertyInfo.GetAttribute&lt;AmfMemberAttribute&gt;(); //    . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; //     - . propertyInfo.SetValue(targetObject, amfObjectType.GetProperty(<span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span>.Name).GetValue(amfObject, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); //             . } //     . <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (FieldInfo fieldInfo <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> currentType.GetFields()) { AmfMemberAttribute <span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> = fieldInfo.GetAttribute&lt;AmfMemberAttribute&gt;(); //    . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; //     - . fieldInfo.SetValue(targetObject, amfObjectType.GetField(<span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span>.Name).GetValue(amfObject)); //             . } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> targetObject <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T; //    T    . } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///     *.amf. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;typeparam <span class="hljs-type"><span class="hljs-type">name</span></span>="T"&gt;  .&lt;/typeparam&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="obj"&gt; .&lt;/param&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="path"&gt;   .&lt;/param&gt; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt;  AMF.&lt;/<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static T DeserializeFromAmf&lt;T&gt;(this <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> obj, string <span class="hljs-type"><span class="hljs-type">path</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> =&gt; File.ReadAllBytes($"{path}.amf").DeserializeFromAmf&lt;T&gt;();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now let's see how you can serialize an object in AMF as the fastest way and send it to the server: </font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (MemoryStream memoryStream = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MemoryStream()) //             . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (AMFWriter amfWriter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> AMFWriter(memoryStream)) //      AMF. <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (WebClient client = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> WebClient()) //  HTTP-      (    HttpWebRequest). { amfWriter.WriteBytes(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> CustomAmfObject().SerializeToAmf()); //     . client.Headers[HttpRequestHeader.ContentType] = "application/x-amf"; //   ContentType  . byte[] buffer = client.UploadData(Host, "POST", memoryStream.ToArray()); //    . }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the screenshot below, you can observe the structure of the serialized object, ready to be sent to the server: </font></font><br><br><img src="http://s019.radikal.ru/i631/1701/85/802ef347bc54.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In case the server after sending data will swear that the object does not implement the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IExternalizable</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> interface </font><font style="vertical-align: inherit;">, we need to implement the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IExternalizable</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementation in our custom classes </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="hljs cs"> [<span class="hljs-meta"><span class="hljs-meta">AmfObject(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"example.game.gameObject"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomAmfObject</span></span> : <span class="hljs-title"><span class="hljs-title">IExternalizable</span></span> { [AmfMember(<span class="hljs-string"><span class="hljs-string">"x"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } [AmfMember(<span class="hljs-string"><span class="hljs-string">"y"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Y { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } [AmfMember(<span class="hljs-string"><span class="hljs-string">"z"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Z { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomAmfObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { X = x; Y = y; Z = z; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomAmfObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0f</span></span></span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadExternal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDataInput input</span></span></span><span class="hljs-function">)</span></span> { X = input.ReadFloat(); Y = input.ReadFloat(); Z = input.ReadFloat(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteExternal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDataOutput output</span></span></span><span class="hljs-function">)</span></span> { output.WriteFloat(X); output.WriteFloat(Y); output.WriteFloat(Z); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As tests showed in real conditions, to serialize data through such an approach, a chain of records in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDataOutput</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and reading from </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDataInput</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is not necessary </font><font style="vertical-align: inherit;">, all data were sent to the server in the correct form without them. </font><font style="vertical-align: inherit;">For the very same "rude" servers, this solution can be very useful.</font></font><br><br><h2>  Afterword </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method of solving the problem described above is far from the only one that does not require intervention in the source code of the original framework. For example, we could do without attributes and work with metadata from the code, if implemented copies of our objects using </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DynamicObject</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExpandoObject</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and other dynamic- </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> amenities, while placing all the work with the metadata on the DLR. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The knowledge base outlined in the article should be enough to write a serializer for almost any task, or a simple MSIL-based interpreter / compiler and reflection, as well as a more visual understanding of the principle of AMF serialization. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sources for the article are available </font></font><a href="https://github.com/Exomode/FluorineFX"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The NuGet package for the FluorineFx extension can be found </font></font><a href="https://www.nuget.org/packages/FluorineFX.Serialization/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you need only to drag and AMF serialized for this entire project in FluorineFX oh how you do not want, then </font></font><a href="https://github.com/artema/DotAmf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you can find the proposed </font></font><a href="https://habrahabr.ru/users/ArtemA/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArtemA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> option serializer implemented by means of mapping, but on the basis DataContract-serialize .NET. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope the material I have outlined has been helpful to you.</font></font><br>  Thank you for attention! </div><p>Source: <a href="https://habr.com/ru/post/320446/">https://habr.com/ru/post/320446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320430/index.html">Understanding the critical rendering path</a></li>
<li><a href="../320432/index.html">Video recordings of the MBLTdev 16 mobile developers conference reports</a></li>
<li><a href="../320434/index.html">Cerebro is a free alternative to Alfred and Spotlight</a></li>
<li><a href="../320436/index.html">10 questions for the informed choice of the SIEM system</a></li>
<li><a href="../320438/index.html">5 of the ‚Äúhottest‚Äù new books in January</a></li>
<li><a href="../320448/index.html">User comfort in VR: player parameters</a></li>
<li><a href="../320450/index.html">A simple version of an indoor video surveillance system using a motion sensor and Python on the Raspberry platform</a></li>
<li><a href="../320452/index.html">Developing a new application architecture for Uber passengers</a></li>
<li><a href="../320454/index.html">ITSM educational program: How to meet customer expectations</a></li>
<li><a href="../320456/index.html">Uncomplicated SCRUM and Image Segmentation for Highlighting Post-it Stickers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>