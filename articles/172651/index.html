<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Building a system for optical recognition of structural information on the example of Imago OCR</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will talk about how you can build an optical recognition system for structural information, based on the algorithms used in image pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Building a system for optical recognition of structural information on the example of Imago OCR</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/d4c/fe6/8c5/d4cfe68c5d85ea6182618817354f84e4.png" align="right">  In this article I will talk about how you can build an optical recognition system for structural information, based on the algorithms used in image processing and their implementation within the OpenCV library.  Behind the description of the system is an actively developing open source project <a href="http://ggasoftware.com/opensource/imago">Imago OCR</a> , which can be directly useful in recognizing <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D1%2583%25D0%25BB%25D0%25B0">chemical structures</a> , however, I will not talk about chemistry in this article, but will touch upon more general issues, which help in recognizing structured information of various kinds, for example, tables or graphics. <br><a name="habracut"></a><habracut><br><h4>  The structure of the recognition engine </h4><br>  One of the most common options for imaging the structure of the <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BF%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D1%2580%25D0%25B0%25D1%2581%25D0%25BF%25D0%25BE%25D0%25B7%25D0%25BD%25D0%25B0%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BC%25D0%25B2%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B2">OCR</a> engine can be the following: <br><img src="https://habrastorage.org/storage2/7cb/797/b9f/7cb797b9f72426741592d1e378a14b4c.png"><br>  Conventionally, processing methods can be divided into three levels: <br><ul><li>  <b>Raster</b> level (working with a set of image pixels); </li><li>  The level of <b>primitives</b> (we identify groups of pixels with certain primitives, - symbols, lines, circles, etc.); </li><li>  <b>Structural</b> level (we collect groups of primitives into logical units - ‚Äútable‚Äù, ‚Äútable cell‚Äù, ‚Äúlabel‚Äù, etc.) </li></ul><br>  I depict the main direction of data transfer with black arrows: load the image, convert it into a convenient form for processing, get primitives, organize primitives into structures, record the result. <br><br>  Blue arrows represent <i>‚Äúfeedback‚Äù</i> - in some cases, it becomes impossible to recognize an object at a certain level (to collect at least some logically acceptable structure from primitives, or to isolate at least some primitive from a set of points).  This indicates either a ‚Äúbad‚Äù source image, or an error in the previous step, and to avoid such errors, we try to process the object again, possibly with different parameters, at the previous structural level. <br><br>  At this stage, we will not go into details, but these systems of optical recognition of structural information differ significantly from ‚Äúgeneral recognition‚Äù - we have the opportunity to correct some errors thanks to an understanding of the required output structure.  This circumstance somewhat changes the approach to the construction of private recognition methods, allowing you to create <i>adaptive</i> algorithms that depend on some tolerances that are modified during the processing and have <i>quality metrics</i> that can be calculated at the structural processing stage. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Raster level: image loading </h4><br>  Since we used the wonderful <a href="http://opencv.willowgarage.com/wiki/">OpenCV library</a> , this step is as simple as possible.  OpenCV can load many popular raster formats: PNG, JPG, BMP, DIB, TIFF, PBM, RAS, EXR, and in fact with one line: <br><pre><code class="cpp hljs">cv::Mat mat = cv::imread(fname, CV_LOAD_IMAGE_GRAYSCALE);</code> </pre> <br>  The selected parameter CV_LOAD_IMAGE_GRAYSCALE allows you to upload a picture in the form of a matrix of pixel intensities (conversion to grayscale will occur automatically).  In a number of tasks it is necessary to use color information, but in ours it is not necessary, which allows you to significantly save memory allocation.  From the dirty tricks, except that the download is ‚Äútransparent‚Äù PNG, the transparent background will be treated as black, which can easily be done with the CV_LOAD_IMAGE_UNCHANGED parameter and manual processing of BGRA color information (yes, OpenCV stores the color data in that order). <br><br>  Let at this stage we get something like this: <img src="https://habrastorage.org/storage2/606/2f9/503/6062f9503978f5ec4496cc9ea01fe59b.png"><br>  I deliberately chose the picture ‚Äúworse‚Äù to show that optical recognition is associated with numerous difficulties that we will solve further, but it is from ‚Äúreal life‚Äù - mobile phone cameras ‚Äúand they can‚Äôt.‚Äù <br><br><h4>  Raster Level: Pre-Filtering </h4><br>  The main task of pre-filtering is to improve the ‚Äúquality‚Äù of the image: remove noise, without loss of detail and restore contrast. <br><br>  Armed with a graphical editor, you can estimate a lot of tricky schemes, how to improve the quality of the image, but here it is important to understand the boundary between what can be done automatically and what is fiction that applies to exactly one image.  Here are examples of more or less automated approaches: <a href="http://habrahabr.ru/post/172231/">sparse masks</a> , <a href="http://habrahabr.ru/post/108212/">median filters</a> , <a href="http://habrahabr.ru/company/gilalgorithms/blog/67594/">for those who like to google</a> . <br><br>  I would like to make a comparison of the methods and <i>show</i> why we chose a specific one, but practically it‚Äôs difficult.  In various images, certain methods have their advantages and disadvantages, ‚Äúon average‚Äù there is no better solution either, so we designed a stack of filters in Imago OCR, each of which can be used in certain cases, and the choice of result will depend on the quality metric. <br><br>  But I want to talk about one interesting solution: <a href="http://www.ipol.im/pub/art/2011/lmps_rpe/">Retinex Poisson Equation</a> <br><br>  The advantages of the method include: <br><ul><li>  Fairly high speed; </li><li>  Parameterized result quality; </li><li>  The lack of blurring during the work, and as a result, "sensitivity" to the details; </li><li>  And the main interesting feature is the normalization of local levels of illumination. </li></ul><br>  The last property is perfectly illustrated by the image from the article, and it is important for recognition because of possible non-uniform illumination of objects when shooting (a piece of paper turned towards the light source so that the light falls unevenly): <br><img src="https://habrastorage.org/storage2/6ab/2cf/5ae/6ab2cf5ae786f3150d04c42bc1643110.png"><br><br>  Surface description of the algorithm: <br><ul><li>  Local threshold image filtering ( <a href="http://www.owlnet.rice.edu/~elec539/Projects97/morphjrks/laplacian.html">laplacian threshold</a> ) with a threshold T; </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D1%2581%25D0%25BA%25D1%2580%25D0%25B5%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BA%25D0%25BE%25D1%2581%25D0%25B8%25D0%25BD%25D1%2583%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">Discrete cosine transformation of the</a> resulting image; </li><li>  Filtering high-frequency characteristics and solving a special equation for low and medium frequencies (Retinex Equation); </li><li>  Inverse discrete cosine transform. </li></ul><br>  The algorithm itself is rather sensitively dependent on the parameter T, but we used its adaptation: <br><ul><li>  Consider Retinex (T) for T = 1,2,4,8 </li><li>  Perform pixel median filtering between Retinex results. </li><li>  <a href="http://en.wikipedia.org/wiki/Histogram_equalization">Normalize the contrast</a> </li></ul><br>  What will help OpenCV: there is a ready function for calculating the discrete cosine transform: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Mat&amp; src, Mat&amp; dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// flags = DCT_INVERSE for inverse DCT</span></span></code> </pre><br>  And it works no worse in speed than the similar one from libfftw, although I don‚Äôt presume to assert this in the general case (tested on Core i5, Core Duo). <br><br>  For the original image, the above method gives a rather pleasant result: <br><img src="https://habrastorage.org/storage2/0a5/09b/afb/0a509bafb7082d4a318c1b1545c93ee0.png"><br><br>  Now we roughly understand what pre-filtering should do, and we already have one parameter that can change in the feedback mechanism: the <i>index of the filter used</i> . <br><br>  <u>Here and below</u> : in fact, of course, there are many other parameters (for example, the very ‚Äúmagic‚Äù T = 1, 2, 4, 8), but in order ‚Äúnot to bother with the head‚Äù, we will not talk about them now.  There are many of them, mentions about them will pop up in the section on machine learning, but I‚Äôll omit the specifics in order not to overload the presentation with a number of parameters. <br><br><h4>  Raster level: binarization </h4><br>  The next step is to get a black and white image, where black will respond to the presence of "paint", and white - to its absence.  This is done because a number of algorithms, such as obtaining the contour of an object, do not work constructively with semitones.  One of the simplest ways to binarize is threshold filtering (we choose t as the threshold value, all pixels with intensity greater than t are background, less are paint), but because of its low <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%259E%25D1%2586%25D1%2583">adaptivity</a> , the <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%259E%25D1%2586%25D1%2583">otsu threshold</a> or adaptive gaussian threshold is often used. <br><br>  Despite the adaptability of more advanced methods, they still contain threshold values ‚Äã‚Äãthat determine the "amount" of output.  In the case of more severe thresholds - some of the elements may be lost, in the case of "soft" - "noise" may come out. <br><table><tbody><tr><td>  Strong thresholding </td><td>  Weak thresholding </td></tr><tr><td><img src="https://habrastorage.org/storage2/bfb/3ca/9f9/bfb3ca9f9f1b9da6af1aab14516157ff.png"></td><td><img src="https://habrastorage.org/storage2/a71/6de/8d9/a716de8d99d5bf4b368770d2dca40fad.png"></td></tr></tbody></table><br>  You can try to guess the thresholds for each image exactly, but we went the other way - using the correlation between the obtained images with different adaptive binarization thresholds: <br><ul><li>  We consider strong and weak binarization (with given thresholds t1 and t2); </li><li>  We divide the images into a set of connected pixel-by-pixel areas ( <a href="http://habrahabr.ru/post/119461/">marking of segments</a> ); </li><li>  Remove all the "weak" segments that have a correlation with the corresponding strong, less than the specified (cratio); </li><li>  Remove all the ‚Äúweak‚Äù segments of low density (the proportions of black / white pixels are less than the given bwratio); </li><li>  The remaining "weak" segments are the result of binarization. </li></ul><br>  As a result, <i>in most cases,</i> we obtain an image that is devoid of noise and without loss in detail: <br><img src="https://habrastorage.org/storage2/318/6b8/e98/3186b8e98f572d183f8fa1e47350f002.png"><br>  The described solution may look strange in the light of the fact that we wanted to ‚Äúget rid‚Äù of one parameter, and introduced a whole bunch of others, but the basic idea is that the correctness of binarization is now provided if the ‚Äúreal‚Äù threshold of binarization falls within the interval , concluded between the t1 and t2 chosen by us (although we cannot increase this interval infinitely, there is also a limit to the difference between t1 and t2). <br><img src="https://habrastorage.org/storage2/9c0/bf8/07c/9c0bf807c4e29a43e429115e0a12a7ee.png"><br>  The idea is quite viable when applied with various methods of threshold filtering, and OpenCV ‚Äúhelped‚Äù with the presence of built-in adaptive filtering functions: <br><pre> <code class="cpp hljs">cv::adaptiveThreshold(image, strongBinarized, <span class="hljs-number"><span class="hljs-number">255</span></span>, cv::ADAPTIVE_THRESH_GAUSSIAN_C, CV_THRESH_BINARY, strongBinarizeKernelSize, strongBinarizeTreshold); cv::threshold(image, otsuBinarized, otsuThresholdValue, <span class="hljs-number"><span class="hljs-number">255</span></span>, cv::THRESH_OTSU);</code> </pre><br>  If the final image contains no segments at all, then a filtering error probably occurred and it is worth considering another preliminary filter (‚Äúfeedback‚Äù; ‚Äúthose‚Äù blue arrows in the image of the engine structure). <br><br><h4>  Level of primitives: vectorization </h4><br>  The next step in the recognition process is the conversion of sets of pixels (segments) into primitives.  Primitives can be figures - a circle, a set of segments, a rectangle (a specific set of primitives depends on the problem to be solved), or symbols. <br><br>  So far we don‚Äôt know to which class each object belongs, therefore we are trying to vectorize it in various ways.  The same set of pixels can be successfully vectorized as a set of segments and as a symbol, for example, ‚ÄúN‚Äù, ‚ÄúI‚Äù.  Or the circle and symbol - ‚ÄúO‚Äù.  At this stage, we do not need to know reliably which class has an object, but it is necessary to have a certain metric of the object's similarity with its vectorization in a certain class.  This is usually solved by a set of recognition functions. <br><br>  For example for a set of pixels <img src="https://habrastorage.org/storage2/ba1/f9a/a64/ba1f9aa644c70b57452639d274f13101.png">  we will get a set of the following objects (do not think about the specific numbers of the metric, they are given to represent what we want from the recognition process, but by themselves do not make sense yet): <br><ul><li>  vectorization in the form of the <b>symbol ‚ÄúH‚Äù</b> with the metric (distance) value of 0.1 <i>(perhaps it is H)</i> ; </li><li>  vectorization in the form of the <b>symbol ‚ÄúR‚Äù</b> with the value of the metric in 4.93 <i>(unlikely, but it is also possible that R)</i> ; </li><li>  vectorization <b>in the form of three segments</b> "|", "-", "|"  with a metric value of 0.12 <i>(it is quite possible that these are three segments)</i> ; </li><li>  vectorization as a <b>rectangle</b> with the sizes of the sides x, y with the value of the metric in 45.4 <i>(it does not look like a rectangle at all)</i> ; </li><li>  vectorization as a <b>circle</b> with the value of the metric + inf <i>(guaranteed is not a circle)</i> ; </li><li>  ... </li></ul><br>  In order to get a list of vectorizations, it is necessary to implement recognition primitives for each particular class. <br><br><h5>  Recognition of a set of segments </h5><br>  Usually the raster area is vectorized into a set of segments as follows: <br><ul><li>  Performing thinning filter ( <img src="https://habrastorage.org/storage2/ba1/f9a/a64/ba1f9aa644c70b57452639d274f13101.png">  -&gt; <img src="https://habrastorage.org/storage2/858/60b/324/85860b324cd53c3a045c6f2085574902.png">  ); </li><li>  Segmentation (decorner) ( <img src="https://habrastorage.org/storage2/65b/750/220/65b75022053230ce9558dc4c24a67c27.png">  ); </li><li>  <a href="http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm">Approximation of</a> points of each segment; </li><li>  The result is a set of approximations and a <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BD%25D0%25B5%25D0%25BA%25D0%25B2%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B0%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25BE%25D1%2582%25D0%25BA%25D0%25BB%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">deviation of the</a> approximation from the original. </li></ul><br>  There is no ready-made thinning filter in OpenCV, but it's <a href="http://opencv-code.com/quick-tips/implementation-of-thinning-algorithm-in-opencv/">not</a> at <a href="http://opencv-code.com/quick-tips/implementation-of-thinning-algorithm-in-opencv/">all difficult to</a> implement.  Splitting into segments (decorner), too, but this is completely trivial: we throw out from the area all points that have more than two neighbors.  But the approximation of points as a set of segments in OpenCV is present, we used it: <br><pre> <code class="cpp hljs">cv::approxPolyDP(curve, approxCurve, approxEps, closed); <span class="hljs-comment"><span class="hljs-comment">// approximation of curve -&gt; approxCurve</span></span></code> </pre><br>  An important parameter is the approximation tolerance ( <i>approxEps</i> ), with an increase in which, as a result, we will get a larger number of segments, and with a decrease, a more rough approximation, and, as a result, a larger metric value.  How <i>to</i> choose it <i>correctly</i> ? <br><br>  Firstly, it depends quite strongly on the average line thickness (intuitively - the greater the line thickness, the less detail; the picture drawn with a sharp pencil can be much more detailed than that drawn with a marker), which we used in our implementation: <br><pre> <code class="cpp hljs">approxEps = averageLineThickness * magicLineVectorizationFactor;</code> </pre><br>  Secondly, taking into account the above described approach to the classification of objects, there is an opportunity to try to vectorize segments with different approxEps (with a certain step) and already at the stage of analyzing the logical structure, choose the ‚Äúmore suitable‚Äù one. <br><br><h5>  Circle Recognition </h5><br>  Pretty simple: <br><ul><li>  Looking for the center of the circle (average over the coordinates of the points) - (x, y); </li><li>  We are looking for the radius (the average distance of points from the center) - r; </li><li>  We consider the error: the average distance by points to a circle with center (x, y) and radius r and thickness averageLineThickness; </li><li>  Consider an additional penalty for breaking a circle: magicCirclePenalty * (% breaks). </li></ul><br>  After selecting <i>magicCirclePenalty</i> with this code, there were absolutely no problems, as well as with the recognition of rectangles similar to it. <br><br><h5>  Character Recognition </h5><br>  Significantly more interesting part, because  This is a challenge problem - there is not a single algorithm that claims to be ‚Äúthe most optimal‚Äù recognition indicators.  There are very simple methods based on <a href="http://habrahabr.ru/post/101446/">heuristics</a> , there are more complex ones, for example, using <a href="http://habrahabr.ru/post/113245/">neural networks</a> , but none of them guarantee ‚Äúgood‚Äù quality of recognition. <br><br>  Therefore, it seemed rather natural to decide to use several subsystems of character recognition and selection of an aggregate result: if p1 = the metric value of the fact that algorithm 1 recognizes area A as a symbol s, and p2 = the metric value that algorithm 2 recognizes area A as a character s, total value p = f (p1, p2).  We have chosen two algorithms that have conveniently compared values, high speed and sufficient stability: <br><ul><li>  recognition based on Fourier descriptors; </li><li>  mask square deviation points. </li></ul><br><h6>  Character recognition based on Fourier descriptors </h6><br>  Training: <br><ul><li>  Getting the outer contour of the object; </li><li>  Converting the coordinates of contour points (x; y) into complex numbers x + iy; </li><li>  The discrete Fourier transform of a set of these numbers; </li><li>  Dropping the high-frequency part of the spectrum. </li></ul><br>  When performing the inverse Fourier transform, we get a set of points describing the original shape with a given degree of approximation (N is the number of coefficients left): <br><img src="https://habrastorage.org/storage2/570/011/497/5700114970e9b5ca94288fe035b26938.jpg"><br><br>  The ‚Äúrecognition‚Äù operation is to compute the Fourier descriptors for the recognized area and compare them with the predefined sets responsible for the supported characters.  To get a metric value from two sets of descriptors, you need to perform an operation called convolution: d = sum ((d1 [i] -d2 [i]) * w [i], i = 1, N), where d1 and d2 are sets of descriptors Fourier, and w is the weights vector for each coefficient (we received it by machine learning).  The value of the convolution is invariant with respect to the scale of the compared characters.  In addition, the function is resistant to high-frequency noise (random pixels that do not change the "geometry" of the shape). <br><br>  OpenCV is quite helpful in implementing this method;  There is a ready-made function for obtaining external contours of objects: <br><pre> <code class="cpp hljs">cv::findContours(image, storage, CV_RETR_EXTERNAL);</code> </pre><br>  And there is the calculation function of the discrete Fourier transform: <br><pre> <code class="cpp hljs">cv::dft(src, dst);</code> </pre><br>  It remains only to implement convolution and intermediate type conversions, saving a set of descriptors. <br><br>  The method is good for handwritten characters (perhaps, probably because others give less qualitative results against it), but it is not suitable for small resolution characters because high-frequency noise, that is, ‚Äúextra‚Äù pixels become large with respect to the entire image and begin to influence those factors that we do not discard.  You can try to reduce the number of compared coefficients, but then it becomes more difficult to choose from similar small characters.  And so another recognition method was introduced. <br><br><h6>  Character recognition based on square deviation masks </h6><br>  This is quite an intuitive solution, which, as it turned out, works great for printable characters of any permissions;  if we have two black and white images of the same resolution, then we can learn to compare them pixel-by-pixel. <br><br>  For each point of the image 1 is considered fine: the minimum distance to the point of the image 2 of the same color.  Accordingly, a metric is simply a sum of penalties with a normalizing factor.  Such a method will be much more stable on low-resolution images with noise ‚Äî for an image with a side length n, individual pixels up to k percent do not ‚Äúspoil‚Äù the metric by more than k * n in the worst case, and in practical cases by no more than k , because in most cases they are adjacent to the ‚Äúright‚Äù pixels of the image. <br><br>  The disadvantage of the method, in the description as I described, will be the low speed of work.  For each pixel (O (n <sup>2</sup> )) we consider the minimum distance to a pixel of the same color of another picture (O (n <sup>2</sup> )), which gives O (n <sup>4</sup> ). <br><br>  But this is quite easily treated with a precomputation: we construct two masks, penalty_white (x, y) and penalty_black (x, y), in which the precomputed penalties for pixel (x, y) turn out to be white or black, respectively.  Then the process of "recognition" (that is, the calculation of the metric) fits into O (n <sup>2</sup> ): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; img.cols; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; img.rows; x++) { penalty += (image(y,x) == BLACK) ? penalty_black(y,x) : penalty_white(y,x); } }</code> </pre><br>  It remains only to store masks (penalty_white, penalty_black) for each writing of each character and in the process of recognizing them to go through.  OpenCV practically does not help us with the implementation of this algorithm, but it is trivial.  But, as I have already said, the compared images must be of the same resolution, therefore, in order to bring one to the other, a function may be required: <br><pre> <code class="cpp hljs">cv::resize(temp, temp, cv::Size(size_x, size_y), <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>);</code> </pre><br>  If we go back to the general process of character recognition, then as a result of running both methods, we get a table of metric values: <br><img src="http://habrastorage.org/storage2/07e/0db/19b/07e0db19b316ecff69c8faa41da957a1.png"><br>  The recognition value is not one element, but the entire table, from which we know that with the greatest probability is the ‚ÄúC‚Äù symbol, but perhaps it is ‚Äú0‚Äù or ‚Äú6‚Äù (or ‚ÄúO‚Äù, or ‚Äúc‚Äù, which did not fit on the screen).  And if it is a bracket, then it is more likely to open than to close.  But for now we don‚Äôt even know if this is a symbol at all ... <br><br><h4>  Primitive Level: Separation </h4><br>  If we lived in the ideal world of superproductive (quantum?) Computers, then most likely this step would not be necessary: ‚Äã‚Äãwe have a set of some objects, for each of which there is a table of ‚Äúprobabilities‚Äù defining what it is.  We iterate over all the elements in the table for each object, build a logical structure, and choose the most likely (by the sum of the metrics of individual objects) from the valid ones.  Delov something, except perhaps the exponential complexity of the algorithm. <br><br>  But in practice it is usually necessary to determine the type of object by default.  That is, to choose some finished interpretation of objects in the image, and then, perhaps slightly change it.  Why we could not choose the type of objects in the previous step (vectorization)?  We did not have enough statistical information about all objects, and if we interpret a certain set of pixels in isolation from the entire picture, then reliably determine its meaning becomes problematic. <br><br>  This is one of the most important issues of recognition of structural information.  In humans, this is much better than the car, because he simply does not know how to see the pixels separately.  And one of the initial stages of disappointment in building an OCR system is an attempt to algorithmize a sort of ‚Äústep-by-step‚Äù human approach, while at the same time obtaining unsatisfactory results.  It seems that just now, it is worthwhile to slightly improve the recognition algorithms of primitives so that they ‚Äúdo not make mistakes‚Äù and we will get better results, but there are always a few pictures that ‚Äúbreak‚Äù any logic. <br><br>  And so, we ask the person what it is - <img src="http://habrastorage.org/storage2/9cf/3f6/3c7/9cf3f63c71ff7b7b854d959ae3ab473a.png"><br>  Of course, this is just a curved line.  But if it is necessary to rank it either as symbols or as a set of straight line segments, what is it?  Then it is most likely either the letter ‚Äúl‚Äù or two straight lines at an angle (just the corner is drawn rounded).  But how to choose the right interpretation?  The machine could have solved the approximate problem at the previous step, and solved it correctly with a probability of 1/2.  But 1/2 is a complete breakdown for the structural information recognition system, we just spoil the structure, it does not pass validation, it is necessary to correct "errors" that, by a happy probability, may not coincide with the true problem.      . <br><br>       ,     : <br><img src="http://habrastorage.org/storage2/144/eb0/c4f/144eb0c4f180e224fcc8612b0429af6a.png"><br>            ,     -      (,       ).     ,    ,    ,   ¬´ ¬ª ‚Äî  . <br><br>    : <br><img src="http://habrastorage.org/storage2/f4b/5fe/1af/f4b5fe1afb5b2bd925de746e15f9b357.png"><br>   ,    ,    ¬´¬ª ,     ,     .    ,    ,     ,         ‚Äî     .   ,  ¬´Cl¬ª ()        ,  ,  -  ¬´l¬ª. <br><br>           .    . <br><br>  : <br><ul><li>           ¬´¬ª (  ),        C,     . </li></ul><br>  ,     . <br><br>       : <br><ul><li>    <i></i>     ; </li><li>    <i></i> ,   ; </li><li>    <i></i> ; </li><li>    , ; </li><li>    ,  <a href="http://en.wikipedia.org/wiki/Image_moment">hu moments</a> (  OpenCV  ). </li></ul><br>     ,    ‚Äî    ,     ,          ‚Äî       " <i></i> ". <br><br>    ,       : (       __-1  __+2,      3*__     0.5*  ),     .       <a href="http://habrahabr.ru/post/171759/"></a> ,      . <br><br>          .     ‚Äî   .         ,   , -      (      ).    ¬´¬ª                 (      ‚Äî     ,    ¬´l¬ª  ,     ¬´l¬ª.         ,    ). <br><br>      : <br><ul><li>      ; </li><li>       ,         ; </li><li> :          ,   . </li></ul><br>      ¬´ ¬ª ‚Äî      . <br><br>           ,     ,   . <br><img src="http://habrastorage.org/storage2/119/499/8cb/1194998cbc8b44d90c1d72a9d3317567.png"><br><br><h4>   </h4><br>        . ,         . <br><br>     ,  Imago OCR     ,      ,      ( ),       .         ,          .       ,     .       ,     . <br><br><h5>    </h5><br>   ,     .  ,     ‚Äî   ,      ¬´¬ª  ¬´¬ª,       : <br><img src="http://habrastorage.org/storage2/199/6a9/1da/1996a91dab4f643e9571c43c10ec50ec.png"><br>       ,  ¬´¬ª ,         : <br><img src="http://habrastorage.org/storage2/684/293/44b/68429344bcdc9be56123527c7d82a14c.png"><br>     ‚Äî            .  ,     ,    ,   ,     . <br><br>     : <br><img src="http://habrastorage.org/storage2/843/312/3cf/8433123cfb0b6bc6e72ec262be39e98e.png"><br>    ‚Äî      (,  ).      ,  ,   ,    ‚Äî  (  ,     ‚Äî  ). <br><br>        ,  .        ,  ¬´¬ª (   ),   ¬´¬ª.     ,    ,       ‚Äî    ¬´¬ª . <br><br><h5>     </h5><br>           ,  ¬´¬ª .     ,         ‚Äî   . <br>    ¬´ ¬ª : <img src="http://habrastorage.org/storage2/364/c33/188/364c3318845863b0ddfe4bac0f5bee6a.png"><br>   (     baseline_y),      ,    ‚Äî .   baseline_y   : <br><ul><li>      (       ); </li><li>          <i>y</i>   ,      . </li></ul><br>    ,    (      )?  ;        ,       ,    ,   ¬´     ¬ª.           baseline_y   ,    ‚Äî       . <br><br>   ,   .    : <br><ul><li> %  ,    ; </li><li>      . </li></ul><br>         :       30%  ‚Äî   .   29?           duck test.  -   ,    ‚Äî  .     ,   -     . <br><br>      ?   ,      .        .             (  ,            ?).            .   ,         : <br><ul><li>     k%   ,           f(k) ; </li><li>    n%   ,   ,        a..z   g(n) . </li></ul><br>    ,             ‚Äî   ,  .       ¬´¬ª  . <br><br><h5>   </h5><br>         ‚Äî   .     ‚Äî  :    ‚Äî    ,        ,    ‚Äî   .               . <br><br>       : {c1, c2} <br>  c1 ‚Äî  ¬´Y¬ª    0.1  ¬´X¬ª    0.4; <br> c2 ‚Äî  ¬´c¬ª    0.3  ¬´e¬ª    0.8 <br>     ,    ‚Äî <i>Yc</i> .   <i>Yc</i>  .            .    ‚Äî      . <br>      4 ,    " <i>Xe</i> ",    1.2. <br><br>     ,    .   ,   ¬´Yc¬ª     ,  .     ,      (1.2)   (0.4),     (0.8).      ,   ,    .     ? <br><br><h4>   </h4><br>     ,  ,    ?  ,       ,     ? <br><br>        ‚Äî       ,   <i> </i>  .    ,   <a href="http://habrahabr.ru/post/171751/"> </a> ,    . <br><br>   ,        ‚Äî  ,          .           ,      .        . <br><br>    ,     , ,   ,        ,    ,     ;        (  )   .       ,   ,         ‚Äî    . <br><br><h4>  Instead of conclusion </h4><br>   ¬´ ¬ª       OCR  ,     .  ,      ,    ,      ,                 .          . <br><br>  ,        ,    open-source  <a href="http://ggasoftware.com/opensource/imago">Imago OCR</a> ,          <a href="https://groups.google.com/forum/%3Ffromgroups"> google</a> . </habracut></div><p>Source: <a href="https://habr.com/ru/post/172651/">https://habr.com/ru/post/172651/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../172633/index.html">First look at the HTC One</a></li>
<li><a href="../172637/index.html">Android and Chrome OS on the road to unification: Sundar Pichai becomes the new head of Android</a></li>
<li><a href="../172641/index.html">Why modern interfaces are bad</a></li>
<li><a href="../172643/index.html">School business is not a hindrance. 10 entrepreneurs from 7 to 15 years</a></li>
<li><a href="../172647/index.html">About the intricacies of foreach in PHP</a></li>
<li><a href="../172653/index.html">On the responsibility of advertisers placing advertisements on torrents and file hosting</a></li>
<li><a href="../172655/index.html">Device and setting of EPU at cellular base station</a></li>
<li><a href="../172661/index.html">Text output in iOS: CoreText, NSAttributedString</a></li>
<li><a href="../172663/index.html">The realities of the Chinese Internet</a></li>
<li><a href="../172665/index.html">Google reader close</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>