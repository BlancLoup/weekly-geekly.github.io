<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to efficiently read data from the disk (provided that you have .Net)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! Some time ago I was interested in the question: how best to read data from a disk (assuming that you have .Net)? The task of reading heaps o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to efficiently read data from the disk (provided that you have .Net)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/8b6/f38/75d/8b6f3875d8347c80e2b21f77b8b3315b.jpg"><br><br>  Hi, Habr!  Some time ago I was interested in the question: how best to read data from a disk (assuming that you have .Net)?  The task of reading heaps of files is found in a variety of programs that, at the very start, begin to read configurations, some of them load modules, etc. <br><br>  On the Internet, I have not found such comparisons (except for tuning under certain configurations). <br><a name="habracut"></a><br>  The results can be viewed on <a href="https://github.com/imanushin/AsyncIOComparison/tree/master/Results">Github</a> : <a href="">SSD</a> , <a href="">HDD</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Ways of reading and testing algorithm </h2><br>  There are several main ways: <br><br><ul><li>  ScenarioReadAllAsParallel - <a href="">read with ReadAllText on ThreadPool</a> ; <br><br></li><li>  ScenarioSyncAsParallel - <a href="">read using Streams synchronously on the Thread Pool</a> ; <br><br></li><li>  ScenarioNewThread - <a href="">to read with the help of Streaming synchronously and on a separate stream for each reading, the time to start a new stream is also taken into account</a> ; <br><br></li><li>  ScenarioAsync2 - <a href="">read using Streams asynchronously (ie, async / await, if the file system responds for a long time, then many operations can start in parallel)</a> ; <br><br></li><li>  ScenarioAsync - <a href="">asynchronous reading, however, the start also occurs in many threads (and not sequentially on the same Main thread, as in the previous test)</a> ; <br><br></li><li>  ScenarioAsyncWithMaxParallelCount ‚Äî <a href="">read using Streams asynchronously (ie, async / await), but no more than in N parallel operations</a> . <br></li></ul><br>  I tested everything on SSD and HDD (in the first case there was a computer with Xeon 24 cores and 16 GB of memory and <a href="http://ark.intel.com/products/81043/Intel-SSD-Pro-2500-Series-180GB-2_5in-SATA-6Gbs-20nm-MLC">Intel SSD</a> , in the second - a Mac Mini MGEM2LL / A with Core i5, 4 GB of RAM and HDD 5400-rpm).  Systems are such that, by results, one can understand how to behave better on relatively modern systems and not very new ones. <br><br>  The project can be viewed <a href="https://github.com/imanushin/AsyncIOComparison">here</a> , it represents one main executable file <a href="https://github.com/imanushin/AsyncIOComparison/tree/master/TestsHost">TestsHost</a> and a bunch of projects with the names Scenario *.  Each test is: <br><br><ol><li>  Running an exe file that counts in pure time. <br><br></li><li>  Once a second, the processor load, memory consumption, disk load and a number of derived parameters (using <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa373083(v%3Dvs.85).aspx">Performance Counters</a> ) are checked. <br><br></li><li>  The result is remembered, the test is repeated several times.  The final result of work is the average time, excluding the largest and smallest values. <br></li></ol><br>  Preparation for the test more tricky.  So, before running: <br><br><ol><li>  We determine the size of files and their number (I chose such that the total volume was larger than the RAM size in order to suppress the influence of the disk cache); <br><br></li><li>  We are looking for files of a given size on a computer (and at the same time we ignore inaccessible files and a number of special folders about which are written below); <br><br></li><li>  Run one of the tests on the fileset, ignore the result.  All this is necessary in order to reset the OS cache, remove the influence from previous tests and just warm up the system. <br></li></ol><br>  And do not forget about error handling: <br><br><ol><li>  The program will return a return code of 0 only if all files have been read. <br><br></li><li>  Sometimes the whole test fails, if suddenly the system starts actively reading the file.  We sigh and restart again, adding the file (or folder) to the ignored ones.  Since I used the Windows &amp; Program Files directories as a good source of files, most realistically spread over the disk, some files could be blocked for a while. <br><br></li><li>  Sometimes one Performance Counter could give an error, since the process, for example, has already begun to end.  In this case, all counters for that second are ignored. <br><br></li><li>  On large files, some tests consistently issued Out Of Memory exceptions.  I removed them from the results. <br></li></ol><br>  And plus the standard moments about load testing: <br><br><ol><li>  Compilation is in Release mode in MSVS.  The launch goes as a separate application, without a debugger, etc. There is no tuning, because the essence of the checks is precisely in that - as in ordinary software it is faster to read files. <br><br></li><li>  The anti-virus is disabled, the system update is stopped, the active programs are also stopped.  No more tuning was not for the same reason. <br><br></li><li>  Each test is the launch of a separate process.  Overhead turned out to be within the framework of the error (i.e. jit, spending on the start of the process, etc.), and therefore I left just such isolation. <br><br></li><li>  Some Performance Counters gave zero results always for HDD / SSD.  Since the set of counters is sewn into the program, I left them. <br><br></li><li>  All programs were run as x64, an attempt to make a swap meant a memory inefficiency and immediately went down in statistics due to the long running time. <br><br></li><li>  Thread Priority and other tunings were not used, as there were no attempts to squeeze the maximum (which will depend heavily on a much larger number of factors). <br></li><li>  Technologies: .Net 4.6, x64 <br></li></ol><br><h2>  results </h2><br>  As I wrote in the header, the results are on <a href="https://github.com/imanushin/AsyncIOComparison/tree/master/Results">Github</a> : <a href="">SSD</a> , <a href="">HDD</a> . <br><br><h2>  SSD drive </h2><br>  <i>The minimum file size (bytes): 2, the maximum size (bytes): 25720320, the average size (bytes): 40953.1175</i> <br><table><tbody><tr><td>  <b>Scenario</b> <br></td><td>  Time <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount4 <br></td><td>  00: 00: 00.2260000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount8 <br></td><td>  00: 00: 00.5080000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount16 <br></td><td>  <b>00: 00: 00.1120000</b> <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount24 <br></td><td>  00: 00: 00.1540000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount32 <br></td><td>  00: 00: 00.2510000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount64 <br></td><td>  00: 00: 00.5240000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount128 <br></td><td>  00: 00: 00.5970000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount256 <br></td><td>  00: 00: 00.7610000 <br></td></tr><tr><td>  ScenarioSyncAsParallel <br></td><td>  00: 00: 00.9340000 <br></td></tr><tr><td>  ScenarioReadAllAsParallel <br></td><td>  00: 00: 00.3360000 <br></td></tr><tr><td>  ScenarioAsync <br></td><td>  00: 00: 00.8150000 <br></td></tr><tr><td>  ScenarioAsync2 <br></td><td>  <b>00: 00: 00.0710000</b> <br></td></tr><tr><td>  ScenarioNewThread <br></td><td>  00: 00: 00.6320000 <br></td></tr></tbody></table><br>  So, when reading many small files, the two winners are asynchronous operations.  In fact, in both cases, .Net used 31 threads. <br><br>  In fact, both programs differed by the presence or absence of ActionBlock for ScenarioAsyncWithMaxParallelCount32 (with restriction), it turned out that reading is better not to limit, then more memory will be used (in my case 1.5 times), and the restriction will be just at the level of standard settings (since Thread Pool depends on the number of cores, etc.) <br><br>  <i>The minimum file size (bytes): 1001, the maximum size (bytes): 25720320, the average size (bytes): 42907.8608</i> <br><table><tbody><tr><td>  <b>Scenario</b> <br></td><td>  Time <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount4 <br></td><td>  00: 00: 00.4070000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount8 <br></td><td>  00: 00: 00.2210000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount16 <br></td><td>  <b>00: 00: 00.1240000</b> <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount24 <br></td><td>  00: 00: 00.2430000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount32 <br></td><td>  00: 00: 00.3180000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount64 <br></td><td>  00: 00: 00.5100000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount128 <br></td><td>  00: 00: 00.7270000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount256 <br></td><td>  00: 00: 00.8190000 <br></td></tr><tr><td>  ScenarioSyncAsParallel <br></td><td>  00: 00: 00.7590000 <br></td></tr><tr><td>  ScenarioReadAllAsParallel <br></td><td>  00: 00: 00.3120000 <br></td></tr><tr><td>  ScenarioAsync <br></td><td>  00: 00: 00.5080000 <br></td></tr><tr><td>  ScenarioAsync2 <br></td><td>  <b>00: 00: 00.0670000</b> <br></td></tr><tr><td>  ScenarioNewThread <br></td><td>  00: 00: 00.6090000 <br></td></tr></tbody></table><br>  Increasing the minimum file size, I got: <br><br><ol><li>  The leaders were the launch of the program with the number of threads close to the number of processor cores. <br></li><li>  In a series of tests, one of the threads was constantly waiting for a blocking release (see <a href="https://msdn.microsoft.com/en-us/library/zf749bat(v%3Dvs.71).aspx">Performance Counter "Concurrent Queue Length"</a> ). <br></li><li>  Synchronous way of reading from the disk is still an outsider. <br></li></ol><br>  <i>The minimum file size (bytes): 10007, the maximum size (bytes): 62 444 171, the average size (bytes): 205102.2773</i> <br><table><tbody><tr><td>  <b>Scenario</b> <br></td><td>  Time <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount4 <br></td><td>  00: 00: 00.6830000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount8 <br></td><td>  00: 00: 00.5440000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount16 <br></td><td>  00: 00: 00.6620000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount24 <br></td><td>  00: 00: 00.8690000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount32 <br></td><td>  00: 00: 00.5630000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount64 <br></td><td>  00: 00: 00.2050000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount128 <br></td><td>  <b>00: 00: 00.1600000</b> <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount256 <br></td><td>  00: 00: 00.4890000 <br></td></tr><tr><td>  ScenarioSyncAsParallel <br></td><td>  00: 00: 00.7090000 <br></td></tr><tr><td>  ScenarioReadAllAsParallel <br></td><td>  00: 00: 00.9320000 <br></td></tr><tr><td>  ScenarioAsync <br></td><td>  00: 00: 00.7160000 <br></td></tr><tr><td>  ScenarioAsync2 <br></td><td>  00: 00: 00.6530000 <br></td></tr><tr><td>  ScenarioNewThread <br></td><td>  00: 00: 00.4290000 <br></td></tr></tbody></table><br>  And the last test for SSD: files from 10 KB, their number is smaller, but they themselves are larger.  And as a result: <br><br><ol><li>  If you do not limit the number of threads, the reading time becomes closer to synchronous operations. <br></li><li>  Limiting is already desirable as (number of cores) * [2.5 - 5.5] <br></li></ol><br><h2>  HDD drive </h2><br>  If everything was more or less good with the SSD, here I had frequent falls, so I excluded some of the results with the fallen programs. <br><br>  <i>The minimum file size (bytes): 1001, the maximum size (bytes): 54989002, the average size (bytes): 210818,0652</i> <br><table><tbody><tr><td>  <b>Scenario</b> <br></td><td>  Time <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount4 <br></td><td>  00: 00: 00.3410000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount8 <br></td><td>  00: 00: 00.3050000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount16 <br></td><td>  00: 00: 00.2470000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount24 <br></td><td>  <b>00: 00: 00.1290000</b> <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount32 <br></td><td>  00: 00: 00.1810000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount64 <br></td><td>  00: 00: 00.1940000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount128 <br></td><td>  00: 00: 00.4010000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount256 <br></td><td>  00: 00: 00.5170000 <br></td></tr><tr><td>  ScenarioSyncAsParallel <br></td><td>  00: 00: 00.3120000 <br></td></tr><tr><td>  ScenarioReadAllAsParallel <br></td><td>  00: 00: 00.5190000 <br></td></tr><tr><td>  ScenarioAsync <br></td><td>  00: 00: 00.4370000 <br></td></tr><tr><td>  ScenarioAsync2 <br></td><td>  00: 00: 00.5990000 <br></td></tr><tr><td>  ScenarioNewThread <br></td><td>  00: 00: 00.5300000 <br></td></tr></tbody></table><br>  For small files, the leaders are again asynchronous reading.  However, synchronous work also showed a good result.  The answer lies in the load on the disk, namely, in limiting parallel reads.  When you try to forcefully start reading in many threads, the system rests on a large queue for reading.  As a result, instead of parallel work, time is spent trying to service many requests in parallel. <br><br>  <i>The minimum file size (bytes): 1001, the maximum size (bytes): 54989002, the average size (bytes): 208913,2665</i> <br><table><tbody><tr><td>  <b>Scenario</b> <br></td><td>  Time <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount4 <br></td><td>  00: 00: 00.6880000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount8 <br></td><td>  <b>00: 00: 00.2160000</b> <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount16 <br></td><td>  00: 00: 00.5870000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount32 <br></td><td>  00: 00: 00.5700000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount64 <br></td><td>  00: 00: 00.5070000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount128 <br></td><td>  00: 00: 00.4060000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount256 <br></td><td>  00: 00: 00.4800000 <br></td></tr><tr><td>  ScenarioSyncAsParallel <br></td><td>  00: 00: 00.4680000 <br></td></tr><tr><td>  ScenarioReadAllAsParallel <br></td><td>  00: 00: 00.4680000 <br></td></tr><tr><td>  ScenarioAsync <br></td><td>  00: 00: 00.3780000 <br></td></tr><tr><td>  ScenarioAsync2 <br></td><td>  00: 00: 00.5390000 <br></td></tr><tr><td>  ScenarioNewThread <br></td><td>  00: 00: 00.6730000 <br></td></tr></tbody></table><br>  For the average file size, asynchronous reading continued to show the best result, except that it is desirable to limit the number of threads to an even lower value. <br><br>  <i>The minimum file size (bytes): 10008, the maximum size (bytes): 138634176, the average size (bytes): 429888,6019</i> <br><table><tbody><tr><td>  <b>Scenario</b> <br></td><td>  Time <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount4 <br></td><td>  00: 00: 00.5230000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount8 <br></td><td>  <b>00: 00: 00.4110000</b> <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount16 <br></td><td>  00: 00: 00.4790000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount24 <br></td><td>  <b>00: 00: 00.3870000</b> <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount32 <br></td><td>  00: 00: 00.4530000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount64 <br></td><td>  00: 00: 00.5060000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount128 <br></td><td>  00: 00: 00.5810000 <br></td></tr><tr><td>  ScenarioAsyncWithMaxParallelCount256 <br></td><td>  00: 00: 00.5540000 <br></td></tr><tr><td>  ScenarioReadAllAsParallel <br></td><td>  00: 00: 00.5850000 <br></td></tr><tr><td>  ScenarioAsync <br></td><td>  00: 00: 00.5530000 <br></td></tr><tr><td>  ScenarioAsync2 <br></td><td>  00: 00: 00.4440000 <br></td></tr></tbody></table><br>  Again as leaders, asynchronous reading with a limit on the number of parallel operations.  Moreover, the recommended number of threads has become even smaller.  And parallel synchronous reading steadily began to show Out Of Memory. <br><br>  With a larger file size increase, scripts with no limit on the number of parallel reads were more likely to fall out of memory.  Since the result was not stable from launch to launch, I have already found such testing inappropriate. <br><br><h2>  Total </h2><br>  What is the result you can learn from these tests? <br><br><ul><li>  In almost all cases, asynchronous reading, compared to synchronous, gave the best result in speed. <br><br></li><li>  As the file size grows, it is advisable to limit the number of threads, since otherwise the reading will be slow, plus the risk of OOM will increase. <br><br></li><li>  In all cases, there was no radically large increase in productivity, a maximum of 2-3 times.  Therefore, it is possible that it is not worth rewriting the old legacy application for asynchronous reading. <br><br></li><li>  However, for async programs, access to files will at least reduce the likelihood of crashes and increase speed. <br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/331668/">https://habr.com/ru/post/331668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331656/index.html">Protected workplace based on VDI Huawei FusionCloud Desktop Solution 6.1</a></li>
<li><a href="../331658/index.html">Ubuntu Mobile: Post-mortem Analysis</a></li>
<li><a href="../331662/index.html">Speed ‚Äã‚Äãreading: does it work or not? Part 2: parsing techniques</a></li>
<li><a href="../331664/index.html">Autoencoders in Keras, Part 4: Conditional VAE</a></li>
<li><a href="../331666/index.html">When will they send me an offer? Tips for applicants from HR-manager</a></li>
<li><a href="../331670/index.html">Dlang Tour translated into Russian</a></li>
<li><a href="../331672/index.html">"Confrontation": how information security specialists try to trick each other</a></li>
<li><a href="../331674/index.html">5 stages of microservice development</a></li>
<li><a href="../331676/index.html">SecureLogin - forget about passwords</a></li>
<li><a href="../331678/index.html">How HumanOps Principles Apply in Server Density</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>