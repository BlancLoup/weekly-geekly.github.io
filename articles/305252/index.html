<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>2D magic in detail. Part one. Shine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Games are large and three-dimensional have long been pleasing the eye with realistic lighting, soft shadows, highlights and other lighting beauty. In ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>2D magic in detail. Part one. Shine</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/3f6/730/35a/3f673035a5624efaa69be465b47d19a1.png"><br><p>  Games are large and three-dimensional have long been pleasing the eye with realistic lighting, soft shadows, highlights and other lighting beauty.  In the same two-dimensional games - at the head of the table are the direct hands of the artist, who will highlight and shade where necessary, sprite behind sprite, or even pixel by pixel.  And if you want dynamics without an artist, and yes, in pixel art? </p><a name="habracut"></a><br><h4 id="nebolshaya-remarka">  Small note </h4><br><p>  Imagine: </p><br><blockquote>  Battle mage enters the field in front of an ancient castle.  The grass is crushed under his boots, the evening sun blinds his eyes.  The magician waves his staff - a flash!  The fireball hits the ground in front of the castle, the shock wave picks up dust and bends blades of grass.  Clods of burnt green mixed with the ground fly apart.  On the stone wall - burning and soot.  Persevered. </blockquote><p>  And now we will make a small, but highly technological, toy out of this imaginary and spectacular image and share our achievements in the Unity3D Asset store. </p><br><p>  A series of articles is planned in which they will be described: light, mesh generation, own particle systems, work with samopisnymi editors, ragdoll on Verlet integration.  In the articles there will be descriptions of algorithms, both invented from the head, and those found in the vast world wide web.  In the articles there will be no descriptions of the form "Let's add a sprite and a camera to the stage, call it an article worthy of Habr, and put good people on the court."  At the time of writing this (first) article, the project has not yet been brought to mind, so the final part is planned to analyze errors and other additions. </p><br><h2 id="ctati-cikla">  Article cycle </h2><br><p>  <b>Part one.</b>  <b>Shine.</b> <br>  <a href="https://habrahabr.ru/post/312046">Part two.</a>  <a href="https://habrahabr.ru/post/312046">Structure.</a> <br>  <a href="https://habrahabr.ru/post/313776/">Part Three</a>  <a href="https://habrahabr.ru/post/313776/">Global coverage.</a> </p><br><h4 id="chto-takoe-svet-v-2d">  What is light in 2D? </h4><br><p>  Let's be honest - "realistic light" means "good looking," and not at all "reliably simulating optical laws."  Yes, and 2D - is also not quite true, because if the light source is in the same plane as the sprites - we will see absolutely nothing.  So let's decide what to consider as lighting. </p><br><p>  Bonfires, lanterns, fireballs and other magic are our main sources of light.  They are located approximately in the same plane where the main gameplay takes place.  And also - the sky, which illuminates the whole scene, and the sun / moon, which are not visible only in the interior. <br>  Apparently, all light sources can be broken as follows: <br><img src="https://habrastorage.org/files/475/801/7bb/4758017bb14648eaa1448192701e071f.png">  <strong>Point.</strong>  Point source of light, for which we can specify the position, brightness, color and radius of action. <br><img src="https://habrastorage.org/files/089/eb6/358/089eb6358b4342c6a9d534f3647fe7e6.png">  <strong>Ambient.</strong>  A light source that is not limited in distance, such as the sun.  Its light does not penetrate the premises.  Determined by position (to cast shadows correctly), brightness and color. <br><img src="https://habrastorage.org/files/824/ede/72f/824ede72f0654a2c8f8e3db0576c048c.png">  <strong>Diffuse ambient</strong> "Real" diffused light, penetrating anywhere.  It would be great if the color of the sky would correlate with light sources of this type.  Determined by color and brightness. </p><br><div class="spoiler">  <b class="spoiler_title">Little hint</b> <div class="spoiler_text"><p>  Icons of the types of sources that you see above are also involved in the project.  Unity3D has a special mechanism for rendering "debugging" information in the editor - Gizmo.  And with the help of them you can draw your icons, which is very convenient for working with objects: </p><br><img src="https://habrastorage.org/files/045/ab1/37c/045ab137ca824c38b2f92ef0124515e5.png"><br><p>  Interested - google in the direction of <a href="https://docs.unity3d.com/ScriptReference/Gizmos.DrawIcon.html">Gizmos.DrawIcon</a> and <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnDrawGizmos.html">MonoBehaviour.OnDrawGizmos</a> . </p></div></div><br><p>  And now we divide the game scene into layers, starting with the nearest one, and see what and how to light: </p><br><img src="https://habrastorage.org/files/9d3/6ef/7dd/9d36ef7dd8b4401ab38565e16f05f515.png"><br><p>  <strong>Walls and other obstacles.</strong>  Solid objects, they cast shadows and are illuminated only by diffused light (since all other sources are "behind them"). </p><br><img src="https://habrastorage.org/files/8d3/adb/7c6/8d3adb7c63f84b89a495e6598ea2c2bf.png"><br><p>  <strong>Game characters, grass, particles, etc.</strong>  Here is the main gameplay.  All objects should be illuminated by light sources, taking into account the shadows from the walls. <br>  <strong>And still background walls.</strong>  These objects are behind the gameplay, but close enough to also be illuminated by point light sources.  Shadows from obstacles are also counted. </p><br><img src="https://habrastorage.org/files/3ae/9e8/20b/3ae9e820b81845dcaa5ba6e9950e3483.png"><br><p>  <strong>Mountains, castles and other background.</strong>  They are far from point sources, illuminated only by diffused light. </p><br><img src="https://habrastorage.org/files/f15/ed5/d75/f15ed5d75a2b44fd8db123eace883c73.png"><br><p>  <strong>Sky.</strong>  It is in itself a source of diffuse lighting.  Point sources do not affect it (this is not entirely true, but I am running ahead). </p><br><h4 id="postroenie-teney">  Shadowing </h4><br><p>  So, we dealt with light sources, with game objects too.  It's time to do the shadows. <br>  Our sources of light are point (the diffuse illumination of shadows does not cast), so if a source of light is not ‚Äúvisible‚Äù from a pixel (the ray from the pixel to the source crosses obstacles) - there is a shadow.  Cool!  It remains only to run through all the pixels and look for intersections for each ... No, no, no, we will not go this way, do not worry!  In 3d games there is a method called Shadow volumes.  The idea is quite simple: take a mesh that casts a shadow, ‚Äúpull it out‚Äù from the light source, and then, when rendering, look where the pixel is - inside the mesh or outside.  Let's try the same!  Let's take meshes for our obstacles, draw them out ... Yes, yes, there is no mesh.  However, it does not matter - there is a texture with sprites, and we will use it. <br>  The idea is as follows: pull information about sprites from textures, find faces in each sprite, and build mesh on these faces.  All this is done in ScriptableObject'e, through a button in the editor.  The output is an associative array, where the key is the sprite, and the value is information about the faces. </p><br><div class="spoiler">  <b class="spoiler_title">A little more detail</b> <div class="spoiler_text"><p>  For reasons that are unclear to me, there are ScriptableObjects in Unity3D, but for some reason there is no way to create it without writing code.  So, if you want to make your objects, <a href="http://wiki.unity3d.com/index.php/CreateScriptableObjectAsset">this is</a> useful. <br>  There are quite a few functions with assets in the editor, they are in the AssetDatabase class, and are used, for example, to get sprites from a texture: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Sprite[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSprites</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Texture2D texture</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> path = AssetDatabase.GetAssetPath(texture); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AssetDatabase.LoadAllAssetsAtPath(path).OfType&lt;Sprite&gt;().ToArray(); }</code> </pre> <br><p>  Then we get the pixel colors through texture.GetPixels (), we run our hands and compare the neighboring pixels, whether the value of the alpha channel has changed. <br>  At the output, we get two arrays (vertical and horizontal) of such structures (the values ‚Äã‚Äãare whole, because we measure in pixels): </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> BasisLine { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> normal; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> start; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> end; }</code> </pre> <br><p>  And finally, to fully work with ScriptableObjects (and anything else!), Self-written editors are very useful.  The benefit in Unity3D is done quite simply: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CustomEditor(typeof(Edges.SpriteGenerator))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SpriteGeneratorEditor</span></span> : <span class="hljs-title"><span class="hljs-title">Editor</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnInspectorGUI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.DrawDefaultInspector(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targets.Length != <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> generator = (Edges.SpriteGenerator)target; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button(<span class="hljs-string"><span class="hljs-string">"Generate"</span></span>)) { generator.UpdateMeshes(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); serializedObject.ApplyModifiedProperties(); } } }</code> </pre> <br><p>  Do not repeat my mistakes - carefully watch that the private serializable fields are marked with [SerializeField] and the classes with [System.Serializable], otherwise you will then look for where the data from the objects in the build got to (everything will be fine in the editor, restart Unity3D). </p></div></div><br><p>  Another point: when placing obstacles on the scene, it makes sense to remove unnecessary edges (those that are in other obstacles).  First, it optimizes the mesh with the shadows.  Secondly, it simplifies life in the following articles (for example, information on the surface of obstacles is used for planting grass).  In short: when generating information about sprites, in addition to the faces, we find rectangles that completely fill the sprite.  I make several passes ‚Äî top-down, left-to-right, etc., and then choose the one that has fewer rectangles.  When placed on the stage, we run over obstacle sprites, find the intersections of AABB sprites, and then the faces of one sprite with the rectangles of the other.  Of course, there are all sorts of tricky moments, such as sprites, sides touching each other (and the face needs to be partially removed), or sprites that are superimposed so that the edge of one continues the edge of the other (and these faces must be merged into one).  But the result is worth it. </p><br><img src="https://habrastorage.org/files/d95/dde/3fb/d95dde3fbbdd4e4eb1ec5fab63de41fa.png"><br><p>  Finally, we have everything to finally build shadow meshes.  The idea is quite simple.  For each face of SF with normal N, we construct a rectangle ABCD, where the coordinates and normals are: </p><br><pre> <code class="cs hljs">A.vertex = D.vertex = S; B.vertex = C.vertex = F; A.normal = B.normal = <span class="hljs-number"><span class="hljs-number">0</span></span>; C.normal = D.normal = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  That is, the thickness of the rectangle is zero, but two faces have a normal, and two have a normal zero.  Now we can extend those vertices in the shader where the non-zero normal is directed away from the light source.  This will be our shadow: </p><br><img src="https://habrastorage.org/files/291/2c9/7d2/2912c97d2380418bb098fef431e8237e.png"><br><div class="spoiler">  <b class="spoiler_title">You can do it like this:</b> <div class="spoiler_text"><pre> <code class="hljs mel">Shader <span class="hljs-string"><span class="hljs-string">"NEngine/Light/Shadow"</span></span> { Properties { _LightPosition (<span class="hljs-string"><span class="hljs-string">"Light position"</span></span>, Vector) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) _ShadowLength (<span class="hljs-string"><span class="hljs-string">"Shadow length"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.1</span></span> _ShadowColor (<span class="hljs-string"><span class="hljs-string">"Shadow color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) } SubShader { Pass { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"IgnoreProjector"</span></span>=<span class="hljs-string"><span class="hljs-string">"True"</span></span> <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> } Cull Off CGPROGRAM #pragma vertex vert #pragma fragment frag struct appdata { fixed4 vertex : POSITION; fixed4 normal : NORMAL; }; struct v2f { fixed4 vertex : SV_POSITION; fixed4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> : COLOR; }; fixed2 _LightPosition; fixed _ShadowLength; fixed4 _ShadowColor; v2f vert(appdata v) { v2f o; fixed2 normal = v.normal.xy; fixed2 position = v.vertex.xy; fixed2 delta = <span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>(_LightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">dot</span></span>(delta, normal) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { o.vertex = <span class="hljs-number"><span class="hljs-number">0</span></span>; o.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v.normal.z == <span class="hljs-number"><span class="hljs-number">0</span></span>) { o.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = _ShadowColor; o.vertex = mul(UNITY_MATRIX_MVP, v.vertex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; } o.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = _ShadowColor; fixed2 direction = -delta * _ShadowLength; fixed4 vertex = v.vertex + fixed4(direction.xy, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); o.vertex = mul(UNITY_MATRIX_MVP, vertex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; } fixed4 frag(v2f i) : SV_Target { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; } ENDCG } } }</code> </pre> </div></div><br><p>  And at the output we get the following image: </p><br><img src="https://habrastorage.org/files/49f/788/cc1/49f788cc14814b2098a07fddf70aed72.png"><br><br><h4 id="zatenenie-pikseli-i-svet">  Shading, pixels and light </h4><br><p>  Initially, I made the shadows in this way, and I had no real light sources.  Just some abstract grayish shadows.  They were superimposed on objects with the stencil buffer ‚Äî all the sprites on which the shadow can be displayed, recorded the value in the buffer, and the shadows checked the buffer before drawing the pixel.  But not only does it look unrealistic, it also knocks itself out of the style - the pixels are large.  We think further. <br>  And after thinking, we do Light2DManager, in which the light sources are recorded when they appear, and then drawn into the texture with a small resolution.  Each source is drawn as: </p><br><ol><li>  First, in the material with shadows we record the position of the current source; </li><li>  Take a special sprite (for Point - this is a sprite with a radial gradient, for Ambient - just a rectangular sprite the size of a camera screen) and change its position to the source position; </li><li>  We draw the shadows and the sprite of the light into the texture (the light is cut off by the shader using the stencil buffer). </li></ol><br><p>  But with the conclusion on the screen of this lighting there is an interesting moment.  The fact is that the color of a pixel on the screen is usually calculated as follows: </p><br><pre> <code class="cs hljs">OBJECT_COLOR * LIGHT_COLOR</code> </pre><br><p>  Since the color of the pixel and the color of the light source range from 0 to 1, the result will be from zero to one.  And more "from zero" than "to one" - the sprites are not white and do their bit.  And sometimes you want to make such a bright source of light so that even the dark stones of the castle corridors shine like the morning sky.  Add an additional coefficient HDRRatio, equal to, for example 10. And in the shader of the light source we will get the result like this: </p><br><pre> <code class="cs hljs">fixed4(light.a * _Amount / _HDRRatio, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, light.a)</code> </pre> <br><p>  And when mixing light and scene, multiply by this factor.  Thus, we lose the lighting gradations (how much we lose - we define HDRRatio), but we can re-highlight the scene. <br>  We will mix the light with the scene through the post-effect - a small shader that will impose light depending on the value in the stencil buffer (remember that not all elements need to be lit?).  And we will summarize all Diffuse ambient sources, with some coefficient set as the background color on the main camera and as the background lighting for all objects in the scene. </p><br><img src="https://habrastorage.org/files/bcb/040/768/bcb0407682ee4419bc8b5a3e52995866.png"><br><br><h4 id="myagkie-teni">  Soft shadows </h4><br><p>  In pixel art there is an important rule, it can be found almost in any tutorial on this kind of visual art.  When drawing a straight oblique line, you need to make sure that the pixels do not look broken, the transitions should be soft and not noticeable. </p><br><div class="spoiler">  <b class="spoiler_title">If anyone is interested, a specific example</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/670/bef/1b2/670bef1b27194a71aecc53e19636b722.png"><br><p>  The upper lines are broken, coarse.  Lower - more smooth. </p></div></div><br><p>  But the lines of shadows cannot observe this rule now, after all, the shader lacks the talent of artists (so, gentlemen designers, do not worry, your work will never replace the soulless graphics card conveyor).  Anyway, since when are the sun's shadows so harsh?  But without smoothing out the shadows it will not work - the light is cut off by the stencil buffer, and there either there is a shadow or not, the middle does not exist. <br>  Google issues scary words to our requests - umbra and penumbra, gives pictures of someone's projects from which drooling.  Their general idea is to make more complex meshes, in which there is both a shadow and a penumbra.  But we will go the other way. <br>  Note that the closer the shadow is to the source of the shadow, the clearer it is.  So, we need to somehow blur the shadow, taking into account the distance to the object. <br>  Draw a sprite of light in only one channel (for example, red).  Draw a shadow in another channel (blue).  And also, draw the most distant points of the shadow (remember how it is built? The most distant ones are those whose normal is not zero) in the remaining green channel.  We will get just such a picture, which has everything you need: light, shadow and distance from the source of the shadow: </p><br><img src="https://habrastorage.org/files/a50/27b/d64/a5027bd648534fc5813836560489134f.png"><br><p>  Blur this image, but if usually with a blur (if you take the neighboring pixels), we do something like this: </p><br><pre> <code class="cs hljs">(current + top + bottom + right + left) / <span class="hljs-number"><span class="hljs-number">5.0</span></span></code> </pre> <br><p>  now we will consider the value from the green channel as weight: </p><br><pre> <code class="cs hljs">(current + top * top.g + bottom * bottom.g + right * right.g + left * left.g) / (top.g + bottom.g + right.g + left.g + <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Now we mix the R-channel with the light and the B-channel with the shadow without a gradient (in fact, simply multiply the two channels and the color of the light source).  We get neat blurry shadows: </p><br><img src="https://habrastorage.org/files/5b8/4e1/cc3/5b84e1cc318d415db2ffdead32ef7f5f.png"><br><img src="https://habrastorage.org/files/60b/677/965/60b67796544a45f29ced5283897a1c45.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4 id="krasivosti">  Beautiful </h4><br><p>  In the previous screenshot, the grass is so bright because it is lit by the sun, but it seems as if it is glowing by itself.  Add light on the verge of sprites obstacles. <br>  In the shadow shader, which is hidden somewhere in this article, the shadows that shine "inside" the object are cut off.  Now we need them to make self-shadowing for the edges.  The faces themselves will receive the light thanks to our post-effect for mixing the lighting and the scene (again, using stencil buffer).  Dirty hack - so that the object does not obscure the edges nearest to the source, we will move the shadow points in which the normal is zero away from the light source (by one pixel). </p><br><div class="spoiler">  <b class="spoiler_title">To be honest ...</b> <div class="spoiler_text"><p>  ... Then we also move in the direction of the normal, if only one pixel is exactly without a shadow.  It looks something like this: </p><br><pre> <code class="hljs mel">fixed2 direction = -delta * _PixelSize; fixed2 normalDirection = -v.normal.xy * _PixelSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>(direction.x) &lt; <span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>(normalDirection.x)) direction.x = normalDirection.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>(direction.y) &lt; <span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>(normalDirection.y)) direction.y = normalDirection.y; o.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = fixed4(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); o.vertex = mul(UNITY_MATRIX_MVP, v.vertex + fixed4(direction, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o;</code> </pre> </div></div><br><p>  That's better: </p><br><img src="https://habrastorage.org/files/266/54e/dfe/26654edfebf246fb97038764e728b690.png"><br><p>  It also happens that there is a lot of vapor, dust or smoke in the air, and the particles reflect light, forming beautiful rays in the air, which are called "twilight rays" or "god rays".  We already have everything we need to make them - we just need to allow the post-effect to draw light where nothing is written in the stencil buffer.  There are two points: first, add a certain factor to adjust the strength of such lighting, and secondly, this light should be added to the sky color, not multiplied: the rays do not depend on the sky color, only on dustiness. </p><br><img src="https://habrastorage.org/files/59d/6aa/5fc/59d6aa5fc28e4392a5adb260c5b4dcc3.png"><br><br><h4 id="zaklyuchenie">  Conclusion </h4><br><p>  It remains to see how it all looks in the dynamics: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iXTJBNjdLEs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><div class="spoiler">  <b class="spoiler_title">And, for the curious, what he looks like in the editor:</b> <div class="spoiler_text"><p>  With Gizmo lights, bots, wind and obstacles included: </p><br><img src="https://habrastorage.org/files/baf/c33/d8d/bafc33d8db1e4237a66b281f961cb4ff.png"></div></div><br><p>  So, we have quite a working light for a pixelart project.  It supports dynamic objects, soft shadows and other effects.  It is possible to move on!  At the moment there are several areas in the project, which are partially completed, and about which, I hope, it will be interesting to read.  Therefore, what the next article will be about - I leave it to you. </p><br><p>  Of course, there are enough unsolved issues, for example, optimization and work on mobile devices.  But about this - in the next times. </p></div><p>Source: <a href="https://habr.com/ru/post/305252/">https://habr.com/ru/post/305252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305182/index.html">Visualization of financial data. Mitap Ministry of Finance with developers, journalists and designers</a></li>
<li><a href="../305184/index.html">How to set up a network bridge (br0) on Ubuntu Linux 14.04 and 16.04 LTS</a></li>
<li><a href="../305188/index.html">Performance analysis of individual subsystems of the program for Linux perf report</a></li>
<li><a href="../305204/index.html">Roman Nester, co-founder of Segmento - about the future of advertising technologies on the Internet</a></li>
<li><a href="../305246/index.html">Big Binary in my Rust?</a></li>
<li><a href="../305254/index.html">ThinkPwn vulnerability in computer firmware was more serious than it seemed before</a></li>
<li><a href="../305256/index.html">ORegex: Is it fast enough for objects?</a></li>
<li><a href="../305258/index.html">Win a weightless flight with Veeam and Zero Gravity (USA)</a></li>
<li><a href="../305262/index.html">Vulners - Google for a hacker. How is the best search engine for vulnerabilities and how to use it</a></li>
<li><a href="../305264/index.html">How we sent SMS from the old Nokia and the phone to Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>