<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Opportunities metatablits in Lua on the example of the implementation of classes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There is no OOP in Lua. And, in general, it is not necessary: ‚Äã‚Äãconvenient modularity and first-class functions are enough to implement many things. O...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Opportunities metatablits in Lua on the example of the implementation of classes</h1><div class="post__text post__text-html js-mediator-article">  There is no OOP in Lua.  And, in general, it is not necessary: ‚Äã‚Äãconvenient modularity and first-class functions are enough to implement many things.  On this one could have finished, but the post is not about that.  In this case, I will sign out how to work with metatables, where, as an example, step by step, the system will be implemented to work with classes in a somewhat similar python-style.  For understanding, you need at least the basic basis of the language: tables, upvalues. <br><br><a name="habracut"></a><br><br><h3>  Vlob option </h3><br>  You can start with the simplest example: <br><pre><code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Obj = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Obj.spam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> <span class="hljs-string"><span class="hljs-string">'Hello world'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">--[[     : local Obj = { spam = function() print 'Hello world' end, } ]]</span></span> Obj.spam() <span class="hljs-comment"><span class="hljs-comment">-- Hello world</span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We got a table with one key, the value of which is a function.  However, inside Obj.spam itself you cannot get a link to Obj itself (except by name due to upvalue), as long as there is no this / self, etc.  inside the function. <br><br>  We can "realize" it ourselves: <br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Obj = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Obj.spam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(self) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> Obj.spam(Obj)</code> </pre><br>  or provide it to lua: <br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Obj = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Obj.spam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(self) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Obj:spam2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(self) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> Obj:spam() <span class="hljs-comment"><span class="hljs-comment">--  Obj['spam'](Obj), ..    ,      ,    ,  . Obj:spam2() Obj.spam(Obj) -- table: 0x417c7d58 -- table: 0x417c7d58 -- table: 0x417c7d58</span></span></code> </pre><br>  The result of the work will be the same link, because  all three self are the same. <br><br>  <i>Explicit use of a: b instead of ab (a) can be used, if desired, to visually distinguish the methods of the class Obj.foo (cls) and the methods of the instance a.foo (self).</i> <br><br>  A naive version of the constructor could look like this: <br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Obj = { var = <span class="hljs-number"><span class="hljs-number">0</span></span>, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Obj:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val)</span></span></span></span> self:set(val <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Obj:set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val)</span></span></span></span> self.var = val <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Obj:print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(self.var) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> a = Obj:new(<span class="hljs-number"><span class="hljs-number">42</span></span>) a:<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> b = Obj:new(<span class="hljs-number"><span class="hljs-number">100500</span></span>) b:<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>() a:<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>() <span class="hljs-comment"><span class="hljs-comment">-- 42 -- 100500 -- 100500</span></span></code> </pre><br><br>  There is a reuse of the same table, which leads to the replacement of a.var inside b.set.  To separate, you need to issue a new table to new: <br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Obj = { var = <span class="hljs-number"><span class="hljs-number">0</span></span>, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Obj:set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val)</span></span></span></span> self.var = val <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Obj:print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(self.var) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Obj:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">--      local inst = {} --     ,    Obj for k, v in pairs(self) do inst[k] = v end inst.new = nil --      .    :) inst:set(val or 0) return inst end local a = Obj:new(42) a:print() local b = Obj:new(100500) b:print() a:print() -- 42 -- 100500 -- 42</span></span></code> </pre><br>  It works, but it is too crooked, and you need to repeat it every time. <br><br><h3>  Metatables </h3><br>  In Lua, for each table (and userdata, but now it is not about them), you can set a metatable describing the behavior of this table in <a href="http://lua-users.org/wiki/MetatableEvents">special cases</a> .  Such cases can be used in arithmetic (operator overloading), concatenation as strings, etc.  As a small example of operator overloading and casting to a string: <br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> mt = { <span class="hljs-built_in"><span class="hljs-built_in">__add</span></span> = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(op1, op2)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> op1 = <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(op1) == <span class="hljs-string"><span class="hljs-string">'table'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op1.val <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> op1 <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> op2 = <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(op2) == <span class="hljs-string"><span class="hljs-string">'table'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op2.val <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> op2 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op1 + op2 <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">__tostring</span></span> = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">tostring</span></span>(self.val) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> T = { val = <span class="hljs-number"><span class="hljs-number">0</span></span>, new = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> inst = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(self) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> inst[k] = v <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">--      ,     setmetatable(inst, getmetatable(self)) return inst end, } setmetatable(T, mt) local a = T:new() a.val = 2 local b = T:new() b.val = 3 print(a) print(b) print(a + b) print(a + 10) print(100 + b) -- 2 -- 3 -- 5 -- 12 -- 103</span></span></code> </pre><br><br>  In this case, we are interested in the __index key used when accessing a table key that does not exist, which is used inside lua as follows: <br><ul><li>  If the key value is a function, then it is called with the transfer of the table and the required key to it.  The result of the function is used as the key value.  Repeating the call with the same key again calls the function (no ‚Äúcaching‚Äù); </li><li>  If the key value is another table, then the key is searched for in it.  If the key is not found, then this table is recursively checked by its metatable, and so on.  <s>The real We need to go deeper.</s> </li></ul><br><br>  This approach allows us to separate the description of the class from the creation of its instance: <br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> T = {} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> T_mt = { <span class="hljs-built_in"><span class="hljs-built_in">__index</span></span> = T, <span class="hljs-comment"><span class="hljs-comment">--     ,       } function T.create() -- setmetatable        return setmetatable({}, T_mt) end function T:set(val) self.val = val or 0 end function T:print() print(self.val) end local a = T.create() a:set(42) local b = T.create() b:set(100500) a:print() b:print() a:print() --   a.foo = 7 print(a.foo) print(b.foo) --   T.bar = 7 print(a.bar) print(b.bar)</span></span></code> </pre><br><br>  The resulting a and b are empty tables that do not have the keys new, set, and print.  These methods are stored in the general table T. With this approach, the a: print () call actually expands to (only the final execution branch): <br><pre> <code class="lua hljs"><span class="hljs-built_in"><span class="hljs-built_in">getmetatable</span></span>(a).<span class="hljs-built_in"><span class="hljs-built_in">__index</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(a)</code> </pre><br>  Inside lua, this is done very quickly. <br><br>  If you need to get a value only from a table, without using the magic of metatables, you can replace a.bar with rawget (a, 'bar') / rawset (a, 'bar', value). <br><br>  As an additional pleasant trivia, you can implement a more familiar syntax of constructors: <br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> T = {} <span class="hljs-built_in"><span class="hljs-built_in">setmetatable</span></span>(T, { <span class="hljs-built_in"><span class="hljs-built_in">__call</span></span> = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cls.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, }) <span class="hljs-comment"><span class="hljs-comment">-- !   T.create()    T(): local a = T() local b = T()</span></span></code> </pre><br><br><h3>  Idea development </h3><br>  Now you can try to put it all together in a common class generator, which will look like this: <br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> OOP = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OOP.class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">--  return cls --  ,   end --          local A = OOP.class { val = 0, set = function(self, val) self.val = val or 0 end, print = function(self) print(self.val) end, } --    local a = A:create() a:print() a:set(42) a:print()</span></span></code> </pre><br><br>  Implementation in this volume is very simple: <br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OOP.class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> struct = struct <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> cls = {} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_create_instance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> inst = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(struct) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> inst[k] = v <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inst <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-built_in"><span class="hljs-built_in">setmetatable</span></span>(cls, { <span class="hljs-built_in"><span class="hljs-built_in">__index</span></span> = { <span class="hljs-built_in"><span class="hljs-built_in">create</span></span> = _create_instance, <span class="hljs-comment"><span class="hljs-comment">--  ,   }, __call = function(cls) return cls:create() --    end, }) return cls end</span></span></code> </pre><br>  Total business. <br><br>  For class methods, you can save the class reference inside the table of the instance and use it later: <br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">-- ... local function _create_instance() local inst = {} -- ... inst.__class = cls -- ... end -- ... A.clsMeth = function(cls) print('Hello') end -- ... a.__class:clsMeth() -- a.clsMeth()  </span></span></code> </pre><br><br>  Much more interesting is the situation with inheritance.  While we analyze the unit: <br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">--     .     function OOP.subclass(parent) return function(struct) return OOP.class(struct, parent) end end local A = OOP.class { -- ... } local B = OOP.subclass(A) { -- B   A welcome = function(self) print('Welcome!') self:print() --      end, } local b = B() b:print() b:set(100500) b:welcome()</span></span></code> </pre><br>  For implementation, you need to make not so many edits: <br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OOP.class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct, parent)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1.     local struct = struct or {} local cls = {} local function _create_instance() local base = parent and parent:create() or nil -- 2.       local inst = {} -- 3.        if base then for k, v in pairs(base) do inst[k] = v end end for k, v in pairs(struct) do inst[k] = v end inst.__class = cls return inst end setmetatable(cls, { __index = setmetatable( -- 4.     { create = _create_instance, }, { --      ,     __index = function(_, key) if parent then return parent[key] end end, } ), __call = function(cls) return cls:create() end, }) return cls end</span></span></code> </pre><br><br>  To create our own explicit constructors, we will describe the new method and call it when creating an instance: <br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">-- ... setmetatable(cls, { -- ... __call = function(cls, ...) local inst = cls:create() --    -   local new = inst.new if new then new(inst, ...) end return inst end, }) -- ... local A = OOP.class { new = function(self, text) text = text or '' print('Hello ' .. text) end, } local B = OOP.subclass(A) { } A('world') B('traveler') -- Hello world -- Hello traveler</span></span></code> </pre><br>  We did not implement an automatic call of the constructor (and indeed of any other method) of the ancestor, respectively <br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> B = OOP.subclass(A) { new = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, text)</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">'B says '</span></span> .. <span class="hljs-built_in"><span class="hljs-built_in">tostring</span></span>(text)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, } B(<span class="hljs-string"><span class="hljs-string">'spam'</span></span>)</code> </pre><br>  will not call A.new.  To do this, again, you just need to make a small addition to the logic of the work, implementing the method of the instance super :) <br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> B = OOP.subclass(A) { new = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, text)</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">'B says '</span></span> .. <span class="hljs-built_in"><span class="hljs-built_in">tostring</span></span>(text)) self:super(<span class="hljs-string"><span class="hljs-string">'from B'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, } <span class="hljs-comment"><span class="hljs-comment">-- ... local function super_func(self, ...) local frame = debug.getinfo(2) local mt = getmetatable(self) assert(mt and mt.__base, 'There are no super method') local func = mt.__base[frame.name] return func and func(self, ...) or nil end -- ... local function _create_instance() -- ... --    inst.super    ,       . --      /. --       pairs(struct),  .   a.super = x   . local inst = setmetatable({}, { __base = base, __index = { super = super_func, }, }) -- ...</span></span></code> </pre><br>  super is called without specifying the name of the method being called.  To get it, use the debug module. <br>  <i>If you don't want to use it (or lua is running without it), then you can explicitly pass the name of the method.</i> <br>  <a href="http://www.lua.ru/doc/5.9.html">debug.getinfo () is</a> used to get brief information about the requested stack level: 0 - debug.getinfo itself, 1 - current (super_func), 2 - the level where super_func was called, ... We need the name of the function from which super, t was called .  field name of the second level stack. <br>  Now you can call any parent methods, not just the constructor :) <br><br>  To implement private fields and methods, you can use an approach based on a naming convention as in python, or use true hiding through the scope of the module, or even through upvalues: <br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> A = OOP.class((<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">--      local function private(self, txt) print('Hello from ' .. txt) end return { val = 0, public = function(self) private(self, 'public') end, } end)())</span></span></code> </pre><br>  Well, there are many options.  I'm quite happy with the naming convention. <br><br>  These are the capabilities provided by metatables in Lua.  If you were able to read all this, then, apparently, it was not written in vain. <br><br>  Full and a little more sophisticated version of the implementation <a href="">can be seen here</a> . </div><p>Source: <a href="https://habr.com/ru/post/228001/">https://habr.com/ru/post/228001/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227989/index.html">Zopo ZP700 - just a good smartphone</a></li>
<li><a href="../227991/index.html">Useful materials for mobile developer # 59 (June 23-29)</a></li>
<li><a href="../227993/index.html">On a compression algorithm for random signals (lossy)</a></li>
<li><a href="../227995/index.html">ASUS fonepad 7 LTE tablet</a></li>
<li><a href="../227999/index.html">AdvoCam-FD Black-GPS budget recorder review: Novatek 96650 vs Ambarella A5</a></li>
<li><a href="../228003/index.html">MiTCR is a platform for diagnosing a new type. Yandex Workshop</a></li>
<li><a href="../228005/index.html">Playing with Euclid</a></li>
<li><a href="../228009/index.html">Pizza delivery by drones in Syktyvkar was outlawed</a></li>
<li><a href="../228015/index.html">Pulse Habra</a></li>
<li><a href="../228019/index.html">The world's largest radio telescope completed and working at full capacity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>