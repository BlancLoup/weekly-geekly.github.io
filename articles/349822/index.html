<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Qt: Writing a generic model for QML ListView</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some people will find the material in this article too simple, useless to someone, but I‚Äôm sure that for Qt and QML beginners who are faced with the n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Qt: Writing a generic model for QML ListView</h1><div class="post__text post__text-html js-mediator-article"><p> Some people will find the material in this article too simple, useless to someone, but I‚Äôm sure that for Qt and QML beginners who are faced with the need to create models for <code>ListView</code> for the first time, this will be useful as an alternative * quick and fairly effective solution. in terms of "price / quality". </p><br><p>  * At least, at one time I didn‚Äôt manage anything like that.  If you know and can add - welcome. </p><br><h3 id="o-chem-shum">  What is the noise about? </h3><br><p>  With the advent of QML in Qt, creating user interfaces has become easier and faster ... until you have to work closely with C ++ code.  Creating exported C ++ classes is fairly well described in the <a href="http://doc.qt.io/qt-5/qtqml-cppintegration-topic.html">documentation</a> and as long as you work with simple structures, everything is really quite trivial (well, almost).  The main trouble comes when you need to "show" in QML the elements of a container, and in a simple way - the collection, and especially when these elements have a complex structure of nested objects, and even other collections. </p><br><p>  Interesting? <a name="habracut"></a></p><br><p>  It is assumed that you are familiar with the terminology of Qt and words such as <em>delegate</em> , <em>role</em> , <em>container</em> as applied to lists and list components will not surprise you, as I once did ... </p><br><p>  The most used component for displaying QML list data is the <code>ListView</code> .  Following the Qt documentation, there are several ways to pass data to it, but the only option that is suitable for a C ++ implementation is to create your model through inheritance from <code>QAbstractItemModel</code> .  How to do this in Habr√© article already, for example, <a href="https://habrahabr.ru/post/302428/">this</a> .  And everything would be fine, but let's start with some facts: </p><br><ul><li>  As a <a href="http://doc.qt.io/archives/qt-4.8/containers.html">container</a> in Qt, we most often use a <code>QList</code> , </li><li>  To avoid unnecessary copying, we usually place objects on the heap. </li><li>  And to make memory management easier, we use some smart pointers.  For Qt, the native <code>QSharedPointer</code> works quite well. </li><li>  The elements of the container are often <code>QObject</code> , since  we need properties exported to QML (for this, you can still use Q_GADGET, if you don‚Äôt need to change these properties, but there you also have your own "jokes"). </li><li>  We often have not so many elements, say, up to a million (for example, some kind of news feed, or a list of files in a regular directory (npm_modules do not count :)) If the elements that need to be displayed are much larger, then rather first of all solve more serious problems - with UX. </li></ul><br><p>  Having realized several such models, you quickly realize that the amount of boilerplate in them exceeds the limit.  Just throwing the names of roles is worth something.  And in general, why, if all this is already in <code>Q_OBJECT</code> and <code>Q_GADGET</code> ?  It quickly comes to mind that I would like to have some kind of template container that could generalize all this: to have a sheet interface and at the same time be able to act as a model for <code>ListView</code> , for example <code>ListModel&lt;ModelItem&gt; itemsCollection</code> ... </p><br><h3 id="dlya-chego-voobsche-listu-model">  What is the model for the sheet for? </h3><br><p>  The sheet creates delegates (renderers for individual items) not all at once, but only those that should be visible at the moment plus an optional cache.  When you scroll the sheet, delegates that went beyond the scope of visibility are destroyed, and new ones are created.  Now let's add a new item to our list.  In this case, the <code>ListView</code> should be informed which index was added and if this index is between the indexes that are currently displayed, it means you need to create a new delegate, initialize it with data and place it between the existing ones.  When deleting, the situation is reversed.  When we change the properties of the elements, there are added signals about the change of "roles" - the data that can be seen directly in the delegate (frankly, I do not know who thought of it so to call it). </p><br><p>  If we use "pure" C ++ structures, then we have no choice: the only way to export such data is our own successor model from QAbstractItemModel.  And if we have Q_OBJECT or Q_GADGET elements, then they already know how to "show" their properties in QML and additional duplication of roles, as well as "juggling" the model when changing such objects becomes very inconvenient and impractical.  And if you need to pass through the role and the structure, the task becomes even more complicated, because  in this case, the structure is transferred hosted in <code>QVariant</code> with all the consequences. </p><br><h3 id="peredacha-strukturnogo-elementa-v-qml">  Transferring a structural element to QML </h3><br><p>  First, let's take a look, how can you delegate a container element with a complex structure to the delegate? </p><br><p>  Suppose we have a list of elements with the following structure of objects: </p><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Person + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> address + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> phoneNumber <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Employee + Person* person + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> position + double salary</code> </pre> <br><p>  Of course, in this case, to display such a structure, it could be painlessly made flat, but let's imagine that the data is complex and we cannot do that. </p><br><p>  So, create a successor from <code>QAbstractListModel</code> (which in turn is a successor from <code>QAbstractItemModel</code> ).  As storage we take popular <code>QList</code> .  But do not ask any roles!  Instead, we proceed as follows: </p><br><ul><li>  Let's register our classes in QMLEngine: </li></ul><br><pre> <code class="hljs objectivec">qmlRegisterUncreatableType&lt;Person&gt;( <span class="hljs-string"><span class="hljs-string">"Personal"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Person"</span></span>, <span class="hljs-string"><span class="hljs-string">"interface"</span></span> ); qmlRegisterUncreatableType&lt;Employee&gt;( <span class="hljs-string"><span class="hljs-string">"Personal"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Employee"</span></span>, <span class="hljs-string"><span class="hljs-string">"interface"</span></span> );</code> </pre> <br><p>  and do not forget yet </p><br><pre> <code class="hljs lisp">Q_DECLARE_METATYPE( <span class="hljs-name"><span class="hljs-name">Person*</span></span> ) Q_DECLARE_METATYPE( <span class="hljs-name"><span class="hljs-name">Employee*</span></span> )</code> </pre> <br><p>  In this case, I assume that our classes are <code>QObject</code> .  One can argue about the effectiveness of such an approach for a long time, but in real problems saving on a QObject often turns out to be a saving on matches and is incommensurable with labor costs.  And if you look at the tendencies at all to write applications on Electron ... <br>  Why <em>uncreatable</em> - because it's easier.  We are not going to create these objects in QML, which means we do not need a default constructor, for example.  For us, this is just an "interface". </p><br><ul><li>  We implement a method in the Q_INVOKABLE model, which will return a pointer to our structure by its index. </li></ul><br><p>  Total, something turns out such: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Personal : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> QAbstractListModel { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: //       Q_INVOKABLE Employee* getEmployee( <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ); //   QAbstractListModel: <span class="hljs-type"><span class="hljs-type">int</span></span> rowCount( const QModelIndex&amp; parent ) const override { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> personal.count(); } //    , ..    . QVariant data( const QModelIndex&amp; <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">role</span></span> ) const override { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QVariant(); } //  -          //     QList,      // beginInsertRows(), endInsertRows()   . //   ,   ,  . private: QList&lt;Employee*&gt; personal; }</code> </pre> <br><p>  Now, with such a model, in view we can substitute into it and then use a <strong>typed</strong> object when instantiating a delegate!  Moreover, Qt Creator is quite capable when typing to podkazyvat fields of this structure, which in turn also can not but rejoice. </p><br><pre> <code class="hljs pgsql">// PS        QMLEngine Personal { id: personalModel } ListView { model: personalModel delegate: Item { // <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> -   .   ,      property Employee employee: personalModel.getEmployee(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-type"><span class="hljs-type">Text</span></span> { <span class="hljs-type"><span class="hljs-type">text</span></span>: employee.person.name } } }</code> </pre> <br><h3 id="stupen-pervaya-model-indeksov">  Step One: Index Model </h3><br><p>  Now let's analyze what we did.  And it turned out that we only use indexes from our <code>QAbstractListModel</code> , the rest of the work is done by <code>Q_OBJECT</code> and their meta-properties.  Those.  we can implement, by and large, a model that will only work with indexes and that will be enough for <code>ListView</code> know what is happening!  We get this interface: </p><br><pre> <code class="hljs perl">class IndicesListModelImpl : public QAbstractListModel { Q_OBJECT Q_PROPERTY( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count READ count NOTIFY countChanged ) public: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count() const; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> --- QAbstractListModel --- <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rowCount( const QModelIndex&amp; parent ) const override; QVariant data( const QModelIndex&amp; <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> role ) const override; protected: <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create <span class="hljs-string"><span class="hljs-string">"count"</span></span> indices <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> them to end void <span class="hljs-keyword"><span class="hljs-keyword">push</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Remove <span class="hljs-string"><span class="hljs-string">"count"</span></span> indices from the end. void <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Remove indices at particular place. void removeAt( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Insert indices at particular place. void insertAt( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Reset model with new indices count void <span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> ); Q_SIGNALS: void countChanged( const <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; count ); private: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_count = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  where in the implementation we simply inform the view that certain indices seem to have changed, like this: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> IndicesListModelImpl::insertAt( <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> count ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> &gt; m_length + <span class="hljs-number"><span class="hljs-number">1</span></span> || count &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> start = <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> end = <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + count - <span class="hljs-number"><span class="hljs-number">1</span></span>; beginInsertRows( QModelIndex(), <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ); m_count += count; endInsertRows(); emit countChanged( m_count ); }</code> </pre> <br><p>  Well, not bad, now we can inherit not directly from <code>QAbstractListModel</code> , but from our improvised class, where there is already half of the logic we need.  What if ... and a container to summarize? </p><br><h3 id="ctupen-vtoraya-dobavlyaem-konteyner">  Step Two: add container </h3><br><p>  Now it‚Äôs not a shame to write a template class for a container.  You can mess up and make two parameters for the template: the container and the stored type, thus allowing the use of anything at all, but I would not and stopped at the most frequently used, in my case it is <code>QList&lt;QSharedPointer&lt;ItemType&gt;&gt;</code> .  <code>QList</code> as the most frequently used container in Qt, and <code>QSharedPointer</code> to worry less about ownership.  (PS Something that still needs to be worried, but more on that later) </p><br><p>  Well, let's go.  Ideally, we want our model to have the same interface as <code>QList</code> and thus mimic him to the maximum, but it would be too inefficient to forward everything, because really we need not so much: only those methods that are used to change - append, insert , removeAt.  For the rest, you can simply make a public accessor to the internal list "as is". </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ItemType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListModelImplTemplate</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IndicesListModelImpl { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QSharedPointer&lt;ItemType&gt;&amp; item )</span></span></span><span class="hljs-function"> </span></span>{ storage.append( item ); IndicesListModelImpl::push(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QList&lt;QSharedPointer&lt;ItemType&gt;&gt;&amp; </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">list</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ storage.append( <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> ); IndicesListModelImpl::push( <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.count() ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeAt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( i &gt; length() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; storage.removeAt( i ); IndicesListModelImpl::removeAt( i ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QSharedPointer&lt;ItemType&gt;&amp; item )</span></span></span><span class="hljs-function"> </span></span>{ storage.insert( i, item ); IndicesListModelImpl::insertAt( i ); } <span class="hljs-comment"><span class="hljs-comment">// --- QList-style comfort ;) --- ListModelImplTemplate&amp; operator+=( const QSharedPointer&lt;ItemType&gt;&amp; t ) { append( t ); return *this; } ListModelImplTemplate&amp; operator&lt;&lt;( const QSharedPointer&lt;ItemType&gt;&amp; t ) { append( t ); return *this; } ListModelImplTemplate&amp; operator+=( const QList&lt;QSharedPointer&lt;ItemType&gt;&gt;&amp; list ) { append( list ); return *this; } ListModelImplTemplate&amp; operator&lt;&lt;( const QList&lt;QSharedPointer&lt;ItemType&gt;&gt;&amp; list ) { append( list ); return *this; } // Internal QList storage accessor. It is restricted to change it directly, // since we need to proxy all this calls, but it is possible to use it's // iterators and other useful public interfaces. const QList&lt;QSharedPointer&lt;ItemType&gt;&gt;&amp; list() const { return storage; } int count() const { return storage.count(); } protected: QList&lt;QSharedPointer&lt;ItemType&gt;&gt; storage; };</span></span></code> </pre> <br><h3 id="stupen-tretya-metod-getitem-i-generalizaciya-modeli">  Step three: getItem () method and model generalization </h3><br><p>  It would seem that it remains to make another template from this class and then use it as a type for any collection and deal with it, for example: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Personal</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QObject</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">public</span></span>: ListModel&lt;Employee&gt;* personal; }</code> </pre> <br><p>  But there is a problem and the third step is not in vain: QObject classes that use the Q_OBJECT macro cannot be template, and at the very first attempt to compile such a MOC class, you are happy to tell about it.  All sailed? </p><br><p>  Not at all, there is a solution to this problem, though not so elegant: the good old macro #define!  We will generate our class dynamically ourselves, where it is needed (any better than writing a boilerplate every time).  Fortunately, it remains for us to implement only one method! </p><br><pre> <code class="hljs kotlin">#define DECLARE_LIST_MODEL( NAME, ITEM_TYPE ) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NAME</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ListModelImplTemplate</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ITEM_TYPE</span></span></span><span class="hljs-class">&gt; </span></span>{ Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: Q_INVOKABLE ITEM_TYPE* item( int i, bool keepOwnership = <span class="hljs-literal"><span class="hljs-literal">true</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; storage.length() &amp;&amp; storage.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { auto obj = storage[i].<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( keepOwnership ) QQmlEngine::setObjectOwnership( obj, QQmlEngine::CppOwnership ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Q_NULLPTR; } } }; Q_DECLARE_METATYPE( NAME* )</code> </pre> <br><p>  We should also tell about <code>QQmlEngine::setObjectOwnership( obj, QQmlEngine::CppOwnership );</code>  - This thing is needed for so that QMLEngine did not even think to manage our facilities.  If we want to use our object in some JS function and place it in a variable with a local scope, then the JS Engine will crash it when it exits this function, because  our <code>QObject</code> no parent.  On the other hand, parent, we do not use intentionally, because  we already have object lifetime control using <code>QSharedPointer</code> and we do not need another mechanism. </p><br><p>  Total, we receive such picture: </p><br><ol><li>  The basic implementation of <code>QAbstractListModel</code> - <code>IndicesListModelImpl</code> - for manipulating indexes so that <code>ListView</code> responds </li><li>  An honest template wrapper class over a standard container, the task of which is to provide editing of this container and calling methods of the upstream <code>IndicesListModelImpl</code> </li><li>  The generated class is the heir to all this "goodness", which provides a single method for accessing elements from QML. </li></ol><br><img src="https://habrastorage.org/webt/x-/9s/1z/x-9s1zi64kcn-suf_qij3dq0njy.png" width="460"><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  It‚Äôs very simple to use this solution: where we need to export some collection of objects to QML, we immediately create the necessary model and use it immediately.  For example, we have some class provider (and in Qt terminology, Backend), one of whose properties should provide a list of some <code>DataItem</code> : </p><br><pre> <code class="hljs pgsql">//    DECLARE_LIST_MODEL( ListModel_DataItem, DataItem ) <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Provider : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> QObject { Q_OBJECT Q_PROPERTY( ListModel_DataItem* itemsModel <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span> itemsModel <span class="hljs-keyword"><span class="hljs-keyword">NOTIFY</span></span> changed ) <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: explicit Provider( QObject* parent = Q_NULLPTR ); ListModel_DataItem* itemsModel() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;m_itemsModel; }; Q_INVOKABLE <span class="hljs-type"><span class="hljs-type">void</span></span> addItem() { m_itemsModel &lt;&lt; QSharedPointer&lt;DataItem&gt;( <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> DataItem ); } Q_SIGNALS: <span class="hljs-type"><span class="hljs-type">void</span></span> changed(); private: ListModel_DataItem m_itemsModel; };</code> </pre> <br><p>  And of course, with all of this together: with the template and the full code of the example of use, you can <a href="https://github.com/koldoon/qt-listview-generic-cpp-model">take and familiarize yourself with the github</a> . </p><br><p>  Any additions, comments and pull requests are welcome. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/349822/">https://habr.com/ru/post/349822/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349810/index.html">Hyperapp for Refugees with React / Redux</a></li>
<li><a href="../349812/index.html">Segregated Witness for Dummies</a></li>
<li><a href="../349816/index.html">Open webinar "Features of JavaScript"</a></li>
<li><a href="../349818/index.html">Asynchronous HTTP requests in C ++: incoming through RESTinio, outgoing through libcurl. Part 2</a></li>
<li><a href="../349820/index.html">–ï–ì–ê–ò–° 3.0 - 100% readiness! Alcohol accounting markup</a></li>
<li><a href="../349824/index.html">Drop Stack Overflow: What Happened</a></li>
<li><a href="../349826/index.html">Sleight of hand and no fraud: practical tips on accelerated design training for developers</a></li>
<li><a href="../349830/index.html">Personal experience: a selection of materials about the virtual infrastructure, information security and trends in the IaaS market</a></li>
<li><a href="../349832/index.html">Alternative to paid off ads in the free Android application</a></li>
<li><a href="../349836/index.html">Understanding Dependencies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>