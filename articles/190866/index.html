<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Determination of the percentage of similarity drawn 2d-polygon with a given pattern</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings, friends. 

 As you know, recently the technology of developing games for mobile platforms has been developing very rapidly. Games are writt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Determination of the percentage of similarity drawn 2d-polygon with a given pattern</h1><div class="post__text post__text-html js-mediator-article">  Greetings, friends. <br><br>  As you know, recently the technology of developing games for mobile platforms has been developing very rapidly.  Games are written in a variety of engines and languages, we will not discuss in this article why a particular language / engine is better or worse (really?).  Developers are trying to come up with new interesting and convenient game controls.  As a player, I really like to use geometric elements in the game.  For example, such as in the game Juggernaut for mobile devices. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89a/552/359/89a5523598aae1c7ba48bf40bee56464.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will try to tell you about the algorithm for determining drawn 2d shapes.  I wrote my version of the engine in ActionScript 3.0.  If desired (and the availability of basic knowledge of geometry) it can be implemented on any other. <br><br>  So, we need to determine the percentage of similarity with the existing one using a hand-drawn figure: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/e8f/02a/7c3e8f02ab057345ed622b5f47109f1f.jpg"><br><a name="habracut"></a><br><h1>  Basic geometry </h1><br>  To implement the algorithm, we need the basic formulas of geometry on the plane. <br><br><h5>  [F1] Cut Length: </h5><br><pre><code class="hljs lisp">len = sqrt((<span class="hljs-name"><span class="hljs-name">x2-x1</span></span>)^<span class="hljs-number"><span class="hljs-number">2</span></span> + (<span class="hljs-name"><span class="hljs-name">y2-y1</span></span>)^<span class="hljs-number"><span class="hljs-number">2</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><br><h5>  [F2] Line direction and normal vectors: </h5><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//     directX = x2-x1; directY = y2-y1; //      normaleX = -directY; normaleY = directX;</span></span></code> </pre><br><br><h5>  [F3] Equation of a line on the plane Ax + By + C = 0 </h5><br>  To get the coefficients A, B and C from the equation of a straight line, knowing the two points of this straight line, you can do this: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">A</span></span> = -normaleX; <span class="hljs-attribute"><span class="hljs-attribute">B</span></span> = -normaleY; <span class="hljs-attribute"><span class="hljs-attribute">C</span></span> = -A*x1 - B*y1;</code> </pre><br><br><h5>  [F4] The position of the point relative to the line. </h5><br>  We assume that a point lies <b>above the line</b> in the case that the formula Ax + By + C, when substituting the values, gives a value greater than zero.  If the value is zero, then the point belongs to this line.  Imagine that the first point of the line lies in the left part of the screen, and the second in the right, and so, all the points that lie above this line (at the top of the screen) will give a positive value when you substitute a straight line into the equation.  It is very important to understand where the first (initial) point is, and where the second (final) is: if you have points <b>p = {x, y}</b> and <b>q = {x, y}</b> , and you calculate the direction (and normal vector) using the formula : <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">directX</span></span> = qx-px; <span class="hljs-attribute"><span class="hljs-attribute">directY</span></span> = qy-py;</code> </pre><br>  , then the first (initial) point will be <b>p</b> , and the second (final) point will be <b>q</b> . <br><br><h5>  [F5] Belonging of a point to a segment </h5><br>  The point <b>o</b> belongs to the segment <b>pq</b> if it lies on a straight line passing through these points, and if it lies between two given points of the segment.  The ownership algorithm is as follows: <br><br>  - determine whether the point lies on the line ( <b>[F4]</b> ) <br>  - we find the lengths of the segments ( <b>[F4]</b> ) <b>op</b> and <b>oq</b> , if at least one of these values ‚Äã‚Äãis greater than the length of the segment <b>pq</b> , then the point <b>o</b> does not lie inside the segment <b>pq</b> <br><br><h5>  [F6] The intersection point of infinitely long straight lines </h5><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// ,     l1 = {p1,p2}; l2 = {p1,p2}; // d = (l2.p2.y-l2.p1.y)*(l1.p2.x-l1.p1._x) - (l2.p2.x-l2.p1.x)*(l1.p2.y-l1.p1.y); a = (l2.p2.x-l2.p1.x)*(l1.p1.y-l2.p1._y) - (l2.p2.y-l2.p1.y)*(l1.p1.x-l2.p1.x) //   x0 = l1.p1.x + a*(l1.p2.x-l1.p1.x)/d y0 = l1.p1.y + a*(l1.p2.y-l1.p1.y)/d</span></span></code> </pre><br>  Note that if <b>d = 0</b> , then the straight lines are parallel. <br><br><h5>  [F7] The intersection point of two segments.  The point of intersection of the infinite line and the segment. </h5><br>  If the intersection of two finite segments or an infinite line and a final segment is checked, it is necessary to first determine the intersection point of two infinite lines ( <b>[F6]</b> ) and check whether this point belongs to all participating segments ( <b>[F5]</b> ). <br><br><h5>  Triangle - elementary polygon as the basis of everything </h5><br>  As you know the triangle is the easiest polygon.  Many calculations of polygons are connected with triangles, therefore I will give several formulas for working with them. <br><br><h5>  [F8] Triangle Geometry Center </h5><br>  The center of a triangle (or <b>Centroid</b> ) is the arithmetic average of the coordinates of the points of the triangle.  Determined by the formula: <br><pre> <code class="hljs lisp">x0 = (<span class="hljs-name"><span class="hljs-name">a</span></span>.x+b.x+cx)/3<span class="hljs-comment"><span class="hljs-comment">; y0 = (a.y+b.y+cy)/3;</span></span></code> </pre><br><br><h5>  [F9] Triangle area </h5><br>  Knowing only the coordinates of the points of the triangle, its area can be determined by multiplying the lengths of the two sides by the sine of the angle between these sides. <br><br><h5>  [F10] Polygon on the plane </h5><br>  The polygon <b>P</b> on the plane is given by a set of vertices: <b>v1, v2, ..., vn</b> , where n is the number of vertices.  The polygon has edges that are formed by connecting adjacent vertices: <b>e1 = {v1, v2}, e2 = {v2, v3}, ..., en = {vn, v1}</b> . <br><br><h5>  [F11] Polygon bounding box </h5><br>  The bounding box is given by the <b>bounds = {x, y, width, height}</b> object, where x and y are the minimum coordinates of the vertices of the polygon, and width and height are the difference between the maximum and minimum coordinates of the vertices. <br><br><h5>  [F12] Polygon Center </h5><br>  The center is usually understood as different entities, for example, the center of a system of points or the center of mass by area ... We will use the center of mass, which is calculated according to the following algorithm.  It is necessary to split the polygon into triangles, no matter what, you can simply use the vertices in order.  We find the sum of the products of the centers of triangles and their areas and divide this amount by the total area of ‚Äã‚Äãthe polygon.  The area of ‚Äã‚Äãthe polygon is calculated as the sum of the areas of its triangles. <br><pre> <code class="hljs xml">//    var triangles:Array = ... ; //   var centerX:Number = 0; var centerY:Number = 0; //   var polygonSquare:Number = 0; // for (i=0; i<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">triangles.length;</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span><span class="hljs-tag">++) { </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">triangle</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">triangles[i];</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">centerX</span></span></span><span class="hljs-tag"> += </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">triangle.center.x*triangle.square;</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">centerY</span></span></span><span class="hljs-tag"> += </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">triangle.center.y*triangle.square;</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">polygonSquare</span></span></span><span class="hljs-tag"> += </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">triangle.square;</span></span></span><span class="hljs-tag"> } </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">centerX</span></span></span><span class="hljs-tag"> /= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">polygonSquare;</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">centerY</span></span></span><span class="hljs-tag"> /= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">polygonSquare;</span></span></span></span></code> </pre><br><br><h5>  [F13] The position of the point relative to the polygon </h5><br>  The point is located inside the polygon in the event that this point is <b>‚Äúbelow‚Äù</b> with respect to all the edges when going around clockwise.  The position of the point relative to the line can be determined by the formula <b>F4</b> .  If a point lies <b>‚Äúabove‚Äù</b> with respect to all edges, then it lies outside the polygon. <br><br><h5>  [F14] The intersection of the infinite line and polygon </h5><br>  To determine the points of intersection of line <b>l</b> with polygon <b>P,</b> it is necessary to find all points of intersection of line <b>l</b> with all segments <b>e1, e2 ...</b> using the formula <b>[F7]</b> . <br><br><h1>  Determination of the similarity of figures </h1><br>  So what do we have at the entrance?  We have a source drawing - a <b>template</b> polygon, defined by a set of vertices v1, v2, ..., vn, and there is a <b>draw</b> polygon consisting of a set of points that we got in the process of drawing.  Before starting to compare them, the draw polygon must be ‚Äúbrought‚Äù to the polygon template.  Those.  It is necessary to apply a compression transformation (scale) and an offset (translate) so that the centers of the polygons coincide and the draw polygon has the most similar sizes of the bounding box with the template (bounds.width and bounds.height): <br><br><img src="http://habrastorage.org/getpro/habr/post_images/310/f12/4f3/310f124f394ea7c42577545359f66b76.jpg"><br><br>  Algorithm for reducing polygons: <br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/   var template = ... ; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   var draw = ... ; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    var scaleW:Number = template.bounds.width/draw</span></span>.bounds.width; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    var <span class="hljs-symbol"><span class="hljs-symbol">scaleH:</span></span>Number = template.bounds.height/draw.bounds.height; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    var <span class="hljs-symbol"><span class="hljs-symbol">scale:</span></span>Number = (scaleW+scaleH)/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    draw.matrixScale(scale); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/   X var dx:Number = draw.centerWeight.x-template.centerWeight.x; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   Y var dy:Number = draw.centerWeight.y-template.centerWeight.y; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    draw.matrixTranslate(dx, dy);</span></span></code> </pre><br>  Note that <b>centerWeight</b> is the center of mass of the polygon. <br><br>  To determine the similarity of the figures can be two algorithms, let's call them <a href="https://habr.com/ru/company/mailru/blog/190866/">Radial</a> and <a href="http://border/">Dimensional</a> .  Let's break them down. <br><br><a name="rads"></a><br><h2>  Radial algorithm </h2><br>  After you fit the drawn polygon to the template, we can start to compare them.  The essence of the radial method is as follows.  We let the ray out from the center and find the intersection points of this ray with the polygons.  Find the distance between the intersection points and memorize it.  Next, draw a new beam with a certain angle pitch, and also find the distance between the intersection points.  If we add the distances between the intersection points at the end, we will get some value.  The smaller this value, the closer the drawn figure to the pattern.  An example can be seen in the image: <br><br><img src="http://habrastorage.org/getpro/habr/post_images/1fe/631/81c/1fe63181cad27567f46db65d2de8ed03.jpg"><br><br>  The more rays are released, the more accurate the check will be.  You can also set the error, for example, how much the average length between the points of intersection of the beam with the polygons differs from the width / height (or the average arithmetic width and height) of the bounding rectangle of the polygon pattern.  You can check the algorithm in the <a href="">flash drive</a> <br><br><a name="border"></a><br><h2>  Overall algorithm </h2><br>  The overall algorithm is to specify two bounding polygons within which all points of the drawn polygon must be located.  Those.  It is necessary to create two clones of the template and apply a transformation of compression to them: to one to the smaller side, to the other - to the big one.  Next, we check all points that are inside a large polygon and outside a small one, after which we can determine the percentage of points that do not fall into this area.  The percentage threshold value can be the level of accuracy of the drawn figure. <br><br><img src="http://habrastorage.org/getpro/habr/post_images/1f1/008/c43/1f1008c43cf9ac077ad06c02ee641a4d.jpg"><br><br>  <b>UPD:</b> An example of a dimensional algorithm <a href="">here</a> . <br><br><h1>  Links </h1><br>  Libraries used for implementation in the ActionScript language: <a href="http://flashpress.ru/blog/libs/">FPGeometry2d.swc</a> and <a href="http://flashpress.ru/blog/libs/">FPGeomControl.swc</a> . </div><p>Source: <a href="https://habr.com/ru/post/190866/">https://habr.com/ru/post/190866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../190852/index.html">ROSA Media Player in Ubuntu. We collect from source codes</a></li>
<li><a href="../190854/index.html">LG Optimus L5 II Dual review: budget smartphone with a number of strange features</a></li>
<li><a href="../190858/index.html">UIAppearance. Manage the appearance of iOS applications</a></li>
<li><a href="../190860/index.html">Introduction to topology (for teapots and humanities scholars)</a></li>
<li><a href="../190862/index.html">Life outside Zion</a></li>
<li><a href="../190868/index.html">PhpBB integration in the Yii framework</a></li>
<li><a href="../190870/index.html">Script for checking the availability of free dates at the embassy</a></li>
<li><a href="../190872/index.html">Pseudolemmatization, composites and other strange words</a></li>
<li><a href="../190874/index.html">As I continued to make my amusement park</a></li>
<li><a href="../190876/index.html">Optimize SQL insertion speed on Android devices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>