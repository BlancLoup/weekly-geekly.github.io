<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Harmonic vibrations</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√© there were several articles on the Fourier transform and about all sorts of beautiful Digital Signal Processing (DSP) types, but an inexperie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Harmonic vibrations</h1><div class="post__text post__text-html js-mediator-article">  On Habr√© there were several articles on the Fourier transform and about all sorts of beautiful Digital Signal Processing (DSP) types, but an inexperienced user is completely unclear why all this is needed and where, and most importantly, how to apply it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/812/914/5a2/8129145a20640e7703e36189297a3260.png"><br>  <b>Frequency response noise.</b> <br><br>  Personally, after reading these articles (for example, <a href="http://habrahabr.ru/post/196374/">this one</a> ) I didn‚Äôt understand what it was and why it was needed in real life, although it was interesting and beautiful. <br>  It would be desirable not just to look at beautiful pictures, but to say so, to feel in your gut, what and how it works.  And I will give a concrete example with the generation and processing of sound files.  It will be possible to listen to the sound and look at its spectrum, and understand why this is so. <br>  The article will not be of interest to those who own the theory of functions of a complex variable, DSP, and other terrible topics.  It is more likely for the curious, schoolchildren, students and their sympathizers :). <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Immediately make a reservation, I am not a mathematician, and I can even say many things incorrectly (correct with a personal message), and I am writing this article based on my own experience and my own understanding of current processes.  If you are ready, then go. <br><br><h4>  A few words about the materiel </h4><br><br>  If we recall a school course in mathematics, then we used a circle to build a sine graph.  In general, it turns out that the rotational motion can be turned into a sinusoid (like any harmonic oscillation).  The best illustration of this process is given in <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B0%25D1%2580%25D0%25BC%25D0%25BE%25D0%25BD%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BB%25D0%25B5%25D0%25B1%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">wikipedia.</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/949/8e5/55b/9498e555bd4585643a4aed476f11ca64.gif"><br>  <b>Harmonic vibrations</b> <br><br>  Those.  in fact, the sine plot is obtained from the rotation of the vector, which is described by the formula: <br><br> <code>f(x) = A sin (œât + œÜ),</code> <br> <br>  where A is the vector length (amplitude of oscillations), œÜ is the initial angle (phase) of the vector at time zero, œâ is the angular velocity of rotation, which is equal to: <br><br>  œâ = 2 œÄf, where f is the frequency in Hertz. <br><br>  As we can see, knowing the signal frequency, amplitude and angle, we can build a harmonic signal. <br><br>  Magic begins when it turns out that the representation of absolutely any signal can be represented as a sum (often infinite) of various sinusoids.  In other words, in the form of a Fourier series. <br>  I will give an example from the English <a href="http://en.wikipedia.org/wiki/Fourier_series">Wikipedia</a> .  For example, take a ramp. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/01f/e61/6f3/01fe616f313bc136c291de9f8f82edb7.gif"><br>  <b>Ramp</b> <br><br>  Its sum will be represented by the following formula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/729/ada/16f/729ada16fa189be498408ad44594b90c.png"><br><br>  If we successively sum up, take n = 1 first, then n = 2, etc., we will see how our harmonic sinusoidal signal gradually turns into a saw: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed5/9c6/e39/ed59c6e39488a266811b11722ee5ec62.gif"><br><br>  Probably the most beautiful thing is illustrated by one program I found in the open spaces of the network.  It was already mentioned above that the sine graph is a projection of a rotating vector, but what about more complex signals?  This, oddly enough, the projection of a set of rotating vectors, or rather their sum, and it looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/906/edc/181/906edc181a89e93c5bade1f5c4b3a5e4.gif"><br>  <b>Vectors draw a saw.</b> <br><br>  In general, I recommend to go by the <a href="http://bl.ocks.org/jinroh/7524988">link</a> and try to play with the parameters, and see how the signal changes.  IMHO more visual toys for understanding, I have not yet met. <br><br>  It should also be noted that there is an inverse procedure that allows to obtain from this signal the frequency, amplitude and initial phase (angle), which is called the Fourier Transform. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2d/e08/0e4/f2de080e480ec3c5ed696c3a9db2a107.png"><br>  <b>Fourier series decomposition of some known periodic functions ( <a href="http://ets.ifmo.ru/osipov/os1/2_1.htm">from here</a> )</b> <br><br>  I will not dwell on it in detail, but I will show how this can be applied in life.  In the list of references I will recommend something where you can read more about the materiel. <br><br><h4>  We turn to practical exercises! </h4><br><br>  It seems to me that each student wonders, sitting at a lecture, for example, on matan: why do I need all this nonsense?  And as a rule, not finding an answer in the foreseeable future, unfortunately, loses interest in the subject.  Therefore, I will immediately show the practical application of this knowledge, and you will already master this knowledge yourself :). <br><br>  All further I will implement on it.  I did everything, of course, under Linux, but I didn‚Äôt use any specifics; in theory, the program will compile and work under other platforms. <br><br>  To begin with we will write the program for formation of the sound file.  Wav file was taken as the easiest.  Read about its structure <a href="http://audiocoding.ru/%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D1%258C%25D0%25B8/%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0-wav-%25D1%2584%25D0%25B0%25D0%25B9%25D0%25BB%25D0%25B0.html">here</a> . <br>  In short, the structure of the wav file is described as follows: the header, which describes the file format, and then (in our case) an array of 16-bit data (pointed) length: sampling frequency * t seconds or 44100 * t pieces. <br><br>  An example was taken <a href="http://karplus4arduino.wordpress.com/2011/10/08/making-wav-files-from-c-programs/">here</a> to generate a sound file.  I modified it a bit, corrected the errors, and the final version with my edits now lies on the github here <br><br>  <a href="https://github.com/dlinyj/generate_wav">github.com/dlinyj/generate_wav</a> <br><br>  We will generate a two-second sound file with a pure sine with a frequency of 100 Hz.  To do this, modify the program as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> S_RATE (44100) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  #define BUF_SIZE (S_RATE*10) /* 2 second buffer */ ‚Ä¶. int main(int argc, char * argv[]) { ... float amplitude = 32000; //    float freq_Hz = 100; //  /* fill buffer with a sine wave */ for (i=0; i&lt;BUF_SIZE; i++) { buffer[i] +=(int)(amplitude * sin((float)(2*M_PI*i*freq_Hz/S_RATE))); } write_wav("test.wav", BUF_SIZE, buffer, S_RATE); return 0; }</span></span></span></span></code> </pre><br><br>  I pay attention that the formula of pure sine corresponds to that about which we spoke above.  The amplitude of 32,000 (it was possible to take 32767) corresponds to a value that can take a 16-bit number (from minus 32767 to plus 32767). <br><br>  As a result, we get the following <a href="http://yadi.sk/d/QEJTYmbeMRmmJ">file</a> (you can even listen to it with any sound reproducing program).  Open this audacity file and see that the signal graph actually corresponds to the pure sine: <br><br><img src="http://img-fotki.yandex.ru/get/9262/74270808.1c/0_bd381_7c4cf696_XL.png"><br>  <b>Pure tube sinus</b> <br><br>  Let's look at the spectrum of this sine (Analysis-&gt; Plot spectrum) <br><br><img src="http://img-fotki.yandex.ru/get/9930/74270808.1c/0_bd453_5fde6601_XL.png"><br>  <b>Spectrum spectrum</b> <br><br>  A clear peak is seen at 100 Hz (logarithmic scale).  What is a spectrum?  This is the amplitude-frequency response.  There is also a phase response characteristic.  If you remember, I said above that to build a signal you need to know its frequency, amplitude and phase?  So, you can get these parameters from the signal.  In this case, we have a graph of frequency amplitude correspondences, with what the amplitude is not in real units, but in decibels. <br><br><img src="http://img-fotki.yandex.ru/get/9796/74270808.1c/0_bd454_4a982213_S.png"><br><br>  The value, expressed in <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D1%2586%25D0%25B8%25D0%25B1%25D0%25B5%25D0%25BB">decibels</a> , is numerically equal to the decimal logarithm of the dimensionless ratio of a physical quantity to a physical quantity of the same name, taken as the original, multiplied by ten. <br><br>  In this case, simply the amplitude logarithm multiplied by 10. It is convenient to use the logarithmic scale when working with signals. <br><br>  I honestly don‚Äôt really like the spectrum analyzer in this program, so I decided to write my own <s>with blackjack and whores</s> , especially since it‚Äôs not hard. <br><br><h4>  We write your spectrum analyzer </h4><br><br>  <i>It can be boring here, so you can go directly to the next chapter.</i> <br><br>  Since I understand perfectly well that it makes no sense to place code wrappers here, those who are really interested in - will find and dig up themselves, and those who are not interested will be bored, I will focus only on the main points of writing a spectrum analyzer wav-file. <br><br>  First, we need to read the wav file.  There it is necessary to read the header in order to understand what the file contains.  I did not realize the sea of ‚Äã‚Äãoptions for reading this file, and stopped at only one.  An example of reading a file was taken <a href="http://yannesposito.com/Scratch/en/blog/2010-10-14-Fun-with-wav/">from here with</a> almost no changes, IMHO is a great example.  There is also a python implementation. <br><br>  The next thing we need is a fast Fourier transform.  This is the same transformation that allows you to get a <u>vector of</u> original signals from a finite set of points.  Let it not scare you yet, then I will explain. <br>  Again, the bike did not reinvent, and took a ready-made example <a href="http://grinkov.blogspot.ru/2011/11/blog-post_29.html">from here</a> . <br><br>  I understand that in order to explain how the program works, it is necessary to explain what the fast Fourier transform is, and this is at least for another non-acidic article. <br><br>  To begin with, let's arrays arrays: <br><br><pre> <code class="cpp hljs"> c = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(size_array*<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//    in = calloc(size_array*2, sizeof(float)); //  out = calloc(size_array*2, sizeof(float)); // </span></span></code> </pre><br><br>  Let me just say that in the program we read the data into an array of length size_array (which we take from the header of the wav file). <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( fread(&amp;value,<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(value),<span class="hljs-number"><span class="hljs-number">1</span></span>,wav) ) { in[j]=(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)value; j+=<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>*size_array) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br><br>  The array for the fast Fourier transform should be a sequence {re [0], im [0], re [1], im [1], ... re [fft_size-1], im [fft_size-1]}, where fft_size = 1 &lt;&lt; p is the number of FFT points.  I explain in normal language: <br>  This is an array of complex numbers.  I‚Äôm even afraid to imagine where the complex Fourier transform is used, but in our case the imaginary part is zero and the real part is equal to the value of each point of the array. <br>  Another feature of the fast Fourier transform is that it cheats arrays that are multiples of powers of two only.  As a result, we must calculate the minimum power of two: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p2=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(log2(header.bytes_in_data/header.bytes_by_capture));</code> </pre><br><br>  The logarithm of the number of bytes in the data, divided by the number of bytes at one point. <br><br>  After that, we consider the turning factors: <br><br><pre> <code class="cpp hljs">fft_make(p2,c);<span class="hljs-comment"><span class="hljs-comment">//       (   ,     ).</span></span></code> </pre><br><br>  And we feed our read array into a Fourier transducer: <br><br><pre> <code class="cpp hljs">fft_calc(p2, c, in, out, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//( ,     ).</span></span></code> </pre><br><br>  At the output we get complex numbers of the form {re [0], im [0], re [1], im [1], ... re [fft_size-1], im [fft_size-1]}.  For those who do not know what a complex number is, I will explain.  It was not for nothing that I started this article with a heap of rotating vectors and a heap of gifs.  So, the vector on the complex plane is determined by the real coordinate a1 and imaginary coordinate a2.  Or the length (this is the amplitude Am) and the Psi angle (phase). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/659/ddc/355/659ddc355195a48c5492b63a56c70b3b.jpg"><br>  <b>Vector on the complex plane</b> <br><br>  Please note that size_array = 2 ^ p2.  The first point of the array corresponds to the frequency of 0 Hz (constant), the last point corresponds to the sampling frequency, namely 44100 Hz.  As a result, we must calculate the frequency corresponding to each point, which will differ by the delta frequency: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta=((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)header.frequency)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)size_array; <span class="hljs-comment"><span class="hljs-comment">//    .</span></span></code> </pre><br><br>  Block an array of amplitudes: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> * ampl; ampl = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(size_array*<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>));</code> </pre><br><br>  And look at the picture: the amplitude is the length of the vector.  And we have its projections on the real and imaginary axis.  As a result, we will have a right triangle, and here we recall the Pythagorean theorem, and consider the length of each vector, and immediately write it into a text file: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;(size_array);i+=<span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(logfile,<span class="hljs-string"><span class="hljs-string">"%.6f %f\n"</span></span>,cur_freq, (<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(out[i]*out[i]+out[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]*out[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]))); cur_freq+=delta; }</code> </pre><br>  As a result, we obtain a file of the following form: <br><br><pre> <code class="bash hljs">‚Ä¶ 11.439514 10.943008 11.607742 56.649738 11.775970 15.652428 11.944199 21.872342 12.112427 30.635371 12.280655 30.329171 12.448883 11.932371 12.617111 20.777617 ...</code> </pre><br><br>  The final version of the program lives on a githaba here: <br>  <a href="https://github.com/dlinyj/fft">github.com/dlinyj/fft</a> <br><br><h4>  We try! </h4><br><br>  Now we feed the resulting program that sine sound file. <br><br><pre> <code class="bash hljs">./fft_an ../generate_wav/sin\ 100\ Hz.wav format: 16 bits, PCM uncompressed, channel 1, freq 44100, 88200 bytes per sec, 2 bytes by capture, 2 bits per sample, 882000 bytes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data chunk=441000 log2=18 size array=262144 wav format Max Freq = 99.928 , amp =7216.136</code> </pre><br><br>  And we get a text file response.  We build his schedule with the help of a nest <br><br>  Script to build: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#! /usr/bin/gnuplot -persist set terminal postscript eps enhanced color solid set output "result.ps" #set terminal png size 800, 600 #set output "result.png" set grid xtics ytics set log xy set xlabel "Freq, Hz" set ylabel "Amp, dB" set xrange [1:22050] #set yrange [0.00001:100000] plot "test.txt" using 1:2 title "AFC" with lines linestyle 1</span></span></code> </pre><br><br>  Pay attention to the restriction in the script on the number of points in X: set xrange [1: 22050].  The sampling frequency is 44100, and if we recall Kotelnikov's theorem, the signal frequency cannot be higher than half the sampling frequency, therefore the signal above 22050 Hz does not interest us.  Why so, I advise you to read in the special literature. <br>  So (drum roll), run the script and see: <br><br><img src="http://img-fotki.yandex.ru/get/9931/74270808.1c/0_bd382_40deab88_XL.png"><br>  <b>Our signal spectrum</b> <br><br>  Note the sharp peak at 100 Hz.  Do not forget that the axes - the logarithmic scale!  The wool on the right, I think, is the Fourier transform error (windows come to mind here). <br><br><h4>  And let's pamper? </h4><br><br>  And let's  Let's look at the spectra of other signals! <br><br><h5>  Around the noise ... </h5><br>  To begin with, let's build a noise spectrum.  The topic of noise, random signals, etc.  worthy of a separate course.  But we touch it slightly.  We modify our program for generating a wav file, add one procedure: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">d_random</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> min, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> max)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min + (max - min) / RAND_MAX * rand(); }</code> </pre><br><br>  it will generate a random number in the specified range.  As a result, main will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> amplitude = <span class="hljs-number"><span class="hljs-number">32000</span></span>; srand((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)time(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//    for (i=0; i&lt;BUF_SIZE; i++) { buffer[i] +=(int)amplitude*d_random(-1.0, 1.0); //nois } write_wav("test.wav", BUF_SIZE, buffer, S_RATE); return 0; }</span></span></code> </pre><br><br>  Generate a <a href="http://yadi.sk/d/TInX4aPDMSMS4">file</a> (I recommend for listening).  Let's look at it in audacity. <br><br><img src="http://img-fotki.yandex.ru/get/9094/74270808.1c/0_bd37f_37995293_XL.png"><br>  <b>Signal in audacity</b> <br><br>  Let's look at the spectrum in the program audacity. <br><br><img src="http://img-fotki.yandex.ru/get/9094/74270808.1c/0_bd37e_b6833709_XL.png"><br>  <b>Spectrum</b> <br><br>  And let's see the spectrum using our program: <br><br><img src="http://img-fotki.yandex.ru/get/9094/74270808.1c/0_bd380_e7d4df12_XL.png"><br>  <b>Our range</b> <br><br>  I want to draw attention to a very interesting fact and a feature of noise - it contains the spectra of all harmonics.  As can be seen from the graph, the spectrum is quite even.  <a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B5%25D0%25BB%25D1%258B%25D0%25B9_%25D1%2588%25D1%2583%25D0%25BC">White noise</a> is usually used for frequency analysis of bandwidth, for example, audio equipment.  There are other types of noise: <i>pink, blue and others</i> .  Homework - find out how they differ. <br><br><h5>  And compote? </h5><br><br>  And now let's see another interesting signal - the meander.  There I gave a label above the decomposition of various signals into the Fourier series, you look at how the meander unfolds, write down on a piece of paper, and we will continue. <br><br>  To generate a meander with a frequency of 25 Hz, we modify our wav-file generator once again: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> meandr_value=<span class="hljs-number"><span class="hljs-number">32767</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* fill buffer with a sine wave */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;BUF_SIZE; i++) { <span class="hljs-comment"><span class="hljs-comment">//meandr if (!(i%(S_RATE/((int)freq_Hz/2)))) { if (meandr_value==32767) { meandr_value=-32767; } else { meandr_value=32767; } } buffer[i]=meandr_value; } write_wav("test.wav", BUF_SIZE, buffer, S_RATE); return 0; }</span></span></code> </pre><br><br>  As a result, we get a sound <a href="http://yadi.sk/d/0jbliiRAMSMnN">file</a> (again, I advise you to listen), which you should immediately see in audacity <br><br><img src="http://img-fotki.yandex.ru/get/9795/74270808.1c/0_bd456_c9422f06_XL.png"><br>  <b>His majesty is a meander or a meander of a healthy person</b> <br><br>  We will not languish and look at its spectrum: <br><br><img src="http://img-fotki.yandex.ru/get/9094/74270808.1c/0_bd37d_d572f4c9_XL.png"><br>  <b>Spectrum of meander</b> <br><br>  So far, it‚Äôs not very clear what it is ... And let's see the first few harmonics: <br><br><img src="http://img-fotki.yandex.ru/get/9094/74270808.1c/0_bd37c_18db457f_XL.png"><br>  <b>First harmonics</b> <br><br>  It is quite another matter!  Well, let's see the tablet.  Look, we only have 1, 3, 5, etc., i.e.  odd harmonics.  We just see that we have the first harmonic of 25 Hz, the next (third) 75 Hz, then 125 Hz, etc., while the amplitude gradually decreases.  The theory has come together with practice! <br>  And now attention!  In real life, the meander signal has an infinite amount of harmonics of higher and higher frequency, but as a rule, real electrical circuits cannot pass frequencies higher than a certain frequency (due to inductance and capacitance of the tracks).  As a result, you can often see the following signal on the oscilloscope screen: <br><br><img src="http://img-fotki.yandex.ru/get/9304/74270808.1c/0_bd459_1b7c7f60_XL.jpg"><br>  <b>Meander smoker</b> <br><br>  This picture is just like a picture from <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D1%258F%25D0%25B4_%25D0%25A4%25D1%2583%25D1%2580%25D1%258C%25D0%25B5">Wikipedia</a> , where not all frequencies are taken as an example of a meander, but only the first few. <br><br><img src="http://upload.wikimedia.org/wikipedia/commons/3/38/%D0%A0%D1%8F%D0%B4_%D0%A4%D1%83%D1%80%D1%8C%D0%B5.gif"><br>  <b>The sum of the first harmonics, and how the signal changes</b> <br><br>  The meander is also actively used in radio engineering (I must say that it is the basis of all digital technology), and it should be understood that with long circuits it can be filtered out so that the native mother does not recognize.  It is also used to check the frequency response of various devices.  Another interesting fact is that jammers of televisions worked precisely according to the principle of higher harmonics, when the microcircuit itself generated a square wave of tens of MHz, and its higher harmonics could have frequencies of hundreds of MHz, just at the frequency of the television, and the higher harmonics successfully jammed the television's broadcast signal. <br><br>  In general, the theme of such experiments is endless, and you can now continue it yourself. <br><br><h4>  Recommendations for reading </h4><br><br><img src="http://img-fotki.yandex.ru/get/9823/74270808.1c/0_bd455_813d628f_XL.png"><br>  <b>Book</b> <br><br>  For those who do not understand what we are doing here, or vice versa, for those who understand, but want to understand even better, as well as for students studying DSP, I highly recommend this book.  This is the DSP for dummies, which is the author of this post.  There accessible even for the child language tells the most complex concepts. <br><br><h4>  Conclusion </h4><br><br>  In conclusion, I want to say that mathematics is the queen of sciences, but without real use, many people lose interest in it.  I hope this post will spur you to the study of such a wonderful subject as signal processing, and in general analog circuitry (plug your ears so that your brains do not flow!).  :) <br>  Good luck! </div><p>Source: <a href="https://habr.com/ru/post/219337/">https://habr.com/ru/post/219337/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../219327/index.html">VSDCT on OpenGL ES 3</a></li>
<li><a href="../219329/index.html">Yii 2.0 beta</a></li>
<li><a href="../219331/index.html">DARPA turns obsolete drones into flying Wi-Fi access points</a></li>
<li><a href="../219333/index.html">Approximation of the curve in the boom trajectory for the game St.Val</a></li>
<li><a href="../219335/index.html">What else does Heartbleed threaten a simple user with?</a></li>
<li><a href="../219339/index.html">Building Global Innovators or do you need 1 million euros?</a></li>
<li><a href="../219341/index.html">In the new build COLT 2.0 (beta 6), extended autocomplete for Angular.js projects appeared - inside {{}} for Sublime Text (2 and 3)</a></li>
<li><a href="../219349/index.html">Micro 3D printer priced at $ 299 collected on Kickstarter more than 2,000,000 dollars in a few days</a></li>
<li><a href="../219351/index.html">7 little things raising sales in our online store</a></li>
<li><a href="../219355/index.html">Newton's MIPS module - Intel's Edison competitor for use in wearable computers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>