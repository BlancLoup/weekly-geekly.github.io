<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Programming language o42a</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I do not like programming. I need a result. 

 It is clear that any ‚Äúresult‚Äù in programming is intermediate. It is followed by maintenance, error corr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Programming language o42a</h1><div class="post__text post__text-html js-mediator-article">  I do not like programming.  I need a result. <br><br>  It is clear that any ‚Äúresult‚Äù in programming is intermediate.  It is followed by maintenance, error correction, development, and, therefore, work with already written code.  Therefore, the result includes not only a working program, but also its source code, the maintenance of which will be the more expensive the less it is suitable for it, or, simply, the more it is connected in this code. <br><br>  But the main thing is to make it work.  And the sooner - the better. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All that separates the idea from the result is programming, the essence of which is the presentation of thoughts, the logic of solving the set task - in a representation available for machine processing. <br><br>  So here.  Modern programming languages ‚Äã‚Äãinterfere with expressing thoughts, burdening with a lot of details that are not relevant to the problem being solved, and are required only in order for the translator of the language to ‚Äúget it‚Äù.  And it's not even about syntax, although many, especially compiled, languages ‚Äã‚Äãare too verbose.  This, above all, is about linguistic entities, which are the ‚Äúterms‚Äù in which they should be expressed.  These entities ‚Äî for example, functions, variables, classes, methods, packages, namespaces, generalizations, patterns ‚Äî are too narrow, specialized, designed more for machine representation than for human understanding.  They force to translate thoughts into their language.  It is not difficult, of course.  But this is absolutely not relevant to the problem being solved.  The selection of suitable linguistic entities and the translation of them distract from the task, reduce concentration and, consequently, reduce the efficiency of development.  And, I suspect, in a substantial way.  Understanding the essence in the process of reading such code is even more difficult, which also does not have the best effect on labor productivity, especially during team development. <br><br>  The problem with modern programming languages ‚Äã‚Äãis that they force the programmer to adapt to the machine or the theories on which they are based, instead of adapting themselves to the programmer.  And the fact that mathematical theories are strict, iron is iron, and the convenience of a programmer is subjective, does not mean that one should not even try. <br><br>  The main idea of ‚Äã‚Äão42a is to automate the work of a programmer.  And this is achieved by a radical reduction of the types of linguistic entities to the only one that can <u>directly</u> replace them all.  The task of effective machine representation of such an entity falls entirely on the compiler. <br><br><a name="habracut"></a><h4>  Idea </h4><br>  I must say at once: such an entity should not be something like a Swiss knife, useless in its universality.  But this is not a primitive brick to build anything from such bricks (like lists in Lisp). <br><br>  In different programming paradigms there are many entities that would seem incompatible with each other.  So how do you achieve their symbiosis? <br><br>  The idea many years ago suggested to me the Prologue.  In addition to the magic of the predicate calculus, there is one more striking feature in it: looking at the predicate record, you can see that at the same time it is a record of the usual function.  You can consider this way and that, the essence does not change. <br><br>  I wanted to apply this idea as much as possible.  Wouldn't that different concepts from different programming paradigms have much more in common than it seems?  The main thing in this business is less dogmatism. <br><br>  The second idea of ‚Äã‚Äão42a is the possibility of separating language semantics and syntax.  Syntax does not have to correspond one-to-one with linguistic entities, however universal they may be.  Syntax should express the semantics of a program, not a programming language.  It should be convenient for perception and rather strict.  It is the task of the compiler, and not the programmer, to bring the text of the program to language entities. <br><br>  You can match the syntax with the representation, and software entities with the model from the <abbr title="Model-view-controller">MVC</abbr> paradigm.  And you can call it <abbr title="Domain-specific language">DSL</abbr> . <br><br>  Here I will begin description with syntax.  I suppose that its least significant features will cause the greatest rejection. <br><br><h4>  Basics of syntax </h4><br>  I decided that the best syntax invented by mankind is written speech.  So the closer the language syntax is to written language (English, of course, according to the tradition that has developed in programming), the better.  In the end, the expression "readability of the code" predisposes to this choice, because written speech was created to be readable, and it was taught to read from childhood. <br><br>  There are no keywords in o42a.  For all that is needed, icons are used.  At first glance, this may seem like a terrible decision.  However, it is necessary to take into account that there is only one entity in the language, and there are not too many syntactic constructions in which it participates.  So that icons are not required much. <br><br><h5>  Names </h5><br>  Names in o42a are case-insensitive and consist of words, Latin numbers and hyphens, separated from each other by spaces: <br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Hello</span></span> World Links <span class="hljs-number"><span class="hljs-number">2</span></span>- <span class="hljs-number"><span class="hljs-number">3</span></span>- <span class="hljs-number"><span class="hljs-number">4</span></span> -<span class="hljs-number"><span class="hljs-number">90</span></span></code> </pre> <br>  Letters in words are any letters of a unicode.  Multiple spaces in a row mean the same as one space.  Spaces do not have to be between letters and non-letters, numbers and non-numbers.  A name must not begin with a digit or a hyphen and must not end with a hyphen.  Hyphens must be single.  The space before the hyphen is prohibited in order to distinguish it from the subtraction sign. <br>  So the names above can be written differently: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Hello</span></span> world links2-<span class="hljs-number"><span class="hljs-number">3</span></span>-<span class="hljs-number"><span class="hljs-number">4</span></span> -<span class="hljs-number"><span class="hljs-number">90</span></span> </code> </pre><br><h5>  Comments </h5><br>  Comments in o42a are also unusual.  Tildes are used as separators.  And they are used for both lowercase and block comments. <br><br>  A line comment begins with two or more tildes: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">a</span></span> + b ~<span class="hljs-regexp"><span class="hljs-regexp">~ The</span></span> sum</code> </pre><br>  A line comment ends at the end of the line, or with two or more tildes: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">a</span></span> +~~~plus~~<span class="hljs-regexp"><span class="hljs-regexp">~ b</span></span></code> </pre><br>  A block comment begins and ends with a horizontal line of three or more tildes.  No characters other than whitespace should be on the same line as the line: <br><pre> <code class="hljs vhdl">~~~~~~~~~~~~~~~~~~~~~~~~~~ Copyright (C) <span class="hljs-number"><span class="hljs-number">2012</span></span> This <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> part <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> o42a. ~~~~~~~~~~~~~~~~~~~~~~~~~~</code> </pre><br>  For documentation purposes, it is intended to use Markdown. <br><br><h5>  Line breaks and underscore </h5><br>  The statements in o42a are combined into <em>sentences</em> and can be separated by different punctuation marks: commas, periods, commas, exclamation marks, or question marks.  Each of these signs has its own purpose.  But I will tell about it later.  It is important that the punctuation mark at the end of the line is optional - then a point is assumed.  It is necessary to transfer expressions or prescriptions to the next line explicitly, using an underscore: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Sum</span></span> = _left operand + _right operand</code> </pre><br>  The underscore can be placed at the end of the previous one or at the beginning of the next line. <br><br>  Also, the underscore character must be used to separate names, since the names themselves may contain spaces: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Print</span></span> <span class="hljs-literal"><span class="hljs-literal">error</span></span> _nl ~<span class="hljs-regexp"><span class="hljs-regexp">~ </span></span>    <span class="hljs-string"><span class="hljs-string">"\n"</span></span> ~<span class="hljs-regexp"><span class="hljs-regexp">~ </span></span>     (stderr  C).</code> </pre><br><h5>  Other </h5><br>  Decimal numbers: <br><pre> <code class="hljs">1 234 567</code> </pre><br>  There are no literals for real numbers or for hexadecimal notation in the language.  However, this is not a problem, since there are phrases (more about them later): <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-string"><span class="hljs-string">'3,141 592 653 59'</span></span></code> </pre><br>  The strings are ‚Äúglued together‚Äù as in C: <br><pre> <code class="hljs 1c"><span class="hljs-string"><span class="hljs-string">"abc"</span></span> <span class="hljs-string"><span class="hljs-string">"def"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">~~  ,  </span></span>: <span class="hljs-string"><span class="hljs-string">"abcdef"</span></span></code> </pre><br>  Shielding is normal, using a backslash.  Unicode code points are always recorded in hexadecimal form and escaped in a special way: <br><pre> <code class="hljs tex">"<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">t</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span></span>42a<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">'</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">r</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span>"</code> </pre><br>  There is support for multi-line text.  Escaping in multiline text does not work: <br><pre> <code class="hljs python"><span class="hljs-string"><span class="hljs-string">""""""</span></span>    <span class="hljs-string"><span class="hljs-string">""""""</span></span></code> </pre><br><h4>  Objects </h4><br>  The object is the main essence of o42a. <br><br>  An object is created by inheriting from another object.  This is the only way to create objects. <br><br>  All objects are directly or indirectly inherited from the <code>Void</code> object - the only object that is not inherited from anyone. <br><br><h5>  Fields and inheritance </h5><br>  An object may have fields.  A field is an nested named object. <br><br>  Here is an example of a field declaration: <br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span> := <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ( Field := <span class="hljs-string"><span class="hljs-string">"Value"</span></span> ~~ <span class="hljs-string"><span class="hljs-string">`Field`</span></span> -    <span class="hljs-string"><span class="hljs-string">`Object`</span></span>   <span class="hljs-string"><span class="hljs-string">`String`</span></span>. )</code> </pre><br>  By default, fields have a public scope.  But you can declare them internal (private) and protected (protected). <br><br>  Any expression in o42a either refers to an existing object, or creates a new one.  There are no other expressions.  Thus, absolutely any expression in o42a is an object reference.  A string literal is a reference to an object inherited from a standard <code>String</code> object.  Number - respectively from <code>Integer</code> . <br><br>  You can access the field of the object with a colon: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>: field</code> </pre><br>  Any object can be inherited.  When an object is inherited, all its fields are also inherited.  In this case, the fields can be overloaded: <br><pre> <code class="hljs pgsql">Derived <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> := <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ( ~~ `Derived <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>`   `<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>`. Field = "New value" ~~  `Field` . )</code> </pre><br>  To overload a field, use the <code>=</code> sign instead of <code>:=</code> . <br><br>  However, in an inheritance object, you can declare a field with the exact same name as in the inherited one: <br><pre> <code class="hljs scala"><span class="hljs-type"><span class="hljs-type">Another</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span></span>:= <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> (</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Field</span></span></span></span><span class="hljs-class"><span class="hljs-params"> := 123 ~~        `</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Field</span></span></span></span><span class="hljs-class"><span class="hljs-params">`. </span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  In this case, the new object will have two fields with the same name.  You can refer to them as follows: <br><pre> <code class="hljs scala"><span class="hljs-type"><span class="hljs-type">Another</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span></span>: field ~~ <span class="hljs-number"><span class="hljs-number">123</span></span> <span class="hljs-type"><span class="hljs-type">Another</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span></span>: field <span class="hljs-meta"><span class="hljs-meta">@object</span></span> ~~ <span class="hljs-string"><span class="hljs-string">"Value"</span></span> <span class="hljs-type"><span class="hljs-type">Another</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span></span>: field <span class="hljs-meta"><span class="hljs-meta">@another</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">~~</span></span></span><span class="hljs-class"> 123</span></span></code> </pre><br><h5>  Prototypes and abstract fields </h5><br>  As it is not difficult to see, objects replace classes.  Indeed, why do we need classes at all if objects have complete information about their own structure?  Only one application remains: when it is necessary to define a (abstract) program interface and several different implementations of it. <br><br>  For these purposes, you can use prototypes: <br><pre> <code class="hljs go">Interface :=&gt; void ( ~~~ .     <span class="hljs-string"><span class="hljs-string">`:=&gt;`</span></span>. ~~~ Name :=&lt; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ~~~  .     <span class="hljs-string"><span class="hljs-string">`:=&lt;`</span></span>. ~~~ )</code> </pre><br>  The difference between prototypes and ordinary objects is that their contents (fields for example) cannot be accessed.  The following code will result in an error: <br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">Interface</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> ~~ : `<span class="hljs-keyword"><span class="hljs-keyword">Interface</span></span>` -  .</code> </pre><br>  But the prototype can be inherited, like any other object.  This is, in fact, the only thing for which it is needed. <br><br>  In addition, the prototype may contain abstract fields.  Such fields must be overloaded with inheritance: <br><pre> <code class="hljs go">Implementation <span class="hljs-number"><span class="hljs-number">1</span></span> := <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> ( Name = <span class="hljs-string"><span class="hljs-string">"Implementation 1"</span></span> Implementation <span class="hljs-number"><span class="hljs-number">1</span></span>-specific field := <span class="hljs-number"><span class="hljs-number">1</span></span> ) Implementation <span class="hljs-number"><span class="hljs-number">2</span></span> := <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> ( Name = <span class="hljs-string"><span class="hljs-string">"Implementation 2"</span></span> Implementation <span class="hljs-number"><span class="hljs-number">2</span></span>-specific field := <span class="hljs-number"><span class="hljs-number">2</span></span> )</code> </pre><br>  According to its purpose, the prototype is a normal class.  In contrast, a regular object in o42a is both a class and an instance of it. <br><br>  The latter should be familiar to Java programmers.  These are anonymous classes: <br><pre> <code class="java hljs">Runnable task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.err.println(<span class="hljs-string"><span class="hljs-string">"Done!"</span></span>); } }</code> </pre><br>  This expression creates both an anonymous class and its instance.  The difference of o42a is that the ‚Äúclasses‚Äù created in this way are not necessarily anonymous. <br><br><h5>  Object values </h5><br>  Every object has a value.  The type of this value is inherited from the ancestor object and cannot be changed unless it is <code>void</code> . <br><br>  There are several types of values ‚Äã‚Äãin o42a.  Each of them is represented by a standard object.  Here are a few simple types: <br><ul><li>  <code>Void</code> - null, the base type for all others. </li><li>  <code>Integer</code> is a 64-bit integer. </li><li>  <code>Float</code> is a 64-bit floating point number. </li><li>  <code>String</code> - a string of unicode characters. </li></ul><br>  There are also more complex types: for example, rows and arrays, connections and variables.  The type system will expand over time, as needed. <br><br>  The value of the object is not necessarily a constant.  It is calculated using the algorithm defined by the <em>definition</em> .  A value definition is a set of statements in the body of an object.  It can be quite complicated: with conditions, cycles, and everything.  But the actual value of the object is given by the <em>prescription (return) of the value of the</em> form: <br><pre> <code class="hljs cs">= <span class="hljs-keyword"><span class="hljs-keyword">value</span></span></code> </pre><br>  The following ads are equivalent: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> := <span class="hljs-number"><span class="hljs-number">5</span></span> ~~   ,  : <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> := <span class="hljs-type"><span class="hljs-type">integer</span></span> (= <span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre><br>  The definition of a value is inherited and may be overloaded. <br><br>  Here is an example of determining the sum of two numbers: <br><pre> <code class="hljs vbscript">Sum :=&gt; integer ( <span class="hljs-built_in"><span class="hljs-built_in">Left</span></span> operand :=&lt; integer <span class="hljs-built_in"><span class="hljs-built_in">Right</span></span> operand :=&lt; integer = <span class="hljs-built_in"><span class="hljs-built_in">Left</span></span> operand + <span class="hljs-built_in"><span class="hljs-built_in">right</span></span> operand )</code> </pre><br>  Note that the same definition can lead to different values: <br><pre> <code class="hljs vbscript">Sum (<span class="hljs-built_in"><span class="hljs-built_in">Left</span></span> operand = <span class="hljs-number"><span class="hljs-number">1.</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Right</span></span> operand = <span class="hljs-number"><span class="hljs-number">2</span></span>) ~~ <span class="hljs-number"><span class="hljs-number">3</span></span> Sum (<span class="hljs-built_in"><span class="hljs-built_in">Left</span></span> operand = <span class="hljs-number"><span class="hljs-number">-1.</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Right</span></span> opernad = <span class="hljs-number"><span class="hljs-number">10</span></span>) ~~ <span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre><br><h5>  Adapters and Samples </h5><br>  When creating an object, in addition to the ancestor, you can specify one or several samples by which the object will be created: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Object</span></span> := ancestor &amp; sample <span class="hljs-number"><span class="hljs-number">1</span></span> &amp; sample <span class="hljs-number"><span class="hljs-number">2</span></span> (~<span class="hljs-regexp"><span class="hljs-regexp">~ </span></span> ~~)</code> </pre><br>  In this case, the fields and definitions of the samples will be inherited by the new object, and the object itself will become compatible with the samples (in the sense <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25BF%25D0%25BE%25D0%25B4%25D1%2581%25D1%2582%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B8_%25D0%2591%25D0%25B0%25D1%2580%25D0%25B1%25D0%25B0%25D1%2580%25D1%258B_%25D0%259B%25D0%25B8%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B2">of the Barbara Liskov principle of substitution</a> ).  Possible conflicts of inheritance will be resolved in accordance with certain rules. <br><br>  Yes, this is multiple inheritance.  But is it always appropriate to use it?  In practice, inheritance (including multiple) is applied in one of three cases: <br><ol><li>  To indicate that an object is a variant of the object inherited by it, that is, instead of the ‚Äúthis‚Äù particle.  For example, "Watermelon is a berry." </li><li>  To give the object certain properties, for this purpose some languages ‚Äã‚Äãuse ‚Äúimpurities‚Äù (traits, mixins). </li><li>  To add an additional program interface to an object or to bring it to another type, in this case it is better to use composition. </li></ol><br>  Samples are convenient to use in the first two cases, and for the third in o42a there is a separate adapter mechanism. <br><br>  An adapter is a field of an object whose identifier is not a name, but another object: <br><pre> <code class="hljs go">Foo := void ( Value := <span class="hljs-number"><span class="hljs-number">123</span></span> @String := <span class="hljs-string"><span class="hljs-string">"Foo="</span></span> + value ~~ <span class="hljs-string"><span class="hljs-string">`String`</span></span>   <span class="hljs-string"><span class="hljs-string">`@`</span></span>  ~~   ,    . )</code> </pre><br>  The adapter object always inherits its object identifier.  When casting, o42a first checks if the object is inherited from the desired one, and then tries to use an adapter to it.  So here is this code: <br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">Print</span></span> [foo] nl</code> </pre><br>  Prints <code>Foo=123</code> , despite the fact that the <code>Print</code> parameter must be a string, and the <code>Foo</code> object from <code>String</code> not inherited.  The corresponding adapter will be passed as a parameter. <br><br>  Standard value types are converted to string and other types using adapters. <br><br>  The adapter can be accessed directly: <br><pre> <code class="hljs mel">Foo @@<span class="hljs-keyword"><span class="hljs-keyword">string</span></span></code> </pre><br>  And also you can refer to the fields of the adapter itself: <br><pre> <code class="hljs perl">Foo: <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> @string ~~ <span class="hljs-number"><span class="hljs-number">7</span></span></code> </pre><br>  Note that the syntax for referring to adapter fields is the same as for referring to fields of the object itself.  Is that an indication of the source field ( <code>@string</code> in this case) - necessarily. <br><br>  Adapters also apply in other cases.  For example, to designate the main object of the application: <br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">Use</span></span> namespace <span class="hljs-string"><span class="hljs-string">'Console'</span></span> ~~ <span class="hljs-string"><span class="hljs-string">`Print`</span></span>  <span class="hljs-string"><span class="hljs-string">`Main`</span></span>    <span class="hljs-string"><span class="hljs-string">`Console`</span></span>. @<span class="hljs-keyword"><span class="hljs-keyword">Main</span></span> := * { ~~  ,    <span class="hljs-string"><span class="hljs-string">`Main`</span></span>  . Print <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span> nl }</code> </pre><br>  The execution of the application will be addressed to the <code>@Main</code> adapter, which will print the famous text. <br><br>  Applications can come up with many.  You can, for example, use adapters to calculate the hash function of an arbitrary object.  It is enough to define the adapter <code>@Hash code</code> . <br><br>  Adapters allow you to add the desired functionality to any object.  This eliminates the need to have any fields in the base <code>Void</code> object.  In addition, it is type safe, unlike annotated or specially named methods of the form <code>__str__</code> . <br><br><h4>  Generalized programming </h4><br>  In o42a there are no usual templates (templates) or generalizations (generics) with their characteristic type parameters.  Each object in o42a is already a generalization, parameterized by its enclosing object and the adjacent fields. <br><br>  The fact is that the reference to an object is usually not static.  This means that if you inherit an object that contains such a link, then the inheriting object can receive another object using the same link. <br><br>  Here is an example: <br><pre> <code class="hljs go">Base := void ( A := void ( F := <span class="hljs-number"><span class="hljs-number">123</span></span> ~~ <span class="hljs-string"><span class="hljs-string">`Base: a`</span></span>   <span class="hljs-string"><span class="hljs-string">`F'. ) B := a ( ~~ `</span></span>Base: b<span class="hljs-string"><span class="hljs-string">`   `</span></span>Base: a<span class="hljs-string"><span class="hljs-string">`.  = 456 ) ) Object := base ( ~~  `</span></span>Base<span class="hljs-string"><span class="hljs-string">`. A = * ( ~~  `</span></span>A<span class="hljs-string"><span class="hljs-string">`. G := f * 10 ~~   `</span></span>A: g<span class="hljs-string"><span class="hljs-string">`. ) ) Object: a: g ~~ 1230 Object: b: g ~~ 4560</span></span></code> </pre><br>  Notice that the <code>Object: a: g</code> field was already defined after <code>Base: b</code> .  However, the expression <code>Object: b: g</code> absolutely correct. <br><br>  The fact is that objects inherit not just other objects, but expressions that reference them.  Being executed in another context such an expression may resolve to another object and, therefore, lead to a slightly different inheritance hierarchy.  It is important that in whatever context the expression is not resolved, the resulting object is always compatible with the original one, that is, it is either he himself or his heir. <br><br>  Such functionality will not completely replace traditional generalizations, but in many cases will eliminate the need for them.  For more complex cases, the macro mechanism is provided in o42a (also original, but how else?).  But I will not talk about macros and metaprogramming possibilities in this article. <br><br><h4>  Summarizing the above </h4><br>  In o42a there is still a lot about which I have not told: <br><ul><li>  on how to build sentences, </li><li>  about imperative programming support, </li><li>  about phrases - exclusively syntactic way of constructing object-oriented expressions (no lambda calculus!) </li><li>  about operator overloading (operators are also phrases, by the way), </li><li>  about complex data types, including variables and relationships, </li><li>  about macros and directives - metaprogramming mechanisms involved during compilation, </li><li>  about the modules and tree structure of the source code of the application. </li></ul><br>  And, of course, I omitted many details.  This is material for future articles. <br><br>  However, the purpose of this article was to introduce you to the plan and its implementation.  I hope I explained everything clearly. <br><br>  So, the main and only semantic unit of a language is an object that can replace a great deal with itself: <br><ul><li>  <b>Object is a namespace</b> <br>  There is nothing special to comment on: the object's fields are symbols in this space. <br></li><li>  <b>Object is a class</b> <br>  Also described above.  Classes are not needed if you directly inherit objects. <br></li><li>  <b>Object is a function</b> (and method at the same time) <br>  The arguments of such a function are the fields of the object, and the result is its value. <br>  Object inheritance is a function call, field overloading is a parameter substitution (currying). <br>  But the object can more.  After all, it can be inherited again, and the fields can be reloaded again (re ... curry?). <br></li><li>  <b>The object is a generalization.</b> <br>  Yes, peculiar.  However, the possibilities are even greater. <br>  A generic object has the same advantage over traditional generics or patterns as a function object over ordinary functions: the parameter fields can be overloaded again and again.  Try a java generic or C ++ template instance to replace an already substituted type parameter.  And sometimes you really want not to produce unnecessary abstract classes. <br></li></ul><br><h4>  Redundancy and normalization </h4><br>  You have to pay for everything.  And the price of the ‚Äúeverything is an object‚Äù approach is high. <br><br>  Simplest expression <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">a</span></span> + b</code> </pre>  where <code>a</code> and <code>b</code> are integers that just need to be folded, it turns out to be a jumble of objects: <br><pre> <code class="hljs vbscript">Integers: add ( <span class="hljs-built_in"><span class="hljs-built_in">Left</span></span> operand = a <span class="hljs-built_in"><span class="hljs-built_in">Right</span></span> operand = b )</code> </pre>  that need to be constructed (inherited by overloading fields), only to request their values. <br><br>  However, there is nothing unexpected in this.  It was immediately clear that the discrepancy between machine representation and human understanding would lead to a serious redundancy of this same machine representation.  Unless, of course, implement it "in the forehead."  But do not do that. <br><br>  Redundancy can and should be eliminated.  This process is called normalization.  Thanks to him, the example above will be compiled in addition of two numbers.  After all, if a person understands that this is just an addition, then the compiler can be taught this. <br><br>  Normalization techniques are rather non-trivial.  And the implementation of these techniques is in the initial stage.  However, in such simple cases, everything works.  This can be verified by compiling, for example, the test set o42a with enabled and disabled normalization ( <code>o42ac -normalize=0</code> ).  The sizes of executable files will differ by four. <br><br>  And this is what the Hello, World! Program looks like in LLVM IR: <br><div class="spoiler">  <b class="spoiler_title">hello_world.ll</b> <div class="spoiler_text"><pre> <code class="hljs java">; ModuleID = <span class="hljs-string"><span class="hljs-string">'hello_world'</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"Ep:64:64:64-S0-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f16:16:16-f32:32:32-f64:64:64-f128:128:128-v64:64:64-v128:128:128-a0:0:64"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-pc-linux-gnu"</span></span> %o42a_val_t = type { i32, i32, i64 } <span class="hljs-meta"><span class="hljs-meta">@CONST</span></span>.STRING.1 = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> constant %o42a_val_t { i32 <span class="hljs-number"><span class="hljs-number">6145</span></span>, i32 <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-function"><span class="hljs-function">i64 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptrtoint</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">13</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x i8]* @DATA.STRING</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> to i64)</span></span></span><span class="hljs-function"> } @CONST.STRING.2 </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> constant %o42a_val_t { i32 <span class="hljs-number"><span class="hljs-number">1</span></span>, i32 <span class="hljs-number"><span class="hljs-number">1</span></span>, i64 <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-meta"><span class="hljs-meta">@DATA</span></span>.STRING.0 = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span> define i32 <span class="hljs-meta"><span class="hljs-meta">@main</span></span>(i32, i8*) nounwind { main: call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-meta"><span class="hljs-meta">@o</span></span>42a_init() nounwind call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-meta"><span class="hljs-meta">@o</span></span>42a_io_print_str(%o42a_val_t* <span class="hljs-meta"><span class="hljs-meta">@CONST</span></span>.STRING.1) nounwind call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-meta"><span class="hljs-meta">@o</span></span>42a_io_print_str(%o42a_val_t* <span class="hljs-meta"><span class="hljs-meta">@CONST</span></span>.STRING.2) nounwind ret i32 <span class="hljs-number"><span class="hljs-number">0</span></span> } declare <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-meta"><span class="hljs-meta">@o</span></span>42a_init() declare <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-meta"><span class="hljs-meta">@o</span></span>42a_io_print_str(%o42a_val_t*)</code> </pre><br>  Agree, there is almost no excess.  And not a single complex structure like an object.  But the program involved several. <br></div></div><br>  The name ‚Äúnormalization‚Äù was chosen intentionally.  Unlike "optimization", based on not always suitable heuristics and often incorrect assumptions, normalization implies a predictable result, achieved in accordance with the principle of minimal redundancy.  And the strict semantics of the language, limiting the number of linguistic entities - a serious help in the implementation of techniques and rules of normalization.  If more mathematical theory to bring this matter ... <br><br>  The essence of normalization is that the compiler, instead of generating executable code in accordance with the original designs, tries to find out: how a particular object is used in the program and, in accordance with this knowledge, first simplify the universal "object" to the minimum redundant performing entity (constant, block of executable code, function or pointer to one of several functions, structure ...) and generate executable code for it. <br><br>  If you think about it, then normalization fundamentally changes the program development process.  If you now have to think through software interfaces in advance, make decisions about whether something will be implemented as a class, a function, its parameter or something else, then the normalizing compiler will make such decisions on its own, based on an already written program, knowing exactly how another entity is <em>actually used</em> and <em>should</em> not <em>be used</em> .  From the point of view of the normalizing compiler, architectural decisions about software interfaces, made in advance, based on assumptions are nothing more than a premature optimization. <br><br>  But besides the normalization, one more thing has been implemented: <br><ul><li>  During compilation everything is calculated that is possible.  And this is not an optimization, but the main functionality.  Without it, the language would have to be made interpretable. </li><li>  Everything that is not used is thrown out of the program: for example, unnecessary objects, as well as unused fields in the necessary objects.  This functionality is quite expected, so I do not refer it to normalization. </li></ul><br><h4>  State and prospects </h4><br>  Project o42a has been implemented by one person on a full-time basis for the past three and a half years.  So you must understand that I take this job seriously. <br><br>  The project has never been thought of as an academic one, and its goal is to create a pragmatic general-purpose programming language, as well as a platform for it.  I came up with the first ideas a long time ago, when I was still a student, but I began to create a language with many years of experience in developing new projects and supporting old projects.  So the very idea of ‚Äã‚Äãthe language, all decisions on it, as well as the actual implementation, are the fruits of practical experience, and not abstract theories. <br><br>  The development of the project is at the implementation stage of the prototype.  The compiler is written in Java and uses LLVM to generate executable code.  Source codes <a href="https://bitbucket.org/o42a/o42a/">are available</a> under the GPLv3 + license (runtime libraries - under LGPLv3 +).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The project has a website with documentation in rather bad English, as well as a forum, which is still empty (I don‚Äôt provide direct links for understandable reasons). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The current version o42a-0.2.4 contains over </font></font><a href="https://www.ohloh.net/p/o42a"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">130 thousand lines of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> source code. The compiler is still quite fragile, and the libraries are almost absent. The target platform is GNU / Linux x86_64, others have not been tested. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the coming months, I plan to implement a collection library as well as an input / output library. At the same time I will debug the compiler, resolve the remaining questions on the language itself, and also write examples with the Rosetta Code. It is assumed that version 0.3.0 can already be used somehow.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With future prospects, everything is rather vague. At the beginning, I didn‚Äôt assume that the development would take so much time, but now I can well imagine the scope of work. For one person it is a lot, and the savings, which I lived in recent years, are exhausted. So if the development does not take a serious office ‚Äúunder the wing‚Äù, then it will slow down, since I will have to return to freelance, to my native oDesk. I don‚Äôt plan to ask for donations. Somehow it is not serious: you will not collect decent money, but you will be obliged.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If anyone has a serious desire to do such an ambitious project - please contact us. </font><font style="vertical-align: inherit;">Though I am a simple programmer, I can come up with ideas for monetizing this monster. </font><font style="vertical-align: inherit;">Only you need to take into account that this is not a web two-zero-price-10k-want-milen start-up. </font><font style="vertical-align: inherit;">These are serious, long-term investments, including serious marketing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there is a desire to work for free for the benefit of Open Source in general and the o42a project in particular, then I will have tasks, including a task not directly related to o42a and useful as an independent project (the required library on pure C). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have thoughts on how to finance the development, please share it.</font></font></div><p>Source: <a href="https://habr.com/ru/post/157329/">https://habr.com/ru/post/157329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../157317/index.html">Systematization of commits</a></li>
<li><a href="../157319/index.html">Torrentmonitor</a></li>
<li><a href="../157321/index.html">Barcode turned 60 years old</a></li>
<li><a href="../157325/index.html">Ministry of Economic Development is going to fight torrents</a></li>
<li><a href="../157327/index.html">Apple failed to defend iPhone trademark rights in Mexico</a></li>
<li><a href="../157331/index.html">What's wrong with windows 8</a></li>
<li><a href="../157333/index.html">Speech Recognition on Bash</a></li>
<li><a href="../157335/index.html">Continuous Delivery PHP Applications</a></li>
<li><a href="../157337/index.html">WPF: 4 options buttons with icon and text</a></li>
<li><a href="../157341/index.html">Build client-side javascript templates</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>