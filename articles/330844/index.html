<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write a simple driver under Windows to lock USB devices.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is unlikely that a user of a home PC will be interested in blocking devices on his PC. But when it comes to the corporate environment, everything b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write a simple driver under Windows to lock USB devices.</h1><div class="post__text post__text-html js-mediator-article">  It is unlikely that a user of a home PC will be interested in blocking devices on his PC.  But when it comes to the corporate environment, everything becomes different.  There are users who can be trusted in absolutely everything, there are those who can delegate something, and there are those who cannot be trusted at all.  For example, you blocked access to the Internet to one of the users, but did not block the devices of this PC.  In this case, the user simply enough to bring a USB-modem, and he will have the Internet.  Those.  it is not limited to simply blocking access to the Internet. <br><br>  Once about this task and stood in front of me.  There was no time to search for any solutions on the Internet, and they, as a rule, are not free.  Therefore, it was easier for me to write such a driver, and its implementation took me one day. <br><br>  In this article I will tell a little theoretical part, on the basis of which everything is built, and I will tell the principle of the decision itself. <br><a name="habracut"></a><br>  Also, complete source codes can be found in the USBLock folder of the git repository at: <a href="">https://github.com/anatolymik/samples.git</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  DRIVER_OBJECT structure </h2><br>  For each loaded driver, the system forms the DRIVER_OBJECT structure.  The system actively uses this structure when it monitors the state of the driver.  The driver is also responsible for its initialization, in particular for initializing the MajorFunction array.  This array contains the addresses of handlers for all requests for which the driver can respond.  Therefore, when the system sends a request to the driver, it will use this array to determine which function of the driver is responsible for the specific request.  Below is an example of initialization of this structure. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ULONG i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= IRP_MJ_MAXIMUM_FUNCTION; i++ ) { DriverObject-&gt;MajorFunction[i] = DispatchCommon; } DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = DispatchCreate; DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = DispatchClose; DriverObject-&gt;MajorFunction[IRP_MJ_READ] = DispatchRead; DriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = DispatchWrite; DriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = DispatchCleanup; DriverObject-&gt;MajorFunction[IRP_MJ_PNP] = DispatchPnp; DriverObject-&gt;DriverUnload = DriverUnload; DriverObject-&gt;DriverExtension-&gt;AddDevice = DispatchAddDevice;</code> </pre> <br>  Such initialization is usually performed when the system calls the driver entry point, the prototype of which is shown below. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DriverEntry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath )</span></span></span></span>;</code> </pre> <br>  As you can see from the example, first the entire MajorFunction array is initialized with the same handler.  In reality, there are more query types than in the example.  Therefore, the entire array is first initialized so that requests that are not supported by the driver are processed correctly.  For example, completed with an error.  After array initialization, handlers are usually initialized for those requests for which the driver is responsible. <br><br>  It also initializes the DriverUnload field of the structure, which contains the address of the handler responsible for terminating the driver.  This field can be left non-initialized, in which case the driver becomes non-paged. <br><br>  Please note that in the DriverExtension-&gt; AddDevice field, the address of the handler is set, which is called whenever the system detects a new device for which the driver is responsible.  This field may be left uninitialized, in which case the driver will not be able to handle this event. <br><br>  This structure is described in more detail at: <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff544174(v%3Dvs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/hardware/ff544174(v=vs.85).aspx</a> . <br><br><h2>  DEVICE_OBJECT structure </h2><br>  The DEVICE_OBJECT structure represents a particular driver functionality.  Those.  This structure can represent a physical device, a logical device, a virtual device, or just some functionality provided by the driver.  Therefore, when the system sends requests, it will indicate the address of this structure in the request itself.  Thus, the driver will be able to determine which functionality is requested from it.  If you do not use such a model, then the driver can only process any one functionality, but in the modern world this is unacceptable.  A prototype of the function that processes a particular request is shown below. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PDEVICE_OBJECT DeviceObject, PIRP Irp )</span></span></span></span>;</code> </pre> <br>  The MajorFunction array of the previously mentioned DRIVER_OBJECT structure contains the addresses of the handlers with this prototype. <br><br>  The DEVICE_OBJECT structure itself is always created by the driver using the IoCreateDevice function.  If the system sends a request to the driver, then it always sends it to some DEVICE_OBJECT, as it follows from the above-presented prototype.  Also, the prototype takes the second parameter, which contains the address of the IRP structure.  This structure describes the request itself, and it exists in memory until the driver completes it.  The request is sent to the driver for processing using the IoCallDriver function both by the system and by other drivers. <br><br>  A name may also be associated with the DEVICE_OBJECT structure.  Thus, this DEVICE_OBJECT can be found in the system. <br><br>  The DEVICE_OBJECT structure is described in more detail at: <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff543147(v%3Dvs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/hardware/ff543147(v=vs.85).aspx</a> .  And the IRP structure is described at: <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff550694(v%3Dvs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/hardware/ff550694(v=vs.85).aspx</a> . <br><br><h2>  Filtration </h2><br>  Filtering is a mechanism that allows you to intercept all requests directed to a specific DEVICE_OBJECT.  To install such a filter, you need to create another instance of DEVICE_OBJECT and attach it to DEVICE_OBJECT, whose requests should be intercepted.  Attaching the filter is done through the IoAttachDeviceToDeviceStack function.  All DEVICE_OBJECT attached to the intercepted DEVICE_OBJECT, together with it form the so-called device stack, as shown below. <br><br><div style="text-align:center;"> <a href=""><img width="500" hspace="5" src="https://habrastorage.org/web/79f/282/626/79f282626a98443a913fb240535e0a65.png"></a> </div><br>  The arrow shows the promotion request.  First, the request will be processed by the top DEVICE_OBJECT driver, then the medium driver, and eventually the target DEVICE_OBJECT driver will receive control over the processing of the request.  Also, the lower DEVICE_OBJECT is called the bottom of the stack, since  it is not attached to anyone. <br><br>  The presence of such a mechanism allows you to add functionality that is not initially in the drivers.  For example, in this way, without modifying the FAT file system shipped in Windows, you can add file access permissions to this file system. <br><br><h2>  Pnp manager </h2><br>  The PnP manager is responsible for scheduling devices throughout the system.  Its tasks include discovering devices, collecting information about them, loading their drivers, calling these drivers, managing hardware resources, starting and stopping devices, and deleting them. <br><br>  When a driver of a bus detects devices on its interfaces, it creates a DEVICE_OBJECT for each child device.  This DEVICE_OBJECT is also called a Physical Device Object or PDO.  Then, using the IoInvalidateDeviceRelations function, it notifies the PnP manager that there have been changes on the bus.  In response, the PnP manager sends a request with the minor code IRP_MN_QUERY_DEVICE_RELATIONS to request a list of child devices.  In response to this request, the bus driver returns a list of PDOs.  Below is an example of such a situation. <br><br><div style="text-align:center;"> <a href=""><img width="500" hspace="5" src="https://habrastorage.org/web/130/1df/892/1301df8928404e65bd6ca75c6ee9624f.png"></a> </div><br>  As shown in the figure, in this example, the USB hub driver acts as a bus.  The specific DEVICE_OBJECT device stack of this hub is not shown for brevity and to preserve the sequence of explanations. <br><br>  As soon as the PnP manager receives a list of all PDOs, it will separately collect all the necessary information about these devices.  For example, a request will be sent with the minor code IRP_MN_QUERY_ID.  Through this request, the PnP manager will obtain device identifiers, both hardware and compatible.  Also, the PnP manager will collect all the necessary information about the required hardware resources by the device itself.  And so on. <br><br>  After all the necessary information has been collected, the PnP manager will create a so-called DevNode, which will reflect the state of the device.  Also, PnP will create a registry branch for a specific device instance or open an existing one if the device was previously connected to a PC. <br><br>  The next PnP task is to start the device driver.  If the driver has not been previously installed, then PnP will wait for the installation.  Otherwise, if necessary, PnP will load it and transfer control to it.  It was previously mentioned that the DriverExtension-&gt; AddDevice field of the DRIVER_OBJECT structure contains the address of the handler that is called whenever the system detects a new device.  The prototype of this handler is shown below. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DispatchAddDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT PhysicalDeviceObject )</span></span></span></span>;</code> </pre> <br>  Those.  whenever a PnP detects a device that a particular driver is controlling, a registered handler for that driver is called, where it is passed a pointer to the PDO.  Information about the installed driver is also stored in the corresponding registry branch. <br><br>  The task of the handler is to create a DEVICE_OBJECT and attach it to the PDO.  Attached DEVICE_OBJECT is also called Functional Device Object or FDO.  It is this FDO that will be responsible for the operation of the device and the presentation of its interfaces in the system.  Below is an example of when PnP has finished calling the driver responsible for the operation of the device. <br><br><div style="text-align:center;"> <a href=""><img width="500" hspace="5" src="https://habrastorage.org/web/541/355/635/5413556350184be190f05a49f12b5167.png"></a> </div><br>  As reflected in the example, in addition to the device driver itself, lower and upper device class filters can also be registered.  Consequently, if any, PnP will also load their drivers and call their AddDevice handlers.  Those.  The order of calling the drivers is as follows: first, the registered lower filters are loaded and called, then the device driver is loaded and called, and in the end, the upper filters are loaded and called.  The lower and upper filters are the usual DEVICE_OBJECT, which create drivers and attach them to the PDO in their AddDevice handlers.  The number of lower and upper filters is not limited. <br><br>  At this point, the device stacks are fully formed and ready to go.  Therefore, PnP sends a request with the minor code IRP_MN_START_DEVICE.  In response to this request, all device stack drivers must prepare the device for operation.  And if there are no problems in this process, then the request is completed successfully.  Otherwise, if any of the drivers cannot start the device, then it completes the request with an error.  Therefore, the device will not start. <br><br>  Also, when the bus driver determines that changes have occurred on the bus, it notifies PnP using the IoInvalidateDeviceRelations function that it should reassemble information about the connected devices.  At this point, the driver does not delete the previously created PDO.  Just when receiving a request with a minor code IRP_MN_QUERY_DEVICE_RELATIONS, he will not include this PDO in the list.  Then, based on the received list, PnP identifies new devices and devices that have been disconnected from the bus.  The PDO of the disabled devices will be deleted by the driver when the PnP sends a request with the minor code IRP_MN_REMOVE_DEVICE.  For a driver, this request means that the device is not used by anyone else, and it can be safely removed. <br><br>  More information about the WDM driver model can be found at: <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff548158(v%3Dvs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/hardware/ff548158(v=vs.85).aspx</a> . <br><br><h2>  The essence of the decision </h2><br>  The essence of the solution itself is to create a top class USB bus filter.  Reserved classes can be found at: <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff553419(v%3Dvs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/hardware/ff553419(v=vs.85).aspx</a> .  We are interested in a USB class with a GUID of 36fc9e60-c465-11cf-8056-444553540000.  As MSDN says, this class is used for USB host controllers and hubs.  However, in practice this is not the case; the same class is used, for example, by flash-drives.  This adds a bit of work to us.  Handler code AddDevice is presented below. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UsbCreateAndAttachFilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PDEVICE_OBJECT PhysicalDeviceObject, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> UpperFilter )</span></span></span><span class="hljs-function"> </span></span>{ SUSBDevice* USBDevice; PDEVICE_OBJECT USBDeviceObject = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; ULONG Flags; NTSTATUS Status = STATUS_SUCCESS; PAGED_CODE(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ;; ) { <span class="hljs-comment"><span class="hljs-comment">//     ,      if ( !UpperFilter ) { USBDeviceObject = PhysicalDeviceObject; while ( USBDeviceObject-&gt;AttachedDevice ) { if ( USBDeviceObject-&gt;DriverObject == g_DriverObject ) { return STATUS_SUCCESS; } USBDeviceObject = USBDeviceObject-&gt;AttachedDevice; } } //   Status = IoCreateDevice( g_DriverObject, sizeof( SUSBDevice ), nullptr, PhysicalDeviceObject-&gt;DeviceType, PhysicalDeviceObject-&gt;Characteristics, false, &amp;USBDeviceObject ); if ( !NT_SUCCESS( Status ) ) { break; } //    ,      //   Flags = PhysicalDeviceObject-&gt;Flags &amp; (DO_BUFFERED_IO | DO_DIRECT_IO | DO_POWER_PAGABLE); USBDeviceObject-&gt;Flags |= Flags; //      USBDevice = (SUSBDevice*)USBDeviceObject-&gt;DeviceExtension; //   USBDevice-&gt;DeleteDevice = DetachAndDeleteDevice; //   for ( ULONG i = 0; i &lt;= IRP_MJ_MAXIMUM_FUNCTION; i++ ) { USBDevice-&gt;MajorFunction[i] = UsbDispatchCommon; } USBDevice-&gt;MajorFunction[IRP_MJ_PNP] = UsbDispatchPnp; USBDevice-&gt;MajorFunction[IRP_MJ_POWER] = UsbDispatchPower; //     IoInitializeRemoveLock( &amp;USBDevice-&gt;Lock, USBDEVICE_REMOVE_LOCK_TAG, 0, 0 ); //   USBDevice-&gt;SelfDevice = USBDeviceObject; USBDevice-&gt;BaseDevice = PhysicalDeviceObject; USBDevice-&gt;UpperFilter = UpperFilter; //  paging  USBDevice-&gt;PagingCount = 0; KeInitializeEvent( &amp;USBDevice-&gt;PagingLock, SynchronizationEvent, true ); //    PDO USBDevice-&gt;LowerDevice = IoAttachDeviceToDeviceStack( USBDeviceObject, PhysicalDeviceObject ); if ( !USBDevice-&gt;LowerDevice ) { Status = STATUS_NO_SUCH_DEVICE; break; } break; } //      if ( !NT_SUCCESS( Status ) ) { //  if ( USBDeviceObject ) { IoDeleteDevice( USBDeviceObject ); } } else { //     USBDeviceObject-&gt;Flags &amp;= ~DO_DEVICE_INITIALIZING; } return Status; } static NTSTATUS DispatchAddDevice( PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT PhysicalDeviceObject ) { UNREFERENCED_PARAMETER( DriverObject ); return UsbCreateAndAttachFilter( PhysicalDeviceObject, true ); }</span></span></code> </pre> <br>  As follows from the example, we create a DEVICE_OBJECT and attach it to the PDO.  Thus, we will intercept all requests directed to the USB-bus. <br><br>  Our task is to intercept requests with the minor code IRP_MN_START_DEVICE.  The handler code for this request is shown below. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UsbDispatchPnpStartDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( SUSBDevice* USBDevice, PIRP Irp )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HubOrComposite; NTSTATUS Status; PAGED_CODE(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ;; ) { <span class="hljs-comment"><span class="hljs-comment">// ,    ,   //   ,       Status = UsbIsDeviceAllowedToWork( &amp;HubOrComposite, USBDevice ); if ( !NT_SUCCESS( Status ) ) { break; } USBDevice-&gt;HubOrComposite = HubOrComposite; //   Status = ForwardIrpSynchronously( USBDevice-&gt;LowerDevice, Irp ); if ( !NT_SUCCESS( Status ) ) { break; } break; } //   Irp-&gt;IoStatus.Status = Status; IoCompleteRequest( Irp, IO_NO_INCREMENT ); //    IoReleaseRemoveLock( &amp;USBDevice-&gt;Lock, Irp ); return Status; }</span></span></code> </pre> <br>  As shown in the figure, the handler calls the UsbIsDeviceAllowedToWork function.  This function performs all necessary checks to determine if the device is allowed to operate.  First of all, the function allows you to always work hubs and composite devices, keyboards and mice.  As well as those devices that are on the allowed list.  If the function returns an unsuccessful return code, then the request fails.  Thus, the operation of the device will be blocked. <br><br>  Note: the function determines whether the device is a hub or a composite device.  This is necessary because, as already mentioned, the device class that is used for hubs and host controllers is not only used by these devices.  And we first need to control the child devices of only hubs, host controllers and composite devices.  Those.  for hubs and composite devices, the enumeration request for child devices is additionally intercepted, at this stage, it is also important to attach a filter to all child devices, and this filter will be lower.  Otherwise, control over the child devices will be lost. <br><br>  All the definitions mentioned are based on device identifiers. <br><br><h2>  Conclusion </h2><br>  Despite its simplicity in my case, this driver effectively solves the problem.  Although of the shortcomings should be made a mandatory reboot after the list of authorized devices will be updated.  To eliminate this drawback, the driver will need some complication.  Another major disadvantage is the complete blocking of the device, and not partial.  The description presented above does not disclose all implementation details.  This was done intentionally, and the emphasis was placed more on the concept itself.  Those who want to understand everything to the end can get acquainted with the source code. </div><p>Source: <a href="https://habr.com/ru/post/330844/">https://habr.com/ru/post/330844/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330834/index.html">Design as a world language of the 21st century</a></li>
<li><a href="../330836/index.html">Technology and non-IT: how and why S / 4HANA is used in wholesale</a></li>
<li><a href="../330838/index.html">Attention, Habrahabr: IBM opens free access to a large number of its resources</a></li>
<li><a href="../330840/index.html">SQL Server Integration Services (SSIS) for Beginners - Part 3</a></li>
<li><a href="../330842/index.html">Hacking Age of Mythology: Turning off the Fog of War</a></li>
<li><a href="../330846/index.html">May the Code Review with you</a></li>
<li><a href="../330848/index.html">Top 15 Free Unity Assets for a Beginner 2D Developer</a></li>
<li><a href="../330850/index.html">Microsoft at CodeFest 2017 - report, slides and video reports</a></li>
<li><a href="../330852/index.html">What is missing Gmail. 4 free deskun features</a></li>
<li><a href="../330854/index.html">Optimize memory usage in Xamarin applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>