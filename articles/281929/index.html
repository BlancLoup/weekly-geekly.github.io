<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The speed of dynamic RAM and the ridiculous idea how to increase it</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A bit of history 
 At the dawn of computing, dynamic memory worked quite well on the frequency of the processor. My first computer experience was rela...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The speed of dynamic RAM and the ridiculous idea how to increase it</h1><div class="post__text post__text-html js-mediator-article"><h4>  A bit of history </h4><br>  At the dawn of computing, dynamic memory worked quite well on the frequency of the processor.  My first computer experience was related to a clone of the ZX Spectrum computer.  The Z80 processor processed instructions on an average of 4 clocks per operation, with two clocks used to perform dynamic memory regeneration, which gives us, at a frequency of 3.5 MHz, no more than 875,000 operations per second. <br><br>  However, after some time, the frequency of the processors reached a level where the dynamic memory could no longer cope with the load.  To compensate for this, an intermediate link was introduced in the form of a cache memory, which made it possible to smooth out the difference in the speed of the processor and main memory using operations performed on a small amount of data. <br><br>  Let's look at what the computer's RAM is now, and what can be done with it to increase the speed of the computer system. <br><img src="https://habrastorage.org/files/8c7/120/c20/8c7120c204e4423b800cd4219e57f33a.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h4>  Briefly about static and dynamic memory </h4><br>  Memory is built in the form of a table consisting of rows and columns.  In each cell of the table there is an information bit (we are discussing semiconductor memory, however, many other implementations are built on the same principle).  Each such table is called a ‚Äúbank‚Äù.  In the chip / module can be placed several banks.  A set of memory modules is projected into the linear address space of the processor, depending on the capacity of individual elements. <br><br>  The static memory cell is built on the basis of a trigger, which is usually in one of the stable states ‚ÄúA‚Äù or ‚ÄúB‚Äù (A =! B).  The minimum number of transistors for a single cell is 6 pieces, while the complexity of tracing in the cells apparently does not allow making modules of static memory of 1 gig at the price of a regular module of 8 gig. <br><br>  The dynamic memory cell consists of one capacitor responsible for storing information and one transistor responsible for isolating the capacitor from the data bus.  In this case, not a hinged electrolyte is used as a capacitor, but a parasitic pn junction capacitance between the ‚Äúsubstrate‚Äù and the transistor electrode (especially for these purposes it is increased, they are usually tried to get rid of it).  The disadvantage of a capacitor is the leakage current (both in itself and in the key transistor) which is very difficult to get rid of, besides it increases with temperature, which leads to the probability of distortion of the stored information.  To maintain reliability, ‚Äúregeneration‚Äù is used in the dynamic memory, it consists in periodically updating the stored information at least a predetermined period during which the information retains a reliable value.  The typical regeneration period is 8 ms, while more often it is possible to update the information, less often it is not recommended. <br><br>  The rest of the principle of operation is identical and is as follows: <br><br>  - the initial sampling of a line of memory leads to access to all of its contents placed in the buffer line with which further work is going on, or multiplexing of reference to columns occurs (the old, slow approach); <br>  - the requested data is transmitted to the host device (usually the CPU), or the specified cells are modified during the write operation (there is a slight difference, for the static memory, direct modification of the cell of the selected row is possible, for the dynamic memory the buffer line is modified, and then write back the contents of the entire line in a special loop); <br>  - closing and changing a memory line is also different for different types of memory, for a static one there can be an instant line change if the data has not changed, for dynamic memory it is necessary to write the contents of the buffer line into place, and only then you can select another line. <br><br>  If at the dawn of computing, each read or write operation ended with a full memory cycle: <br><br>  - row selection; <br>  - read / write operation from the cell; <br>  - change / re-select line. <br><br>  Modern operation of working with chips "synchronous memory a la DDRX" is as follows: <br><br>  - row selection; <br>  - read / write operations of cells in a row in groups of 4-8 bits / words (multiple inversion within a single string is allowed); <br>  - closing a line with recording information into place; <br>  - change / re-select line. <br><br>  This solution allowed saving data access time when, after reading the value from cell ‚Äú1‚Äù, it is necessary to refer to cells ‚Äú2, 3, 4, or 7‚Äù located in the same line, or immediately after the read operation, it is necessary to write back the changed value . <br><br><h4>  Read more about the work of dynamic memory in conjunction with the cache </h4><br>  The memory controller (in the chipset or embedded in the processor) sets the block address and line number (most significant block address) to the chip / memory module.  The corresponding block is selected (further work will be considered within one block) and the resulting ‚Äúbinary number‚Äù is decoded into the positional address of the line, after which information is transferred to the buffer from which data is subsequently accessed.  The time in ticks required for this operation is called tRCD and is displayed in the "9-9-9 / 9-9-9-27" schemes in second place. <br><br>  After the row is activated, you can refer to the "columns" for this memory controller transmits the cell address in the row, and after a time "CL" (indicated in the above marked "xxxx" at 1 place), data starts to be transmitted from the memory chip into the processor (why in the plural? because the cache intervenes here) as a packet of 4-8 bits (for a single chip) in the cache line (size depends on the processor, the typical value is 64 bytes - 8 words 64 bits each, but and other meanings).  After a certain number of ticks required to transfer a data packet, you can form the following request to read data from other cells of the selected row, or issue a command to close the row which is expressed in the form of tRP specified as the third parameter from ‚Äúxxxx ... ".  During the closing of the line, the data from the buffer is written back to the block line, after the recording is finished, you can select another line in the block.  In addition to these three parameters, there is a minimum time during which the line should be active ‚ÄútRAS‚Äù, and the minimum time for a full cycle of working with the line separating two commands to activate the line (affects random access). <br><br><blockquote>  grossws April 19, 2016 at 12:40 <br><br>  CL - CAS latency, tRCD - RAS to CAS delay, tRP - row precharge, CAS - column address strobe, RAS - row address strobe. <br><br><blockquote> The speed of semiconductor technology is determined by the delays of the circuit elements.  In order to obtain reliable information at the output, it is necessary to wait a certain time in order for all elements to take a steady state.  Depending on the current state of the memory bank, the data access time changes, but in general, the following transitions can be characterized: <br><br>  If the block is at rest (there is no active line), the controller issues a row select command, as a result, the binary line number is converted to the positional number, and the contents of the line are read during the "tRCD" time. <br><br>  After the contents of the row have been read into the buffer zone, you can issue a command to select a column that converts the binary number of the column to a positional number during the ‚ÄúCL‚Äù, but depending on the alignment of the lower addresses, the order of transmission of bits may change. <br><br>  Before changing / closing a line, it is necessary to write data into place, because during the reading, the information was actually destroyed.  The time needed to restore information in the ‚ÄútRP‚Äù line. <br><br>  According to the full specification for dynamic memory, there are also many time parameters determining the sequence and delay of control signal changes.  One of these is ‚ÄútRCmin‚Äù which defines the minimum time for a complete cycle of a line, including: row selection, data access and writeback. <br><br>  The RAS signal determines whether a row address is issued; <br>  The CAS signal determines whether a column address is issued. <br><br>  If earlier all control was shifted to the side of the memory controller and controlled by these signals, now there is a command mode when a command is issued to the module / microchip, and after a while data is being transmitted.  For more details, see the standard specification, for example, <a href="http://www.softnology.biz/pdf/JESD79-4%2520DDR4%2520SDRAM.pdf">DDR4</a> . <br></blockquote><br><br>  If we talk about working with the dram in general, then when mass reading it usually looks like this: <br><br>  set the address of the string <br>  put up the RAS (and through the beat removed) <br>  waited tRCD, <br>  set the address of the column we are reading from (and every next clock set the next column number), <br>  exposed CAS, <br>  waited for CL, started reading the data, <br>  removed CAS, read the rest of the data (more CL cycles). <br><br>  When passing to the next row, precharge (RAS + WE) is done, tRP is waited, RAS is performed with the specified line address, and then it is read as described above. <br><br>  The random cell reading latency naturally follows from the above: tRP + tRCD + CL. <br><blockquote>  In fact, it depends on the previous state of the ‚Äúmemory bank‚Äù that is being accessed. </blockquote><br></blockquote><br><br>  It is necessary to remember that the DDR has two frequencies: <br><br>  - the main clock frequency determines the rate of transmission of commands and timings; <br>  - the effective frequency of data transmission (double the clock frequency, which marks the memory modules). <br><br><blockquote>  The integration of the memory controller has increased the speed of the memory subsystem by eliminating the intermediate transmitting link.  An increase in memory channels requires that this be taken into account by the application, for example, four-channel mode with a certain location of files does not give a performance boost (12 and 14 configurations). <br><br><img src="https://habrastorage.org/files/dda/795/55a/dda79555a138494497c07981f1c46a64.gif"><br>  Processing one element of a linked list with different steps (1 step = 16 bytes) <br></blockquote><br><br><h4>  Now a little math </h4><br>  Processor: processor operating frequencies now reach 5 GHz.  According to manufacturers, circuit solutions (pipelines, predictions and other tricks) allow you to perform one instruction per clock.  To round off the calculations we take the clock frequency value of 4 GHz, which will give us one operation in 0.25 ns. <br><br>  RAM: let's take for example the RAM of the new DDR4-2133 format with timings of 15-15-15. <br><br>  Given: <br><br>  CPU <br>  Ftakt = 4 GHz <br>  Tact = 0.25 ns (part-time execution of one operation "conditionally") <br><br>  DDR4-2133 RAM <br>  Fact = 1066 MHz <br>  Fdata = 2133 MHz <br>  ttakt = 0.94 ns <br>  tdata = 0.47 ns <br>  SPDmax = 2133 MHz * 64 = 17064 MB / s (data transfer rate) <br>  tRCmin = 50 ns (minimum time between two line activations) <br><br><h5>  Data acquisition time </h5><br>  From registers and cache, data can be provided during the operating cycle (registers, cache level 1) or with a delay of several processor cycles for the cache of the 2nd and 3rd level. <br><br>  For RAM, the situation is worse: <br><br>  - line selection time is: 15 clk * 0.94 ns = 14 ns <br>  - time to receive data from the column selection command: 15 clk * 0.94 ns = 14 ns <br>  - line closing time: 15 clk * 0.94 ns = 14 ns (who would have thought) <br><br>  From which it follows that the time between the command requesting data from the memory cell (if the cache is not included) may vary: <br><br>  14 ns - the data is in the already selected line; <br>  28 ns - data is in the unselected row, provided that the previous row is already closed (the block is in the ‚Äúidle‚Äù state); <br>  42-50 ns - the data is in a different line, while the current line needs to be closed. <br><br>  The number of operations that the processor can perform (above) during this time ranges from 56 (14 ns) to 200 (50 ns line feed).  Separately, it should be noted that by the time between the column selection command and the receipt of the entire data packet, the cache row loading delay is added: 8 bits of the packet * 0.47 ns = 3.76 ns.  For the situation when the data will be available to the ‚Äúprogram‚Äù only after the cache line is loaded (who knows what and how the processor developers wound up, the memory according to the specification allows to output the necessary data ahead), we get 15 more clock cycles. <br><br>  In the framework of one work, I conducted a study of the speed of memory, the results showed that it is possible to completely "utilize" memory bandwidth only in sequential memory access operations; in the case of random access, processing time increases (for example, a coherent list of 32-bit pointer and three double words, one of which is updated) from 4-10 (sequential access) to 60-120 ns (changing lines), which gives a difference in processing speed of 12-15 times. <br><br><h5>  Data processing speed </h5><br>  For the selected module, we have a peak bandwidth of 17064 MB / s.  That for a frequency of 4 GHz makes it possible to process 32-bit words per clock (17064 MB / 4000 MHz = 4.266 bytes per clock).  The following restrictions apply here: <br><br>  - without explicit planning of cache loading, the processor will be forced to idle (the higher the frequency, the larger the kernel just waits for data); <br>  - in the cycles ‚Äúreading modification record‚Äù the processing speed is halved; <br>  - multi-core processors will divide the memory bus bandwidth between the cores, and for the situation when there will be competing requests (a degenerate case), the memory performance may deteriorate ‚Äú200 times (changing lines) * X cores‚Äù. <br><br>  Calculate: <br><br>  17064 MB / s / 8 cores = 2133 MB / s per core in the optimal case. <br>  17064 MB / s / (8 cores * 200 missed operations) = 10 MB / s per core for the degenerate case. <br><br>  Translated into operations, we obtain for an 8-core processor: from 15 to 400 operations for processing a data byte, or from 60 to 1600 operations / cycles for processing a 32-bit word. <br><br>  In my opinion slowly somehow.  Compared with DDR3-1333 memory 9-9-9, where the full cycle time is approximately 50 ns, but the timings are different: <br><br>  - data access time is reduced to 13.5 ns (1.5 ns * 9 cycles); <br>  - the transmission time of a packet of eight words is 6 ns (0.75 * 8 instead of 3.75 ns) and with random access to memory, the difference in the data transfer rate almost disappears; <br>  - peak speed will be 10,664 MB / s. <br><br>  Not too far away.  The situation is somewhat saved by the presence in the memory modules of the ‚Äúbanks‚Äù.  Each ‚Äúbank‚Äù is a separate table of memory which can be accessed separately, which makes it possible to change a row in one bank while reading / writing data from another row, by reducing idle time, allows you to ‚Äúhammer‚Äù the data bus to the outset in optimized situations. <br><br><h4>  Actually there were ridiculous ideas </h4><br>  The memory table contains a specified number of columns, equal to 512, 1024, 2048 bits.  Taking into account the cycle time for activation of rows at 50 ns, we get the potential data exchange rate: ‚Äú1 / 0.00000005 s * 512 columns * 64 bits word = 81 920 MB / s‚Äù instead of the current 17 064 MB / s (163 840 and 327 680 MB / s for rows of 1024 and 2048 columns).  You will say: ‚Äúonly 5 times (4.8) faster‚Äù, to which I will answer: ‚Äúthis is the exchange rate when all competing requests are addressed to one memory bank, and the available bandwidth increases in proportion to the number of banks, and the row length of each table increases (it will require an increase in the length of the operating line), which in turn rests mainly on the speed of the data exchange bus. ‚Äù <br><br>  Changing the mode of data exchange will require the transfer of the entire contents of the line to the lower level cache, for which it is necessary to divide the cache levels not only by the speed of work, but also by the size of the cache line.  For example, by implementing the ‚Äúlength‚Äù of the Nth level cache line (3212 columns * 64 word size) 32,768 bits, we can, by reducing the number of comparison operations, increase the total number of cache lines and increase its maximum volume accordingly.  But if you make a parallel bus in a cache of this size, we can get a decrease in the frequency of operation, from which you can use a different approach to cache organization, if you divide the specified ‚ÄúJumbo‚Äù cache line into blocks along the top cache line and exchange it with small portions, allows you to save the frequency of operation, dividing the access delay into stages: search for a cache line, and selection of the desired "word" in the found string. <br><br>  As for the exchange between the cache and the main memory: it is necessary to transfer data with the rate of access to the rows of one bank, or having a certain margin to distribute requests to different banks.  In addition, there is a difficulty with the time of access to data located in different areas of the line, for serial transmission in addition to the initial delay associated with the sampling line, there is a data transmission delay depending on the amount of data "in the packet", and the transmission speed.  Even the ‚Äúrambus‚Äù approach may not cope with the increased load.  The situation can save the transition to the serial bus (possibly differential), by further reducing the bitness of the data, we can increase the channel throughput rate, I can reduce the time between the transfer of the first and last bit of data, apply a split line transfer to several channels.  That will allow you to use a lower clock frequency of one channel. <br><br>  Estimate the speed of this channel: <br><br>  1 / 0.00000005 ns = 20 MHz (the frequency of changing lines within one block) <br>  20 MHz * 32 768 bits = 655 360 Mbit / s <br>  For differential transmission with the same data bus size, we get: <br>  655 360 Mbit / s / 32 channels = 20 480 Mbit / s per channel. <br><br>  Such a speed looks acceptable for an electrical signal (10 Gbit / s for a signal with a built-in synchronization of 15 meters is available, why not mastering 20 Gbit / s with an external synchronization of 1 meter); however, a further increase in the transmission speed to reduce the transmission delay between The first and last bit of information may require an increase in bandwidth, with the possible integration of an optical transmission channel, but this is a question for circuitry, I have little experience with such frequencies. <br><br><h5>  and here Ostap suffered </h5><br>  Changing the concept of projecting the cache to main memory to use ‚Äúmain memory as an intermediate ultrafast block storage device‚Äù will shift the prediction of loading data from the controller circuitry to the processing algorithm (and who better to know where it will break after some time is clearly not the memory controller) turn will increase the cache size of the external level, without sacrificing performance. <br><br>  If you go further, you can additionally change the concept of orientation of the processor architecture from "switching the context of the actuator" to "the working environment of the program."  Such a change can significantly improve the security of a code through the definition of a program as a set of functions with specified entry points for individual procedures, an accessible region for placing data for processing, and the possibility of hardware monitoring the ability to call a function from other processes.  Such a change will also make it possible to more efficiently use multi-core processors by eliminating context switching for a part of the threads, and for processing events using a separate thread within the available ‚Äúprocess‚Äù environment, which will allow more efficient use of 100+ nuclear systems. <br><br>  PS: the accidental use of registered trademarks or patents is random.  All original ideas are available for use under the "anthill" license agreement. </div><p>Source: <a href="https://habr.com/ru/post/281929/">https://habr.com/ru/post/281929/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281913/index.html">M2M in 5 minutes with DeviceHive and Microsoft Azure. How to start your journey in IoT</a></li>
<li><a href="../281915/index.html">How to send an email using Python: a guide for dummies</a></li>
<li><a href="../281917/index.html">The story of my participation in the Ubuntu Scope Showdown 2016</a></li>
<li><a href="../281919/index.html">Osliki.Net - social delivery</a></li>
<li><a href="../281925/index.html">Bitrix gives knowledge - all #FailOverConf materials</a></li>
<li><a href="../281931/index.html">Electron, SASS, TypeScript, Pug (Jade), Polymer and a bit of flight cycling to create an application for Windows</a></li>
<li><a href="../281933/index.html">Flume - manage data streams. Part 2</a></li>
<li><a href="../281935/index.html">April 20 from 10 to 18 hours (MCK) Q & A on Windows Server, Windows 10 and Microsoft MVP Cloud and Microsoft employees</a></li>
<li><a href="../281937/index.html">Standard for managing access rights to corporate file information resources</a></li>
<li><a href="../281941/index.html">35 useful virtualization tools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>