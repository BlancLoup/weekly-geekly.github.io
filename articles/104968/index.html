<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsing the source code of programming languages ‚Äã‚Äãand markup languages</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="..it is true that you need to write an operating system .. 
 The latest versions of the Nemerle language include a library for parsing languages ‚Äã‚Äãwho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsing the source code of programming languages ‚Äã‚Äãand markup languages</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  ..it is true that you need to write an operating system .. </blockquote><br>  The latest versions of the Nemerle language include a library for parsing languages ‚Äã‚Äãwhose grammar belongs to the PEG class. <br><br><h4>  What is PEG? </h4><br>  Unlike other tools for creating parsers, PEG does not describe the grammar, but a strategy for parsing it, but in fact the description of the strategy of ruin is a description of the grammar.  For the parser described using PEG, there is an algorithm ( <a href="http://citeseerx.ist.psu.edu/viewdoc/summary%3Fdoi%3D10.1.1.19.1175">packrat</a> ) that parses any text that satisfies the grammar from this class, for a linear time from the length of the text. <br><br>  The class of languages ‚Äã‚Äãthat can be parsed using parsers described in a similar way is wide enough to cover popular programming languages ‚Äã‚Äã(for example, C #) and markup languages.  Obviously, it covers all the functionality of regular expressions. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Why do you need something when there RegExp? </h4><br>  Regular expression libraries are included in the set of standard libraries of almost any programming language.  Because of this walking distance, they are used where it is appropriate (parsing regular grammars), and where there is none (parsing html and other recursive structures). <br><br>  Quote from <a href="http://stackoverflow.com/questions/1732348">stackoverflow</a> : <br><blockquote>  ..it is true that you need to write an operating system .. </blockquote><br>  At the other extreme are parser generators, for example, yacc and antlr.  They cope with the task of generating parsers according to the provided grammar, but in practice it happens that it is ‚Äúeasier‚Äù for the programmer to write the parser itself than to use them.  The reason for this is most likely the complexity of working with these tools, as well as the fact that, unlike regular expressions that are eDSL, working with them requires code generation, and code generation is inconvenient. <br><br>  A macro is responsible for generating the parser by the PEG grammar in Nemerle.  Thus, code generation disappears and work with irregular grammars turns into work with eDSL: the accessibility of regular expressions is added to the power of parser generation.  Consider the example of working with PEG in Nemerle <br><br><h3>  Analysis of the mathematical markup of the language TeX </h3><br>  Consider the PEG grammar using the example of the TeX mathematical markup grammar.  We will analyze the source of this picture <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32f/1ab/ac3/32f1abac3a522170d7a3c545f51b944b.png" alt="image"></div><br>  Here he is <br><br><pre><code class="tex hljs"><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">int</span></span></span></span>_{-<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">frac</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{\pi}</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{2}</span></span></span></span>}^{<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">frac</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{\pi}</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{2}</span></span></span></span>} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cos</span></span></span></span> x <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">;</span></span></span></span> dx = 2</code> </pre> <br>  It can be seen that it consists of the commands (\ int, \ pi, \ cos), the escape sequence (\;), the nested bracket structure ({.. {..} ..}) and everything else. <br><br>  First of all, we define the structure in which this text will be dealt with: <br><br><pre> <code class="hljs pgsql"> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> variant WordTexAst { | Command { <span class="hljs-type"><span class="hljs-type">name</span></span> : string } //  | <span class="hljs-keyword"><span class="hljs-keyword">Escape</span></span> { symbol : string } // <span class="hljs-keyword"><span class="hljs-keyword">escape</span></span>  | <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> { data : WordTexAst.<span class="hljs-keyword"><span class="hljs-keyword">Sequence</span></span> } //    | Data { data : string } //   | <span class="hljs-keyword"><span class="hljs-keyword">Sequence</span></span> { words : list[WordTexAst]} }</code> </pre> <br>  I used variations, in other programming languages, they are also known as algebraic data types or labeled joins. <br><br>  In order to create a language parser, you need to declare a class, describe the strategy for parsing the language in the attribute of this class, and associate each function with a function that builds a tree from the parsed information.  Let's start with the attribute <br><br><pre> <code class="hljs pgsql"> [PegGrammar(ast, grammar { commandName = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>..<span class="hljs-string"><span class="hljs-string">'z'</span></span>,<span class="hljs-string"><span class="hljs-string">'A'</span></span>..<span class="hljs-string"><span class="hljs-string">'Z'</span></span>]+; escapeLetter = <span class="hljs-string"><span class="hljs-string">';'</span></span> / <span class="hljs-string"><span class="hljs-string">','</span></span>; letter = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>..<span class="hljs-string"><span class="hljs-string">'z'</span></span>,<span class="hljs-string"><span class="hljs-string">'A'</span></span>..<span class="hljs-string"><span class="hljs-string">'Z'</span></span>,<span class="hljs-string"><span class="hljs-string">'0'</span></span>..<span class="hljs-string"><span class="hljs-string">'9'</span></span>] / <span class="hljs-string"><span class="hljs-string">'^'</span></span> / <span class="hljs-string"><span class="hljs-string">'_'</span></span> / <span class="hljs-string"><span class="hljs-string">'='</span></span> / <span class="hljs-string"><span class="hljs-string">' '</span></span> / <span class="hljs-string"><span class="hljs-string">'-'</span></span> / <span class="hljs-string"><span class="hljs-string">'+'</span></span> / <span class="hljs-string"><span class="hljs-string">'/'</span></span> / <span class="hljs-string"><span class="hljs-string">'('</span></span> / <span class="hljs-string"><span class="hljs-string">')'</span></span> / <span class="hljs-string"><span class="hljs-string">'['</span></span> / <span class="hljs-string"><span class="hljs-string">']'</span></span>; command : WordTexAst = <span class="hljs-string"><span class="hljs-string">'\\'</span></span> commandName; <span class="hljs-keyword"><span class="hljs-keyword">escape</span></span> : WordTexAst = <span class="hljs-string"><span class="hljs-string">'\\'</span></span> escapeLetter; <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> : WordTexAst = <span class="hljs-string"><span class="hljs-string">'{'</span></span> ast <span class="hljs-string"><span class="hljs-string">'}'</span></span>; data : WordTexAst = letter+; word : WordTexAst = command / <span class="hljs-keyword"><span class="hljs-keyword">escape</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> / data; ast : WordTexAst.<span class="hljs-keyword"><span class="hljs-keyword">Sequence</span></span> = word+; })]</code> </pre> <br>  The first parameter of the macro is the rule with which to start parsing.  Then - a description of the grammar (strategy), which is very similar to the Backus-Naur form.  In the left column is the rule to be defined, followed by the type of structure that is parsed by this rule.  In the first three cases, it is omitted, since these rules serve as constants for the remaining rules.  After the equal sign, the structure of the parsed text is described; it can be specified using constants and other rules, separated by a space.  To describe the structure, you can use special characters, for example, '+' - apply the rule one or more times, 'a / b' means apply the parsing rule 'a', if it doesn‚Äôt fit, then the parsing rule 'b'.  It is important that this operator is not commutative, if the first parsing rule is applied successfully, then the alternative is not considered. <br><br>  In addition to the attribute, you need to add several methods to the parser class - one for each parsing rule.  The number of arguments and their type must comply with the rules that are used by this rule on the right side (after the equal sign). <br><br>  Full parser code example: <br><pre> <code class="hljs java"> [PegGrammar(ast, grammar { commandName = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>..<span class="hljs-string"><span class="hljs-string">'z'</span></span>,<span class="hljs-string"><span class="hljs-string">'A'</span></span>..<span class="hljs-string"><span class="hljs-string">'Z'</span></span>]+; escapeLetter = <span class="hljs-string"><span class="hljs-string">';'</span></span> / <span class="hljs-string"><span class="hljs-string">','</span></span>; letter = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>..<span class="hljs-string"><span class="hljs-string">'z'</span></span>,<span class="hljs-string"><span class="hljs-string">'A'</span></span>..<span class="hljs-string"><span class="hljs-string">'Z'</span></span>,<span class="hljs-string"><span class="hljs-string">'0'</span></span>..<span class="hljs-string"><span class="hljs-string">'9'</span></span>] / <span class="hljs-string"><span class="hljs-string">'^'</span></span> / <span class="hljs-string"><span class="hljs-string">'_'</span></span> / <span class="hljs-string"><span class="hljs-string">'='</span></span> / <span class="hljs-string"><span class="hljs-string">' '</span></span> / <span class="hljs-string"><span class="hljs-string">'-'</span></span> / <span class="hljs-string"><span class="hljs-string">'+'</span></span> / <span class="hljs-string"><span class="hljs-string">'/'</span></span> / <span class="hljs-string"><span class="hljs-string">'('</span></span> / <span class="hljs-string"><span class="hljs-string">')'</span></span> / <span class="hljs-string"><span class="hljs-string">'['</span></span> / <span class="hljs-string"><span class="hljs-string">']'</span></span>; command : WordTexAst = <span class="hljs-string"><span class="hljs-string">'\\'</span></span> commandName; escape : WordTexAst = <span class="hljs-string"><span class="hljs-string">'\\'</span></span> escapeLetter; group : WordTexAst = <span class="hljs-string"><span class="hljs-string">'{'</span></span> ast <span class="hljs-string"><span class="hljs-string">'}'</span></span>; data : WordTexAst = letter+; word : WordTexAst = command / escape / group / data; ast : WordTexAst.Sequence = word+; })] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TexParser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">escape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_ : NToken, symbol : NToken)</span></span></span><span class="hljs-function"> : WordTexAst </span></span>{ WordTexAst.Escape(GetText(symbol)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">command</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_ : NToken, commandName : NToken)</span></span></span><span class="hljs-function"> : WordTexAst </span></span>{ WordTexAst.Command(GetText(commandName)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">group</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_ : NToken, ast : WordTexAst.Sequence, _ : NToken)</span></span></span><span class="hljs-function"> : WordTexAst </span></span>{ WordTexAst.Group(ast) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg : NToken)</span></span></span><span class="hljs-function"> : WordTexAst </span></span>{ WordTexAst.Data(GetText(arg)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">word</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg : WordTexAst)</span></span></span><span class="hljs-function"> : WordTexAst </span></span>{ arg } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data : List[WordTexAst])</span></span></span><span class="hljs-function"> : WordTexAst.Sequence </span></span>{ WordTexAst.Sequence(data.ToList()) } }</code> </pre> <br>  The type NToken has not been described yet.  This is the class that matches the substring in the parsed text that satisfies the ‚Äúconstant‚Äù rule.  You can translate an object of this class into a string using the GetText method. <br><br>  It remains to demonstrate the use of the parser: <br><br><pre> <code class="hljs tex"> def parser = TexParser(); def text = @"<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">int</span></span></span></span>_{-<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">frac</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{\pi}</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{2}</span></span></span></span>}^{<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">frac</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{\pi}</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{2}</span></span></span></span>} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cos</span></span></span></span> x <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">;</span></span></span></span> dx = 2"; def (pos,ast) = parser.TryParse(text); when (pos == text.Length) Console.WriteLine("success");</code> </pre> <br>  The TryParse method parses the text, pos contains the number of characters parsed, if the string is fully parsed, then pos is equal to the length of the string, if only the prefix is ‚Äã‚Äãparsed, then pos contains the prefix length. <br><br><h4>  Conclusion </h4><br>  The article describes eDSL for building PEG grammars.  In addition to building recursive language parsers, it can be used to parse regular grammars, in the case when a regular expression is too complicated to work with. <br><br>  This eDSL is implemented as a macro, which at the compilation stage is disclosed in an efficient parsing algorithm.  The resulting dll can be used in any .net language.  Thus, the use of this library is not limited to one language. <br><br><h4>  Links </h4><br>  <a href="http://code.google.com/p/nemerle/downloads/list">Current version of Nemerle</a> <br>  <a href="http://rsdn.ru/forum/nemerle/">Forum on rsdn.ru (Russian)</a> <br>  <a href="http://groups.google.com/group/nemerle-en/">Google group (English)</a> </div><p>Source: <a href="https://habr.com/ru/post/104968/">https://habr.com/ru/post/104968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../104961/index.html">Zen engineering</a></li>
<li><a href="../104962/index.html">Standards for syntax syntax. The first steps</a></li>
<li><a href="../104963/index.html">Web Developer Toolkit for Mobile Devices</a></li>
<li><a href="../104964/index.html">The first TV Google TV will be released October 12</a></li>
<li><a href="../104966/index.html">E-Books make up only 6% in the book market</a></li>
<li><a href="../104971/index.html">XSS in mail.ru?</a></li>
<li><a href="../104973/index.html">Stuxnet did get to the Iranian nuclear plant in Bushehr</a></li>
<li><a href="../104974/index.html">Parallels Desktop 6 for Mac details</a></li>
<li><a href="../104975/index.html">Facebook introduced Discover Facebook Pages functionality</a></li>
<li><a href="../104977/index.html">Personal portable giant Acer Aspire 8943G</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>