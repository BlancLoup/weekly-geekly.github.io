<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As I wrote the fastest memoization feature</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In fact, I wrote perhaps the slowest function of memoization, but it turned out fast. My guilt is not here. It's all about balance. 

 In the balance ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As I wrote the fastest memoization feature</h1><div class="post__text post__text-html js-mediator-article">  In fact, I wrote perhaps the slowest function of memoization, but it turned out fast.  My guilt is not here.  It's all about balance. <br><br>  In the balance between how long the function being memorized will be fulfilled, how much extra time will be required by the sugar of memoization, and (everyone will forget about it) how many programmers will need to be properly screwed up this memoization. <br><br><img src="https://habrastorage.org/webt/ic/uj/qa/icujqah2v0kwqifzpyttxzpbkew.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But let's start with a simple one - what kind of a word is so strange - ‚Äúmemoization‚Äù. <br><a name="habracut"></a><br><blockquote>  Memoization (from the English memoization) is one of the optimization methods used to increase the speed of computer program execution ‚Äî saving the results of functions to prevent recalculations. Thanks to Wikipedia. </blockquote>  There are a LOT of libraries that provide this very memory, but everyone has their own different implementation details - how they work with the number of arguments, how they store the results and how much, well, of course, how fast they are. <br><br>  The speed of the library is very different - thousands of times.  But the whole secret is how they measure and how, of course, every author will find a case that suits his creation best of all, will find his own tricks. <br><br>  <a href="">Lodash.memoize</a> , for example, works by default with one function argument.  <a href="">Fast-memoize</a> - has a different code for the functions of one or more than one argument.  <a href="https://github.com/alexreardon/memoize-one">Memoize-one</a> or <a href="https://github.com/reactjs/reselect">reselect</a> silently saves one last answer, and is compared only with it.  Which is very bad in some cases (calculation of fibonacci numbers, for example), and very good in others (React / Redux), with the exception of some features (more than one instance of the component). <br><br>  In general, there are tricks everywhere.  Without this, it would not be interesting.  Let's look at the last case, which over the past couple of years has been VERY well chewed - Redux.  Yes, that's not the end. <br><blockquote>  In the world of React / Redux, there is a mapStateToProps function that ‚Äúselects‚Äù some values ‚Äã‚Äãfor a specific element from a large common state.  If the result of the function is different from the previously saved one, the component will be redrawn with new data. <br></blockquote><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">todos</span></span>: state.todos.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> todo.active) });</code> </pre> <br>  ^ here I am a little nosyachil.  I wanted to filter only active TODOs, but I will get a unique array (with non-unique values), with each function call.  This is a very, very bad idea, since then the return value is compared by shallowequal, but it is not equal. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filterTodos = memoize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todos</span></span></span><span class="hljs-function"> =&gt;</span></span> todos.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> todo.active)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">todos</span></span>: filterTodos(state.todos) });</code> </pre> <br>  ^ I corrected it here, and now the answer will <i>change</i> only if the array itself changes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filterTodos = memoize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todos</span></span></span><span class="hljs-function"> =&gt;</span></span> todos.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> todo.active)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getTodos = memoize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todos</span></span></span><span class="hljs-function"> =&gt;</span></span> todos.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> todo.text )) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">todos</span></span>: getTodos(filterTodos(state.todos)) });</code> </pre> <br>  ^ and here I really wanted the answer to change only when the text was changed in the active TODO, but to want is not harmful.  It is almost impossible to do. <br><br>  Redux is a very good tool, and I love it with all my heart.  But when it comes to parsing the state on the cascade of selectors, with the subsequent assembly in response, with the sole purpose - to memorize the result so that once again React does not pull.  No guys - I do not play such games. <br><br>  Here the matter is not in the speed of the function of the memoization, but in the process of the ‚Äúcorrect‚Äù memoisation itself, the time spent on it and the expected final result. <br><blockquote>  And of course, we should not forget that not everything should be memosized.  It is often easier to find something ‚Äúfor real‚Äù than to think that it is not necessary to count anything.  Sugar memoization is far from free. </blockquote>  But!  In the React / Redux environment, the speed of memoization means practically nothing.  The very fact of memoisation is important.  If you were able to understand in time that you already have the result, and you don‚Äôt need to update anything - you miss the giant piece of React code that would have wasted a part of the application. <br><blockquote>  And even the smallest optimization will be dozens of times greater than the "extra" calculations in the sugar memoization, which made this optimization possible. </blockquote>  Well, if it turns out that it is even possible to use the ‚Äúcomplex‚Äù functions of memoization, when we consider not fibonacci, but something simpler, then let's search. <br><br><h4>  Memoize-state </h4><br>  <a href="https://github.com/theKashey/memoize-state">Memoize-state</a> is a library of memoization, based on slightly different principles, which makes memorization easier and faster.  Despite the fact that the code in it is 10 times more than in the usual memoization function. <br><br>  Let's start with examples <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filterTodos = memoizeState(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todos</span></span></span><span class="hljs-function"> =&gt;</span></span> todos.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> todo.active)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getTodos = memoizeState(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todos</span></span></span><span class="hljs-function"> =&gt;</span></span> todos.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> todo.text )) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps =<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">todos</span></span>: getTodos(filterTodos(state.todos)) });</code> </pre> <br>  ^ The end result will only change if the text in the active TODO has changed. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filterTodos =<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todos</span></span></span><span class="hljs-function"> =&gt;</span></span> todos.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> todo.active); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getTodos = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todos</span></span></span><span class="hljs-function"> =&gt;</span></span> todos.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> todo.text ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = memoizeState (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">todos</span></span>: getTodos(filterTodos(state.todos)) }));</code> </pre> <br>  ^ completely identical result.  Suddenly? <br><br>  Memoize-state works on the principles similar to <b>MobX</b> or <b>Immer.js</b> - ES6 <b>Proxy</b> , WeakMaps, Reflection and other modern crap, which makes this magic possible. <br><br>  In short, a memoize-state keeps track of how you use the passed arguments, and what you return as an answer.  Then she understands what changes she should react to, and which changes shouldn‚Äôt.  (it took almost a month to understand how this really should work) <br>  In other words, you can write any function, wrap it in a memoize-state (at least 10 times), and they will be memorated to the theoretical maximum. <br><blockquote>  PS: !!!  the function must be pure, otherwise the focus will fail.  The function must accept "objects" as input, work with keys in objects and return the object, otherwise there will be garbage, not focus. </blockquote>  memoize-state is ideal for complex cases, and especially for mapStateToProps and any analogs.  Do not try to use it to calculate fibonacci - there is TOO much logic in the depths too many times more than the complexity of the fibonacci calculation itself. <br><br><h4>  Speed </h4><br>  Once the conversation about speed, let's compare: <br><br>  1. Calculation of fibonacci numbers.  Fast-memoize library test <br><br><pre> <code class="hljs css">0. <span class="hljs-selector-tag"><span class="hljs-selector-tag">base</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">line</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> 123<span class="hljs-selector-class"><span class="hljs-selector-class">.592</span></span> (  ) 2. <span class="hljs-selector-tag"><span class="hljs-selector-tag">fast-memoize</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> 203<span class="hljs-selector-class"><span class="hljs-selector-class">.342</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.420</span></span> 3. <span class="hljs-selector-tag"><span class="hljs-selector-tag">lodash</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> 25<span class="hljs-selector-class"><span class="hljs-selector-class">.877</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.616</span></span> 4. <span class="hljs-selector-tag"><span class="hljs-selector-tag">underscore</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> 20<span class="hljs-selector-class"><span class="hljs-selector-class">.518</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.294</span></span> 5. <span class="hljs-selector-tag"><span class="hljs-selector-tag">memoize-state</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> 16<span class="hljs-selector-class"><span class="hljs-selector-class">.834</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.719</span></span> 6. <span class="hljs-selector-tag"><span class="hljs-selector-tag">ramda</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.274</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.908</span></span></code> </pre><br>  Well - not the worst option. <br><br>  2. The calculation of the "slow" function of the three integer arguments.  A test from the memoize-state library <br><br><pre> <code class="hljs css">0. <span class="hljs-selector-tag"><span class="hljs-selector-tag">base</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">line</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> 10<span class="hljs-selector-class"><span class="hljs-selector-class">.646</span></span> (  ) 1. <span class="hljs-selector-tag"><span class="hljs-selector-tag">memoize-one</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> 4<span class="hljs-selector-class"><span class="hljs-selector-class">.605</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.161</span></span> 2. <span class="hljs-selector-tag"><span class="hljs-selector-tag">memoize-state</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.494</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.236</span></span> 3. <span class="hljs-selector-tag"><span class="hljs-selector-tag">lodash</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.memoize</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.148</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.475</span></span> 4. <span class="hljs-selector-tag"><span class="hljs-selector-tag">fast-memoize</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> 647<span class="hljs-selector-class"><span class="hljs-selector-class">.231</span></span></code> </pre><br>  Already better. <br><br>  3. Calculation of "mapStateToProps" is an object at the input, values ‚Äã‚Äãchange randomly (or do not change). <br><br><pre> <code class="hljs css">0. <span class="hljs-selector-tag"><span class="hljs-selector-tag">base</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">line</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.921</span></span> (  ) 1. <span class="hljs-selector-tag"><span class="hljs-selector-tag">memoize-state</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> 424<span class="hljs-selector-class"><span class="hljs-selector-class">.303</span></span> 3. <span class="hljs-selector-tag"><span class="hljs-selector-tag">fast-memoize</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> 29<span class="hljs-selector-class"><span class="hljs-selector-class">.811</span></span> 2. <span class="hljs-selector-tag"><span class="hljs-selector-tag">lodash</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.memoize</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> 20<span class="hljs-selector-class"><span class="hljs-selector-class">.664</span></span> 4. <span class="hljs-selector-tag"><span class="hljs-selector-tag">memoize-one</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.592</span></span></code> </pre><br>  Very good.  memoize-state just rips to shreds.  fast-memoize and lodash.memoize, like those based on JSON.stringify, handle cases when the object was given a new one, but the values ‚Äã‚Äãin it are old. <br><br>  There's another test, when just a large object is served at the input, and the overhead of JSON.stringify takes off to the skies.  There the difference is even greater. <br><br>  The result is the slowest, because the most difficult, the function of memoization is not so slow at all.  Yes, and the overhead of ensuring its work allows it to run 16 million per second, which of course is not as cool as 200 for the leaders of memoization, but a hundred thousand times more than the react / redux application needs. <br><br>  Memoize-state differs from the usual functions of memoization in that it <b>does not require configuration</b> , it is friendly with memoizations that you already have (they will choose the keys they need from the general state), which ultimately allows you to call it ‚Äúexternal memoization‚Äù. <br><br>  As a result, even more magical magic becomes possible - <a href="https://github.com/theKashey/beautiful-react-redux">beautiful-react-redux</a> . <br>  <b>beautiful-react-redux</b> is a wrapper for react-redux that silently wraps the mapStateToProps <b>two times</b> in a memoize-state, thereby providing automatic memoization for both one and many components (bye <a href="https://github.com/toomuchdesign/re-reselect">re-reselect</a> ).  One line - and the whole application has become a little (or a lot) faster.  Without any work on your part, and this is important. <br><blockquote>  PS: beautiful-react-redux also provides a tool for testing the application for the "correctness" of memoization WITHOUT activating memoize-state.  Those can use this magic to test a lower-level, more complex, but faster approach ‚Äî standard libraries.  More in repository. </blockquote>  The second excellent example of use is <a href="https://github.com/theKashey/react-memoize">react-memoize</a> - a library based on <a href="https://twitter.com/dan_abramov/status/965378278461755392">Dan Abramov‚Äôs tweet</a> (and so it is), which memorizes the render, allowing you to actually abandon any logic in componentWillReceiveProps. <br><br><img src="https://habrastorage.org/webt/rb/-m/j-/rb-mj-2pas7k0dnowtu4s0rw7dk.png"><br><br>  In fact, the implementation is slightly different.  Just because the "selectors" are no longer needed, and the possibility of "just writing code." <br><br>  Just pass some kind of props, just somehow count something based on them, and the trick is in the bag. <br><br><pre> <code class="javascript hljs">&lt;Memoize prop1 = <span class="hljs-string"><span class="hljs-string">"theKey"</span></span> state = {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state} compute={({prop1, state}) =&gt; heavyComputation(state[prop1])} &gt; { result =&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Display</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{result}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Display</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/Memoize&gt;</span></span></code> </pre> <br>  And this again works simply, and completely automagically. <br><br>  The second important option is the original memoize-state tests not only compare the speed, but also compare cache hit / miss.  So - 99 out of 100 cases when you need to memoize, and 0 cases out of 100 when not necessary.  It works almost perfectly.  And of course, this is all covered in tests in three layers, as the memoize-state consists of three parts - a memoize-state for memoization itself, a proxyequal for wrapping, expanding and comparing objects and a search-trie to speed up the search for those parts of objects that follow. compare by value, and those which should not be. <br><br><h4>  Compatibility </h4><br>  There is only one minus for all this - for IE11 and Android (React Navite) it requires a polyfil for a proxy, which slows down somewhat.  But it‚Äôs better that way. <br><br><h4>  It's time to act </h4><br>  There is still an untapped field ahead, for example, you can <a href="https://github.com/theKashey/proxyequal/issues/1">increase the speed of</a> checking for memoization twice.  Yes, and the react-redux integration can be freed <a href="https://github.com/theKashey/beautiful-react-redux/issues/2">from any calculations</a> in some cases. <br><br>  In general - all interested are invited to <b>yarn add memoize-state</b> , and experiments. <br><br>  <a href="https://github.com/theKashey/memoize-state"><b>Github</b></a> </div><p>Source: <a href="https://habr.com/ru/post/350562/">https://habr.com/ru/post/350562/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350552/index.html">Who is the product manager on the project and can it come from the lead developer?</a></li>
<li><a href="../350554/index.html">Lightning network in depth, part 1: payment channels</a></li>
<li><a href="../350556/index.html">How to convince others to respond to letters and become a universal email machine</a></li>
<li><a href="../350558/index.html">Why we put content first</a></li>
<li><a href="../350560/index.html">Asynchronous (self-timed) circuits. Calculation of logical functions directly on the event graph. Part 2</a></li>
<li><a href="../350564/index.html">The preliminary program DUMP-2018 is ready. Speakers from Microsoft, VKontakte, Rambler, Tinkoff, HTML Academy</a></li>
<li><a href="../350566/index.html">Schi, or Recognition of 330 million people at a speed of 400 photos / sec</a></li>
<li><a href="../350570/index.html">Backend on CodeFest: bigdate, machine and blockchain</a></li>
<li><a href="../350572/index.html">Backlog in product management: what to do when ideas grow ‚Äúlike a snowball‚Äù</a></li>
<li><a href="../350574/index.html">You can not just take and edit subtitles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>