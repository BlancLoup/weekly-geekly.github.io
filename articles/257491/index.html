<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>REST server for a simple Haskell blog</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago I was completely tired of languages ‚Äã‚Äãwith dynamic typing and decided to try to learn something brutally static. Haskell appealed to me ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>REST server for a simple Haskell blog</h1><div class="post__text post__text-html js-mediator-article">  Some time ago I was completely tired of languages ‚Äã‚Äãwith dynamic typing and decided to try to learn something brutally static.  Haskell appealed to me with the beauty of the code and the uncompromising desire to clearly separate the pure functions from the side effects.  I gulped down a few Haskell books and decided it was time to write something. <br><br>  And here I was disappointed: I was not able to write anything except hello world.  Those.  I had some idea how to write any console utility like find or something like that, but the very first meeting with IO destroyed all my ideas.  There are a lot of libraries for Haskell, but there is almost no documentation on them at all.  Examples of solving typical problems are also very few. <br><br>  The symptoms are clear, the diagnosis is simple: lack of practice.  And for Haskell, this is quite painful, because  language is extremely unusual.  Even the fact that I know Clojure quite well did not help me at all, since  Clojure focuses more on functions, while Haskell focuses on their types. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I think a lot of newbies have a problem with the lack of practice in Haskell.  Writing something completely without an interface is somehow not interesting, but making a desktop or web application for a novice haskelist is quite difficult.  And in this article, I'm going to offer a simple example of how to write a Haskell web application server specifically for those who want to practice Haskell, but do not know which way to approach it. <br><br>  For the most impatient: the source is <a href="https://github.com/dbushenko/scotty-blog">here</a> . <br><a name="habracut"></a><br>  I have to say: this is not just another tutorial by <a href="http://www.yesodweb.com/">Yesod</a> .  This framework dictates its own ideas about how to properly create web applications, and I do not agree with everything.  Therefore, the base will be a small <a href="https://hackage.haskell.org/package/scotty">Scotty</a> library, offering a nice syntax for route description for the <a href="https://hackage.haskell.org/package/warp">Warp</a> web server. <br><br><h4>  Task </h4><br>  Develop a web application server for a simple blog.  The following routes will be available: <br><ul><li>  GET / articles - list of articles. </li><li>  GET / articles /: id - a separate article. </li><li>  POST / admin / articles - create an article. </li><li>  PUT / admin / articles - update the article. </li><li>  DELETE / admin / articles /: id - delete the article. </li></ul><br>  All routes that begin with ‚Äú/ admin‚Äù require user authentication.  For stateless-service it is very convenient to use <a href="http://en.wikipedia.org/wiki/Basic_access_authentication">Basic authentication</a> , since  Each request contains a username and password. <br><br><h4>  What is needed? </h4><br><ul><li>  Some basic Haskell knowledge, a general understanding of monads and functors, program design, I / O, etc. </li><li>  Cabal utility, ability to use sandboxes, connect libraries, compile and run a project. </li><li>  MySQL and the most basic knowledge of it. </li></ul><br><h4>  Architecture </h4><br>  To implement the architecture I propose to use the following libraries. <br><ul><li>  Web server - Warp. </li><li>  Router - Scotty. </li><li>  Application configuration - configurator. </li><li>  Database access: mysql and mysql-simple. </li><li>  Database connection pool: resource-pool. </li><li>  Client interaction - REST using JSON, library - aeson. </li><li>  wai-extra for basic authentication, since  the application will be stateless. </li></ul><br>  Let's break our application into modules. <br><ul><li>  Main.hs will contain the code for running the application, the router and the application configuration. </li><li>  Db.hs - everything related to access to the database. </li><li>  View.hs - data presentation. </li><li>  Domain.hs types and functions for working with the subject area. </li><li>  Auth.hs - functions for authentication. </li></ul><br><h4>  Getting started </h4><br>  Let's create a simple cabal project for our application. <br><br><pre><code class="bash hljs">mkdir hblog <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> hblog cabal init</code> </pre> <br>  Here you need to answer a couple of questions, while the project type is select Executable, the main file is Main.hs, the source directory is src.  Here are the used libraries that need to be added to build-depends in the hblog.cabal file: <br><br><pre> <code class="haskell hljs"> base &gt;= <span class="hljs-number"><span class="hljs-number">4.6</span></span> &amp;&amp; &lt; <span class="hljs-number"><span class="hljs-number">4.7</span></span> , scotty &gt;= <span class="hljs-number"><span class="hljs-number">0.9</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> , bytestring &gt;= <span class="hljs-number"><span class="hljs-number">0.9</span></span> &amp;&amp; &lt; <span class="hljs-number"><span class="hljs-number">0.11</span></span> , text &gt;= <span class="hljs-number"><span class="hljs-number">0.11</span></span> &amp;&amp; &lt; <span class="hljs-number"><span class="hljs-number">2.0</span></span> , mysql &gt;= <span class="hljs-number"><span class="hljs-number">0.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.8</span></span> , mysql-simple &gt;= <span class="hljs-number"><span class="hljs-number">0.2</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.5</span></span> , aeson &gt;= <span class="hljs-number"><span class="hljs-number">0.6</span></span> &amp;&amp; &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span> , <span class="hljs-type"><span class="hljs-type">HTTP</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">4000.2</span></span><span class="hljs-number"><span class="hljs-number">.19</span></span> , transformers &gt;= <span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> , wai &gt;= <span class="hljs-number"><span class="hljs-number">3.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span> , wai-middleware-static &gt;= <span class="hljs-number"><span class="hljs-number">0.7</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> , wai-extra &gt;= <span class="hljs-number"><span class="hljs-number">3.0</span></span><span class="hljs-number"><span class="hljs-number">.7</span></span> , resource-pool &gt;= <span class="hljs-number"><span class="hljs-number">0.2</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> , configurator &gt;= <span class="hljs-number"><span class="hljs-number">0.3</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> , <span class="hljs-type"><span class="hljs-type">MissingH</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">1.3</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span></code> </pre><br>  Now, in order to avoid the hellish confusion with the versions of libraries and their dependencies, let's create a sandbox. <br><br><pre> <code class="bash hljs"> cabal sandbox init cabal install ‚Äîdependencies-only</code> </pre><br>  Remember to create the src / Main.hs file. <br><br>  Let's see how the minimal web application on Scotty works.  Documentation and examples of using this micro-framework are very good, so at first glance everything becomes clear.  And if you have experience with Sinatra, Compojure or Scalatra - consider yourself lucky, because  This experience is completely useful here. <br><br>  Here is the minimum src / Main.hs: <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE OverloadedStrings #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Web.Scotty <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Monoid (<span class="hljs-title"><span class="hljs-title">mconcat</span></span>) main = scotty 3000 $ do get "/:word" $ do beam &lt;- param "word" html $ mconcat ["&lt;h1&gt;Scotty, ", beam, " me up!&lt;/h1&gt;"]</code> </pre><br>  The first line of the code can plunge a beginner into amazement: what else for the overloaded lines?  I'll explain now. <br><br>  Since I, like many others, began to learn Haskell from the books ‚Äú <a href="http://learnyouahaskell.com/">Learn you a Haskell for a greater good</a> ‚Äù and ‚Äú <a href="http://book.realworldhaskell.org/">Real World Haskell,</a> ‚Äù I immediately became a big problem with word processing.  I found the best description of working with text in Haskell in the book <a href="http://www.amazon.com/Beginning-Haskell-A-Project-Based-Approach/dp/1430262508">Beginning Haskell</a> in Chapter 10. <br><br>  In short, in practice three basic types of string data are used: <br><ul><li>  String - a list of characters.  This data type is built into the language. </li><li>  Text is a data type intended for both ASCII and UTF characters.  It is located in the text library and exists in two forms: strict and lazy.  Read more - <a href="https://hackage.haskell.org/package/text">here</a> </li><li>  ByteString - designed to serialize strings to a byte stream.  It is delivered in the library <a href="https://hackage.haskell.org/package/bytestring">bytestring</a> and also in two versions: strict and lazy. </li></ul><br>  Let's return to the OverloadedStrings header.  The thing is that, given the presence of several types of string data, the source code will be filled with calls like T.pack ‚ÄúHello‚Äù, where the ‚ÄúHello‚Äù token must be converted to Text;  or B.pack "Hello" where the token needs to be converted to a ByteString.  Here, to remove this syntactic garbage, the OverloadedStrings directive is used, which itself converts a string token to the desired string type. <br><br><h4>  Main.hs file </h4><br>  Main function: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">--      application.conf,         loadedConf &lt;- C.load [C.Required "application.conf"] dbConf &lt;- makeDbConfig loadedConf case dbConf of Nothing -&gt; putStrLn "No database configuration found, terminating..." Just conf -&gt; do --    (    ‚Äî 5 ,      -- 10) pool &lt;- createPool (newConn conf) close 1 5 10 --   Scotty scotty 3000 $ do --       ¬´static¬ª middleware $ staticPolicy (noDots &gt;-&gt; addBase "static") --   .    logStdout  logStdoutDev middleware $ logStdoutDev --       middleware $ basicAuth (verifyCredentials pool) "Haskell Blog Realm" { authIsProtected = protectedResources } get "/articles" $ do articles &lt;- liftIO $ listArticles pool articlesList articles --     :id       get "/articles/:id" $ do id &lt;- param "id" :: ActionM TL.Text maybeArticle &lt;- liftIO $ findArticle pool id viewArticle maybeArticle --      Article     Article   post "/admin/articles" $ do article &lt;- getArticleParam insertArticle pool article createdArticle article put "/admin/articles" $ do article &lt;- getArticleParam updateArticle pool article updatedArticle article delete "/admin/articles/:id" $ do id &lt;- param "id" :: ActionM TL.Text deleteArticle pool id deletedArticle id</span></span></code> </pre><br>  To configure the application, we will use the <a href="http://ruhaskell.org/posts/packages/2015/01/21/configurator.html">configurator</a> package.  We will store the configuration in the application.conf file, and here is its contents: <br><br><pre> <code class="javascript hljs">database { name = <span class="hljs-string"><span class="hljs-string">"hblog"</span></span> user = <span class="hljs-string"><span class="hljs-string">"hblog"</span></span> password = <span class="hljs-string"><span class="hljs-string">"hblog"</span></span> }</code> </pre><br>  For the connection pool, use the resource-pool library.  Connecting to a database is a pleasure, so it is better not to create it for each request, but to give the opportunity to reuse the old ones.  The type of the createPool function is: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">createPool</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> a -&gt; (a -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> ()) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">NominalDiffTime</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Pool</span></span> a) createPool create destroy numStripes idleTime maxResources</code> </pre><br>  Here, create and destroy are functions for creating and terminating a connection to the database, numStripes is the number of separate sub-pools of connections, idleTime is the lifetime of an unused connection (in seconds), maxResources is the maximum number of connections in the sub-pool. <br><br>  To open a connection, use the function newConn (from Db.hs). <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbName</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbUser</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbPassword</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Generic</span></span></span><span class="hljs-class">) newConn :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Connection</span></span></span><span class="hljs-class"> newConn conf = connect defaultConnectInfo { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connectUser</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbUser</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conf</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connectPassword</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbPassword</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conf</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connectDatabase</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbName</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conf</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br>  Well, DbConfig itself is created like this: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">makeDbConfig</span></span> :: <span class="hljs-type"><span class="hljs-type">C</span></span>.<span class="hljs-type"><span class="hljs-type">Config</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Db</span></span>.<span class="hljs-type"><span class="hljs-type">DbConfig</span></span>) makeDbConfig conf = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> name &lt;- <span class="hljs-type"><span class="hljs-type">C</span></span>.lookup conf <span class="hljs-string"><span class="hljs-string">"database.name"</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span>) user &lt;- <span class="hljs-type"><span class="hljs-type">C</span></span>.lookup conf <span class="hljs-string"><span class="hljs-string">"database.user"</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span>) password &lt;- <span class="hljs-type"><span class="hljs-type">C</span></span>.lookup conf <span class="hljs-string"><span class="hljs-string">"database.password"</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span>) return $ <span class="hljs-type"><span class="hljs-type">DbConfig</span></span> &lt;$&gt; name &lt;*&gt; user &lt;*&gt; password</code> </pre><br>  Data.Configurator.Config is passed to the input, which we read and parsed from application.conf, and Maybe DbConfig wrapped in an IO shell at the output. <br><br>  Such a record for beginners may seem a bit incomprehensible, and I will try to clarify what is happening here. <br>  The type of the expression C.lookup conf ‚Äúdatabase.name‚Äù is Maybe String, enclosed in IO.  You can extract it from IO like this: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">name</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">C</span></span>.lookup conf <span class="hljs-string"><span class="hljs-string">"database.name"</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span>)</code> </pre><br>  Accordingly, the constants name, user, password type - Maybe String. <br><br>  The DbConfig data constructor type is: <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">DbConfig</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DbConfig</span></span></code> </pre><br>  This function accepts three lines as input and returns DbConfig. <br><br>  The type of the function (&lt;$&gt;) is: <br><br><pre> <code class="haskell hljs">(&lt;$&gt;) :: <span class="hljs-type"><span class="hljs-type">Functor</span></span> f =&gt; (a -&gt; b) -&gt; fa -&gt; fb</code> </pre><br>  Those.  it takes an ordinary function, a functor, and returns a functor with a function applied to its value.  In short, this is a regular map. <br><br>  The DbConfig &lt;$&gt; name entry extracts a string from name (the name type is Maybe String) assigns the value to the first parameter in the DbConfig constructor and returns the curried DbConfig in the Maybe shell: <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">DbConfig</span></span> &lt;$&gt; name :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> (<span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DbConfig</span></span>)</code> </pre><br>  Please note that there is already one less string transmitted. <br><br>  Type (&lt;*&gt;) is similar to &lt;$&gt;: <br><br><pre> <code class="haskell hljs">(&lt;*&gt;) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; f (a -&gt; b) -&gt; fa -&gt; fb</code> </pre><br>  It takes a functor whose value is a function, takes another functor and applies the function from the first functor to the value from the second, returning a new functor. <br><br>  Thus, the DbConfig &lt;$&gt; name &lt;*&gt; user entry is of the type: <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">DbConfig</span></span> &lt;$&gt; name &lt;*&gt; user :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> (<span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DbConfig</span></span>)</code> </pre><br>  The last String parameter remains, which we fill with the password: <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">DbConfig</span></span> &lt;$&gt; name &lt;*&gt; user &lt;*&gt; password :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">DbConfig</span></span></code> </pre><br><h4>  Authentication </h4><br>  In the main function, the last complex construct remains - middleware basicAuth.  The type of basicAuth function is: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">basicAuth</span></span> :: <span class="hljs-type"><span class="hljs-type">CheckCreds</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">AuthSettings</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Middleware</span></span></code> </pre><br>  The first parameter is a function that checks the presence of a user in the database, the second one determines which routes require authentication protection.  Their types are: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CheckCreds</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ByteString</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ByteString</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ResourceT</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AuthSettings</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AuthSettings</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">authRealm</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ByteString</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">authOnNoAuth</span></span></span><span class="hljs-class"> :: !(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ByteString</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span><span class="hljs-class">) , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">authIsProtected</span></span></span><span class="hljs-class"> :: !(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Request</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ResourceT</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class">) }</span></span></code> </pre><br>  The data type AuthSettings is quite complex, and if you want to get deeper with it, see the source <a href="https://hackage.haskell.org/package/wai-extra-1.3.4.5/docs/src/Network-Wai-Middleware-HttpAuth.html">here</a> .  We are only interested in one parameter here - authIsProtected.  This is a function that, by Request, can determine whether to require authentication or not.  Here is its implementation for our blog: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">protectedResources</span></span> :: <span class="hljs-type"><span class="hljs-type">Request</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Bool</span></span> protectedResources request = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> path = pathInfo request return $ protect path <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> protect (p : _) = p == <span class="hljs-string"><span class="hljs-string">"admin"</span></span> protect _ = <span class="hljs-type"><span class="hljs-type">False</span></span></code> </pre><br>  The pathInfo function has the following type: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">pathInfo</span></span> :: <span class="hljs-type"><span class="hljs-type">Request</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Text</span></span>]</code> </pre><br>  It takes a Request and returns a list of strings that turned out after dividing the request route into substrings by the delimiter ‚Äú/‚Äù. <br>  Thus, if our request starts with ‚Äú/ admin‚Äù, then the protectedResources function returns IO True, requiring authentication. <br><br>  But the verifyCredentials function, which checks the user and password, relates to interaction with the database, and therefore about it - below. <br><br><h4>  Database interaction </h4><br>  Utility functions for extracting data from the database using the connection pool: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fetchSimple</span></span> :: <span class="hljs-type"><span class="hljs-type">QueryResults</span></span> r =&gt; <span class="hljs-type"><span class="hljs-type">Pool</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.<span class="hljs-type"><span class="hljs-type">Connection</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Query</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> [r] fetchSimple pool sql = withResource pool retrieve <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> retrieve conn = query_ conn sql fetch :: (<span class="hljs-type"><span class="hljs-type">QueryResults</span></span> r, <span class="hljs-type"><span class="hljs-type">QueryParams</span></span> q) =&gt; <span class="hljs-type"><span class="hljs-type">Pool</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.<span class="hljs-type"><span class="hljs-type">Connection</span></span> -&gt; q -&gt; <span class="hljs-type"><span class="hljs-type">Query</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> [r] fetch pool args sql = withResource pool retrieve <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> retrieve conn = query conn sql args</code> </pre><br>  The fetchSimple function should be used for queries with no parameters, and fetch for queries with parameters.  Changing data can be made a function execSql: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">execSql</span></span> :: <span class="hljs-type"><span class="hljs-type">QueryParams</span></span> q =&gt; <span class="hljs-type"><span class="hljs-type">Pool</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.<span class="hljs-type"><span class="hljs-type">Connection</span></span> -&gt; q -&gt; <span class="hljs-type"><span class="hljs-type">Query</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int64</span></span> execSql pool args sql = withResource pool ins <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ins conn = execute conn sql args</code> </pre><br>  If you need to use a transaction, here is the execSqlT function: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">execSqlT</span></span> :: <span class="hljs-type"><span class="hljs-type">QueryParams</span></span> q =&gt; <span class="hljs-type"><span class="hljs-type">Pool</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.<span class="hljs-type"><span class="hljs-type">Connection</span></span> -&gt; q -&gt; <span class="hljs-type"><span class="hljs-type">Query</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int64</span></span> execSqlT pool args sql = withResource pool ins <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ins conn = withTransaction conn $ execute conn sql args</code> </pre><br>  Using the fetch function, you can, for example, find the user's password hash in the database by his login: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">findUserByLogin</span></span> :: <span class="hljs-type"><span class="hljs-type">Pool</span></span> <span class="hljs-type"><span class="hljs-type">Connection</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span>) findUserByLogin pool login = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> res &lt;- liftIO $ fetch pool (<span class="hljs-type"><span class="hljs-type">Only</span></span> login) <span class="hljs-string"><span class="hljs-string">"SELECT * FROM user WHERE login=?"</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> [(<span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>)] return $ password res <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> password [(_, _, pwd)] = <span class="hljs-type"><span class="hljs-type">Just</span></span> pwd password _ = <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre><br>  It is needed in the module Auth.hs: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">verifyCredentials</span></span> :: <span class="hljs-type"><span class="hljs-type">Pool</span></span> <span class="hljs-type"><span class="hljs-type">Connection</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>.<span class="hljs-type"><span class="hljs-type">ByteString</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>.<span class="hljs-type"><span class="hljs-type">ByteString</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Bool</span></span> verifyCredentials pool user password = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> pwd &lt;- findUserByLogin pool (<span class="hljs-type"><span class="hljs-type">BC</span></span>.unpack user) return $ comparePasswords pwd (<span class="hljs-type"><span class="hljs-type">BC</span></span>.unpack password) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> comparePasswords <span class="hljs-type"><span class="hljs-type">Nothing</span></span> _ = <span class="hljs-type"><span class="hljs-type">False</span></span> comparePasswords (<span class="hljs-type"><span class="hljs-type">Just</span></span> p) password = p == (md5s $ <span class="hljs-type"><span class="hljs-type">Str</span></span> password)</code> </pre><br>  As you can see, if the password hash is found in the database, then it can be matched with the password from the request, encoded using the md5 algorithm. <br><br>  But not only users are stored in the database, but also articles that a blog should be able to create-edit-display.  In the Domain.hs file, we define the data type of Article with the fields id title bodyText: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Article</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Article</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Integer</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Text</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Text</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Now you can define CRUD functions in the database for this type: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">listArticles</span></span> :: <span class="hljs-type"><span class="hljs-type">Pool</span></span> <span class="hljs-type"><span class="hljs-type">Connection</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> [<span class="hljs-type"><span class="hljs-type">Article</span></span>] listArticles pool = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> res &lt;- fetchSimple pool <span class="hljs-string"><span class="hljs-string">"SELECT * FROM article ORDER BY id DESC"</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> [(<span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">TL</span></span>.<span class="hljs-type"><span class="hljs-type">Text</span></span>, <span class="hljs-type"><span class="hljs-type">TL</span></span>.<span class="hljs-type"><span class="hljs-type">Text</span></span>)] return $ map (\(id, title, bodyText) -&gt; <span class="hljs-type"><span class="hljs-type">Article</span></span> id title bodyText) res findArticle :: <span class="hljs-type"><span class="hljs-type">Pool</span></span> <span class="hljs-type"><span class="hljs-type">Connection</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">TL</span></span>.<span class="hljs-type"><span class="hljs-type">Text</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Article</span></span>) findArticle pool id = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> res &lt;- fetch pool (<span class="hljs-type"><span class="hljs-type">Only</span></span> id) <span class="hljs-string"><span class="hljs-string">"SELECT * FROM article WHERE id=?"</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> [(<span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">TL</span></span>.<span class="hljs-type"><span class="hljs-type">Text</span></span>, <span class="hljs-type"><span class="hljs-type">TL</span></span>.<span class="hljs-type"><span class="hljs-type">Text</span></span>)] return $ oneArticle res <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> oneArticle ((id, title, bodyText) : _) = <span class="hljs-type"><span class="hljs-type">Just</span></span> $ <span class="hljs-type"><span class="hljs-type">Article</span></span> id title bodyText oneArticle _ = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> insertArticle :: <span class="hljs-type"><span class="hljs-type">Pool</span></span> <span class="hljs-type"><span class="hljs-type">Connection</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Article</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ActionT</span></span> <span class="hljs-type"><span class="hljs-type">TL</span></span>.<span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> () insertArticle pool <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = return () insertArticle pool (<span class="hljs-type"><span class="hljs-type">Just</span></span> (<span class="hljs-type"><span class="hljs-type">Article</span></span> id title bodyText)) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> liftIO $ execSqlT pool [title, bodyText] <span class="hljs-string"><span class="hljs-string">"INSERT INTO article(title, bodyText) VALUES(?,?)"</span></span> return () updateArticle :: <span class="hljs-type"><span class="hljs-type">Pool</span></span> <span class="hljs-type"><span class="hljs-type">Connection</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Article</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ActionT</span></span> <span class="hljs-type"><span class="hljs-type">TL</span></span>.<span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> () updateArticle pool <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = return () updateArticle pool (<span class="hljs-type"><span class="hljs-type">Just</span></span> (<span class="hljs-type"><span class="hljs-type">Article</span></span> id title bodyText)) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> liftIO $ execSqlT pool [title, bodyText, (<span class="hljs-type"><span class="hljs-type">TL</span></span>.decodeUtf8 $ <span class="hljs-type"><span class="hljs-type">BL</span></span>.pack $ show id)] <span class="hljs-string"><span class="hljs-string">"UPDATE article SET title=?, bodyText=? WHERE id=?"</span></span> return () deleteArticle :: <span class="hljs-type"><span class="hljs-type">Pool</span></span> <span class="hljs-type"><span class="hljs-type">Connection</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">TL</span></span>.<span class="hljs-type"><span class="hljs-type">Text</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ActionT</span></span> <span class="hljs-type"><span class="hljs-type">TL</span></span>.<span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> () deleteArticle pool id = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> liftIO $ execSqlT pool [id] <span class="hljs-string"><span class="hljs-string">"DELETE FROM article WHERE id=?"</span></span> return ()</code> </pre><br>  The most important here are the insertArticle and updateArticle functions.  They take the Maybe Article as input and insert / update the corresponding entry in the database.  But where to get this Maybe Article? <br><br>  Quite simply, the user must pass an Article encoded in JSON in the body of a PUT or POST request.  Here are the functions for encoding and decoding Article to and from JSON: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FromJSON</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Article</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> parseJSON (<span class="hljs-type"><span class="hljs-type">Object</span></span> v) = <span class="hljs-type"><span class="hljs-type">Article</span></span> &lt;$&gt; v .:? <span class="hljs-string"><span class="hljs-string">"id"</span></span> .!= <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;*&gt; v .: <span class="hljs-string"><span class="hljs-string">"title"</span></span> &lt;*&gt; v .: <span class="hljs-string"><span class="hljs-string">"bodyText"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">ToJSON</span></span> <span class="hljs-type"><span class="hljs-type">Article</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> toJSON (<span class="hljs-type"><span class="hljs-type">Article</span></span> id title bodyText) = object [<span class="hljs-string"><span class="hljs-string">"id"</span></span> .= id, <span class="hljs-string"><span class="hljs-string">"title"</span></span> .= title, <span class="hljs-string"><span class="hljs-string">"bodyText"</span></span> .= bodyText]</code> </pre><br>  To handle JSON, we use the aeson library, more about it <a href="http://ruhaskell.org/posts/packages/2015/02/03/aeson-hello-world.html">here</a> . <br><br>  As you can see, when decoding, the id field is optional, and if it is not in the line with JSON, then the default value of 0 will be substituted. The id field will not be created when creating an Article, since  id must create the database itself.  But the id will be in the update request. <br><br><h4>  Data presentation </h4><br>  Let's go back to the Main.hs file and see how we get the request parameters.  You can get the parameter from the route using the param function: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">param</span></span> :: <span class="hljs-type"><span class="hljs-type">Parsable</span></span> a =&gt; <span class="hljs-type"><span class="hljs-type">TL</span></span>.<span class="hljs-type"><span class="hljs-type">Text</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ActionM</span></span> a</code> </pre><br>  And the request body can be obtained by the body function: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">body</span></span> :: <span class="hljs-type"><span class="hljs-type">ActionM</span></span> <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">ByteString</span></span>.<span class="hljs-type"><span class="hljs-type">Lazy</span></span>.<span class="hljs-type"><span class="hljs-type">Internal</span></span>.<span class="hljs-type"><span class="hljs-type">ByteString</span></span></code> </pre><br>  Here is a function that can get the request body, parse it and return the Maybe Article <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">getArticleParam</span></span> :: <span class="hljs-type"><span class="hljs-type">ActionT</span></span> <span class="hljs-type"><span class="hljs-type">TL</span></span>.<span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Article</span></span>) getArticleParam = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> b &lt;- body return $ (decode b :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Article</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> makeArticle s = <span class="hljs-string"><span class="hljs-string">""</span></span></code> </pre><br>  The last thing left: return the data to the client  To do this, we define the following functions in the Views.hs file: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">articlesList</span></span> :: [<span class="hljs-type"><span class="hljs-type">Article</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">ActionM</span></span> () articlesList articles = json articles viewArticle :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Article</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ActionM</span></span> () viewArticle <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = json () viewArticle (<span class="hljs-type"><span class="hljs-type">Just</span></span> article) = json article createdArticle :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Article</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ActionM</span></span> () createdArticle article = json () updatedArticle :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Article</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ActionM</span></span> () updatedArticle article = json () deletedArticle :: <span class="hljs-type"><span class="hljs-type">TL</span></span>.<span class="hljs-type"><span class="hljs-type">Text</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ActionM</span></span> () deletedArticle id = json ()</code> </pre><br><br><h4>  Server performance </h4><br>  For the tests, I used a Samsung 700Z laptop with 8GB of memory and a quad-core Intel Core i7. <br><ul><li>  1000 consecutive PUT requests to create an article entry. <br>  Average response time: 40 milliseconds, approximately 25 requests per second. <br></li><li>  100 threads with 100 PUT requests each. <br>  Average response time: 1248 milliseconds, approximately 80 parallel requests per second. <br></li><li>  100 threads of 1000 GET requests returning 10 article entries. <br>  Average response time: 165 milliseconds, approximately 600 requests per second. <br></li></ul><br>  Just to make at least something to compare, I implemented exactly the same server in Java 7 and Spring 4 with the Tomcat 7 web server and got the following numbers. <br><ul><li>  1000 consecutive PUT requests to create an article entry. <br>  Average response time: 51 milliseconds, approximately 19-20 requests per second. <br></li><li>  100 threads with 100 PUT requests each. <br>  Average response time: 104 milliseconds, approximately 960 parallel requests per second. <br></li><li>  100 threads of 1000 GET requests returning 10 article entries. <br>  Average response time: 26 milliseconds, approximately 3800 requests per second. <br></li></ul><br><h4>  findings </h4><br>  If you do not have enough practice in Haskell, and you want to try writing web applications on it, <a href="https://github.com/dbushenko/scotty-blog">here</a> you will find an example of a simple server with CRUD operations for one entity, Article, described in the article.  The application is implemented as a JSON REST service and requires basic authentication on secure routes.  MySQL is used for data storage, a connection pool is used to improve performance.  Since the application does not store state in the session, it is very easy to scale it horizontally, and besides, the stateless server is ideal for developing <a href="http://habrahabr.ru/post/249183/">microservice</a> <a href="http://eax.me/micro-service-architecture/">architecture</a> . <br><br>  Using Haskell to develop a JSON REST server has made it possible to get a short and beautiful source that, among other things, is easy to maintain: refactoring, making changes and additions will not require much work, because  the compiler itself will check the correctness of all changes.  The disadvantage of using Haskell is not very high performance of the received web service in comparison with the similar written in Java. <br><br><h4>  PS </h4><br>  On the advice of the comments conducted additional testing.  Changing the number of threads to N = 8 inclusive - does not affect performance.  When reducing N further, the performance drops, because  On my laptop 8 logical cores. <br><br>  Another interesting thing.  If you disable saving the record in the database, the average delay in the response of the service in Haskell drops to as much as 6 milliseconds (!), In a similar service in java this time is 80ms.  Those.  the bottleneck in the shown project is interaction with the database, if you turn it off, then Haskell is 13 times faster than the similar functionality in Java.  Memory consumption is also several times lower: approximately 80MB vs. 400MB. </div><p>Source: <a href="https://habr.com/ru/post/257491/">https://habr.com/ru/post/257491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257479/index.html">Infrastructure of the Radio Access Network as an investment</a></li>
<li><a href="../257481/index.html">Reference Code</a></li>
<li><a href="../257483/index.html">And again about the ears</a></li>
<li><a href="../257487/index.html">What is Junos Fusion?</a></li>
<li><a href="../257489/index.html">Intel Enterprise Edition - ‚ÄúShade‚Äù for Luster</a></li>
<li><a href="../257493/index.html">How to quickly build mailer for call center</a></li>
<li><a href="../257497/index.html">Development of Return of Dr. Destructo: What Progress Reached</a></li>
<li><a href="../257499/index.html">Notes on the fields of Big Data Week Moscow</a></li>
<li><a href="../257501/index.html">Cach√© 2015 Scalability with Ivy Bridge-EX</a></li>
<li><a href="../257503/index.html">Power profiling of microcontrollers (EFM32, SiLabs series)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>