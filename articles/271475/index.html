<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parallel parsing of a large number of HTML pages using Apache Ignite (GridGain) in 200 lines of code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Periodically, I have tasks to process a large number of files. This is usually converting from one format to another: XSLT transformation, parsing, co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parallel parsing of a large number of HTML pages using Apache Ignite (GridGain) in 200 lines of code</h1><div class="post__text post__text-html js-mediator-article">  Periodically, I have tasks to process a large number of files.  This is usually converting from one format to another: XSLT transformation, parsing, converting images or video.  To solve these problems, I adapted the <b>GridGain In-Memory Data Fabric</b> framework.  It provides the ability to do distributed computing, MapReduce, distributed caches and queues, a distributed file system in memory, moving code to data, job stealing, accelerators for Hadoop, and many other things that are fashionable today.  And all this is easy and for different OSes.  You can easily feel all this under Windows. <br><br>  I will try to talk about my experience using the example of a simple task. <br><a name="habracut"></a><br>  Recently there was a task to extract product descriptions from a large site (2.5 million products). <br>  The site was downloaded using the wget utility: <br><pre><code class="bash hljs">C:&gt;start wget110 --recursive --level 10 -nc --no-clobber --html-extension --exclude-directories=it,fr --convert-links http://site.com</code> </pre> <br><br>  You can run several utility instances that will download in parallel.  But still a long time, a week somewhere. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Initially, I tried parsing with the Xidel console program: <br><pre> <code class="bash hljs">REM          FOR /R ./ %%G IN (dbfamily*.html) DO xidel <span class="hljs-string"><span class="hljs-string">"%%G"</span></span> --quiet --extract-file=mytemplate.txt</code> </pre><br>  The file mytemplate.txt contained a pattern: <br><pre> <code class="bash hljs">//td/h1 || <span class="hljs-string"><span class="hljs-string">" # "</span></span> || //td[contains(text(),<span class="hljs-string"><span class="hljs-string">""</span></span>)] || <span class="hljs-string"><span class="hljs-string">" # "</span></span> || //td[contains(text(),<span class="hljs-string"><span class="hljs-string">""</span></span>)] || <span class="hljs-string"><span class="hljs-string">" # "</span></span> || //td[contains(text(),<span class="hljs-string"><span class="hljs-string">""</span></span>)] || <span class="hljs-string"><span class="hljs-string">" # "</span></span> || //td[contains(text(),<span class="hljs-string"><span class="hljs-string">""</span></span>)]</code> </pre><br>  But it took a lot of time sequential parsing.  Therefore, it was decided to do this in parallel on several computers.  Surprisingly, in the end, this resulted in only one class in java. <br><br>  Each HTML page is parsed with XPath expressions.  The document is pre-cleaned with html-cleaner <br><br>  <b>HTML Parsing Code:</b> <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ArrayList </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseWithXPathList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path, ArrayList&lt;String&gt; XPathList)</span></span></span><span class="hljs-function"> </span></span>{ count++; String str = <span class="hljs-string"><span class="hljs-string">""</span></span>; ArrayList list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { String content = readFile(path, StandardCharsets.UTF_8); TagNode tagNode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlCleaner().clean(content); org.w3c.dom.Document doc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DomSerializer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CleanerProperties()).createDOM(tagNode); <span class="hljs-comment"><span class="hljs-comment">// And then use the standard JAXP interfaces to query it: XPath xpath = XPathFactory.newInstance().newXPath(); Iterator&lt;String&gt; it = XPathList.iterator(); while (it.hasNext()) { String XPath = it.next(); String res = (String) xpath.evaluate(XPath, doc, XPathConstants.STRING); list.add(res); } // System.out.println(str); } catch (Exception e) { str = "" + e; list.add(str); } return list; }</span></span></code> </pre><br><br>  Called as follows: <br>  ArrayList Xpaths = new ArrayList (Arrays.asList ("// title", "// td / h1")); <br>  ArrayList ResultList = parseWithXPathList (param.toString (), Xpaths); <br><br>  It now remains only to bypass the directory tree using the standard wolf: <br>  Files.walkFiletree (startingDir, opts, Integer.MAX_VALUE, parseFiles) <br>  And apply a parser to each file. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.toString().endsWith(<span class="hljs-string"><span class="hljs-string">".html"</span></span>)) { ArrayList&lt;String&gt; Xpaths= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;(Arrays.asList(<span class="hljs-string"><span class="hljs-string">"//title"</span></span>,<span class="hljs-string"><span class="hljs-string">"//td/h1"</span></span>)); ArrayList&lt;String&gt; ResultList=parseWithXPathList(file.toString(),Xpaths); System.out.format(<span class="hljs-string"><span class="hljs-string">" %d ) %s %n"</span></span>, count,<span class="hljs-string"><span class="hljs-string">""</span></span>+ResultList); <span class="hljs-comment"><span class="hljs-comment">//castOneAsync(ignite, "" + file); }</span></span></code> </pre><br><br>  Parsing a million files on one machine consistently takes ~ 12 hours <br>  I tried to parallelize the code using the GridGain framework, or rather its non-commercial version of Apache Ignite. <br>  This thing works like this: you need to run the nodes (on one or more machines), the nodes will find each other over the network and write in their consoles how many processors and memory you have organized in a cluster (these are your slaves).  I launched 12 nodes on 3 machines (4 cores each and 16 GB RAM). <br>  After downloading the site (~ 500GB), the daddy with html-kami is shared for access on the grid.  Share daddy should be visible to all nodes (check access rights!) <br><br>  Further, you should write a simple java app in which the master-node should also start: <br><pre> <code class="java hljs">Ignite ignite = Ignition.start(<span class="hljs-string"><span class="hljs-string">"D:\\grid\\1.4\\apache-ignite-fabric-1.4.0-bin\\config\\default-config.xml"</span></span>);</code> </pre><br><br>  After that, you can ask her about the state of the cluster and cast the job on arbitrary nodes. <br>  The division into master and slave is conditional.  Nody equal.  I call the master node on which the initial code will be executed.  Actually, you can do a cluster segmentation by node type, but we now need nothing. <br><br>  Code casting job with parsing to the node: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">castOneAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ignite ignite, String param)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Enable asynchronous mode. IgniteCluster cluster = ignite.cluster(); IgniteCompute asyncCompute = ignite.compute(cluster.forRemotes()).withAsync(); // Asynchronously execute a job. asyncCompute.call(() -&gt; { System.out.println("processing: " + param); ArrayList&lt;String&gt; Xpaths = new ArrayList&lt;String&gt;(Arrays.asList("//title", "//td/h1")); ArrayList&lt;String&gt; ResultList = parseWithXPathList(param.toString(), Xpaths); System.out.format(" %d ) %s \n %n", count, "" + ResultList); return ""+param+" :" + ResultList; }); // Get the future for the above invocation. IgniteFuture&lt;String&gt; fut = asyncCompute.future(); // Asynchronously listen for completion and print out the result. fut.listen(f -&gt; { String resultStr = f.get()+" \n"; // System.out.println("Job result: " + resultStr); count++; try { Files.write(Paths.get("d:\\grid\\result.txt"), resultStr.getBytes(), StandardOpenOption.APPEND); } catch (IOException e) { System.out.println("" + e); } if (count%100==0) System.out.println( "processed: "+count ); }); }</span></span></code> </pre><br>  Important points: <br><ul><li>  A node is a folder with a java program and configuration in the form of the default-config.xml file.  Starts from ignite.bat. <br>  Copy the folder with the node to arbitrary machines on the local network.  You can run multiple instances of the node on the same machine. <br>  <a href="">Download node</a> (They call it a fabric) <br></li><li>  All nodes must have the same configuration file. </li><li>  Ignite supports the concept of peer class loading (Zero Deployment).  This means that you do not need to rewrite your project to all nodes.  He himself odeploitsya.  This is a very cool feature.  Saves a lot of time. <br>  But you need to include this feature in the configuration file.  They write that it works faster with the feature disabled.  Did not check. <br></li><li>  You can run multiple nodes on the same machine and emulate working with a cluster. </li><li>  Yes, in the cluster, you can add and remove nodes in the process of running app. <br></li><li>  In the configuration file, you must specify the IP addresses of the machines in the cluster </li><li>  Need java 8, since lambda is used </li><li>  If you stop the master node, then the task, which it has cast, will die on other machines. </li><li>  You can ask the framework for data on any machine in the cluster: CPU load, free memory, number of jobs, but I trusted the wizard to decide which machine is better to throw job </li></ul><br>  As a result, I managed to fit the entire project into one java class ~ 200 lines of code with comments.  The class needs jar files with htmlcleaner and apache ignite. <br><br>  You can instead of html cleaner to use the external utility Xidel.  It supports XQuery and XPath. <br>  Then you need to register it on all machines with nodes in the system variable PATH and then call directly from java.  But you will enjoy XQuery. <br><br>  If the publication is of interest, I will write about distributed cache, queues and other distributed things on this framework. <br><br>  <a href="">Project Source Code for Eclipse</a> <br><br>  - <pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> gridE; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.ignite.Ignite; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.ignite.IgniteCluster; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.ignite.IgniteCompute; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.ignite.Ignition; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.ignite.lang.IgniteFuture; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.htmlcleaner.CleanerProperties; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.htmlcleaner.DomSerializer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.htmlcleaner.HtmlCleaner; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.htmlcleaner.TagNode; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.xml.xpath.XPath; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.xml.xpath.XPathConstants; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.xml.xpath.XPathFactory; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.PrintWriter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.charset.Charset; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.charset.StandardCharsets; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.attribute.BasicFileAttributes; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Arrays; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Date; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.EnumSet; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Iterator; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Scanner; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.nio.file.FileVisitResult.CONTINUE; <span class="hljs-comment"><span class="hljs-comment">/** * Created by Veaceslav Kunitki on 11/13/2015. * This class parse files on cluster with "Apache Ignite" framework */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.nio.file.FileVisitResult.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParseFilesOnCluster</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleFileVisitor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Path</span></span></span><span class="hljs-class">&gt; </span></span>{ Ignite ignite; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// counter of parsed files // Java standart FileTree walker @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attr) { if (attr.isSymbolicLink()) { System.out.format("Symbolic link: %s ", file); } else if (attr.isRegularFile()) { // System.out.format("Regular file: %s ", file); if (file.toString().endsWith(".html") ) { //if (file.toString().endsWith(".html") ) { // uncomment it for serial processing //ArrayList&lt;String&gt; Xpaths = new ArrayList&lt;String&gt;(Arrays.asList("//title", "//td/h1")); // ArrayList&lt;String&gt; // ResultList=parseWithXPathList(file.toString(),Xpaths); // System.out.format(" %d ) %s %n", count,""+ResultList); castOneAsync(ignite, "" + file); // parallel processing } } else { System.out.format("Other: %s ", file); } return CONTINUE; } // Print each directory visited. @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) { System.out.format("Directory: %s%n", dir); return CONTINUE; } @Override public FileVisitResult visitFileFailed(Path file, IOException exc) { System.err.println(exc); return CONTINUE; } static String readFile(String path, Charset encoding) throws IOException { byte[] encoded = Files.readAllBytes(Paths.get(path)); return new String(encoded, encoding); } public static ArrayList parseWithXPathList(String path, ArrayList&lt;String&gt; XPathList) { count++; String str = ""; ArrayList list = new ArrayList(); try { String content = readFile(path, StandardCharsets.UTF_8); TagNode tagNode = new HtmlCleaner().clean(content); org.w3c.dom.Document doc = new DomSerializer(new CleanerProperties()).createDOM(tagNode); // And then use the standard JAXP interfaces to query it: XPath xpath = XPathFactory.newInstance().newXPath(); // String str = (String) xpath.evaluate("//div//td[contains(@id, // 'foo')]/text()", Iterator&lt;String&gt; it = XPathList.iterator(); while (it.hasNext()) { String XPath = it.next(); String res = (String) xpath.evaluate(XPath, doc, XPathConstants.STRING); list.add(res); } // System.out.println(str); } catch (Exception e) { str = "" + e; list.add(str); } return list; } /* * Asynchronously execute a job on external PC */ public static void castOneAsync(Ignite ignite, String param) { // Enable asynchronous mode. IgniteCluster cluster = ignite.cluster(); // IgniteCompute compute1 = ignite.compute(cluster.forRemotes()); IgniteCompute asyncCompute = ignite.compute(cluster.forRemotes()).withAsync(); // Asynchronously execute a job. asyncCompute.call(() -&gt; { // Print hello world on some cluster node and wait for completion. System.out.println("processing: " + param); ArrayList&lt;String&gt; Xpaths = new ArrayList&lt;String&gt;(Arrays.asList("//title", "//li/@data-zoom")); ArrayList&lt;String&gt; ResultList = parseWithXPathList(param.toString(), Xpaths); System.out.format(" %d ) %s \n %n", count, "" + ResultList); String text = new Scanner(new File(param.toString()), "UTF-8").useDelimiter("\\A").next(); return "{ 'url':" + param + " ,'ResultList'=" + ResultList + " }"; }); // Get the future for the above invocation. IgniteFuture&lt;String&gt; fut = asyncCompute.future(); // Asynchronously listen for completion and print out the result. fut.listen(f -&gt; { String resultStr = f.get() + " \n"; // System.out.println("Job result: " + resultStr); count++; try { Files.write(Paths.get("d:\\grid\\result.txt"), resultStr.getBytes(), StandardOpenOption.APPEND ); //Warning! File must be exist, do it manual! } catch (IOException e) { System.out.println("" + e); } if (count % 100 == 0) System.out.println("processed: " + count); }); } public static void main(String[] args) throws Exception { System.out.println("# Distributed parser!"); Ignite ignite = Ignition.start("D:\\grid\\1.4\\apache-ignite-fabric-1.4.0-bin\\config\\default-config.xml"); IgniteCluster cluster = ignite.cluster(); // Compute instance over remote nodes. IgniteCompute compute4remote = ignite.compute(cluster.forRemotes()); // Print hello message on all remote nodes. compute4remote.broadcast( () -&gt; System.out.println("---===Distributed parser started===---: " + cluster.localNode().id())); System.out.println( "Cluster ready!" ); if (true) { // start parsing job // final Path startingDir = Paths.get("d:/home/familytree.ru/"); Path startingDir = Paths.get("\\\\SERGIU-PC\\temp"); // shared directory with HTML-files EnumSet&lt;FileVisitOption&gt; opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS); ParseFiles parseFiles = new ParseFiles(); parseFiles.ignite = ignite; // log time to file PrintWriter writer = new PrintWriter("d:\\grid\\start.txt", "UTF-8"); String dateTime = "" + (new Date()); writer.println(dateTime + "\n"); System.out.println(dateTime + "\n"); writer.close(); System.out.println("# walking...!"); Files.walkFileTree(startingDir, opts, Integer.MAX_VALUE, parseFiles); // log end time dateTime = "" + (new Date()); Files.write(Paths.get("d:\\grid\\start.txt"), dateTime.getBytes(), StandardOpenOption.APPEND); } } }</span></span></code> </pre><br><br>  <b>POM-file with project dependencies</b> <br><br><pre> <code class="java hljs">&lt;project xmlns=<span class="hljs-string"><span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span> xmlns:xsi=<span class="hljs-string"><span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span> xsi:schemaLocation=<span class="hljs-string"><span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span></span>&gt; &lt;modelVersion&gt;<span class="hljs-number"><span class="hljs-number">4.0</span></span>.0&lt;/modelVersion&gt; &lt;groupId&gt;gridE&lt;/groupId&gt; &lt;artifactId&gt;gridE&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">0.0</span></span>.1-SNAPSHOT&lt;/version&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;GridGain External Repository&lt;/id&gt; &lt;url&gt;http:<span class="hljs-comment"><span class="hljs-comment">//www.gridgainsystems.com/nexus/content/repositories/external&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.ignite&lt;/groupId&gt; &lt;artifactId&gt;ignite-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.ignite&lt;/groupId&gt; &lt;artifactId&gt;ignite-spring&lt;/artifactId&gt; &lt;version&gt;1.1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.ignite&lt;/groupId&gt; &lt;artifactId&gt;ignite-indexing&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.ignite&lt;/groupId&gt; &lt;artifactId&gt;ignite-examples&lt;/artifactId&gt; &lt;version&gt;1.0.0-RC1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.htmlcleaner&lt;/groupId&gt; &lt;artifactId&gt;htmlcleaner&lt;/artifactId&gt; &lt;version&gt;2.15&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt;</span></span></code> </pre><br><br>  <b>Configuration file for node</b> <br><br><pre> <code class="java hljs">&lt;?xml version=<span class="hljs-string"><span class="hljs-string">"1.0"</span></span> encoding=<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>?&gt; &lt;!-- _________ _____ __________________ _____ __ ____/___________(_)______ /__ ____/<span class="hljs-function"><span class="hljs-function">______ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">____</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">_______ _ / __ __ ___/__ / _ __ / _ / __ _ __ `/__ / __ __ \ / /_/ / _ / _ / / /_/ / / /_/ / / /_/ / _ / _ / / / \____/ /_/ /_/ \_,__/ \____/ \__,_/ /_/ /_/ /_/ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Copyright</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(C)</span></span></span><span class="hljs-function"> GridGain Systems. All Rights Reserved. Licensed under the Apache License, Version 2.0 </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(the </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"License"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; you may not use <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> file except in compliance with the License. You may obtain a copy of the License at http:<span class="hljs-comment"><span class="hljs-comment">//www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. --&gt; &lt;!-- Ignite Spring configuration file. --&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd"&gt; &lt;bean class="org.apache.ignite.configuration.IgniteConfiguration"&gt; &lt;!-- Set to true to enable grid-aware class loading for examples, default is false. --&gt; &lt;property name="peerClassLoadingEnabled" value="true"/&gt; &lt;property name="marshaller"&gt; &lt;bean class="org.apache.ignite.marshaller.optimized.OptimizedMarshaller"&gt; &lt;!-- Set to false to allow non-serializable objects in examples, default is true. --&gt; &lt;property name="requireSerializable" value="false"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- Enable events for examples. --&gt; &lt;property name="includeEventTypes"&gt; &lt;util:constant static-field="org.apache.ignite.events.EventType.EVTS_ALL"/&gt; &lt;/property&gt; &lt;!-- Explicitly configure TCP discovery SPI to provide list of initial nodes. --&gt; &lt;property name="discoverySpi"&gt; &lt;bean class="org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi"&gt; &lt;property name="ipFinder"&gt; &lt;!-- Uncomment multicast IP finder to enable multicast-based discovery of initial nodes. --&gt; &lt;!--&lt;bean class="org.apache.ignite.spi.discovery.tcp.ipfinder.multicast.TcpDiscoveryMulticastIpFinder"&gt;--&gt; &lt;bean class="org.apache.ignite.spi.discovery.tcp.ipfinder.vm.TcpDiscoveryVmIpFinder"&gt; &lt;property name="addresses"&gt; &lt;list&gt; &lt;!-- In distributed environment, replace with actual host IP address. --&gt; &lt;value&gt;127.0.0.1:47500..47509&lt;/value&gt; &lt;value&gt;192.168.4.110:47500..47509&lt;/value&gt; &lt;value&gt;192.168.4.117:47500..47509&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name="cacheConfiguration"&gt; &lt;bean class="org.apache.ignite.configuration.CacheConfiguration"&gt; &lt;!-- Set a cache name. --&gt; &lt;property name="name" value="cacheName"/&gt; &lt;!-- Set cache mode. --&gt; &lt;property name="cacheMode" value="PARTITIONED"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt;</span></span></code> in writing, software <code class="java hljs">&lt;?xml version=<span class="hljs-string"><span class="hljs-string">"1.0"</span></span> encoding=<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>?&gt; &lt;!-- _________ _____ __________________ _____ __ ____/___________(_)______ /__ ____/<span class="hljs-function"><span class="hljs-function">______ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">____</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">_______ _ / __ __ ___/__ / _ __ / _ / __ _ __ `/__ / __ __ \ / /_/ / _ / _ / / /_/ / / /_/ / / /_/ / _ / _ / / / \____/ /_/ /_/ \_,__/ \____/ \__,_/ /_/ /_/ /_/ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Copyright</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(C)</span></span></span><span class="hljs-function"> GridGain Systems. All Rights Reserved. Licensed under the Apache License, Version 2.0 </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(the </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"License"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; you may not use <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> file except in compliance with the License. You may obtain a copy of the License at http:<span class="hljs-comment"><span class="hljs-comment">//www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. --&gt; &lt;!-- Ignite Spring configuration file. --&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd"&gt; &lt;bean class="org.apache.ignite.configuration.IgniteConfiguration"&gt; &lt;!-- Set to true to enable grid-aware class loading for examples, default is false. --&gt; &lt;property name="peerClassLoadingEnabled" value="true"/&gt; &lt;property name="marshaller"&gt; &lt;bean class="org.apache.ignite.marshaller.optimized.OptimizedMarshaller"&gt; &lt;!-- Set to false to allow non-serializable objects in examples, default is true. --&gt; &lt;property name="requireSerializable" value="false"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- Enable events for examples. --&gt; &lt;property name="includeEventTypes"&gt; &lt;util:constant static-field="org.apache.ignite.events.EventType.EVTS_ALL"/&gt; &lt;/property&gt; &lt;!-- Explicitly configure TCP discovery SPI to provide list of initial nodes. --&gt; &lt;property name="discoverySpi"&gt; &lt;bean class="org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi"&gt; &lt;property name="ipFinder"&gt; &lt;!-- Uncomment multicast IP finder to enable multicast-based discovery of initial nodes. --&gt; &lt;!--&lt;bean class="org.apache.ignite.spi.discovery.tcp.ipfinder.multicast.TcpDiscoveryMulticastIpFinder"&gt;--&gt; &lt;bean class="org.apache.ignite.spi.discovery.tcp.ipfinder.vm.TcpDiscoveryVmIpFinder"&gt; &lt;property name="addresses"&gt; &lt;list&gt; &lt;!-- In distributed environment, replace with actual host IP address. --&gt; &lt;value&gt;127.0.0.1:47500..47509&lt;/value&gt; &lt;value&gt;192.168.4.110:47500..47509&lt;/value&gt; &lt;value&gt;192.168.4.117:47500..47509&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name="cacheConfiguration"&gt; &lt;bean class="org.apache.ignite.configuration.CacheConfiguration"&gt; &lt;!-- Set a cache name. --&gt; &lt;property name="name" value="cacheName"/&gt; &lt;!-- Set cache mode. --&gt; &lt;property name="cacheMode" value="PARTITIONED"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt;</span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/271475/">https://habr.com/ru/post/271475/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271461/index.html">Codesign.io - architecture that works</a></li>
<li><a href="../271465/index.html">The matrix of capabilities of modern messengers with an emphasis on security</a></li>
<li><a href="../271467/index.html">NGINX as a load balancer for MySQL or MariaDB Galera Cluster</a></li>
<li><a href="../271469/index.html">Zabyty on Mars: explore the travels of Mark Watney from The Martian movie</a></li>
<li><a href="../271471/index.html">The rise of Node.js - and why it will lead in the development of corporate software</a></li>
<li><a href="../271477/index.html">Cooking ASP.NET 5: Continuous Deployment with Docker and Tutum</a></li>
<li><a href="../271479/index.html">Rabdological abacus Claude Perrot</a></li>
<li><a href="../271481/index.html">Domestic server manufacturer = self-assembly?</a></li>
<li><a href="../271483/index.html">C #, ways to store program settings</a></li>
<li><a href="../271485/index.html">A way to quickly measure the performance of a random server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>