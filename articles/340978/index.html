<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL Indexes - 7</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We already got acquainted with the PostgreSQL indexing mechanism and the access methods interface , and examined hash indexes , B-trees , GiST and SP-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL Indexes - 7</h1><div class="post__text post__text-html js-mediator-article"><br>  We already got acquainted with <a href="https://habrahabr.ru/company/postgrespro/blog/326096/">the PostgreSQL indexing mechanism</a> and the <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">access methods interface</a> , and examined <a href="https://habrahabr.ru/company/postgrespro/blog/328280/">hash indexes</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/330544/">B-trees</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/333878/">GiST</a> and <a href="https://habrahabr.ru/company/postgrespro/blog/337502/">SP-GiST</a> indexes.  And in this part we will deal with the GIN index. <br><br><h1>  GIN </h1><br>  <em>- Gin? .. Gin - it seems to be such an American alcoholic drink? ..</em> <br>  <em>- I am not a drink, oh an inquisitive lad!</em>  <em>- the old man flared up again, he realized himself again and again took himself in hand.</em>  <em>- I am not a drink, but a powerful and fearless spirit, and there is no such magic in the world that I could not do.</em> <br><br>  Lazar Lagin, "Old Man Hottabych." 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <em>Gin stands for indexed invert index and should be considered as a genie, not a drink.</em> <br><br>  <a href="https://git.postgresql.org/gitweb/%3Fp%3Dpostgresql.git%3Ba%3Dblob%3Bf%3Dsrc/backend/access/gin/README%3Bhb%3DHEAD">README</a> <br><br><h2>  General idea </h2><br>  GIN stands for Generalized Inverted Index - this is the so-called <em>reverse index</em> .  It works with data types whose values ‚Äã‚Äãare not atomic, but consist of elements.  In this case, not the values ‚Äã‚Äãthemselves are indexed, but individual elements;  each element refers to the values ‚Äã‚Äãin which it occurs. <br><br>  A good analogy for this method is the alphabetical index at the end of the book, where for each term there is a list of pages where this term is mentioned.  Like the pointer in the book, the index method should provide a quick search for indexed items.  For this, they are stored in the form of a <a href="https://habrahabr.ru/company/postgrespro/blog/330544/">B-tree</a> already familiar to us (another, simpler implementation is used for it, but in this case it is irrelevant).  Each item has an ordered set of links to table rows containing values ‚Äã‚Äãwith this item.  The orderliness is not critical for sampling data (the sorting order of TIDs does not carry much sense), but it is important from the point of view of the internal structure of the index. <br><br><a name="habracut"></a><br>  Items are never removed from the GIN index.  It is believed that the values ‚Äã‚Äãcontaining the elements may disappear, appear, change, but the set of elements of which they consist is rather static.  This solution greatly simplifies the algorithms that provide parallel operation with the index of several processes. <br><br>  If the list of TIDs is small enough, it is placed in the same page as the item (and is called the posting list).  But if the list is large, we need a more efficient data structure, and we already know it - this is again a B-tree.  Such a tree is located in separate data pages (and is called a posting tree). <br><br>  Thus, the GIN index consists of a B-tree of elements, to the leaf entries of which B-trees or flat lists of TIDs are attached. <br><br>  Like the GiST and SP-GiST indexes discussed earlier, GIN provides an application developer with an interface to support various operations on complex data types. <br><br><h2>  Full text search </h2><br>  The main area of ‚Äã‚Äãapplication of the gin method is the acceleration of full-text search, so it is logical to consider this index in more detail using this example. <br><br>  In the <a href="https://habrahabr.ru/company/postgrespro/blog/333878/">part about GiST,</a> there was already a small introduction to full-text search, so we will not repeat and get right to the point.  It is clear that complex values ‚Äã‚Äãin this case are <em>documents,</em> and elements of these documents are <em>lexemes.</em> <br><br>  Take the same example that we looked at in the GiST part (just repeat the chorus twice): <br><br> <code>postgres=# create table ts(doc text, doc_tsv tsvector); <br> CREATE TABLE <br> postgres=# insert into ts(doc) values <br> ('   '),  ('   '), <br> (', , '),    (', , '), <br> ('  '), ('  '), <br> (', , '),  (', , '), <br> ('  '),        ('  '), <br> (', , '),    (', , '); <br> INSERT 0 12 <br> <br> postgres=# set default_text_search_config = russian; <br> SET <br> postgres=# update ts set doc_tsv = to_tsvector(doc); <br> UPDATE 12 <br> postgres=# create index on ts using gin(doc_tsv); <br> CREATE INDEX <br></code> <br>  The possible structure of such an index is shown in the figure: <br><br><img src="https://habrastorage.org/webt/59/f1/29/59f129c0ad430497276918.png"><br><br>  Unlike all previous illustrations, references to table lines (TIDs) are shown not by arrows, but by numeric values ‚Äã‚Äãon a dark background (page number and position on the page): <br><br> <code>postgres=# select ctid, doc, doc_tsv from ts; <br> ctid  |          doc          |            doc_tsv <br> --------+-------------------------+-------------------------------- <br> (0,1)  |      | '':3 '':2 '':4 <br> (0,2)  |     | '':3 '':2 '':4 <br> (0,3)  | , ,       | '':1,2 '':3 <br> (0,4)  | , ,       | '':1,2 '':3 <br> (1,1)  |     | '':2 '':3 '':1 <br> (1,2)  |    | '':3 '':2 '':1 <br> (1,3)  | , ,     | '':3 '':1,2 <br> (1,4)  | , ,     | '':3 '':1,2 <br> (2,1)  |           | '':3 '':2 <br> (2,2)  |       | '':1 '':2 '':3 <br> (2,3)  | , ,     | '':3 '':1,2 <br> (2,4)  | , ,     | '':3 '':1,2 <br> (12 rows) <br></code> <br>  In our speculative example, the list of TIDs fit into ordinary pages for all lexemes, except for "lyul."  This token met in as many as six documents and for her the list of TIDs was placed in a separate B-tree. <br><br>  How, by the way, to understand how many documents contain a token?  For a small table, the ‚Äúdirect‚Äù method shown below will work, and we will see how to deal with large ones. <br><br> <code>postgres=# select (unnest(doc_tsv)).lexeme, count(*) from ts group by 1 order by 2 desc; <br> lexeme  | count <br> ---------+------- <br>     |    6 <br>     |    4 <br>  |    4 <br>   |    3 <br>   |    3 <br>     |    2 <br>     |    2 <br>   |    2 <br>     |    1 <br>     |    1 <br>   |    1 <br> (11 rows) <br></code> <br>  We also note that, in contrast to a regular B-tree, the pages of the GIN index are not related to a bidirectional, but to a unidirectional list.  This is sufficient, since a tree is always traversed in one direction only. <br><br><h3>  Request example </h3><br>  How will the following query be performed in our example? <br><br> <code>postgres=# explain(costs off) <br> select doc from ts where doc_tsv @@ to_tsquery(' &amp; '); <br> QUERY PLAN <br> ------------------------------------------------------------------------ <br> Bitmap Heap Scan on ts <br> Recheck Cond: (doc_tsv @@ to_tsquery(' &amp; '::text)) <br> -&gt;  Bitmap Index Scan on ts_doc_tsv_idx <br> Index Cond: (doc_tsv @@ to_tsquery(' &amp; '::text)) <br> (4 rows) <br></code> <br>  First, separate lexemes (search keys) are selected from the search query: ‚Äústanding‚Äù and ‚Äúcurly‚Äù.  This is done by a special API function that takes into account the data type and the strategy defined by the class of statements: <br><br> <code>postgres=# select amop.amopopr::regoperator, amop.amopstrategy <br> from pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <br> where opc.opcname = 'tsvector_ops' <br> and opf.oid = opc.opcfamily <br> and am.oid = opf.opfmethod <br> and amop.amopfamily = opc.opcfamily <br> and am.amname = 'gin' <br> and amop.amoplefttype = opc.opcintype; <br> amopopr        | amopstrategy <br> -----------------------+-------------- <br> @@(tsvector,tsquery)  |            1     <br> @@@(tsvector,tsquery) |            2   @@ (  ) <br> (2 rows) <br></code> <br>  Next, we find both keys in the B-tree of tokens and iterate over the ready lists of TIDs.  We get: <br><br><ul><li>  for ‚Äústanding‚Äù - (0,1), (0,2), (0,3), (0,4); </li><li>  for ‚Äúcurly‚Äù - (0,2), (1,2). </li></ul><br><br><img src="https://habrastorage.org/webt/59/f1/2a/59f12a40a6fef548481070.png"><br><br>  Finally, for each TID found, the API match function is called, which must determine which of the found strings match the search query.  Since in our query, the tokens are combined with the logical ‚Äúand‚Äù, a single string (0,2) is returned: <br><br> <code>|      |        |     <br> |      |        |  <br> TID  |  |  |   &amp;  <br> -------+------+--------+----------------- <br> (0,1) |    T |      f |              f <br> (0,2) |    T |      T |              T <br> (0,3) |    T |      f |              f <br> (0,4) |    T |      f |              f <br> (1,2) |    f |      T |              f <br></code> <br>  And we get the result: <br><br> <code>postgres=# select doc from ts where doc_tsv @@ to_tsquery(' &amp; '); <br> doc <br> ------------------------- <br>     <br> (1 row) <br></code> <br>  If we compare this approach with the one we considered for GiST, the advantage of GIN for full-text search seems obvious.  But not everything is so simple. <br><br><h3>  Slow update problem </h3><br>  The point is that inserting or updating data in a GIN index is relatively slow.  Each document usually contains many tokens to be indexed.  Therefore, when a single document appears or changes, it is necessary to make massive changes to the index tree. <br><br>  On the other hand, if several documents change at once, then a part of the tokens may coincide with them, and the total amount of work will be less than if the documents are changed one by one. <br><br>  The GIN index has a fastupdate storage parameter, which you can specify when creating the index or change it later: <br><br> <code>postgres=# create index on ts using gin(doc_tsv) with (fastupdate = true); <br> CREATE INDEX <br></code> <br>  When enabled, changes will accumulate as a separate unordered list (in separate linked pages).  When this list is large enough, or when performing a cleaning process, all accumulated changes are simultaneously made to the index.  What is considered a ‚Äúlarge enough‚Äù list is determined by the configuration parameter gin_pending_list_limit or by the same storage parameter of the index itself. <br><br>  But this approach also has negative sides: first, the search slows down (due to the fact that besides the tree you have to look through an unordered list), and second, the next change can suddenly take a long time if the unordered list is overflowed. <br><br><h3>  Partial match search </h3><br>  Partial match can be used in full-text search.  The request is formulated, for example, as follows: <br><br> <code>gin=# select doc from ts where doc_tsv @@ to_tsquery(':*'); <br> doc <br> ------------------------- <br>    <br>    <br> , ,  <br> , ,  <br>    <br> , ,  <br> , ,  <br> (7 rows) <br></code> <br>  Such a request will find documents in which there are tokens starting with the ‚Äúhall‚Äù.  That is, in our example, ‚Äúthe crease‚Äù (which is obtained from the word ‚ÄúI hack‚Äù) and the ‚Äúzalomat‚Äù (from the word ‚Äúzaromati‚Äù). <br><br>  The query, of course, will work in any case, even without indices, but the GIN allows you to speed up such a search: <br><br> <code>postgres=# explain (costs off) <br> select doc from ts where doc_tsv @@ to_tsquery(':*'); <br> QUERY PLAN <br> -------------------------------------------------------------- <br> Bitmap Heap Scan on ts <br> Recheck Cond: (doc_tsv @@ to_tsquery(':*'::text)) <br> -&gt;  Bitmap Index Scan on ts_doc_tsv_idx <br> Index Cond: (doc_tsv @@ to_tsquery(':*'::text)) <br> (4 rows) <br></code> <br>  In this case, in the tree of tokens there are all tokens that have the prefix specified in the search query, and are combined with the logical ‚Äúor‚Äù. <br><br><h3>  Frequent and rare lexemes </h3><br>  To see how the indexing works on real data, take the pgsql-hackers mailing list, which we have already used in the GiST topic.  <a href="https://oc.postgrespro.ru/index.php/s/fRxTZ0sVfPZzbmd">This version of the archive</a> contains 356,125 letters with the date of departure, subject, author and text. <br><br> <code>fts=# alter table mail_messages add column tsv tsvector; <br> ALTER TABLE <br> fts=# set default_text_search_config = default; <br> SET <br> fts=# update mail_messages <br> set tsv = to_tsvector(body_plain); <br> NOTICE:  word is too long to be indexed <br> DETAIL:  Words longer than 2047 characters are ignored. <br> ... <br> UPDATE 356125 <br> fts=# create index on mail_messages using gin(tsv); <br> CREATE INDEX <br></code> <br>  Take the lexeme, which is found in a large number of documents.  A query using unnest will not work on such a volume of data, and the correct way is to use the ts_stat function, which gives information about tokens, the number of documents in which they are encountered, and the total number of entries. <br><br> <code>fts=# select word, ndoc <br> from ts_stat('select tsv from mail_messages') <br> order by ndoc desc limit 3; <br> word  |  ndoc <br> -------+-------- <br> re    | 322141 <br> wrote | 231174 <br> use  | 176917 <br> (3 rows) <br></code> <br>  Choose "wrote". <br><br>  And take some rare word in the list of developers, for example, "tattoo": <br><br> <code>fts=# select word, ndoc from ts_stat('select tsv from mail_messages') where word = 'tattoo'; <br> word  | ndoc <br> --------+------ <br> tattoo |    2 <br> (1 row) <br></code> <br>  Are there any documents in which these tokens appear at the same time?  It turns out there is: <br><br> <code>fts=# select count(*) from mail_messages where tsv @@ to_tsquery('wrote &amp; tattoo'); <br> count <br> ------- <br> 1 <br> (1 row) <br></code> <br>  The question is how to execute this query.  If, as described above, to get lists of TIDs for both lexemes, the search will turn out to be obviously ineffective: we will have to iterate over more than two hundred thousand values, of which only one will be the result.  Fortunately, using the statistics of the scheduler, the algorithm understands that the ‚Äútoken‚Äù lexeme is often found, and the ‚Äútattoo‚Äù is rare.  Therefore, the search is performed on a rare lexeme, and the resulting two documents are then checked for the presence of the ‚Äúwrote‚Äù token in them.  As it can be seen - the request is executed quickly: <br><br> <code>fts=# \timing on <br> Timing is on. <br> <br> fts=# select count(*) from mail_messages where tsv @@ to_tsquery('wrote &amp; tattoo'); <br> count <br> ------- <br> 1 <br> (1 row) <br> Time: 0,959 ms <br></code> <br>  Although the search simply ‚Äúwrote‚Äù - significantly longer: <br><br> <code>fts=# select count(*) from mail_messages where tsv @@ to_tsquery('wrote'); <br> count <br> -------- <br> 231174 <br> (1 row) <br> Time: 2875,543 ms (00:02,876) <br></code> <br>  Such optimization works, of course, not only for two tokens, but also in more complex cases. <br><br><h3>  Sample limit </h3><br>  The peculiarity of the gin access method is that the result is always returned in the form of a <em>bitmap:</em> this method does not know how to issue TIDs one by one.  That is why all query plans that are encountered in this part use bitmap scan. <br><br>  Therefore, limiting a sample by index using the LIMIT clause is not quite effective.  Pay attention to the predicted cost of the operation (the ‚Äúcost‚Äù field of the Limit node): <br><br> <code>fts=# explain (costs off) <br> select * from mail_messages where tsv @@ to_tsquery('wrote') limit 1; <br> QUERY PLAN <br> ----------------------------------------------------------------------------------------- <br> Limit  (cost=1283.61..1285.13 rows=1) <br> -&gt;  Bitmap Heap Scan on mail_messages  (cost=1283.61..209975.49 rows=137207) <br> Recheck Cond: (tsv @@ to_tsquery('wrote'::text)) <br> -&gt;  Bitmap Index Scan on mail_messages_tsv_idx  (cost=0.00..1249.30 rows=137207) <br> Index Cond: (tsv @@ to_tsquery('wrote'::text)) <br> (5 rows) <br></code> <br>  The cost is estimated at 1283.61, which is slightly more than the cost of building the entire bitmap 1249.30 (the ‚Äúcost‚Äù field of the Bitmap Index Scan node). <br><br>  Therefore, the index has a special ability to limit the number of results.  The threshold value is set in the gin_fuzzy_search_limit configuration parameter and defaults to zero (no limit occurs).  However, it can be installed: <br><br> <code>fts=# set gin_fuzzy_search_limit = 1000; <br> SET <br> fts=# select count(*) from mail_messages where tsv @@ to_tsquery('wrote'); <br> count <br> ------- <br> 5746 <br> (1 row) <br> <br> fts=# set gin_fuzzy_search_limit = 10000; <br> SET <br> fts=# select count(*) from mail_messages where tsv @@ to_tsquery('wrote'); <br> count <br> ------- <br> 14726 <br> (1 row) <br></code> <br>  As you can see, the query produces a different number of rows for different values ‚Äã‚Äãof the parameter (if index access is used).  The restriction is not precise;  more lines than specified can be issued - therefore fuzzy. <br><br><h3>  Compact view </h3><br>  Among other things, GIN-indices are good for their compactness.  Firstly, if the same token is found in several documents (as it usually happens), it is stored only once in the index.  Secondly, TIDs are stored in an index in an orderly manner, and this makes it possible to use simple compression: each next one in the TID list is actually stored as the difference with the previous one ‚Äî usually a small number that requires much less bits than a full 6 -byte TID. <br><br>  To get some idea of ‚Äã‚Äãvolume, create a B-tree in the text of the letters.  Fair comparison, of course, does not work: <br><br><ul><li>  GIN is built on a different data type (tsvector, not text), but it‚Äôs smaller, </li><li>  but the size of the letters for the B-tree has to be shortened to about two kilobytes. </li></ul><br>  But nonetheless: <br><br> <code>fts=# create index mail_messages_btree on mail_messages(substring(body_plain for 2048)); <br> CREATE INDEX <br></code> <br>  At the same time, we will build the GiST index: <br><br> <code>fts=# create index mail_messages_gist on mail_messages using gist(tsv); <br> CREATE INDEX <br></code> <br>  The size of the index after complete cleaning (vacuum full): <br><br> <code>fts=# select pg_size_pretty(pg_relation_size('mail_messages_tsv_idx')) as gin, <br> pg_size_pretty(pg_relation_size('mail_messages_gist')) as gist, <br> pg_size_pretty(pg_relation_size('mail_messages_btree')) as btree; <br> gin  |  gist  | btree <br> --------+--------+-------- <br> 179 MB | 125 MB | 546 MB <br> (1 row) <br></code> <br>  Due to the compactness of the representation, the GIN index can be used to migrate from Oracle as a replacement for bitmap indexes (I won‚Äôt go into details, but for inquiring minds I‚Äôll leave a <a href="https://jonathanlewis.wordpress.com/2006/11/29/bitmap-indexes/">link to Lewis' post</a> ).  As a rule, bitmap indexes are used for fields that have some unique values ‚Äã‚Äã‚Äî which is fine for GIN as well.  And to build a bitmap, as we saw <a href="https://habrahabr.ru/company/postgrespro/blog/326096/">in the first part</a> , PostgreSQL can on the fly based on any index, including the GIN. <br><br><h3>  GiST or GIN? </h3><br>  For many data types, there are classes of operators for both GiST and GIN, which raises the question: what to use?  Perhaps, it is already possible to draw any conclusions. <br><br>  As a rule, GIN gains in accuracy and speed of search from GiST.  If the data does not change often, but you need to search quickly - most likely the choice will fall on the GIN. <br><br>  On the other hand, if the data changes actively, the overhead of updating the GIN may be too large.  In this case, you will have to compare both options and choose the one whose indicators will be better balanced. <br><br><h2>  Arrays </h2><br>  Another example of using the gin method is array indexing.  In this case, the elements of the arrays fall into the index, which allows speeding up a series of operations on them: <br><br> <code>postgres=# select amop.amopopr::regoperator, amop.amopstrategy <br> from pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <br> where opc.opcname = 'array_ops' <br> and opf.oid = opc.opcfamily <br> and am.oid = opf.opfmethod <br> and amop.amopfamily = opc.opcfamily <br> and am.amname = 'gin' <br> and amop.amoplefttype = opc.opcintype; <br> amopopr        | amopstrategy <br> -----------------------+-------------- <br> &amp;&amp;(anyarray,anyarray) |            1   <br> @&gt;(anyarray,anyarray) |            2    <br> &lt;@(anyarray,anyarray) |            3     <br> =(anyarray,anyarray)  |            4   <br> (4 rows) <br></code> <br>  Our <a href="https://postgrespro.ru/education/demodb">demo database</a> has routes with flight information.  Among other things, it contains the days_of_week column - an array of days of the week on which flights are made.  For example, a flight from Vnukovo to Gelendzhik departs on Tuesdays, Thursdays and Sundays: <br><br> <code>demo=# select departure_airport_name, arrival_airport_name, days_of_week <br> from routes <br> where flight_no = 'PG0049'; <br> departure_airport_name | arrival_airport_name | days_of_week <br> ------------------------+----------------------+-------------- <br>                 |             | {2,4,7} <br> (1 row) <br></code> <br>  To build the index, we ‚Äúmaterialize‚Äù the view into the table: <br><br> <code>demo=# create table routes_t as select * from routes; <br> SELECT 710 <br> demo=# create index on routes_t using gin(days_of_week); <br> CREATE INDEX <br></code> <br>  Now, using the index, we can find out all flights departing on Tuesdays, Thursdays and Sundays: <br><br> <code>demo=# explain (costs off) select * from routes_t where days_of_week = ARRAY[2,4,7]; <br> QUERY PLAN <br> ----------------------------------------------------------- <br> Bitmap Heap Scan on routes_t <br> Recheck Cond: (days_of_week = '{2,4,7}'::integer[]) <br> -&gt;  Bitmap Index Scan on routes_t_days_of_week_idx <br> Index Cond: (days_of_week = '{2,4,7}'::integer[]) <br> (4 rows) <br></code> <br>  It turns out, these 6 pieces: <br><br> <code>demo=# select flight_no, departure_airport_name, arrival_airport_name, days_of_week from routes_t where days_of_week = ARRAY[2,4,7]; <br> flight_no | departure_airport_name | arrival_airport_name | days_of_week <br> -----------+------------------------+----------------------+-------------- <br> PG0005    |             |                 | {2,4,7} <br> PG0049    |                 |             | {2,4,7} <br> PG0113    | -            |           | {2,4,7} <br> PG0249    |             |             | {2,4,7} <br> PG0449    |             |               | {2,4,7} <br> PG0540    |                 |               | {2,4,7} <br> (6 rows) <br></code> <br>  How is such a request?  In the same way as described above: <br><br><ol><li>  From the search query, whose role is played by the array {2,4,7}, the elements (search keys) are distinguished.  Obviously, these will be the values ‚Äã‚Äã"2", "4" and "7". </li><li>  In the element tree there are selected keys and for each of them a list of TIDs is selected. </li><li>  Of all the TIDs found, the consistency function selects those that fit the operator from the query.  For operator = only those TIDs that are met in all three lists are suitable (in other words, the initial array must contain all the elements).  But this is not enough: it is also necessary that the array does not contain any other values ‚Äã‚Äã‚Äî and we cannot check this condition by index.  Therefore, in this case, the access method asks the indexing mechanism to double-check all the issued TIDs in the table. </li></ol><br>  It is interesting that there are strategies (for example, ‚Äúcontained in an array‚Äù) that cannot check anything at all and are forced to recheck all the TIDs found in the table. <br><br>  But what if we need to find out flights departing on Tuesdays, Thursdays and Sundays from Moscow?  The additional condition will not be supported by the index and will fall into the Filter column: <br><br> <code>demo=# explain (costs off) <br> select * from routes_t where days_of_week = ARRAY[2,4,7] and departure_city = ''; <br> QUERY PLAN <br> ----------------------------------------------------------- <br> Bitmap Heap Scan on routes_t <br> Recheck Cond: (days_of_week = '{2,4,7}'::integer[]) <br> Filter: (departure_city = ''::text) <br> -&gt;  Bitmap Index Scan on routes_t_days_of_week_idx <br> Index Cond: (days_of_week = '{2,4,7}'::integer[]) <br> (5 rows) <br></code> <br>  In this case, it is not scary (the index already selects only 6 lines), but in cases where the additional condition increases the selectivity, I would like to have such an opportunity.  True, just create an index does not work: <br><br> <code>demo=# create index on routes_t using gin(days_of_week,departure_city); <br> ERROR:  data type text has no default operator class for access method "gin" <br> HINT:  You must specify an operator class for the index or define a default operator class for the data type. <br></code> <br>  But the <a href="https://postgrespro.ru/docs/postgresql/10/btree-gin">btree_gin</a> extension will help, adding classes of GIN operators that mimic the operation of a regular B-tree. <br><br> <code>demo=# create extension btree_gin; <br> CREATE EXTENSION <br> demo=# create index on routes_t using gin(days_of_week,departure_city); <br> CREATE INDEX <br> <br> demo=# explain (costs off) <br> select * from routes_t where days_of_week = ARRAY[2,4,7] and departure_city = ''; <br> QUERY PLAN <br> --------------------------------------------------------------------- <br> Bitmap Heap Scan on routes_t <br> Recheck Cond: ((days_of_week = '{2,4,7}'::integer[]) AND <br> (departure_city = ''::text)) <br> -&gt;  Bitmap Index Scan on routes_t_days_of_week_departure_city_idx <br> Index Cond: ((days_of_week = '{2,4,7}'::integer[]) AND <br> (departure_city = ''::text)) <br> (4 rows) <br></code> <br><h2>  Jsonb </h2><br>  Another example of a complex data type for which there is built-in GIN support is JSON.  To work with JSON values, a number of operators and functions are currently defined, some of which can be accelerated using indexes: <br><br> <code>postgres=# select opc.opcname, amop.amopopr::regoperator, amop.amopstrategy as str <br> from pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <br> where opc.opcname in ('jsonb_ops','jsonb_path_ops') <br> and opf.oid = opc.opcfamily <br> and am.oid = opf.opfmethod <br> and amop.amopfamily = opc.opcfamily <br> and am.amname = 'gin' <br> and amop.amoplefttype = opc.opcintype; <br> opcname    |    amopopr      | str <br> ----------------+------------------+----- <br> jsonb_ops      | ?(jsonb,text)    |  9      <br> jsonb_ops      | ?|(jsonb,text[]) |  10   -    <br> jsonb_ops      | ?&amp;(jsonb,text[]) |  11       <br> jsonb_ops      | @&gt;(jsonb,jsonb)  |  7  JSON-     <br> jsonb_path_ops | @&gt;(jsonb,jsonb)  |  7 <br> (5 rows) <br></code> <br>  There are, as you can see, two classes of operators: jsonb_ops and jsonb_path_ops. <br><br>  The first class of operators, jsonb_ops, is used by default.  All keys, values ‚Äã‚Äãand elements of arrays fall into the index as elements of the source JSON document.  To each of them, a sign is added whether this element is a key (this is necessary for ‚Äúexist‚Äù strategies that distinguish keys and values). <br><br>  For example, imagine several lines from routes in the form of JSON as follows: <br><br> <code>demo=# create table routes_jsonb as <br> select to_jsonb(t) route <br> from ( <br> select departure_airport_name, arrival_airport_name, days_of_week <br> from routes <br> order by flight_no limit 4 <br> ) t; <br> SELECT 4 <br> demo=# select ctid, jsonb_pretty(route) from routes_jsonb; <br> ctid  |                jsonb_pretty <br> -------+----------------------------------------------- <br> (0,1) | {                                            + <br> |    "days_of_week": [                        + <br> |        1                                    + <br> |    ],                                      + <br> |    "arrival_airport_name": "",        + <br> |    "departure_airport_name": "-"  + <br> | } <br> (0,2) | {                                            + <br> |    "days_of_week": [                        + <br> |        2                                    + <br> |    ],                                      + <br> |    "arrival_airport_name": "-",  + <br> |    "departure_airport_name": ""      + <br> | } <br> (0,3) | {                                            + <br> |    "days_of_week": [                        + <br> |        1,                                  + <br> |        4                                    + <br> |    ],                                      + <br> |    "arrival_airport_name": "",          + <br> |    "departure_airport_name": "-"+ <br> | } <br> (0,4) | {                                            + <br> |    "days_of_week": [                        + <br> |        2,                                  + <br> |        5                                    + <br> |    ],                                      + <br> |    "arrival_airport_name": "-", + <br> |    "departure_airport_name": ""        + <br> | } <br> (4 rows) <br> <br> demo=# create index on routes_jsonb using gin(route); <br> CREATE INDEX <br></code> <br>  The index may have the following form: <br><br><img src="https://habrastorage.org/webt/59/f1/2c/59f12cddc1d46346806251.png"><br><br>  Now, for example, such a query can be executed using an index: <br><br> <code>demo=# explain (costs off) <br> select jsonb_pretty(route) <br> from routes_jsonb <br> where route @&gt; '{"days_of_week": [5]}'; <br> QUERY PLAN <br> --------------------------------------------------------------- <br> Bitmap Heap Scan on routes_jsonb <br> Recheck Cond: (route @&gt; '{"days_of_week": [5]}'::jsonb) <br> -&gt;  Bitmap Index Scan on routes_jsonb_route_idx <br> Index Cond: (route @&gt; '{"days_of_week": [5]}'::jsonb) <br> (4 rows) <br></code> <br>  The <code>@&gt;</code> operator checks whether the specified path is present ( <code>"days_of_week": [5]</code> ), starting from the root of the JSON document.  In our case, the query returns one line: <br><br> <code>demo=# select jsonb_pretty(route) from routes_jsonb where route @&gt; '{"days_of_week": [5]}'; <br> jsonb_pretty <br> ---------------------------------------------- <br> {                                          + <br> "days_of_week": [                      + <br> 2,                                  + <br> 5                                  + <br> ],                                      + <br> "arrival_airport_name": "-",+ <br> "departure_airport_name": ""        + <br> } <br> (1 row) <br></code> <br>  The query is executed as follows: <br><br><ol><li>  From the search query ( <code>"days_of_week": [5]</code> ), elements (search keys) are highlighted: "days_of_week" and "5". </li><li>  In the tree of elements there are selected keys and for each of them a list of TIDs is selected: for ‚Äú5‚Äù - (0.4) and for ‚Äúdays_of_week‚Äù - (0.1), (0.2), (0.3) , (0.4). </li><li>  Of all the TIDs found, the consistency function selects those that fit the operator from the query.  For the <code>@&gt;</code> operator, documents that do not contain all the elements from the search query are definitely not suitable, so only (0.4) remains.  But the remaining TID must be rechecked against the table, because the index does not understand the order in which the found elements are found in the JSON document. </li></ol><br>  More information about other operators can be read <a href="https://postgrespro.ru/docs/postgresql/10/datatype-json.html">in the documentation</a> . <br><br>  In addition to regular operations for working with JSON, the jsquery extension has been around for a long time, defining a query language with richer capabilities (and, of course, with support for GIN indices).  And in 2016, the new SQL standard came out, which defines its own set of operations and the SQL / JSON path query language.  The implementation of this standard has already been <a href="https://commitfest.postgresql.org/15/1063/">completed</a> and we hope it will appear in PostgreSQL 11. <br><br><h2>  Inside </h2><br>  You can <a href="https://postgrespro.ru/docs/postgresql/10/pageinspect">look</a> inside the GIN index using the <a href="https://postgrespro.ru/docs/postgresql/10/pageinspect">pageinspect</a> extension. <br><br> <code>fts=# create extension pageinspect; <br> CREATE EXTENSION <br></code> <br>  Information from the metastpage shows general statistics: <br><br> <code>fts=# select * from gin_metapage_info(get_raw_page('mail_messages_tsv_idx',0)); <br> -[ RECORD 1 ]----+----------- <br> pending_head    | 4294967295 <br> pending_tail    | 4294967295 <br> tail_free_size  | 0 <br> n_pending_pages  | 0 <br> n_pending_tuples | 0 <br> n_total_pages    | 22968 <br> n_entry_pages    | 13751 <br> n_data_pages    | 9216 <br> n_entries        | 1423598 <br> version          | 2 <br></code> <br>  <a href="https://postgrespro.ru/docs/postgresql/10/storage-page-layout">The structure of the page</a> provides a special area, ‚Äúopaque‚Äù (opaque) for ordinary programs like cleaning (vacuum), in which access methods can store their information.  This data for the GIN is shown in the gin_page_opaque_info function.  For example, you can find out the composition of the index pages: <br><br> <code>fts=# select flags, count(*) <br> from generate_series(1,22967) as g(id), -- n_total_pages <br> gin_page_opaque_info(get_raw_page('mail_messages_tsv_idx',g.id)) <br> group by flags; <br> flags          | count <br> ------------------------+------- <br> {meta}                |    1   <br> {}                    |  133    B-  <br> {leaf}                | 13618    B-  <br> {data}                |  1497    B- TID- <br> {data,leaf,compressed} |  7719    B- TID- <br> (5 rows) <br></code> <br>  The gin_leafpage_items function returns information about TIDs stored in {data, leaf, compressed} pages: <br><br> <code>fts=# select * from gin_leafpage_items(get_raw_page('mail_messages_tsv_idx',2672)); <br> -[ RECORD 1 ]--------------------------------------------------------------------- <br> first_tid | (239,44) <br> nbytes    | 248 <br> tids      | {"(239,44)","(239,47)","(239,48)","(239,50)","(239,52)","(240,3)",... <br> -[ RECORD 2 ]--------------------------------------------------------------------- <br> first_tid | (247,40) <br> nbytes    | 248 <br> tids      | {"(247,40)","(247,41)","(247,44)","(247,45)","(247,46)","(248,2)",... <br> ... <br></code> <br>  Here you can see that the leaf pages of the TID tree actually do not contain separate pointers to table rows, but small compressed lists. <br><br><h2>  Properties </h2><br>  Let's look at the properties of the gin access method (the queries <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">were cited earlier</a> ): <br><br> <code>amname |    name      | pg_indexam_has_property <br> --------+---------------+------------------------- <br> gin    | can_order    | f <br> gin    | can_unique    | f <br> gin    | can_multi_col | t <br> gin    | can_exclude  | f <br></code> <br>  Interestingly, the GIN supports the creation of multi-column indexes.  At the same time, unlike the usual B-tree, not composite keys will be stored in it, but still separate elements, but only with indication of the column number. <br><br>  Index properties: <br><br> <code>name      | pg_index_has_property <br> ---------------+----------------------- <br> clusterable  | f <br> index_scan    | f <br> bitmap_scan  | t <br> backward_scan | f <br></code> <br>  Please note that one-by-one (index scan) results are not supported, only bitmap scan is possible. <br><br>  Backward scan is not supported: this feature is relevant only for index scanning, but not for scanning on a bitmap. <br><br>  And column level properties: <br><br> <code>name        | pg_index_column_has_property <br> --------------------+------------------------------ <br> asc                | f <br> desc              | f <br> nulls_first        | f <br> nulls_last        | f <br> orderable          | f <br> distance_orderable | f <br> returnable        | f <br> search_array      | f <br> search_nulls      | f <br></code> <br>  Nothing is available here: neither sorting (which is understandable), nor using an index as a cover (the document itself is not stored in the index), nor working with undefined values ‚Äã‚Äã(does not make sense for elements of a complex type). <br><br><h2>  Other data types </h2><br>  Here are some more extensions that add GIN support for some data types. <br><br><ul><li>  <a href="https://postgrespro.ru/docs/postgresql/10/pgtrg">pg_trgm</a> allows <a href="https://postgrespro.ru/docs/postgresql/10/pgtrg">you</a> to determine the "similarity" of words by comparing the number of matching sequences of three letters (trigrams).  Two classes of operators are added, gist_trgm_ops and gin_trgm_ops, supporting different operators, including comparison using LIKE and regular expressions.  This extension can be used in conjunction with full-text search in order to offer word variations for typos. <br></li><li>  <a href="https://postgrespro.ru/docs/postgresql/10/hstore">hstore</a> implements key-value storage.  For this data type, there are classes of operators for different access methods, including GIN.  Although, with the advent of the jsonb data type, there are no particular reasons to use hstore. <br></li><li>  <a href="https://postgrespro.ru/docs/postgresql/10/intarray">intarray</a> extends the functionality of integer arrays.  Index support includes both GiST and GIN (operator class gin__int_ops). <br></li></ul><br>  And two extensions have already been mentioned in the text: <br><br><ul><li>  <a href="https://postgrespro.ru/docs/postgresql/10/btree-gin">btree_gin</a> adds GIN support for common data types to use in a multi-column index along with complex types. <br></li><li>  <a href="https://postgrespro.ru/docs/postgrespro/9.6/jsquery">jsquery</a> defines the query language for JSON and the class of operators for its index support.  This extension is not included in the standard PostgreSQL distribution. <br></li></ul><br>  <a href="https://habrahabr.ru/company/postgrespro/blog/343488/">Continued</a> . </div><p>Source: <a href="https://habr.com/ru/post/340978/">https://habr.com/ru/post/340978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340966/index.html">High-quality image reduction in constant time</a></li>
<li><a href="../340968/index.html">Window shop in Vivaldi 1.13.997.3</a></li>
<li><a href="../340972/index.html">10 most simple and frequent mistakes on sites</a></li>
<li><a href="../340974/index.html">Student supercomputer competitions: instructions for use</a></li>
<li><a href="../340976/index.html">Photo storage and upload architecture in Badoo</a></li>
<li><a href="../340982/index.html">Mathematical model of a vibrating level gauge with a resonator in the form of a cantilever elliptical tube</a></li>
<li><a href="../340984/index.html">Ethereum smart contract to calculate bonuses using fractional degrees</a></li>
<li><a href="../340986/index.html">Six questions for FrontFest speakers</a></li>
<li><a href="../340992/index.html">Blockchain: how it works, and why this technology will change the world</a></li>
<li><a href="../340994/index.html">Crawler for crawler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>