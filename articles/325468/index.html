<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How not to step on a rake in Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post is a version of my English-language article "How to avoid gotchas in Go" , but the word gotcha is not translated into Russian, so I will use...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How not to step on a rake in Go</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>This post is a version of my English-language article <a href="https://divan.github.io/posts/avoid_gotchas/">"How to avoid gotchas in Go"</a> , but the word gotcha is not translated into Russian, so I will use this word without translation, and a little indirect option - "step on the rake."</em> </p><br><blockquote>  Gotcha is the correct design of a system, program, or programming language that works as described, but is counterintuitive and causes errors, since it is easy to use incorrectly. </blockquote><p>  In the Go language there are several such gotchas and there are quite a few good articles that <a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html">describe</a> and <a href="https://medium.com/%40Jarema./golang-slice-append-gotcha-e9020ff37374">explain</a> them <a href="https://go-traps.appspot.com/">in detail</a> .  I believe that these articles are very important, especially for newcomers to Go, because I regularly see people falling for the same rake. </p><br><p>  But one question tormented me for a long time - why did I never make these mistakes myself?  Seriously, the most popular of them, like a confusion with a nil-interface or an incomprehensible result with append () - e slices - have never been a problem in my practice.  Somehow I was lucky to get around these pitfalls from the first days of my work with Go.  What helped me? </p><br><p>  And the answer was quite simple.  I just read a few good articles about the internal structure of data structures in Go and other implementation details.  And this, quite superficial in fact, knowledge was enough to develop some intuition and avoid these pitfalls. </p><a name="habracut"></a><br><p>  Let's go back to the definition, <em>"gotcha ... this is a valid construction ... which is counterintuitive ..."</em> .  That's the whole point.  We actually have two options: </p><br><ul><li>  fix language </li><li>  fix intuition </li></ul><br><p>  The first option, which will appeal to many habratchitelemi, of course not an option.  In Go, there is a <a href="https://golang.org/doc/go1compat">promise of backward compatibility</a> - the language will not change anymore, and that's fine - programs written in 2012 are compiled today with the latest version of Go without a single Vorning.  By the way, there are no goings in Go :) </p><br><p>  The second option would be more correct to call <em>develop intuition</em> .  As soon as you learn how interfaces or slices work from the inside, intuition will prompt you more correctly and help you avoid mistakes.  This method has helped me well and will certainly help others.  Therefore, I decided to gather this basic knowledge of Go internals in one post, to help others develop intuition about how Go works from within. </p><br><p>  Let's start with a basic understanding of how data types are stored in memory.  Here is a brief list of what we will learn: </p><br><ul><li>  <a href="https://habrahabr.ru/post/325468/">Pointers</a> </li><li>  <a href="https://habrahabr.ru/post/325468/">Arrays</a> </li><li>  <a href="https://habrahabr.ru/post/325468/">Slices</a> </li><li>  <a href="https://habrahabr.ru/post/325468/">Append to slice (append)</a> </li><li>  <a href="https://habrahabr.ru/post/325468/">Interfaces</a> </li><li>  <a href="https://habrahabr.ru/post/325468/">Interface blank (interface {})</a> </li></ul><br><h1 id="ukazateli">  Pointers </h1><br><p> Go, with C in the genealogical tree, is actually quite close to the gland.  If you create an <code>int64</code> variable (a 64-bit integer value), you can be sure exactly how much space it takes in memory, and you can always use <a href="https://golang.org/pkg/unsafe/">unsafe.Sizeof ()</a> to find out for any other type. </p><br><p>  I really like to use a visual representation of data in memory to "see" the sizes of variables, arrays or data structures.  The visual approach helps to quickly understand the scale, develop intuition and clearly assess even things such as performance. </p><br><p>  For example, let's start with the simplest base types in Go: </p><br><p><img src="https://habrastorage.org/files/ab0/e26/533/ab0e26533e24410494d74fe55bd2d985.png" alt="image"></p><br><p>  For example, in such a visualization you can see that a variable of <em>int64</em> type will take twice as much ‚Äúspace‚Äù as <em>int32</em> , and <em>int</em> takes up as much as <em>int32</em> (implying that this is a 32-bit machine). </p><br><p>  Pointers, on the other hand, look a little more complicated - in fact, this is one block of memory that contains an address in memory that points to another block of memory where the data lies.  If you hear the phrase "dereference pointer", it means "to find data from the memory block pointed to by the address in the memory block of the pointer".  You can think of it this way: </p><br><p><img src="https://habrastorage.org/files/88a/377/a62/88a377a62fcd4cd2ad2d703d4659bc2a.png" alt="image"></p><br><p>  The address in memory is usually indicated in hexadecimal form, hence the "0x ..." in the picture.  But the important point here is that the ‚Äúmemory block of the pointer‚Äù can be in one place, and the ‚Äúdata pointed to by the address‚Äù can be completely different.  We need it a little further. </p><br><p>  And here we come to one of the gotchas in Go, which people encounter who have not had experience working with pointers in other languages ‚Äã‚Äã- this is a confusion in understanding what "transfer by value" of parameters in a function is.  As you probably know, everything is transferred to Go "by value", that is, it is literally copied.  Let's try to visualize it for functions in which the parameter is passed as it is and through the pointer: </p><br><p><img src="https://habrastorage.org/files/db2/249/550/db22495500b341cc9b9cffe13a3b5dd8.png" alt="image"></p><br><p>  In the first case, we copy all these blocks of memory - and, in reality, they can easily be more than 2, at least 2 million blocks, and they will all be copied, and this is one of the most expensive operations.  In the second case, we copy only one block of memory ‚Äî in which the address is stored in memory ‚Äî and this is fast and cheap.  However, for small data it is recommended to pass all the same by value, because pointers create an additional load on the GC, and, as a result, turn out to be more expensive, but about this somehow in another article. </p><br><p>  But now, having this visual representation, how pointers are passed to a function, you can naturally ‚Äúsee‚Äù that in the first case changing the variable <code>p</code> in the <code>Foo()</code> function, you will work with a copy and do not change the value of the original variable ( <code>p1</code> ), change the second one, since the pointer will refer to the original variable.  Although in either case, when passing parameters, data is copied. </p><br><p>  Okay, the warm-up is over, let's dig deeper and see things a little more complicated. </p><br><h1 id="massivy-i-slaysy">  Arrays and Slices </h1><br><p>  Slices are initially taken as a regular array.  But this is not the case, and, in fact, these are two different types in Go.  Let's first look at the arrays. </p><br><h2 id="massivy">  Arrays </h2><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr [...]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>}</code> </pre> <br><p>  An array is just a sequential set of memory blocks, and if we look at the Go source ( <a href="">src / runtime / malloc.go</a> ), we will see that creating an array is essentially just selecting a piece of memory of the right size.  Good old malloc, just a little smarter: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// newarray allocates an array of n elements of type typ. func newarray(typ *_type, n int) unsafe.Pointer { if n &lt; 0 || uintptr(n) &gt; maxSliceCap(typ.size) { panic(plainError("runtime: allocation size out of range")) } return mallocgc(typ.size*uintptr(n), typ, true) }</span></span></code> </pre> <br><p>  What does this mean for us?  This means that we can visually present an array simply as a set of memory blocks arranged one after the other: </p><br><p><img src="https://habrastorage.org/files/118/563/43b/11856343b99d4c8a83e4a3849c5a0944.png" alt="image"></p><br><p>  Each array element is always initialized with a <em>zero value of</em> this type ‚Äî 0 in this case, an array of integers of length 5. We can refer to them by index and use the built-in <code>len()</code> function to find out the size of the array.  When we refer to an individual element of an array by index and do something like this: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span></code> </pre> <br><p>  Then we simply take the fifth (4 + 1) element and change the value of this block in the memory: </p><br><p><img src="https://habrastorage.org/files/943/99a/c8b/94399ac8b8394858917c740331cc046c.png" alt="image"></p><br><p>  Okay, now let's figure it out with slices. </p><br><h2 id="slaysy">  Slices </h2><br><p>  At first glance, they look like arrays.  Well, that's very similar: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br><p>  But if we look at the Go source ( <a href="">src / runtime / slice.go</a> ), then we see that the slice is, in fact, a structure of three fields - a pointer to an array, length and capacity (capacity): </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> slice <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { array unsafe.Pointer <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> }</code> </pre> <br><p>  When you create a new slice, the runtime ‚Äúunder the hood‚Äù will create a new variable of this type, with a zero pointer ( <code>nil</code> ) and a length and capacity equal to zero.  This is the zero value for the slice.  Let's try to visualize it: </p><br><p><img src="https://habrastorage.org/files/04f/75f/05b/04f75f05b879490abc0744288a3b7e7b.png" alt="image"></p><br><p>  This is not very interesting, so let's initialize the slice of the size we need using the <code>make()</code> built-in command: </p><br><pre> <code class="go hljs">foo = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br><p>  This command will first create an array of 5 elements (allocate memory and fill them with zeros), and set the values ‚Äã‚Äãof <code>len</code> and <code>cap</code> to 5. <code>Cap</code> means capacity and helps to reserve memory space for the future to avoid unnecessary memory allocations as the slice grows.  You can use a slightly more advanced form - <code>make([]int, len, cap)</code> to specify the capacity initially.  To work confidently with slices, it is important to understand the difference between length and capacity. </p><br><pre> <code class="go hljs">foo = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br><p>  Let's look at both calls: </p><br><p><img src="https://habrastorage.org/files/99d/104/4f9/99d1044f9f4b4b5884353c52af85bb14.png" alt="image"></p><br><p>  Now, combining our knowledge of how pointers, arrays and slices are arranged, let's visualize what happens when we call the following code: </p><br><pre> <code class="go hljs">foo = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) foo[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span> foo[<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">100</span></span></code> </pre> <br><p><img src="https://habrastorage.org/files/ef4/eb0/d0b/ef4eb0d0b6604d8a9617977d1c1927ec.png" alt="image"></p><br><p>  It was easy.  But what happens if we create a new sub-element from <code>foo</code> and change some element?  Let's get a look: </p><br><pre> <code class="go hljs">foo = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) foo[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span> foo[<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">100</span></span> bar := foo[<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] bar[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">99</span></span></code> </pre> <br><p><img src="https://habrastorage.org/files/c88/3dd/6c6/c883dd6c66654f30a7f00eb42eb909c2.png" alt="image"></p><br><p>  Seen the same?  By modifying the <code>bar</code> slice, we actually change the array, but this is the same array that the <code>foo</code> slice points to.  And this is, in fact, the real thing - you can write code like this: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> digitRegexp = regexp.MustCompile(<span class="hljs-string"><span class="hljs-string">"[0-9]+"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDigits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span></span> { b, _ := ioutil.ReadFile(filename) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> digitRegexp.Find(b) }</code> </pre> <br><p>  And, say, having read 10MB of data in a slice from a file, find 3 bytes containing digits, but you will return a slice that refers to an array of 10MB in size! </p><br><p><img src="https://habrastorage.org/files/608/3f5/4aa/6083f54aab664d69829c4c7673d4919b.png" alt="image"></p><br><p>  And this is one of the most frequently mentioned gotchas in Go.  But now, clearly understanding how it works, it will be hard for you to make such an error. </p><br><h1 id="dobavlenie-k-slaysu-append">  Append to slice (append) </h1><br><p>  Following a tricky error with slices, there is a not very obvious behavior of the built-in function <code>append()</code> .  She, in principle, makes one simple operation - adds elements to it.  But under the hood there are made quite complex manipulations to allocate memory only when necessary and do it effectively. </p><br><p>  Take a look at the following code: </p><br><pre> <code class="go hljs">a := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>) a = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(a, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  He creates a new slice of 32 integers and adds another, 33rd element to it. </p><br><p>  Remember about <code>cap</code> - slice capacity?  Capacity means the amount of allocated space for an array.  The <code>append()</code> function checks if the slice has enough space to add another element there, and if not, allocates more memory.  Memory allocation is always an expensive operation, so <code>append()</code> tries to optimize it, and in this case it requests memory not for one variable, but for 32 more - twice as large as the initial size.  Allocating a pack of memory once is cheaper than many times in pieces. </p><br><p>  The unobvious thing here is that for various reasons, allocating memory usually means allocating it to a different address and moving data from the old place to the new.  This means that the address of the array referenced by the slice will also change!  Let's visualize this: </p><br><p><img src="https://habrastorage.org/files/efa/e92/0b7/efae920b744b49eba4ed0d6ba00274ab.png" alt="image"></p><br><p>  It is easy to see two arrays - old and new.  It seems to be nothing complicated, and the garbage collector will simply free up the space occupied by the old array on the next pass.  But this is, in fact, one of those very gotchas with slices.  What if we make the sub- <code>b</code> , then increase the slice <code>a</code> , meaning that they use the same array? </p><br><pre> <code class="go hljs">a := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>) b := a[<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">16</span></span>] a = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(a, <span class="hljs-number"><span class="hljs-number">1</span></span>) a[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span></code> </pre> <br><p>  We get this: </p><br><p><img src="https://habrastorage.org/files/06a/855/8e4/06a8558e4d1b4c4cb95e9e5932b467b8.png" alt="image"></p><br><p>  This is how we get two different arrays, and two slices will point to completely different memory areas!  And this, to put it mildly, is quite counterintuitive, agree.  Therefore, as a rule, if you work with <code>append()</code> and subslices - be careful and keep in mind this feature. </p><br><p>  By the way, <code>append()</code> increases the slice by doubling only up to 1024 bytes, and then starts using a different approach - the so-called "memory size classes", which guarantee that no more than ~ 12.5% ‚Äã‚Äãwill be allocated.  Allocating 64 bytes for a 32-byte array is normal, but if a 4GB slice, then allocating another 4GB, even if we want to add only one element, is too expensive. </p><br><h1 id="interfeysy">  Interfaces </h1><br><p>  Okay, interfaces are probably the weirdest thing in Go.  Usually it takes some time before understanding fits into your head, especially after the difficult consequences of long work with classes in other languages.  And one of the most popular problems is understanding the <code>nil</code> interface. </p><br><p>  As usual, let's go to the Go source code.  What is the interface?  This is the usual structure of two fields, here is its definition ( <a href="">src / runtime / runtime2.go</a> ): </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> iface <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { tab *itab data unsafe.Pointer }</code> </pre> <br><p>  <code>itab</code> stands for <em>interface table</em> and is also a structure in which additional information about the interface and the base type is stored: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> itab <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { inter *interfacetype _type *_type link *itab bad <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> unused <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> fun [<span class="hljs-number"><span class="hljs-number">1</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">uintptr</span></span> <span class="hljs-comment"><span class="hljs-comment">// variable sized }</span></span></code> </pre> <br><p>  Now we will not go into how type conversion works in interfaces, but it is important to understand that, by its very nature, an interface is just a set of data about types (interface and type of variable inside it) and a pointer to the variable itself with static (specific) type ( <code>data</code> field in <code>iface</code> ).  Let's see how it looks and define the <code>err</code> variable of the interface type <code>error</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error</code> </pre> <br><p><img src="https://habrastorage.org/files/8fd/a1f/773/8fda1f773e5f4755952fde1f5d28f0d0.png" alt="image"></p><br><p>  What we see on this visualization is the nil interface.  When we return <code>nil</code> in the function that returns <code>error</code> , we return exactly this object.  It stores information about the interface itself ( <code>itab.inter</code> ), but the <code>data</code> and <code>itab.type</code> empty - equal to <code>nil</code> .  Comparing this object with <code>nil</code> will return <code>true</code> in the <code>if err == nil {}</code> condition. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error <span class="hljs-comment"><span class="hljs-comment">// nil return err } err := foo() if err == nil {...} // true</span></span></code> </pre> <br><p>  Now, take a look at this case here, which is also the famous gotcha in Go: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err *os.PathError <span class="hljs-comment"><span class="hljs-comment">// nil return err } err := foo() if err == nil {...} // false</span></span></code> </pre> <br><p>  These two pieces of code are very similar if you don‚Äôt know what the interface is.  But let's see how the <code>error</code> interface looks like, in which a variable of the type <code>*os.PathError</code> is "wrapped": </p><br><p><img src="https://habrastorage.org/files/716/394/057/716394057eb94e58b2ddc86dcd6493e0.png" alt="image"></p><br><p>  We clearly see here the variable of the type <code>*os.PathError</code> is a piece of memory in which <code>nil</code> written, because it is a zero value for any pointer.  But the object that we return from the <code>foo()</code> function is already a more complex structure, which stores not only information about the interface, but also information about the type of the variable, and the address in memory for the block that contains the <code>nil</code> pointer.  Feel the difference? </p><br><p>  In both cases we see <code>nil</code> as it were, but there is a big difference between <em>"interface with variable inside, whose value is nil"</em> and <em>"interface without variable inside"</em> .  Now, understanding this difference, try confusing these two examples: </p><br><p><img src="https://habrastorage.org/files/ac9/905/1fb/ac99051fbb924e6d8912f479915b7a78.png" alt="image"></p><br><p>  Now it should be difficult for you to come across such a problem in your code. </p><br><h1 id="pustoy-interfeys-empty-interface">  Empty interface </h1><br><p>  A few words about the so-called empty interface - <code>interface{}</code> .  In Go sources, it is implemented by a separate structure - <code>eface</code> ( <a href="">src / runtime / malloc.go</a> ): </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> eface <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { _type *_type data unsafe.Pointer }</code> </pre> <br><p>  It is easy to see that this structure is similar to <code>iface</code> , but it does not have an interface table (itab).  Which is logical, because, by definition, any static type satisfies an empty interface.  Therefore, when you "wrap" a variable ‚Äî either explicitly or implicitly (passing as an argument or returning from a function, for example) <code>interface{}</code> , you are actually working with this structure. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { foo := <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(<span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo }</code> </pre> <br><p><img src="https://habrastorage.org/files/4db/6d7/e57/4db6d7e5728c4cba841bad4a0d055aa1.png" alt="image"></p><br><p>  One of the known problems with an empty interface is that it is impossible to bring a slice of specific types to an interface slice in one fell swoop.  If you write something like this: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>} }</code> </pre> <br><p>  Kompliyator quite clearly swear: </p><br><pre> <code class="hljs sql">$ go build cannot <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> []<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> literal (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> []<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> argument</code> </pre> <br><p>  At first, it is confusing.  Like, what's the matter - I can bring one variable of any type into an empty interface, why can't I do the same with a slice?  But when you know what an empty interface is and how the slices are arranged, then you must intuitively understand that this ‚Äúslice cast‚Äù is actually a rather expensive operation, which will involve going through the entire slice length and allocating memory directly proportional number of items.  And, since one of the principles in Go is - <strong>you want to do something expensive - do it explicitly</strong> , then such a conversion is left to the programmer. </p><br><p>  Let's try to visualize what the cast of <code>[]int</code> in <code>[]interface{}</code> : </p><br><p><img src="https://habrastorage.org/files/43d/7d2/4ad/43d7d24ad23345d38763ed5be2b425e8.png" alt="image"></p><br><p>  Hopefully now this moment makes sense for you. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  Of course, not all gotchas and misunderstandings of the language can be solved by delving into the guts of realization.  Some of them are just the difference between the old and the new experience, and it is different for all of us.  And yet, the most popular of them, this approach helps to get around.  I hope this post will help you to understand more deeply what is happening in your programs and how Go is arranged under the hood.  Go is your friend, and knowing him a little better will always benefit. </p><br><p>  If you are interested in reading more about Go internals, here is a small selection of articles that helped me in my time: </p><br><ul><li>  <a href="http://research.swtch.com/godata">Go Data Structures</a> </li><li>  <a href="http://research.swtch.com/interfaces">Go Data Structures: Interfaces</a> </li><li>  <a href="https://blog.golang.org/go-slices-usage-and-internals">Go Slices: usage and internals</a> </li><li>  <a href="http://talks.godoc.org/github.com/davecheney/presentations/gopher-puzzlers.slide">Gopher puzzlers</a> </li></ul><br><p>  Well, of course, as without these resources :) </p><br><ul><li>  <a href="https://golang.org/src/">Go sources</a> </li><li>  <a href="https://golang.org/doc/effective_go.html">Effective go</a> </li><li>  <a href="https://golang.org/ref/spec">Go specification</a> </li></ul><br><p>  Good coding! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/325468/">https://habr.com/ru/post/325468/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325456/index.html">Create a bot for Skype. Step by step through REST API and in Python</a></li>
<li><a href="../325458/index.html">Secure access from anywhere in the world using Microsoft DirectAccess and Windows To Go. Part One - Theory</a></li>
<li><a href="../325460/index.html">Product Design Digest March 2017</a></li>
<li><a href="../325462/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ256 (March 27 - April 2, 2017)</a></li>
<li><a href="../325464/index.html">Vector pictures with gradient in Android 5.0</a></li>
<li><a href="../325470/index.html">How to understand and make friends with transactions and JPA</a></li>
<li><a href="../325472/index.html">Decorating life with gdb PrettyPrinting API</a></li>
<li><a href="../325476/index.html">Flexible release planning for 101 releases (based on Excel)</a></li>
<li><a href="../325478/index.html">Composition or inheritance: how to choose?</a></li>
<li><a href="../325480/index.html">Matreshka.js 2 - tl; dr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>