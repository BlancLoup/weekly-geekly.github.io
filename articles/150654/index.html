<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to copy an array correctly and what does it have to do with SFINAE</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Copy items from one container to another? There is nothing easier, the universal algorithm is placed in 5 lines: 

template<class InputIterator, class...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to copy an array correctly and what does it have to do with SFINAE</h1><div class="post__text post__text-html js-mediator-article">  Copy items from one container to another?  There is nothing easier, the universal algorithm is placed in 5 lines: <pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> InputIterator, <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> OutputIterator&gt; OutputIterator <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>(InputIterator first, InputIterator last, OutputIterator result) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(first != last) *result++ = *first++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre>  You may have learned the implementation of <a href="http://www.cplusplus.com/reference/algorithm/copy/">std :: copy from cplusplus.com</a> .  Why does the implementation of std :: copy from GNU STL take 139 lines?  Let's see. <a name="habracut"></a><br>  STL is the most basic library used by all normal C ++ programs.  Therefore, it should provide the most efficient implementations of the algorithms.  And effective in many ways: <ul><li>  Execution speed </li><li>  Size generated by the compiler code </li><li>  Memory consumption </li><li>  Compilation speed </li></ul><h2>  Execution speed </h2>  The code can be made faster if you consider the features of the types by which the template is instantiated.  For example, if a type has a trivial copy constructor, it can be copied byte-by-byte.  And if the objects lie in a continuous memory area, instead of repeatedly calling the constructor, you can use the good old C function memmove, which can use vector processor commands that copy data especially quickly.  Please note that the implementation of std :: copy cannot use memcpy, since memcpy works only on non-overlapping memory areas. <br>  Thus, we want to write two implementations of std :: copy: one fast, for trivially copied types, and the other universal, for all others. <h2>  SFINAE </h2>  And here comes a technique known as "substitution failure is not an error".  If the substitution of template parameters results in an incorrect expression, this is not an error.  The compiler should ignore the pattern and continue searching.  It is important that in the case of a template function, an incorrect expression should not be found in the body of the function, when a particular template has already been selected and there is nowhere to continue the search, but in its prototype.  The easiest way to do this is to use std :: enable_if. <h3>  std :: enable_if </h3>  By itself, enable_if is very simple.  This is a pattern from an integral constant and type.  If the constant is true, then it contains a nested type declaration named type, otherwise it is empty. <pre> <code class="hljs pgsql"> // Define a nested <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> predicate holds. // <span class="hljs-keyword"><span class="hljs-keyword">Primary</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>. /// enable_if <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-type"><span class="hljs-type">bool</span></span>, typename _Tp = <span class="hljs-type"><span class="hljs-type">void</span></span>&gt; struct enable_if { }; // Partial specialization <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename _Tp&gt; struct enable_if&lt;<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, _Tp&gt; { typedef _Tp <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>; };</code> </pre>  Type of <pre> <code class="hljs pgsql">std::enable_if&lt;, <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>&gt;::<span class="hljs-keyword"><span class="hljs-keyword">type</span></span></code> </pre>  will be defined and have type Type, but only if the condition is true.  Use it like this: <pre> <code class="hljs pgsql">//      <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> T&gt; std::enable_if&lt;<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> get_t() {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> T();} //     <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> T&gt; std::enable_if&lt;<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> get_t() {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> T();}</code> </pre><h3>  type traits </h3>  To make everything described above make sense, you need to have constants that depend on the type.  They are called type traits.  These are template structures that have a static constant public property value, which is true or false, depending on the type by which the template is instantiated.  Some of them are described using partial template specialization, some are implemented by the compiler itself, and some are built as expressions over other type traits. <h2>  Special implementation of std :: copy </h2>  <b>Before the</b> universal implementation we add the following: <pre> <code class="hljs kotlin">template&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; //  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gcc</span></span></span><span class="hljs-class"> 4.5  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">:is_trivially_copiable</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">     //inline typename std::enable_if</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">std::is_trivially_copiable&lt;T</span></span></span><span class="hljs-class">&gt;:</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">:value</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T*&gt;::type inline typename std::enable_if</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">std::is_trivial&lt;T</span></span></span><span class="hljs-class">&gt;:</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">:value</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T*&gt;::type copy</span></span></span></span>(T* first, T* last, T* result) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ptrdiff_t num = last - first; memmove(result, first, sizeof(T) * num); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result + num; }</code> </pre>  If copy is invoked with three pointers to the trivially copied type, the compiler will apply this optimized implementation.  Otherwise, this template will be ignored and the universal version will be used. <br>  In a real library, everything is a bit more complicated, because the standard states that std :: copy has two template parameters.  If the programmer explicitly indicates them, you still need to choose an optimized version.  Therefore, various implementations are described under utility names, and in the std :: move itself there is a code that selects the most appropriate implementation.  Here is a significantly simplified version: <pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstring&gt;</span></span></span><span class="hljs-meta"> // :     C++11. //  C++03   type_traits (     ) //      . //  is_simple,   memmove,    . //      . template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;bool is_simple&gt;</span></span></span><span class="hljs-meta"> struct __do_copy; //    ,   _.    //        . //        ,      //  .         std::copy template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&gt;</span></span></span><span class="hljs-meta"> struct __do_copy</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;true&gt;</span></span></span><span class="hljs-meta"> { //      //     ,      //  memmove  . template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class InputIterator, class OutputIterator&gt;</span></span></span><span class="hljs-meta"> static inline OutputIterator do_copy(InputIterator first, InputIterator last, OutputIterator result) { typedef typename std::iterator_traits</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;InputIterator&gt;</span></span></span><span class="hljs-meta">::value_type ValueType; const std::ptrdiff_t num = last - first; memmove(result, first, sizeof(ValueType) * num); return result + num; } }; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&gt;</span></span></span><span class="hljs-meta"> struct __do_copy</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;false&gt;</span></span></span><span class="hljs-meta"> { //   template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class InputIterator, class OutputIterator&gt;</span></span></span><span class="hljs-meta"> static inline OutputIterator do_copy(InputIterator first, InputIterator last, OutputIterator result) { while(first != last) *result++ = *first++; return result; } }; //  trait      //    STL   template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename, typename&gt;</span></span></span><span class="hljs-meta"> struct are_same : public std::false_type {}; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename Tp&gt;</span></span></span><span class="hljs-meta"> struct are_same</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Tp, Tp&gt;</span></span></span><span class="hljs-meta">: public std::true_type {}; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class InputIterator, class OutputIterator&gt;</span></span></span><span class="hljs-meta"> inline InputIterator copy( InputIterator first, InputIterator last, OutputIterator result) { //  typename    ,  value_type  // , , .   . typedef typename std::iterator_traits</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;InputIterator&gt;</span></span></span><span class="hljs-meta">::value_type ValueTypeI; typedef typename std::iterator_traits</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;OutputIterator&gt;</span></span></span><span class="hljs-meta">::value_type ValueTypeO; const bool is_simple = ( std::is_trivial</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ValueTypeI&gt;</span></span></span><span class="hljs-meta">::value &amp;&amp; std::is_pointer</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;InputIterator&gt;</span></span></span><span class="hljs-meta">::value &amp;&amp; std::is_pointer</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;OutputIterator&gt;</span></span></span><span class="hljs-meta">::value &amp;&amp; are_same</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ValueTypeI, ValueTypeO&gt;</span></span></span><span class="hljs-meta">::value); //    return __do_copy</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;is_simple&gt;</span></span></span><span class="hljs-meta">::do_copy(first, last, result); }</span></span></code> </pre>  In addition, another optimization is used in GNU STL: for a random access iterator, a for loop is used to calculate the number of iterations.  The compiler is able to develop such cycles, increasing the speed of the program. <h2>  Size of generated code </h2>  Please note that the template at the beginning of the article will generate a completely new code for each new type.  The second pattern degenerates into one subtraction and one addition of pointers, and the memmove implementation is common to all types.  That is, in addition to speeding up the program, its size decreases.  Similar tricks can be used in containers: parts that are not dependent on the stored type are removed from the template and use a common implementation.  For example, in the implementation of std :: list, the template structure storing data contains nothing but the data itself.  References to neighbors and operations on them are implemented in the base non-template class, from which it is inherited. <h2>  Use library functions </h2>  The moral of this article is simple: use the algorithms provided by the standard library as often as possible.  It makes your programs <b>more efficient, more understandable and more flexible</b> . <br>  <b>More efficiently</b> because developers of standard libraries can apply optimizations that you cannot afford in normal code.  You are not ready to write and support several implementations of copying objects for a dozen platforms?  An application programmer has no time for this. <br>  <b>It is more understandable</b> because you can write a short high-level code, operating with primitives familiar to your colleagues. <br>  <b>More flexible</b> because you don‚Äôt have to do premature optimizations and because you use more general algorithms than you would write yourself. <h2>  PS </h2>  Note that std :: copy knows that result is not between start and finish, but uses the memmove function, which is forced to check this and select the copy direction (from beginning to end or from end to beginning).  It was possible to make a slightly more optimal implementation, but then the STL developers would have to support special implementations for each of the supported architectures.  The glibc developers are already spending their time on this.  Nobody needs to duplicate this work. </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/150654/">https://habr.com/ru/post/150654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150648/index.html">IconBIT STB330DVBT2 review: Affordable TV set-top box with support for DVB-T2 or preparing a sleigh from summer</a></li>
<li><a href="../150649/index.html">Valve like open source technology</a></li>
<li><a href="../150650/index.html">The digest of interesting news and materials from the world of ayti for the last week ‚Ññ20 (August 25 - 31, 2012)</a></li>
<li><a href="../150651/index.html">Ruby NoName Podcast S04E16</a></li>
<li><a href="../150652/index.html">Windows 8 is a work of art. But this is not Linux</a></li>
<li><a href="../150655/index.html">Interception of video in the browser or TCP sniffer under Windows on the knee (part one)</a></li>
<li><a href="../150656/index.html">web site (story)</a></li>
<li><a href="../150657/index.html">Real-time log analysis</a></li>
<li><a href="../150658/index.html">Raising money for a space elevator</a></li>
<li><a href="../150661/index.html">Putting dots on Li: Do I need to train lithium batteries?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>