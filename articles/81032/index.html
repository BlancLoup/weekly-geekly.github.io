<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>GOST 28147-89 (Part 2. Simple replacement mode)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a continuation of the article about GOST 28147-89 . As mentioned earlier, GOST 28147-89 supports four modes of operation, but perhaps ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>GOST 28147-89 (Part 2. Simple replacement mode)</h1><div class="post__text post__text-html js-mediator-article">  This article is a continuation of the <a href="http://habrahabr.ru/blogs/infosecurity/80967/">article about GOST 28147-89</a> .  As mentioned earlier, GOST 28147-89 supports four modes of operation, but perhaps the main one is the simple replacement mode, which is used both independently and as an integral part of other modes. <h5>  The article provides c ++ code that implements this mode. </h5><a name="habracut"></a>  To understand how GOST 28147-89 works in this mode, you need to consider the following scheme: <img src="http://i.fotometka.ru/16669.jpg"><h3>  Actually, the essence </h3><h4>  Encryption </h4><ol><li>  Open data is divided into blocks of 64 bits. </li><li>  Next, enter the first block in drives <em>N <sub>1</sub></em> and <em>N <sub>2</sub></em> .  In this case, the bits of open information are entered as follows: The 1st bit of the open information is entered into the 1st bit of drive <em>N <sub>1</sub></em> , ..., the 32nd bit into the 32nd bit of drive <em>N <sub>1</sub></em> , the 33rd bit into the 1st discharge of drive <em>N <sub>2</sub></em> and so on until the 64th bit of the open information is entered into the 32nd discharge of drive <em>N <sub>2</sub></em> . </li><li>  A key with a length of 256 bits is inserted into the KZU in the manner described in the article <a href="http://habrahabr.ru/blogs/infosecurity/80967/">GOST 28147-89 (Part 1. Introduction and general principles)</a> . </li><li><h4>  Encryption of open data is performed in the simple replacement mode (in 32 cycles): </h4><ol><li>  In the first cycle, the contents of the register <em>N <sub>1 is</sub></em> summed with the filling of <em>X <sub>0</sub></em> from a KZU modulo 2 <sup>32</sup> in the adder <em>CM <sub>1</sub></em> . </li><li>  In the substitution block K, 32 bits of information received from the adder <em>CM <sub>1</sub></em> are replaced according to the rules discussed in the <a href="http://habrahabr.ru/blogs/infosecurity/80967/">first article</a> . </li><li>  In the shift register <em>R, there</em> is a cyclic shift by 11 in the direction of the higher digit. </li><li>  Information from the shift register <em>R</em> and the drive <em>N <sub>2 is</sub></em> summed modulo 2 in the adder <em>CM <sub>2</sub></em> . </li><li>  The old filling of drive <em>N <sub>1 is</sub></em> rewritten to drive <em>N <sub>2</sub></em> . </li><li>  The result from the output of the adder <em>CM <sub>2</sub></em> corresponds to the drive <em>N <sub>1</sub></em> . </li><li>  The first cycle ends. </li></ol></li><li>  Subsequent cycles are similar to the first, with the only difference that in the 2nd cycle the key <em>X <sub>1</sub></em> is entered, in the 8th, X7, in the 9th, X0 and so on in the same order up to 24 cycles.  From 25 to 32 cycle, the key is entered in the reverse order: <em>X <sub>7</sub></em> - in the 25th, <em>X <sub>0</sub></em> - in the 32nd. </li><li>  After the 32nd cycle in <em>N <sub>1 the</sub></em> information is saved, but the result from the output of the <em>CM <sub>2</sub></em> adder is rewritten in <em>N <sub>2</sub></em> . </li><li>  The filling of <em>N <sub>1</sub></em> and <em>N <sub>2</sub></em> is the first block of encrypted data. </li><li>  The following blocks are encrypted in the same way. </li></ol><h4>  Decryption </h4>  Decryption is carried out using the same algorithm as encryption, only encrypted data divided into blocks of 64 bits are sent to the input of drives <em>N <sub>1</sub></em> and <em>N <sub>2.</sub></em> Another important difference is that in direct order ( <em>X <sub>0</sub></em> through <em>X <sub>7</sub></em> ) the key is entered only in the first 8 cycles of the RPT, in the rest - in the reverse ( <em>X <sub>7</sub></em> through <em>X <sub>0</sub></em> ). And so, after passing 32 cycles, the drives <em>N <sub>1</sub></em> and <em>N <sub>2</sub></em> contain blocks of open data. <h3>  Explain all of the above with C ++ code. </h3>  This code was written in console mode in C ++ Builder 6 for a long time and does not claim to be the best, so do not hit hard, there is no time to optimize.  Simply, it works, and, rather quickly. <h6>  gost28147.cpp </h6><pre> // ------------------------------------------------ ---------------------------
 #include &lt;vcl.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;conio.h&gt;

 // ------------------------------------------------ ---------------------------

 // taken from the help, determine the file size
 long filesize (FILE * stream)
 {
  long curpos, length;
  curpos = ftell (stream);
  fseek (stream, 0L, SEEK_END);
  length = ftell (stream);
  fseek (stream, curpos, SEEK_SET);
  return length;
 }

 // function that implements the work of GOST 28147-89 in the simple replacement mode
 void rpz (int rezh, char * opener, char * saver)
 {
  FILE * f_begin, * f_end;  // streams for source and destination files

  // replacement table
  byte Tab_Z [8] [16] =
  {
   0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA, 0xB, 0xC, 0xD, 0xE, 0xF,
   0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA, 0xB, 0xC, 0xD, 0xE, 0xF,
   0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA, 0xB, 0xC, 0xD, 0xE, 0xF,
   0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA, 0xB, 0xC, 0xD, 0xE, 0xF,
   0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA, 0xB, 0xC, 0xD, 0xE, 0xF,
   0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA, 0xB, 0xC, 0xD, 0xE, 0xF,
   0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA, 0xB, 0xC, 0xD, 0xE, 0xF,
   0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA, 0xB, 0xC, 0xD, 0xE, 0xF
  };

 // key
  unsigned long key [8] =
  {
   0x0123,
   0x4567
   0x89AB,
   0xCDEF,
   0x0123,
   0x4567
   0x89AB,
   0xCDEF
  };

  char N [4];  // 32-bit drive

  unsigned long n1 = 0, n2 = 0, SUM232 = 0;  // drives N1, N2, and adder

  // open files
  f_begin = fopen (opener, "rb");
  f_end = fopen (saver, "wb");

  // determine the number of blocks
  float blokoff;
  blokoff = 8 * filesize (f_begin);
  blokoff = blokoff / 64;
  int block = blokoff;
  if (blokoff-block&gt; 0) block ++;

  int sh;
  if (filesize (f_begin)&gt; = 4) sh = 4;  else sh = filesize (f_begin);
  int sh1 = 0;
  int flag = 0;

  // start reading and converting blocks
  // there are checks for the completeness of the blocks to read only the required number of bits
  for (int i = 0; i &lt;block; i ++)
  {
   // write to drive N1
   for (int q = 0; q &lt;4; q ++) * ((byte *) &amp; N + q) = 0x00;
   if ((sh1 + sh) &lt;filesize (f_begin))
   {
    fread (N, sh, 1, f_begin);
    sh1 + = sh;
   }
   else
   {
    sh = filesize (f_begin) -sh1;
    fread (N, sh, 1, f_begin);
    flag = 1;
   }
   n1 = * ((unsigned long *) &amp; N);

   // write to N2 drive
   for (int q = 0; q &lt;4; q ++) * ((byte *) &amp; N + q) = 0x00;
   if ((sh1 + sh) &lt;filesize (f_begin))
   {
    fread (N, sh, 1, f_begin);
    sh1 + = sh;
   }
   else
   {
    if (flag == 0)
    {
     sh = filesize (f_begin) -sh1;
     fread (N, sh, 1, f_begin);
    } 
   }
   n2 = * ((unsigned long *) &amp; N);

   // 32 simple replacement cycles
   // read the key in the required GOST order
   int c = 0;
   for (int k = 0; k &lt;32; k ++)
   {
    if (rezh == 1) {if (k == 24) c = 7;  }
     else {if (k == 8) c = 7;  }

    // sum in the adder CM1
    SUM232 = key [c] + n1;

    // replace by replacement table
    byte first_byte = 0, second_byte = 0, zam_symbol = 0;
    int n = 7;
    for (int q = 3; q&gt; = 0; q--)
    {
     zam_symbol = * ((byte *) &amp; SUM232 + q);
     first_byte = (zam_symbol &amp; 0xF0) &gt;&gt; 4;
     second_byte = (zam_symbol &amp; 0x0F);
     first_byte = Tab_Z [n] [first_byte];
     n--;
     second_byte = Tab_Z [n] [second_byte];
     n--;
     zam_symbol = (first_byte &lt;&lt; 4) |  second_byte;
     * ((byte *) &amp; SUM232 + q) = zam_symbol;
    } 
   
    SUM232 = (SUM232 &lt;&lt; 11) | (SUM232 &gt;&gt; 21);  // cyclic shift by 11
    SUM232 = n2 ^ SUM232;  // add in the adder CM2

    if (k &lt;31)
    {
     n2 = n1;
     n1 = SUM232;
    }
    if (rezh == 1)
    {
     if (k &lt;24)
     {
      c ++;
      if (c&gt; 7) c = 0;
     }
     else
     {
      c--;
      if (c &lt;0) c = 7;
     }
    }
    else
    {
     if (k &lt;8)
     {
      c ++;
      if (c&gt; 7) c = 0;
     }
    else
    {
     c--;
     if (c &lt;0) c = 7;
    }
   }
  }
  n2 = SUM232;

  // output result to file
   char sym_rez;
   for (int q = 0; q &lt;= 3; q ++)
   {
    sym_rez = * ((byte *) &amp; n1 + q);
    fprintf (f_end, "% c", sym_rez);
   }
   for (int q = 0; q &lt;= 3; q ++)
   {
    sym_rez = * ((byte *) &amp; n2 + q);
    fprintf (f_end, "% c", sym_rez);
   }
  }
  fclose (f_begin);
  fclose (f_end);
 }

 // ------------------------------------------------ ---------------------------
 int main ()
 {
  // choose encryption or decryption
  int rezhim = 0;
  do
  {
   printf ("Select the mode of operation: \ nCrypting - 1 \ nCoding - 2 \ n");
    scanf ("% d", &amp; rezhim);
  } while ((rezhim! = 1) &amp;&amp; (rezhim! = 2));  // repeat until 1 or 

  // select the source and destination files (slash '\' in the path to write as '\\') 
  char open_str [50], save_str [50];
  printf ("\ nEnter the path to the source file \ n");
  scanf ("% s", &amp; open_str);
  printf ("\ nEnter the path to the file where you want to write the result \ n");
  scanf ("% s", &amp; save_str);

  rpz (rezhim, open_str, save_str);  // run the RPP
  return 0;
 }
 // ------------------------------------------------ ---------------------------
</pre><h3>  Note the advantages and disadvantages of this mode. </h3><h4>  Advantages: </h4><ul><li>  The effect of cipher overlap on encryption strength is excluded </li><li>  It is possible to decrypt any block, regardless of its location in the cryptogram. </li><li>  Easy to sync. </li></ul><h4>  Disadvantages: </h4><ul><li>  Message statistics penetrate cryptogram statistics. </li><li>  One mistake of the type "replacement of the sign" in the cryptogram leads to the complete destruction of the block during decryption. </li></ul><h3>  Application. </h3>  This mode is used in the remaining three modes of GOST 28147-89, in GOST R34.11-94 when performing mixing transformations, as well as for key processing. It is not recommended to use it for encryption / decryption, there are more advanced modes, which will be discussed in the following parts. </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/81032/">https://habr.com/ru/post/81032/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../81018/index.html">Internet made of cats</a></li>
<li><a href="../81019/index.html">ACHTUNG! Another parted detected</a></li>
<li><a href="../81020/index.html">It's time to stop using IE6</a></li>
<li><a href="../81025/index.html">Notion ink adam</a></li>
<li><a href="../81027/index.html">We are playing with a thinkpad gyro on linux</a></li>
<li><a href="../81033/index.html">Inoblogger</a></li>
<li><a href="../81034/index.html">Doctrine pagination (Using SQL_CALC_FOUND_ROWS)</a></li>
<li><a href="../81040/index.html">On the role of change</a></li>
<li><a href="../81044/index.html">Nvidia 3d vision review: a second eye for games, movies and photos</a></li>
<li><a href="../81046/index.html">"The correctly asked question is half the answer" (c)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>