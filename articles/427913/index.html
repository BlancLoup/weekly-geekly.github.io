<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Entertaining prologue # 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, the community of developers , it is necessary to finish business. 


 In my previous opus, there was a call to show how the Prolog language can be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Entertaining prologue # 2</h1><div class="post__text post__text-html js-mediator-article"><p>  Hi, the <em>community of developers</em> , it is necessary to finish business. </p><br><p>  In my previous <a href="https://habr.com/post/427189/">opus, there</a> was a call to show how the Prolog language can be used, and to show that it would be fun.  Turn this into an exercise. </p><br><p>  I will try to continue <del>  show off </del>  to demonstrate. </p><br><p>  Briefly recall the <a href="https://leetcode.com/problems/wildcard-matching/">task:</a> </p><br><div class="spoiler">  <b class="spoiler_title">Wildcard matching</b> <div class="spoiler_text"><p>  An anaeronautical string (s) and a pattern (p), implement a wildcard pattern matching with support for '?'  and ' <em>'.</em> <em><br></em>  <em>'?'</em>  <em>Matches any single character.</em> <em><br></em>  <em>'</em> ' Matches any sequence of characters (including the empty sequence). <br>  The matching input string (not partial). </p></div></div><br><p>  Prove the completeness of the solution failed.  On the site that provides the task there are 1808 tests that cannot be immediately seen, you need to write a program and get another test as an error. </p><br><p>  Hardcore I got 66 from him and checked my solution - while everything worked.  But it can not be so simple. </p><br><p>  Why do so many tests, I want to check further ... </p><br><p>  I will try to rewrite this solution in language <del>  understandable </del>  available on this system (they reflect the popularity of modern programming languages). </p><br><p>  So, choose Python. </p><a name="habracut"></a><br><p>  The power of Prolog in the search procedure, the roots of which are in the methods of proving <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25BE_%25D1%2580%25D0%25B5%25D0%25B7%25D0%25BE%25D0%25BB%25D1%258E%25D1%2586%25D0%25B8%25D0%25B9">theorems</a> .  Simply put, it has a built-in mechanism for unification and search with a return.  It is even simpler to say mapping plus depth search in a decision tree. </p><br><p>  And Python is a modern Pascal (something already three languages ‚Äã‚Äãon the letter "P")), it is also possible to write programs on it for <a href="https://habr.com/company/raiffeisenbank/blog/425843/">schoolchildren</a> . </p><br><p>  Now I will rewrite the solution that was laid in the previous implementation and quickly implement a similar prolog search with a return. </p><br><p>  Then I will launch it into the testing system, and I will see if the move (code) was correct. </p><br><h1 id="prisoedinyaytes">  Join now. </h1><br><p>  At the entrance, the test string and pattern: </p><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(st,pat)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st==<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat==<span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pat&gt;<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'*'</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> test(st,pat[<span class="hljs-number"><span class="hljs-number">1</span></span>:]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st&gt;<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat&gt;<span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st[<span class="hljs-number"><span class="hljs-number">0</span></span>]==pat[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'?'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> test(st[<span class="hljs-number"><span class="hljs-number">1</span></span>:],pat[<span class="hljs-number"><span class="hljs-number">1</span></span>:]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'*'</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> test(st[<span class="hljs-number"><span class="hljs-number">1</span></span>:],pat) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  It seems to be very similar to the implementation of Prolog: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">test_pattrn</span></span>(<span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span>,<span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span>). <span class="hljs-selector-tag"><span class="hljs-selector-tag">test_pattrn</span></span>(<span class="hljs-selector-attr"><span class="hljs-selector-attr">[Ch|UnpTail]</span></span>,<span class="hljs-selector-attr"><span class="hljs-selector-attr">[Ch|PatTail]</span></span>)<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:-test_pattrn(UnpTail</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">PatTail</span></span>). <span class="hljs-selector-tag"><span class="hljs-selector-tag">test_pattrn</span></span>(<span class="hljs-selector-attr"><span class="hljs-selector-attr">[Ch|UnpTail]</span></span>,<span class="hljs-selector-attr"><span class="hljs-selector-attr">['?'|PatTail]</span></span>)<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:-test_pattrn(UnpTail</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">PatTail</span></span>). <span class="hljs-selector-tag"><span class="hljs-selector-tag">test_pattrn</span></span>(<span class="hljs-selector-attr"><span class="hljs-selector-attr">[Ch|UnpTail]</span></span>,<span class="hljs-selector-attr"><span class="hljs-selector-attr">['*'|PatTail]</span></span>)<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:-test_pattrn(UnpTail</span></span>,<span class="hljs-selector-attr"><span class="hljs-selector-attr">['*'|PatTail]</span></span>). <span class="hljs-selector-tag"><span class="hljs-selector-tag">test_pattrn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Str</span></span>,<span class="hljs-selector-attr"><span class="hljs-selector-attr">['*'|PatTail]</span></span>)<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:-test_pattrn(Str</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">PatTail</span></span>).</code> </pre><br><p>  Five solutions, otherwise a lie. </p><br><p>  But how to do a return search ?, for this I use yield, as it is called there, unfinished (lazy) calculations, closure, an element of the functional approach, tell me ... It will return something from which you can get the following solution, but if will not lead to the correct answer, then we will go to the program branch with the next yield, this is the difference from return. </p><br><p>  This function will accept the result of the first test () as an input, if it is true then everything is fine, otherwise it will try to iterate more, and so will be a depth search similar to the prolog output. </p><br><p>  Here, return is already specifically needed: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(r)==bool: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r==<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> run(nr):<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre><br><h1 id="proveryaem-1">  Checking 1 </h1><br><p><img src="https://habrastorage.org/webt/b_/bd/qy/b_bdqy_ehypljwck0ihcbarfwhc.png"></p><br><p>  Wow, this is the result, "939/1808 test cases passed."  and "Status: Time Limit Exceeded". <br>  This is exactly what I expected; a declarative solution does not always lead to an effective implementation time.  Transparent wording is not a quick wording. </p><br><p>  But, here is the result of the python, let's test the opened test in the implementation from the first article, and measure the time: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time pt=time.time() print(run(test(<span class="hljs-string"><span class="hljs-string">"babaaababaabababbbbbbaabaabbabababbaababbaaabbbaaab"</span></span>,<span class="hljs-string"><span class="hljs-string">"***bba**a*bbba**aab**b"</span></span>))) print(time.time()-pt)</code> </pre> <br><p>  Runtime by Python 11.10963249206543 sec., Yes, a bit too much. </p><br><p>  Improved testing mechanism for Prolog: </p><br><pre> <code class="hljs ruby">%unit-tests framework assert_are_equal(Goal, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:-get_time</span></span>(St),<span class="hljs-keyword"><span class="hljs-keyword">not</span></span>(Goal),!,get_time(Fin),Per is Fin-St,writeln(Goal-&gt;<span class="hljs-symbol"><span class="hljs-symbol">ok:</span></span>Per/sec). assert_are_equal(Goal, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:-</span></span> get_time(St),Goal, !,get_time(Fin),Per is Fin-St,writeln(Goal-&gt;<span class="hljs-symbol"><span class="hljs-symbol">ok:</span></span>Per/sec). assert_are_equal(Goal, Exp)<span class="hljs-symbol"><span class="hljs-symbol">:-writeln</span></span>(Goal-&gt;<span class="hljs-symbol"><span class="hljs-symbol">failed:</span></span>expected-Exp). <span class="hljs-symbol"><span class="hljs-symbol">:-assert_are_equal</span></span>(isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab,<span class="hljs-string"><span class="hljs-string">'*ab***ba**b*b*aaab*b'</span></span>),<span class="hljs-literal"><span class="hljs-literal">true</span></span>).</code> </pre><br><p>  And here is the result of Prolog (running not in the online editor, locally, on the same hardware as the previous one): </p><br><pre> <code class="hljs markdown">isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab,<span class="hljs-emphasis"><span class="hljs-emphasis">*ab*</span></span><span class="hljs-strong"><span class="hljs-strong">**ba**</span></span>b<span class="hljs-emphasis"><span class="hljs-emphasis">*b*</span></span>aaab*b)-&gt;ok:2.208951950073242/sec</code> </pre> <br><p>  It looks like I do not use python badly ((, it is necessary to improve, not so visually: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(st,pat)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st==pat: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pat&gt;<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'*'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test(st,pat[<span class="hljs-number"><span class="hljs-number">1</span></span>:]):<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st&gt;<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat&gt;<span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st[<span class="hljs-number"><span class="hljs-number">0</span></span>]==pat[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'?'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test(st[<span class="hljs-number"><span class="hljs-number">1</span></span>:],pat[<span class="hljs-number"><span class="hljs-number">1</span></span>:]):<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'*'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test(st[<span class="hljs-number"><span class="hljs-number">1</span></span>:],pat):<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time pt=time.time() print(test(<span class="hljs-string"><span class="hljs-string">"babaaababaabababbbbbbaabaabbabababbaababbaaabbbaaab"</span></span>,<span class="hljs-string"><span class="hljs-string">"***bba**a*bbba**aab**b"</span></span>)) print(time.time()-pt)</code> </pre> <br><p>  Here is the result: 3.921879768371582 sec.  (this is closer to the original).  We return to the arbitrator: </p><br><p><img src="https://habrastorage.org/webt/js/sj/q2/jssjq2qynkpuiuxxhgkauok69e8.png"></p><br><p>  Once again. </p><br><p><img src="https://habrastorage.org/webt/ak/fa/cs/akfacs0zye38rbwjujdmtprshru.png"></p><br><p>  I conclude that the total passing of tests goes beyond the time frame, because the last two options are solved very quickly. </p><br><p>  Need optimization on the order. </p><br><h1 id="proveryaem-2-nuzhna-optimizaciya">  Check 2. Need optimization. </h1><br><p>  What begs, for sure - search in width. </p><br><p>  Do not continue the decision of each branch until we get a lie and return to another branch, but look through the solutions by levels, descending simultaneously for each option and gradually go deeper further. </p><br><p>  I'll try to make it a python, and then I'll demonstrate the prologue. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(st,pat)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st==pat: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> res=[] <span class="hljs-comment"><span class="hljs-comment">#     ,    if pat&gt;"" and pat[0]=='*':res+=[(st,pat[1:])] if st&gt;"" and pat&gt;"": stt=st[1:] if st[0]==pat[0] or pat[0]=='?':res+=[(stt,pat[1:])] if pat[0]=='*':res+=[(stt,pat)] return res def run(st,pat): lev=[(st,pat)] while len(lev)!=0: nxt=set() ##        for s,p in lev: one=test(s,p) if one==True:return True else:nxt.update(set(one)) lev=nxt return False</span></span></code> </pre><br><p>  There is already a result for test 939, only 0.01585698127746582 seconds. <br>  and ..., URA this decision is made </p><br><p><img src="https://habrastorage.org/webt/uk/cl/tg/ukcltg11trpklqys9xew7kiqou8.png"></p><br><h1 id="prolog">  Prologue </h1><br><p>  I will try to show how to implement a search in width, in a declarative implementation.  To do this, there are special predicates of the second order, which can assemble solutions into the list, for example, bagof, setof, findall. </p><br><blockquote>  bagof (+ Template,: Goal, -Bag) <br>  Unify Bag with the alternatives of Template.  The bagof / 3 will be able to track your bag.  Not in the bind Var in Goal.  bagof / 3 fails if goal has no solutions. <br>  setof (+ Template, + Goal, -Set) <br>  This is a list of alternatives without duplicates. </blockquote><p>  The predicate setof works well.  he already knows how to remove duplicates (in the python for this I had to learn about sets). </p><br><p>  So, I will make a predicate that gets a solution of one level, then we collect it with another predicate and delve into it, here‚Äôs the complete solution: </p><br><pre> <code class="hljs pgsql">atom_to_list(Str,[Ch|T]) :- atom_concat(Ch,Rest,Str),atom_length(Ch,<span class="hljs-number"><span class="hljs-number">1</span></span>), atom_to_list(Rest,T). %  pattrn(X:X,<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>). %-      pattrn([Ch|UnpTail]:[Ch|PatTail],UnpTail:PatTail). pattrn([_|UnpTail]:[<span class="hljs-string"><span class="hljs-string">'?'</span></span>|PatTail],UnpTail:PatTail). pattrn([_|UnpTail]:[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|PatTail],UnpTail:[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|PatTail]). pattrn(Str:[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|PatTail],Str:PatTail). %  <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>,     ,     next_level(Lev):-member(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>,Lev),!. next_level(Lev):-<span class="hljs-keyword"><span class="hljs-keyword">setof</span></span>(One,SP^(member(SP,Lev),pattrn(SP,One)),Next),!, next_level(Next). test_pattrn(Str,Pat):-next_level([Str:Pat]). isMatch(S,P) :- atom_to_list(S,SL), atom_to_list(P,PL),!, test_pattrn(SL,PL),!. %unit-tests framework assert_are_equal(Goal, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>):-get_time(St),<span class="hljs-keyword"><span class="hljs-keyword">not</span></span>(Goal),!,get_time(Fin),Per <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Fin-St, writeln(Goal-&gt;ok:Per/sec). assert_are_equal(Goal, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>):- get_time(St),Goal, !,get_time(Fin),Per <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Fin-St, writeln(Goal-&gt;ok:Per/sec). assert_are_equal(Goal, Exp):-writeln(Goal-&gt;failed:expected-Exp). %<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> test :-assert_are_equal(isMatch(aa,a),<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>). :-assert_are_equal(isMatch(aa,<span class="hljs-string"><span class="hljs-string">'*'</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>). :-assert_are_equal(isMatch(cb,<span class="hljs-string"><span class="hljs-string">'?a'</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>). :-assert_are_equal(isMatch(adceb,<span class="hljs-string"><span class="hljs-string">'*a*b'</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>). :-assert_are_equal(isMatch(acdcb,<span class="hljs-string"><span class="hljs-string">'a*c?b'</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>). :-assert_are_equal(isMatch(aab,<span class="hljs-string"><span class="hljs-string">'c*a*b'</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>). :-assert_are_equal(isMatch(mississippi,<span class="hljs-string"><span class="hljs-string">'m??*ss*?i*pi'</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>). :-assert_are_equal(isMatch(abefcdgiescdfimde,<span class="hljs-string"><span class="hljs-string">'ab*cd?i*de'</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>). :-assert_are_equal(isMatch(zacabz,<span class="hljs-string"><span class="hljs-string">'*a?b*'</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>). :-assert_are_equal(isMatch(leetcode,<span class="hljs-string"><span class="hljs-string">'*e*t?d*'</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>). :-assert_are_equal(isMatch(aaaa,<span class="hljs-string"><span class="hljs-string">'***a'</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>). :-assert_are_equal(isMatch(b,<span class="hljs-string"><span class="hljs-string">'*?*?*'</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>). :-assert_are_equal(isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab,<span class="hljs-string"><span class="hljs-string">'*ab***ba**b*b*aaab*b'</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>). :-assert_are_equal(isMatch(abbbbbbbaabbabaabaa,<span class="hljs-string"><span class="hljs-string">'*****a*ab'</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>). :-assert_are_equal(isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab,<span class="hljs-string"><span class="hljs-string">'*ab***ba**b*b*aaab*b'</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>). :-assert_are_equal(isMatch(babaaababaabababbbbbbaabaabbabababbaababbaaabbbaaab,<span class="hljs-string"><span class="hljs-string">'***bba**a*bbba**aab**b'</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).</code> </pre> <br><p>  Here you can see that the rule that previously performed a pattern-based search, as if making a transition along a face in a graph, has now become a set of pattrn facts that contain possible transitions (connections between states) - this is a description of the graph, and not its implementing code. </p><br><p>  And results of performance with time in sec .: </p><br><pre> <code class="hljs erlang-repl">isMatch(aa, a)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.00010013580322265625</span></span>/sec isMatch(aa, *)-&gt;ok:<span class="hljs-number"><span class="hljs-number">4.00543212890625e-5</span></span>/sec isMatch(cb, ?a)-&gt;ok:<span class="hljs-number"><span class="hljs-number">3.981590270996094e-5</span></span>/sec isMatch(adceb, *a*b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0001399517059326172</span></span>/sec isMatch(acdcb, a*c?b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">9.989738464355469e-5</span></span>/sec isMatch(aab, c*a*b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">4.00543212890625e-5</span></span>/sec isMatch(mississippi, m??*ss*?i*pi)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0003399848937988281</span></span>/sec isMatch(abefcdgiescdfimde, ab*cd?i*de)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0003600120544433594</span></span>/sec isMatch(zacabz, *a?b*)-&gt;ok:<span class="hljs-number"><span class="hljs-number">9.989738464355469e-5</span></span>/sec isMatch(leetcode, *e*t?d*)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.00020003318786621094</span></span>/sec isMatch(aaaa, ***a)-&gt;ok:<span class="hljs-number"><span class="hljs-number">9.989738464355469e-5</span></span>/sec isMatch(b, *?*?*)-&gt;ok:<span class="hljs-number"><span class="hljs-number">6.008148193359375e-5</span></span>/sec isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab, *ab***ba**b*b*aaab*b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0040400028228759766</span></span>/sec isMatch(abbbbbbbaabbabaabaa, *****a*ab)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0006201267242431641</span></span>/sec isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab, *ab***ba**b*b*aaab*b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.003679990768432617</span></span>/sec isMatch(babaaababaabababbbbbbaabaabbabababbaababbaaabbbaaab, ***bba**a*bbba**aab**b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.002460002899169922</span></span>/sec</code> </pre> <br><p>  And this is a successful solution not only logically but also in time. </p><br><h1 id="vyvody">  findings </h1><br><p>  In the previous article, I wanted to see an interest in the topic of a declarative approach.  The theme "niasilil such an approach" immediately opened, yet you can show interest.  Here I showed that there is a performance problem, what is written clearly does not work quickly.  Attempts to create a parallel prologue did not end with success.  Maybe there is a question of the future, can a quantum computer ?? <br>  Total use puzzles on the above site, for a pleasant stay with the mind. </p><br><p>  Well, next time there will be an attempt to immediately solve another one of the <a href="https://leetcode.com/problemset/algorithms/">hard tasks</a> effectively. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/427913/">https://habr.com/ru/post/427913/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427901/index.html">How not to use the Node.js Stream API</a></li>
<li><a href="../427905/index.html">Mining food or "Crossroads" through the eyes of a hacker</a></li>
<li><a href="../427907/index.html">Drone shooting, ‚Äúrakes‚Äù, life hacking, self-development and a photographer / videographer career: a new podcast ‚ÄúGLPH‚Äù</a></li>
<li><a href="../427909/index.html">Python: how to reduce memory consumption by half by adding just one line of code?</a></li>
<li><a href="../427911/index.html">Office passions</a></li>
<li><a href="../427915/index.html">Presumption of stupidity</a></li>
<li><a href="../427917/index.html">The answer to the post "Presumption of the mind"</a></li>
<li><a href="../427919/index.html">Porting COM to Linux</a></li>
<li><a href="../427921/index.html">4 videos about procrastination</a></li>
<li><a href="../427923/index.html">How I added a new device to SmartThings Hub, part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>