<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The algorithm "diamond-square" to build fractal landscapes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think many are familiar with the very unusual Minecraft game (on the right is an example of a map generated in it), in which the player is on the (a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The algorithm "diamond-square" to build fractal landscapes</h1><div class="post__text post__text-html js-mediator-article"> <a href=""><img src="https://habrastorage.org/storage/fe971240/ff0111e1/e8b0482c/fcd1ee86.jpg" align="right" alt="  Minecraft,     Cartograph" title="The map of the game Minecraft, created using the application Cartograph"></a>  I think many are familiar with the very unusual <a href="http://minecraft.net/">Minecraft</a> game (on the right is an example of a map generated in it), in which the player is on the (almost) infinite surface of the Earth and can explore the world with minimal restrictions. <br><br>  How did the author of the game, Notch, manage to achieve a similar similarity between his random "worlds" and earthly expanses?  In this topic, I‚Äôll just consider one of the ways to build an artificial landscape of this kind (and briefly mention a couple of other ways), and also talk about my small improvement of this algorithm, which allows you to significantly increase the size of the landscape without noticeable loss in performance. <br><br>  Inside you will find several schemes and beautiful pictures, quite a few letters and a link to an example of the implementation of the algorithm. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h2>  General action plan </h2><br>  What is the general meaning of landscape generation?  If we talk about creating (almost in real time) a level for a computer game - such as Minecraft itself, this process consists of the following points: <br><ol><li>  <b>Creating a height map</b> .  Initially, we have a flat two-dimensional grid and we assign a certain height to each of its cells.  How?  This will be discussed further.  By the way, the grid does not have to be rectangular - for example, <a href="http://ibiblio.org/e-notes/VRML/Terra/Terra.htm">a</a> similar algorithm for a grid consisting of triangles <a href="http://ibiblio.org/e-notes/VRML/Terra/Terra.htm">is</a> described <a href="http://ibiblio.org/e-notes/VRML/Terra/Terra.htm">here</a> .  However, in most cases, a grid consisting of square pixel cells is more convenient.  Together with a height map, areas covered by water are also set ‚Äî at a minimum, seas and oceans (as a rule, only those cells that lie below a certain level become water). </li><li><img src="https://habrastorage.org/storage/694bf417/2bd7e8fe/47ea1f86/057bf768.png" align="right" alt="       " title="The distribution of biomes depending on the height and humidity">  <b>The distribution of <a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B8%25D0%25BE%25D0%25BC">biomes</a></b> .  Here you will need some knowledge in geography (however, the whole process of creating a landscape requires it).  To determine where the tundra should be, where there is a desert, and where there is a rainforest - the already created altitude map and, for example, the distance from water spaces or to some predefined points (equator / poles) will help.  In turn, biomes will set many other parameters - for example, grass cover, number of stony areas, plants, number of rivers and lakes, etc. </li><li>  We created the earth, the oceans and the seas, too, the geographical zones were distributed.  What have you forgotten?  <b>Let the river</b> , of course!  In addition to the water itself, which will flow from the mountains and descend into the seas or form lakes in hollows, they should be emulated by their impact on the surface of the earth - to form river beds and transfer sand and soft soil along the stream to form beaches on the shores of lakes and other water bodies.  Unfortunately, this process, called <b>water erosion</b> , like other types of <a href="http://en.wikipedia.org/wiki/Erosion">erosion</a> , I have to leave outside the scope of this article.  However, in the list of references there are a couple of links to very good materials on this topic. </li><li>  <b>Additional actions</b> .  In fact, the landscape has already been created, but there are still many things that can be improved on it - for example, in Minecraft, the space under the ground is completely dug up with natural caves, and many trees are growing on the surface.  In addition, of course, depending on the biomes, you can diversify the flora and fauna - if the goal is to get as close as possible to what is happening in the present nature. </li></ol><br>  Finally, the generated landscape will only draw.  Here, I would like to notice only one detail - while the triangular grid mentioned above would be useful when traditional rendering a three-dimensional map, for square cells, <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25BE%25D0%25BA%25D1%2581%25D0%25B5%25D0%25BB%25D1%258C">voxels</a> can be very useful.  However, this is a completely different story. <br><br><h2>  Ways to build a height map </h2><br>  So, we will deal with the most important stage in the construction of the landscape - the definition of how high each point of the earth‚Äôs surface is.  The most commonplace idea is to go over both coordinates and make <i>map [x] [y] = random ()</i> - oddly enough, it will not give acceptable results, so you need to use something more cunning. <br><br><h3>  Creating hills "by hand" </h3><br>  A rather simple algorithm: initially we believe that all points are on the same level and begin to add, in arbitrary places, such ‚Äúbulges‚Äù - hills of different heights.  As a result of the careful imposition of these hills on each other (and, perhaps, adding the slight noise mentioned above), it is already possible to get something similar to the truth.  But much more realistic landscapes can be achieved by the algorithms listed below, so I will not dwell on the ‚Äúhills‚Äù method. <br><br><h3>  Landscape based on the Voronoi diagram </h3><br>  In fact, until recently, the next approach for me was completely unknown and I was quite surprised that it was capable of producing very impressive results. <br><br><img src="https://habrastorage.org/storage/a683ff85/ef3fbe3f/9b942e2c/19c32c5c.jpg" alt=" " title="Voronoi diagram" align="right">  It all starts with a random throwing points on the map.  Then, using these points, we construct <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25B0%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0_%25D0%2592%25D0%25BE%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE">the Voronoi diagram</a> (and, accordingly, the <a href="http://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay triangulation</a> ), and several iterations <a href="http://en.wikipedia.org/wiki/Lloyd%27s_algorithm">of Lloyd's relaxation</a> are performed on it to get rid of too small polygons. <br><br>  If the previous paragraph was not clear to you - it is not scary, its essence boils down to creating approximately such a grid as in the figure on the right.  Its main property is its irregularity.  This allows the landscape based on it not to look too ‚Äúsquare‚Äù. <br><br> <a href=""><img src="https://habrastorage.org/storage/81042320/0aa94e02/caa1e210/b3d11377.jpg" alt=" " title="Resulting landscape" align="left"></a>  Further actions are trivial - we randomly select polygons to be filled with water, and make the height of points belonging to the other polygons equal to the shortest distance to the sea-ocean.  It remains to add all the same noise (both to the actual height and to the boundaries of the polygons) - and we get a very nice island (or continent, depending on the scale). <br><br>  I did not deal with the implementation of this algorithm and, to simplify the article, I omitted several details and intermediate ones.  A detailed article (from which pictures and most of the information were borrowed) can be found <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/">here</a> (in English), there is also a wonderful <a href="">swf demo</a> , which very clearly illustrates all stages of the process. <br><br><h3>  Diamond-square algorithm </h3><br>  The most common and giving one of the most realistic results is the diamond-square (or square-diamond) algorithm, an extension of the one-dimensional midpoint displacement algorithm to a two-dimensional plane.  The landscapes resulting from it are usually referred to as fractal, although, it must be admitted, in fact, they are not so self-similar ‚Äî on the contrary, as we shall see later, their not very pleasant property is that on a large scale they become relatively smooth. , and in the shallow turn into a kind of sandpaper. <br><br><img src="https://habrastorage.org/storage/33bc0cc2/2710b7d2/f41b7a20/f7fbb8f7.png" alt=" ,     midpoint displacement" title="Night horizon, obtained using the algorithm of midpoint displacement" align="left"><img src="https://habrastorage.org/storage/72a3c934/f2df0720/2067fdec/95dfcbf6.png" alt="The operation of the midpoint displacement algorithm" align="right">  Let's start with a simpler midpoint displacement algorithm.  As already mentioned, it works not on a two-dimensional plane, but on a one-dimensional segment (therefore, it can be used, for example, to create a horizon line). <br><br>  What makes this algorithm related to fractals is its recursive behavior.  Initially, in any way we set the height at the ends of the segment and divide it by a point in the middle into two sub-segments.  We shift this point by a random value and repeat the splitting and offset for each of the obtained sub-segments.  And so on - until the segments become one pixel long.  That's the whole algorithm (see the figure on the right).  Oh yes, an important note: random displacements should be proportional to the lengths of the segments into which the partitions are made.  For example, we divide a segment of length <i>l</i> - then a point in the middle of it should have a height <br>  <i>h</i> = ( <i>h <sub>L</sub></i> + <i>h <sub>R</sub></i> ) / 2 + random (- <i>R</i> * <i>l</i> , <i>R</i> * <i>l</i> ) <br>  ( <i>h <sub>L</sub></i> and <i>h <sub>R</sub></i> are the heights on the left and right ends of the segment, and the constant <i>R</i> determines the roughness of the resulting broken line and is the main parameter in this algorithm). <br><br><img src="https://habrastorage.org/storage/6f10a87f/ca5eb342/eaa5cd2e/fe6fa0c5.png" alt="Midpoint displacement   " title="Midpoint displacement in two dimensions" align="left">  Let's try to generalize this algorithm for a two-dimensional height map.  We start by assigning random heights to the four corners of the entire map and divide it (for convenience, I assume that we work with a square card, and its side is a power of two) into four equal squares.  Each of them knows the value in one of the corners.  Where to get the rest? <img src="https://habrastorage.org/storage/35df2fa7/3d2e47a7/6ae410a9/8f627db1.gif" alt="   midpoint displacement" title="The result of a two-dimensional midpoint displacement" align="right"><br>  All the same interpolation, as in the one-dimensional midpoint displacement - a point in the center is obtained by averaging the heights of all 4 corner points, and each midpoint on the side of a large square is averaged by a pair of points lying at the ends of the corresponding side.  It remains to introduce a bit of noise - randomly moving the center point up or down (within the limits proportional to the side of the square) - and our actions can be repeated recursively for the resulting sub-squares.  Everything?  All, yes, not all. <br><br>  This is not diamond-square yet - this algorithm, as a rule, is also called the midpoint displacement algorithm, and despite the fact that it already provides relatively acceptable results, you can easily notice its ‚Äústraight-line‚Äù nature in the resulting image. <br><br><img src="https://habrastorage.org/storage/40a707db/06476d56/98bd3b4e/45d2891d.png" alt="  diamond-square" title="Diamond-square algorithm" align="right">  The diamond-square algorithm - the one that allows you to get "real" fractal landscapes - differs from the two-dimensional midpoint displacement in that it consists of two steps.  The first is the so-called.  ‚ÄúSquare‚Äù - in the same way determines the center point in a square by averaging angular and adding displacement itself - random deviation.  The second step - "diamond" - is designed to determine the height of the points lying on the middle of the sides.  Here, not two points are averaged - ‚Äúabove‚Äù and ‚Äúbelow‚Äù (if we talk about points on the vertical side), but also a couple of points ‚Äúleft‚Äù and ‚Äúright‚Äù - that is, two more central points obtained in step ‚Äúsquare‚Äù.  It is important to note that these two heights that we got in the previous step should already be calculated - so you need to calculate the ‚Äúlayers‚Äù, first perform the ‚Äúsquare‚Äù step for all squares - then perform the ‚Äúdiamond‚Äù step for all diamonds - and go to smaller squares. <br><br>  The explanations, I think, may seem confusing, so I advise you to carefully study the attached schemes - it should make it clearer from them which heights are calculated at each stage. <br><br>  In addition to the need to use, say, a walk in width instead of a walk in depth, there is another subtlety - the situation at the edges of the landscape.  The fact is that at the diamond stage, the algorithm uses the height of points that are outside the current square and, possibly, the entire map.  How to be?  There are two options (although you can come up with your own, of course): either consider these heights as 0 (or 1, or any other constant; this, by the way, is convenient for submerging the edges of our landscape under water), or imagine that our plane is collapsed into torus (toroidal planet, hmm ...) and trying to find out the height of a point lying 64 pixels to the left of the <i>left</i> border of the map, we find out the height of a point that is 64 points from the <i>right</i> border.  It is implemented very simply (as, however, the first option) - we will be helped by taking the coordinates in absolute value equal to the size of the map. <br><br><img src="https://habrastorage.org/storage/37879634/a3fdfd9b/5a995a17/c358aa93.jpg" align="right" alt="   diamond-square" title="The result of the diamond-square algorithm">  So, these are the basic algorithms for constructing maps of heights for artificially generated landscapes.  In my opinion, the most realistic result comes from the last one, diamond-square - although it is not without some drawbacks.  For example, creating a map that looks good with a strong approximation - when viewed entirely, you will see a lot of small islands (or even continuous noise, from which we started) instead of several large continents and oceans.  Self-similarity does not come out.  This can be corrected by various combinations of fractal landscapes of various scales.  Their values ‚Äã‚Äãcan be multiplied, added, used different coefficients or, for example, to introduce data obtained using the Voronoi diagram - in general, the scope for experiments is quite large.  By the way, even using only one diamond-square, the values ‚Äã‚Äãobtained (previously normalized, that is, in the range from 0.0 to 1.0) are useful to square - this will make the plains more gentle, and the mountain slopes are steeper (remember about erosion?). <br><br><h2>  Modification of the diamond-square algorithm for large cards </h2><br>  And finally - a few words about my implementation of the diamond-square algorithm.  The main question you ask yourself when generating a landscape is how to make it possible to significantly increase its size?  The standard implementation of the algorithm under discussion makes it possible to easily increase the level of detail (move ‚Äúinwards‚Äù), but not dimensions (‚Äúbreadth‚Äù). <br><br>  This problem was solved by me as follows.  I don‚Äôt know - maybe this decision will be well-known or quite obvious to someone - but before that I didn‚Äôt come across it and it didn‚Äôt happen at once (moreover - ‚Äúfrom scratch‚Äù there was one unexpected hitch that could be solved ‚Äúcorrectly‚Äù and failed - on this below). <br><br>  So, the approach is as follows: let our landscape was originally conceived of gigantic dimensions (for example, 16777216x16777216 pixels, although this is far from the limit).  The important thing is that we are not going to recognize the height <b>at each point</b> , but instead we will have some much smaller ‚Äúwindow‚Äù (for example, 128x128 pixels), which we will need to move over our height map.  It turns out that the original algorithm is easily modified so that we will need to calculate the ‚Äúwindow‚Äù the number of operations proportional to the size of the window, but little dependent on the size of the landscape.  That is why we can initially set the landscape almost arbitrarily large. <br><br><div style="text-align:center;"> <a href="http://denull.ru/terrain.htm"><img src="https://habrastorage.org/storage/c62fb5e5/0f86ebbc/e70087ac/1619e605.jpg" alt="   diamond-square" title="My implementation of the diamond-square algorithm"></a> </div><br><br>  We will come to the aid of a technique called <b>lazy dynamics</b> .  Those who know what they are talking about, I think, everything has become clear, for the ignorant in the question I will explain.  We "turn" the whole process inside out - instead of starting with large squares and going down to each pixel, we accept a query like "find out the height at point (x, y)" and then go up: our point, as we know was obtained by averaging four other points and a random shift.  The most difficult thing is to understand what these 4 points were.  After we understand this, it will be enough for us to repeat the request to ‚Äúfind out the height‚Äù, but for each of these points.  These requests, in turn, will rise even higher - and so on, until they reach the very top, to the corner points of the map (I have them, like the points outside the map, are 0.0).  In the source, it all looks like this: <br><br><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">val</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, v)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeof(v) != <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) data[x + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + y] = Math.<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, Math.<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, v)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x &gt;= size || y &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || y &gt;= size) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data[x + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + y] == null) { //       . base = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (((x &amp; base) == <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; ((y &amp; base) == <span class="hljs-number"><span class="hljs-number">0</span></span>)) base &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((x &amp; base) != <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; ((y &amp; base) != <span class="hljs-number"><span class="hljs-number">0</span></span>)) squareStep(x, y, base); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> diamondStep(x, y, base); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data[x + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + y]; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v, blockSize, x, y)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (v + (randFromPair(x, y, seed) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * blockSize * <span class="hljs-number"><span class="hljs-number">2</span></span> / size * roughness); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">squareStep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, blockSize)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data[x + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + y] == null) { val(x, y, displace((val(x - blockSize, y - blockSize) + val(x + blockSize, y - blockSize) + val(x - blockSize, y + blockSize) + val(x + blockSize, y + blockSize)) / <span class="hljs-number"><span class="hljs-number">4</span></span>, blockSize, x, y)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">diamondStep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, blockSize)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data[x + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + y] == null) { val(x, y, displace((val(x - blockSize, y) + val(x + blockSize, y) + val(x, y - blockSize) + val(x, y + blockSize)) / <span class="hljs-number"><span class="hljs-number">4</span></span>, blockSize, x, y)); } }</code> </pre> <br><br>  The main thing is to memorize (and add to any cache) all heights that we have already calculated.  This will allow us not to do the same thing many times.  Actually, even having calculated the first point in our ‚Äúwindow‚Äù, we will in the process find out a number of other points that also belong to this ‚Äúwindow‚Äù.  In fact, having run through all the points of the ‚Äúwindow‚Äù, we will not do so many unnecessary operations - although their exact number strongly depends on whether the ‚Äúwindow‚Äù (its upper left corner and size) has been aligned in powers of two. <br><br>  As already mentioned, there are several magic lines in the algorithm - here they are: <br><pre> <code class="javascript hljs">base = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (((x &amp; base) == <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; ((y &amp; base) == <span class="hljs-number"><span class="hljs-number">0</span></span>)) base &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((x &amp; base) != <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; ((y &amp; base) != <span class="hljs-number"><span class="hljs-number">0</span></span>)) squareStep(x, y, base); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> diamondStep(x, y, base);</code> </pre> <br>  Here it is determined whether the current point is the center of a square or a rhombus and what is the size of this shape.  To be honest - this code was written simply on a whim, I cannot give an exact mathematical justification.  We simply find the least significant bit, which is non-zero at least at one of the coordinates - it will be the desired size.  And in order to determine whether the figure was a square, we check that both coordinates had this bit set.  Both coordinates are zero-indexed. <br><br>  And finally, an unexpected underwater stone: a pseudo-random number generator.  In my code, unusual demands were made of it: for each point <i>(x, y) you</i> always want to get the same random number, and do it quickly.  Many programming languages ‚Äã‚Äãin the random number generator have the ability to specify a so-called.  A ‚Äúseed‚Äù (seed) on which the entire following sequence of generated numbers will depend (in JavaScript this is not the case, but for it there is an implementation of the common <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B8%25D1%2585%25D1%2580%25D1%258C_%25D0%259C%25D0%25B5%25D1%2580%25D1%2581%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0">Mersenn vortex</a> ).  The problem is that the sequence does not suit us - when you shift the window (and clear the cache), we will approach one point from a completely different side and the random shift will become different.  We want a static landscape, under whatever conditions we consider it.  An attempt to initialize a Mersenne vortex each time with a ‚Äúgrain‚Äù depending on both coordinates failed: its initialization lasts too long. <br><br>  After some reflection, I came to the conclusion that a quick way to convert two coordinates into a number that would be hardly correlated with them is basically impossible.  As a result, I settled on such a function, which gives acceptable results due to repeated taking of numbers using simple modules: <br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randFromPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">80</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xm7 = x % <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xm13 = x % <span class="hljs-number"><span class="hljs-number">13</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xm1301081 = x % <span class="hljs-number"><span class="hljs-number">1301081</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ym8461 = y % <span class="hljs-number"><span class="hljs-number">8461</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ym105467 = y % <span class="hljs-number"><span class="hljs-number">105467</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ym105943 = y % <span class="hljs-number"><span class="hljs-number">105943</span></span>; y = x + seed; x += (xm7 + xm13 + xm1301081 + ym8461 + ym105467 + ym105943); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (xm7 + xm13 + xm1301081 + ym8461 + ym105467 + ym105943) / <span class="hljs-number"><span class="hljs-number">1520972.0</span></span>; }</code> </pre> <br>  In addition, it was possible to easily introduce a ‚Äúglobal grain‚Äù into this function, which determines the entire landscape as a whole, and because of taking the residues, its return values ‚Äã‚Äãturned out to be fairly evenly distributed over the [0, 1) range.  However, I am sure that you can come up with a quicker and elegant solution - you can consider this as ‚Äúhomework‚Äù in this article :) <br><br>  As everyone probably guessed, I wrote the implementation in JavaScript, which makes it equally easy to experiment with both the values ‚Äã‚Äãand the source code.  The actual page is available at <a href="http://denull.ru/terrain.htm">http://denull.ru/terrain.htm</a> , and all the code is located in the file <a href="">http://denull.ru/terrain.js</a> .  To view, you will need a browser that supports html5 (to be honest, I tested it only in Google Chrome), since the rendering goes to the canvas (and, it should be noted, the actual rendering also takes some time). <br><br><h2>  Materials on the topic </h2><br><ul><li>  <a href="http://oddlabs.com/download/terrain_generation.pdf">Realtime Procedural Terrain Generation</a> (PDF, 1.52 MB).  Very detailed and interesting material on the creation of landscapes - both using the Voronoi diagram and the diamond-square algorithm, with a description of erosion methods and a variety of illustrations and formulas. </li><li>  <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/">Polygonal Map Generation</a> , a wonderful article about building a landscape based on the Voronoi diagram.  Well illustrated, there is a demo swf-file, many links to other materials. </li><li>  <a href="http://www-evasion.imag.fr/Publications/2007/MDH07/">Fast Hydraulic Erosion Simulation and Visualization on GPU</a> .  An article about optimizing the simulation of water erosion, in the presence of not only PDF and images, but also a few videos that help you understand what it is about.  Whatever the idea of ‚Äã‚Äãoptimizing the process, shifting the load on the GPU, there is enough information in the document about the mechanisms of erosion. </li><li>  Several short articles on fractal algorithms: <a href="http://www.gameprogrammer.com/fractal.html">Generating Random Fractal Terrain</a> , <a href="http://en.wikipedia.org/wiki/Fractal_landscape">Fractal landscape</a> , <a href="http://ibiblio.org/e-notes/VRML/Terra/Terra.htm">Fractal Terrains</a> , <a href="http://en.wikipedia.org/wiki/Diamond-square_algorithm">Diamond-square algorithm</a> . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/111538/">https://habr.com/ru/post/111538/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../111531/index.html">35 logos with hidden meaning</a></li>
<li><a href="../111534/index.html">Can London Tech City become a serious competitor to Silicon Valley?</a></li>
<li><a href="../111535/index.html">Several non-standard ways to use Dropbox</a></li>
<li><a href="../111536/index.html">A brief note on some of the third-generation Kindle features.</a></li>
<li><a href="../111537/index.html">Introducing Kohana 3.0 - Part 3</a></li>
<li><a href="../111540/index.html">UA ATMS. ATMs of Ukraine</a></li>
<li><a href="../111541/index.html">Sending a letter with an attached file from Drupal</a></li>
<li><a href="../111544/index.html">Development of digital devices based on VLSI programmable logic</a></li>
<li><a href="../111545/index.html">Adding the ability to sort by rating in the search</a></li>
<li><a href="../111548/index.html">SCEA certification - will we discuss?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>