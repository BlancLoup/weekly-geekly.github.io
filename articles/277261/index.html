<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How ill-conceived compiler warnings help to spoil completely correct code.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a post about the complexities of the interaction of artificial and natural intelligence. Modern compilers have fairly advanced static analysis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How ill-conceived compiler warnings help to spoil completely correct code.</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/daa/c21/c19/daac21c1959343eea2bd68ee5ed63d54.jpg" align="right">  This is a post about the complexities of the interaction of artificial and natural intelligence.  Modern compilers have fairly advanced static analysis tools that can issue warnings to various suspicious constructs in code.  In theory, these warnings should help developers make fewer errors in the code. <br><br>  In practice, the compiler warnings are not always equally useful.  Often, they do not help developers, but interfere with them and can provoke to correct a completely correct code, i.e.  violating the rule "works - do not touch." <br><a name="habracut"></a><br>  For example, there will be a story about one line of code from a fairly popular open source library for working with XML.  The context for this line is: <br><pre><code class="cpp hljs">fseek( fp, <span class="hljs-number"><span class="hljs-number">0</span></span>, SEEK_END ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> filelength = ftell( fp ); fseek( fp, <span class="hljs-number"><span class="hljs-number">0</span></span>, SEEK_SET ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( filelength == <span class="hljs-number"><span class="hljs-number">-1L</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FILE_READ_ERROR; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( filelength &gt;= (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span> ) {<span class="hljs-comment"><span class="hljs-comment">//    return FILE_READ_ERROR; } const size_t size = filelength; _charBuffer = new char[size+1]; size_t read = fread( _charBuffer, 1, size, fp ); if( read != size ) { return FILE_READ_ERROR; }</span></span></code> </pre> <br>  This fragment tries to read the entire file on the disk.  To do this, translate the file pointer to the end of the file and get the current position in the file.  Then an attempt is made to allocate memory for the data of the entire file.  Before allocating the memory, it is worth checking whether the required size fits in size_t to avoid hard-to-diagnose logical errors during further work. <br><br>  It is performed (in fact, and the code is opposite and the error code is returned) checking that filelength is strictly less than the maximum size_t value.  The check is performed on ‚Äústrictly less‚Äù, because you need to allocate one more memory to write the terminating null character before further parsing the contents of the file. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Everything would be fine, but the compiler is indignant - after all, on the one hand the comparison is the signed type long, and on the other hand the unsigned size_t.  WARNING -Wsign-compare from gcc !!! <br><br>  What to do, where to run ???  This is a warning !!! <br><br>  One of the developers corrects the check: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)filelength &gt;= (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span> ) {</code> </pre><br>  ... and the compiler is <s>UZBAGOIL</s> satisfied.  Success?  Alas, initially the correct code now does not work as planned.  The sizes long and size_t are not related to each other.  The size of any of these types may be larger than the size of the second on a particular platform.  The original code required in this case to convert both values ‚Äã‚Äãto the same type - sufficient for both size.  In the "corrected" code, some of the significant digits will be lost if the length of a long is larger than the size of size_t. <br><br>  So to get rid of the warning in the originally correct code, this code was fixed and broken. <br><br>  The error could remain for a long time and for many years to please the users when working with very large files on a certain subset of systems.  Not left - the library code is open and even lies on Github, soon comes a pool request with editing this code.  In the corrected code, the check looks like this: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)filelength &gt;= (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span> ) {</code> </pre><br>  The corrected code compares the values ‚Äã‚Äãof both unsigned types, so the terrible problem (tm), which gcc reported with the -Wsign-compare warning, is missing here.  Reduction of long to unsigned long here does not lead to incorrect interpretation of the data, because the only possible negative value is processed previously. <br><br>  Success?  No, not so fast. <br><br>  Editing is poured into the main branch, after which new warning messages begin to arrive.  When compiling for platforms where the size of unsigned long is less than size_t, clang issues a warning -Wututological-constant-out-of-range-compare ‚ÄúWARNING !!!  The range of unsigned long values ‚Äã‚Äãis so <s>dull and</s> hopelessly limited that the comparison always gives the same result and has absolutely no meaning. ‚Äù <br><br>  Fully portable code for any platform, speak?  No, when the explicit reduction of long to size_t could lead to the loss of discharges, it suited everyone.  And now clang gives a useless warning and library users leave comments to the edits and reports of defects.  This is a warning !!! <br><br>  What to do ... after all, it is necessary to make it so that on platforms where the size of unsigned long is less than size_t, there is no comparison, and on other platforms there is. <br><br>  And, here is the solution to the "problem": <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) &gt;= <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>))&gt; struct LongFitsIntoSizeTMinusOne { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Fits( <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> value ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)value &lt; (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> LongFitsIntoSizeTMinusOne&lt;<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;::Fits( <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-comment"><span class="hljs-comment">/*value*/</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  - What is it, Barrymore ??? <br>  - This is a Baskervilles pattern, sir !!! <br><br>  Here you could apply the function template, but the default template parameter values ‚Äã‚Äãfor function templates are supported only starting from C ++ 11, and the library - trying to expand the audience - tries to do without it.  struct instead of class is used to not specify the public visibility explicitly. <br><br>  Used as follows: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !LongFitsIntoSizeTMinusOne&lt;&gt;::Fits( filelength ) ) {</code> </pre><br>  Depending on the relationship between the sizes of long and size_t, the compiler chooses either specialization or implementation by default.  In the first case, there will be no meaningless checking, and the compiler will be NOTARED about anything. <br><br>  The main branch is poured in using this template, and the ‚Äúproblem‚Äù has been resolved. <br><br>  Summary of the previous text ... A perfectly correct code with one comparison of an integer variable and an integer constant was ruled three times to make two very popular compilers happy.  The first of the edits this completely correct code broke, but it made the compiler happy for which they made the revision.  In the end, instead of a simple comparison, they got something closer to <a href="https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition">FizzBuzz Enterprise</a> .  But there are no warnings. <br><br>  Now let's talk ... <br><br>  How popular should a spherical piece of open source be in vacuum so that it has a chance to go all the way from the first edit to the last, and how much more likely is it that a less popular code would remain broken by the first edit?  It took a total of clearly more than one hour of work of developers with not the lowest qualifications to find the solution shown above, which does not even correct the error, but simply turns the correct code into the correct code without warning. <br><br>  Why did it happen?  There are exactly two reasons. <br><br>  The first reason is that developers almost unconditionally trust the compiler.  Next to such a complex program, many developers feel like being next to the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25BA%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258F%25D0%25BC_%25D0%25BA%25D0%25BE%25D1%2581%25D0%25BC%25D0%25BE%25D1%2581%25D0%25B0">107-meter monument to the Conquerors of Space</a> on Prospekt Mira in Moscow.  A modern compiler is a very complex program, and many people believe that it cannot be wrong.  Alas, this opinion is incorrect - the more complex the program, the more opportunities it has to err.  The compiler may issue a warning to a completely correct code. <br><br>  The second reason is that the developers of static analyzers (especially those that are part of the compilers) usually believe that a false positive is not a problem and nothing terrible, the main thing is to WARN, and ‚Äúthe developer must understand‚Äù.  Understand it without fail, but it‚Äôs far from the fact that as a result the code will get better. <br><br>  In discussions of this problem, there are ideas that the compiler cannot figure out if there is a problem in the code, and only ‚Äúthe developer must‚Äù. <br>  Is the compiler so hopelessly helpless and unable to ‚Äúunderstand‚Äù the code?  It's time to think about code optimization.  Nontrivial code optimizations ‚Äî automatic vectorization and unwinding of loops, calculating invariants, removing unnecessary checks, and other useful and smart conversions ‚Äî require the compiler to be very thoughtful in analyzing the code. <br><br>  How thoughtful analysis is needed in this example?  The value tested is derived from the execution of the ftell () function, its behavior is documented.  gcc, for example, already knows how to optimize ‚Äî and ‚Äúbreak‚Äù non-Standard-code using the Standard's requirements to pass into ‚Äústring functions‚Äù ‚Äîfor example, memcpy () ‚Äîonly non-zero pointers, details are <a href="http://habrahabr.ru/company/abbyy/blog/234033/">in this publication</a> .  How he does it?  The gcc developers added such an opportunity to it - to recognize a number of functions as ‚Äústring‚Äù and make some assumptions about the values ‚Äã‚Äãof the pointers passed to these functions. <br><br>  In the same way, compiler developers can add to it the ability to use data on the behavior of other functions of the standard library ‚Äî hardly trivial, but definitely feasible.  Third-party static analyzers also "know" about the functions of the standard library and popular environments, this allows them to report, for example, a possible logical error in the above code when the result of ftell () is not checked for the error-reporting value -1L. <br><br>  The technical possibility for significant improvements is.  This is a question of priorities and attitude to the problem. <br><br>  You can ‚Äúteach‚Äù the compiler to optimize and ‚Äúbreak‚Äù non-Standard code with the call of string functions, or you can ‚Äúteach‚Äù it to issue less useless warnings. <br><br>  What is the output?  Many static analysis tools still work according to the principles of ‚Äúthe main thing to warn‚Äù and ‚Äúthe developer should‚Äù, with this they provoke developers to make unnecessary edits to the code, sometimes breaking working code along the way.  You can, of course, declare these developers unworthy and crooked, but you should not forget that the fate of the millions of lines of code used every day by hundreds of millions of people depends on their work. <br><br>  Static analysis was conceived as a means of facilitating the writing of the correct code ‚Äî to achieve this goal, static analysis tools should help developers, not hinder them with useless messages. <br><br>  Each time, as a static analysis tool, a warning is issued to the correct code, one cat is sad somewhere (tm) and, perhaps, an unnecessary edit is made to the completely correct code, causing another error with consequences like Heartbleed. <br><br>  <i>Dmitry Mescheryakov,</i> <i><br></i>  <i>product department for developers</i> </div><p>Source: <a href="https://habr.com/ru/post/277261/">https://habr.com/ru/post/277261/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277251/index.html">ARP: Cisco equipment features and interesting cases. Part 2</a></li>
<li><a href="../277253/index.html">How to create an animated flask using CSS</a></li>
<li><a href="../277255/index.html">What's wrong with javascript in a big project? What problems did we face and how did we solve them</a></li>
<li><a href="../277257/index.html">List of technical and IT conferences 2016. Part # 3</a></li>
<li><a href="../277259/index.html">Opinion: Why spam is so hard to beat</a></li>
<li><a href="../277265/index.html">Zabbix 3.0 released</a></li>
<li><a href="../277267/index.html">In-depth training in the garage - Data Brotherhood</a></li>
<li><a href="../277269/index.html">I'm sitting in the cloud, working</a></li>
<li><a href="../277273/index.html">Java rake</a></li>
<li><a href="../277275/index.html">Finger Math: Least Squares</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>