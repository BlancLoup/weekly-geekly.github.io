<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Three aspects of optimization (DB and software)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 Quite often, users, developers, administrators, etc. MS SQL Server DBMS encounter problems with the performance of the database or the data...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Three aspects of optimization (DB and software)</h1><div class="post__text post__text-html js-mediator-article"><h3>  Foreword </h3><br>  Quite often, users, developers, administrators, etc. MS SQL Server DBMS encounter problems with the performance of the database or the database management system as a whole. <br><br>  This article will give general recommendations on how to optimize both the database and the entire DBMS as a whole.  There will also be given basic recommendations on the interaction of the .NET application and MS SQL Server.  Examples of solutions to most of the recommendations below will be given. <br><br>  This article will not consider the optimization of hardware resources, the OS itself and the use of various built-in features for the DBMS and the OS as a whole, t this would take a whole book. <br><a name="habracut"></a><br><h3>  Decision </h3><br>  In total, there are only 3 blocks of recommendations for optimizing the database: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1) directly optimization of the database and database management system as a whole <br>  2) optimization of the interaction between the application and MS SQL Server (we will further discuss the interaction between the .NET application and MS SQL Server) <br>  3) optimization of the queries themselves <br><br>  We first analyze the first block. <br><br>  There are only 3 main recommendations for optimizing the database and the database in general: <br><br>  1) procedural cache obsolescence <br>  2) non-optimal indices <br>  3) non-optimal statistics <br><br>  This unit needs to be worked out within the framework of routine work from 1 time per day to 1 time per week, depending on the needs of the entire information system.  It is also worth considering that during the operation of this block, the databases and the DBMS as a whole will be heavily loaded with resources.  Therefore, this work should be carried out either in the hours of minimum load, or on the backup server, or by distributing work throughout the day (in the latter version, then item 1 is not applicable). <br><br>  It is also important to note that this block should be performed after all mass data processing in the framework of other routine maintenance. <br><br>  Usually, item 2 is first performed (optimize indexes), and then item 1 (the procedural cache is cleared), and then item 3 is done (update statistics). <br><br>  Let us analyze each item of the first block separately. <br><br>  Item 1 on the obsolescence of the procedural cache is solved by simply clearing this cache by calling a simple command: <br><br>  DBCC FLUSHPROCINDB ('NAME_BD'); <br><br>  However, it is important to note that such a solution does not always fit all databases and all DBMSs.  This solution is suitable for databases with the following characteristics: <br><br>  1) DB data size up to 500 GB <br>  2) the total amount of data in the database is changing every day, that is, not only do new data appear, as well as significant amounts are updated and deleted <br><br>  Examples of such databases are TFS, CRM, NAV and 1C. <br><br>  If the database has a data size of more than 500 GB, or the data is only added, but it changes and deletes in extremely small amounts (it means that the amount of changes is so many times less than the total amount of unchanged data, then this amount can be neglected). The solution must first be tested on a test environment that is as close to production as possible.  In any case, when clearing the procedural cache for such databases and the DBMS as a whole, the subsequent update of statistics will be a very long and resource-intensive operation.  Therefore, for such databases and the DBMS as a whole, claim 1 for cleaning the procedural cache must first be canceled ‚Äî at least before receiving the test results on the test environment. <br><br>  For databases in which you can apply Clause 1, and DBMS containing only such databases, you can implement the following stored procedure [srv]. [AutoUpdateStatisticsCache] for later use: <br><br><div class="spoiler">  <b class="spoiler_title">An example implementation of the stored procedure [srv]. [AutoUpdateStatisticsCache]</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> [  ] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ANSI_NULLS <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> QUOTED_IDENTIFIER <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> [srv].[AutoUpdateStatisticsCache] @DB_Name <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>)=<span class="hljs-literal"><span class="hljs-literal">null</span></span>, @IsUpdateStatistics <span class="hljs-built_in"><span class="hljs-built_in">bit</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-comment"><span class="hljs-comment">/*           */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> NOCOUNT <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> @tbl <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>), [DB_ID] <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> @db_id <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">str</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>); <span class="hljs-comment"><span class="hljs-comment">--  ,        insert into @tbl(Name, [DB_ID]) select name, database_id from sys.databases where name not in ('master', 'tempdb', 'model', 'msdb', 'distribution') and is_read_only=0 --write and state=0 --online and user_access=0 --MULTI_USER and is_auto_close_on=0 and (name=@DB_Name or @DB_Name is null); while(exists(select top(1) 1 from @tbl)) begin --    select top(1) @db_id=[DB_ID] , @name=Name from @tbl; --   id  DBCC FLUSHPROCINDB(@db_id); if(@IsUpdateStatistics=1) begin --  set @str='USE'+' ['+@name+']; exec sp_updatestats;' exec(@str); end delete from @tbl where [DB_ID]=@db_id; end END GO</span></span></code> </pre> </div></div><br>  Here at the end, if the @IsUpdateStatistics parameter is set to 1, then the statistics for the specified database in the @DB_Name parameter are also updated.  If @ IsUpdateStatistics = 1, then the item 1 for cleaning the procedural cache should be done after solving the problem of item 2, that is, in this case, the problem of item 3 for non-optimal statistics is closed. <br><br>  The current size of the entire plan cache and query plan cache can be viewed by implementing for example the following view in the administration database: <br><br><div class="spoiler">  <b class="spoiler_title">An example of the implementation of the representation [inf]. [VSizeCache]</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> [  ] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ANSI_NULLS <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> QUOTED_IDENTIFIER <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> [inf].[vSizeCache] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-comment"><span class="hljs-comment">--         (https://club.directum.ru/post/1125) with tbl as ( select TotalCacheSize = SUM(CAST(size_in_bytes as bigint)) / 1048576, QueriesCacheSize = SUM(CAST((case when objtype in ('Adhoc', 'Prepared') then size_in_bytes else 0 end) as bigint)) / 1048576, QueriesUseMultiCountCacheSize = SUM(CAST((case when ((objtype in ('Adhoc', 'Prepared')) and (usecounts&gt;1)) then size_in_bytes else 0 end) as bigint)) / 1048576, QueriesUseOneCountCacheSize = SUM(CAST((case when ((objtype in ('Adhoc', 'Prepared')) and (usecounts=1)) then size_in_bytes else 0 end) as bigint)) / 1048576 from sys.dm_exec_cached_plans ) select 'Queries' as 'Cache', (select top(1) QueriesCacheSize from tbl) as 'Cache Size (MB)', CAST((select top(1) QueriesCacheSize from tbl) * 100 / (select top(1) TotalCacheSize from tbl) as int) as 'Percent of Total/Queries' union all select 'Total' as 'Cache', (select top(1) TotalCacheSize from tbl) as 'Cache Size (MB)', 100 as 'Percent of Total/Queries' union all select 'Queries UseMultiCount' as 'Cache', (select top(1) QueriesUseMultiCountCacheSize from tbl) as 'Cache Size (MB)', CAST((select top(1) QueriesUseMultiCountCacheSize from tbl) * 100 / (select top(1) QueriesCacheSize from tbl) as int) as 'Percent of Queries/Queries' union all select 'Queries UseOneCount' as 'Cache', (select top(1) QueriesUseOneCountCacheSize from tbl) as 'Cache Size (MB)', CAST((select top(1) QueriesUseOneCountCacheSize from tbl) * 100 / (select top(1) QueriesCacheSize from tbl) as int) as 'Percent of Queries/Queries' --option(recompile) GO</span></span></code> </pre></div></div><br>  Now we will consider item 2.  about non-optimal indices. <br><br>  Under non-optimal indices we will understand the following 4 factors: <br><br>  1) highly fragmented indices <br>  2) unused indexes <br>  3) missing indexes <br>  4) indexes that use more costs for their maintenance than they bring in performance gains <br><br>  By a highly fragmented index we mean the following indicators of fragmentation: <br><br>  1) more than 30% for indexes whose size is at least 20 pages <br>  2) more than 20% for indexes whose size is at least 100 pages <br>  3) more than 10% for indexes whose size is at least 500 pages <br><br>  The indices of p.2 and p.4 can be determined, for example, using the following representation [inf]. [VDelIndexOptimize] for a specific database: <br><br><div class="spoiler">  <b class="spoiler_title">An example of the implementation of the representation [inf]. [VDelIndexOptimize]</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> [_] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ANSI_NULLS <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> QUOTED_IDENTIFIER <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> [inf].[vDelIndexOptimize] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   ,          ,   .  master, model, msdb  tempdb   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DB_NAME(t.database_id) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [DBName] , SCHEMA_NAME(obj.schema_id) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [SchemaName] , OBJECT_NAME(t.object_id) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [ObjectName] , obj.Type <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [ObjectType] , obj.Type_Desc <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [ObjectTypeDesc] , ind.name <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [IndexName] , ind.Type <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IndexType</span></span> , ind.Type_Desc <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IndexTypeDesc , ind.Is_Unique <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IndexIsUnique , ind.is_primary_key <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IndexIsPK , ind.is_unique_constraint <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IndexIsUniqueConstraint , (t.[USER_SEEKS]+t.[USER_SCANS]+t.[USER_LOOKUPS]+t.[SYSTEM_SEEKS]+t.[SYSTEM_SCANS]+t.[SYSTEM_LOOKUPS])-(t.[USER_UPDATES]+t.[System_Updates]) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [index_advantage] , t.[Database_ID] , t.[Object_ID] , t.[Index_ID] , t.USER_SEEKS , t.USER_SCANS , t.USER_LOOKUPS , t.USER_UPDATES , t.SYSTEM_SEEKS , t.SYSTEM_SCANS , t.SYSTEM_LOOKUPS , t.SYSTEM_UPDATES , t.Last_User_Seek , t.Last_User_Scan , t.Last_User_Lookup , t.Last_System_Seek , t.Last_System_Scan , t.Last_System_Lookup , ind.Filter_Definition, <span class="hljs-keyword"><span class="hljs-keyword">STUFF</span></span>( ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> N<span class="hljs-string"><span class="hljs-string">', ['</span></span> + [<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>] +N<span class="hljs-string"><span class="hljs-string">'] '</span></span>+<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ic.[is_descending_key] <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> N<span class="hljs-string"><span class="hljs-string">'ASC'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> N<span class="hljs-string"><span class="hljs-string">'DESC'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.index_columns ic <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> sys.columns c <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.[object_id] = obj.[object_id] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ic.[column_id] = c.[column_id] <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ic.[object_id] = obj.[object_id] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ic.[index_id]=ind.[index_id] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ic.[is_included_column]=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ic.[key_ordinal] <span class="hljs-keyword"><span class="hljs-keyword">asc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">XML</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PATH</span></span>(<span class="hljs-string"><span class="hljs-string">''</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> ).value(<span class="hljs-string"><span class="hljs-string">'.'</span></span>,<span class="hljs-string"><span class="hljs-string">'NVARCHAR(MAX)'</span></span>),<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Columns</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">STUFF</span></span>( ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> N<span class="hljs-string"><span class="hljs-string">', ['</span></span> + [<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>] +N<span class="hljs-string"><span class="hljs-string">']'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.index_columns ic <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> sys.columns c <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.[object_id] = obj.[object_id] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ic.[column_id] = c.[column_id] <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ic.[object_id] = obj.[object_id] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ic.[index_id]=ind.[index_id] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ic.[is_included_column]=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ic.[key_ordinal] <span class="hljs-keyword"><span class="hljs-keyword">asc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">XML</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PATH</span></span>(<span class="hljs-string"><span class="hljs-string">''</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> ).value(<span class="hljs-string"><span class="hljs-string">'.'</span></span>,<span class="hljs-string"><span class="hljs-string">'NVARCHAR(MAX)'</span></span>),<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [IncludeColumns] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sys.dm_db_index_usage_stats <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> sys.objects <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t.[object_id]=obj.[object_id] <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> sys.indexes <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ind <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t.[object_id]=ind.[object_id] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.index_id=ind.index_id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ((last_user_seek <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> last_user_seek &lt;<span class="hljs-keyword"><span class="hljs-keyword">dateadd</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">year</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">getdate</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (last_user_scan <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> last_user_scan &lt;<span class="hljs-keyword"><span class="hljs-keyword">dateadd</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">year</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">getdate</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (last_user_lookup <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> last_user_lookup &lt;<span class="hljs-keyword"><span class="hljs-keyword">dateadd</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">year</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">getdate</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (last_system_seek <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> last_system_seek &lt;<span class="hljs-keyword"><span class="hljs-keyword">dateadd</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">year</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">getdate</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (last_system_scan <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> last_system_scan &lt;<span class="hljs-keyword"><span class="hljs-keyword">dateadd</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">year</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">getdate</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (last_system_lookup <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> last_system_lookup &lt;<span class="hljs-keyword"><span class="hljs-keyword">dateadd</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">year</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">getdate</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (((t.[USER_UPDATES]+t.[System_Updates])&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (t.[SYSTEM_SEEKS]&lt;=(t.[USER_UPDATES]+t.[System_Updates]-(t.[USER_SEEKS]+t.[USER_SCANS]+t.[USER_LOOKUPS]+t.[SYSTEM_SCANS]+t.[SYSTEM_LOOKUPS]))))) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.database_id&gt;<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.[object_id]&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ind.is_primary_key=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">--     and ind.is_unique_constraint=0 --    and t.database_id=DB_ID() GO</span></span></code> </pre></div></div><br>  It is also important to analyze the <a href="http://www.sql.ru/blogs/andraptor/1218">index overlap</a> .  To do this, create a view [srv]. [VDelIndexInclude] in the database in question: <br><br><div class="spoiler">  <b class="spoiler_title">An example of the implementation of the representation [srv]. [VDelIndexInclude]</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> [_] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ANSI_NULLS <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> QUOTED_IDENTIFIER <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> [srv].[vDelIndexInclude] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  ..  () .                 ,     ,        . http://www.sql.ru/blogs/andraptor/1218 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> cte_index_info <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tSS.[<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [SchemaName] ,tSO.[<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [ObjectName] ,tSO.[type_desc] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [ObjectType] ,tSO.[create_date] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [ObjectCreateDate] ,tSI.[<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [IndexName] ,tSI.[is_primary_key] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [IndexIsPrimaryKey] ,d.[index_type_desc] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">IndexType</span></span>] ,d.[avg_fragmentation_in_percent] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [IndexFragmentation] ,d.[fragment_count] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [IndexFragmentCount] ,d.[avg_fragment_size_in_pages] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [IndexAvgFragmentSizeInPages] ,d.[page_count] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [IndexPages] ,c.key_columns <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [IndexKeyColumns] ,<span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(ic.included_columns, <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [IndexIncludedColumns] ,tSI.is_unique_constraint <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tSDDIPS.[object_id] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [object_id] ,tSDDIPS.[index_id] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [index_id] ,tSDDIPS.[index_type_desc] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [index_type_desc] ,<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(tSDDIPS.[avg_fragmentation_in_percent]) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [avg_fragmentation_in_percent] ,<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(tSDDIPS.[fragment_count]) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [fragment_count] ,<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(tSDDIPS.[avg_fragment_size_in_pages]) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [avg_fragment_size_in_pages] ,<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(tSDDIPS.[page_count]) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [page_count] <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">sys</span></span>].[dm_db_index_physical_stats] (DB_ID(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> , <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, N<span class="hljs-string"><span class="hljs-string">'LIMITED'</span></span>) tSDDIPS <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> tSDDIPS.[object_id] ,tSDDIPS.[index_id] ,tSDDIPS.[index_type_desc] ) d <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">sys</span></span>].[<span class="hljs-keyword"><span class="hljs-keyword">indexes</span></span>] tSI <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tSI.[object_id] = d.[object_id] <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tSI.[index_id] = d.[index_id] <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">sys</span></span>].[objects] tSO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tSO.[object_id] = d.[object_id] <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">sys</span></span>].[schemas] tSS <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tSS.[schema_id] = tSO.[schema_id] <span class="hljs-keyword"><span class="hljs-keyword">CROSS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">APPLY</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STUFF</span></span>(( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">', '</span></span> + c.[<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>] + <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> ic.[is_descending_key] <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'(-)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">sys</span></span>].[index_columns] ic <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">sys</span></span>].[<span class="hljs-keyword"><span class="hljs-keyword">columns</span></span>] c <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> c.[object_id] = ic.[object_id] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.[column_id] = ic.[column_id] <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ic.[index_id] = tSI.[index_id] <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ic.[object_id] = tSI.[object_id] <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ic.[is_included_column] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> ic.[key_ordinal] <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">XML</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PATH</span></span>(<span class="hljs-string"><span class="hljs-string">''</span></span>) ) ,<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [key_columns] ) c <span class="hljs-keyword"><span class="hljs-keyword">CROSS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">APPLY</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STUFF</span></span>(( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">', '</span></span> + c.[<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">sys</span></span>].[index_columns] ic <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">sys</span></span>].[<span class="hljs-keyword"><span class="hljs-keyword">columns</span></span>] c <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> c.[object_id] = ic.[object_id] <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.[column_id] = ic.[column_id] <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ic.[index_id] = tSI.[index_id] <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ic.[object_id] = tSI.[object_id] <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ic.[is_included_column] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">XML</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PATH</span></span>(<span class="hljs-string"><span class="hljs-string">''</span></span>) ) ,<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [included_columns] ) ic <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tSO.[type_desc] <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( N<span class="hljs-string"><span class="hljs-string">'USER_TABLE'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> OBJECTPROPERTY(tSO.[object_id], N<span class="hljs-string"><span class="hljs-string">'IsMSShipped'</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> d.[index_type_desc] <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( <span class="hljs-string"><span class="hljs-string">'HEAP'</span></span> ) ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> t1.[SchemaName] ,t1.[ObjectName] ,t1.[ObjectType] ,t1.[ObjectCreateDate] ,t1.[IndexName] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [DelIndexName] ,t1.[IndexIsPrimaryKey] ,t1.[<span class="hljs-keyword"><span class="hljs-keyword">IndexType</span></span>] ,t1.[IndexFragmentation] ,t1.[IndexFragmentCount] ,t1.[IndexAvgFragmentSizeInPages] ,t1.[IndexPages] ,t1.[IndexKeyColumns] ,t1.[IndexIncludedColumns] ,t2.[IndexName] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [ActualIndexName] <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> cte_index_info t1 <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> cte_index_info t2 <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t2.[SchemaName] = t1.[SchemaName] <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> t2.[ObjectName] = t1.[ObjectName] <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> t2.[IndexName] &lt;&gt; t1.[IndexName] <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PATINDEX</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span>(t1.[IndexKeyColumns], <span class="hljs-string"><span class="hljs-string">'_'</span></span>, <span class="hljs-string"><span class="hljs-string">'[_]'</span></span>) + <span class="hljs-string"><span class="hljs-string">',%'</span></span>, t2.[IndexKeyColumns] + <span class="hljs-string"><span class="hljs-string">','</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> t1.[IndexIncludedColumns] = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-comment"><span class="hljs-comment">-- don't check indexes with INCLUDE columns AND t1.[IndexIsPrimaryKey] = 0 -- don't check primary keys AND t1.is_unique_constraint=0 -- don't check unique constraint AND t1.[IndexType] NOT IN ( N'CLUSTERED INDEX' ,N'UNIQUE CLUSTERED INDEX' ) -- don't check clustered indexes GO</span></span></code> </pre></div></div><br>  It is important to note here that even if the index falls under item 2 or item 4, then there is no need to hurry to delete it.  You must make sure that the system does not really need it.  To do this, it is necessary on a test environment that is as close as possible to the production environment, to carry out the necessary tests ‚Äî first with an index, and then with a remote index (take measurements and compare). <br><br>  Missing indices (p.3) can be determined, for example, using the following representation [inf]. [VRecomendateIndex]: <br><br><div class="spoiler">  <b class="spoiler_title">An example of the implementation of the [inf]. [VRecomendateIndex]</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> [_] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ANSI_NULLS <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> QUOTED_IDENTIFIER <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> [inf].[vRecomendateIndex] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-comment"><span class="hljs-comment">--    DMV SELECT @@ServerName AS ServerName , DB_Name(ddmid.[database_id]) as [DBName] , t.name AS 'Affected_table' , ddmigs.user_seeks * ddmigs.avg_total_user_cost * (ddmigs.avg_user_impact * 0.01) AS index_advantage, ddmigs.group_handle, ddmigs.unique_compiles, ddmigs.last_user_seek, ddmigs.last_user_scan, ddmigs.avg_total_user_cost, ddmigs.avg_user_impact, ddmigs.system_seeks, ddmigs.last_system_scan, ddmigs.last_system_seek, ddmigs.avg_total_system_cost, ddmigs.avg_system_impact, ddmig.index_group_handle, ddmig.index_handle, ddmid.database_id, ddmid.[object_id], ddmid.equality_columns, -- = ddmid.inequality_columns, ddmid.[statement], ( LEN(ISNULL(ddmid.equality_columns, N'') + CASE WHEN ddmid.equality_columns IS NOT NULL AND ddmid.inequality_columns IS NOT NULL THEN ',' ELSE '' END) - LEN(REPLACE(ISNULL(ddmid.equality_columns, N'') + CASE WHEN ddmid.equality_columns IS NOT NULL AND ddmid.inequality_columns IS NOT NULL THEN ',' ELSE '' END, ',', '')) ) + 1 AS K , COALESCE(ddmid.equality_columns, '') + CASE WHEN ddmid.equality_columns IS NOT NULL AND ddmid.inequality_columns IS NOT NULL THEN ',' ELSE '' END + COALESCE(ddmid.inequality_columns, '') AS Keys , ddmid.included_columns AS [include] , 'Create NonClustered Index IX_' + t.name + '_missing_' + CAST(ddmid.index_handle AS VARCHAR(20)) + ' On ' + ddmid.[statement] COLLATE database_default + ' (' + ISNULL(ddmid.equality_columns, '') + CASE WHEN ddmid.equality_columns IS NOT NULL AND ddmid.inequality_columns IS NOT NULL THEN ',' ELSE '' END + ISNULL(ddmid.inequality_columns, '') + ')' + ISNULL(' Include (' + ddmid.included_columns + ');', ';') AS sql_statement , ddmigs.user_seeks , ddmigs.user_scans , CAST(( ddmigs.user_seeks + ddmigs.user_scans ) * ddmigs.avg_user_impact AS BIGINT) AS 'est_impact' , ( SELECT DATEDIFF(Second, create_date, GETDATE()) Seconds FROM sys.databases WHERE name = 'tempdb' ) SecondsUptime FROM sys.dm_db_missing_index_groups ddmig INNER JOIN sys.dm_db_missing_index_group_stats ddmigs ON ddmigs.group_handle = ddmig.index_group_handle INNER JOIN sys.dm_db_missing_index_details ddmid ON ddmig.index_handle = ddmid.index_handle INNER JOIN sys.tables t ON ddmid.OBJECT_ID = t.OBJECT_ID WHERE ddmid.database_id = DB_ID() --ORDER BY est_impact DESC; GO</span></span></code> </pre></div></div><br>  This will return a list of missing indexes for a specific database. <br><br>  If you need a list of missing indexes for all DBMS databases, you can output it by defining the following representation [inf]. [VNewIndexOptimize]: <br><br><div class="spoiler">  <b class="spoiler_title">An example of the implementation of the representation [inf]. [VNewIndexOptimize]</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> [  ] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ANSI_NULLS <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> QUOTED_IDENTIFIER <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> [inf].[vNewIndexOptimize] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     index_advantage: &gt;50 000 -     &gt;10 000 -   ,       &lt;=10000 -     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @@ServerName <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ServerName, DB_Name(ddmid.[database_id]) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [DBName], OBJECT_SCHEMA_NAME(ddmid.[object_id], ddmid.[database_id]) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Schema</span></span>], OBJECT_NAME(ddmid.[object_id], ddmid.[database_id]) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>], ddmigs.user_seeks * ddmigs.avg_total_user_cost * (ddmigs.avg_user_impact * <span class="hljs-number"><span class="hljs-number">0.01</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> index_advantage, ddmigs.group_handle, ddmigs.unique_compiles, ddmigs.last_user_seek, ddmigs.last_user_scan, ddmigs.avg_total_user_cost, ddmigs.avg_user_impact, ddmigs.system_seeks, ddmigs.last_system_scan, ddmigs.last_system_seek, ddmigs.avg_total_system_cost, ddmigs.avg_system_impact, ddmig.index_group_handle, ddmig.index_handle, ddmid.database_id, ddmid.[object_id], ddmid.equality_columns, <span class="hljs-comment"><span class="hljs-comment">-- = ddmid.inequality_columns, ddmid.[statement], ( LEN(ISNULL(ddmid.equality_columns, N'') + CASE WHEN ddmid.equality_columns IS NOT NULL AND ddmid.inequality_columns IS NOT NULL THEN ',' ELSE '' END) - LEN(REPLACE(ISNULL(ddmid.equality_columns, N'') + CASE WHEN ddmid.equality_columns IS NOT NULL AND ddmid.inequality_columns IS NOT NULL THEN ',' ELSE '' END, ',', '')) ) + 1 AS K , COALESCE(ddmid.equality_columns, '') + CASE WHEN ddmid.equality_columns IS NOT NULL AND ddmid.inequality_columns IS NOT NULL THEN ',' ELSE '' END + COALESCE(ddmid.inequality_columns, '') AS Keys , ddmid.included_columns AS [include] , 'Create NonClustered Index [IX_' + OBJECT_NAME(ddmid.[object_id], ddmid.[database_id]) + '_missing_' + CAST(ddmid.index_handle AS VARCHAR(20)) + '] On ' + ddmid.[statement] COLLATE database_default + ' (' + ISNULL(ddmid.equality_columns, '') + CASE WHEN ddmid.equality_columns IS NOT NULL AND ddmid.inequality_columns IS NOT NULL THEN ',' ELSE '' END + ISNULL(ddmid.inequality_columns, '') + ')' + ISNULL(' Include (' + ddmid.included_columns + ');', ';') AS sql_statement , ddmigs.user_seeks , ddmigs.user_scans , CAST(( ddmigs.user_seeks + ddmigs.user_scans ) * ddmigs.avg_user_impact AS BIGINT) AS 'est_impact' , ( SELECT DATEDIFF(Second, create_date, GETDATE()) Seconds FROM sys.databases WHERE name = 'tempdb' ) SecondsUptime FROM sys.dm_db_missing_index_group_stats ddmigs INNER JOIN sys.dm_db_missing_index_groups AS ddmig ON ddmigs.group_handle = ddmig.index_group_handle INNER JOIN sys.dm_db_missing_index_details AS ddmid ON ddmig.index_handle = ddmid.index_handle --WHERE mid.database_id = DB_ID() --ORDER BY migs_adv.index_advantage GO</span></span></code> </pre></div></div><br>  Here (as in clause 2 and clause 4) it is also important to note that even if the index falls under clause 3, then there is no need to rush to create it.  You need to make sure that the system really needs it.  For this, it is necessary on a test environment that is as close as possible to the production environment, to carry out the necessary tests ‚Äî first without a new index, and then with a new index (take measurements and compare).  It is not uncommon for a new index from clause 3 to become later an index from clause 2 or clause 4. <br><br>  So how to solve the problem of claim 1 - to get rid of a strong degree of index fragmentation?  The Internet is full of ready-made solutions on this issue.  Let's give one more example which will be based on recommendations from <a href="https://docs.microsoft.com/ru-ru/sql/relational-databases/indexes/reorganize-and-rebuild-indexes">msdn</a> . <br><br>  To do this, create the [inf]. [VIndexDefrag] view in those databases where you need to consider the level of index fragmentation: <br><br><div class="spoiler">  <b class="spoiler_title">An example of the implementation of the representation [inf]. [VIndexDefrag]</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> [_] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ANSI_NULLS <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> QUOTED_IDENTIFIER <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> [inf].[vIndexDefrag] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> info <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ps.[object_id], ps.database_id, ps.index_id, ps.index_type_desc, ps.index_level, ps.fragment_count, ps.avg_fragmentation_in_percent, ps.avg_fragment_size_in_pages, ps.page_count, ps.record_count, ps.ghost_record_count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.dm_db_index_physical_stats (DB_ID() , <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> , N<span class="hljs-string"><span class="hljs-string">'LIMITED'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ps <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> sys.indexes <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> i.[object_id]=ps.[object_id] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> i.[index_id]=ps.[index_id] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ps.index_level = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ps.avg_fragmentation_in_percent &gt;= <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ps.index_type_desc &lt;&gt; <span class="hljs-string"><span class="hljs-string">'HEAP'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ps.page_count&gt;=<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-comment"><span class="hljs-comment">--1  and i.is_disabled=0 ) SELECT DB_NAME(i.database_id) as db, SCHEMA_NAME(t.[schema_id]) as shema, t.name as tb, i.index_id as idx, i.database_id, (select top(1) idx.[name] from [sys].[indexes] as idx where t.[object_id] = idx.[object_id] and idx.[index_id] = i.[index_id]) as index_name, i.index_type_desc,i.index_level as [level], i.[object_id], i.fragment_count as frag_num, round(i.avg_fragmentation_in_percent,2) as frag, round(i.avg_fragment_size_in_pages,2) as frag_page, i.page_count as [page], i.record_count as rec, i.ghost_record_count as ghost, round(i.avg_fragmentation_in_percent*i.page_count,0) as func FROM info as i inner join [sys].[all_objects] as t on i.[object_id] = t.[object_id]; GO</span></span></code> </pre></div></div><br>  Here will be a list of those included indexes that are not heaps, occupy at least 1 extent (8 pages) and have a fragmentation level of at least 10%. <br><br>  We will also create 2 tables in the database for administration - to save the list of processed indexes and to save the results of processed indexes.  The first table is needed in order not to take into account two times the same indices until all indices are processed: <br><br><div class="spoiler">  <b class="spoiler_title">Table for saving a list of indexes that have been reorganized in one iteration</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> [  ] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ANSI_NULLS <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> QUOTED_IDENTIFIER <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> [srv].[ListDefragIndex]( [db] [<span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>](<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [shema] [<span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>](<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>] [<span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>](<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [IndexName] [<span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>](<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [object_id] [<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [idx] [<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [db_id] [<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [frag] [<span class="hljs-built_in"><span class="hljs-built_in">decimal</span></span>](<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [InsertUTCDate] [datetime] <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> [PK_ListDefragIndex] PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> CLUSTERED ( [object_id] <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, [idx] <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, [db_id] <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span> )<span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (PAD_INDEX = <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>, STATISTICS_NORECOMPUTE = <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>, IGNORE_DUP_KEY = <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>, ALLOW_ROW_LOCKS = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>, ALLOW_PAGE_LOCKS = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> [PRIMARY] ) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> [PRIMARY] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> [srv].[ListDefragIndex] <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> [DF_ListDefragIndex_InsertUTCDate] <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">getutcdate</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> [InsertUTCDate] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Table for saving history about the reorganization of the indexes of all databases of an instance of MS SQL Server</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> [  ] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ANSI_NULLS <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> QUOTED_IDENTIFIER <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> [srv].[Defrag]( [<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>] [<span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [db] [<span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>](<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [shema] [<span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>](<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>] [<span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>](<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [IndexName] [<span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>](<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [frag_num] [<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [frag] [<span class="hljs-built_in"><span class="hljs-built_in">decimal</span></span>](<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [page] [<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [rec] [<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>] <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [ts] [datetime] <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [tf] [datetime] <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [frag_after] [<span class="hljs-built_in"><span class="hljs-built_in">decimal</span></span>](<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [object_id] [<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [idx] [<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [InsertUTCDate] [datetime] <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> [PK_Defrag] PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> CLUSTERED ( [<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span> )<span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (PAD_INDEX = <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>, STATISTICS_NORECOMPUTE = <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>, IGNORE_DUP_KEY = <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>, ALLOW_ROW_LOCKS = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>, ALLOW_PAGE_LOCKS = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> [PRIMARY] ) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> [PRIMARY] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> [srv].[Defrag] <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> [DF_Defrag_InsertUTCDate] <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">getutcdate</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> [InsertUTCDate] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span></code> </pre></div></div><br>  Next, create the [srv]. [AutoDefragIndex] stored procedure itself for optimizing indexes on each desired database (also on system databases) as follows: <br><br><div class="spoiler">  <b class="spoiler_title">An example implementation of the stored procedure [srv]. [AutoDefragIndex]</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> [_] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ANSI_NULLS <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> QUOTED_IDENTIFIER <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> [srv].[AutoDefragIndex] @<span class="hljs-keyword"><span class="hljs-keyword">count</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>=<span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-comment"><span class="hljs-comment">---    ,@isrebuild bit=0 --    (   30%) AS BEGIN SET NOCOUNT ON; SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; --      ONLINE declare @isRebuildOnline bit=CASE WHEN (CAST (SERVERPROPERTY ('Edition') AS nvarchar (max)) LIKE '%Enterprise%' OR CAST (SERVERPROPERTY ('Edition') AS nvarchar (max)) LIKE '%Developer%' OR CAST (SERVERPROPERTY ('Edition') AS nvarchar (max)) LIKE '%Evaluation%') THEN 1 ELSE 0 END; declare @IndexName nvarchar(100) ,@db nvarchar(100) ,@db_id int ,@Shema nvarchar(100) ,@Table nvarchar(100) ,@SQL_Str nvarchar (max)=N'' ,@frag decimal(6,2) ,@frag_after decimal(6,2) ,@frag_num int ,@page int ,@ts datetime ,@tsg datetime ,@tf datetime ,@object_id int ,@idx int ,@rec int; --  declare @tbl table ( IndexName nvarchar(100) ,db nvarchar(100) ,[db_id] int ,Shema nvarchar(100) ,[Table] nvarchar(100) ,frag decimal(6,2) ,frag_num int ,[page] int ,[object_id] int ,idx int ,rec int ); --  declare @tbl_copy table ( IndexName nvarchar(100) ,db nvarchar(100) ,[db_id] int ,Shema nvarchar(100) ,[Table] nvarchar(100) ,frag decimal(6,2) ,frag_num int ,[page] int ,[object_id] int ,idx int ,rec int ); set @ts = getdate() set @tsg = @ts; -- ,    ,   10% --     if(@count is null) begin insert into @tbl ( IndexName ,db ,[db_id] ,Shema ,[Table] ,frag ,frag_num ,[page] ,[object_id] ,idx ,rec ) select ind.index_name, ind.db, ind.database_id, ind.shema, ind.tb, ind.frag, ind.frag_num, ind.[page], ind.[object_id], ind.idx , ind.rec from [inf].[vIndexDefrag] as ind where not exists( select top(1) 1 from [  ].[srv].[ListDefragIndex] as lind where lind.[db_id]=ind.database_id and lind.[idx]=ind.idx and lind.[object_id]=ind.[object_id] ) --order by ind.[page] desc, ind.[frag] desc end else begin insert into @tbl ( IndexName ,db ,[db_id] ,Shema ,[Table] ,frag ,frag_num ,[page] ,[object_id] ,idx ,rec ) select top (@count) ind.index_name, ind.db, ind.database_id, ind.shema, ind.tb, ind.frag, ind.frag_num, ind.[page], ind.[object_id], ind.idx , ind.rec from [inf].[vIndexDefrag] as ind where not exists( select top(1) 1 from [  ].[srv].[ListDefragIndex] as lind where lind.[db_id]=ind.database_id and lind.[idx]=ind.idx and lind.[object_id]=ind.[object_id] ) --order by ind.[page] desc, ind.[frag] desc end --    (   ) --     --   if(not exists(select top(1) 1 from @tbl)) begin delete from [  ].[srv].[ListDefragIndex] where [db_id]=DB_ID(); if(@count is null) begin insert into @tbl ( IndexName ,db ,[db_id] ,Shema ,[Table] ,frag ,frag_num ,[page] ,[object_id] ,idx ,rec ) select ind.index_name, ind.db, ind.database_id, ind.shema, ind.tb, ind.frag, ind.frag_num, ind.[page], ind.[object_id], ind.idx , ind.rec from [inf].[vIndexDefrag] as ind where not exists( select top(1) 1 from [  ].[srv].[ListDefragIndex] as lind where lind.[db_id]=ind.database_id and lind.[idx]=ind.idx and lind.[object_id]=ind.[object_id] ) --order by ind.[page] desc, ind.[frag] desc end else begin insert into @tbl ( IndexName ,db ,[db_id] ,Shema ,[Table] ,frag ,frag_num ,[page] ,[object_id] ,idx ,rec ) select top (@count) ind.index_name, ind.db, ind.database_id, ind.shema, ind.tb, ind.frag, ind.frag_num, ind.[page], ind.[object_id], ind.idx , ind.rec from [inf].[vIndexDefrag] as ind where not exists( select top(1) 1 from [  ].[srv].[ListDefragIndex] as lind where lind.[db_id]=ind.database_id and lind.[idx]=ind.idx and lind.[object_id]=ind.[object_id] ) --order by ind.[page] desc, ind.[frag] desc end end --    if(exists(select top(1) 1 from @tbl)) begin --   INSERT INTO [  ].[srv].[ListDefragIndex] ( [db] ,[shema] ,[table] ,[IndexName] ,[object_id] ,[idx] ,[db_id] ,[frag] ) select [db] ,[shema] ,[table] ,[IndexName] ,[object_id] ,[idx] ,[db_id] ,[frag] from @tbl; insert into @tbl_copy ( IndexName ,db ,[db_id] ,Shema ,[Table] ,frag ,frag_num ,[page] ,[object_id] ,idx ,rec ) select IndexName ,db ,[db_id] ,Shema ,[Table] ,frag ,frag_num ,[page] ,[object_id] ,idx ,rec from @tbl; --      (  -     ) while(exists(select top(1) 1 from @tbl)) begin select top(1) @IndexName=[IndexName], @Shema=[Shema], @Table=[Table], @frag=[frag] from @tbl; if(@frag&gt;=30 and @isrebuild=1 and @isRebuildOnline=1) begin set @SQL_Str = @SQL_Str+'ALTER INDEX ['+@IndexName+'] on ['+@Shema+'].['+@Table+'] REBUILD WITH(ONLINE=ON);' end else begin set @SQL_Str = @SQL_Str+'ALTER INDEX ['+@IndexName+'] on ['+@Shema+'].['+@Table+'] REORGANIZE;' +'UPDATE STATISTICS ['+@Shema+'].['+@Table+'] ['+@IndexName+'];'; end delete from @tbl where [IndexName]=@IndexName and [Shema]=@Shema and [Table]=@Table; end --   execute sp_executesql @SQL_Str; --    insert into [  ].srv.Defrag( [db], [shema], [table], [IndexName], [frag_num], [frag], [page], ts, tf, frag_after, [object_id], idx, rec ) select [db], [shema], [table], [IndexName], [frag_num], [frag], [page], @ts, getdate(), (SELECT top(1) avg_fragmentation_in_percent FROM sys.dm_db_index_physical_stats (DB_ID([db]), [object_id], [idx], NULL , N'LIMITED') where index_level = 0) as frag_after, [object_id], [idx], [rec] from @tbl_copy; end END GO</span></span></code> </pre></div></div><br>  It is important to note that when rebuilding an index, it is not necessary to update statistics on an index.  The index is also rebuilt here only if it is fragmented by no less than 30% and, at the same time, the release of MS SQL Server allows it to be done in ONLINE mode, and the input parameter @isrebuild of the stored procedure was set as 1. <br><br>  Here, the count parameter is needed more to distribute the load throughout the day.  If optimization by indexes occurs only at a certain time during a day or less, then you can pass NULL to count (as default). <br><br>  Now we will create the stored procedure [srv]. [AutoDefragIndexDB] in the database for administration, for its subsequent call: <br><br><div class="spoiler">  <b class="spoiler_title">An example implementation of the stored procedure [srv]. [AutoDefragIndexDB]</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> [  ] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ANSI_NULLS <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> QUOTED_IDENTIFIER <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> [srv].[AutoDefragIndexDB] @DB <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>)=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">--      @count int=NULL, ---       @IsTempdb bit=0 --   tempdb AS BEGIN /*       */ SET NOCOUNT ON; declare @db_name nvarchar(255); declare @sql nvarchar(max); declare @ParmDefinition nvarchar(255)= N'@count int'; if(@DB is null) begin select [name] into #tbls from sys.databases where [is_read_only]=0 and [state]=0 --ONLINE and [user_access]=0--MULTI_USER and (((@IsTempdb=0 or @IsTempdb is null) and [name]&lt;&gt;N'tempdb') or (@IsTempdb=1)); while(exists(select top(1) 1 from #tbls)) begin select top(1) @db_name=[name] from #tbls; set @sql=N'USE ['+@db_name+']; '+ N'IF(object_id('+N''''+N'[srv].[AutoDefragIndex]'+N''''+N') is not null) EXEC [srv].[AutoDefragIndex] @count=@count;'; exec sp_executesql @sql, @ParmDefinition, @count=@count; delete from #tbls where [name]=@db_name; end drop table #tbls; end else begin set @sql=N'USE ['+@DB+']; '+ N'IF(object_id('+N''''+N'[srv].[AutoDefragIndex]'+N''''+N') is not null) EXEC [srv].[AutoDefragIndex] @count=@count;'; exec sp_executesql @sql, @ParmDefinition, @count=@count; end END GO</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, to automate the process of optimizing indexes, you can take the following steps: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) for each desired database, define the representation [inf]. [VIndexDefrag] and the stored procedure [srv]. [AutoDefragIndex] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) in the administration database, define two tables [srv]. [ListDefragIndex] and [srv]. [Defrag], and stored procedure [srv]. [AutoDefragIndexDB] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) create a task in the agent on a periodic call to the stored procedure [srv]. [AutoDefragIndexDB] administration of BD </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now analyze claim 3 nonoptimal statistics.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In most cases, when executing p.1-2 or p.2 simply by directly optimizing the database and the DBMS as a whole and setting statistics update in the database properties (automatic update of statistics, statistics of automatic creation, asynchronous automatic update of statistics, automatic creation of statistics with ), MS SQL Server copes well with the task of optimizing statistics. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main thing is not to forget to update the statistics after the index reorganization, that is, in this case, it is not updated, as well as when executing item 1 on cleaning the procedural cache.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But sometimes there are cases when MS SQL Server does not cope with its task due to the specifics of the entire information system or if it is impossible to use item 1 (clearing the procedural cache). </font><font style="vertical-align: inherit;">Then you can take from item 1 just a command to update the statistics for the entire database:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Updating statistics for the entire database</font></font></b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> [_] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> exec sp_updatestats; GO</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, if this is not enough or updating the statistics for the entire database takes a very long time, then it is necessary to consider a more flexible algorithm for updating the statistics. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immediately, it is worth noting that when building a more flexible algorithm for updating statistics, step 1 for clearing the procedural cache and updating all database statistics is not applicable in the block for directly optimizing the database and the DBMS as a whole. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we give an example of the implementation of p.3 in the case when it is impossible to update the statistics for the entire database and the built-in tools are also insufficient. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To do this, create the following stored procedure [srv]. [AutoUpdateStatistics] in the necessary databases:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example implementation of the stored procedure [srv]. [AutoUpdateStatistics]</font></font></b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> [_] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ANSI_NULLS <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> QUOTED_IDENTIFIER <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> [srv].[AutoUpdateStatistics] <span class="hljs-comment"><span class="hljs-comment">--       @ObjectSizeMB numeric (16,3) = NULL, -- -    @row_count numeric (16,3) = NULL AS BEGIN /*    */ SET NOCOUNT ON; SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; declare @ObjectID int; declare @SchemaName nvarchar(255); declare @ObjectName nvarchar(255); declare @StatsID int; declare @StatName nvarchar(255); declare @SQL_Str nvarchar(max); ;with st AS( select DISTINCT obj.[object_id] , obj.[create_date] , OBJECT_SCHEMA_NAME(obj.[object_id]) as [SchemaName] , obj.[name] as [ObjectName] , CAST( ( --  ,    ( 8   1024 =  128) SELECT SUM(ps2.[reserved_page_count])/128. from sys.dm_db_partition_stats as ps2 where ps2.[object_id] = obj.[object_id] ) as numeric (38,2) ) as [ObjectSizeMB] --    , s.[stats_id] , s.[name] as [StatName] , sp.[last_updated] , i.[index_id] , i.[type_desc] , i.[name] as [IndexName] , ps.[row_count] , s.[has_filter] , s.[no_recompute] , sp.[rows] , sp.[rows_sampled] ---   : --  -           --   -                 , sp.[modification_counter]+ABS(ps.[row_count]-sp.[rows]) as [ModificationCounter] --%  ,    , --             , NULLIF(CAST( sp.[rows_sampled]*100./sp.[rows] as numeric(18,3)), 100.00) as [ProcSampled] --%  -           --      , CAST(sp.[modification_counter]*100./(case when (ps.[row_count]=0) then 1 else ps.[row_count] end) as numeric (18,3)) as [ProcModified] -- : --[ProcModified]*    -    , CAST(sp.[modification_counter]*100./(case when (ps.[row_count]=0) then 1 else ps.[row_count] end) as numeric (18,3)) * case when (ps.[row_count]&lt;=10) THEN 1 ELSE LOG10 (ps.[row_count]) END as [Func] --  : --  ,    ,   --            , CASE WHEN sp.[rows_sampled]&lt;&gt;sp.[rows] THEN 0 ELSE 1 END as [IsScanned] , tbl.[name] as [ColumnType] , s.[auto_created] from sys.objects as obj inner join sys.stats as s on s.[object_id] = obj.[object_id] left outer join sys.indexes as i on i.[object_id] = obj.[object_id] and (i.[name] = s.[name] or i.[index_id] in (0,1) and not exists(select top(1) 1 from sys.indexes i2 where i2.[object_id] = obj.[object_id] and i2.[name] = s.[name])) left outer join sys.dm_db_partition_stats as ps on ps.[object_id] = obj.[object_id] and ps.[index_id] = i.[index_id] outer apply sys.dm_db_stats_properties (s.[object_id], s.[stats_id]) as sp left outer join sys.stats_columns as sc on s.[object_id] = sc.[object_id] and s.[stats_id] = sc.[stats_id] left outer join sys.columns as col on col.[object_id] = s.[object_id] and col.[column_id] = sc.[column_id] left outer join sys.types as tbl on col.[system_type_id] = tbl.[system_type_id] and col.[user_type_id] = tbl.[user_type_id] where obj.[type_desc] &lt;&gt; 'SYSTEM_TABLE' ) SELECT st.[object_id] , st.[SchemaName] , st.[ObjectName] , st.[stats_id] , st.[StatName] INTO #tbl FROM st WHERE NOT (st.[row_count] = 0 AND st.[last_updated] IS NULL)--       --   AND NOT (st.[row_count] = st.[rows] AND st.[row_count] = st.[rows_sampled] AND st.[ModificationCounter]=0) --    (   ) AND ((st.[ProcModified]&gt;=10.0) OR (st.[Func]&gt;=10.0) OR (st.[ProcSampled]&lt;=50)) --,     AND ( ([ObjectSizeMB]&lt;=@ObjectSizeMB OR @ObjectSizeMB IS NULL) AND (st.[row_count]&lt;=@row_count OR @row_count IS NULL) ); WHILE (exists(select top(1) 1 from #tbl)) BEGIN select top(1) @ObjectID =[object_id] ,@SchemaName=[SchemaName] ,@ObjectName=[ObjectName] ,@StatsId =[stats_id] ,@StatName =[StatName] from #tbl; SET @SQL_Str = 'IF (EXISTS(SELECT TOP(1) 1 FROM sys.stats as s WHERE s.[object_id] = '+CAST(@ObjectID as nvarchar(32)) + ' AND s.[stats_id] = ' + CAST(@StatsId as nvarchar(32)) +')) UPDATE STATISTICS ' + QUOTENAME(@SchemaName) +'.' + QUOTENAME(@ObjectName) + ' ('+QUOTENAME(@StatName) + ') WITH FULLSCAN;'; execute sp_executesql @SQL_Str; delete from #tbl where [object_id]=@ObjectID and [stats_id]=@StatsId; END drop table #tbl; END GO</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here you can notice the fact that statistics are updated only for those objects for which significant changes were made. However, it is worth paying attention to the value of the [IsScanned] column. If it is different from 1, this means that the total number of rows in the table or indexed view at the last update of statistics and the total number of rows selected for statistical calculations do not match. This means that the statistics are already outdated. And although the algorithm considers only significant changes in the data, it is not necessary to exclude the need that someday you may need to update all the statistics of the object in which there were few changes and which weighs very much on the data. Therefore, the above algorithm cannot be universal for all databases,but for most it is suitable as a starting point for further fine tuning in statistics optimization.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Next, in the database for administration, we create a stored procedure [srv]. [AutoUpdateStatisticsDB], which will then need to be periodically run according to the rules: </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example implementation of the stored procedure [srv]. [AutoUpdateStatisticsDB]</font></font></b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> [  ] <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ANSI_NULLS <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> QUOTED_IDENTIFIER <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> [srv].[AutoUpdateStatisticsDB] @DB <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>)=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">--      @ObjectSizeMB numeric (16,3) = NULL, -- -    @row_count numeric (16,3) = NULL, @IsTempdb bit=0 --   tempdb AS BEGIN /*        */ SET NOCOUNT ON; declare @db_name nvarchar(255); declare @sql nvarchar(max); declare @ParmDefinition nvarchar(255)= N'@ObjectSizeMB numeric (16,3), @row_count numeric (16,3)'; if(@DB is null) begin select [name] into #tbls from sys.databases where [is_read_only]=0 and [state]=0 --ONLINE and [user_access]=0--MULTI_USER and (((@IsTempdb=0 or @IsTempdb is null) and [name]&lt;&gt;N'tempdb') or (@IsTempdb=1)); while(exists(select top(1) 1 from #tbls)) begin select top(1) @db_name=[name] from #tbls; set @sql=N'USE ['+@db_name+']; '+ N'IF(object_id('+N''''+N'[srv].[AutoUpdateStatistics]'+N''''+N') is not null) EXEC [srv].[AutoUpdateStatistics] @ObjectSizeMB=@ObjectSizeMB, @row_count=@row_count;'; exec sp_executesql @sql, @ParmDefinition, @ObjectSizeMB=@ObjectSizeMB, @row_count=@row_count; delete from #tbls where [name]=@db_name; end drop table #tbls; end else begin set @sql=N'USE ['+@DB+']; '+ N'IF(object_id('+N''''+N'[srv].[AutoUpdateStatistics]'+N''''+N') is not null) EXEC [srv].[AutoUpdateStatistics] @ObjectSizeMB=@ObjectSizeMB, @row_count=@row_count;'; exec sp_executesql @sql, @ParmDefinition, @ObjectSizeMB=@ObjectSizeMB, @row_count=@row_count; end END GO</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usually, a more flexible algorithm for updating statistics is needed in such databases, where the hardware power is not capable of updating statistics for the entire database in a reasonable time, that is, databases with very large data sizes (significantly more than 1 TB). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, all 3 points of the first block were considered on the direct optimization of the database itself and the DBMS as a whole. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to this block, the following general recommendations should be added: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) it is necessary to ensure that the database data files are fragmented from 5 to 20% (if less than 5% increase (by setting the initial size in the database file properties), more than 20% - compress with the help of the command </font></font><a href="https://msdn.microsoft.com/ru-ru/library/ms189493(v%3Dsql.120).aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHRINKFILE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) it is necessary to maintain the system databases by indices and statistics (especially </font></font><a href="https://docs.microsoft.com/ru-ru/sql/relational-databases/databases/msdb-database"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msdb</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) it is necessary to clean the logs of the </font></font><a href="https://docs.microsoft.com/ru-ru/sql/relational-databases/databases/msdb-database"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msdb</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> database </font><font style="vertical-align: inherit;">, for example as follows:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of cleaning the msdb database logs</font></font></b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> @dt datetime=<span class="hljs-keyword"><span class="hljs-keyword">DateAdd</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">day</span></span>,<span class="hljs-number"><span class="hljs-number">-28</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">GetDate</span></span>()); exec msdb.dbo.sp_delete_backuphistory @dt; exec msdb.dbo.sp_purge_jobhistory @oldest_date=@dt; exec msdb.dbo.sp_maintplan_delete_log null, null, @dt; exec msdb.dbo.sp_cycle_errorlog; exec msdb.dbo.sp_Cycle_Agent_ErrorLog; ...</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's analyze the second block for optimizing the interaction between the application and MS SQL Server (.NET and MS SQL Server applications). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we present only the main recommendations without examples of implementation, so that the article does not turn out too capacious. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, here are the general recommendations for optimizing the interaction between the application and MS SQL Server: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) Try to work not with a string, but with a set when sending commands to the DBMS </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) Try to send requests to the DBMS asynchronously and not make the user wait for the application response </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) Try to send requests to the DBMS in batches, and not in single ones (especially relevant when changing data) - that is, implement a delayed launch mechanism and query accumulation system</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4) Use hashing for all software components to reduce access to the DBMS </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5) Sign </font><font style="vertical-align: inherit;">application components </font><font style="vertical-align: inherit;">in </font></font><a href="https://docs.microsoft.com/ru-ru/dotnet/api/system.data.sqlclient.sqlconnection.connectionstring%3Fview%3Dnetframework-4.7.1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the connection string</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to the database in the Application Name:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application Name Usage Example</font></font></b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Data.SqlClient; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleApp2</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { OpenSqlConnection(); Console.ReadKey(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenSqlConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> connectionString = GetConnectionString(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (SqlConnection connection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlConnection()) { connection.ConnectionString = connectionString; connection.Open(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"State: {0}"</span></span>, connection.State); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"ConnectionString: {0}"</span></span>, connection.ConnectionString); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetConnectionString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SqlConnectionStringBuilder conn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlConnectionStringBuilder(); conn.ApplicationName = <span class="hljs-string"><span class="hljs-string">"MyProgram"</span></span>; conn.DataSource = <span class="hljs-string"><span class="hljs-string">"SQLServerName"</span></span>; conn.InitialCatalog = <span class="hljs-string"><span class="hljs-string">"DBName"</span></span>; conn.IntegratedSecurity = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conn.ToString(); } } }</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6) Set </font></font><a href="https://docs.microsoft.com/ru-ru/sql/t-sql/statements/set-transaction-isolation-level-transact-sql"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the isolation level</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> correctly </font><font style="vertical-align: inherit;">when working with the database. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7) On the server side of the software, if necessary, implement a queue of calls to the DBMS, which will take into account not only the specifics of the information system, but also the hardware capabilities of the DBMS server or DBMS server group, if the latter work as AlwaysOn </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8) Try to pre-filter as much data as possible, rather than requesting everything from the DBMS at once and then applying the filter (for example, use paged return if necessary with dynamic asynchronous data loading) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9) Try not to filter on a large array of data not on the DBMS side (see the previous paragraph) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10) Separate the component logs and the database logs, but do not write everything in one table</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we will sort the third block on optimization of requests. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will not go into much detail here again, we will not occupy the whole book, but we will describe only some key points. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, the general recommendations for optimizing the queries themselves: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) try to filter the data as far as possible before joining them with other tables </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) try to sort the result set as little as possible by the data volume </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) avoid the DISTINCT, LIKE '% construction whenever possible. .. ', OUTER JOIN especially on big data </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4) if the sample needs only one field from the table being joined, then do not join such a table, and in the sample itself make a subquery</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5) when filtering, aggregating and sampling, try to take into account the available indexes so that the optimizer can use them </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6) try to return only those fields that are really needed, and not all fields from all the connected tables (do not match the code in T-SQL, t for it is a very bad approach especially with large data) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7) when updating and deleting data (if the filter or aggregation is not built on the clustered index or clustered index in addition there are other conditions or aggregation), then do not do the operation from the table, and the first Select the deleted / modified data to a temporary table (which will consist of columns that are included in the clustered index, as well as all other required fields to update) and apply directly after removal / update</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8) do not overload the conditions for joining the tables, but rather bring some of the conditions into the filter </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9) use hints sensibly for queries. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For more understanding, we will give an example of clause 7. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, we have a Personal table (there is a clustered index in the ID field) and remove all people with a name containing the substring 'on' from it and update the comment by the name of those people whose last name ends with 'you'. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here's how to implement this task:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examples according to claim 7</font></font></b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-comment"><span class="hljs-comment">#tbl_del from [Personal] where [FirstName] like '%%'; delete from p from #tbl_del as t inner join [Personal] as p on t.[ID]=p.[ID]; drop table #tbl_del; select [ID] ,[FirstName] into #tbl_upd from [Personal] where [LastName] like '%'; update p set p.[Comment]=t.[FirstName] from #tbl_upd as t inner join [Personal] as p on t.[ID]=p.[ID]; drop table #tbl_upd;</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, when the example of clause 7 was considered on simple queries, we will give an example of the work of so-called duplicates. </font><font style="vertical-align: inherit;">The problem of removing duplicate records is quite common. </font><font style="vertical-align: inherit;">It can be implemented as follows:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of removing duplicate records according to paragraph 7</font></font></b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--      Personal     . --       ,  ,    : ;with DelDups as ( select [ID], --         row_number() over(partition by [FirstName], [LastName] order by [InsertDate] desc) as [rn] from [Personal] ) select [ID] into #tbl_del delete from DelDups where rn&gt;1; delete from p from #tbl_del as t inner join [Personal] as p on t.[ID]=p.[ID]; drop table #tbl_del;</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Similarly, an example of updating duplicate rows is considered. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, all 3 blocks were considered for optimizing both the database itself and the DBMS as a whole, and when the software was accessed and the queries themselves.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, it is also worth noting that with the growth of the information system, in particular the number of simultaneous users and the volumes of the database itself, it is worthwhile to consider the separation of systems into OLTP and OLAP, where background tasks (such as integration, data movement (ETL, etc.) and e) will be performed with the OLAP system (including reports), and real-time tasks emanating from users will be performed with the OLTP system. This separation will allow even more fine-tuning of each of the systems and greatly reduce the load on the OLTP system. Here you can follow the golden rule: the number of requests from users in the OLTP system should be many times greater than the number of all other requests. Similarly, the total volume of data processed for a sufficiently long period (week, month and so on).Although in practice it is not uncommon to encounter the opposite situation, when users turn mainly to the OLAP system, and all other tasks apply (accumulate new data with subsequent transfer to the OLAP via ETL) to the OLTP system.</font></font><br><br>  Comment.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, to distinguish the OLAP system from the OLTP, it is enough to check one fact: in the first system, the number of data samples will be many times greater than the number of changes in data on the frequency of operations (either changes are rare or occur in such small volumes as compared with selectable volumes, that these changes can be neglected). The OLTP system is exactly the opposite. OLAP and OLTP systems are configured differently, and the hybrid solution will increasingly show its inadequacy with increasing data volumes and the number of simultaneous references to these data (these characteristics will be particularly acute in databases whose volumes are significantly larger than 1 TB). If the database is significantly less than 1 TB, then the division into OLTP and OLAP may not be necessary, and this optimization may not give a significant increase in performance (users will not sense it).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also try to use all available features intelligently from both the DBMS itself and the OS as a whole, and also properly configure the hardware resources themselves for overall optimization of work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, do not forget about the limitation of resources (CPU, RAM and the capacity of the input-output system, as well as the speed of its work). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After all the optimizations, it is also important to clarify over time the future growth in requirements for the DBMS (in particular, the increase in the number of simultaneous calls, the increase in the volume of data being processed, and so on) and predict problems in advance and ways to solve them where it is necessary to improve the hardware or purchase the missing capacity for the future).</font></font><br><br><h3>  Result </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This article has reviewed the optimization of the database and database management system as a whole, and also provides general recommendations for optimizing applications for working with the database management system and the database queries themselves. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The above recommendations make it possible to significantly optimize the entire DBMS for a long term, taking into account the further development of the information system and an increase in the number of simultaneous references to the DBMS.</font></font><br><br><h3>  Sources: </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ª </font></font><a href="https://docs.microsoft.com/ru-ru/sql/relational-databases/system-dynamic-management-views/system-dynamic-management-views"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamic administrative views of the system</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="http://www.sql.ru/blogs/andraptor/1218"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Index overlapping</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="https://docs.microsoft.com/ru-ru/sql/relational-databases/indexes/reorganize-and-rebuild-indexes"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reorganization and rebuilding of indices</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="https://msdn.microsoft.com/ru-ru/library/ms189493(v%3Dsql.120).aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHRINKFILE</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="https://docs.microsoft.com/ru-ru/sql/relational-databases/databases/msdb-database"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msdb</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="https://docs.microsoft.com/ru-ru/dotnet/api/system.data.sqlclient.sqlconnection.connectionstring%3Fview%3Dnetframework-4.7.1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connection string</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="https://docs.microsoft.com/ru-ru/sql/t-sql/statements/set-transaction-isolation-level-transact-sql"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isolation level</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="https://habrahabr.ru/post/209816/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatic update of statistics</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="https://habrahabr.ru/post/314454/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatic defragmentation of indexes</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="https://club.directum.ru/post/1125"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Current size of all plan cache and query plan cache</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/349910/">https://habr.com/ru/post/349910/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349900/index.html">Creating a Telegram bot to get information on the Dogecoin wallet</a></li>
<li><a href="../349902/index.html">"Digital States": how it all began</a></li>
<li><a href="../349904/index.html">GLPI in a small organization, part 2. Basic functionality and features of its use</a></li>
<li><a href="../349906/index.html">Setting up VoIP FXO gateway Yeastar Neogate TAXXX to work with 3CX</a></li>
<li><a href="../349908/index.html">How to learn to learn. Part 3 - we train memory "on a science"</a></li>
<li><a href="../349912/index.html">Ruby on Rails ActionCable + Vue.js v2 for example chat</a></li>
<li><a href="../349914/index.html">Measuring the speed of Java code correctly (using JMH)</a></li>
<li><a href="../349916/index.html">The Dream Machine: The history of the computer revolution. Prologue</a></li>
<li><a href="../349918/index.html">Sound in ReactJS</a></li>
<li><a href="../349920/index.html">Again about empty transfers in C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>