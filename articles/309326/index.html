<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How does MySQL replication work?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How does MySQL replication work? 
 Andrey Aksenov (Sphinx), shodan 


 My report is intended for those people who know the word "replication", even kn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How does MySQL replication work?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/5a6/337/273/5a633727390bc4fab40d6ca533953da7.jpg" alt="Andrey Aksyonov"><br><br><h1>  How does MySQL replication work? </h1><br><h2>  Andrey Aksenov (Sphinx), <a href="https://habrahabr.ru/users/shodan/" class="user_link">shodan</a> </h2><br><p>  My report is intended for those people who know the word "replication", even know that it exists in MySQL, and perhaps it was set up once, they spent 15 minutes and forgot.  More about her, they do not know anything. </p><br><p>  We will go through the theory for a bit, try to explain how it all works inside, and after that you can dive into the documentation with triple strengths. </p><br><p>  What is replication, in principle?  This is a copy of the changes.  We have one copy of the database, we want, for some purpose, another copy. </p><br><p>  Replication is of different types.  Different axes of comparison: </p><br><ul><li>  the degree of synchronization of changes (sync, async, semisync); </li><li>  number of recording servers (M / S, M / M); </li><li>  format changes (statement-based (SBR), row-based (RBR), mixed); </li><li>  theoretically, the change transfer model (push, pull). </li></ul><br><a name="habracut"></a><br><p>  The report will not: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/aa9/20d/a0c/aa920da0c38e4139668796fa3d00a15d.jpg"><br><br><p>  All this is on the Internet, the syntax does not make sense. </p><br><p>  Funny fact - if you think a little, replication theoretically helps us, as a matter of principle, to read only the scale.  Here is a somewhat unobvious conclusion.  This is because if we need to pour a certain amount of changes on the same copy of the data, and this specific copy of the data is served by the same server, then this server is able to withstand a certain number of updates per second and not upload more there.  The server is able to update 1000 records per second, and 2000 is not capable.  What will change from the fact that you put a replica to this server, it does not matter in the master-slave or master-master mode?  Can you pour a second thousand updates on this cue?  The correct answer is no. </p><br><p>  You can, of course, be able to add additional updates to the replica in master mode, another thing is that when they don‚Äôt fly to the first master and try to make the second thousand updates on it, then the capacity is not enough.  It is necessary to understand and not to confuse two almost obvious points that replication, as it were, about one thing, but that the data must be split, and if it is necessary not to read, but write, you will have to do something else, and replication will not save much . </p><br><p>  Those.  replication is more about reading. </p><br><h3>  About synchronization. </h3><br><p>  Synchronization is a guarantee of availability and availability.  Availability in the sense that we have completed the commit, the transaction is committed, everything is fine, this data is visible to one or several nodes in the cluster, they can participate in the following requests.  Availability is that the data, in principle, is on more than one server, but perhaps the transaction is not lost and is not available. </p><br><p>  There is no refrain "commit ended successfully, what does this mean?".  A synchronous commit means that we have local and remote (at least on one replica) ended, i.e.  we have committed something to the machine, if we have a synchronous replication mode, then these changes are successfully committed, they are visible for subsequent requests on the local machine, on the remote machine (at least one) are also visible.  This means that if a standard emergency situation occurred, i.e.  in one server and scrap arrived and broke through everything - from the processor to the screw itself, despite this, the data is not only copied to a remote server, but also, in addition, can instantly, without any additional delay, participate in subsequent transactions. </p><br><p>  This is all common terminology, completely unrelated to MySQL.  In any distributed system, it will be arranged like this. </p><br><p>  Asynchronous commit - no additional guarantees, as lucky. </p><br><p>  A semisynchronous commit is a pleasant intermediate solution, this is when we have a local commit passed, nothing is known about the remote commit - maybe the slave caught up, but maybe it didn't catch up, but at least we received confirmation that this data was they flew away and were accepted there and probably signed up. </p><br><p>  Pro server for recording.  What are the types of replication. </p><br><p>  Master-slave classic, all changes are sent to one server, then copied to the mass of replicas. </p><br><p>  Master-master true - when changes flow into a bunch of masters at the same time and somehow from one to another, from the other to the third and between them all, which gives rise to a number of joys and a series of automatic problems.  It is clear that when you have one ‚Äúgolden copy‚Äù and several replicas from it, which should (ideally - instantly) repeat this ‚Äúgolden copy‚Äù, then everything is relatively simple in terms of how to drive data back and forth and what do on each particular copy.  An interesting ‚Äúheadache‚Äù begins with master-master, and, I emphasize, not specifically in the case of MySQL, but purely theoretical.  How to be, if on two nodes simultaneously tried to drive the same transaction, which changes the same data, and, changing them, for simplicity of example, in different ways.  It is clear that we cannot apply these two changes at the same time.  At the moment when we are starting to change something on one node, there is still nothing on the second node.  Conflict.  One of the transactions will have to be rolled back.  In addition, separate "dances" begin with the verification of watches, etc. </p><br><p>  A curious moment - even the option when you ultimately have all the changes from all the masters have to gradually spread everywhere will still not help that very write bandwidth.  It's a shame, but like this. </p><br><p>  A nice option is called ‚ÄúMaster-slave + routing requests‚Äù.  It is pleasant because it is easy to program inside, you have one main copy, you replicate it to a bunch of machines.  This is much simpler than in the master-master environment, when everyone has equal rights, etc., but from the point of view of the application, it still looks like you have a lot of recording points.  You come to any node, she knows where to cast you, and successfully routs.  Well, the reads are scaled - that‚Äôs the happiness of replication.  You can read everything from all points and always. </p><br><p>  Now closer to databases, ‚Äúmagic‚Äù statement-based, row-based, etc.  About the format changes. </p><br><p>  What can you do?  You can send the requests themselves, and you can transfer only the modified lines.  I emphasize - while we have not yet dived into the wilds of MySQL, any DBMS that has a number of queries that generate a large number of changes (i.e.,  updating a lot of data.  The question arises - what exactly will we copy?  You can query yourself back and forth between the nodes to drive, and you can drive only the changed data.  Interestingly, this way and that is very bad!  You can still try to mix. </p><br><p>  Another point about replication.  Pro distribution model.  Probably, somewhere until now, the Push-based model has not completely died out, when the node that made the changes must send them to all the other nodes.  From the point of view of programming and tracking states, this is still a trouble.  Therefore, Pull-based is driving.  Taking updates from one or another node is much easier to program than to monitor a chaotic cluster of your replicas on one node. </p><br><p>  Some common terms introduced.  Moving on to what was done in MySQL. </p><br><p>  MySQL itself is a kind of deception.  There is a logical layer called MySQL, which deals with all sorts of common and isolated from data storage cases - network, optimizer, caches, etc.  The specific physical layer that is responsible for storing the data lies on the floor below.  There are several built-in, there are plug-in set.  But even embedded MyISAM, InnoDB, etc.  live on the physical layer.  Plug-in architecture is cool, you can pick up a new engine, but instantly there is some kind of non-optimality.  In principle, transactional write-ahead logs (WAL), which the physical storage layer still writes, would be good to use for replication, and if the system knows that there is a certain physical layer, or it is fairly well connected with this physical layer , it would be possible not to write a separate log at the logical level, but to use the same WAL.  But in MySQL it is impossible conceptually, or if you change the interface in PSE so that it becomes possible conceptually, there will be a lot of work. </p><br><p>  Replication is implemented at the level of MySQL itself.  This is also good - in addition to one log in the form of deep internal data of the storage engine, there is a more or less logical log, perhaps at the statement level, which is maintained separately from this engine.  And this is ‚Äúextra‚Äù security, etc.  plus, since there are no limitations inside, you can do any creative type of engine replacement on the fly. </p><br><p>  In terms of MySQL 4.1, the following terms were implemented: master-slave, pull-based, strictly async and strictly SBR.  If you are stuck in the ancient epoch 4.x, then, probably, you are all bad.  Version 5.x is almost 10 years old - it‚Äôs time to upgrade. </p><br><p>  It's funny to track on the versions how people attacked all kinds of rakes and, when it was impossible to do anything, fastened a new rake to this rake so that life would not be so painful.  So, in version 5.1 they screwed up the RBR to compensate for the inevitable problems with SBR, and screwed up the mixed mode.  In version 5.6, they screwed some more nice pieces: semi-sync, delayed slave, GTID. </p><br><p>  One more thing.  Since MySQL is a kind of common layer, on the one hand, and a bunch of pluggable engines, on the other hand, including built-in ones, there is a divine NDB cluster from a certain point, which is told about cool.  There is a fully synchronous master replication, a very accessible in-memory database ... But there is one nuance - as soon as you start looking for people who use NDB cluster in production, there are very few people like that. </p><br><p>  What does the wizard do when you decide to enable replication?  On the master there are quite a few additional movements.  As usual, we receive requests over the network, parse them, drive transactions, commit them, etc.  In addition to this, at the logical level MySQL, the wizard begins to maintain a binary log file, not quite a text file, into which everything changes are being streamed.  Also, the wizard can send these logs over the network.  All this is very simple and it seems to work. </p><br><p>  What does a slave do?  It is better not to send changes to the slave, because you can get into the incomprehensible.  The slave has a little more work.  In addition to keeping one additional log and sending it on request, there is also a thread that goes to the remote master, perhaps not even one, and downloads the binary log from there.  The decision ‚Äúlet's go to several remote masters and download various logs from them‚Äù is ambiguous.  On the one hand it is not bad, but on the other there is an instant divergence.  It is impossible to physically copy files via SCP, one log is already obtained on the server, we locate our positions locally, we add them to the grid, add them to a separate log, another thread runs and tries to play these local logs.  The most hellish, in my opinion, is that up to version 5.6 the identification of a transaction in the log occurred by the file name and position on the master.  An interesting decision. </p><br><p>  Here is the write path that a simple insert passes without replicating: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d76/431/533/d76431533f23292067084b5799e70edb.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  The application is connected to the server, put in the table and hang up. </p><br><p>  With replication, there are several additional steps: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/5a6/f83/944/5a6f83944051d9525992ebae059510eb.jpg"><br><br><p>  The application writer also goes to the master in the same way, but in addition this data gets into binary log in one form or another, then it is downloaded over the network to the relay log, then it is gradually replayed from the relay log (if we are lucky, the slave does not lag, Replace immediately) in the table on the slave, after that everything is available in the reader. </p><br><p>  What exactly gets into the binary log depends on the SBR / RBR / mixed settings.  Where does all this grow?  Imagine yourself as a database.  We received a simple request ‚Äúupdate one specific entry‚Äù - UPDATE users SET x = 123 WHERE id = 456 </p><br><p> What to write in the binary log?  In principle, all the same, in fact.  We can write a short request, or (and he updated one record) we can write the change in some way in one format or another. </p><br><p>  Another situation.  Imagine that the same request, which is small in itself, but many changes data, arrived to us - UPDATE users SET bonus = bonus + 100 </p><br><p>  There is only one effective option - to write the request itself, because the request is exactly 32 bytes, and it can update an arbitrary number of records ‚Äî 1000, 100 000, 1 000 000, as many as you like ... It is not efficient to write changed records to the log. </p><br><p>  And what happens if we put such a simple request in the log ‚Äúlet's turn off all users who have not logged in for a long time‚Äù - UPDATE users SET disabled = 1 WHERE last_login &lt;UNIX_TIMESTAMP (NOW ()) - 100 * 86400 </p><br><p>  Suddenly terrified.  The problem is that if you perfect the request itself, then, firstly, the time is never synchronous between two nodes, besides, due to the fact that the recording path is so long, at the time of the replay this ‚ÄúNOW‚Äù will diverge.  The replica suddenly diverges from the master, and all subsequent changes, formally speaking, already unsafe, can lead to anything. </p><br><p>  Generally speaking, for such queries, regardless of the amount of changed data, ideally, the lines themselves should be copied.  In this particular case, you can not copy the lines themselves, but fix the constant and write in the log not ‚ÄúNOW‚Äù, but the specific timestamp that was used by the master at the time of replication. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/270/fa5/d09/270fa5d092428540e043bfb7e5047fad.jpg"><br><br><p>  Fun facts that you accidentally learn, diving into the jungle of replication.  Moreover, you can dive shallowly - you run up a rhinestone on them.  In random order, they are: </p><br><ul><li>  the master is multithreaded, but the slave is not.  It is clear that if the master pours the load into four cores, the slave does not have time to pour this load into one core.  Everything is pretty bad; </li><li>  The state of the slave is determined by the name of the position in the master file.  Think about it - the state of one node in a cluster is determined by the file name and position in this file on another node of the cluster, from which anything can happen for any reason! </li><li>  "Saving" RBR.  It turns out that by default full before / after row image is written there, i.e.  we changed one column in the five-kilobyte line, op!  - 10 Kb of traffic and bytes of 20-40 overheads on this line, then op!  - such fat line of the previous version goes, op!  - the version with new values ‚Äã‚Äãgoes after that.  Administrators howl in chorus!  Nevertheless, it is just awesome from the point of view of some perverted applications, for example, external readers, who are trying to hook up to the MySQL server, pull data from it and do something with it, for example, poke it into a full-text index.  How bad it is from the point of view of database administration, in which one change by three bytes generates 10 Kb of traffic per screw, and then 10 Kb of traffic across the network for each slave, it‚Äôs as good for any full-text search systems like Sphinx, which there is no local copy of the data, and there is no desire to implement MySQL from scratch.  In MySQL 5.6, they remembered and did binlog_row_image (but by default full, not minimal or noblob). </li></ul><br><p>  In short, everything is not cleverly arranged - a stick, a rope, one log, the second log.  And even in this log, ‚Äúchildhood‚Äù diseases are quite funny: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/a3a/817/7fb/a3a8177fb1f01fabdac2210ceb9db891.jpg"><br><br><p>  For a person who uses replication for two days, all this is scary and hard.  But, knowing how simple it is, in principle, it is clear how to live with it: </p><br><ul><li>  first of all, we do not believe in defaults; </li><li>  We carefully look at the settings, think what we want - SBR, RBR, etc. </li></ul><br><p>  And it‚Äôs better to set it up right away so you don‚Äôt disassemble the strange stuffing. </p><br><p>  In the situation of ‚Äúa rotten log, a position has gone, it is not known what is happening‚Äù there are certain tools - we look at the events, trying to understand which transaction has already slipped, which is not, can the whole thing be saved or restored, etc.  If GTID ‚Äúyou managed to turn it on, then life becomes easier. </p><br><p>  Another point of observing replication.  It is interesting to see how the internal curved device provokes not that competition, but the creation of additional products.  ‚ÄúMagic‚Äù Tungsten Replicator, they say, solves a problem called ‚Äúsingle-threaded slave - this is bad,‚Äù and if it were not for inherent difficulties, there would not be an additional product that allows using this mechanism to transfer data to other systems, on the one hand and at the same time solve a number of problems embedded in the existing system, on the other hand. </p><br><p>  As usual, it is impossible to advise.  Helping someone, someone will spit hard.  But, they say, there are situations in which Tungsten copes well with the inevitable single-threaded lag.  I'm sure there are all sorts of fascinating tricks, but the internal single-threaded slave is hard. </p><br><p>  What if you for some reason used replicas as a backup?  I think you need to beat your head against the wall, because the replica and the backup are two different things.  Nevertheless, if you are creative guys and use a fairly new version, delayed replication saves you, on the one hand, but on the other hand, if you don‚Äôt make full backups, you will not be saved by anything. </p><br><p>  Next, another element of creativity.  It is not difficult to imagine a situation where the master logged the entire 10 PB cloud disk or scored the entire network with these logs, and we don‚Äôt need 90% of these updates because we are interested to replicate, for example, one table sighting or one database sighting, and by default everything falls in bulk to the binary log - all changes across all databases, across all tables, across.  The decision is again striking in its creativity.  On the one hand, there are four settings - {binlog | replicate} _ {do | ignore} _db, which allow filtering on the wizard - what is written to the log and what is being ignored.  On the slave, respectively, allows you to do the same.  Those.  on the master, we can filter out what gets into the binary log - in this funnel, which then merges into the network, and on the slave, respectively, we can put the incoming filter on what comes from the network.  Or write to the disk only part of the data, and then replay on the slave, again, only part of the data.  Suddenly, even in this simple story comes the horror, because the combination - use one database, and update the table in another database through an interesting syntax - it behaves somehow ... And how exactly it will behave - is unknown, because  Different filters work at different times. </p><br><p>  There are no built-in pleasant pieces called ‚Äúre-election of the master, if he suddenly died‚Äù, you need to lift it with your hands.  The lack of tools for cluster management, which, in my opinion, is good, creates competition, creates additional products.  In fact, if in normal MySQL a very cool master replication master would work, or at least automatic lifting after failures, then why would you need any Galera, Percona / MariaDB Cluster, etc.? </p><br><p>  Some more tricks.  Interesting is the implementation of replication, which is as simple as a stick and a rope, without any checks, on the one hand, and without any tools, so that it is more pleasant to manage a replicating slave cluster, on the other.  This is bad.  But on the other hand, you can manually sculpt such interesting configurations from this, that everyone who comes will come and shudder after you. </p><br><p>  Configuration number 1.  The master on the knee in the MySQL style is done like this: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/30e/210/6c7/30e2106c725146cb132f310cf7a84a93.jpg"><br><br><p>  What scares - how many idiots in the world!  Google ‚ÄúMySQL Master replication master‚Äù - every second link is like this.  Hell and Holocaust. </p><br><p>  Focus number 2 - catch-all slave - more pleasant.  There are no unnecessary checks - what comes from whom, who gets to, and what to do with it.  Due to this, you can make funny things like a slave, on which either part of the data is precisely merged from the heap of servers, or all the data from all the servers are merged - the server with all the backups.  But, I repeat, there is replication, i.e.  there is some basic tool that copies table A instead of B and that's it. </p><br><p>  And finally, the trick number 3 - we replace everything.  We recall that replication lives on a logical level that is in no way connected with the physical level of storage.  Due to this, it can be extremely interesting to wonder.  You can change the engine "on the fly" with incomprehensible goals - this is a true story that, they say, replication from InnoDB databases in MyISAM tables just for the sake of full-text search to work at least somehow.  There is a creative trick called "changing the scheme through replication".  What is fat, I refuse to understand, but there are also such tricks.  Well, there is a clear and interesting mode of operation called ‚Äúparanoid version upgrade through replication‚Äù. </p><br><p>  During the report, we learned: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/3e9/98a/350/3e998a350cd07125cbd4af61d69fe1a1.jpg"><br><br><p>  Nevertheless, it is possible to live with this hell, if at least roughly understand how it works. </p><br><p>  The main message is that: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/4c1/c8b/d13/4c1c8bd132d8fa066697f41ffaae1587.jpg"><br><br><blockquote>  <font color="gray">In 2015, at the <a href="http://junior.highload.ru/">HighLoad ++ Junior</a> conference, Andrei Aksyonov read a new version of his report on the replication device in MySQL.</font>  <font color="gray">We also deciphered it and <a href="http://highload.guide/blog/mysql_replication_2015.html">published it</a> on our blog.</font> <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/309326/">https://habr.com/ru/post/309326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309314/index.html">Cisco DNA Architecture - IT in Digital Business</a></li>
<li><a href="../309316/index.html">Clear boy Zone.js</a></li>
<li><a href="../309318/index.html">4 types of memory leaks in javascript and how to deal with them</a></li>
<li><a href="../309320/index.html">Mail of Russia: in e-commerce-future with cautious optimism</a></li>
<li><a href="../309324/index.html">Anatomy of a web service</a></li>
<li><a href="../309328/index.html">The basics of indexing and EXPLAIN in MySQL</a></li>
<li><a href="../309330/index.html">Database scaling through sharding and partitioning</a></li>
<li><a href="../309332/index.html">Principles and techniques for processing queues</a></li>
<li><a href="../309338/index.html">Future is now: what will happen on JavaDay Kharkiv 2016, September 17</a></li>
<li><a href="../309340/index.html">.Net Core, 1C, dynamic compilation, Scripting API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>