<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The most difficult problem of computer science</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... this is, of course, the naming of entities. And I'm not just talking about the names of variables or new technologies, no. We can not even agree o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The most difficult problem of computer science</h1><div class="post__text post__text-html js-mediator-article">  ... this is, of course, the naming of entities.  And I'm not just talking about the names of variables or new technologies, no.  We can not even agree on the most basic terms. <br><br><h2>  Thousand Dialects </h2><br>  Did you know that <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf">the</a> C programming language <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf">specification</a> often mentions the term "object"?  No, this is not an object as it is described in OOP - an object in C is defined as ‚Äúa data block in the runtime environment, the contents of which can represent a certain value‚Äù.  In this understanding of an object, it makes sense to talk about, for example, a ‚Äúchar object‚Äù. <br><br>  The term ‚Äúmethod‚Äù is quite common, but you can meet programmers who will speak exclusively ‚Äúfunction-member of a class‚Äù.  The Java programming language, therefore, either has or does not have functions, depending on who you ask about it.  The terms "procedure" and "subroutine" are sometimes used as an analogue of "function", but in some programming languages ‚Äã‚Äã(for example, Pascal), the procedure is not at all the same as a function. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Even within a single programming language, we sometimes get confused. <br><a name="habracut"></a><br>  Python programmers can catch the use of the term ‚Äúproperty‚Äù (instead of the attribute), although both terms exist in the language and they are not absolutely identical.  There is a difference between an ‚Äúargument‚Äù and a ‚Äúparameter‚Äù, but who cares about it - we just say this or that word when it seems to us more convenient.  I often use the term "interface functions" (" <a href="http://stackoverflow.com/questions/2322736/what-is-the-difference-between-function-declaration-and-signature">signature</a> "), but other people do it very rarely, so sometimes I think about it - does anyone understand what I‚Äôm talking about? <br><br>  When we say "float data type", the C programmer will hear "a single-precision floating point type", and the Python programmer will be sure that the double-precision type was meant.  And this is not the worst case yet, because when the word type is mentioned, it can mean at least four different interpretations in terms of its size. <br><br>  Part of the problem is that when we talk "about computer science," we are not really talking about computer science.  We are <a href="https://twitter.com/hashtag/iamdoingprogramming%3Fsrc%3Dhash">engaged in practical programming</a> on some set (out of hundreds!) Of non-ideal programming languages, each of which has its own peculiarities and quirks.  At the same time, we have a certain (limited) number of familiar terms that we apply to different features of different languages, sometimes to the place, and sometimes not so.  A person who has begun to learn programming with Javascript will have a certain idea of ‚Äã‚Äãwhat a ‚Äúclass‚Äù is and it will be very different from the view of the person whose first language was Ruby.  People come from the background of one language to another and start <a href="https://eev.ee/blog/2011/04/24/gotcha-python-scoping-closures/">accusing</a> him, for example, that there are no normal closures, because in their language the term "closure" means something completely different. <br><br>  Sometimes with all this you can somehow put up.  And sometimes confusion can happen.  Here are my (least?) Favorite examples of such situations. <br><br><h2>  Arrays, Vectors and Lists </h2><br>  In C language, an array is a sequential data block in which you can put a certain (clearly defined) number of variables of the same type.  int [5] describes an array for storing five variables of type int, directly one after another. <br><br>  C ++ introduces the concept of a vector as an analogue of an array that can automatically change its size, adjusting to current needs.  There is also a standard list type, which in this case means a doubly linked list (in fact, the standard does not put forward requirements for a specific implementation, but functional requirements make logical the implementation of a vector based on an array and the list based on a doubly linked list).  But wait!  In C ++ 11, the term ‚Äúinitializer_list‚Äù is introduced, the title of which contains the word ‚Äúlist‚Äù (list), but in essence it is an array. <br><br>  Lisp lists are, of course, linked lists, which makes it easy to process them in terms of access to the head and tail.  Haskell also works in the same way, plus it has Data.Array for quick access to the elements by index. <br><br>  In Perl, the type of a sequence is an array, although the word ‚Äútype‚Äù itself is not very appropriate here, it is rather one of the forms of variables.  Perl also has the concept of a ‚Äúlist‚Äù, but this is only a temporary object that exists during the evaluation of a certain expression, and not a classic container data type.  This is a rather strange thing and its explanation will take more than one paragraph, so I will not even begin here. <br><br>  In Python, a list is a fundamental data type, in which there are properties similar to a vector in C ++ and (in CPython) it is implemented on the basis of a C-array.  The standard library also provides the rarely used data type array, which packs numbers into arrays of C to save space and disorients programmers who came to Python through C ‚Äî they think that ‚Äúarray‚Äù is just what you need to use by default.  Oh yeah, there is still a built-in type byte array, which is not the same as an array that stores bytes. <br><br>  Javascript has an array type, but it is built on top of a hash table with string (!) Keys.  There is also an ArrayBuffer for storing numbers in C-arrays (very similar to the type of array in Python). <br><br>  In PHP, a data type called an array is actually an ordered hash table with string (!) Keys.  Also in PHP there are lists, but this is not a data type, but only some syntactic sugar.  People who go from PHP to other languages ‚Äã‚Äãare sometimes surprised that classic hash tables, it turns out, do not retain order. <br><br>  The Lua language, sweeps aside all sorts of traditions, without using the terms of an array, a vector, or a list at all.  The only data type there is called a table. <br><br>  Well, in order not to get up two times, let's go through the names of the data types of associative containers: <br><br>  <b>C ++</b> : map (and in fact this is a binary tree. C ++ 11 adds unordered_map, which is a hash table) <br>  <b>JavaScript</b> : object (!) (This is actually not a classic associative array, but you can store values ‚Äã‚Äãaccessible by a string key. And there is also a data type Map.) <br>  <b>Lua</b> : table <br>  <b>PHP</b> : array (!) (And only string keys) <br>  <b>Perl</b> : hash (also "form", not type, plus ambiguity due to the fact that hashes also call something completely different, plus again only string keys) <br>  <b>Python</b> : dict <br>  <b>Rust</b> : map (although it exists as two separate types - BTreeMap and HashMap) <br><br><h2>  Pointers, links and aliases </h2><br>  In C, there are pointers that are addresses of some data in memory.  For C, this is natural, since everything in C is about data management in memory and the representation of all data as addresses in one large data block (well, more or less so).  A pointer is just an index in this large block of data. <br><br>  With ++, having inherited pointers from C, immediately warns you against their abuse.  As an alternative, a link is offered that seems to be exactly like pointers, but for access to values ‚Äã‚Äãin which you do not need to use the "*" operator.  This immediately creates a new (very strange) possibility, which was not in C: two local variables can point to the same data block in memory, so the string a = 5;  quite to itself can change the value of the variable b. <br><br>  There are links in Rust, and they even use the C ++ syntax, but in fact they are ‚Äúborrowed pointers‚Äù (that is, pointers, but transparent).  Also in the language there are less common "clean pointers" that use the syntax of pointers C. <br><br>  Perl has links.  Even two separate types of links.  Hard links (similar to pointers in C, with the exception that the address is not available and implies that it should not be used directly) and soft links where you use the contents of some variable as the name of another variable.  Also in Perl there are aliases that work similarly to references in C ++ - but they do not work for local variables and, in general, are not actually a data type, but simply manipulation of a symbol table. <br><br>  There are links in PHP, but despite the influence of Perl, the link syntax was taken from C ++.  C ++ defines a reference by the type of the variable to which it refers.  But in PHP there is no variable declaration, so the variable begins to count as a reference from the moment it participates in some specific set of operations involving the &amp; operator.  This magic symbol "infects" the variable "referential." <br><br>  Python, Ruby, JavaScript, Lua, Java, and a bunch of languages ‚Äã‚Äãdo not have pointers, references, or aliases.  This somewhat complicates the understanding of these languages ‚Äã‚Äãfor people who come from the world of C and C ++, because in the course of explaining certain higher-level things, one often has to say phrases like ‚Äúit indicates ...‚Äù, ‚Äúit refers to ...‚Äù, which misleads people, giving the impression that they do have some kind of pointer or reference to a certain area in memory, the contents of which can be directly accessed.  For this reason, I refer to the behavior of links in C ++ as aliasing, since it more clearly reflects the essence of what is happening and leaves the word ‚Äúreference‚Äù for a more general use. <br><br><h2>  Pass by reference and by value </h2><br>  By the way, about the links.  I have already <a href="https://eev.ee/blog/2012/05/23/python-faq-passing/">explained</a> this before for Python, but I will write here again an abbreviated version.  All this dichotomy does not make sense in most languages, since the key question here is what language C considers to be meaning, and this question has no meaning outside the family of languages ‚Äã‚Äãrelated to C. <br><br>  The fundamental problem here is that C has a syntax for describing structures, but the semantics of the structure language in the code itself does not see - only a set of bytes.  The structure seems to look like a container, a good such reliable container: the contents are enclosed in curly brackets, you need to use the "." Operator  for access to internal members.  But for C, your structure is just a block of binary data, not much different from int, well, except maybe a bit larger.  Oh, yes, and you can still look at some separate part of the data.  If you put one structure inside another, language C stupidly selects in the external structure a data block for the internal one.  When you assign one structure to another, a banal byte copying occurs, the same as when assigning, for example, double variables.  The face is illusory.  As a result, the only truly "real" container in the C language is a pointer! <br><br>  If you pass a structure to a function, C will copy it completely, just like a variable of any other type.  If you want a function to modify a structure, you need to pass a pointer to it to the function.  If you want to transfer a very large structure to a function, you again need to use a pointer to improve performance. <br><br>  With ++ I introduced the concept of reference, well, just in case if all of a sudden in C with its pointers everything was too easy and understandable.  Now, as before, you can pass the structure "by value", but if the called function accepts a link, then you are already passing your structure "by reference" and the function can modify it.  The function argument becomes the alias of the variable passed to it, so that even simple types like int can be rewritten.  This ‚Äútransfer by reference‚Äù is better called ‚Äútransfer by alias‚Äù. <br><br>  Java, Python, Ruby, Lua, JavaScript, and many other languages ‚Äã‚Äãoperate containers as separate entities.  If you have a variable in which there is a structure and you assign this variable to another variable, then in fact no copying takes place.  Just now both variables are referenced ... no, do not link, indicate ... (no, do not indicate) ... <br><br>  And here it is - the problem of terminology!  When someone asks if the X language transmits parameters by value or by reference, this person most likely thinks in terms of the C language model and presents all other languages ‚Äã‚Äãas something that must necessarily fall one way or another on this fundamental model.  If I say ‚Äúboth variables refer‚Äù, then you might think that this is a C ++ reference (aliasing).  If I say "both variables indicate", then we can decide that we are talking about C-style pointers. In many cases, the language may not have the first or second.  But in the English language there are no other words for expressing what we want to say. <br><br>  Semantically, languages ‚Äã‚Äãbehave as if the contents of variables (their values) exist by themselves, in some abstract world, and variables are just names.  The assignment associates a name with a value.  It is tempting to explain this to newbies as ‚Äúnow and points to b‚Äù or ‚Äúnow they refer to the same object as an oddit‚Äù, but these explanations add indirection, which in fact does not exist in the language.  a and b just both call the same object. <br><br>  The function call in this case is an assignment form, because the arguments inside the function now name the same values ‚Äã‚Äãthat the caller passed to the function.  You can modify them - and the calling code will see the result of these modifications, since it also names those values.  Inside the called function, you cannot reassign variables: a variable in this case is not an alias, assigning any value to it will only link its name (inside the function) with the new value, but will not affect the variables in the calling code.  All this is somewhat beyond the scope of the classic "passing by reference" and "passing by value."  There are no established terminology here at all, I heard how it is called object transfer, transfer by name, transfer by division. <br><br>  In principle, passing by reference in the C ++ style can also be implemented in other languages ‚Äã‚Äã(as I mentioned, PHP can transmit by alias using the C ++ reference syntax).  But transfer by alias exists only as an alternative to transfer by value, and transfer by value exists, because in the low-level C half a century ago, nothing else could be realized. <br><br>  Everything that you can do by passing by value, you can also do by passing by name followed by explicit copying.  More often, such things are done for the sake of being able to return several values ‚Äã‚Äãfrom a function, which can be done in a lot of other ways in high-level languages. <br><br><h2>  Free typing </h2><br>  This, of course, is a matter of interpretation, but personally I am sure that such a thing as ‚Äúfree typing‚Äù does not exist.  At least I have not heard any specific definition for this term. <br>  I remember: <br><br><ul><li>  There is a <b>strong</b> typing, which means that the variable does not change its type in order to ‚Äútune in‚Äù to those operations that the code wants to do with it.  Rust is a strongly typed language, comparing 32-bit and 64-bit integer values ‚Äã‚Äãwill cause an error. </li><li>  There is <b>weak</b> typing, which means that a variable can change its type in order to approach a calculated expression.  JavaScript is a weakly typed language, in it 5 + ‚Äú3‚Äù will implicitly convert the string to a number and the expression will give the result 8 (just kidding, the result will be, of course, ‚Äú53‚Äù).  C is also weakly typed: you can simply take and assign a value of ‚Äú3‚Äù to a variable of int type and get at least an eccentric, but completely compiled code. </li><li>  There is <b>static</b> typing, which means that the type of the variable is known at the compaction stage.  Java is a language with static typing.  Just look at any Java code - the impression is that it consists of 70% of the names of the types used. </li><li>  There is a <b>dynamic</b> typing, which means that the type of a variable is determined as the program runs.  Ruby is a dynamically typed language; types are defined at runtime. </li></ul><br>  The concepts of "strong" and "weak" typing create a harmonious picture of the world.  "Static" and "dynamic" typifications are also understandable and complementary.  Languages ‚Äã‚Äãcan have elements of both strong and weak typing, as well as static and dynamic, although a single position is still prevalent.  For example, although Go is considered to be statically typed, interface {} has signs of dynamic typing.  Conversely, Python is <a href="https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/">formally</a> statically typed and each variable is of type object, but good luck with that. <br><br>  Since the relation of "strong" \ "weak" typification concerns the values ‚Äã‚Äãof variables, and the "static" \ "dynamic" relates to their names, all four combinations exist.  Haskell is strong and static, C is weak and static, Python is strong and dynamic, Shell is weak and dynamic. <br><br>  What then is ‚Äúfree typing‚Äù?  Someone says that this is an analogue of ‚Äúweak‚Äù, but many people call Python ‚Äúfreely typable‚Äù, although Python refers to languages ‚Äã‚Äãwith strong typing.  (At least, stronger than C!). <br><br>  And, since the term ‚Äúfreely typable‚Äù I mostly meet in a derogatory sense, I can assume that people mean ‚Äúnot as typified as it happens in C ++‚Äù.  Here, it should be noted that whose cow would mumble, and C ++ would keep mum.  The type system C ++ is far from flawless.  What, for example, would be the type of a pointer to type T?  No, this is not T *, since it can be assigned a null pointer (which is not a pointer to a variable of type T) or random garbage (which is also unlikely to be a pointer to a variable of type T).  What is the point of being proud of static typing, if variables of some type in fact may not contain the value of this type? <br><br><h2>  Caching </h2><br>  With caching, the situation is the funniest of all, and in fact it‚Äôs not even a feature of any one language, but a well-known concept.  Caching stores the results of some calculations, eliminating the need to repeat them later.  Classic optimization, or rather the exchange of memory for speed.  I believe that the most important property of caching is that when cleaning the cache, destroying it, or inaccessible data in it for some other reason - everything continues to work as before, except a little slower. <br><br>  And I everywhere see programmers and code who call the cache any data retention for reuse.  This is very confusing.  A good example is one example of code that I often met in Python projects.  For the first time I paid attention to it in the <a href="http://pyramid.readthedocs.io/en/latest/">Pyramid</a> project, where this feature was called reify.  She performed a lazy initialization of an object attribute, something like this: <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Monster</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">think</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># do something smart @reify def inventory(self): return []</span></span></code> </pre> <br>  Here, monster.inventory does not actually exist until you try to read it.  At this point, reify is called (only once) and the list that it returns becomes an attribute.  Everything is completely transparent as soon as the value is created, it is a regular attribute without any subsequent overhead costs for indirect access.  You can add something to it, and you will see the same result with every access.  The attribute did not exist until you called it to life by trying to look at it. <br><br>  Such an approach may make sense for objects that describe several related, but still separate aspects of a certain entity (and for some reason all this cannot be divided into separate classes).  If the initialization of some part of such an object can take a long time and its existence is not necessary for the operation of the remaining parts of the object, it is quite reasonable to use lazy initialization to create the required component only when it is clearly necessary. <br><br>  reify for a long time was not represented in the PyPI repository as a separate component.  Probably because it can be implemented from scratch to ten lines.  When I talked about what I saw to reify in many projects, I meant ‚Äúmany projects copied or wrote a reify implementation on my knee‚Äù.  And finally, this component was added to the repository under the name ... <a href="https://pypi.python.org/pypi/cached-property">cached-property</a> .  Documentation even showed how to ‚Äúinvalidate the cache‚Äù - damage to the internal state of the object. <br><br>  The big problem I see here is that literally absolutely every use of a given decorator that I saw was not a cache in its classic sense.  The example above is somewhat simple, but even for it, ‚Äúinvalidating‚Äù the cache will lead to irreversible consequences - we completely lose the state of Monster.inventory.  Actual @reify applications often open files or connections to a database, and in these cases, ‚Äúinvalidation‚Äù will be equivalent to data destruction.  This is absolutely not a cache, the loss of which should only slow down the work, but not spoil the data in memory or on disk. <br><br>  Yes, you can create a cache with @reify.  And you can create it even more using dict and various other ways too. <br><br>  I tried to put forward a proposal to rename the cached-property to reify at the early stage of the appearance of this component in the repository (this was important, especially given the author‚Äôs desire to add it to the standard language library) - but nobody liked the name of reify and the conversation quickly turned to discussion and criticism other alternative titles.  So the naming of entities is really the most important problem in computer science. </div><p>Source: <a href="https://habr.com/ru/post/318618/">https://habr.com/ru/post/318618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318606/index.html">Serious vulnerabilities detected in Siemens power substation control systems</a></li>
<li><a href="../318608/index.html">JetBrains Night in Moscow. Video. Using ReSharper in .NET Development Teams</a></li>
<li><a href="../318610/index.html">HTML basics video course - to help informatics teacher</a></li>
<li><a href="../318612/index.html">Ten IT jobs that are hardest to find people</a></li>
<li><a href="../318614/index.html">IBM and BMW are working together to create a smart car</a></li>
<li><a href="../318620/index.html">Experience in building Infrastructure-as-Code in VMware. Part 1.1: Dynamic Inventory</a></li>
<li><a href="../318622/index.html">Titan Quest redesign for smartphones and tablets</a></li>
<li><a href="../318626/index.html">How IT professionals work. Andrei Aksenov, founder of the Sphinx project</a></li>
<li><a href="../318628/index.html">Intel Software Guard Extensions tutorial. Part 4, the enclave</a></li>
<li><a href="../318630/index.html">New Year's Eve Mobile Applications Promotion Test</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>