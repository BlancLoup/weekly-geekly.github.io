<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>White box testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The development of high quality programs implies that the program and its parts are being tested. Classic unit testing involves breaking a large progr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>White box testing</h1><div class="post__text post__text-html js-mediator-article"><p>  The development of high quality programs implies that the program and its parts are being tested.  Classic unit testing involves breaking a large program into small blocks suitable for testing.  Or, if test development takes place in parallel with code development or tests are developed prior to a program (TDD - test driven development), then the program is initially developed in small blocks that meet the requirements of the tests. </p><br><p>  One of the varieties of unit testing can be considered propery-based testing (this approach is implemented, for example, in the libraries of <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> , <a href="https://www.scalacheck.org/">ScalaCheck</a> ).  This approach is based on finding universal properties that should be valid for any input data.  For example, <em>serialization followed by deserialization should produce the same object</em> .  Or, <em>re-sorting should not change the order of the elements in the list</em> .  To test such universal properties in the above libraries, a mechanism for generating random input data is supported.  This approach works especially well for programs based on mathematical laws that serve as universal properties valid for a wide class of programs.  There is even a library of ready-made mathematical properties - <a href="https://github.com/typelevel/discipline">discipline</a> - which allows you to check the implementation of these properties in new programs (a good example of re-use of tests). </p><br><p>  Sometimes it turns out that it is necessary to test a complex program without being able to disassemble it into independently verifiable parts.  In this case, the program being tested is <del>  the black </del>  white box (white - because we have the opportunity to study the internal structure of the program). </p><br><p>  Under the cat described several approaches to testing complex programs with a single entrance with different degrees of complexity (involvement) and different degrees of coverage. </p><a name="habracut"></a><br><p>  * <em>In this article, we assume that the program under test can be represented as a pure function without an internal state.</em>  <em>(Some of the considerations given below can be applied even if the internal state is present, but there is a possibility of resetting this state to a fixed value.)</em> </p><br><h3 id="testovyy-stend-test-bench">  Test bench </h3><br><p> First of all, since only one function is being tested, the calling code of which is always the same, we do not need to create separate unit tests.  All such tests would be the same with the accuracy of the input data and checks.  It is quite enough to transfer source data ( <code>input</code> ) in a loop and check the results ( <code>expectedOutput</code> ).  In order to detect the problem set of test data in case of an error, all test data must be labeled.  Thus, one set of test data can be represented as a triple: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCase</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">label: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, input: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, expectedOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  The result of a single run can be represented as <code>TestCaseResult</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCaseResult</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">testCase: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">TestCase</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">], actualOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Try</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  (We present the result of the launch using <code>Try</code> to catch possible exceptions.) </p><br><p>  To simplify the run of all test data through the program under test, you can use an auxiliary function that will call the program for each input value: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runTestCases</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](cases: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCase</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>])(f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>]] = cases .map{ testCase =&gt; <span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>(testCase, <span class="hljs-type"><span class="hljs-type">Try</span></span>{ f(testCase.input) } ) } .filter(r =&gt; r.actualOutput != <span class="hljs-type"><span class="hljs-type">Success</span></span>(r.testCase.expectedOutput))</code> </pre> <br><p>  This helper function will return problem data and results that differ from those expected. </p><br><p>  For convenience, you can format test results </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span></span>(results: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[_, _]]): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">s"Failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${results.length}</span></span></span><span class="hljs-string">:\n"</span></span> + results .map(r =&gt; r.testCase.label + <span class="hljs-string"><span class="hljs-string">": expected "</span></span> + r.testCase.expectedOutput + <span class="hljs-string"><span class="hljs-string">", but got "</span></span> + r.actualOutput) .mkString(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><p>  and display the report only in case of errors: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) ) test(<span class="hljs-string"><span class="hljs-string">"all test cases"</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testBench = runTestCases(testCases) _ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> results = testBench(f) assert(results.isEmpty, report(results)) }</code> </pre> <br><h3 id="podgotovka-vhodnyh-dannyh">  Input preparation </h3><br><p>  In the simplest case, you can manually create test data to test the program, write it directly in the test code, and use it, as demonstrated above.  It often turns out that interesting cases of test data have much in common and can be represented as some basic instance, with minor changes. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = <span class="hljs-type"><span class="hljs-type">MyObject</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">//        val testCases = Seq( TestCase("baseline", baseline, ???), TestCase("baseline + (field1 = 123)", baseline.copy(field1 = "123"), ???) )</span></span></code> </pre> <br><p>  When working with nested immutable data structures, lenses are a great help, for example, from the <a href="http://julien-truffaut.github.io/Monocle/">Monocle</a> library: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = ??? <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testObject1 = (field1 composeLens field2).set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline) <span class="hljs-comment"><span class="hljs-comment">//    : val testObject1 = baseline.copy(field1 = baseline.field1.copy(field2 = "123"))</span></span></code> </pre> <br><p>  Lenses allow you to elegantly "modify" deeply nested parts of data structures: Each lens is a getter and setter for one property.  Lenses can be connected and get lenses that "focus" on the next level. </p><br><h3 id="ispolzovanie-dsl-dlya-predstavleniya-izmeneniy">  Using DSL to present changes </h3><br><p>  Next, we will consider the formation of test data by making changes to some initial input object.  Usually a few changes are required to get the test object we need.  It is very useful to include a list of changes in the text description of the TestCase: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline"</span></span>, baseline, ???), <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline + "</span></span> + <span class="hljs-string"><span class="hljs-string">"(field1 = 123) + "</span></span> + <span class="hljs-comment"><span class="hljs-comment">//  1-  "(field2 = 456) + " + // 2- "(field3 = 789)", // 3- baseline .copy(field1 = "123") // 1-  .copy(field2 = "456") // 2-  .copy(field3 = "789"), // 3-  ???) )</span></span></code> </pre> <br><p>  Then we will always know for which test data the test is performed. </p><br><p>  So that the text list of changes does not differ from the actual changes, it is necessary to follow the principle of the "one version of truth".  (If the same information is required / used at several points, then you should have a single primary source of unique information, and all other points of use should be distributed automatically, with the necessary conversions. If this principle is violated and the information is copied manually, then . discrepancy version information at different points in other words in the description of the test data, we see one, and test data -. another example, copying a change <code>field2 = "456"</code> and adjusting it in the <code>field3 = "789"</code> we Mauger  accidentally forget to correct the description. As a result, the description will only reflect two changes of three.) </p><br><p>  In our case, the primary source of information is the changes themselves, or rather, the source code of the program that makes the changes.  We would like to derive from them the text describing the changes.  Offhand, as a first option, you can suggest using a macro that will capture the source code of the changes, and use the source code as documentation.  This seems to be a good and relatively uncomplicated way to document actual changes, and it may well be applied in some cases.  Unfortunately, if we present changes in the form of plain text, we lose the ability to perform meaningful transformations of the list of changes.  For example, to detect and eliminate duplicate or overlapping changes, draw up a list of changes in a convenient way for the end user. </p><br><p>  To be able to operate with changes, it is necessary to have their structured model.  The model should be expressive enough to describe all the changes we are interested in.  Part of this model, for example, will be addressing the fields of objects, constants, assignment operations. </p><br><p>  The change model should allow to solve the following tasks: </p><br><ol><li>  Generating instances of the change model.  (That is, in fact, the creation of a specific list of changes.) </li><li>  Formation of the text description of changes. </li><li>  Apply changes to domain objects. </li><li>  Perform optimization transformations on the model. </li></ol><br><p>  If a universal programming language is used to make changes, it can be difficult to represent these changes in the model.  In the source code of the program can be used complex constructions that are not supported by the model.  Such a program to change the fields of an object can use secondary patterns, like lenses or the <code>copy</code> method, which are lower-level abstractions relative to the level of the change model.  As a result, an additional analysis of such patterns may be required to display instances of changes.  Thus, initially a good option using a macro is not very convenient. </p><br><p>  Another way to create instances of a change model can be a specialized language (DSL), which creates objects of change models using a set of extension-methods and auxiliary operators.  Well, in the simplest cases, instances of the change model can be created directly, via constructors. </p><br><div class="spoiler">  <b class="spoiler_title">Details of the language of change</b> <div class="spoiler_text"><p>  The language of change is a rather complex construction that includes several components, which also, in turn, are non-trivial. </p><br><ol><li>  Data structure model </li><li>  Model of change. </li><li>  Actually Embedded (?) DSL - auxiliary constructions, extension-methods, for convenient design of changes. </li><li>  The change interpreter, which allows you to actually "modify" the object (in fact, of course, create a modified copy). </li></ol><br><p>  Here is an example of a program recorded using DSL: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> target: <span class="hljs-type"><span class="hljs-type">Entity</span></span>[<span class="hljs-type"><span class="hljs-type">Target</span></span>] <span class="hljs-comment"><span class="hljs-comment">// ,     val updateField1 = target \ field1 := "123" val updateField2 = target \ subobject \ field2 := "456" // ,   DSL: val updateField1 = SetProperty(PropertyAccess(target, Property(field1, typeTag[String])), LiftedString("123")) val updateField2 = SetProperty(PropertyAccess(PropertyAccess(target, Property(subobject, typeTag[SubObject])), Property(field2, typeTag[String])), LiftedString("456"))</span></span></code> </pre> <br><p>  That is, using the extension-methods <code>\</code> and <code>:=</code> , <code>PropertyAccess</code> , <code>SetProperty</code> objects are formed from previously created <code>target</code> , <code>field1</code> , <code>subobject</code> , <code>field2</code> .  Also, due to (dangerous) implicit conversions, the string "123" is packaged in a <code>LiftedString</code> (you can do without implicit conversions and call the corresponding method explicitly: <code>lift("123")</code> ). </p><br><p>  A typed ontology can be used as a data model (see <a href="https://habr.com/post/229035/">https://habr.com/post/229035/</a> and <a href="https://habr.com/post/222553/">https://habr.com/post/222553/</a> ).  (In brief: objects-names are declared that represent properties of a particular domain type: <code>val field1: Property[Target, String]</code> .) In this case, the actual data can be stored, for example, in the form of JSON.  The convenience of a typed ontology in our case lies in the fact that the change model usually operates with separate properties of objects, and the ontology just gives a suitable tool for addressing properties. </p><br><p>  To present the changes, a set of classes of the same plan as the above <code>SetProperty</code> class is <code>SetProperty</code> : </p><br><ul><li>  <code>Modify</code> - the use of the function, </li><li>  <code>Changes</code> - applying multiple changes sequentially, </li><li>  <code>ForEach</code> - applying changes to each element of the collection, </li><li>  etc. </li></ul><br><p>  The change language interpreter is a regular recursive expression evaluator based on PatternMatching.  Something like: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span></span>(expression: <span class="hljs-type"><span class="hljs-type">DslExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Any</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">LiftedString</span></span>(str) =&gt; str <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PropertyAccess</span></span>(obj, prop) =&gt; <span class="hljs-type"><span class="hljs-type">Getter</span></span>(prop)(gamma).get(obj) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] (expression: <span class="hljs-type"><span class="hljs-type">DslChangeExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>], target: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">SetProperty</span></span>(path, valueExpr) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = eval(valueExpr, gamma) <span class="hljs-type"><span class="hljs-type">Setter</span></span>(path)(gamma).set(value)(target) }</code> </pre> <br><p>  To directly manipulate the properties of objects, it is necessary for each property used in the change model to set getter and setter.  This can be achieved by filling in the mapping ( <code>Map</code> ) between the ontological properties and the corresponding lenses. </p></div></div><br><p>  This approach generally works, and really allows you to describe the changes once, but gradually there is a need to introduce more and more complex changes and the model of changes is growing somewhat.  For example, if you need to change a property using the value of another property of the same object (for example, <code>field1 = field2 + 1</code> ), you need to support variables at the DSL level.  And if the property change is nontrivial, then at the DSL level, support for arithmetic expressions and functions will be required. </p><br><h3 id="testirovanie-vetvey">  Branch testing </h3><br><p>  The code under test can be linear, and then by and large we only need one set of test data to see if it works.  In the case of a branch ( <code>if-then-else</code> ), it is necessary to run a white box at least twice with different input data so that both branches are executed.  The number of input data sets sufficient to cover all the branches appears to be numerically equal to the cyclomatic complexity of the code with branches. </p><br><p>  How to generate all the input data sets?  Since we are dealing with a white box, we can isolate the branch conditions and double-modify the input object so that in one case one branch is fulfilled, in the other case the other.  Consider an example: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  Having such a condition, we can form two test cases: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase1 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline), <span class="hljs-comment"><span class="hljs-comment">/* result of A */</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase2 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"B"</span></span>, field1.set(<span class="hljs-comment"><span class="hljs-comment">/*  "123", , , */</span></span><span class="hljs-string"><span class="hljs-string">"123"</span></span> + <span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;)(baseline), <span class="hljs-comment"><span class="hljs-comment">/*result of B*/</span></span>)</code> </pre> <br><p>  <em>(If one of the test scripts cannot be created, then we can assume that a dead code has been detected, and the condition along with the corresponding branch can be safely removed.)</em> </p><br><p>  If independent properties of an object are checked in several branches, then it is quite easy to form an exhaustive set of modified test objects that completely covers all possible combinations. </p><br><div class="spoiler">  <b class="spoiler_title">DSL to form all combinations of changes</b> <div class="spoiler_text"><p>  Let us consider in more detail the mechanism that allows to form all possible lists of changes, providing full coverage of all branches.  In order to use the list of changes when testing, we need to combine all the changes into one object, which we give to the input of the code being tested, that is, support for the composition is required.  To do this, you can either use the above DSL to simulate changes, and then a simple list of changes is enough, or submit one change as a function of the modification <code>T =&gt; T</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> change1: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(_) <span class="hljs-comment"><span class="hljs-comment">// val change1: T =&gt; T = _.copy(field1 = "123") val change2: T =&gt; T = field2.set("456")</span></span></code> </pre> <br><p>  then the chain of changes will simply be a composition of functions: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> changes = change1 compose change2</code> </pre> <br><p>  or, for a list of changes: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rawChangesList: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>] = <span class="hljs-type"><span class="hljs-type">Seq</span></span>(change1, change2) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> allChanges: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = rawChangesList.foldLeft(identity)(_ compose _)</code> </pre> <br><p>  To compactly record all changes that correspond to all possible branches, you can use DSL of the next level of abstraction, which simulates the structure of the white box under test: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>)] = <span class="hljs-type"><span class="hljs-type">IF</span></span>(<span class="hljs-string"><span class="hljs-string">"field1 == '123'"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  ,    THEN( field1.set("123"))( //  target \ field1 := "123" IF("field2 == '456') THEN(field2.set("456"))(TERMINATE) ELSE(field2.set("456" + "1"))(TERMINATE) ) ELSE( field1.set("123" + "1") )(TERMINATE)</span></span></code> </pre> <br><p>  Here, the <code>tests</code> collection contains aggregated changes corresponding to all possible combinations of branches.  The <code>String</code> parameter will contain all the names of the conditions and all the descriptions of the changes from which the aggregated change function is formed.  And the second element of the <code>T =&gt; T</code> type pair is an aggregate function of changes, resulting from the composition of individual changes. </p><br><p>  To get the changed objects, you need to apply all the aggregated functions of the changes to the baseline object: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests2: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>)] = tests.map(_.map_2(_(baseline)))</code> </pre> <br><p>  As a result, we get a collection of pairs, and the string will describe the changes applied, and the second element of the pair will be the object in which all these changes are combined. </p><br><p>  Based on the structure of the model of the tested code in the form of a tree, the lists of changes will be paths from the root to the sheets of this tree.  Thus, a significant part of the changes will be duplicated.  You can get rid of this duplication by using the DSL variant, in which the changes are directly applied to the baseline object as you move along the branches.  In this case, slightly less unnecessary calculations will be performed. </p></div></div><br><h3 id="avtomaticheskoe-formirovanie-testovyh-dannyh">  Automatic generation of test data </h3><br><p>  Since we are dealing with a white box, we can see all the branches.  This makes it possible to build a model of logic contained in a white box and use the model to generate test data.  If the code under test is written in Scala, you can, for example, use <a href="https://scalameta.org/">scalameta</a> to read the code, and then convert it into a logic model.  Again, as in the previously discussed issue of modeling the logic of change, it is difficult for us to simulate all the capabilities of a universal language.  Further, we will assume that the code under test is implemented using a limited subset of the language, either in another language or DSL, which is initially restricted.  This allows us to focus on those aspects of the language that are of interest to us. </p><br><p>  Consider a sample code containing a single branch: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  The condition divides the set of <code>field1</code> values ‚Äã‚Äãinto two equivalence classes: <code>== "123"</code> and <code>!= "123"</code> .  Thus, the entire set of input data is also divided into two equivalence classes with respect to this condition - <code>ClassCondition1IsTrue</code> and <code>ClassCondition1IsFalse</code> .  From the point of view of completeness of coverage, it is enough for us to take at least one example from these two classes to cover both branches <code>A</code> and <code>B</code>  For the first class, we can build an example, in a certain sense, uniquely: take a random object, but change the field <code>field1</code> to <code>"123"</code> .  In this case, the object is sure to be in the equivalence class <code>ClassCondition1IsTrue</code> and the calculations will go along branch <code>A</code>  For the second class there are more examples.  One way to generate some kind of second class example is to generate arbitrary input objects and discard those with <code>field1 == "123"</code> .  Another way is to take a random object, but change the field <code>field1</code> to <code>"123" + "*"</code> (for modification, you can use any change in the control line, ensuring that the new line is not equal to the control line). </p><br><p>  The <a href=""><code>  Arbitrary</code> and <code>Gen</code> <code>  Arbitrary</code> from the ScalaCheck library</a> are quite suitable as random data <a href=""><code>  Arbitrary</code></a> . </p><br><p>  Essentially, we are <strong>reversing the</strong> boolean function used in the <code>if</code> .  That is, we find all the values ‚Äã‚Äãof the input object for which this boolean function is <code>true</code> - <code>ClassCondition1IsTrue</code> , and all the values ‚Äã‚Äãof the input object for which it is <code>false</code> - <code>ClassCondition1IsFalse</code> . </p><br><p>  Similarly, you can generate data that is suitable for constraints generated by simple conditional operators with constants (more / less constants, part of a set, starts with a constant).  Such conditions are not difficult to reverse.  Even if simple functions are called in the code being tested, we can replace their call with their definition (inline) and still implement the inversion of conditional expressions. </p><br><h4 id="trudno-obratimye-funkcii">  Hard reversible functions </h4><br><p>  The situation is different when the condition uses a function that is difficult to reverse.  For example, if a hash function is used, then it will not be possible to automatically generate an example giving the desired hash code value. </p><br><p>  In this case, you can add an additional parameter to the input object, which represents the result of the function calculation, replace the function call with a call to this parameter, and update this parameter, regardless of the violation of the functional connection: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sha(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class">"</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a9403</span></span></span><span class="hljs-class">...") ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">object.sha_field1 == "a9403..."</span></span></span><span class="hljs-class">) ...</span></span></code> </pre> <br><p>  An additional parameter allows to ensure the execution of code inside a branch, but, obviously, it can lead to actually incorrect results.  That is, the program being tested will produce results that can never be observed in reality.  Nevertheless, verification of a part of the code that is otherwise unavailable to us is still useful and can be considered as a type of unit testing.  After all, during unit testing, the subfunction is called with such arguments that may never be used in the program. </p><br><p>  With such manipulations, we replace (replace) the test object.  However, in a sense, the newly built program includes the logic of the old program.  Indeed, if as the values ‚Äã‚Äãof the new artificial parameters we take the results of the calculation of the functions that we replaced with the parameters, then the program will produce the same results.  Apparently, testing a modified program may still be of interest.  It is only necessary to remember under what conditions the changed program will behave in the same way as the original one. </p><br><h4 id="zavisimye-usloviya">  Dependent conditions </h4><br><p>         ,      .        ,  ,   ,      .        ,     . (,  , <code>x &gt; 0</code> ,   ‚Äî <code>x &lt;= 1</code> .         ,           ‚Äî <code>(-‚àû, 0]</code> , <code>(0, 1]</code> , <code>(1, +‚àû)</code> , ‚Äî      .) </p><br><p>       ,     ,   ,        <code>true</code>  <code>false</code>     .   ,    ,  " "         . </p><br><h4 id="svyazannye-parametry">   </h4><br><p>  ,        ,   : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; x)</code> </pre> <br><p> (     <code>&gt; 0</code> ,       ‚Äî <code>y &gt; x</code> .) <br>    "", ,   ,      ,    ,     .             ,             "  "     . <br>  ,   "",  ( <code>y == x + 1</code> ),    ,        . <br>   "" ( <code>y &gt; x + 1 &amp;&amp; y &lt; x + 2</code> ),     ,        . </p><br><h4 id="simvolnoe-vypolnenie">   </h4><br><p>  ,    ,    -  ,   "c " ( <a href="https://en.wikipedia.org/wiki/Symbolic_execution">Symbolic Execution</a> , <a href="http://erseal.blogspot.com/2012/02/blog-post_16.html">  </a> ),     .        ( <code>field1 = field1_initial_value</code> ).       ,    .       : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = field1 + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">//    a = field_initial_value + 10 val b = a * 3 //    b = 3 * field_initial_value + 30</span></span></code> </pre> <br><p>         ‚Äî <code>true</code>  <code>false</code> .       .           .  For example, </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">B</span></span> <span class="hljs-comment"><span class="hljs-comment">//   A ,  field_initial_value + 10 &gt; 0 //   B ,  field_initial_value + 10 &lt;= 0</span></span></code> </pre> <br><p>           ,  ,   ,     ,    .        ,       (, ,   ). </p><br><h4 id="testirovanie-ciklov-i-rekursivnyh-funkciy">      </h4><br><p>        .    ,     ,       .        ,       .         ,         . </p><br><p> ,      .       . , ,        .  ,       ,      ,        .        ,   ,   ,  ,   ,      ? </p><br><p>     Y- ( <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25B1%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_%25D0%25BD%25D0%25B5%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25B2%25D0%25B8%25D0%25B6%25D0%25BD%25D0%25BE%25D0%25B9_%25D1%2582%25D0%25BE%25D1%2587%25D0%25BA%25D0%25B8">"  "</a> , <a href="https://stackoverflow.com/questions/93526/what-is-a-y-combinator">stackoverflow:What is a Y-combinator? (2- )</a> , <a href="https://habr.com/post/118927/">habr:  Y-  7  </a> ).      ,       . (   ,      ,  .)    .            ,      .        ,    ""    . Y-   "  "     (     ). </p><br><p>        ( <a href="https://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B2%25D0%25BE%25D1%2581%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D1%2580%25D0%25B5%25D0%25BA%25D1%2583%25D1%2580%25D1%2581%25D0%25B8%25D1%258F"> </a> ).   ,       .         ,     .       ,      . ,   ,       ,       <code>TestCase</code> '.  ,       ,     ( <code>throw</code>   <code>Nothing</code>  <code>bottom</code> ,    ).            . </p><br><p>        ,   .        .    ,  ,        .  ,       .        ,    ,     .          , ,    ,    ,      .      ,        .      ,    . </p><br><h3 id="smysl-testirovaniya-belogo-yaschika">     </h3><br><p>      ,  ,     ,      ,    100% .       ,     ,   .  Hm .   , ,   ,   ?         ,    ,     -  . </p><br><p>           : </p><br><ol><li>                . </li><li>       (      ). </li><li>       ,          . </li><li>      ,    . </li></ol><br><p>       ,   ,       . -,       ,     ,   ,       . -,    ,   ,     ( ,  ),         ,  ,   ""  .   /    ,         . </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>        "   "  "   ".  ,      ,     ,      ,     .         ,           . </p><br><p>      ,      ,  ,  ,  . -,          ,        ( ),      . -, -,      .      DSL,  ,    . -,          ,   . -,       ,        (   ,     ,   ).            . </p><br><p>  ,          ,      . ,      ,         -   . </p><br><h3 id="blagodarnosti">  Thanks </h3><br><p>    <a href="https://github.com/mneychev/">@mneychev</a>        . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/422283/">https://habr.com/ru/post/422283/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../422269/index.html">The book "The internal structure of Windows. 7th ed "</a></li>
<li><a href="../422273/index.html">There are no stupid roads in a smart city. What is RWIS and how it will reduce the cost of road works</a></li>
<li><a href="../422275/index.html">A Google employee was able to manage the door-opening system at the company's office due to software vulnerability</a></li>
<li><a href="../422277/index.html">Architecture and Programming RCA Studio II</a></li>
<li><a href="../422281/index.html">A7 Data Server: online data management</a></li>
<li><a href="../422285/index.html">Why online shopping is enough loyalty 1% of buyers</a></li>
<li><a href="../422291/index.html">Little black square (visualization of all the money and markets in the world)</a></li>
<li><a href="../422293/index.html">Retrieving an alarm list from OSS via the AlarmIRP interface</a></li>
<li><a href="../422297/index.html">The first experience or how to try to become a legend of code and magic</a></li>
<li><a href="../422299/index.html">TsNIIMash: SpaceX allegedly implements Soviet designs. Why does Ilona Mask have so many enemies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>