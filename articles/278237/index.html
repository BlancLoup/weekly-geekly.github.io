<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pub-Sub implementation examples: Azure Topics, EventHub, ZeroMQ, microServiceBus, etc</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The basic idea behind the Pub-Sub is quite simple: it is a public message. If you‚Äôre a person, you‚Äôll be, you‚Äôll be, you‚Äôll be. In a free translation,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pub-Sub implementation examples: Azure Topics, EventHub, ZeroMQ, microServiceBus, etc</h1><div class="post__text post__text-html js-mediator-article">  The basic idea behind the <a href="https://en.wikipedia.org/wiki/Publish%25E2%2580%2593subscribe_pattern">Pub-Sub is</a> quite simple: it is a public message. If you‚Äôre a person, you‚Äôll be, you‚Äôll be, you‚Äôll be.  In a <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B7%25D0%25B4%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C-%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25BF%25D0%25B8%25D1%2581%25D1%2587%25D0%25B8%25D0%25BA_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">free translation,</a> it may sound like this: " <b>Publisher-subscriber</b> ( <i>publisher-subscriber</i> or <i>pub / sub</i> <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BD%25D0%25B3%25D0%25BB%25D0%25B8%25D0%25B9%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA">. English</a> ) is a <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD%25D1%258B_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">behavioral</a> <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">design pattern</a> of messaging, in which message senders, called publishers, are not directly tied to the program code sending messages to subscribers ( <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BD%25D0%25B3%25D0%25BB%25D0%25B8%25D0%25B9%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA">eng.</a> <i>subscribers</i> ). Instead, messages are divided into classes and do not contain information about their subscribers, if any. Similarly, subscribers deal with one or several classes of messages abstracting from specific publishers  . " <br><a name="habracut"></a><br><h2>  Pub sub model </h2><br>  Let's fantasize a little bit and try to develop a Pub-sub system from scratch by ourselves.  The result will be the most obvious model, which will further help us understand the features and possible problems of specific implementations. <br>  The main business process in our system may look like this: <br><ol><li>  Subscribers <b>subscribe</b> to the <i>message</i> . <br></li><li>  Publisher <b>creates a message</b> . <br></li><li>  The <b>publisher publishes a message</b> in our system. <br></li><li>  <i>The message</i> is <b>stored</b> for some time in the <i>system</i> . <br></li><li>  The system <b>sends a message to</b> all subscribers. <br></li><li>  Subscribers <b>accept the message</b> . <br></li><li>  Subscribers <b>process the message</b> . <br></li></ol><br><br>  I highlighted the participants of the above described business process with the underlining, this is: <br><ul><li>  Publisher.  There may be several. <br></li><li>  Subscriber.  They are usually several, but may not be at all. <br></li><li>  System.  This is our pub-sub system. <br></li></ul><br><br>  All participants operate with <i>messages</i> .  Messages are transmitted data.  Usually this is just an array of bytes into which any data is serialized. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We have listed the following <b>operations</b> on messages (in bold): <br><ul><li>  Subscribe <br></li><li>  Create <br></li><li>  Post <br></li><li>  Keep <br></li><li>  To send <br></li><li>  To accept <br></li><li>  Process <br></li></ul><br><h3>  Queues and asynchronous </h3><br>  Nowhere in our model, we are not faced with queues.  They are not mentioned in the definition of pub-sub.  Also, asynchrony was not mentioned anywhere. <br>  But without the queue / queue pub-sub implementation is hardly possible.  If we try to send messages immediately after they are published, there are a lot of problems.  For example, how fast will sending messages to thousands of subscribers?  What happens if the subscriber fails to process the previous message?  What if new messages are posted at a time when previous messages have not yet been sent? <br>  I have not seen pub-sub implementations without queues, although theoretically this is possible. <br>  So, turn.  <b>A queue</b> is a temporary repository of messages, based on the principle ‚ÄúThe first has come - the first has left‚Äù.  Again, the pub-sub in its definition does not require maintaining the order of messages, but this is usually implied. <br>  Where will we place queues / queues?  This question will pass a golden thread through our further discussion. <br><h2>  Implementation issues </h2><br>  Now, perhaps, we will begin to formulate questions on our business process: <br><br><ul><li>  <b>Where and how are publisher and subscriber addresses stored?</b> <br>  In principle, addresses can be stored by any participant in the process.  But usually the system acts as a broker and stores all the addresses at home. <br></li><li>  <b>Subscription, what is it like?</b> <br>  Surely the subscription will include <b>the subscriber‚Äôs address</b> .  In addition, a " <b>message class</b> " will be indicated, a kind of filter that determines whether the message matches this subscription or not.  The address of the publisher is not needed here. <br></li><li>  <b>Can we add or remove a subscription at any time or should we stop the system for this?</b> <br>  If we add / remove a subscription, how will this affect the messages that are already published and are waiting to be sent? <br></li><li>  <b>Is the message format important?</b> <br>  Most likely the message will be serialized and placed in the package.  Additional parameters may be passed along with the packet, which are placed in the headers of the packet. <br></li><li>  <b>How are messages filtered by subscriptions?</b> <br>  Usually the message is immediately filtered by subscriptions at the publishing stage.  Sometimes the message is filtered only at the stage of sending the message to the subscriber.  Sometimes the message is already filtered by the subscriber. <br></li><li>  <b>What are subscription filters?</b> <br>  Subscription filters can be hierarchies like namespaces, or keysets, or RegEx expressions. <br></li><li>  <b>What happens if the system or the subscriber cannot accept messages?</b> <br>  The system or the subscriber may refuse to accept, may delete the message without any warning, or it may just hang or fail. <br></li><li>  <b>Does the message retry if it fails?</b> <br>  Retry is a standard solution if the receiving party is temporarily unavailable.  The key word here is "temporary."  If the receiving party or the transmission channel has ceased to work on an ongoing basis, then repeating the sending will not help anything, but will only overload the system / communication channel. <br></li><li>  <b>Can I customize the re-send algorithm?</b> <br>  With unreliable communication channels this question can be one of the main ones.  Can we change the number of retries, the interval between attempts?  According to what algorithm is the interval between attempts configured? <br></li><li>  <b>How long are messages stored?</b> <br>  If the subscriber does not take the message for a long time, what should he do with it?  Should it be stored indefinitely or deleted after a certain interval? <br></li><li>  <b>Who initiates the message sending?</b> <br>  A subscriber may occasionally poll the system for new messages (poll mode) or the system itself sends a new message to the subscriber (push mode).  In the first case, the subscriber must know the address of the system, in the second case the system must know the address of the subscriber.  In the second case, the system more economically consumes both its resources and data channel resources. <br></li><li>  <b>What happens if the subscriber is overloaded with messages?</b> <br>  Should he close the entrance to receive new messages and send warnings to the sending side or silently ignore messages?  Or maybe the subscriber can increase (scale) their resources? <br></li></ul><br><br>  If you are going to use the pub-sub in your project and choose one of the available pub-sub systems for this, go through these questions.  If any of them are critical to you, try to find answers. <br><h2>  Implementation details </h2><br>  I want to consider the implementation of Pub-Sub on the example of the most popular programs of this class.  If the reader decides that something needs to be changed in this list, I will discuss it once.  Why am I doing this, instead of continuing the theoretical discussion of the template?  I have a feeling that examples of implementation are no less important for understanding than bare theory. <br>  So, what is now in the list: <br><ul><li>  <a href="https://azure.microsoft.com/en-us/documentation/articles/service-bus-queues-topics-subscriptions/">Microsoft Azure ServiceBus Topics</a> <br></li><li>  <a href="https://azure.microsoft.com/en-us/services/event-hubs/">Microsoft Azure EventHub</a> <br></li><li>  <a href="https://msdn.microsoft.com/en-us/library/aa560414(BTS.70).aspx">Microsoft BizTalk Server</a> <br></li><li>  <a href="https://www.rabbitmq.com/tutorials/tutorial-three-python.html">RabbitMQ</a> <br></li><li>  <a href="http://zeromq.org/">ZeroMQ</a> <br></li><li>  <a href="https://microservicebus.com/">microServiceBus</a> <br></li><li>  <a href="http://redis.io/topics/pubsub">Redis</a> <br></li></ul><br><h3>  Azure ServiceBus Topics </h3><br>  The entire system is located in Microsoft Azure.  The implementation can be said to be classical, based on the <a href="https://en.wikipedia.org/wiki/Message_broker">message broker</a> model. <br>  Pub-sub system is a centralized paid service, a broker through which all messages pass.  All publishers and subscribers are registered here, all their credentials are also stored here.  The subscriber registers the subscription here.  All messages come here and go to the queue implemented on the basis of SQL Server.  For each subscription, a virtual queue is created, a kind of cursor in which the pointers to the real messages stored in the main queue are stored.  The messages selected by the filter of the subscription fall into the virtual queue.  The subscriber asks for the next message itself (poll), or the system notifies the subscriber of a new message (push).  The subscriber receives the message, after which the message pointer is deleted from the virtual queue.  When a message is deleted from all virtual queues, it is removed from the main queue, from the system. <br><h3>  Microsoft Azure EventHub </h3><br>  EventHub is very different from the classic implementation.  The main difference is that EventHub does not register or store subscriptions, it does not create or store virtual queues.  Received messages are simply stored in the system as a linear list.  They are stored for a certain time, after which they are deleted by the system.  Subscribers have access to all messages.  The subscriber himself filters the messages and keeps the cursor on the list.  On the one hand, this imposes an additional function on the subscriber.  On the other hand, EventHub is free of subscription support, which results in excellent performance.  It also allows for a different approach to reliability issues, since the subscriber can go back through the list at any time and re-read messages.  Achieved almost complete independence of subscribers from publishers. <br>  The subscription operation in the event hub is a null operation.  Any customer can start reading messages at any time. <br><h3>  Microsoft BizTalk Server </h3><br>  BizTalk has been around for the second decade, so you should not expect innovative approaches from it.  Essentially, its Pub-sub mechanism, called MessageBox, is a precursor to Azure Topics.  The difference is that it is accessed via adapters.  We cannot simply call an API function to publish or receive a message, we need to use adapters.  Adapters play the role of both publishers and recipients of messages. <br><h3>  RabbitMQ </h3><br>  <a href="https://www.rabbitmq.com/tutorials/tutorial-three-dotnet.html">RabbitMQ is</a> based on the ideas of the <a href="http://www.amqp.org/sites/amqp.org/files/amqp.pdf">AMQP</a> protocol, but not on its latest version (1.0), but on previous versions: 0-8 and 0-9-1.  In these versions, so-called exchanges are supported, which AMQP developers abandoned in version 1.0.  The exchange model elegantly implements the pub-sub for the broker, which is RabbitMQ. <br><h3>  ZeroMQ </h3><br>  ZeroMQ is the heir to the AMQP ideas.  One of the creators of AMQP did ZeroMQ, when the process of discussing AMQP version 1 came to a standstill.  ZeroMQ is one of the interesting ideas on the implementation of ultra-high-speed messaging system, including using pub-sub. <br>  ZeroMQ has no centralized service.  The entire Pub-sub system is implemented as part of the publisher and subscriber code.  ZeroMQ is just a library that supports queues.  In the simplest model, subscriber and publisher programs create local queues.  The subscriber is explicitly connected to the address of the publisher, after which messages from the publisher's queue begin to flow into the subscriber's queue.  Queues are located in the address spaces of the programs of the publisher and subscriber, without an intermediate broker.  The system is not represented by a separate service, but rather, as it were, spread between the publisher and the subscriber. <br>  On the one hand, if the publisher or subscriber decides to complete the work, messages from his turn will simply disappear.  On the other hand, such an implementation provides the maximum message transfer rate. <br>  Queues in ZeroMQ are stored in memory, which provides maximum performance, but reduces reliability. <br>  ZeroMQ also implements more complex configurations.  For example, you can create a pub-sub c broker.  Moreover, ZeroMQ allows you to create a variety of architectures that have no analogues in classical Pub-sub systems.  For example, you can create various options for distributed brokers.  I recommend reading one of the most successful <a href="http://zguide.zeromq.org/">pub-sub descriptions on the ZeroMQ website</a> , starting with the <a href="http://zguide.zeromq.org/page:all">pub-sub basics</a> and ending with <a href="http://zguide.zeromq.org/page:all">more complex models</a> .  It takes a lot of time, but, for example, it opened my eyes to many important aspects of the pub-sub. <br><h3>  microServiceBus </h3><br>  One of the new implementations of the pub-sub.  I included it in our list because of several interesting decisions.  MicroServiceBus is based on Azure ServiceBus Topics. <br>  Interestingly, the publisher and subscriber code is stored here on Azure.  Moreover, this code can be loaded automatically.  The code is implemented on Node.js, which means a good platform independence.  Node.js runs on virtually any operating system and device.  Any device where Node.js can work can be either a publisher or a subscriber, or both. <br>  Following the example of BizTalk Server, microServiceBus implements adapters for many systems and protocols.  But unlike BizTalk, adapters are just a useful addition to the API. <br>  microServiceBus is similar to ZeroMQ in that it is focused on the developer. <br>  Just like ZeroMQ, it is multiplatform, although the multiplatform ZeroMQ is based on porting the library into many languages ‚Äã‚Äãand on the fact that the core library is made in C. The multiplatform microServiceBus is based on the fact that Node.js has been ported to many operating systems. <br>  microServiceBus is focused both on system integration and device integration (IoT). <br><h3>  Redis </h3><br>  Redis is actually not a pub-sub system, but a <a href="https://en.wikipedia.org/wiki/Redis">key-value data storage</a> .  But it surprisingly well implements the classic <a href="http://redis.io/topics/pubsub">pub-sub</a> and shows remarkable performance. <br>  You can install Redis locally or as a distributed service.  You can add the ability to save messages to disk. <br><h2>  System selection </h2><br>  If we try to look at the pub-sub systems from a more practical side, we will inevitably face the question of choosing a system for our projects and work.  I am in no way trying to answer this question, only schematically outline the outline for finding an answer.  Firstly, pub-sub systems are significantly larger than those collected in this article.  Secondly, I do not in any way claim to have the correct placement of accents. <br>  I will focus on systems that stand out with something special from the general list. <br>  <a href="https://drive.google.com/file/d/0B9hlpXJWxB0cV1YzSUhTWVRiOG8/view%3Fusp%3Dsharing">The comparison table is here</a> . <br><h3>  Development environment </h3><br>  BizTalk Server can only be used with Visual Studio.  Numerous editors are used to create various parts of the system. <br>  Development for other systems basically comes down to the usual work with code and system API. <br><h3>  Development languages </h3><br>  This refers to the development of programs for publishers and subscribers, I will call it client code.  The system kernel is usually provided as a ready-made service, and we need to add the programs of publishers and subscribers to get a working system. <br>  Client code for Redis, ZeroMQ and RabbitMQ can be developed in a large number of languages.  You can use all the languages ‚Äã‚Äãused for industrial systems: C #, Java, Python, PHP, JavaScript / Node.js, Scala, Ruby. <br>  In ZeroMQ, most of the languages ‚Äã‚Äãare implemented as shells for the original library written in C. There are also original libraries for C #, Java, Erlang, and JavaScript.  But they are a little behind in the functionality of the original library in C. <br>  Azure ServiceBus Topics and Azure EventHub have C # and REST API. <br>  The microServiceBus client code is written only on Node.js, but this is a strength rather than a flaw. <br><h3>  System core implementation </h3><br>  Azure ServiceBus Topics and Azure EventHub systems are implemented as SaaS services hosted in the Microsoft Azure cloud.  microServiceBus runs on top of Azure ServiceBus Topics. <br>  ZeroMQ does not have a ready-made broker part, but it can be done quite simply.  And you can make a broker of any complexity with any functionality.  Good programmers often choose ZeroMQ because of this. <br>  The RabbitMQ and Redis services are supplied in binary and original form and can be installed on any server platforms: Windows, Linux, Mac, Unix.  ZeroMQ can also be installed on any platform. <br>  BizTalk Server is implemented as a massive SQL code and .NET code that works in Windows services and it works only under Windows.  You will need to have not only a license for BizTalk, but also a license for Windows and SQL Server. <br><h3>  Reliability and Maturity </h3><br>  BizTalk Server stands out in this category.  He is known for the fact that systems based on it operate for years without any service.  The code of its kernel practically does not change, for many years the errors were corrected. <br>  ZeroMQ and Redis are fairly new systems and are constantly being upgraded.  It imposes its own specifics in terms of reliability.  There are massive systems implemented based on them, but to create such systems, programmers of a good level are surely needed. <br>  Azure Topics and EventHub are new systems, but Microsoft is behind them, so there are no complaints about reliability. <br>  There is no information on the microServiceBus yet, as the system has just appeared. <br>  I note that systems that store message queues on disks are more reliable than systems that only hold messages in memory. <br><h3>  Performance </h3><br>  ZeroMQ stands out here.  In some cases, it sends messages even faster than TCP, thanks to batching. <br>  ZeroMQ is followed by Redis, then EventHub. <br><h3>  Scalability </h3><br>  ZeroMQ also scales best because of its architecture and low resource requirements.  But you will have to pay close attention to the design of the system.  Although the ZeroMQ documentation provides many examples of scalable systems, you are unlikely to find a ready-made design that can be implemented without significant refinement. <br><h3>  Price </h3><br>  BizTalk Server is the most expensive system on our list.  But you should understand that pub-sub is only a small part of its functionality and choose BizTalk by completely different criteria. <br>  Some of the systems listed are Open Source Systems.  In extreme cases, you will spend on paid support. <br><h3>  Simplicity </h3><br>  You only need a few minutes to start working with ZeroMQ.  Redis takes a little more.  Azure ServiceBus Topics, microServiceBus, RabbitMQ and Azure EventHub are also quite simple to start development. <br>  BizTalk Server is difficult in all aspects, but because of its maturity, you are unlikely to be left alone with the system, you will always find good professionals with extensive experience. <br>  A running system on Azure or RabbitMQ is not as easy to set up and scale as it may seem.  Any broker that is configured in a cluster configuration will require you not only knowledge, but also experience. <br>  The complexity of the system will grow much faster than the number of nodes in the system. </div><p>Source: <a href="https://habr.com/ru/post/278237/">https://habr.com/ru/post/278237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278223/index.html">Using PowerShell to work with Veeam Backup Free Edition</a></li>
<li><a href="../278227/index.html">The digest of interesting materials from the world of Drupal # 18</a></li>
<li><a href="../278231/index.html">Practical training in the field of information security: Corporate Laboratories 2016, reboot</a></li>
<li><a href="../278233/index.html">Java programmer cheat sheet 7.1 Typical tasks: The optimal way to convert an InputStream to a string</a></li>
<li><a href="../278235/index.html">Rules of life of the sysadmin</a></li>
<li><a href="../278243/index.html">Tales of "engineering special forces", well, or just our fun work</a></li>
<li><a href="../278245/index.html">Stack chases with a stack, or bytecode conversion of a Java virtual machine into a Phantom OS bytecode.</a></li>
<li><a href="../278247/index.html">Preparing an ASP.NET Core: Creating Your Cross-Platform Modular Framework</a></li>
<li><a href="../278251/index.html">Preparing an ASP.NET Core: Creating Your Own Tag Helper</a></li>
<li><a href="../278253/index.html">Zephyr Project - real-time open source OS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>