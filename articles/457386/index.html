<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding Linux Virtual Interfaces: Tunnels</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Linux supports many types of tunnels. This confuses newbies who find it difficult to understand the differences in technology, and understand which tu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding Linux Virtual Interfaces: Tunnels</h1><div class="post__text post__text-html js-mediator-article"> Linux supports many types of tunnels.  This confuses newbies who find it difficult to understand the differences in technology, and understand which tunnel is best to use in a specific situation.  In the material, the translation of which we are publishing today, we will give a brief overview of the frequently used tunnel interfaces of the Linux kernel.  We will not go deep into this topic, having considered only the general features of tunnels and options for their use in Linux. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/457386/"><img src="https://habrastorage.org/webt/-0/wg/hq/-0wghqvj6hymntfthlttl1xu6tm.jpeg"></a> <br><br>  The author of this material believes that what will be discussed here may be of interest to anyone who has something to do with the management of computer networks.  A list of tunnel interfaces, as well as reference information about a specific configuration, can be obtained using the iproute2 <code>ip link help</code> command. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The following commonly used interfaces will be discussed here: IPIP, SIT, ip6tnl, VTI and VTI6, GRE and GRETAP, GRE6 and GRE6TAP, FOU, GUE, GENEVE, ERSPAN and IP6ERSPAN. <br><br>  After reading this article, you will learn about the features of these interfaces and find out the differences between them.  You will learn how to create them and learn about the situations in which they are best used. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">IPIP</font> </h2><br>  An IPIP tunnel, as its name suggests, is a tunnel operating in IP over IP mode ( <a href="https://tools.ietf.org/html/rfc2003">RFC 2003</a> ).  The IPIP tunnel packet header is as shown below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/369/49b/92c/36949b92c3d045185f09095a7a23dbfd.png"></div><br>  <i><font color="#999999">IPIP Tunnel Packet Header</font></i> <br><br>  Such tunnels are commonly used to connect two internal IPv4 subnets over a public IPv4 network (Internet).  The use of IPIP creates a minimal additional load on the system, but only unidirectional data transmission (unicast) can be performed through such a tunnel.  That is, having built a similar tunnel, it will not be possible to use it for multicast data transmission (multicast). <br><br>  IPIP tunnels support IP over IP and MPLS over IP modes. <br><br>  Note that when the ipip module is loaded, or when an IPIP device is first created, the Linux kernel will create a <code>tunl0</code> with the attributes <code>local=any</code> and <code>remote=any</code> in each namespace.  Receiving IPIP packets, the kernel, in certain cases, will redirect them to <code>tunl0</code> as the device used by default.  This happens when the kernel cannot find another device whose <code>local/remote</code> attributes more closely match the source and destination addresses of the packets. <br><br>  Here's how to create an IPIP tunnel: <br><br>  On server A: <br><br><pre> <code class="plaintext hljs"># ip link add name ipip0 type ipip local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR # ip link set ipip0 up # ip addr add INTERNAL_IPV4_ADDR/24 dev ipip0 Add a remote internal subnet route if the endpoints don't belong to the same subnet # ip route add REMOTE_INTERNAL_SUBNET/24 dev ipip0</code> </pre> <br>  On server B: <br><br><pre> <code class="plaintext hljs"># ip link add name ipip0 type ipip local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR # ip link set ipip0 up # ip addr add INTERNAL_IPV4_ADDR/24 dev ipip0 # ip route add REMOTE_INTERNAL_SUBNET/24 dev ipip0</code> </pre> <br>  Note that when using this configuration, it must be aligned with real data.  In particular, <code>LOCAL_IPv4_ADDR</code> , <code>REMOTE_IPv4_ADDR</code> , <code>INTERNAL_IPV4_ADDR</code> and <code>REMOTE_INTERNAL_SUBNET</code> need to be replaced with addresses used in your environment.  The same is true for other examples of configurations, which we will consider further. <br><br><h2>  <font color="#3AC1EF">Sit</font> </h2><br>  SIT (Simple Internet Transition) is a technology for creating tunnels, the main purpose of which is to connect isolated IPv6 networks via the Internet using the IPv4 protocol. <br><br>  Initially, SIT technology could work only in the ‚ÄúIPv6 over IPv4‚Äù tunneling mode.  However, over the years of development, it has gained the support of several more regimes.  In particular, this is <code>ipip</code> (it was the same with the IPIP tunnel), <code>ip6ip</code> , <code>mplsip</code> and <code>any</code> . <br><br>  The <code>any</code> mode is used to work with IP and IPv6 traffic, which can be useful in some situations.  SIT tunnels also support <a href="https://www.ietf.org/rfc/rfc4214.txt">ISATAP</a> .  Here is <a href="http://www.litech.org/isatap">an example of</a> using this technology. <br><br>  The header of the SIT packet is as shown below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/193/172/49e/19317249ec76200873dabf9aac6bc755.png"></div><br>  <i><font color="#999999">SIT Tunnel Packet Header</font></i> <br><br>  When the <code>sit</code> module loads, the Linux kernel creates the default <code>sit0</code> . <br><br>  Here's how to create an SIT tunnel (these steps must be performed on servers A and B): <br><br><pre> <code class="plaintext hljs"># ip link add name sit1 type sit local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR mode any # ip link set sit1 up # ip addr add INTERNAL_IPV4_ADDR/24 dev sit1</code> </pre> <br><h2>  <font color="#3AC1EF">Ip6tnl</font> </h2><br>  The ip6tnl interface works in IPv4 / IPv6 over IPv6 mode.  It is similar to the IPv6 version of the SIT tunnel.  This is what the ip6tnl header looks like. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e7/b3b/1b6/9e7b3b1b6862d0f3100c9c64db2171b7.png"></div><br>  <i><font color="#999999">Ip6tnl tunnel packet header</font></i> <br><br>  Ip6tnl tunnels support <code>ip6ip6</code> , <code>ipip6</code> and <code>any</code> modes.  The <code>ipip6</code> mode <code>ipip6</code> represented by the ‚ÄúIPv4 over IPv6‚Äù scheme, the <code>ip6ip6</code> mode is ‚ÄúIPv6 over IPv6‚Äù.  The <code>any</code> mode supports both schemes. <br><br>  When the <code>ip6tnl</code> module is <code>ip6tnl</code> , the Linux kernel creates a default device named <code>ip6tnl0</code> . <br><br>  Here's how to create an ip6tnl tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name ipip6 type ip6tnl local LOCAL_IPv6_ADDR remote REMOTE_IPv6_ADDR mode any</code> </pre> <br><h2>  <font color="#3AC1EF">VTI and VTI6</font> </h2><br>  The Virtual Tunnel Interface (VTI) interface in Linux is similar to the Cisco VTI interface and the Juniper implementation of a secure tunnel (st.xx). <br><br>  This tunneling driver implements IP encapsulation, which can be used with xfrm to create secure tunnels and then use kernel-level routing over such tunnels. <br><br>  In general, VTI tunnels work almost like IPIP or SIT tunnels.  The exception is that they enable fwmark and IPsec encapsulation / decapsulation. <br><br>  VTI6 is the IPv6 equivalent of VTI. <br><br>  Here's how to create a VTI tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name vti1 type vti key VTI_KEY local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR # ip link set vti1 up # ip addr add LOCAL_VIRTUAL_ADDR/24 dev vti1 # ip xfrm state add src LOCAL_IPv4_ADDR dst REMOTE_IPv4_ADDR spi SPI PROTO ALGR mode tunnel # ip xfrm state add src REMOTE_IPv4_ADDR dst LOCAL_IPv4_ADDR spi SPI PROTO ALGR mode tunnel # ip xfrm policy add dir in tmpl src REMOTE_IPv4_ADDR dst LOCAL_IPv4_ADDR PROTO mode tunnel mark VTI_KEY # ip xfrm policy add dir out tmpl src LOCAL_IPv4_ADDR dst REMOTE_IPv4_ADDR PROTO mode tunnel mark VTI_KEY</code> </pre> <br>  In addition, you can configure IPsec using <a href="https://libreswan.org/wiki/Route-based_VPN_using_VTI">libreswan</a> or <a href="https://wiki.strongswan.org/projects/strongswan/wiki/RouteBasedVPN">strongSwan</a> . <br><br><h2>  <font color="#3AC1EF">GRE and GRETAP</font> </h2><br>  GRE (Generic Routing Encapsulation) technology is described in <a href="https://tools.ietf.org/html/rfc2784">RFC 2784</a> .  With GRE tunneling, an additional GRE header is added between the headers of the inner and outer IP packets. <br><br>  In theory, GRE can encapsulate packets of any Layer 3 protocol with a valid Ethernet type.  This distinguishes GRE technology from IPIP technology, which only supports IP encapsulation.  This is what the package header looks like when using the GRE technology. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22d/b74/b09/22db74b090586084bfe845c7df963139.png"></div><br>  <i><font color="#999999">GRE Tunnel Packet Header</font></i> <br><br>  Note that GRE tunnels allow multicast data transfer and support IPv6. <br><br>  When the <code>gre</code> module is loaded, the Linux kernel creates a default device, <code>gre0</code> . <br><br>  Here's how to create a GRE tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name gre1 type gre local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR [seq] key KEY</code> </pre> <br>  While GRE tunnels operate at layer 3 of the OSI model, GRETAP tunnels operate at layer 2 of OSI.  This means that one of the internal headers of the corresponding packets are Ethernet headers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1da/ec8/099/1daec8099c6cede117df740da4791144.png"></div><br>  <i><font color="#999999">GRETAP tunnel packet header</font></i> <br><br>  Here's how to create a GRETAP tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name gretap1 type gretap local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR</code> </pre> <br><h2>  <font color="#3AC1EF">GRE6 and GRE6TAP</font> </h2><br>  GRE6 is the IPv6 equivalent of GRE.  GRE6 tunnels allow you to encapsulate any Layer 3 protocols in IPv6.  This is what the GRE6 header looks like. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8c/69e/45a/d8c69e45aab1f77ea5948cf2a6e81c35.png"></div><br>  <i><font color="#999999">GRE6 Tunnel Packet Header</font></i> <br><br>  In GRE6TAP tunnels, as well as in GRETAP tunnels, there are Ethernet headers among the internal packet headers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72c/290/7c7/72c2907c7c649e6390d1e51156bcac57.png"></div><br>  <i><font color="#999999">GRE6TAP Tunnel Packet Header</font></i> <br><br>  Here's how to create a GRE tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name gre1 type gre6 local LOCAL_IPv6_ADDR remote REMOTE_IPv6_ADDR # ip link add name gretap1 type gretap6 local LOCAL_IPv6_ADDR remote REMOTE_IPv6_ADDR</code> </pre> <br><h2>  <font color="#3AC1EF">FOU</font> </h2><br>  Tunneling can be performed at different levels of the network stack.  IPIP, SIT and GRE tunnels exist at the IP level.  And FOU tunnels (they are arranged according to the ‚Äúfoo over UDP‚Äù scheme) operate at the UDP level. <br><br>  Using UDP tunneling has some advantages over IP tunneling.  The fact is that the UDP protocol works with the existing hardware infrastructure. <br><br>  For example, this is <a href="https://en.wikipedia.org/wiki/Network_interface_controller">RSS</a> in network cards, <a href="https://en.wikipedia.org/wiki/Equal-cost_multi-path_routing">ECMP</a> in switches, these are technologies for calculating checksums without the participation of a central processor.  Applying the appropriate FOU <a href="https://lwn.net/Articles/614433/">patch</a> for developers shows a significant increase in performance for the SIT and IPIP protocols. <br><br>  Currently, FOU tunnels support IPIP, SIT, and GRE based protocol encapsulation.  This is what a FOU header might look like. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90d/a66/cb9/90da66cb92c6e3083f29ed97b952e0b6.png"></div><br>  <i><font color="#999999">FOU Tunnel Packet Header</font></i> <br><br>  Here's how to create a FOU tunnel: <br><br><pre> <code class="plaintext hljs"># ip fou add port 5555 ipproto 4 # ip link add name tun1 type ipip remote 192.168.1.1 local 192.168.1.2 ttl 225 encap fou encap-sport auto encap-dport 5555</code> </pre> <br>  The first command sets up the receiving FOU port for IPIP, tied to 5555. To use GRE, you need to use <code>ipproto 47</code> .  The second command sets up a new IPIP virtual interface ( <code>tun1</code> ), designed for FOU encapsulation, the target port of which is 5555. <br><br>  Please note that FOU tunnels are not supported in Red Hat Enterprise Linux. <br><br><h2>  <font color="#3AC1EF">GUE</font> </h2><br>  Another type of UDP tunneling is represented by GUE ( <a href="https://tools.ietf.org/html/draft-ietf-intarea-gue">Generic UDP Encapsulation</a> ) technology.  The difference between FOU and GUE is that GUE has its own header, which contains protocol information and other data. <br><br>  Currently, GUE tunnels support IPIP, SIT, and GRE internal encapsulation.  Here‚Äôs what a GUE package header might look like. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/412/d7f/d38/412d7fd38350aa55b24cb0b93865d93c.png"></div><br>  <i><font color="#999999">GUE Tunnel Packet Header</font></i> <br><br>  Here's how to create a GUE tunnel: <br><br><pre> <code class="plaintext hljs"># ip fou add port 5555 gue # ip link add name tun1 type ipip remote 192.168.1.1 local 192.168.1.2 ttl 225 encap gue encap-sport auto encap-dport 5555</code> </pre> <br>  These commands will create a receiving GUE port for IPIP, tied to 5555, and an IPIP tunnel configured for GUE encapsulation. <br><br>  GUE tunnels are not supported in Red Hat Enterprise Linux. <br><br><h2>  <font color="#3AC1EF">GENEVE</font> </h2><br>  GENEVE (Generic Network Virtualization Encapsulation) tunnels support all XLAN, NVGRE and STT features.  GENEVE technology is designed with a view to bypassing the identified limitations of these three technologies.  Many believe that this technology can, in the long term, completely replace these three older formats.  This is what the GENEVE tunnel packet header looks like. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/767/f30/98e/767f3098ee539caf3f03778143fa6106.png"></div><br>  <i><font color="#999999">GENEVE Tunnel Packet Header</font></i> <br><br>  This header is similar to the <a href="https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking/">VXLAN</a> packet header.  The main difference between the two is that the GENEVE header is more flexible.  It makes it very easy to implement new features by expanding headers with Type-Length-Value (TLV) fields. <br><br>  Details about GENEVE can be found <a href="https://tools.ietf.org/html/draft-ietf-nvo3-geneve-08">here</a> and <a href="https://www.redhat.com/en/blog/what-geneve">here</a> . <br><br>  GENEVE is used in the <a href="https://access.redhat.com/documentation/en-us/red_hat_openstack_platform/13/html/networking_with_open_virtual_network/open_virtual_network_ovn">Open Virtual Network</a> (OVN) SDN solution as a standard encapsulation tool.  Here's how to create a GENEVE tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name geneve0 type geneve id VNI remote REMOTE_IPv4_ADDR</code> </pre> <br><h2>  <font color="#3AC1EF">ERSPAN and IP6ERSPAN</font> </h2><br>  ERSPAN (Encapsulated Remote Switched Port Analyzer) technology uses GRE encapsulation to extend the basic port mirroring capabilities from level 2 to level 3.  This allows you to forward mirrored traffic over a routed IP network.  This is what the ERSPAN package header looks like. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dee/15d/871/dee15d871a6ee9d433f154b9a6a6e048.png"></div><br>  <i><font color="#999999">ERSPAN Tunnel Packet Header</font></i> <br><br>  ERSPAN tunnels allow Linux hosts to act as an ERSPAN traffic source and send mirrored ERSPAN traffic either to a remote host or to an ERSPAN destination that receives and processes ERSPAN packets generated by Cisco switches or other ERSPAN-enabled devices.  Such a system can be used to analyze and diagnose the network, to detect malicious traffic. <br><br>  Linux currently supports most of the capabilities of the two versions of ERSPAN - v1 (type II) and v2 (type III). <br><br>  Here's how to create ERSPAN tunnels: <br><br><pre> <code class="plaintext hljs"># ip link add dev erspan1 type erspan local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR seq key KEY erspan_ver 1 erspan IDX</code> </pre> <br>  You can still do this: <br><br><pre> <code class="plaintext hljs"># ip link add dev erspan1 type erspan local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR seq key KEY erspan_ver 2 erspan_dir DIRECTION erspan_hwid HWID</code> </pre> <br>  Add a tc filter to monitor traffic: <br><br><pre> <code class="plaintext hljs"># tc qdisc add dev MONITOR_DEV handle ffff: ingress # tc filter add dev MONITOR_DEV parent ffff: matchall skip_hw action mirred egress mirror dev erspan1</code> </pre> <br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  We have covered quite a few technologies for creating tunnels in Linux.  Here is a summary table for them. <br><br><div class="scrollable-table"><table><tbody><tr><td>  Type of tunnel / connection <br></td><td>  External header <br></td><td>  Encapsulated header <br></td><td>  Internal header <br></td></tr><tr><td>  ipip <br></td><td>  IPv4 <br></td><td>  None <br></td><td>  IPv4 <br></td></tr><tr><td>  sit <br></td><td>  IPv4 <br></td><td>  None <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  ip6tnl <br></td><td>  IPv4 <br></td><td>  None <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  vti <br></td><td>  IPv4 <br></td><td>  IPsec <br></td><td>  IPv4 <br></td></tr><tr><td>  vti6 <br></td><td>  IPv6 <br></td><td>  IPsec <br></td><td>  IPv6 <br></td></tr><tr><td>  gre <br></td><td>  IPv4 <br></td><td>  GRE <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  gretap <br></td><td>  IPv4 <br></td><td>  GRE <br></td><td>  Ether + IPv4 / IPv6 <br></td></tr><tr><td>  gre6 <br></td><td>  IPv6 <br></td><td>  GRE <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  gre6tap <br></td><td>  IPv6 <br></td><td>  GRE <br></td><td>  Ether + IPv4 / IPv6 <br></td></tr><tr><td>  fou <br></td><td>  IPv4 / IPv6 <br></td><td>  UDP <br></td><td>  IPv4 / IPv6 / GRE <br></td></tr><tr><td>  gue <br></td><td>  IPv4 / IPv6 <br></td><td>  UDP + GUE <br></td><td>  IPv4 / IPv6 / GRE <br></td></tr><tr><td>  geneve <br></td><td>  IPv4 / IPv6 <br></td><td>  UDP + Geneve <br></td><td>  Ether + IPv4 / IPv6 <br></td></tr><tr><td>  erspan <br></td><td>  IPv4 <br></td><td>  GRE + ERSPAN <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  ip6erspan <br></td><td>  IPv6 <br></td><td>  GRE + ERSPAN <br></td><td>  IPv4 / IPv6 <br></td></tr></tbody></table></div><br>  Please note that all the tunnels, examples of which are shown here, exist only until the server is restarted.  If you want to create a tunnel that can be restored after a reboot, consider using a daemon to configure the network, like <a href="https://developer.gnome.org/NetworkManager/stable/">NetworkManager</a> , or use the appropriate mechanism from your Linux distribution. <br><br>  <b>Dear readers!</b>  What kind of Linux tunnel are you using? </div><p>Source: <a href="https://habr.com/ru/post/457386/">https://habr.com/ru/post/457386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457374/index.html">Reduce the build time of your Android projects</a></li>
<li><a href="../457378/index.html">How id Software created Wolfenstein 3D based technologies from Commander Keen</a></li>
<li><a href="../45738/index.html">Bored, my friends ...</a></li>
<li><a href="../457380/index.html">Super modern OpenGL. Part 2</a></li>
<li><a href="../457382/index.html">7 habits of highly efficient programmers</a></li>
<li><a href="../45739/index.html">Openit.com.ua [Not] v_kkrita kraina</a></li>
<li><a href="../457392/index.html">Saving on mobile cross-platform development: Skyeng case</a></li>
<li><a href="../457396/index.html">Automatic unlocking of the root LUKS container after a hot reboot</a></li>
<li><a href="../457398/index.html">Am I not doing bullshit? Why do developers go to gemba</a></li>
<li><a href="../4574/index.html">SchoolZhizni.ru - social network of journalists and critics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>