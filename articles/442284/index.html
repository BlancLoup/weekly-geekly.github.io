<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>NoVerify: Linter for PHP from Team VKontakte is now publicly available</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let me tell you how we managed to write a linter, which turned out fast enough to check for changes during each git push and do it in 5-10 seconds wit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>NoVerify: Linter for PHP from Team VKontakte is now publicly available</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/zu/fg/gw/zufggwwy-grc8n2umc_p0_ioskw.png"><br><br>  Let me tell you how we managed to write a linter, which turned out fast enough to check for changes during each git push and do it in 5-10 seconds with a code base of 5 million lines in PHP.  We called it NoVerify. <br><br>  NoVerify supports basic things like the transition to defining and finding uses and can work in <a href="">Language Server</a> mode.  First of all, our tool is focused on the search for potential errors, but is able to check and style.  Today its source code appeared in open-source on GitHub.  Look for the link at the end of the article. <br><a name="habracut"></a><br><h2>  Why do we need a linter </h2><br>  In the middle of 2018, we decided that it was time to implement a linter for PHP code.  There were two goals: to reduce the number of errors that users see, and to more strictly enforce the code style.  At the same time, we focused on preventing typical errors: the presence of undeclared and unused variables in the code, unreachable code and others.  I also wanted the static analyzer to work as fast as possible on our code base (5-6 million lines of PHP code at the time of this writing). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As you probably know, the source code for most of the site is written in PHP and compiled using <a href="https://habr.com/ru/company/vk/blog/214877/">KPHP</a> , so it would be logical to add these checks to the compiler.  But in fact, not all code makes sense to run through KPHP - for example, the compiler is weakly compatible with third-party libraries, so regular PHP is still used for some parts of the site.  They are also important and should be checked by the linter, so, unfortunately, there is no possibility to embed it in KPHP. <br><br><h2>  Why NoVerify </h2><br>  Given the size of the PHP code (remember, this is 5-6 million lines), it is not possible to ‚Äúfix‚Äù it right away so that it passes our own checks in the linter.  Nevertheless, I want the changing code to gradually become cleaner and more strictly follow the coding standards, and also contain fewer errors.  Therefore, we decided that the linter should be able to check for changes that the developer is going to push, and not swear at the rest. <br><br>  To do this, the linter needs to index the entire project, fully analyze the files before and after the changes, and calculate the difference between the generated warnings.  New warnings are shown to the developer, and we need to fix them before you can push. <br><br>  But there are situations when this behavior is undesirable, and then developers can push without local hooks ‚Äî using the <code>git push --no-verify</code> .  The option <code>--no-verify</code> and gave the name to the linter :) <br><br><h2>  What were the alternatives </h2><br>  The code base in VK uses little OOP and mainly consists of functions and classes with static methods.  If classes in PHP support autoload, then functions are not.  Therefore, we cannot use static analyzers without significant modifications, which base their work on the fact that autoload will load all the missing code.  Such linters include, for example, <a href="https://psalm.dev/">psalm from the company Vimeo</a> . <br><br>  We reviewed the following static analysis tools: <br><br><ul><li>  <a href="https://github.com/phpstan/phpstan">PHPStan</a> is single-threaded, requires autoload, code base analysis has reached 30% in half an hour; </li><li>  <a href="https://github.com/phan/phan">Phan</a> - even in quick mode with 20 processes, analysis stopped at 5% after 20 minutes; </li><li>  <a href="https://psalm.dev/">Psalm</a> - requires autoload, the analysis took 10 minutes (I would still like to be much faster); </li><li>  <a href="https://github.com/squizlabs/PHP_CodeSniffer">PHPCS</a> - checks style, but not logic; </li><li>  <a href="https://github.com/badoo/phpcf">phpcf</a> - only checks formatting. </li></ul><br>  As you can guess from the title of the article, none of these tools satisfy our requirements, so we wrote our own. <br><br><h2>  How to create a prototype </h2><br>  At first we decided to build a small prototype to see if it was worth trying to make a full-fledged linter at all.  Since one of the most important requirements for a linter is its speed, instead of PHP, we chose Go.  ‚ÄúFast‚Äù is to give feedback to the developer as quickly as possible, preferably in no more than 10-20 seconds.  Otherwise, the cycle ‚Äúcorrect the code, run the linter again‚Äù begins to significantly slow down the development and spoil the mood of people :) <br><br>  Since Go is chosen for the prototype, you need a PHP parser.  There are several of them, but the <a href="https://github.com/z7zmey/php-parser">php-parser</a> project seemed to be the most mature.  This parser is not perfect and is still being finalized, but for our purposes it is quite suitable. <br><br>  For the prototype, it was decided to try to implement one of the most simple, at first glance, inspections: access to an undefined variable. <br><br>  The basic idea for implementing such an inspection looks simple: for each branch (for example, for if) we create a separate nested scope and combine the types of variables at the output from it.  Example: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rand()) { $a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  : { $a: int } } else { $b = "test"; $a = "another_test"; //  : { $b: string, $a: string } } //   : { $b: string?, $a: int|string } echo $a, $b; //       , //   $b   </span></span></code> </pre><br>  Looks easy, right?  In the case of ordinary conditional statements, everything works well.  But we have to handle, for example, switch without break; <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (rand()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: $a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// { $a: int } case 2: $b = 2; // { $a: int, $b: int } default: $c = 3; // { $a: int, $b: int, $c: int } } // { $a: int?, $b: int?, $c: int }</span></span></code> </pre><br>  It is not immediately clear from the code that $ c will always be actually defined.  Specifically, this example is fictional, but it illustrates well what are the difficult moments for the linter (and for the person in this case too). <br><br>  Consider a more complex example: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> exec(<span class="hljs-string"><span class="hljs-string">"hostname"</span></span>, $out, $retval); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $out, $retval; <span class="hljs-comment"><span class="hljs-comment">// { $out: ???, $retval: ??? }</span></span></code> </pre><br>  Without knowing the signature of the exec function, one cannot say whether $ out and $ retval are defined.  Signatures of built-in functions can be obtained from the repository <a href="https://github.com/JetBrains/phpstorm-stubs">github.com/JetBrains/phpstorm-stubs</a> .  But the same problems will be when calling custom functions, and their signature can be found only by indexing the entire project.  The exec function takes the second and third arguments by reference, so the variables $ out and $ retval can be defined.  Here, accessing these variables is not necessarily an error, and the linter should not swear at such a code. <br><br>  Similar problems with implicit passing by reference arise with methods, but at the same time the need to infer types of variables is added: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rand()) { $a = some_func(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $a = other_func(); } $a-&gt;some_method($b); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $b;</code> </pre><br>  We need to know which types return some_func () and other_func () functions, so that we can later find a method called some_method in these classes.  Only then can we say whether the variable $ b will be defined or not.  The situation is complicated by the fact that often simple functions and methods do not have phpdoc annotations, so you need to be able to calculate the types of functions and methods based on their implementation. <br><br>  When developing a prototype, we had to implement about half of all the functionality in order for the simplest inspection to work as it should. <br><br><h2>  Work as a language server </h2><br>  To make it easier to debug the linter logic and make it easier to see the warnings that it issues, we decided to add a mode as a <a href="">language server for PHP</a> .  In the integration mode with Visual Studio Code, it looks like this: <br><br><img src="https://habrastorage.org/webt/dr/ig/vj/drigvj1bhifibymyhcl_vzjq7q8.jpeg"><br><br>  In this mode, it is convenient to test hypotheses and test complex cases (after that, you need to write tests, of course).  It is also good to test performance: even on large files, php-parser on Go shows good performance. <br><br>  Language server support is far from ideal, since its main purpose is to debug linter rules.  However, in this mode there are several additional features: <br><br><ol><li>  Hints for the names of variables, constants, functions, properties and methods. </li><li>  Highlighting derived types of variables. </li><li>  Transition to definition. </li><li>  Search for uses. </li></ol><br><h2>  Lazy type inference </h2><br>  In language server mode, the following is required: you change the code in one file, and then, when you switch to another, you should work with the already updated information about which types are returned in functions or methods.  Imagine that the files are edited in the following sequence: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//  A.php,  1 class A { /** @var int */ public $prop; } //  B.php,   class B { public static function something() { $obj = new A; return $obj-&gt;prop; } } //  C.php,   $c = B::something(); // $c   int //  A.php,  2 class A { /** @var string &lt;---   string */ public $prop; } //  C.php,   $c = B::something(); // $c   string,   B.php,  C.php  </span></span></code> </pre><br>  Given that we do not force developers to always write PHPDoc (especially in such simple cases), we need a way to store information about what type the function B :: something () returns.  So that when the A.php file changes, the type information in the C.php file is immediately up to date. <br><br>  One possible solution is to store "lazy types."  For example, the return type of the method B :: something () actually represents the type of the expression (new A) -&gt; prop.  In this form, the linter and stores information about the type, and thanks to this, you can cache all the meta-information on each file and update it only when this file changes.  This should be done carefully, so that there is no chance that specific types of information are leaked.  You also need to change the cache version when the type inference logic changes.  However, such a cache speeds up the indexing phase (which I will discuss later) by a factor of 5‚Äì10 compared to re-parsing all files. <br><br><h2>  Two phases of work: indexing and analysis </h2><br>  As we remember, even for the simplest code analysis, information on at least all functions and methods in a project is required.  This means that you can not analyze only one file separately from the project.  And also - that it is impossible to do this in one pass: for example, PHP allows accessing functions that are further declared in a file. <br><br>  Due to these limitations, the linter operation consists of two phases: primary indexing and subsequent analysis of only the necessary files.  Now more about these two phases. <br><br><h3>  Indexing phase </h3><br>  In this phase, all files are parsed and local code analysis of methods and functions is done, as well as code at the top level (for example, to determine the types of global variables).  Information about declared global variables, constants, functions, classes and their methods is collected and written to the cache.  For each file in the project, the cache is a separate file on the disk. <br><br>  A global dictionary of all the meta-information about the project is compiled from individual pieces, which later does not change anymore *. <br><br>  <i>* In addition to the mode of operation as a language server, when an indexing and analysis of a modified file is carried out for every edit.</i> <br><br><h3>  Analysis phase </h3><br>  In this phase, we can use the meta-information (about functions, classes ...) and already directly analyze the code.  Here is a list of what NoVerify can check by default: <br><br><ul><li>  unreachable code; </li><li>  referring to objects as an array; </li><li>  insufficient number of arguments when calling a function; </li><li>  calling an undefined method / function; </li><li>  access to a missing class property / constant; </li><li>  lack of class; </li><li>  invalid phpdoc; </li><li>  reference to an undefined variable; </li><li>  reference to a variable that is not always defined; </li><li>  no ‚Äúbreak;‚Äù after case in switch / case constructs; </li><li>  syntax error; </li><li>  unused variable. </li></ul><br>  The list is quite short, but you can add checks that are specific to your project. <br><br>  During the operation of the linter, it turned out that the most useful inspection is just the last (unused variable).  This often happens when you refactor a code (or write a new one) and put it wrong in the name of the variable: this code is valid from the point of view of PHP, but erroneously logically. <br><br><h2>  Work speed </h2><br>  How long does the change we want to push are checked?  It all depends on the number of files.  With NoVerify, the process can take up to a minute (as it was when I changed 1,400 files in the repository), but if there were a few changes, then usually all checks take 4‚Äì5 seconds to complete.  During this time there is a full indexing of the project, the parsing of new files, as well as their analysis.  We were quite able to create a linter for PHP, which works quickly even with our large codebase. <br><br><h2>  What is the result? </h2><br>  Since the solution is written in Go, you need to use the repository <a href="https://github.com/JetBrains/phpstorm-stubs">github.com/JetBrains/phpstorm-stubs</a> to have the definitions of all the built-in PHP functions and classes.  Instead, we got high speed (indexing 1 million lines per second, analyzing 100 thousand lines per second) and were able to add linker checks as one of the first steps in hooks for git push. <br><br>  A convenient base was developed for creating new inspections and a code understanding level close to PHPStorm was achieved.  Due to the fact that out of the box, the mode of operation with diff calculation is supported, it is possible to gradually improve the code, preventing new potentially problematic structures in the new code. <br><br>  Diff counting is not perfect: for example, if one large file was separated into several small ones, then git, and therefore NoVerify, will not be able to determine that the code has been moved, and the linter will require fixing any problems found.  In this regard, the counting of diffs makes it difficult to conduct a major refactoring, so in such cases it is often turned off. <br><br>  Writing a linter on Go has another advantage: not only the AST parser is faster and consumes less memory than PHP, but the subsequent analysis is also very smart compared to anything that could be done in PHP.  This means that our linter can perform more complex and in-depth analysis of the code, while maintaining high performance (for example, the ‚Äúlazy types‚Äù feature requires a fairly large number of calculations to be performed in the process). <br><br><h2>  Open source </h2><br>  <a href="https://github.com/VKCOM/noverify">NoVerify is available in open source on github</a> <br><br>  Enjoy using your project! <br><br>  <b>UPD:</b> I have prepared a <a href="https://yuriynasretdinov.github.io/noverify/">demo that works through WebAssembly</a> .  The only limitation of this demo is the lack of definitions of functions from phpstorm-stubs, so the linter will swear on the built-in functions. <br><br>  <i>Yury Nasretdinov, developer of the VKontakte infrastructure department</i> </div><p>Source: <a href="https://habr.com/ru/post/442284/">https://habr.com/ru/post/442284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442268/index.html">AsyncIO Micropython: Synchronization Methods in Asynchronous Programming</a></li>
<li><a href="../442270/index.html">5 mistakes to avoid when creating 3D models for 3D printing</a></li>
<li><a href="../442272/index.html">Go + = package version control</a></li>
<li><a href="../442278/index.html">Kibana User Guide. Visualization. Part 6</a></li>
<li><a href="../442280/index.html">Machine learning in Dodo. How to start a new direction, if you are a developer</a></li>
<li><a href="../442286/index.html">Russian ophthalmologists told about bionic vision. New mobile application demonstrates cybernet work</a></li>
<li><a href="../442290/index.html">Making ST-Link V2.1 from Chinese ST-Link V2</a></li>
<li><a href="../442292/index.html">Internship Sberseasons: Python, UX / UI, Data and more for students</a></li>
<li><a href="../442294/index.html">What is slightly wrong Oleg Artamonov</a></li>
<li><a href="../442298/index.html">Gatsby.js in detail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>