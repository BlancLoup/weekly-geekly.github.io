<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Python, how would I like to see it</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Everyone knows that I do not like the third version of Python and the direction in which this programming language is developing. Over the past few mo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Python, how would I like to see it</h1><div class="post__text post__text-html js-mediator-article">  Everyone knows that I do not like the third version of Python and the direction in which this programming language is developing.  Over the past few months, I have received many emails asking about my vision for Python development and decided to share my thoughts with the community in order to, if possible, give food for thought to future language developers. <br><br>  We can say for sure: Python is not an ideal programming language.  In my opinion, the main problems stem from the features of the interpreter and are little related to the language itself, however all these nuances of the interpreter gradually become part of the language itself, and therefore they are so important. <br><br>  I want to start our conversation with one interpreter weirdness (slots) and end it with the biggest mistake of the language architecture.  In fact, this series of posts is a study of the decisions inherent in the architecture of the interpreter, and their influence on both the interpreter and the language itself.  I believe that from the point of view of the overall design of the language, such articles will look much more interesting than just expressing thoughts on improving Python. <br><a name="habracut"></a><br><h1>  Language and implementation </h1>  This section was added by me after writing the entire article.  In my opinion, some developers overlook the fact that Python is interconnected as a language and CPython as an interpreter, and believe that they are independent of each other.  Yes, there is a specification of the language, but in many cases it either describes the work of the interpreter, or simply holds back some points. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      With this approach, the implicit implementation details of the interpreter directly affect the architecture of the language, and even force other implementations of the Python language to adopt some things.  For example, PyPy does not know anything about slots (as far as I know), but has to work as if slots are part of it. <br><br><h1>  Slots </h1>  In my opinion, one of the biggest problems of the language is the idiotic slot system.  I'm not talking about the construction of <strong>__slots__</strong> , I mean internal type slots for special methods.  These slots are a ‚Äúfeature‚Äù of the language, which many lose sight of because few people have to deal with it.  At the same time, the existence of slots is the biggest problem of the Python language. <br><br>  So what is a slot?  This is a side effect of the internal implementation of the interpreter.  Every Python programmer knows about ‚Äúmagic methods,‚Äù such as <strong>__add__</strong> : these methods begin and end with two underscores, between which their name is enclosed.  Every developer knows that if we write <strong>a + b</strong> in the code, the interpreter will call the function <strong>a .__ add __ (b)</strong> . <br><br>  Unfortunately, this is not true. <br><br>  Python doesn't really work that way.  Python inside is completely different (at least in the current version).  Here is how the interpreter works: <br><ol><li>  When an object is created, the interpreter finds all the class descriptors and searches for magic methods, such as <strong>__add__</strong> . </li><li>  For each special method found, the interpreter places a reference to the descriptor in a specially designated object slot, for example, the magic <strong>__add__</strong> method is associated with two internal slots: <strong>tp_as_number-&gt; nb_add</strong> and <strong>tp_as_sequence-&gt; sq_concat</strong> . </li><li>  When the interpreter wants to execute <strong>a + b</strong> , it will call something like <strong>TYPE_OF (a) -&gt; tp_as_number-&gt; nb_add (a, b)</strong> (in fact, everything is more complicated there, because the <strong>__add__</strong> method has several slots). </li></ol><br>  The <strong>a + b</strong> operation should be something like <strong>type (a) .__ add __ (a, b)</strong> , however, as we saw from working with slots, this is not entirely true.  You can easily verify this yourself by redefining the metaclass method <strong>__getattribute__</strong> , and trying to implement your own <strong>__add__</strong> method ‚Äî you will notice that it will never be called. <br><br>  In my opinion, the system of slots is simply absurd.  It is an optimization for working with some data types (for example, integer), however, it makes absolutely no sense for other objects. <br><br>  To demonstrate this, I wrote such a meaningless class ( <strong>x.py</strong> ): <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__add__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, other)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span></code> </pre> <br>  Since we redefined the <strong>__add__</strong> method, the interpreter will place it in the slot.  But let's check how fast it is?  When we perform operation <strong>a + b</strong> , we will use the slot system, and here are the results of the profiling: <br><br><pre> <code class="bash hljs">$ python3 -mtimeit -s <span class="hljs-string"><span class="hljs-string">'from x import A; a = A(); b = A()'</span></span> <span class="hljs-string"><span class="hljs-string">'a + b'</span></span> 1000000 loops, best of 3: 0.256 usec per loop</code> </pre><br>  If we perform the operation <strong>a .__ add __ (b)</strong> , then the slot system will not be used, and instead the interpreter will refer to the class instance dictionary (where it will not find anything) and, further, to the class dictionary itself, where the desired method will be found.  Here are the measurements: <br><br><pre> <code class="bash hljs">$ python3 -mtimeit -s <span class="hljs-string"><span class="hljs-string">'from x import A; a = A(); b = A()'</span></span> <span class="hljs-string"><span class="hljs-string">'a.__add__(b)'</span></span> 10000000 loops, best of 3: 0.158 usec per loop</code> </pre><br>  Can you believe it?  The option without using slots turned out to be faster than the option with slots.  Magic?  I‚Äôm not completely sure about the reasons for this behavior, but this has been going on for a long time, a very long time.  In fact, the classes of the old type (which did not have slots) worked much faster than the classes of the new type and had more features. <br><br>  More opportunities, you ask?  Yes, because old type classes could do this (Python 2.7): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>original = <span class="hljs-number"><span class="hljs-number">42</span></span> &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooProxy</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__getattr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getattr(original, x) ... &gt;&gt;&gt; proxy = FooProxy() &gt;&gt;&gt; proxy <span class="hljs-number"><span class="hljs-number">42</span></span> &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> + proxy <span class="hljs-number"><span class="hljs-number">43</span></span> &gt;&gt;&gt; proxy + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">43</span></span></code> </pre><br>  Today, despite a more complex type system than in Python 2, we have fewer features.  The code above cannot be executed using new type classes.  In fact, it is still worse if we take into account how lightweight the classes of the old type were: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OldStyleClass</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewStyleClass</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; sys.getsizeof(OldStyleClass) <span class="hljs-number"><span class="hljs-number">104</span></span> &gt;&gt;&gt; sys.getsizeof(NewStyleClass) <span class="hljs-number"><span class="hljs-number">904</span></span></code> </pre><br><h1>  Where did the slot system come from? </h1>  All this raises the question of where the slots came from.  As far as I can tell, it has long been the custom.  When the Python interpreter was originally created, the built-in types (for example, strings) were implemented as global static structures, which made it necessary for them to contain all these special methods that the object should have.  This was before the advent of the <strong>__add__</strong> method as such.  If we turn to the earliest version of Python in 1990, we will see how the objects were implemented at that time. <br><br>  Here, for example, how integer looked like: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> number_methods int_as_number = { intadd, <span class="hljs-comment"><span class="hljs-comment">/*tp_add*/</span></span> intsub, <span class="hljs-comment"><span class="hljs-comment">/*tp_subtract*/</span></span> intmul, <span class="hljs-comment"><span class="hljs-comment">/*tp_multiply*/</span></span> intdiv, <span class="hljs-comment"><span class="hljs-comment">/*tp_divide*/</span></span> intrem, <span class="hljs-comment"><span class="hljs-comment">/*tp_remainder*/</span></span> intpow, <span class="hljs-comment"><span class="hljs-comment">/*tp_power*/</span></span> intneg, <span class="hljs-comment"><span class="hljs-comment">/*tp_negate*/</span></span> intpos, <span class="hljs-comment"><span class="hljs-comment">/*tp_plus*/</span></span> }; typeobject Inttype = { OB_HEAD_INIT(&amp;Typetype) <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(intobject), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*tp_dealloc*/</span></span> intprint, <span class="hljs-comment"><span class="hljs-comment">/*tp_print*/</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*tp_getattr*/</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*tp_setattr*/</span></span> intcompare, <span class="hljs-comment"><span class="hljs-comment">/*tp_compare*/</span></span> intrepr, <span class="hljs-comment"><span class="hljs-comment">/*tp_repr*/</span></span> &amp;int_as_number, <span class="hljs-comment"><span class="hljs-comment">/*tp_as_number*/</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*tp_as_sequence*/</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*tp_as_mapping*/</span></span> };</code> </pre><br>  As we can see, even in the very first version of Python, the <strong>tp_as_number</strong> method already existed.  Unfortunately, some old versions of Python (in particular, the interpreter) were lost due to damage to the repository, so we turn to slightly later versions to see how the objects were implemented.  This is how the <strong>add</strong> function code looked in 1993: <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> object * add(v, w) object *v, *w; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v-&gt;ob_type-&gt;tp_as_sequence != <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*v-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_concat)(v, w); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v-&gt;ob_type-&gt;tp_as_number != <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) { object *x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (coerce(&amp;v, &amp;w) != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; x = (*v-&gt;ob_type-&gt;tp_as_number-&gt;nb_add)(v, w); DECREF(v); DECREF(w); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } err_setstr(TypeError, <span class="hljs-string"><span class="hljs-string">"bad operand type(s) for +"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; }</code> </pre><br>  So when did the <strong>__add__</strong> and other methods appear?  I think they appeared in version 1.1.  I managed to compile Python 1.1 on OS X 10.9: <pre> <code class="bash hljs">$ ./python -v Python 1.1 (Aug 16 2014) Copyright 1991-1994 Stichting Mathematisch Centrum, Amsterdam</code> </pre><br>  Of course, this version is not stable, and not everything works as it should, but you can get an idea about the Python of those days.  For example, there was a huge difference between the implementation of objects in C and in Python: <br><br><pre> <code class="bash hljs">$ ./python test.py Traceback (innermost last): File <span class="hljs-string"><span class="hljs-string">"test.py"</span></span>, line 1, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ? <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> dir(1 + 1) TypeError: dir() argument must have __dict__ attribute</code> </pre><br><br>  We see that then there was no introspection for built-in types, such as integer.  In fact, the <strong>__add__</strong> method was supported exclusively for user-defined classes: <br><br><pre> <code class="bash hljs">&gt;&gt;&gt; (1).__add__(2) Traceback (innermost last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line 1, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ? TypeError: attribute-less object</code> </pre><br>  Here is the legacy we got today in Python.  The basic principle of the Python object architecture has not changed, but for many, many years they have been subjected to numerous modifications, changes and refactoring. <br><br><h1>  Modern PyObject </h1>  Today, many will argue with the statement that the difference between the built-in Python data types implemented in C and objects implemented in pure Python is insignificant.  In Python 2.7, this difference is particularly pronounced in the fact that the <strong>__repr__</strong> method <strong>is</strong> provided by the corresponding class <strong>class</strong> for types implemented in Python and, accordingly, the <strong>type</strong> for embedded objects implemented in C. This difference actually indicates the location of the object: statically (for <strong>type</strong> ) or dynamically on the heap (for <strong>class</strong> ).  In practice, this difference did not matter, and in Python 3, it completely disappeared.  Special methods are placed in slots and vice versa.  It would seem that the difference between the Python and C classes is no more. <br><br>  However, the difference is still there, and very noticeable.  Let's figure it out. <br><br>  As you know, classes in Python are ‚Äúopen‚Äù.  This means that you can ‚Äúlook‚Äù at them, see the content that is stored in them, add or delete methods even after the class declaration is completed.  But this flexibility is not provided for the built-in interpreter classes.  Why is that? <br><br>  There are no technical limitations to add a new method to, say, a <strong>dict</strong> object.  The reason why the interpreter does not allow you to do this has little to do with the developer's sanity, the whole point is that the built-in data types are not located in the heap.  To appreciate the global implications of this, you first need to understand how Python runs the interpreter. <br><br><h1>  Devil interpreter </h1>  Running an interpreter in Python is a very expensive process.  When you run an executable file, you activate a complex mechanism that can do a little more than anything.  Among other things, built-in data types, import mechanisms for modules are initialized, some required modules are imported, work with the operating system is performed to customize working with signals and command line parameters, the internal state of the interpreter is configured, etc.  And only after the end of all these processes, the interpreter runs your code and completes its work.  So Python has been working for 25 years now. <br><br>  Here is what it looks like in pseudocode: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> bootstrap() <span class="hljs-comment"><span class="hljs-comment">/*        ,   */</span></span> initialize() rv = run_code() finalize() <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> shutdown()</code> </pre><br>  The problem is that the interpreter has a huge number of global objects, and in fact we have one interpreter.  Much better, in terms of architecture, was you to initialize the interpreter and run it something like this: <br><br><pre> <code class="hljs lisp">interpreter *iptr = make_interpreter()<span class="hljs-comment"><span class="hljs-comment">; interpreter_run_code(iptr): finalize_interpreter(iptr);</span></span></code> </pre><br>  This is how other dynamic programming languages ‚Äã‚Äãwork, such as Lua, JavaScript, etc.  The key feature is that you may have two interpreters, and this is a new concept. <br><br>  Who in general may need several interpreters?  You'd be surprised, but even for Python it is necessary, or, at least, it can be useful.  Among the existing examples are applications with embedded Python, such as <strong>mod_python</strong> web applications, they definitely need to run in an isolated environment.  Yes, in Python there are subinterpreters, but they work inside the main interpreter, and only because in Python so much is tied to the internal state.  The biggest part of the code for working with Python's internal state is at the same time the most controversial one: global interpreter lock (GIL).  Python works in the concept of a single interpreter because there is a huge amount of data shared by all subinterpreters.  They all need a lock (lock) for the sole access to this data, so this lock is implemented in the interpreter.  What data are we talking about? <br><br>  If you look at the code above, you will see all these huge structures declared as global variables.  In fact, the interpreter uses these structures directly in Python code using the <strong>OB_HEAD_INIT (&amp; Typetype)</strong> macro, which sets the necessary headers for these structures.  For example, there is a count of the number of links to the object. <br><br>  Now you see what all goes?  These objects are shared with all subinterpreters.  Now imagine that we can change any of these objects in Python code: two completely independent and unrelated Python programs that nothing should link can affect each other's state.  Imagine, for example, that JavaScript code in a tab with Facebook could change the implementation of the embedded <strong>array</strong> object, and in a tab with Google these changes would immediately begin to work. <br><br>  This is an architectural decision of 1990, which still continues to influence the modern version of the language. <br><br>  On the other hand, the immutability of built-in types was generally favorably received by the Python developer community, because the problems of changeable data types are well known in the example of other programming languages, and we will be frank, not so much lost. <br><br>  However, there is more. <br><br><h1>  What is VTable? </h1>  So, in Python, built-in (implemented in C) data types are practically immutable.  What else are they different?  Another difference is the ‚Äúopenness‚Äù of Python classes.  The methods of classes implemented in the Python programming language are ‚Äúvirtual‚Äù: there is no ‚Äúreal‚Äù table of virtual methods, as in C ++, and all methods are stored in the dictionary of the class from which the selection is made using a search algorithm.  The consequences are obvious: when you inherit from an object and override its method, it is likely that another method will be indirectly affected, because it is called in the process. <br><br>  A good example are collections that contain easy-to-use features.  So, Python dictionaries have two methods for getting an object: <strong>__getitem __ ()</strong> and <strong>get ()</strong> .  When you create a class in Python, you usually implement one method through another, returning, for example, <strong>return self .__ getitem __ (key)</strong> from the <strong>get (key)</strong> function. <br><br>  For the types implemented in the interpreter, everything is different.  The reason, again, is the difference between slots and dictionaries.  Let's say you want to create a dictionary in the interpreter, and one of the conditions is to reuse the existing code, so you want to call <strong>__getitem__</strong> from <strong>get</strong> .  What do you do? <br><br>  The Python method in C is just a function with a specific signature, and this is the first problem.  The main task of the function is to process the parameters from the Python code and convert them to something that can be used at the C level. At a minimum, you need to convert the function call arguments from the Python tuple or dictionary (args and kwargs) to local variables.  Usually they do this: first, <strong>dict__getitem__</strong> simply parses the arguments, and then <strong>dict_do_getitem</strong> is called with the actual parameters.  See what happens?  <strong>dict__getitem__</strong> and <strong>dict_get</strong> both call <strong>dict_get</strong> , which is an internal static function, and you can't do anything about it. <br><br>  There is no good way to get around this limitation, and the reason is the slot system.  The interpreter does not have a normal way to make a call via vtable, and the reason for this is GIL.  The dictionary (dict) communicates with the ‚Äúoutside world‚Äù via an API using atomic operations, and this completely loses all meaning when such calls occur through a vtable.  Why?  Because such a call may not reach the Python level, and then it will not be processed through GIL, and this will immediately lead to huge problems. <br><br>  Imagine the suffering of the redefinition in the class inherited from the dictionary, the internal function <strong>dict_get</strong> , in which lazy import is run.  You throw all your guarantees out of the window.  But then again, perhaps we should have done it a long time ago? <br><br><h1>  Conclusion </h1>  In recent years, there has been a clear trend of increasing complexity of the Python language.  I would like to see the opposite. <br><br>  I want the internal architecture of its interpreter to be based on independent subinterpreters with local basic data types, in the same way as it works in JavaScript.  This would open up tremendous possibilities for embedding and multi-threading based on messaging.  Processors will no longer be faster. <br><br>  Instead of slots and dictionaries in the role of vtable, let's just experiment with dictionaries.  Objective-C language is completely based on messaging, and it plays a decisive role in its speed: I see that call processing in Objective-C is much faster than in Python.  The fact that strings are internal type in Python makes comparing them quick.  I am ready to argue that the proposed approach will not be worse, and even if it slows down the work of internal types a little, the result should be a much simpler architecture that is easier to optimize. <br><br>  You should study the Python source code to see how much extra code is required for the operation of the slot system, it‚Äôs just unbelievable!  I am convinced that it was a bad idea, and we should have given it up long ago.  Rejection of slots will benefit even PyPy, since I am sure that its authors have to go all out, so that their interpreter works in CPython compatibility mode. <br><br>  <em>Translated <a href="https://habrahabr.ru/users/dreadatour/" class="user_link">Dreadatour</a> , text read <a href="https://habrahabr.ru/users/dreadatour/" class="user_link">%%</a> username.</em> </div><p>Source: <a href="https://habr.com/ru/post/234747/">https://habr.com/ru/post/234747/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../234737/index.html">Flask Mega-Tutorial, Part 11: Email Support</a></li>
<li><a href="../234739/index.html">InFocus M512 - a budget device for Snapdragon 400 and with support for 4G networks</a></li>
<li><a href="../234741/index.html">Speed: terminal acceleration for stock trading with undocumented features</a></li>
<li><a href="../234743/index.html">Open lecture on the basics of Swift from MasterUp</a></li>
<li><a href="../234745/index.html">New virtual monitoring features for System Center with Veeam Management Pack v7</a></li>
<li><a href="../234749/index.html">Extremely cool tester-style programming!</a></li>
<li><a href="../234753/index.html">Natural selection - the enemy of the bot</a></li>
<li><a href="../234755/index.html">We launched LTE-Advanced: 100 Mbit / s barrier per subscriber has been overcome</a></li>
<li><a href="../234757/index.html">Gmini accessories reviewer - battery cases and mobile speaker</a></li>
<li><a href="../234759/index.html">Skype announced the termination of support for Android 2.2 and previous versions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>