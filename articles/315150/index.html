<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overclocking the performance of iOS applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Brake for the battleship USS Indiana BB-1, 1910. This thing should slow down the ship with a displacement of 10453 tons. 

 Original: iOS App Performa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overclocking the performance of iOS applications</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/914/018/821/914018821531d185f8a709ba52210369.jpg" alt="image"><br>  <i>Brake for the battleship USS Indiana BB-1, 1910.</i>  <i>This thing should slow down the ship with a displacement of 10453 tons.</i> <br><br>  Original: <a href="https://medium.com/%40mandrigin/ios-app-performance-instruments-beyond-48fe7b7cdf2">iOS App Performance: Instruments &amp; beyond</a> <br>  Posted by: Igor M <br><br>  Users do not like to wait.  They do not care (and should not) what the application needs for initialization; they just want to accomplish their task as quickly as possible.  Your application should start almost instantly, its interface should be beautiful with smooth transitions.  Application performance is one of the key advantages in a competitive software market. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As developers, we also want to be proud of our applications. <br><br>  However, performance optimization is a complex issue.  Most of the bottlenecks are counterintuitive.  In the absence of proper measurements, it is extremely difficult to understand what slows down your application. <br><br>  In order to be able to optimize the performance of your application, you must make data-based decisions.  In this part, I will show how to get this data by measuring the performance of various parts of your application. <br><a name="habracut"></a><br>  Tools that I will touch on: <br><br><ul><li>  analytics of the use of CPU, GPU, memory and energy consumption by your application; </li><li>  responsiveness of the application; </li><li>  launch time; </li><li>  performance metrics collected from your users. </li></ul><br>  Analytics of CPU, GPU, Memory, and Energy Use by Your Application <br>  The first task is to use the profiler to find inefficient code that misuses the CPU, GPU or memory.  Apple has a great tool to accomplish this: ‚Äú <a href="https://developer.apple.com/library/watchos/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html">Instruments</a> .‚Äù <br><br>  There are 4 main areas that should be used first: <br><br><ul><li>  CPU ("Time Profiler" tool); </li><li>  GPU ("Core Animation" tool); </li><li>  memory usage ("allocations" tool); </li><li>  power consumption ("Energy diagnostics" tool). </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/3fa/903/1d3/3fa9031d3592828f5b06cb98a03fd6fa.png" alt="image"><br><br>  WWDC videos are the best source for using Instruments for profiling your application. <br><br>  Here are some options to get you started. <br><br><ol><li>  <a href="https://developer.apple.com/videos/play/wwdc2012-409/">Training Instruments</a> . </li><li>  Productivity iOS <a href="https://developer.apple.com/videos/play/wwdc2012-235/">1</a> , <a href="https://developer.apple.com/videos/play/wwdc2012-242/">2</a> , <a href="https://developer.apple.com/videos/play/wwdc2012-238/">3</a> . </li><li>  <a href="https://developer.apple.com/videos/play/wwdc2014-418/">Optimize your application with Instruments</a> . </li><li>  <a href="https://developer.apple.com/videos/play/wwdc2014-419/">Advanced Graphics and Animation for iOS applications</a> . </li><li>  <a href="https://developer.apple.com/videos/play/wwdc2015-412/">Depth profiling</a> . </li><li>  <a href="https://developer.apple.com/videos/play/wwdc2015-231/">Cocoa Touch best practices</a> . </li><li>  <a href="https://developer.apple.com/videos/play/wwdc2011-312/">IOS performance and power optimization with Instruments</a> . </li><li>  <a href="https://developer.apple.com/videos/play/wwdc2011-105/">Polishing your application</a> . </li></ol><br><h2>  Application responsiveness </h2><br>  The next important thing to measure is the responsiveness of the user interface.  Sensory processing occurs in the mainstream.  When you have lengthy operations there, your application becomes sluggish. <br><br>  Some operations may take a long time, even if they do not use a processor.  If you have synchronous calls in the main thread, then you should measure the time spent on these calls. <br><br>  To measure, you can use an example: <br><br><pre><code class="hljs objectivec"><span class="hljs-built_in"><span class="hljs-built_in">CFAbsoluteTime</span></span> startTime = <span class="hljs-built_in"><span class="hljs-built_in">CFAbsoluteTimeGetCurrent</span></span>(); <span class="hljs-comment"><span class="hljs-comment">// Your method NSUInteger milliseconds = (NSUInteger)((CFAbsoluteTimeGetCurrent() ‚Äî startTime) * 1000); NSLog(‚ÄúDone in %lu ms‚Äù, milliseconds);</span></span></code> </pre> <br>  Another approach has been described by <a href="https://www.viber.com/">Viber</a> developers.  They create a special stream that monitors the main stream and checks that it is not blocked for more than 400 ms. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f41/73c/f5e/f4173cf5e9de70a10d8953b532677636.png" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/61d/f66/24d/61df6624df69d29a6a9d07a07e1795b2.png" alt="image"><br>  More information can be found in <a href="https://dl.dropboxusercontent.com/u/3820193/VbierClientUnderTheHood.pdf">their presentations</a> (PDF, 7MB). <br><br>  Use this data to detect calls that take too long (400 ms is a good threshold, you can read <a href="http://amzn.com/0321509188">this book</a> for more information) and either optimize them or move it from the main thread. <br><br><h2>  Start time </h2><br>  The next important thing to measure is how quickly your application starts.  A typical user spends <a href="http://info.localytics.com/blog/time-in-app-increases-by-21-across-all-apps">just a few minutes</a> in your application.  Long startup time leads to frustration. <br><br>  There are 2 options for running your application. <br><br><ul><li>  <b>Cold start: the</b> process of your application has not yet been launched, the launch is performed first through the OS. </li><li>  <b>Warm start:</b> your application has been minimized, but has not been killed.  It is restored from the background. </li></ul><br>  This section is dedicated to cold loading, as it requires more resources and is hard work. <br><br>  There is a startup sequence from an IOS application.  Application launch phases (from documentation) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f34/96d/efd/f3496defd739a04dce2eddd794b2b2f1.png" alt="image"><br><br><h3>  1. Measure the total time taken to start. </h3><br>  We need to measure the time from the beginning of <b>main ()</b> to the end of the <b>applicationDidBecomeActive</b> : <br><br>  main.m <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Save the initial time for startup [[StartipTimeMonitor sharedMonitor] appWillStartLoading]; @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } }</span></span></code> </pre> <br>  AppDelegate.m <br><pre> <code class="cpp hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)applicationDidBecomeActive:(UIApplication *)application { <span class="hljs-comment"><span class="hljs-comment">// Your code // We assume that the app is loaded then the main thread become free // after this callback is finished. dispatch_async(dispatch_get_main_queue(), ^{ [[StartipTimeMonitor sharedMonitor] appDidFinishLoading]; }); }</span></span></code> </pre> <br><br>  After adding the code, check that it doesn't get worse when you add new features to the application.  Try to keep the cold start time up to 1 sec. <br><br><h3>  2. Measure the phase time at startup. </h3><br>  As a rule, it is not enough to know only the total time taken to start.  It is also important to know which phase of the startup sequence slows it down. <br><br>  The most important stages are: <br><br><ul><li>  [AppDelegate application: didFinishLaunchingWithOptions:] - this method is called when the boot image or storyboard is shown.  As soon as the execution point returns from this method, the actual loading of the user interface begins. </li><li>  [UIViewController loadView] - if your application creates its own UIView, this is where it is initialized. </li><li>  [UIViewController viewDidLoad] - UIView was loaded;  time for final initialization. </li><li>  [AppDelegate applicationDidBecomeActive:] - the user interface has already been initialized, but it is still blocked until the call to this method is completed.  This method is also called when the application is restored from the background. </li></ul><br>  If some of the methods take too much time, then you need to optimize them. <br><br><h3>  3. Measure launch time "under pressure" </h3><br>  There is one important difference between the real world and the typical test environment. <br>  Your application does not live in isolation in the real world.  The user usually enters your application from another application.  ‚ÄúOther application‚Äù can be very heavy. <br><br>  It is really important to measure the launch time in the conditions when your application is launched while another, heavy application is at the same time taken to the background and trying to save its data.  This testing may reveal some unexpected results.  Code that was completely harmless before can slow down your application significantly under these conditions. <br><br><ul><li>  4. The application has already started, but still useless </li></ul><br>  If your application does not work after the user interface is loaded, then you need to assume that in fact the startup phase is not yet complete.  Even if the loaded user interface is responsive, but there is data that needs to be loaded, then this should also be considered part of the launch phase. <br><br><h2>  Performance indicators to be assembled from users </h2><br>  All previous measurements are possible in a test environment.  They are necessary, but not sufficient.  If your application is popular, if the base of your users is spread around the globe, some of your users may have an environment that is very different from what you expected. <br><br>  They may have different: <br><br><ul><li>  network conditions; </li><li>  hardware; </li><li>  software (OS version, jailbreak ...); </li><li>  the amount of free space on the device; </li><li>  etc. </li></ul><br>  They may use the application in an unusual way. <br><br>  You can get a ‚Äúone star‚Äù rating when reviewing complaints (‚ÄúYour app is slow!‚Äù).  Even if all the metrics that you measure in the lab are in the safe zone. <br><br><h2>  What to do with it? </h2><br>  Determine a set of performance indicators (KPIs) and collect them from your real users.  You can use almost any analytics package to do this. <br><br>  Here are examples of key performance indicators that you can get from users: <br><br><ul><li>  total cold start time; </li><li>  total warm start time; </li><li>  phase start time; </li><li>  the time spent on downloading the necessary data from the server; </li><li>  the number of times the main thread is blocked for more than 400 ms; </li><li>  Number of low memory warnings </li><li>  number of <a href="https://code.facebook.com/posts/1146930688654547/reducing-fooms-in-the-facebook-ios-app/">FOOMS</a> ; </li><li>  the duration of operations when the interface is locked, or is unusable. </li></ul><br>  Analytics packages will allow you to distribute these indicators into segments, along with the type of device, country, or network operator.  This will help get an idea of ‚Äã‚Äãwhat performance problems users have and how to fix it. <br><br><h2>  findings </h2><br>  As you can see, performance measurements go beyond just launching Instruments.app.  There are other important points to analyze.  Some of the described methods of analysis are quick and easy to implement, others require more time and effort.  However, they will help you monitor the performance of the application to find and fix problems and make your application more enjoyable to use. <br><br><hr><br><br><h2>  Achieving high performance scrolling, for example Facebook application </h2><br>  Original: <a href="https://code.facebook.com/posts/456535491190613/delivering-high-scroll-performance/">Delivering high scroll performance</a> <br>  Posted by: Cl√©ment Genzmer <br><br>  One of our goals on Facebook is to maximize the user experience of using our iOS app.  One of the tasks is to make sure that the news feed scrolls smoothly, but in a complex UIScrollView, with very diverse content, there are currently no good ways in iOS to determine why the frame rate has decreased.  We have developed an identification strategy that works very well in practice and helps us maintain high scrolling performance.  Next, we describe in detail how it works. <br><br><h2>  Measure scroll performance on device </h2><br>  The first step in most of the work is to measure performance and measuring instruments.  Apple's tools allow you to measure the frame rate of your application, but it's still difficult to simulate all the interactions that occur while the application is running.  Another approach would be to measure the scroll performance directly on the device. <br><br>  We measure the frame rate on a device using Apple's CADisplayLink API.  Every time a frame is outlined, we measure the time it took to do this.  If it took more than one sixtieth of a second (16.6 ms), the frame rate was low and the scrolling jerked. <br><br> <code>[CADisplayLink displayLinkWithTarget:self selector:@selector(_update)]; <br> [_displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</code> <br> <br><h2>  Detecting and fixing regression </h2><br>  Unlike video games, the Facebook application does not use the GPU very intensively.  It displays mostly text and images, and thus most frames fall due to processor overhead.  To maintain the high performance of the processor, we want to make sure that all operations that make up the data rendering in the News Feed are performed in less than 16.6 milliseconds.  In practice, frame rendering consists of several stages, and an application, as a rule, has only 8 to 10 ms in the main stream until the frame rate drops. <br><br>  Knowing where the main thread spends most of the time on the CPU allows you to get the best scrolling performance.  You can use the Time Profiler tool to estimate where the main thread spends most of the time, but it can be difficult to recreate the exact conditions on the device when the frame rate drops. <br><br>  Another approach is to collect data while the application is running to help determine the most likely cause of a frame drop.  That is, we can say that the application profiles itself.  To do this, you need to use signals.  The data obtained may not be accurate, but this allows you to get profiling data in an isolated environment.  This is not possible with traditional profiling on iOS using standard tools such as Instruments and DTrace. <br><br><h2>  Signals and profiling on the device </h2><br>  In order to understand what the thread is doing, we pause it by sending a signal to it, which has a callback function registered to the signal. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _callstack_signal_handler(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> signr, <span class="hljs-keyword"><span class="hljs-keyword">siginfo_t</span></span> *info, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *secret) { callstack_size = backtrace(callstacks, <span class="hljs-number"><span class="hljs-number">128</span></span>); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sigaction</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sa</span></span></span><span class="hljs-class">;</span></span> sigfillset(&amp;sa.sa_mask); sa.sa_flags = SA_SIGINFO; sa.sa_sigaction = _callstack_signal_handler; sigaction(SIGPROF, &amp;sa, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre> <br>  Operations that are safe when dealing with signals are quite limited.  Allocating memory, for example, is not a safe operation, so the only thing we do in the signal handler is to capture the current stack trace. <br><br><h2>  Trigger signal </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/f11/82e/1e4/f1182e1e4f38a6a6329556d1bc9f0654.jpg" alt="image"><br><br>  After the signal is set, we need a mechanism to trigger the signal.  This cannot be sent from the main stream, since we are trying to track this stream.  GCD is an excellent abstraction for controlling the flow of execution.  However, dispatch sources, the standard mechanism for supporting execution blocks, will be executed with a time resolution no more than every 10 ms.  NSThread offers the necessary granularity with higher temporal resolution. <br><br>  When the main thread is heavily loaded, and as a result, the frame rate drops, it will consume most of the processor execution time.  Unfortunately, this means that our reporting flow will be awakened when the main flow has already completed all labor-intensive operations, and we will miss the moment of intensive use.  To get around this problem, we give the telling thread a priority that is higher than in the main thread.  This ensures that we can capture the trace, even when the main thread is maximally loaded. <br><br><pre> <code class="hljs objectivec">_trackerThread = [[<span class="hljs-built_in"><span class="hljs-built_in">NSThread</span></span> alloc] initWithTarget:[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>] selector:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(_trackerLoop) object:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; _trackerThread.threadPriority = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; [_trackerThread start];</code> </pre> <br>  As is often the case with performance measurement, the act of measuring affects an application and may have additional implications for application performance.  Capturing a trace on the iPhone 4S takes about 1 microsecond, and when you have only 16 milliseconds, it would seem that this is quite a bit.  In addition, the act of suspending the main thread (sending a signal) generates more context switches between threads and can slow down the application as a whole. <br><br>  Thus, it is important to choose an ideal measurement policy only when absolutely necessary.  In our case, we made a number of optimizations, while measuring.  For example, a signal should be sent only when the user scrolls.  Another change we made is the performance measurement only on the internal assembly, which is used only by employees, so the measurement will not affect our public version of the program. <br><br><h2>  Reporting and symbolization </h2><br>  After the trace is captured, we collect this data on the device and send it to the server in batch mode.  Tracing, of course, is unreadable - a collection of addresses - and should be symbolized, for which there are a number of tools.  Apple, Atos API, Google Breakpad and atosl Facebook are some examples.  After symbolization, we aggregate call stacks using a data visualization tool to identify parts of the system on which to focus our efforts to prevent regression, as we continue to improve the efficiency of our scrolling. <br><br>  Below is an example showing the CPU usage of two versions of the Facebook application: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa3/6ab/b6f/aa36abb6fe3c9df010df3fdcc3548d7d.jpg" alt="image"><br><br><h2>  try it </h2><br>  This strategy allowed us to discover a very large number of regressions before they hit the release version.  We put a sample of this implementation on <a href="https://gist.github.com/clementgenzmer/4ff6c51224089cc65e9b">github</a> .  We hope you find it useful in your projects. <br><br><hr><br><br><h2>  Read more </h2><br><ul><li>  <a href="https://habrahabr.ru/company/edison/blog/314444/">27 open-source nishtyachkov for iOS developer</a> </li><li>  <a href="https://habrahabr.ru/company/edison/blog/272085/">8 principles of development planning, simplifying life</a> </li><li>  <a href="https://habrahabr.ru/company/edison/blog/271811/">Developing fast mobile apps on Android</a> </li></ul><br>  The <a href="https://www.edsd.ru/ru/proekty/portfolio">EDISON Software portfolio</a> has 8 projects related to <a href="https://www.edsd.ru/mobilnye-prilozheniya-dlya-dostupa-k-korporativnoj-infrastrukture">Android development</a> and 4 major projects related to iOS development: <br><br><ul><li>  <a href="https://www.edsd.ru/servis-dostavki-bankovskih-uvedomlenij-na-smartfony">Service delivery of banking notifications on smartphones</a> </li><li>  <a href="https://www.edsd.ru/prilozhenie-vivaldi-dlya-raboty-s-ehlektronnoj-bibliotekoj">Vivaldi application for working with the electronic library</a> </li><li>  <a href="https://www.edsd.ru/virusnaya-rassylka-informacii">Viral distribution of information</a> </li><li>  <a href="https://www.edsd.ru/mobilnye-prilozheniya-dlya-dostupa-k-korporativnoj-infrastrukture">Mobile applications for access to corporate infrastructure</a> </li></ul><br><iframe width="560" height="315" src="https://www.youtube.com/embed/YKhnhxJbu8Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/315150/">https://habr.com/ru/post/315150/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../315140/index.html">Interfaces: My, Your, Your, Our or This</a></li>
<li><a href="../315142/index.html">Ducks, Thailand, and T-SQL ... or what might lurk programmers when working with SQL Server?</a></li>
<li><a href="../315144/index.html">The digest of interesting materials for the mobile # 179 developer (November 7-13)</a></li>
<li><a href="../315146/index.html">Texel density. Why and how to use it</a></li>
<li><a href="../315148/index.html">Y. Schmidhuber: ‚ÄúIt's great to be part of the future of artificial intelligence‚Äù</a></li>
<li><a href="../315152/index.html">Your programming language sucks</a></li>
<li><a href="../315154/index.html">VaR as a way to assess risk. Historical method</a></li>
<li><a href="../315156/index.html">The correct polymorphic Java builder.</a></li>
<li><a href="../315160/index.html">Terminal Server Scan Free</a></li>
<li><a href="../315164/index.html">How else to use type safety to improve the API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>