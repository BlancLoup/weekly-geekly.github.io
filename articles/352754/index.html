<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introducing Google's S2 Geo-Library and Case Studies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 My name is Marco, I work in Badoo on the Platform team. Not so long ago, on GopherCon Russia 2018, I told you how to work with coordinate...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introducing Google's S2 Geo-Library and Case Studies</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  My name is Marco, I work in <a href="https://badoo.com/">Badoo</a> on the Platform team.  Not so long ago, on <a href="https://www.gophercon-russia.ru/">GopherCon Russia 2018,</a> I told you how to work with coordinates.  For those who do not like to watch the video (and of all those interested, of course), I publish a text version of my report. <br><br><img src="https://habrastorage.org/webt/p_/vd/6i/p_vd6i2kvf37kxey6now-zmc2ja.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Introduction </h2><br>  Now most people in the world have a smartphone with constant access to the Internet.  Speaking in numbers, in 2018 almost 5 billion people <a href="https://www.statista.com/statistics/274774/forecast-of-mobile-phone-users-worldwide/">will</a> have a smartphone, and 60% of them <a href="https://www.statista.com/statistics/284202/mobile-phone-internet-user-penetration-worldwide/">use the</a> mobile Internet. <br><br>  These are huge numbers.  It became easy and simple for companies to receive user coordinates.  These ease and accessibility have spawned (and continue to spawn) a huge number of services based on coordinates. <br><br>  We all know companies like <a href="https://www.uber.com/">Uber</a> , games that have conquered the world, such as <a href="https://www.ingress.com/">Ingress</a> and <a href="https://www.pokemongo.com/">Pokemon Go</a> .  But what is there, in any banking application, you can see ATMs or discounts nearby. <br><br>  We at Badoo are also very active in using coordinates to provide our users with the best, relevant and interesting service for them.  But what kind of use are we talking about?  Let's look at examples of services that we have. <br><a name="habracut"></a><br><h2>  Badoo Geo Services </h2><br><h3>  First example: Meetmaker and Geousers </h3><br>  Badoo is first of all dating.  A place where people get to know each other.  One of the important criteria when searching for people is the distance.  Indeed, in most cases, a girl from Moscow wants to meet a boy who is a couple of kilometers away from her, or at least also lives in Moscow, and not in far Vladivostok. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t1/rr/sg/t1rrsg2duubf0ivr3oaldz-fi7g.png" width="600"></div><br><br>  Services that pick you people for a ‚Äúyes / no game‚Äù or show users around are searching for people with the criteria that are appropriate for you within a certain radius of you. <br><br><h3>  Second example: Geoborder </h3><br>  In order to answer the questions in which city the user is located, in which country or, more precisely, for example, at which airport or at which university, we use the Geoborder service, which deals with the so-called <a href="https://en.wikipedia.org/wiki/Geo-fence">geofencing</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bw/bo/wi/bwbowi6ah4xaaszvmhep7-x6lbm.png" width="600"></div><br><br>  The easiest way to answer these questions would be to consider the distance from the user to the city center or the center of the university, but this approach is very inaccurate and depends on a large number of boundary conditions. <br><br>  Therefore, we have drawn very precise borders of countries, cities, important objects (for example, universities and airports, of which I spoke).  These borders are defined by polygons.  Having a set of such boundaries, we can understand whether the user is inside a polygon, or find the nearest polygon to it.  Accordingly, we can tell in which city he is, or find the city nearest to him. <br><br><h3>  Third example: Bumpd </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aj/_b/3h/aj_b3h5kucyjzftyfgzt7lqaw50.png" width="400"></div><br><br>  We have a very popular feature called Bumped Into, which in the background constantly searches for users to intersect in time and space and shows you that you regularly visit the same place at the same time with this boy or this girl walk regularly the same way.  This feature is very popular with users, because it is another reason to get acquainted with the topic with which you can start a conversation. <br><br><h3>  Fourth example: Geocache - caching geo-information that is expensive to "get" </h3><br>  Well, the last example I‚Äôll mention is related to caching geo-information.  Imagine that you are using data from, for example, Booking.com, which provides you with information about hotels around, but to go to Booking.com every time is too long.  Your internet pipe is probably quite narrow, like the pit of this gopher.  Perhaps the service you go to for data takes money for each request and you want to save a little. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/a9/2r/mx/a92rmxuv5h94wtvrsg2vuatdwum.gif"></div><br><br>  In this case, it would be nice to have a caching layer, which significantly reduces the number of requests to a slow or expensive service, and will provide a very similar API to the outside.  A service that will understand that he already knows about all or most of the hotels in a given area, these data are relatively fresh, and, accordingly, you can not get behind them in an external service.  Such tasks are solved in our service called Geocache. <br><br><h2>  Features of geo-services </h2><br>  We have already understood that there are a lot of coordinates, coordinates are important, and on the basis of them you can make a lot of interesting services.  So what's next?  What is actually the matter?  How do the coordinates differ from any other information received from the user? <br><br>  And I would say two features. <br><br><img src="https://habrastorage.org/webt/tj/nl/jz/tjnljzw04vxaqa0ife5bktetdws.png"><br><br>  First, the geo-data is three-dimensional, or rather two-dimensional, because in the general case we are not interested in height.  They consist of latitude and longitude, and the search most often goes simultaneously on both.  Imagine searching in any area.  Standard indexes in common DBMSs are not optimal for this use. <br><br><img src="https://habrastorage.org/webt/7f/t_/d9/7ft_d9efytx3-du7p9k8dyky4xu.png"><br><br>  Secondly, many tasks require more complex data types such as polygons, which we discussed above using the example of the Geoborder service in Badoo.  Polygons, of course, are composed of vertex coordinates, but require additional processing, and search queries for such data types are also more complicated.  We have already seen the query "Find the nearest polygon to a point" or "Find a polygon that includes this point." <br><br><h2>  Why write your service </h2><br>  In order to comply with these features, many DBMSs include <a href="https://en.wikipedia.org/wiki/R-tree">special indexes,</a> sharpened for multidimensional data, and additional functions that allow you to work with objects such as polygons or broken lines. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/00/xt/6a/00xt6alzpo4u1by5kx4vp6bzjky.png" width="400"></div><br><br>  Probably the most striking example is <a href="https://postgis.net/">PostGIS</a> - an extension to the popular <a href="https://www.postgresql.org/">PostgreSQL</a> DBMS, which has the most extensive capabilities for working with coordinates and geography. <br><br>  But using a ready-made DBMS is not the only and not always the best solution. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5n/ef/zn/5nefzngepqetnf42_zvlr0np7z0.png" width="500"></div><br><br>  If you do not want to divide the business logic of your service between it and the DBMS, if you want something that is not available in the DBMS, if you want to fully manage your service and not be limited to scaling any DBMS, for example, then you can want to embed the ability to search and work with geo-data in your service. <br><br>  Such an approach is undoubtedly more flexible, but it can be much more complicated, because the DBMS is an all-in-one solution, and many infrastructure-type replications are already done for you.  Replications and, in fact, algorithms and indices for working with coordinates. <br><br>  But not so scary.  I would like to introduce you to the library, which implements most of what you need.  Which is a kind of cube, easily embedded wherever you need to work with the geometry on the sphere or search by coordinates.  With a library called <a href="https://s2geometry.io/">S2</a> . <br><br><h2>  S2 </h2><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rm/wu/kf/rmwukfftio50hicjpx60k9jfkma.png" width="800"></div><br><br>  <a href="https://s2geometry.io/">S2</a> is a library for working with geometry (including on a sphere), which provides very convenient possibilities for creating geo-indices. <br><br>  Until recently, S2 was virtually unknown and had very poor documentation, but not so long ago, Google decided to " <a href="https://opensource.googleblog.com/2017/12/announcing-s2-library-geometry-on-sphere.html">re-release</a> " it in open-source, adding to the layout with a promise to support and develop the product. <br><br>  The main version of the library is written in C ++ and has several official ports or versions in other languages, including the Go version.  The go-version today is not 100% realizing everything that is in the C ++ version, but what is there is enough to implement most things. <br><br>  In addition to Google, the library is actively used in companies such as <a href="https://foursquare.com/">Foursquare</a> , <a href="https://www.uber.com/">Uber</a> , <a href="https://www.yelp.com/">Yelp</a> , and of course <a href="https://badoo.com/">Badoo</a> .  And among the products that use the library inside, you can highlight the well-known MongoDB. <br><br>  But so far I have not said anything sensible about why S2 is convenient and why it makes it easy to write services with a geo search.  Let me fix and immerse myself a bit in the guts before we look at two examples. <br><br><h3>  Projection </h3><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ad/et/ko/adetkojl0x2pl2j1dzd2klp-hkg.png" width="500"></div><br><br>  Usually geography involves the use of one of the most common projections of the globe on a plane.  For example, we all know the <a href="https://en.wikipedia.org/wiki/Mercator_projection">projection of the Mercator</a> .  The disadvantage of this approach is that any projection somehow has distortions.  Our globe with you is not very much like a plane. <br><br><img src="https://habrastorage.org/webt/hl/qj/lb/hlqjlbnyiawbaiz_j0njr6z2fa0.png"><br><br>  Recall the famous picture with a comparison of Russia and Africa.  On the maps, Russia is huge, and in fact, the area of ‚Äã‚ÄãAfrica is already twice the area of ‚Äã‚ÄãRussia!  This is just an example of the distortion of the Mercator projection. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2y/aq/rc/2yaqrclawkhsbieza4x9qdzu-x0.png" width="300"></div><br><br>  S2 solves this problem by using exclusively spherical projection and spherical geometry.  Of course, the Earth is also not quite a sphere, but distortions in the case of a sphere can be neglected for most tasks. <br><br>  We will work with a unit, or <a href="https://en.wikipedia.org/wiki/Unit_sphere">unit-sphere</a> , that is, with a sphere of radius 1 and we will use such concepts as the <a href="https://en.wikipedia.org/wiki/Central_angle">central angle</a> , the spherical rectangle and the <a href="https://en.wikipedia.org/wiki/Spherical_cap">spherical segment</a> . <br><br>  The name S2 is derived from the mathematical notation denoting the unit sphere. <br><br>  But you should not be afraid, as the library takes on almost all the mathematics. <br><br><h3>  Hierarchical cells (cells) </h3><br><br>  The second (and most important) feature of the library is the concept of hierarchical partitioning of the globe into cells (in English - cells). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-_/ek/t6/-_ekt6obw6ecbrpysanyhxjxrbm.png" width="800"></div><br>  The division is hierarchical, that is, there is such a thing as a level (or level) of a cell.  And at one level, the cells are about the same size. <br><br>  Cells can set any point on Earth.  If you use a cell of the maximum, 30th level, which is smaller than a centimeter in width, then the accuracy, as you understand, will be very high.  The lower level cells can set the same point, but the accuracy will be less.  For example, 5 m by 5 m. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ar/x9/je/arx9jetwcvgc_iwpgqgbxwf5jlm.png" width="600"></div><br><br>  Cells can be set not only points, but also more complex objects such as polygons and some areas (in the picture you, for example, see Hawaii).  In this case, such figures will be given by sets of cells (possibly at different levels). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/rc/ox/zwrcox66ecwxojqwdbnbrcylwo0.png" width="800"></div><br>  Such a partition is very compact: each cell can be encoded with one 64-bit number. <br><br><h3>  Hubert Curve </h3><br><br>  I mentioned that the cell is defined by one 64-bit number.  Here it is!  It turns out that a coordinate or a point on Earth, which by default is given by two coordinates, with which we are inconvenient to work with standard methods, can be given with a single number.  But how to achieve this?  Let's get a look‚Ä¶ <br><br>  How does the hierarchical division of the sphere occur? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e_/sh/kn/e_shkngaio-ovscsom8mpv_z54i.png" width="300"></div><br><br>  We first surround the sphere with a cube and project it onto all six of its faces, slightly modifying the projection on the move to remove distortion.  This is level 0. Then we can divide each of the six faces of the cube into four equal parts - this is level 1. And each of the four parts that we can get can be further divided into four equal parts - level 2. And so on until level 30. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-_/ek/t6/-_ekt6obw6ecbrpysanyhxjxrbm.png" width="700"></div><br><br>  But at this stage, we still have two-dimensionality.  And here we come to the aid of a mathematical idea from the distant past.  At the end of the 19th century, David Hilbert came up with a way to fill any space with a one-dimensional line that turns, collapses and thus fills the space.  <a href="https://en.wikipedia.org/wiki/Hilbert_curve">The Hilbert curve is</a> recursive, which means that precision or density can be chosen.  Any small piece we can fill up more tightly if necessary. <br><br><img src="https://habrastorage.org/webt/3a/vk/cx/3avkcx6cecky-lgr5bcy0eby5ka.png"><br><br>  We can fill our two-dimensional space with such a curve.  And if we now take this curve and stretch it into a straight line (as if we are pulling a thread), we will get a one-dimensional object describing a multi-dimensional object, a one-dimensional object or a coordinate on this line, which is convenient and easy to work with. <br><br>  Something like the filling of the Hilbert curve of the Earth at one of the middle levels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dm/yo/7i/dmyo7izdarunbo70bex4qhiufv8.png" width="400"></div><br><br>  Another feature of the Hilbert curve is the fact that the points that are near on the curve are near and in space.  The reverse is not always the case, but mostly true.  And we will actively apply this feature too. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ry/nv/6d/rynv6ddkslad-zoruu9xcjnstom.png" width="400"></div><br><br><h2>  Encoding to 64-bit variable </h2><br><br>  But why can we encode any cell with a single 64-bit number, which, by the way, is called CellID?  Let's get a look. <br><br>  We have six faces of the cube.  Six different values ‚Äã‚Äãcan be encoded in three bits.  Recall <a href="https://en.wikipedia.org/wiki/Binary_logarithm">logarithms</a> . <br><br>  Then we divide each of the six faces into four equal parts 30 times.  To set one of the four parts into which we divide the cell at each level, two bits are enough for us. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fz/_b/iu/fz_biuufi066n188xcpdhtvmjha.png" width="500"></div><br><br>  Total 3 + 2 * 30 = 63. And we will set one extra bit at the end in order to know and quickly understand what level a cell is assigned to this CellID. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-a/df/pg/-adfpgqmbvqojewg80nuxvor028.png" width="500"></div><br><br>  What do all these partitions and coding of the Hilbert curve into one number give us? <br><br><ol><li>  We can encode any point on the globe with one CellID.  Depending on the level, we get different accuracy. </li><li>  We can encode any two-dimensional object on the globe with one or several CellID.  Similarly, we can play with precision by varying the levels. </li><li>  The property of the Hilbert curve, which consists in the fact that the points that are near on it are near and in space, and the fact that we have a CellID is just a number, allows us to use an ordinary B-tree for searching.  Depending on what we are looking for (point or area), we will use either get, or range scan, that is, the search ‚Äúfrom‚Äù and ‚Äúto‚Äù. </li><li>  Splitting the globe into levels gives us a simple sharding framework for our system.  For example, at the zero level we can divide our service into six instances, at the first level - into 24, etc. </li></ol><br><br>  Now, to consolidate this theoretical knowledge, let's look at two examples.  We will write two simple services, and the first one is just a search for ‚Äúaround‚Äù. <br><br><h2>  Examples </h2><br><h3>  Let's write a search service for people around </h3><br><br>  We will make a search index.  We need a function to create an index, a function to add a person to the index and, in fact, a search function.  Well, the test. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Index <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storageLevel </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Index</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *Index)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(userID </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, lon, lat </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *Index)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lon, lat </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, radius </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestSearch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> {}</code> </pre> <br>  The user is defined by his ID and coordinates, and the search - by the coordinates of the search center and the search radius. <br><br>  In the index, we need a <a href="https://en.wikipedia.org/wiki/B-tree">B-tree,</a> in the nodes of which we will store a cell of the storageLevel level and a list of users in this cell.  The storageLevel cell level is the choice between initial search accuracy and performance.  In this example, we will use a cell of about 1 km in size per 1 km.  The Less function is necessary for B-tree to work, so that the tree can understand which of our values ‚Äã‚Äãis smaller and which of them is greater. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Index <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { storageLevel <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bt *btree.BTree } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> userList <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { cellID s2.CellID list []<span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ul userList)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Less</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(than btree.Item)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(ul.cellID) &lt; <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(than.(userList).cellID) }</code> </pre><br>  Now let's look at the add user function. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *Index)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(userID </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, lon, lat </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { latlng := s2.LatLngFromDegrees(lat, lon) cellID := s2.CellIDFromLatLng(latlng) cellIDOnStorageLevel := cellID.Parent(i.storageLevel) <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><img src="https://habrastorage.org/webt/yz/bg/zp/yzbgzpfrjrxmah8xjgnjj1xmcqm.png"><br><br>  Here we see S2 in action for the first time.  We convert our coordinates, given in degrees, to radians, and then to CellID, which corresponds to these coordinates at the maximum level of 30th (that is, with the minimum cell size), and convert the resulting CellID to CellID of the level at which we will keep people.  If you look "inside" of this function, we will see just zeroing of several bits.  Remember how CellID is encoded. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *Index)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(userID </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, lon, lat </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... ul := userList{cellID: cellIDOnStorageLevel, list: nil} item := i.bt.Get(ul) if item != nil { ul = item.(userList) } ul.list = append(ul.list, userID) i.bt.ReplaceOrInsert(ul) return nil }</span></span></code> </pre><br>  Then we just need to add this user to the appropriate cell in the B-tree.  Either first, or at the end of the list, if someone is already there.  Our simple index is ready. <br><br>  Go to the search function.  The first transformations are similar, but instead of a cell, we obtain the ‚Äúdot‚Äù object by coordinates.  This is the center of our search. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *Index)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lon, lat </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, radius </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { latlng := s2.LatLngFromDegrees(lat, lon) centerPoint := s2.PointFromLatLng(latlng) centerAngle := <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(radius) / EarthRadiusM <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span> := s2.CapFromCenterAngle(centerPoint, s1.Angle(centerAngle)) <span class="hljs-comment"><span class="hljs-comment">// ... return result, nil }</span></span></code> </pre><br>  Further along the radius given in meters, we get the central angle.  This is the angle from the center of the sphere.  The transformation in this case is simple: it is enough to divide our radius in meters by the radius of the Earth in meters. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xi/bo/rd/xibordo9wkilh9echymubl-ojpw.png" width="300"></div><br><br>  We can calculate a spherical segment (or ‚Äúcap‚Äù) from the point of the center of the search and from the angle we just received.  In fact, it is a circle on a sphere, but only three-dimensional. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kb/ba/hq/kbbahq_igd-w41lyxotnx-9yvdi.png" width="300"></div><br><br>  Great, we have a ‚Äúcap‚Äù inside which we need to look.  But how?  To do this, we will ask S2 to give us a list of storageLevel level cells that completely cover our circle or our ‚Äúcap‚Äù. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *Index)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lon, lat </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, radius </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... rc := s2.RegionCoverer{MaxLevel: i.storageLevel, MinLevel: i.storageLevel} cu := rc.Covering(cap) // ... return result, nil }</span></span></code> </pre><br>  It looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bu/yc/7m/buyc7m-kvyajpgyxbbd-zuq5ncq.png" width="400"></div><br><br>  It remains only to walk through the received cells and get-s in the B-tree to get all the users that are inside. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *Index)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lon, lat </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, radius </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... var result []uint32 for _, cellID := range cu { item := i.bt.Get(userList{cellID: cellID}) if item != nil { result = append(result, item.(userList).list...) } } return result, nil }</span></span></code> </pre><br>  For the test, we will create an index and several users.  Three closer, two - away.  And let us check that in the case of a small radius only three users return, and in the case of a larger radius, all.  Hooray!  Our simple little program works. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Index</span></span></span></span> { i := NewIndex(<span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ~ 1km */</span></span>) i.AddUser(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">14.1313</span></span>, <span class="hljs-number"><span class="hljs-number">14.1313</span></span>) i.AddUser(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">14.1314</span></span>, <span class="hljs-number"><span class="hljs-number">14.1314</span></span>) i.AddUser(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">14.1311</span></span>, <span class="hljs-number"><span class="hljs-number">14.1311</span></span>) i.AddUser(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">14.2313</span></span>, <span class="hljs-number"><span class="hljs-number">14.2313</span></span>) i.AddUser(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">14.0313</span></span>, <span class="hljs-number"><span class="hljs-number">14.0313</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestSearch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { indx := prepare() found, _ := indx.Search(<span class="hljs-number"><span class="hljs-number">14.1313</span></span>, <span class="hljs-number"><span class="hljs-number">14.1313</span></span>, <span class="hljs-number"><span class="hljs-number">2000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(found) != <span class="hljs-number"><span class="hljs-number">3</span></span> { t.Fatal(<span class="hljs-string"><span class="hljs-string">"error while searching with radius 2000"</span></span>) } found, _ = indx.Search(<span class="hljs-number"><span class="hljs-number">14.1313</span></span>, <span class="hljs-number"><span class="hljs-number">14.1313</span></span>, <span class="hljs-number"><span class="hljs-number">20000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(found) != <span class="hljs-number"><span class="hljs-number">5</span></span> { t.Fatal(<span class="hljs-string"><span class="hljs-string">"error while searching with radius 20000"</span></span>) } } $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -run <span class="hljs-string"><span class="hljs-string">'TestSearch$'</span></span> PASS ok github.com/mkevac/gophercon-russia<span class="hljs-number"><span class="hljs-number">-2018</span></span>/geosearch <span class="hljs-number"><span class="hljs-number">0.008s</span></span></code> </pre><br>  But there is one rather obvious drawback.  In the case of a large search radius and low population density, it will be necessary for getters to check very, very many cells.  It is not so fast. <br><br>  Recall that we asked S2 to cover our ‚Äúcap‚Äù with exactly the cells of the storageLevel level.  But since these cells are rather small, they turn out a lot. <br><br>  We can ask S2 to cover the ‚Äúcap‚Äù with cells of different levels;  then you get something like this: <br><br><pre> <code class="go hljs">rc := s2.RegionCoverer{MaxLevel: i.storageLevel} cu := rc.Covering(<span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>)</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yn/r6/ls/ynr6lsq9qt8dnjdtvhmtjiywkas.png" width="400"></div><br><br>  As you can see, S2 uses a larger cage inside the circle, and a smaller one at the edges.  In sum, the cells become smaller. <br><br>  But in order to find users from larger cells in our B-tree, we can no longer use Get.  We need to ask S2 for each large cell the number of the first internal cell of our storageLevel level and the number of the last one and look for it using the range scan, that is, the query ‚Äúfrom‚Äù and ‚Äúto‚Äù. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *Index)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SearchFaster</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lon, lat </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, radius </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... for _, cellID := range cu { if cellID.Level() &lt; i.storageLevel begin := cellID.ChildBeginAtLevel(i.storageLevel) end := cellID.ChildEndAtLevel(i.storageLevel) i.bt.AscendRange(userList{cellID: begin}, userList{cellID: end.Next()},func(item btree.Item) bool { result = append(result, item.(userList).list...) return true }) } else { // ... } } return result, nil }</span></span></code> </pre><br>  The change is insignificant, but let's look at it in the process.  We write simple benchmarks, which are engaged in the search cycle, and run them. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res []<span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkSearch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { indx := prepare() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { res, _ = indx.Search(<span class="hljs-number"><span class="hljs-number">14.1313</span></span>, <span class="hljs-number"><span class="hljs-number">14.1313</span></span>, <span class="hljs-number"><span class="hljs-number">50000</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkSearchFaster</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { indx := prepare() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { res, _ = indx.SearchFaster(<span class="hljs-number"><span class="hljs-number">14.1313</span></span>, <span class="hljs-number"><span class="hljs-number">14.1313</span></span>, <span class="hljs-number"><span class="hljs-number">50000</span></span>) } }</code> </pre><br>  Our small change led to an acceleration of three orders of magnitude.  Not bad! <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. goos: darwin goarch: amd64 pkg: github.com/mkevac/gophercon-russia<span class="hljs-number"><span class="hljs-number">-2018</span></span>/geosearch BenchmarkSearch<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">3097564</span></span> ns/op BenchmarkSearchFaster<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">200000</span></span> <span class="hljs-number"><span class="hljs-number">7198</span></span> ns/op PASS ok github.com/mkevac/gophercon-russia<span class="hljs-number"><span class="hljs-number">-2018</span></span>/geosearch <span class="hljs-number"><span class="hljs-number">3.393s</span></span></code> </pre> <br><h3>  Let's write a geofencing service </h3><br><br>  We have considered the super-simple implementation of the search by radius.  Let's now quickly go through the same simple implementation of geofencing, that is, determining which polygon we are in or which polygon is closest to us. <br><br>  Here in our index, we will similarly need a B-tree, but in addition to it we will have a global map of all added polygons. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Index <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { storageLevel <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bt *btree.BTree polygons <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span>]*s2.Polygon } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storageLevel </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Index</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;Index{ storageLevel: storageLevel, bt: btree.New(<span class="hljs-number"><span class="hljs-number">35</span></span>), polygons: <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span>]*s2.Polygon), } }</code> </pre><br>  In the B-tree nodes, as before, we will store the list, but only now polygons that are in the storageLevel level cell. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> IndexItem <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { cellID s2.CellID polygonsInCell []<span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ii IndexItem)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Less</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(than btree.Item)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(ii.cellID) &lt; <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(than.(IndexItem).cellID) }</code> </pre><br>  In this example, we will have the functions of adding a polygon to an index, searching for a polygon in which we are located, and searching for the nearest polygon. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *Index)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddPolygon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(polygonID </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, vertices []s2.LatLng)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *Index)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lon, lat </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *Index)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SearchNearest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lon, lat </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> {}</code> </pre><br>  Let's start by adding a polygon.  The polygon is given by the list of vertices, and S2 expects that the order of the vertices will be counterclockwise.  But in case of an error, we will have a function of ‚Äúnormalization‚Äù, which, as it were, turns it inside out. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *Index)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddPolygon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(polygonID </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, vertices []s2.LatLng)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { points := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res []s2.Point)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, vertex := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> vertices { point := s2.PointFromLatLng(vertex) res = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(res, point) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }() loop := s2.LoopFromPoints(points) loop.Normalize() polygon := s2.PolygonFromLoops([]*s2.Loop{loop}) <span class="hljs-comment"><span class="hljs-comment">// ... return nil }</span></span></code> </pre><br>  We will convert the list of vertex points into a Loop, and then into a polygon.  The difference between them is that a polygon can consist of several loop-s, have a hole, for example, like a donut. <br><br>  As in the previous example, we will ask S2 to cover our polygon with cells and add each of the returned cells to B-tree.  Well, in the global map. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *Index)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddPolygon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(polygonID </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, vertices []s2.LatLng)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... coverer := s2.RegionCoverer{MinLevel: i.storageLevel, MaxLevel: i.storageLevel} cells := coverer.Covering(polygon) for _, cell := range cells { // ... ii.polygonsInCell = append(ii.polygonsInCell, polygonID) i.bt.ReplaceOrInsert(ii) } i.polygons[polygonID] = polygon return nil }</span></span></code> </pre><br>  The search function of the polygon we are in is trivial in this example.  As before, we transform the search coordinate in CellID at the storageLevel level and find or not find this cell in the B-tree. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *Index)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lon, lat </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { latlng := s2.LatLngFromDegrees(lat, lon) cellID := s2.CellIDFromLatLng(latlng) cellIDOnStorageLevel := cellID.Parent(i.storageLevel) item := i.bt.Get(IndexItem{cellID: cellIDOnStorageLevel}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item.(IndexItem).polygonsInCell, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []<span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span>{}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br>  Finding the nearest polygon is a bit more difficult.  First, we will try to determine if suddenly we are already in some kind of testing ground.  If not, then we will search by increasing radius (below I will show how it looks).  Well, when we find the nearest polygons, we filter them and find the closest one, by calculating the distance to each of the found and taking the one that is the smallest. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *Index)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SearchNearest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lon, lat </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... alreadyVisited := []s2.CellID{cellID} var found []IndexItem searched := []s2.CellID{cellID} for { found, searched = i.searchNextLevel(searched, &amp;alreadyVisited) if len(searched) == 0 { break } if len(found) &gt; 0 { return i.filter(lon, lat, found), nil } } return []uint32{}, nil }</span></span></code> </pre><br>  What does ‚Äúover increasing radius‚Äù mean?  In the first picture you see the orange cell - the center of our search.  First we will try to find the nearest polygon in all the adjacent cells (they are gray in the picture).  If we don‚Äôt find anything there, we‚Äôll move away to another level, as in the second picture.  And so on. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xa/dy/mo/xadymoefl-3gngat5w0bj05kvme.png" width="400"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6o/gs/qm/6ogsqmbecpg9int1ajfzywrzu5w.png" width="300"></div><br><br>  "Neighbors" gives us the function AllNeighbors.  Unless you need to filter the cells and remove those that we have already viewed. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *Index)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchNextLevel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radiusEdges []s2.CellID, alreadyVisited *[]s2.CellID)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(found []IndexItem, searched []s2.CellID)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, radiusEdge := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> radiusEdges { neighbors := radiusEdge.AllNeighbors(i.storageLevel) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, neighbor := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> neighbors { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> in(*alreadyVisited, neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } *alreadyVisited = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(*alreadyVisited, neighbor) searched = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(searched, neighbor) item := i.bt.Get(IndexItem{cellID: neighbor}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { found = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(found, item.(IndexItem)) } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre><br>  That's all.  For this example, I also wrote a test, and it passes successfully. <br><br>  If you are interested in looking at it or at full examples, you can find them <a href="https://github.com/mkevac/gophercon-russia-2018">here</a> along with the slides. <br><br><h2>  Conclusion </h2><br>  If you ever need to write a search service that works with coordinates or some more complex geographic objects, and you don‚Äôt want or can‚Äôt use ready-made DBMS like PostGIS, think about S2. <br><br>  This is a cool and simple tool that will give you basic things and a framework for working with coordinates and the globe.  We in Badoo love S2 very much and recommend it in every possible way. <br><br>  Thank! <br><br>  Upd: And here comes the video! <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/LHQN8lWPLw8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/352754/">https://habr.com/ru/post/352754/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352744/index.html">Mobio Talks with Natalia Shagarina (Foodadil) about product growth, launching a cashback service and partnership with Yandex</a></li>
<li><a href="../352746/index.html">Data Center in Miniature</a></li>
<li><a href="../352748/index.html">We are looking for problems with website conversion to Google Spreadsheets</a></li>
<li><a href="../352750/index.html">Cretaceous lettering for dummies on the example of working on an art object</a></li>
<li><a href="../352752/index.html">Procedural worlds from simple tiles</a></li>
<li><a href="../352758/index.html">What is behind the cleanliness in your apartment, or Qlean preparation</a></li>
<li><a href="../352760/index.html">Compare Tarantool with Redis and Memcached</a></li>
<li><a href="../352762/index.html">Code Conventions: how we maintain the fast pace of developing a PHP project</a></li>
<li><a href="../352764/index.html">EGAIS 3.0 or how not to answer for the mistakes of others</a></li>
<li><a href="../352766/index.html">Intelligence networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>