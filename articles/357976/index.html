<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The basis of the gameplay in C ++ for the Unreal Engine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The basis of the gameplay for Unreal Engine 4 provides the developer with a powerful set of classes for creating a game. Your project can be a shooter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The basis of the gameplay in C ++ for the Unreal Engine</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5f/048/741/c5f04874110bc8e8ac79374ad194abea.jpg" alt="image"></div><br>  The basis of the gameplay for Unreal Engine 4 provides the developer with a powerful set of classes for creating a game.  Your project can be a shooter, farm simulator, deep RPG - it doesn‚Äôt matter, the foundation is very versatile, does some of the hard work for you and sets some standards.  It is quite integrated into the engine, so I recommend that you stick to these classes, rather than trying to reinvent your own game base, as is often the case with engines like Unity3D.  Understanding this framework is very important for successful and effective work on projects. <br><br><h1>  Who is this article for? </h1><br>  For everyone who is interested in creating games in UE4, specifically in C ++, and who wants to learn more about the basis of the Unreal gameplay.  This post discusses the base classes that you will use at the heart of the gameplay, explains their use, the process of creating their instances with the engine, and how to access these classes from other parts of the game code.  Most information is also valid for blueprints. <br><a name="habracut"></a><br>  If you want to get acquainted with the basics of Unreal Engine 4, then study my previous <a href="http://www.tomlooman.com/getting-started-with-unreal-engine-4/" rel="noopener">manual</a> .  I also have a separate guide dedicated to <a href="http://www.tomlooman.com/getting-started-with-vr/" rel="noopener">virtual reality for beginners</a> .  It is useful to those who study the specifics of VR in the Unreal Engine 4. <br><br>  When creating games in Unreal Engine 4, you will encounter many ready-made boilerplate blanks.  There are several classes that you will often use when creating games in C ++ or in blueprints.  We will look at each of these classes, their nice features, and learn how to refer to them from other parts of the code.  Most of the information in this guide also applies to blueprints, however, I use code fragments in C ++ and therefore some functions will not be available in blueprints and are useful only for C ++ users. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Actor </h2><br>  Probably the most frequently used class in games.  Actor is the basis for any object on a level, including players controlled by AI of enemies, doors, walls and gameplay objects.  Actors are created using ActorComponents (see the next section), such as StaticMeshComponent, CharacterMovementComponent, ParticleComponent, and many others.  Even classes such as GameMode (see below) are actors (although GameMode does not have a ‚Äúreal‚Äù position in the world).  Let's discuss a couple of aspects that you need to know about actors. <br><br>  Actor is a class that can be replicated over a network (for multi-user mode).  This is easily done using a call in the SetReplicates (true) constructor.  To create effective network programming actors need to take into account many aspects that I can not consider in this article. <br><br>  Actors support the concept of taking damage.  Damage can be applied directly to the actor using MyActor-&gt; TakeDamage (...) or via UGameplayStatics :: ApplyDamage (...).  It is worth considering that there are variations: PointDamage (for example, for weapons, the hit from which is calculated by the ray tracing (hitscan)) and RadialDamage (for example, for explosions).  The official Unreal Engine website has a great introductory article <a href="https://www.unrealengine.com/en-US/blog/damage-in-ue4" rel="noopener">Damage in UE4</a> . <br><br>  Create a new instance of the actor in the code, you can simply using GetWorld () -&gt; SpawnActor &lt;T&gt; (...);  where T is the return class, for example, AActor for one of your own classes ‚Äî AGadgetActor, AGameplayProp, etc. <br><br>  Here is an example code in which an actor is created during the execution of an application: <br><br><pre><code class="cpp hljs">FTransform SpawnTM; FActorSpawnParameters SpawnParams; SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn; SpawnParams.Owner = GetOwner(); <span class="hljs-comment"><span class="hljs-comment">/* Attempt to assign an instigator (used for damage application) */</span></span> SpawnParams.Instigator = Cast&lt;APawn&gt;(GetOwner()); ASEquippableActor* NewItem = GetWorld()-&gt;SpawnActor&lt;ASEquippableActor&gt;(NewItemClass, SpawnTM, SpawnParams);</code> </pre> <br>  There are many ways to access actors.  Usually you will have a pointer / link to a specific actor that you need.  In the example shown above, we store a pointer to the actor of the worn object in a variable and begin to manipulate the actor instance through it. <br><br>  A very useful function that can be used for prototyping or mastering the engine is <em>UGameplayStatics :: GetAllActorsOfClass (...)</em> .  It allows us to get an array of all the actors of the passed class (including the generated classes; if you pass as a class Actor, then we get ALL the objects of the level).  This function is often feared and avoided as a not very effective way of interacting with the environment, but sometimes it is the only available tool. <br><br>  Actors do not have their own transfer, rotation or scale.  All this is set and obtained using RootComponent, i.e.  the top-level component in the SceneComponents hierarchy (more on SceneComponents is described below).  The most commonly used functions like MyActor-&gt; GetActorLocation () actually go to the RootComponent and return its location in the world. <br><br>  Here are some more useful functions that are used in the context of an actor: <br><br><ul><li>  <strong>BeginPlay</strong> // ‚ÄúFirst‚Äù function, called after the creation and full initialization of the actor.  This is a convenient place to set the base logic, the timer, and make changes to the properties, because the actor is already fully initialized and can perform queries to its environment. </li><li>  <strong>Tick</strong> // Called every frame.  For most actors, you can disable it for performance reasons, but by default it is enabled.  Great for quickly setting up dynamic logic and checking conditions in each frame.  Gradually, you will begin to move more and more code related to the events of logic from the timers to logic that operates at lower frequencies. </li><li>  <strong>EndPlay</strong> // Called when the actor is removed from the world.  Contains ‚ÄúEEndPlayReason‚Äù indicating the reason for the call. </li><li>  <strong>GetComponentByClass</strong> // Finds one instance of a component of a particular class.  It is very useful when you do not know the exact type of actor, but you know that it must contain a certain type of component.  There is also a GetComponentsByClass that returns all instances of the class, and not just the first one found. </li><li>  <strong>GetActorLocation</strong> // And all its variations - * Rotation, * Scale, including <strong>SetActorLocation</strong> , etc. </li><li>  <strong>NotifyActorBeginOverlap</strong> // Convenient for checking overlays caused by any of its components.  In this way, you can quickly customize gameplay triggers. </li><li>  <strong>GetOverlappingActors</strong> // Finds which other actors intersect with the selected one.  There is also an option for components: <strong>GetOverlappingComponents</strong> </li></ul><br>  Actor contains a huge functionality and a lot of variables - it is the foundation of the gameplay core in the Unreal Engine, so this is not surprising.  For further study of this class, it would be nice to open the header file Actor.h in Visual Studio and see what functionality it has.  In the article we still have a lot to consider, so let's move on to the next class in the list. <br><br><h2>  Actorcomponent </h2><br>  The components are located inside the actors, the standard components are StaticMeshComponent, CharacterMovementComponent, CameraComponent and SphereComponent.  Each of these components handles its own particular task, for example, movement, physical interaction (for example, the amount of collision to clearly check interacting actors) or visually display something in the world, for example, the mesh of a player. <br><br>  A subclass of this component is <strong>SceneComponent</strong> - this is the base class for everything associated with Transform (Position, Rotation, Scale) that supports pinning.  For example, we can attach a CameraComponent to a SpringArmComponent to configure a third-person camera.  Both transform and attachment are required to set the relative position correctly. <br><br>  Most often, components are created in the actor constructor, but you can also create and destroy them during execution.  To begin, let's consider one of the constructors of my actor. <br><br><pre> <code class="cpp hljs">ASEquippableActor::ASEquippableActor() { PrimaryActorTick.bCanEverTick = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; MeshComp = CreateDefaultSubobject&lt;USkeletalMeshComponent&gt;(TEXT(<span class="hljs-string"><span class="hljs-string">"MeshComp"</span></span>)); MeshComp-&gt;SetCollisionObjectType(ECC_WorldDynamic); <span class="hljs-comment"><span class="hljs-comment">// Just setting a property on our component RootComponent = MeshComp; // Set our root component for other SceneComponents to attach to ItemComp = CreateDefaultSubobject&lt;USItemComponent&gt;(TEXT("ItemComp")); // not attached to anything (not a SceneComponent with a transform) }</span></span></code> </pre> <br>  USkeletalMeshComponent is created using the <em>CreateDefaultSubobject &lt;T&gt;</em> (actor function) and requires the name to be specified (this name can be seen in the list of blueprint components).  If you are writing game code in C ++, you will often use this function, but ONLY within the context of the constructor. <br><br>  You may also notice that we set MeshComp as the new RootComponent.  All Scene Components should now be attached to this mesh, which can be easily done using the following line: <br><br><pre> <code class="cpp hljs">WidgetComp = CreateDefaultSubobject&lt;UWidgetComponent&gt;(TEXT(<span class="hljs-string"><span class="hljs-string">"InteractWidgetComp"</span></span>)); WidgetComp-&gt;SetupAttachment(MeshComp);</code> </pre> <br>  SetupAttachment will handle the initial attachment;  it is expected that it will be called in the constructor for ALL components of the scene, except for the RootComponent itself.  One may wonder why my ItemComponent does not call this SetupAttachment function.  It happened so simply because this component is an ActorComponent, but NOT a SceneComponent and does not have a Transform (position, rotation, scale), and therefore should not be added to the hierarchy.  However, the component will still register with Actor.  Being separated from the hierarchy means that functions like MyActor-&gt; GetComponentByClass will return all ActorComponents and SceneComponents. <br><br>  Along with Actor, these components are crucial for creating games in both C ++ and blueprints.  They are the building blocks of the game.  You can easily create your own components so that they handle some specific aspects of the game, such as the HealthComponent, which stores health points and responds to the damage taken by its parent actor. <br><br>  Using the code below, you can create your own components during the execution process.  This is different from the CreateDefaultSubobject behavior, which is used only for constructors. <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">UActorComponent</span></span>* <span class="hljs-selector-tag"><span class="hljs-selector-tag">SpawnedComponent</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">NewObject</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">UActorComponent</span></span>&gt;(<span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">UStaticMeshComponent</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::StaticClass()</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TEXT</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">DynamicSpawnedMeshCompoent</span></span>")); <span class="hljs-selector-tag"><span class="hljs-selector-tag">if</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">SpawnedComponent</span></span>) { SpawnedComponent-&gt;RegisterComponent(); }</code> </pre> <br>  Here is some of the useful functionality of ActorComponents: <br><br><ul><li>  TickComponent () // Like the actor's Tick (), each frame is executed to handle high-frequency logic. </li><li>  bool bIsActive and related functions like Activate, Deactivate, ... Used to fully enable / disable a component (including TickComponent) without destroying the component and removing it from the actor. </li></ul><br>  To ensure the replication of ActorComponent, it is necessary to call the function SetIsReplicated (true), whose name is slightly different from the function of the actor.  This is necessary only when you need to replicate a specific part of the component's logic, for example, a variable when you call a function, that is, you do not need to replicate all components of the replicated actor. <br><br><h2>  Playercontroller </h2><br>  This is the base class for the player receiving input from the user.  PlayerController itself is not visually displayed in the environment, instead it controls the Pawn instance, which determines the visual and physical representation of this player in the world.  During gameplay, a player may have several different Pawn (for example, a vehicle or a fresh copy of Pawn in respawn), and an instance of PlayerController remains the same throughout the level.  This is important, because at some points PlayerController may not have any pawn at all.  This means that things like opening the menu should be added to the PlayerController, and not to the Pawn class. <br><br>  In multiplayer games, PlayerController exists only on the client that owns it and on the server.  This means that in a 4-player game, the server has 4 player controllers, and each client only has one.  It is very important to understand when it is necessary to use variables;  if all players require replication of a player variable, then it should exist not in PlayerController, but in Pawn or even in PlayerState (discussed below). <br><br><h5>  Accessing PlayerControllers </h5><br><ul><li>  GetWorld () -&gt; GetPlayerControllerIterator () // GetWorld is available in any Actor instance </li><li>  PlayerState-&gt; GetOwner () // the owner state players is of type PlayerController, and you must transfer it to PlayerController yourself. </li><li>  Pawn-&gt; GetController () // Set only when the player already owns (ie controls) PlayerController. </li></ul><br>  This class contains the <em>PlayerCameraManager</em> , which handles the camera‚Äôs view targets and transforms, including shaking.  Another important class that PlayerController manages is HUD (discussed below).  It is used for rendering on Canvas (now used less frequently because there is a UMG) and it can be used to manage the data that needs to be transferred to the UMG interface. <br><br>  When a new player connects to GameMode, PlayerController is created for this player in the GameModeBase class using Login (). <br><br><h2>  Pawn </h2><br>  It is a physical and visual representation of what the player (or AI) controls.  It can be a car, a warrior, a tower, or anything else that represents a character in a game.  The standard Pawn subclass is Character, which implements SkeletalMesh and, more importantly, CharacterMovementComponent with many options to fine-tune the player‚Äôs movement around the environment using the usual motion shooter. <br><br>  In multiplayer games, each instance of Pawn is replicated to other clients.  This means that there are 4 pawn instances in the game for 4 players both on the server and on each client.  Quite often, a Pawn instance is ‚Äúkilled‚Äù when a player dies, while a respawn creates a new instance.  Keep this in mind when storing data that should be saved after the end of the player‚Äôs life (or completely abandon this pattern and keep the pawn instance alive at all times) <br><h5>  Accessing Pawn </h5><br><ul><li>  PlayerController-&gt; GetPawn () // Only when PlayerController owns Pawn </li><li>  GetWorld () -&gt; GetPawnIterator () // GetWorld is available for any Actor instance and returns ALL Pawn, including AI. </li></ul><br><h5>  Creature </h5><br>  GameModeBase creates a pawn using the SpawnDefaultPawnAtTransform.  The GameModeBase class also determines which Pawn class to create. <br><br><h2>  Gamemodebase </h2><br>  Base class that defines which classes to use (PlayerController, Pawn, HUD, GameState, PlayerState).  Often used to set game rules in modes such as ‚ÄúCapture the Flag‚Äù;  he can handle flags or waves of enemies.  Handles other important functions, such as player creation. <br><br>  GameMode is a subclass of GameModeBase.  It contains a few more features that were originally used in the Unreal Tournament, such as MatchState and other shooter features. <br><br>  In multiplayer mode, the GameMode class exists only on the server!  This means that no client has an instance of it.  In single player games, it has no influence.  You can use GameState, which exists on all clients and is designed specifically for this purpose, to replicate the functions and store the data necessary for GameMode. <br><br><h5>  Accessing GameMode </h5><br><ul><li>  GetWorld () -&gt; GetAuthGameMode () // GetWorld is available for any Actor instance. </li><li>  GetGameState () // returns the gamestate for replicating functions and / or variables </li><li>  InitGame (...) // initializes some of the rules of the game, including those specified in the URL (for example, ‚ÄúMyMap? MaxPlayersPerTeam = 2‚Äù) that can be transmitted when loading levels in the game. </li></ul><br><h2>  Hud </h2><br>  This is the user interface class.  It contains a lot of Canvas code, which is a user interface drawing code written before the appearance of <a href="https://docs.unrealengine.com/latest/INT/Engine/UMG/index.html" rel="noopener">UMG</a> .  Today, the main work on drawing the user interface is engaged in UMG. <br><br>  The class exists only in the client.  Replication is not possible.  It is owned by PlayerController. <br><br><h5>  Accessing HUD </h5><br>  PlayerController-&gt; GetHUD () // Available in local PlayerController. <br><br><h5>  Creature </h5><br>  It is created using SpawnDefaultHUD (creates a regular AHUD) inside PlayerController, which owns the HUD, and then overwritten by GameModeBase using the InitializeHUDForPlayer HUD class specified in GameModeBase. <br><br><h5>  My personal notes </h5><br>  I began to use this class less and less, and I use UMG, which can be controlled through PlayerController.  Don't forget - before creating widgets in multiplayer games, you need to make sure that the player's controller is IsLocalController (). <br><br><h2>  World </h2><br>  <a href="https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/Engine/UWorld/" rel="noopener">UWorld</a> is a top-level object representing the map on which actors and components will exist and render.  Contains a constant level and many other objects, such as gamestate, gamemode, as well as lists of Pawns and Controllers on the map. <br><br>  Line tracing and all its variations are performed through the World using functions such as <a href="https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/Engine/UWorld/LineTraceSingleByChannel/" rel="noopener">World-</a> &gt; <a href="https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/Engine/UWorld/LineTraceSingleByChannel/" rel="noopener">LineTraceSingleByChannel</a> and many other similar variations. <br><br><h5>  Accessing the World </h5><br>  To gain access, just call GetWorld () inside the actors. <br><br>  When you need to get an instance of World in <em>static functions</em> , you need to pass WorldContextObject, which is essentially a word for any actor that you can use to call -&gt; GetWorld ().  Here is an example from one of my header files: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> APlayerController* GetFirstLocalPlayerController(UObject* WorldContextObject);</code> </pre> <br><h2>  Gameinstance </h2><br>  GameInstance has one instance that continues to exist for the duration of the entire game.  When navigating between maps and menus, the same instance of this class will be saved.  You can use this class to create event handlers or handle network errors, load user data such as game parameters, and functions that are not related to just one game level. <br><br><h5>  Accessing GameInstance </h5><br><ul><li>  GetWorld () -&gt; GetGameInstance &lt;T&gt; ();  // where T is the class type, for example, GetGameInstance &lt;UGameInstance&gt; () or you own native type. </li><li>  Actor-&gt; GetGameInstance () </li></ul><br><h5>  My personal notes </h5><br>  Usually not used in the early stages of a project.  Do not do anything critical, unless you dive into the development (can control aspects such as gaming sessions, playing a demo or transferring data between levels) <br><br><h2>  Playerstate </h2><br>  Container for variables replicated between client / server for an individual player.  In multiplayer games, it is not designed to perform logic and is simply a data container, since PlayerController is not available to all clients, and Pawn is often destroyed when the game player dies, therefore not applicable to data that should be stored after death. <br><br><h5>  Accessing PlayerState </h5><br>  Pawn contains it as a variable Pawn-&gt; PlayerState, also available in Controller-&gt; PlayerState.  PlayerState in Pawn is assigned only when Pawn owns the Controller; otherwise, it is nullptr. <br><br>  A list of all available PlayerState instances (for example, all players in a match) can be obtained via GameState-&gt; PlayerArray. <br><br><h5>  Creature </h5><br>  The creating class is assigned in GameMode (PlayerStateClass) and created in AController :: InitPlayerState () <br><br><h5>  My personal notes </h5><br>  Useful only when working on multiplayer games. <br><br><h2>  GameStateBase </h2><br>  Looks like PlayerState, but provides clients with GameMode information.  Since the GameMode instance does not exist in clients, but only on the server, this class is a useful container for replicating information, such as the end of a match, team points, etc. <br><br>  It has two variations - GameState and GameStateBase.  GameState handles additional variables required by GameMode (unlike GameModeBase) <br><br><h5>  Accessing GameStateBase </h5><br><ul><li>  World-&gt; GetGameState &lt;T&gt; () // where T is the class being called, for example GetGameState &lt;AGameState&gt; () </li><li>  MyGameMode-&gt; GetGameState () // is stored and accessible in the gamemode instance (only needed on the server that owns a single GameMode instance);  customers must use the above call. </li></ul><br><h5>  My personal notes </h5><br>  Use GameStateBase instead of GameState, only if the gamemode is not inherited from GameMode instead of GameModeBase. <br><br><h2>  Uobject </h2><br>  The basic object for almost everything in the engine.  Actors are inherited from UObject, as well as other base classes, such as GameInstance.  It should never be used for rendering, but is very useful for storing data and functions when a struct is not suitable for you. <br><br><h5>  Creating UObjects </h5><br>  UObjects do not spawn like actors, but are created using NewObject &lt;T&gt; ().  For example: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">TSubclassOf</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">UObject</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">ClassToCreate</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">UObject</span></span>* <span class="hljs-selector-tag"><span class="hljs-selector-tag">NewDesc</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">NewObject</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">UObject</span></span>&gt;(<span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ClassToCreate</span></span>);</code> </pre> <br><h5>  Personal notes </h5><br>  It is unlikely that you will create classes directly from a UObject, unless you have mastered the engine well and do not want to delve into creating your own systems.  I, for example, use it to store lists of information from a database. <br><br>  It can be used for the network, but additional configuration of the object class is required, and the objects must be stored in the actor. <br><br><h2>  Gameplaystatics </h2><br>  Static classes are used to handle various standard game functions, for example, playing sounds and creating particle effects, creating actors, applying damage to actors, getting a player's Pawn, PlayerController, etc.  This class is very useful for all sorts of access to gameplay features.  All functions are static, that is, you do not need a pointer to an instance of this class and you can call functions directly from anywhere, as shown in the example below. <br><br><h5>  Accessing GameplayStatics </h5><br>  Since GameplayStatics is a UBlueprintFunctionLibrary, you can access it from anywhere in the code (or blueprint) <br><br><pre> <code class="cpp hljs">UGameplayStatics::WhateverFunction(); <span class="hljs-comment"><span class="hljs-comment">// static functions are easily accessed anywhere, just include #include "Kismet/GameplayStatics.h"</span></span></code> </pre> <br><h5>  My personal notes </h5><br>  In this class, many useful features and it must be known when creating any game.  I recommend <a href="https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/Kismet/UGameplayStatics/" rel="noopener">to study it</a> to learn about its capabilities. <br><br><h1>  Links </h1><br>  Recommended for learning the basics of gameplay and programming in the Unreal Engine 4 materials. <br><br><ul><li>  <a href="https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Classes/index.html" rel="noopener">Gameplay Framework Documentation</a> </li><li>  <a href="https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/index.html" rel="noopener">Gameplay Programming Documentation</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/357976/">https://habr.com/ru/post/357976/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../357966/index.html">Orange Pi 2G-IOT or Orange Paradise</a></li>
<li><a href="../357968/index.html">Released updated Raspberry Pi 3 Model B +</a></li>
<li><a href="../357970/index.html">Second GIS-hackathon "Guessing on the Cards"</a></li>
<li><a href="../357972/index.html">Reverse "Neuromant". Part 2: Render the Font</a></li>
<li><a href="../357974/index.html">Get free, quick, easy and simple system information from a variety of PCs on the network</a></li>
<li><a href="../357978/index.html">Turn on teleport: moving hubs</a></li>
<li><a href="../357980/index.html">Roskomnadzor threatens 15 hosting providers. Whatsapp and viber can also block</a></li>
<li><a href="../357982/index.html">On the rezolv plot of domain names from the RosComNadzor registry, someone sends a ‚Äúmessage‚Äù in Morse code</a></li>
<li><a href="../357984/index.html">Russia's largest IT companies have begun to speak out about the actions of Roskomnadzor</a></li>
<li><a href="../357986/index.html">Roskomnadzor explained why "VKontakte", "Yandex" and "Classmates" got into the registry</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>