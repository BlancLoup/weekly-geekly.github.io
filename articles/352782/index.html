<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Debugging multithreaded programs based on FreeRTOS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Debugging multitasking programs is not easy, especially if you come across this for the first time. After the joy of starting the first task or the fi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Debugging multithreaded programs based on FreeRTOS</h1><div class="post__text post__text-html js-mediator-article"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/xp/it/lh/xpitlhkw1ag3kk7oqogzgaifjvq.jpeg" alt="image"></div><br>  Debugging multitasking programs is not easy, especially if you come across this for the first time.  After the joy of starting the first task or the first demo of the program, from infinitely exciting observation of the LEDs, each of which blinks in its own task, there comes a time when you realize that you understand quite a bit (you <s>don‚Äôt</s> understand it <s>all</s> ) what's really going on.  Classics of the genre: ‚ÄúI allocated as many as 3KB to the operating system and launched only 3 tasks with a stack of 128B, and for the fourth reason I don't have enough memory for some reason‚Äù or ‚ÄúHow much stack should I allocate to the task?  How much is enough?  And so much?  Many solve these problems through trial and error, so in this article I decided to combine most of the points that, at present, greatly simplify my life and allow me to more consciously debug multi-threaded programs based on FreeRTOS. <br><br>  This article is intended, first of all, for those who only recently began to learn FreeRTOS, but it is likely that readers well familiar with this operating system will find something interesting for themselves here.  In addition, despite the fact that the article is aimed at developers of embedded software, it will also be interesting for application programmers, since  A lot of words will be said about FreeRTOS as such, regardless of microcontroller romance. <br><br><h4>  <b>In this article I will talk about the following points:</b> </h4><br><ol><li>  <a href="https://habr.com/ru/post/352782/">Setting up OpenOCD to work with FreeRTOS.</a> </li><li>  <a href="https://habr.com/ru/post/352782/">Do not forget to include hooks.</a> </li><li>  <a href="https://habr.com/ru/post/352782/">Static or dynamic memory allocation?</a> </li><li>  <a href="https://habr.com/ru/post/352782/">The tale of the parameter configMINIMAL_STACK_SIZE.</a> </li><li>  <a href="https://habr.com/ru/post/352782/">Monitoring the use of resources.</a> </li></ol><a name="habracut"></a><br><h3><a name="one"></a>  <b>Setting up OpenOCD to work with FreeRTOS</b> </h3><br>  The first thing you may encounter when using FreeRTOS is the absence of any useful information in the Debug window: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/we/zq/qk/wezqqk5e111bb-r5_vulzci2fku.png" alt="image"><br><br>  It looks as sad as possible.  Fortunately, OpenOCD supports FreeRTOS debugging, you just need to configure it correctly: <br><br><ol><li>  Add the file <a href="">FreeRTOS-openocd.c to the project</a> </li><li>  Add flags to the linker (Properties&gt; C / C ++ Build&gt; Settings&gt; Cross ARM C ++ Linker&gt; Miscellaneous&gt; Other linker flags): <br><br><pre><code class="plaintext hljs">-Wl,--undefined=uxTopUsedPriority</code> </pre> </li><li>  Add flags to debugger (Run&gt; Debugs configurations&gt; Debugger&gt; Config options): <br><br><pre> <code class="plaintext hljs">-c "$_TARGETNAME configure -rtos auto"</code> </pre> </li><li>  Uncheck Run&gt; Debugs configurations&gt; Startup&gt; Set breakpoint at main. </li></ol><br>  After these settings, the Debug window will display all existing threads with details, i.e.  we will always have access to information about the state of a particular process and what it is currently busy with: <br><br><img src="https://habrastorage.org/webt/m7/l3/i2/m7l3i2bj0dmlxf_nlirr7iyrsak.png" alt="image"><br><br><h3><a name="two"></a>  <b>Do not forget to include hooks</b> </h3><br>  If our program has fallen into some hard_fault_handler (), then with the settings from the previous paragraph, we can understand from which task we got there.  However, we will not know anything about the reasons for this fall. <br><br><img src="https://habrastorage.org/webt/ge/ns/nk/gensnk3dub2hteonmewym1tgbbc.png" alt="image"><br><br>  For example, in the picture above, we see that the error occurred during the execution of the YellowLedTask task.  The first thing we do is in the debug, we start to walk line by line along the endless loop of the task to clarify the place of the fall.  Suppose we learned that the program breaks down during the execution of the dummy () function (by the <i>way, there is a way to immediately understand what function we have broken, you can read about it <a href="https://www.element14.com/community/message/199113/l/gdb-assisted-debugging-of-hard-faults">in this article</a></i> ).  We begin to check the function body for errors or typos.  An hour passes, the eye begins to twitch, and we are sure that the function is written correctly as firmly as we are sure that the chair on which we sit exists.  So what's the deal?  But the fact is that the error that occurred may not have anything to do with your function, and the problem lies precisely in the operation of the OS.  And here we come to the aid of hooks. <br><br>  The following hooks exist in FreeRTOS: <br><br><pre> <code class="plaintext hljs">/* Hook function related definitions. */ #define configUSE_IDLE_HOOK 0 #define configUSE_TICK_HOOK 0 #define configCHECK_FOR_STACK_OVERFLOW 2 #define configUSE_MALLOC_FAILED_HOOK 1 #define configUSE_DAEMON_TASK_STARTUP_HOOK 0</code> </pre><br>  The most important debugging programs are configCHECK_FOR_STACK_OVERFLOW and configUSE_MALLOC_FAILED_HOOK. <br><br>  The <b>configCHECK_FOR_STACK_OVERFLOW</b> parameter can be enabled with a value of 1 or 2 depending on which stack overflow detection method you want to use.  Read more about it <a href="https://www.freertos.org/Stacks-and-stack-overflow-checking.html">here</a> .  If you enabled this hook, you will need to define a function. <br>  void vApplicationStackOverflowHook (TaskHandle_t xTask, signed char * pcTaskName), which will be executed every time when the stack allocated for a task is not enough for it to work, and most importantly, you will see it in the call stack of a specific task.  Thus, to solve the arisen problem, you only need to increase the size of the stack allocated for the task. <br><br><div class="spoiler">  <b class="spoiler_title">vApplicationStackOverflowHook</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationStackOverflowHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TaskHandle_t xTask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pcTaskName)</span></span></span><span class="hljs-function"> </span></span>{ rtos::CriticalSection::Enter(); { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { portNOP(); } } rtos::CriticalSection::Exit(); }</code> </pre></div></div><br>  Parameter <b>configUSE_MALLOC_FAILED_HOOK is</b> enabled 1, like most configurable FreeRTOS parameters.  If you enabled this hook, you will need to define the void vApplicationMallocFailedHook () function.  This function will be called when there is not enough free space on the heap allocated for FreeRTOS to accommodate the next entity.  And, again, the main thing is that we will see all this in the call stack.  Therefore, all we need to do to solve this problem is to increase the size of the heap allocated for FreeRTOS. <br><br><div class="spoiler">  <b class="spoiler_title">vApplicationallocFailedHook</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationMallocFailedHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ rtos::CriticalSection::Enter(); { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { portNOP(); } } rtos::CriticalSection::Exit(); }</code> </pre></div></div><br>  Now, if we run our program again, then when it crashes in hard_fault_handler () we will see the reason for this crash in the Debug window: <br><br><img src="https://habrastorage.org/webt/uj/h_/lf/ujh_lfbeplkoroijsdwt4xlhmgy.png" alt="image"><br><br>  By the way, if you have ever found an interesting use of configUSE_IDLE_HOOK, configUSE_TICK_HOOK or configUSE_DAEMON_TASK_STARTUP_HOOK, then it would be very interesting to read about it in the comments) <br><br><h3><a name="three"></a>  <b>Static or dynamic memory allocation?</b> </h3><br>  So, we figured out how to monitor stack overflow and heaps in FreeRTOS, and now it's time to talk about the eternal - about memory. <br><br>  In this section we will consider the following FreeRTOS parameters: <br><br><pre> <code class="plaintext hljs">/* Memory allocation related definitions. */ #define configSUPPORT_STATIC_ALLOCATION 0 #define configSUPPORT_DYNAMIC_ALLOCATION 1 #define configTOTAL_HEAP_SIZE 100000 #define configAPPLICATION_ALLOCATED_HEAP 0</code> </pre><br>  In FreeRTOS, memory for creating tasks, semaphores, timers, and other RTOS objects can be allocated both statically (configSUPPORT_STATIC_ALLOCATION) and dynamically (configSUPPORT_DYNAMIC_ALLOCATION).  If you enable dynamic memory allocation, you also need to specify the size of the heap that RTOS can use (configTOTAL_HEAP_SIZE).  In addition, if you want the heap to be located in a particular place, and not automatically located in the memory by the linker, then you need to enable the configAPPLICATION_ALLOCATED_HEAP parameter and define the uint8_t array ucHeap [configTOTAL_HEAP_SIZE].  And do not forget that for dynamic memory allocation, in the folder with the FreeRTOS files you need to add the file heap_1.c, heap_2.c, heap_3.c, heap_4.c or heap_5.c, depending on which version of the memory manager is more suitable for you. <br><br>  In order to estimate how much memory you can give to the FreeRTOS heap, after building the project you need to look at the size of the .bss section.  It displays the amount of RAM needed to store all static variables.  For example, I have a controller with a 128K RAM, I gave FreeRTOS 50KB and after assembling the project the .bss section takes 62304B.  This means that in my project static variables at 12,304 bytes + 50,000 bytes are statically allocated to the OS heap.  It is necessary to remember that a couple of kilobytes must be stored for the main () stack, and as a result we get that a bunch of FreeRTOS can be increased by (128,000 - 62304 - 2000) bytes. <br><br>  The advantages of each approach to memory allocation can be read <a href="https://www.freertos.org/Static_Vs_Dynamic_Memory_Allocation.html">here</a> , and a detailed comparative description of various memory managers is presented <a href="https://www.freertos.org/a00111.html">here</a> . <br><br>  As for my opinion, at this stage of development, I see no point in using static memory allocation, therefore, in the above config, static memory allocation is turned off.  And that's why: <br><br><ol><li>  Why self-allocate a buffer for the stack and the StaticTask_t structure, if the operating system supports as many as 5 different memory managers for every taste and color, which will figure out where, what and how to create, and even tell you if they haven't succeeded?  In particular, for most programs under microcontrollers, <a href="https://www.freertos.org/a00111.html">heap_1.c is</a> more than fully suitable <a href="https://www.freertos.org/a00111.html">.</a> </li><li>  You may need some kind of third-party library, written in a very optimal and capacious manner, but using inside itself malloc (), calloc () or new [] ().  And what to do?  To abandon it in favor of less optimal (this is even if there is a choice)?  Or you can simply use dynamic memory allocation with <a href="https://www.freertos.org/a00111.html">heap_2.c</a> or <a href="https://www.freertos.org/a00111.html">heap_4.c</a> .  The only thing you need to do is override the corresponding functions so that the memory allocation takes place using the FreeRTOS tools in the heap provided to it: <br><br><div class="spoiler">  <b class="spoiler_title">code snippet</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pvPortMalloc(size); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pvPortMalloc(num * size); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vPortFree(ptr); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sz)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pvPortMalloc(sz); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> sz) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pvPortMalloc(sz); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ vPortFree(p); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* p) { vPortFree(p); }</code> </pre></div></div></li></ol><br>  In my projects I use only dynamic memory allocation with heap_4.c, giving the maximum possible memory for the OS heap, and always redefine the functions malloc (), calloc (), new (), etc., regardless of whether they are used at the moment or not. <br><br>  Ratuya for dynamic memory allocation, I, of course, do not deny that there are tasks for which the static memory allocation is an ideal solution (this, you can also discuss in the comments). <br><br><h3><a name="four"></a>  <b>The tale of the parameter configMINIMAL_STACK_SIZE</b> </h3><br>  <b>The value of the parameter configMINIMAL_STACK_SIZE is calculated NOT in bytes, but in words!</b>  <b>Moreover, the word size varies from one OS port to another and it is defined in the file portmacro.h by the portSTACK_TYPE file.</b>  For example, in my case, the word size is 4 bytes.  Thus, the fact that the configMINIMAL_STACK_SIZE parameter in my configuration is 128 means that the minimum stack size for the task is 512 bytes. <br><br>  That's all I wanted to say. <br><br><h3><a name="five"></a>  <b>Resource Usage Monitoring</b> </h3><br>  It would be great to have answers to such questions as: <br><br><ul><li>  Did I adequately select the stack size for the task?  Is it too much?  Maybe too little? </li><li>  And how much CPU time is required to complete my task? </li><li>  And how much does the real heap allocated for the OS use?  The program is already at the limit, or is there another where to turn? </li></ul><br>  In this section I will give an example of how you can implement a simple monitoring of resources, which will help to get unambiguous answers to all the above questions. <br><br>  FreeRTOS has a toolkit that allows you to collect resource usage statistics on the fly, which includes the following parameters: <br><br><pre> <code class="plaintext hljs">#define configGENERATE_RUN_TIME_STATS 0 #define configUSE_TRACE_FACILITY 0 #define configUSE_STATS_FORMATTING_FUNCTIONS 0</code> </pre><br>  I will talk about the value of each parameter a little further, but first we need to create a task, let's call it MonitorTask, an infinite loop of which will collect statistics at config :: MonitorTask :: SLEEP_TIME_MS interval and send it to the terminal. <br><br>  After the task is created, we need to set the <b>configUSE_TRACE_FACILITY</b> parameter to 1, after which the function will be available to us: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">UBaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uxTaskGetSystemState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TaskStatus_t* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pxTaskStatusArray, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> UBaseType_t uxArraySize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pulTotalRunTime)</span></span></span></span></code> </pre><br>  The pxTaskStatusArray should be sizeof (TaskStatus_t) * uxTaskGetNumberOfTasks (), i.e.  it must be large enough to contain information about all existing tasks. <br><br>  By the way, about the structure of TaskStatus_t.  What kind of information regarding each task can we get?  But this: <br><br><div class="spoiler">  <b class="spoiler_title">TaskStatus_t</b> <div class="spoiler_text"><blockquote>  typedef struct xTASK_STATUS <br>  { <br>  / * <br>  structure  * / <br>  TaskHandle_t <b>xHandle</b> ; <br><br>  / * A pointer to the task's name.  This value will be invalid if the task was <br>  deleted since the structure was populated!  * / <br>  const signed char * <b>pcTaskName</b> ; <br><br>  / * A number is unique to the task.  * / <br>  UBaseType_t <b>xTaskNumber</b> ; <br><br>  / * The state was populated.  * / <br>  eTaskState <b>eCurrentState</b> ; <br><br>  / * The priority at which <br>  structure was populated.  * / <br>  UBaseType_t <b>uxCurrentPriority</b> ; <br><br>  / * Current priority priority <br>  has been inherited to avoid unbounded priority inversion when <br>  mutex.  Only valid if configUSE_MUTEXES is defined as 1 in <br>  FreeRTOSConfig.h.  * / <br>  UBaseType_t <b>uxBasePriority</b> ; <br><br>  / * The total run is defined by the run. <br>  time stats clock.  Only valid when configGENERATE_RUN_TIME_STATS is <br>  Defined as 1 in FreeRTOSConfig.h.  * / <br>  unsigned long <b>ulRunTimeCounter</b> ; <br><br>  / * Points to stack area.  * / <br>  StackType_t * <b>pxStackBase</b> ; <br><br>  / * <br>  the task was created.  The closer this task <br>  has come to overflowing its stack.  * / <br>  unsigned short <b>usStackHighWaterMark</b> ; <br>  } TaskStatus_t; <br></blockquote></div></div><br>  So now we are ready to describe the infinite loop of the MonitorTask task.  It might look like this: <br><br><div class="spoiler">  <b class="spoiler_title">MonitorTask function</b> <div class="spoiler_text"><pre> <code class="cpp hljs">TickType_t delay = rtos::Ticks::MsToTicks(config::MonitorTask::SLEEP_TIME_MS); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { UBaseType_t task_count = uxTaskGetNumberOfTasks(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task_count &lt;= config::MonitorTask::MAX_TASKS_MONITOR) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> _total_runtime; TaskStatus_t _buffer[config::MonitorTask::MAX_TASKS_MONITOR]; task_count = uxTaskGetSystemState(_buffer, task_count, &amp;_total_runtime); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> task = <span class="hljs-number"><span class="hljs-number">0</span></span>; task &lt; task_count; task++) { _logger.add_str(DEBG, <span class="hljs-string"><span class="hljs-string">"[DEBG] %20s: %c, %u, %6u, %u"</span></span>, _buffer[task].pcTaskName, _task_state_to_char(_buffer[task].eCurrentState), _buffer[task].uxCurrentPriority, _buffer[task].usStackHighWaterMark, _buffer[task].ulRunTimeCounter); } _logger.add_str(DEBG, <span class="hljs-string"><span class="hljs-string">"[DEBG] Current Heap Free Size: %u"</span></span>, xPortGetFreeHeapSize()); _logger.add_str(DEBG, <span class="hljs-string"><span class="hljs-string">"[DEBG] Minimal Heap Free Size: %u"</span></span>, xPortGetMinimumEverFreeHeapSize()); _logger.add_str(DEBG, <span class="hljs-string"><span class="hljs-string">"[DEBG] Total RunTime: %u ms"</span></span>, _total_runtime); _logger.add_str(DEBG, <span class="hljs-string"><span class="hljs-string">"[DEBG] System Uptime: %u ms\r\n"</span></span>, xTaskGetTickCount() * portTICK_PERIOD_MS); } rtos::Thread::Delay(delay); }</code> </pre></div></div><br>  Suppose that in my program besides MonitorTask, there are a few more tasks with these parameters, where configMINIMAL_STACK_SIZE = 128: <br><br><div class="spoiler">  <b class="spoiler_title">TasksConfig.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> MIN_TASK_STACK_SIZE = configMINIMAL_STACK_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> MIN_TASK_PRIORITY = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> MAX_TASK_PRIORITY = configMAX_PRIORITIES; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoggerTask</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> STACK_SIZE = MIN_TASK_STACK_SIZE * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> NAME[] = <span class="hljs-string"><span class="hljs-string">"Logger Task"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> PRIORITY = MIN_TASK_PRIORITY; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> SLEEP_TIME_MS = <span class="hljs-number"><span class="hljs-number">100</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonitorTask</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> STACK_SIZE = MIN_TASK_STACK_SIZE * <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> NAME[] = <span class="hljs-string"><span class="hljs-string">"Monitor Task"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> PRIORITY = MIN_TASK_PRIORITY; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> SLEEP_TIME_MS = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> MAX_TASKS_MONITOR = <span class="hljs-number"><span class="hljs-number">10</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreenLedTask</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> STACK_SIZE = MIN_TASK_STACK_SIZE * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> NAME[] = <span class="hljs-string"><span class="hljs-string">"Green Led Task"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> PRIORITY = MIN_TASK_PRIORITY; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> SLEEP_TIME_MS = <span class="hljs-number"><span class="hljs-number">1000</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RedLedTask</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> STACK_SIZE = MIN_TASK_STACK_SIZE * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> NAME[] = <span class="hljs-string"><span class="hljs-string">"Red Led Task"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> PRIORITY = MIN_TASK_PRIORITY; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> SLEEP_TIME_MS = <span class="hljs-number"><span class="hljs-number">1000</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">YellowLedTask</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> STACK_SIZE = MIN_TASK_STACK_SIZE * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> NAME[] = <span class="hljs-string"><span class="hljs-string">"Yellow Led Task"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> PRIORITY = MIN_TASK_PRIORITY; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> SLEEP_TIME_MS = <span class="hljs-number"><span class="hljs-number">1000</span></span>; };</code> </pre></div></div><br>  Then, after launching the program, I will see the following information in the terminal: <br><br><img src="https://habrastorage.org/webt/h4/af/ua/h4afuaj6leq-tgioutce-bqh8fg.png" alt="image"><br><br>  Wow, this is pretty good!  So let's see what we see in this log. <br><br><ul><li>  We see the names of all existing tasks.  In addition to the tasks described in the TaskConfig.h file, we also see the IDLE task, which is created automatically when the RTOS scheduler starts (its purpose is written <a href="https://www.freertos.org/RTOS-idle-task.html">here</a> ). </li><li>  We see the status of each task, where B = Blocked, R = Ready, S = Suspended, D = Deleted. </li><li>  We see the priority of each task. </li><li>  We see the minimum amount of free space on the stack, since the creation of the task.  And here it becomes obvious to us that for most of the tasks, we allocated too much stack.  For example, for the LoggerTask task, a stack of 256 words was allocated, but in reality it uses only 40. Thus, a stack of 64 words is sufficient for the functioning of the task.  Here you have the start of optimization. </li><li>  We see the current and minimum (from the start of the scheduler) free space in the heap.  In our simple example, these values ‚Äã‚Äãare equal, but in more complex programs, these two variables are, of course, different.  Thus, we understand that out of 100K given to FreeRTOS, it uses less than 10K, therefore we have more than 90K of free memory in our hands. </li><li>  And finally, we see the amount of time elapsed since the start of the scheduler in milliseconds. </li></ul><br>  Applying this knowledge to the TasksConfig.h file and lowering the value of the configMINIMAL_STACK_SIZE parameter from 128 to 64, we get the following picture: <br><br><img src="https://habrastorage.org/webt/nc/pd/bb/ncpdbbaz_w4s7fsfqo78vpmsuc4.png" alt="image"><br><br>  Super!  Now each task has an optimal supply of free space on the stack: not too large, and not too small.  In addition, we freed up almost 3KB of memory. <br><br>  And now it's time to talk about what we have not yet seen in the resulting log.  We do not see how much CPU time each task uses, i.e.  how much time the task was in running state.  To find out, we need to set the <b>configGENERATE_RUN_TIME_STATS</b> parameter to 1 and add the following definitions to the FreeRTOSConfig.h file: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> configGENERATE_RUN_TIME_STATS == 1 void vConfigureTimerForRunTimeStats(void); unsigned long vGetTimerForRunTimeStats(void); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() vConfigureTimerForRunTimeStats() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> portGET_RUN_TIME_COUNTER_VALUE() vGetTimerForRunTimeStats() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Now we need to start an external timer that counts down the time (preferably in microseconds, because some tasks may take less than a millisecond time, but we still want to know about everything).  Let's add the file of MonitorTask.h with the declaration of two static functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">config_timer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_counter_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre><br>  In the MonitorTask.cpp file, we write their implementation: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MonitorTask::config_timer() { _timer-&gt;disable_counter(); _timer-&gt;set_counter_direction(cm3cpp::tim::Timer::CounterDirection::UP); _timer-&gt;set_alignment(cm3cpp::tim::Timer::Alignment::EDGE); _timer-&gt;set_clock_division(cm3cpp::tim::Timer::ClockDivision::TIMER_CLOCK_MUL_1); _timer-&gt;set_prescaler_value(hw::config::MONITOR_TIMER_PRESQ); _timer-&gt;set_autoreload_value(hw::config::MONITOR_AUTORELOAD); _timer-&gt;enable_counter(); _timer-&gt;set_counter_value(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> MonitorTask::get_counter_value() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> _counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; _counter += _timer-&gt;get_counter_value(); _timer-&gt;set_counter_value(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (_counter); }</code> </pre><br>  And in the main.cpp file we will write the implementation of the functions vConfigureTimerForRunTimeStats () and vGetTimerForRunTimeStats (), which we declared in FreeRTOSConfig.h: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> configGENERATE_RUN_TIME_STATS == 1 void vConfigureTimerForRunTimeStats(void) { tasks::MonitorTask::config_timer(); } unsigned long vGetTimerForRunTimeStats(void) { return (tasks::MonitorTask::get_counter_value()); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Now, after starting the program, our log will be like this: <br><br><img src="https://habrastorage.org/webt/qo/sj/_n/qosj_nncywicxeqwp_yyghdaxeg.png" alt="image"><br><br>  Comparing the values ‚Äã‚Äãof Total RunTime and System Uptime, we can conclude that only a third of the time our program is busy performing tasks, and 98% of the time is spent on IDLE, and 2% on all other tasks.  What is our program doing the remaining two thirds of the time?  This time is spent on the work of the scheduler and switching between all tasks.  Sad but true.  Of course, there are ways to optimize this time, but this is a topic for the next article. <br><br>  As for the <b>configUSE_STATS_FORMATTING_FUNCTIONS</b> parameter, it is very minor, most often it is used in various demo programs provided by the FreeRTOS developers.  Its essence lies in the fact that it includes two functions: <br><br><pre> <code class="plaintext hljs">void vTaskList(char* pcWriteBuffer); void vTaskGetRunTimeStats(char* pcWriteBuffer);</code> </pre><br>  Both of these functions are NOT part of FreeRTOS.  Inside themselves, they call the same uxTaskGetSystemState function that we used above, and add already formatted data to pcWriteBuffer.  The developers themselves do not recommend using these functions (but, of course, they do not prohibit them), pointing out that their task is rather a demonstration, and it is obvious that they can use the uxTaskGetSystemState function directly, as we did. <br><br>  That's all.  As always, I hope that this article was useful and informative) <br><br>  To build and debug the <a href="https://github.com/mamilla11/monitor">demo of the project</a> described in the article, the Eclipse + GNU MCU Eclipse bundle (formerly GNU ARM Eclipse) + OpenOCD was used. <br><br>  <a href="https://geektimes.ru/company/thirdpin/">Third Pin Company Blog</a> </div><p>Source: <a href="https://habr.com/ru/post/352782/">https://habr.com/ru/post/352782/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352770/index.html">Kubernetes meetup - presentation and webcast</a></li>
<li><a href="../352772/index.html">Announcement of Moscow Spark # 4</a></li>
<li><a href="../352774/index.html">Is there any powder in the old dog? Hackathon Radio Canada 2018 (Part One, We Make a Team)</a></li>
<li><a href="../352776/index.html">What's new in LLVM</a></li>
<li><a href="../352778/index.html">Does the manager need to be able to program</a></li>
<li><a href="../352784/index.html">ESET: Turla Mosquito backdoor used in Eastern Europe</a></li>
<li><a href="../352786/index.html">How to use Azure for free (life hacking for students)</a></li>
<li><a href="../352790/index.html">Public Key Infrastructure: Certification Center based on the OpenSSL utility, SQLite3 and Tcl / Tk</a></li>
<li><a href="../352792/index.html">Conference DEFCON 22. ‚ÄúTraveling on the dark side of the Internet. Introduction to Tor, Darknet and Bitcoin ¬ª</a></li>
<li><a href="../352794/index.html">Generative adversarial networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>