<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Monitoring service connectivity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword  Our main project is the optimization of advertising in social networks and mobile applications. Each banner display is the result of interac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Monitoring service connectivity</h1><div class="post__text post__text-html js-mediator-article"><h4>  Foreword </h4>  Our main project is the optimization of advertising in social networks and mobile applications.  Each banner display is the result of interaction of a rather large number of services located on different servers, sometimes in different data centers.  Naturally, there is the task of monitoring the connection between servers and services.  About the form in which this task stands, which solutions are suitable, which ones are not suitable - this is further discussed. <br><br><a name="habracut"></a><h4>  Network structure: frontends, backends, services </h4><br><br>  Like many other web applications, ours consists of frontends (FE), backends (BE), and services.  The frontend accepts the connection from the client and sends it to the backend, which calls on services for help and responds to the client.  In our case, FE is almost always - nginx, BE - tomcat.  This architecture is fairly standard, non-standards begin when you need to decide how to route requests between frontends, backends, and services. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In our case, the routing is controlled by the CMDB configuration database.  This database reflects both the physical network device (data centers, physical servers, ...) and the application logic device (which services and interfaces are located in which containers on which physical servers, splitting FE and BE into clusters, which servers can serve traffic , and which - no, etc.) <br><br>  CMDB information can be used in two ways.  The first - conditionally ‚Äúoffline‚Äù, is that, according to the crown, every few minutes, the script selects the necessary information from the CMDB and builds up-to-date configs, for example, for nginx, including the necessary upstream ones.  How the second method of accessing CMDB works is in the next section. <br><br><br><h4>  CMDB, short names, search service by name </h4><br><br>  The second way to use CMDB can be designated as online, because it reflects changes in the CMDB not periodically, but immediately (taking into account short-term caches on top of the CMDB). This method is mainly used by backends to find the services they need, to connect services between is based on the use of DNS.  The easiest way to understand how this is done from the image with explanations: <img src="http://dl.dropbox.com/u/105149544/resolving.png" alt="image"><ol><li>  The back-end be5 located on host58 needs to connect to the database, the name of the database service is db1 (short DNS name) </li><li>  From the name db1, from the data in resolv.conf is built the name db1.be5.host58.example.com.  Resolver sends a request to PowerDNS </li><li>  The pDNS plugin from db1.be5.host58 concludes that the be5 container located on host58 is looking for the db1 service </li><li>  CMDB data is used to issue a list of IP working containers that provide db1 service closest to host58 </li><li>  The service on be5 selects an arbitrary address from the received list and calls the db1 service. </li></ol><br>  Summarizing the intermediate result: front-ends, backends, services find each other using a single source of information CMDB.  There are two methods for obtaining addresses: through the construction of configs and through queries to the DNS. <br><br><h4>  The physical structure of the network, communication problems </h4><br><img src="http://dl.dropbox.com/u/105149544/phys.png" alt="image">  We rent servers from hosting providers.  The structure in different data centers is the same - a set of physical hosts running containers with frontends, backends or services.  A request from any component can go to any other host and even to another data center, if for some reason the necessary service is only in another data center.  In total, we are located in six data centers, in each data center there are about a hundred or two servers, on each server up to four or five containers.  In total, we get about a thousand hosts and about five thousand containers. <br><br>  Since the entire network structure is not in our hands, we cannot monitor links, switches, channel congestion, etc.  For the same reason (the network is not in our hands) we use ipsec for communication between servers.  Ipsec sometimes gives surprises in the form of loss of communication between two hosts (or only between containers).  Similar surprises are presented by the provider infrastructure.  In any case, all that we can detect is the fact that one host (or its containers) is unavailable from some set of hosts or containers.  Moreover, the fact of unavailability is not always manifested at the application level: services are duplicated, the request can be satisfied from an available server.  Also, we cannot monitor such problems using pings from the central server - it simply will not notice them. <br><br>  At a time when the number of our servers was limited to dozens, we did not particularly bother, we checked connectivity by pings sent from each host to everything else and tracking losses.  As the number of hosts approaches one thousand, this simple method stops working: <ol><li>  ping sending time becomes too long, or: </li><li>  network consumption for monitoring becomes noticeable (a standard ping sent from one server to a thousand servers will take about a megabit of bandwidth within a second, if the whole thousand servers do this then this is already too much) </li><li>  CPU consumption on the host for processing and analysis of "who sees whom or does not see" becomes large </li><li>  connectivity between containers is not monitored ‚Äî we don‚Äôt see ipsec problems or root routing problems leading to problems at the container level </li></ol><br><br>  In order to solve all these problems with one blow, we need to monitor not ‚Äúeverything‚Äù, but only the connection between the components that appeal to each other.  So the first task that arises here is how to find out which components the component is accessing.  Only developers know this exactly, but they cannot always provide up-to-date information, therefore, it makes no sense to ask them about it, or ask to keep some register, no - in reality it does not work <br><br>  Here we come to the aid of knowing how services find each other: those components that do not use rezolving, but calculate partners through a direct appeal to the CMDB, we will ask to save the result of this calculation not only in our configs, but also in some public place in the agreed format.  And for services that use CMDB through rezolving - we will parse the PowerDNS logs and find out that PowerDNS responded to the request.  In this way, we will be able to collect a complete list of which IP specific components can access. <h4>  Monitoring, tests </h4><br><br>  We collect a complete list of current connections between containers in one place, for the task of monitoring the link, this one place plays the role of a ‚Äúserver‚Äù.  All information is presented on the server as a dictionary: <br><table><tbody><tr><th>  container </th><th>  list of links </th></tr><tr><td>  be5.host58 </td><td>  192.168.5.1 192.168.5.2 10.1.2.3 10.2.3.4 </td></tr><tr><td>  be8.host1000 </td><td>  10.0.0.1 10.0.100.5 </td></tr></tbody></table><br><br>  The server makes this information available through the REST interface. <br><br>  The second half of the monitoring is located in each container - this part is called the ‚Äúagent‚Äù.  The agent does not know about the container in which it is located; nothing but the name stores any current state.  Every two minutes, the agent contacts the server for a list of his connections and the server responds with a string from the table above.  Usually the length of the list of IP addresses does not exceed ten.  The agent sends pings to these addresses.  The result, containing a list of problems (if any), is reported back to the server via POST.  Since all operations performed by the server for agents are very simple, it can easily serve a large number of them - for this, it just needs to have time to accept the GET, POST request and perform a search in the dictionary or add data to the dictionary several dozen times per second. <br><br>  In addition, since the agent still runs every couple of minutes - it makes sense to collect some more current performance indicators of the component and transfer them to the server.  We monitor a lot of things through the munin, but the munin gives a fairly large delay in the presentation of data, and here we can get something straight in the ‚Äúreal time‚Äù mode.  Therefore, the agent also collects indicators such as LA in the component, the rate of requests to nginx, if there is one, and the number of nginx errors broken down by code. <br><br><img src="http://dl.dropbox.com/u/105149544/ipsecmon2server.png" alt="image"><br><h4>  Monitoring, presentation and analysis of results </h4><br>  As mentioned above, agents send the results of connectivity tests to the server (along with some other data, the list of which may be different for different agents).  Here is some information we have about: <br><br><table><tbody><tr><td>  name </td><td>  disconnects </td><td>  DC </td><td>  role </td><td>  load </td><td>  nginxErrRate </td><td>  connectivity </td><td>  nginxAccessRate </td></tr><tr><td>  be1.host123 </td><td>  0 </td><td>  Tx </td><td>  be </td><td>  0.21 </td><td>  15.55 </td><td></td><td>  31.38 </td></tr><tr><td>  be1.host122 </td><td>  0 </td><td>  Tx </td><td>  be </td><td>  0.11 | </td><td>  18.28 </td><td></td><td>  34.61 </td></tr><tr><td>  fo1.host161 </td><td>  2 </td><td>  VA </td><td>  fo </td><td>  0.02 </td><td>  0.11 </td><td>  10.1.1.4,10.1.2.4 </td><td>  14.1 </td></tr><tr><td>  fo1.host160 </td><td>  0 </td><td>  VA </td><td>  fo </td><td>  0.0 </td><td>  0.00 </td><td></td><td>  0.0 </td></tr><tr><td>  fo1.host162 </td><td>  2 </td><td>  VA </td><td>  fo </td><td>  0.01 </td><td>  0.18 </td><td>  10.2.1.4,10.2.4.3 </td><td>  17.56 </td></tr></tbody></table><br><br>  Some of the information in this table was sent by agents (disconnects, load, nginx ...), part (DC, role) - filled in from the CMDB.  Since the data in this table is very short-lived and the number of rows in it is on the order of thousands, it makes sense to arrange it as part of the sqlite database of type ": memory:". <br><br>  The main reason for which all this garden was fostered - monitoring communication problems.  Therefore, in the first place, we are only interested in the disconnects and connectivity columns ‚Äî the number of dangling connections and the corresponding list of containers, but in general we can get various interesting facts from such a table using simple SQL queries.  ‚ÄúSELECT name FROM data ORDER by disconnects DESC‚Äù - gives us a list of servers with communication problems that we must solve first.  The results of this query, if they are not empty, are sent to Nagios as an alert with an attached list of problem servers.  The duty engineer, after receiving information about the problem, takes further measures - removes traffic from problem servers, creates a ticket in the system of the hosting provider, etc. <br><br>  We sometimes have a situation in which the overall level of errors in the system begins to grow.  This can occur for various reasons, related both to our operational problems and to external causes.  An abstract example - routing between data centers has changed, as a result, cross-data center requests no longer fit into the time limits, which leads to an increase of 504 errors in nginx.  The query ‚ÄúSELECT SUM (nginxAccessRate), SUM (nginxErrorRate), dataCenter FROM data group by ORDER BY SUM (nginxAccessRate)‚Äù gives us a general picture of errors broken down by data centers.  This overall picture can then be detailed using queries that work only with 504 errors, etc. <br><br>  Another example - let's say we want to find out if there is a correlation between server load and the number of errors that occur on it.  The query "SELECT load, nginxErrorRate FROM data WHERE role =" be1 "ORDER by nginxErrorRate DESC" allows us to plot or analytically detect such a dependency. <br><br>  The enumeration of such examples can be continued.  What is important here is that all this information is quite relevant, in contrast to the munin graphs, the delay in data presentation is about two minutes, the methods for analyzing the data are incomparably more and it is easier to execute them. <br><br>  This is not a solution replacing bundles such as statsd + graphite, if only because there is no history management, the ability to quickly get different cuts of system behavior here is just a bonus to analyzing connectivity between services. <br><br><h4>  Conclusion </h4><br><br>  The system described today monitors the connection for about a thousand containers.  No performance issues have yet been identified.  On the other hand, the sensitivity to short-term interruptions of communication, channel overload, or increased time to ping was found to be too high.  With this we are fighting the sensitivity setting of the Nagios alerts. </div><p>Source: <a href="https://habr.com/ru/post/151435/">https://habr.com/ru/post/151435/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../151430/index.html">Wi-Fi in the metro: look at the cable in the wall of the tunnel</a></li>
<li><a href="../151431/index.html">Google Pluto Switch</a></li>
<li><a href="../151432/index.html">Installing Kernel Tube Video Sharing 2.4.3 on Ubuntu 12.04</a></li>
<li><a href="../151433/index.html">‚ÄúAndroid for programmers: create applications‚Äù - a new book from Daytelov</a></li>
<li><a href="../151434/index.html">Ozon.ru: The Russian answer to Amazon is ready for the clouds, but the Kindle is too tough</a></li>
<li><a href="../151436/index.html">How is going to the new iPhone5 at Foxconn factory</a></li>
<li><a href="../151438/index.html">Podcast Appprofessionals - Promotion of mobile applications: one of the most difficult issues of the industry</a></li>
<li><a href="../151439/index.html">Badoo office</a></li>
<li><a href="../15144/index.html">RightLearn - closed beta test</a></li>
<li><a href="../151440/index.html">Lecture: PMbok is suitable for climbing Everest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>