<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>(Not) for protothreads lovers dedicated to: High-level functions for working with 1-Wire</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is understood that we will write the firmware under the "bare iron". Otherwise, the use of protothreads does not make sense, because multitasking s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>(Not) for protothreads lovers dedicated to: High-level functions for working with 1-Wire</h1><div class="post__text post__text-html js-mediator-article">  It is understood that we will write the firmware under the "bare iron".  Otherwise, the use of protothreads does not make sense, because  multitasking should be provided by OS.  It is also understood that we need to implement several more or less complex algorithms associated with input-output operations.  Well, as always in microcontrollers, the obvious requirements for saving RAM and power consumption. <br><a name="habracut"></a><br>  As an example, consider the task of servicing devices on a 1-Wire bus.  You can see the implementation of asynchronous primitives for it in my previous articles <a href="https://habr.com/ru/post/326320/">here</a> and <a href="https://habr.com/ru/post/326320/">here</a> . <br><br>  For the PnP implementation, it is necessary that the program can independently determine the characteristics of the bus, such as the maximum allowable exchange rate, the list of identifiers of the devices currently connected and the conditions for their power supply. <br>  The maximum permissible exchange rate, we define in order to subsequently communicate with high-speed devices as quickly as possible.  At the same time, slow devices will not ‚Äúnotice‚Äù this exchange and will not interfere with us. <br><br>  Power supply conditions must be known in order to (if necessary) after issuing a command to perform measurements (or programming an EEPROM) enable active pullup mode.  Otherwise, when using parasite power, we get an error when trying to read the measurement result (well, or you will have to install low-impedance pull-up resistors, which is probably not a beautiful solution). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Well, the list of identifiers of currently connected devices is simply vital for us.  Otherwise, how are we going to contact them? <br><br><a name="probe"></a>  Tire performance determination algorithm: <br><ol><li>  We will try to perform the RESET procedure in OVERDRIVE mode.  If a PRESENCE was detected at the same time, then at least some of the connected devices can operate at high speed.  In this case, go to paragraph 3. </li><li>  We will try to perform the RESET procedure in normal mode.  If a PRESENCE was detected at the same time, then there is at least one connected device on the 1-Wire bus and we proceed to step 3.  Otherwise, there are no devices currently connected to the bus. </li><li>  We send the ‚ÄúAddress all devices‚Äù command to the bus and then the ‚ÄúRead power conditions‚Äù command.  In case at least one of the connected devices uses the parasite power mode, <br>  set the appropriate flag. </li></ol><br>  But the algorithm for determining the identifiers of connected devices is quite cumbersome.  Its synchronous implementation is given in <a href="https://habr.com/ru/post/326320/">APPLICATION NOTE 187</a> , I just redid it into an asynchronous one. <br><br>  At all stages of the algorithms, it is advisable to track errors that may occur due to interference on the 1-Wire bus.  Depending on the point of error, you can either automatically try to repeat the operation being performed, or return a negative completion status. <br><br>  Further, it is assumed that the reader has minimal knowledge of <a href="https://habr.com/ru/post/326320/">protothreads</a> .  It‚Äôs hard to understand English texts, maybe, for starters, read <a href="https://habr.com/ru/post/326320/">here</a> and <a href="https://habr.com/ru/post/326320/">here</a> . <br><br>  Under the spoiler, an example of calling the procedures for determining bus parameters and detecting connected devices from the main program. <br><br><div class="spoiler">  <b class="spoiler_title">Main program</b> <div class="spoiler_text"><pre><code class="hljs swift"><span class="hljs-type"><span class="hljs-type">PT_INIT</span></span>(&amp;ptSearchContext.pt); <span class="hljs-comment"><span class="hljs-comment">/*          */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-type"><span class="hljs-type">PT_SCHEDULE</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = ptOneWireProbeBus(&amp;ptSearchContext.pt, &amp;nested))) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-type"><span class="hljs-type">PT_WAITING</span></span> == <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*    ,   -  */</span></span> waitComplete(); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> ptOneWireInitWalkROM(&amp;ptSearchContext); <span class="hljs-comment"><span class="hljs-comment">/*      1-Wire  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-type"><span class="hljs-type">PT_SCHEDULE</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = ptOneWireWalkROM(&amp;ptSearchContext))) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-type"><span class="hljs-type">PT_WAITING</span></span> == <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*    ,   -  */</span></span> waitComplete(); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*   1-Wire   . *  S/N    ptSearchContext.romid */</span></span> __no_operation(); } <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> __no_operation();</code> </pre> <br></div></div><br>  This is a demo.  In a real program, instead of calling the waitComplete () function, we can switch to serving other protothreads (and if not, then go into low-power mode). <br><br><div class="spoiler">  <b class="spoiler_title">Macros used in implementation</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE() \ drv_onewire_context.overdrive #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PRESENCE_DETECTED() \ drv_onewire_context.presence #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PARASITE_POWER \ drv_onewire_context.parasite #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATUS \ drv_onewire_context.status #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PT_WAIT_IO_COMPLETE() \ PT_WAIT_WHILE(TASK_CONTEXT, ONEWIRE_STATUS_PROGRESS == (dummy = drvOneWireStatus())) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IO_SUCCESS() \ (ONEWIRE_STATUS_COMPLETE == dummy) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PT_TX_BITS(_v,_n) do { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(drvOneWireTxBits((_v),(_n))) { \ PT_WAIT_IO_COMPLETE(); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { \ dummy = ONEWIRE_STATUS_ERROR; } } while(0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PT_TX_BYTE(_v) \ PT_TX_BITS((_v), 8) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PT_RX_BITS(_n) \ PT_TX_BITS(~0,(_n)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PT_TX_BYTE_CONST(_v) do { \ PT_TX_BYTE((_v)); \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(!IO_SUCCESS() || ((_v) != drvOneWireRxBits(8))) { \ STATUS = ONEWIRE_STATUS_ERROR; } } while(0)</span></span></code> </pre><br></div></div><br>  Short description: <br><br>  PT_WAIT_IO_COMPLETE () <br>  Waiting for I / O completion.  Designed for use only inside the protothread. <br><br>  PT_TX_BITS (_v, _n) <br>  Passing _n bits from _v to the bus while waiting for an I / O operation to complete.  Designed for use only inside the protothread. <br><br>  PT_TX_BYTE (_v) <br>  Sending a _v byte to the bus, waiting for an I / O operation to complete.  Designed for use only inside the protothread. <br><br>  PT_RX_BITS (_n) <br>  Receiving the _n bit with waiting for completion of an I / O operation.  Designed for use only inside the protothread. <br><br>  PT_TX_BYTE_CONST (_v) <br>  Sending a command byte (constant) to the bus with checking the absence of distortions of the transmitted data and waiting for the completion of an I / O operation.  Designed for use only inside the protothread. <br><br>  It should be noted that ‚Äúwaiting for completion of input-output‚Äù in this case means not a dead loop with checking of any condition, but an interruption of the current protothread with the status PT_WAITING.  This allows you to perform other protothreads with periodic checking of the current until the end of the activated I / O operation. <br><br><div class="spoiler">  <b class="spoiler_title">Passing the addressing command of all devices</b> <div class="spoiler_text"><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">PT_THREAD</span></span>(ptOneWireTargetAll(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pt</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_pt</span></span></span><span class="hljs-class">)) </span></span>{ uint8_t dummy; <span class="hljs-type"><span class="hljs-type">PT_BEGIN</span></span>(<span class="hljs-type"><span class="hljs-type">TASK_CONTEXT</span></span>); <span class="hljs-type"><span class="hljs-type">PT_TX_BYTE_CONST</span></span>(<span class="hljs-type"><span class="hljs-type">OP_SKIP_ROM</span></span>); <span class="hljs-type"><span class="hljs-type">PT_END</span></span>(<span class="hljs-type"><span class="hljs-type">TASK_CONTEXT</span></span>); }</code> </pre><br></div></div><br>  The addressing operation of all devices can be used with other 1-Wire bus commands, so it was framed as a separate protothreads. <br><br><div class="spoiler">  <b class="spoiler_title">The procedure for determining the parameters of the bus</b> <div class="spoiler_text"><pre> <code class="hljs cs">PT_THREAD(ptOneWireProbeBus(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> pt * _pt, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> pt * _nested)) { uint8_t dummy; PT_BEGIN(TASK_CONTEXT); <span class="hljs-comment"><span class="hljs-comment">/* Parasite power not detected */</span></span> PARASITE_POWER = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Try overdrive procedure first */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(drvOneWireReset(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { PT_WAIT_IO_COMPLETE(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!IO_SUCCESS() || !PRESENCE_DETECTED()) { <span class="hljs-comment"><span class="hljs-comment">/* Overdrive RESET procedure failed */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(drvOneWireReset(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { PT_WAIT_IO_COMPLETE(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!IO_SUCCESS() || !PRESENCE_DETECTED()) { <span class="hljs-comment"><span class="hljs-comment">/* No devices on the bus */</span></span> PT_EXIT(TASK_CONTEXT); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Hardware BUSY */</span></span> PT_EXIT(TASK_CONTEXT); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Hardware BUSY */</span></span> PT_EXIT(TASK_CONTEXT); } PT_SPAWN(TASK_CONTEXT, _nested, ptOneWireTargetAll(_nested)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ONEWIRE_STATUS_COMPLETE == STATUS) { PT_TX_BYTE_CONST(OP_READ_POWER_SUPPLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IO_SUCCESS()) { <span class="hljs-comment"><span class="hljs-comment">/* Read one bit after command */</span></span> PT_RX_BITS(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IO_SUCCESS()) { <span class="hljs-comment"><span class="hljs-comment">/* Fetch bit value */</span></span> int16_t <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = drvOneWireRxBits(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Rx bit decode failed */</span></span> STATUS = ONEWIRE_STATUS_ERROR; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* If any device sent "0" then it used parasite power */</span></span> PARASITE_POWER = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } } PT_END(TASK_CONTEXT); }</code> </pre><br></div></div><br>  The code is quite simple and implements the <a href="https://habr.com/ru/post/326320/">algorithm</a> described above. <br><br><div class="spoiler">  <b class="spoiler_title">The procedure for determining the identifiers of connected devices</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">PT_THREAD(ptOneWireWalkROM(pt_onewire_search_context_t * _ctx)) { PT_BEGIN(TASK_CONTEXT); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!LAST_DEVICE_FLAG) { int16_t dummy; <span class="hljs-comment"><span class="hljs-comment">/* initialize for search */</span></span> ID_BIT_NUMBER = <span class="hljs-number"><span class="hljs-number">1</span></span>; LAST_ZERO = <span class="hljs-number"><span class="hljs-number">0</span></span>; ROM_BYTE_NUMBER = <span class="hljs-number"><span class="hljs-number">0</span></span>; ROM_BYTE_MASK = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 1-Wire reset (dependent on OVERDRIVE flag) */</span></span> PT_ONEWIRE_RESET(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!IO_SUCCESS() || !PRESENCE_DETECTED()) { // <span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">search</span></span> LAST_DISCREPANCY = <span class="hljs-number"><span class="hljs-number">0</span></span>; LAST_DEVICE_FLAG = <span class="hljs-number"><span class="hljs-number">0</span></span>; LAST_FAMILY_DISCREPANCY = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* If presence not detected then no devices on the bus */</span></span> PT_EXIT(TASK_CONTEXT); } <span class="hljs-comment"><span class="hljs-comment">/* issue the search command */</span></span> PT_TX_BYTE(OP_SEARCH_ROM); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!IO_SUCCESS() || (OP_SEARCH_ROM != drvOneWireRxBits(<span class="hljs-number"><span class="hljs-number">8</span></span>))) { <span class="hljs-comment"><span class="hljs-comment">/* Send command error, repeat procedure from RESET point */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Other solution is abort search procedure */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } // <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">search</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { // <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> a <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> its complement PT_RX_BITS(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!IO_SUCCESS()) { <span class="hljs-comment"><span class="hljs-comment">/* Error while receiving 2 bits. * As ID_BIT_NUMBER less than 65 search procedure * resumed from state such as original task entry. */</span></span> break; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((RX_VALUE = drvOneWireRxBits(<span class="hljs-number"><span class="hljs-number">2</span></span>)) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { __no_operation(); break; } uint8_t id_bit = (RX_VALUE &amp; <span class="hljs-number"><span class="hljs-number">0x01</span></span>) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; uint8_t cmp_id_bit = (RX_VALUE &amp; <span class="hljs-number"><span class="hljs-number">0x02</span></span>) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; uint8_t search_direction; <span class="hljs-comment"><span class="hljs-comment">/* check for no devices on 1-wire */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((id_bit == <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp;&amp; (cmp_id_bit == <span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">/* Same bit values equ "1" indicate no devices on the bus */</span></span> break; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* all devices coupled have 0 or 1 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id_bit != cmp_id_bit) { search_direction = id_bit; <span class="hljs-comment"><span class="hljs-comment">/* bit write value for search */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* if this discrepancy if before the LAST_DISCREPANCY on a previous next then pick the same as last time */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ID_BIT_NUMBER &lt; LAST_DISCREPANCY) { search_direction = (ROMID_BYTE_REF(ROM_BYTE_NUMBER) &amp; ROM_BYTE_MASK) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* if equal to last pick 1, if not then pick 0 */</span></span> search_direction = (ID_BIT_NUMBER == LAST_DISCREPANCY) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* if 0 was picked then record its position in LAST_ZERO */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (search_direction == <span class="hljs-number"><span class="hljs-number">0</span></span>) { LAST_ZERO = ID_BIT_NUMBER; } <span class="hljs-comment"><span class="hljs-comment">/* check for LAST_FAMILY_DISCREPANCY in family */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LAST_ZERO &lt; <span class="hljs-number"><span class="hljs-number">9</span></span>) { LAST_FAMILY_DISCREPANCY = LAST_ZERO; } } } <span class="hljs-comment"><span class="hljs-comment">/* set or clear the bit in the ROM byte ROM_BYTE_NUMBER with mask rom_byte_mask */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (search_direction == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ROMID_BYTE_REF(ROM_BYTE_NUMBER) |= ROM_BYTE_MASK; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ROMID_BYTE_REF(ROM_BYTE_NUMBER) &amp;= ~ROM_BYTE_MASK; } <span class="hljs-comment"><span class="hljs-comment">/* serial number search direction write bit */</span></span> PT_TX_BITS(search_direction, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* search_direction not stored, therefore we can't check echo */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!IO_SUCCESS()) { <span class="hljs-comment"><span class="hljs-comment">/* Sending direction failed. * As ID_BIT_NUMBER less than 65 search procedure * resumed from state such as original task entry. */</span></span> break; } <span class="hljs-comment"><span class="hljs-comment">/* increment the byte counter ID_BIT_NUMBER and shift the mask rom_byte_mask */</span></span> ID_BIT_NUMBER++; ROM_BYTE_MASK &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* if the mask is 0 then go to new SerialNum byte ROM_BYTE_NUMBER and reset mask */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ROM_BYTE_MASK == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ROM_BYTE_NUMBER++; ROM_BYTE_MASK = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(ROM_BYTE_NUMBER &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* loop until through all ROM bytes 0-7 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* if the search was successful then */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!(ID_BIT_NUMBER &lt; <span class="hljs-number"><span class="hljs-number">65</span></span>)) { uint8_t i; <span class="hljs-comment"><span class="hljs-comment">/* Calculate CRC */</span></span> uint8_t crc = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>;i &lt; sizeof(ROMID);i++) { crc = modOneWireUpdateCRC(crc, ROMID_BYTE_REF(i)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(crc) { <span class="hljs-comment"><span class="hljs-comment">/* CRC error. * Repeat procedure from original point */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* search successful so set LAST_DISCREPANCY and LAST_DEVICE_FLAG */</span></span> LAST_DISCREPANCY = LAST_ZERO; // <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> last device <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LAST_DISCREPANCY == <span class="hljs-number"><span class="hljs-number">0</span></span>) { LAST_DEVICE_FLAG = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Next device detection complete */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* I/O error. * Retry procedure from original point */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ROMID.id.familyCode) { <span class="hljs-comment"><span class="hljs-comment">/* familyCode     0! */</span></span> break; } <span class="hljs-comment"><span class="hljs-comment">/* Return detected device S/N */</span></span> PT_YIELD(TASK_CONTEXT); } <span class="hljs-comment"><span class="hljs-comment">/* Reset state for next scan loop (if need) */</span></span> ptOneWireInitWalkROM(CONTEXT); PT_END(TASK_CONTEXT); } <span class="hljs-comment"><span class="hljs-comment">/* * Initialize device search procedure */</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> ptOneWireInitWalkROM(pt_onewire_search_context_t * _ctx) { <span class="hljs-comment"><span class="hljs-comment">/* Prepare ptOneWireWalkROM() for first call */</span></span> LAST_DISCREPANCY = <span class="hljs-number"><span class="hljs-number">0</span></span>; LAST_DEVICE_FLAG = <span class="hljs-number"><span class="hljs-number">0</span></span>; LAST_FAMILY_DISCREPANCY = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Initialize protothreads data */</span></span> PT_INIT(TASK_CONTEXT); }</code> </pre><br></div></div><br>  I just took the synchronous implementation from <a href="https://habr.com/ru/post/326320/">Maxim</a> and replaced the calls to the I / O procedures with asynchronous macros.  All of this, along with running the test cases, took me about half an hour.  I wonder how much would have to mess around without using the protothreads wrapper? <br><br>  The complete project source code for the STM8L-Discovery board is available on <a href="https://habr.com/ru/post/326320/">github</a> .  To create an assembly with the above examples, it is necessary to define the HIGH_LEVEL symbol when compiling. <br><br>  Bibliography: <br><br><ol><li><a name="code"></a>  <a href="https://github.com/vedga/1-wire">Project code on github</a> </li><li><a name="stm"></a>  <a href="https://habrahabr.ru/post/326114/">Primitives for implementing 1-Wire master using PWM and ICP for STM8L and STM32</a> </li><li><a name="avr"></a>  <a href="https://habrahabr.ru/post/322710/">Primitives for implementing 1-Wire master using PWM and ICP on AVR AtMega microcontrollers</a> </li><li><a name="dunkels"></a>  <a href="http://dunkels.com/adam/pt/index.html">Protothreads from Adam Dunkels</a> </li><li><a name="continuation"></a>  Habr from <a href="https://habrahabr.ru/users/ldir/" class="user_link">ldir</a> <a href="https://habrahabr.ru/post/143318/">Multitasking in microcontrollers based on the sequels</a> </li><li><a name="multitask"></a>  Habr from <a href="https://habrahabr.ru/users/lifev/" class="user_link">LifeV</a> <a href="https://habrahabr.ru/company/embox/blog/244361/">Protothread and cooperative multitasking</a> </li><li><a name="apn_187"></a>  <a href="https://www.maximintegrated.com/en/app-notes/index.mvp/id/187">APPLICATION NOTE 187. 1-Wire Search Algorithm</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/326320/">https://habr.com/ru/post/326320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326308/index.html">Google released technical data and TPU appointment</a></li>
<li><a href="../326312/index.html">How to write a chat bot for vk.com in 3 minutes</a></li>
<li><a href="../326314/index.html">Delta has lost $ 150 million due to the desire of the manufacturer of emergency generators for the data center</a></li>
<li><a href="../326316/index.html">Useful Plugins and Security Tips for WordPress</a></li>
<li><a href="../326318/index.html">In the Canadian airport discovered devices to spy on smartphones</a></li>
<li><a href="../326322/index.html">5 stages of implementation of a CRM system. Fascinating about the important</a></li>
<li><a href="../326324/index.html">Implement a custom UI element for timing. Part 1</a></li>
<li><a href="../326328/index.html">Bash scripts, part 3: command line options and keys</a></li>
<li><a href="../326330/index.html">First steps to the web SCADA-system. We animate the mnemonic in the browser using AngularJS</a></li>
<li><a href="../326332/index.html">Results of the first round of the Russian Code Cup 2017</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>