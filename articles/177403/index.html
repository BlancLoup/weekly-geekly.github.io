<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>I'm writing a toy OS (about the scheduler)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue to blog about the development of a toy OS. 

 In the last post I wrote about how to achieve the ability to implement interrupt handlers on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>I'm writing a toy OS (about the scheduler)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/1d9/424/cf4/1d9424cf4e9c4467f7a018ea821f694f.png"><br>  I continue to blog about the development of a toy OS. <br><br>  In the <a href="http://habrahabr.ru/post/175749/">last post</a> I wrote about how to achieve the ability to implement interrupt handlers on C.  Now, using previously written macros, you can implement a simple SMP scheduler.  It will provide the minimum possible functionality, on the basis of which in the future it will be necessary to build various add-ins, in particular, synchronization primitives (for example, a mutex).  Again, a beautiful modular structure does not contribute to high performance, but beauty, as is known, will save the world, so we give it preference. <br><br>  So, we will try to formulate the requirements for our planner.  We need the ability to create a thread, specify the stack for it, the mask of allowed logical processors (affinity), the base priority and the execution function.  Further, the stream can be started, paused, continued, and finally terminated. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In addition, it would be great if the scheduler was not engaged in the allocation of memory, but could receive and return the memory allocated for the stream by someone else.  On the one hand, this would provide the flexibility of randomly reserving the memory of threads.  On the other hand, it would give a unique opportunity to save a stream in external memory (for example, on a hard disk) with its subsequent loading and launching from an interrupted place. <br><a name="habracut"></a><br>  So, the above requirements resulted in the following scheduler interface: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// IN fields should be set before calling attach_thread struct thread_data { INTERNAL uint64_t magic; INTERNAL struct thread_data *prev, *next, *all_prev, *all_next; IN struct int_stack_frame context; IN uint8_t *stack; IN size_t stack_size; // size available to thread: stack_size - 8 IN uint64_t affinity[THREAD_AFFINITY_SIZE]; OUT uint64_t output; OUT uint64_t run_time; IN uint8_t priority; INTERNAL uint8_t real_priority; INTERNAL uint16_t quantum; INTERNAL uint8_t cpu; INTERNAL uint8_t state: 2; IN uint8_t fixed_priority : 1; }; typedef uint64_t thread_id; typedef uint64_t (*thread_proc)(uint64_t input); // set stack and stack_size fields before calling this function err_code set_thread_context(struct thread_data *thread, thread_proc proc, uint64_t input); // attached thread becomes paused; thread should not reside in stack! err_code attach_thread(struct thread_data *thread, thread_id *id); err_code detach_thread(thread_id id, struct thread_data **thread); err_code resume_thread(thread_id id); err_code pause_thread(thread_id id); err_code stop_thread(thread_id id, uint64_t output); thread_id get_thread(void);</span></span></code> </pre> <br>  Here is a sample code that starts a new thread: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint64_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread_proc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// do some work return output; } #define STACK_SIZE 0x1000 static void start_thread(void) { thread_id id; struct thread_data *thrd; struct thread_data *thrd = kmalloc(sizeof(*thrd)+STACK_SIZE); if (!thrd) { LOG_ERROR("Failed to allocate memory"); return; } memset(thrd, 0, sizeof(*thrd)); thrd-&gt;stack = (uint8_t*)(thrd + 1); thrd-&gt;stack_size = STACK_SIZE; thrd-&gt;affinity[0] = 1; // will run on first CPU only thrd-&gt;priority = 3; thrd-&gt;fixed_priority = true; set_thread_context(thrd, thread_proc, 0); if (attach_thread(thrd, &amp;id) != ERR_NONE) { LOG_ERROR("Failed to attach thread"); return; } if (resume_thread(id) != ERR_NONE) { LOG_ERROR("Failed to resume thread"); return; }</span></span></code> </pre><br>  Now is the time to look under the hood. <br><br>  Our planner consists of the following parts: <br>  1. List of all added threads.  Protected by its own spinlock. <br>  2. List of inactive streams.  Inactive streams are suspended and terminated streams.  Protected by its own spinlock. <br>  3. Workspace CPU (one for each logical processor).  It contains priority queues, as well as a special task structure (it will be discussed later).  The working area of ‚Äã‚Äãthe CPU is also protected by its own spinlock. <br><br><img src="https://habrastorage.org/storage2/b3f/2f1/37a/b3f2f137a8fd7000fb7f5ba74e453cd7.png"><br><br>  Consider the work of the scheduler as an example of starting a new thread.  First of all, the spinlock of the list of inactive streams is captured (we will extract an element from it).  This spinlock not only protects the list from inconsistent modification by different threads, but also disables interrupts, ensuring that the operation on this processor is atomic.  After extracting the thread, a processor with the smallest number of scheduled threads (among those allowed in affinity) is searched ‚Äî a simple load balancing option. <br><br>  So, the thread must be added to the workspace of the target processor.  It just won't work this way (even by blocking it with a spinlock), because at any moment a timer interrupt can trigger, updating the priority queues.  Therefore, it is better to entrust the addition of a thread to the target processor itself in an interrupt specially allocated for such purposes. <br><br>  In the general case, the task processor of the target processor is filled in, previously blocked by the spinlock of its working area, then an interrupt is triggered on the target processor and a response is expected (in the same task structure).  In the case when the target processor is local, there is no need for an interrupt (after all, the spinlock has disabled local interrupts), so the interrupt handler is called as an ordinary function. <br><br>  After adding the stream to the workspace of the target processor, both spinlock (the workspace and the list of inactive tasks) are released.  Our thread is in the scheduling queue, and probably will one day be run in one of the timer interrupts (this depends on its current priority, as well as on the priorities of other threads on that processor). <br><br>  A few muddled presentation, many things remained behind the scenes, but enough for today.  If anyone has questions - I will describe in more detail in the comments.  And yes, you can always read the <a href="https://github.com/ababo/toy">source</a> . </div><p>Source: <a href="https://habr.com/ru/post/177403/">https://habr.com/ru/post/177403/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../177377/index.html">.ORG - trusted domain</a></li>
<li><a href="../177389/index.html">These irreplaceable registration cards</a></li>
<li><a href="../177395/index.html">Making life easier, GruntJS (for beginners)</a></li>
<li><a href="../177399/index.html">JavaScript scrollbar wrapper in the form of jQuery plugin</a></li>
<li><a href="../177401/index.html">Keyboard for designers - is it necessary? Or as I see the perfect keyboard.</a></li>
<li><a href="../177405/index.html">Self-made mechanical keyboard on a standard controller</a></li>
<li><a href="../177409/index.html">Durex created vibrating underwear that can be controlled via smartphone</a></li>
<li><a href="../177411/index.html">The digest of news from the world of mobile development for the last week ‚Ññ10 (April 15 - 21, 2013)</a></li>
<li><a href="../177413/index.html">Applications for Sony NEX-6</a></li>
<li><a href="../177415/index.html">Peter Molyneu pushed two options for monetization in Curiosity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>