<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a blockchain in less than 200 lines of Go code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to your attention the translation of the article " Code your own blockchain in less than 200 lines of Go! ". 



 This lesson is a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a blockchain in less than 200 lines of Go code</h1><div class="post__text post__text-html js-mediator-article"><p>  Hi, Habr!  I present to your attention the translation of the article " <a href="https://medium.com/%40mycoralhealth/code-your-own-blockchain-in-less-than-200-lines-of-go-e296282bcffc">Code your own blockchain in less than 200 lines of Go!</a> ". </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ui/te/cq/uitecq3ytvbahfprb2zsnofulpo.jpeg" alt="image"></div><br><p>  This lesson is a well-adapted <a href="https://medium.com/%40lhartikk/a-blockchain-in-200-lines-of-code-963cc1cc0e54">post</a> about simply writing blockchain in Javascript.  We ported it to Go and added additional features, such as browsing chains in the browser. </p><a name="habracut"></a><br><p>  The examples in the lesson will be based on the heartbeat data.  We are a medical company.  For interest, you can calculate your <a href="https://www.webmd.com/heart-disease/heart-failure/watching-rate-monitor">heart rate</a> (beats per minute) and take this number into account during the training course. </p><br><p>  Almost every developer in the world has heard about blockchain, but most still do not know how it works.  Many have heard only about Bitcoin, <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BC%25D0%25B0%25D1%2580%25D1%2582-%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582">smart contracts</a> .  This post is an attempt to dispel rumors of a blockchain, helping you write your own blockchain on Go in less than 200 lines of code!  At the end of this lesson, you can run and write data to the blockchain locally, as well as view it in a browser. </p><br><p>  Is there a better way to learn about blockchain than to create your own? </p><br><h2>  What can you do </h2><br><ul><li>  Create your own blockchain </li><li>  Understand how hashing works in preserving the integrity of a block chain </li><li>  See how new blocks are added. </li><li>  See how collisions are resolved when multiple nodes generate blocks </li><li>  Create a view of your blockchain in the browser. </li><li>  Add new blocks </li><li>  Gain a basic knowledge of blockchain </li></ul><br><h2>  What you can not do </h2><br><p>  To keep this post simple, we will not consider more sophisticated concepts of <a href="https://habrahabr.ru/post/263769/">proof of work</a> and <a href="https://habrahabr.ru/post/265561/">proof of stake</a> .  Networking will be modeled so that you can view your blockchain and view the added blocks.  Networking will be reserved for future posts. </p><br><h1>  Let's start! </h1><br><h2>  Installation </h2><br><p>  Since we are going to write code on Go, we assume that you already have experience developing on it.  After <a href="https://golang.org/dl/">installation,</a> we will also use the following packages: </p><br><pre><code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> get github.com/davecgh/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-spew/spew</code> </pre> <br><p>  Spew allows us to beautifully display structures and slices in the console. </p><br><pre> <code class="hljs swift">go <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> github.com/gorilla/mux</code> </pre> <br><p>  Gorilla / mux is a popular package for writing query handlers. </p><br><pre> <code class="hljs swift">go <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> github.com/joho/godotenv</code> </pre> <br><p>  <code>Gotdotenv</code> allows us to read from the <code>.env</code> file that lies in the root of the directory, so we don‚Äôt have to set parameters like http port in our code. </p><br><p>  Let's create our <code>.env</code> file in the root of the directory that will determine the port on which we will listen for HTTP requests.  Just add a line to the file: </p><br><pre> <code class="hljs">ADDR=8080</code> </pre> <br><p>  Create a file <code>main.go</code>  The entire implementation will be in this file and will contain less than 200 lines of code. </p><br><h2>  Imports </h2><br><p>  Package imports, along with package declarations: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"crypto/sha256"</span></span> <span class="hljs-string"><span class="hljs-string">"encoding/hex"</span></span> <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/davecgh/go-spew/spew"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gorilla/mux"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/joho/godotenv"</span></span> )</code> </pre> <br><h2>  Data model </h2><br><p>  Let's define the structure of each of our blocks, which are blockchain.  Below we explain why all these fields are necessary: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Block</span></span></span><span class="hljs-class"> struct { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Index</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Timestamp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BPM</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Hash</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrevHash</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Each block contains data that will be recorded in the blockchain and represents the event of each pulse measurement. </p><br><ul><li>  <code>Index</code> - the index of the data entry in blockchain </li><li>  <code>Timestamp</code> - timestamp when data is written </li><li>  <code>BPM</code> - beats per minute.  This is your heart rate. </li><li>  <code>Hash</code> - SHA256 identifier identifying the current record </li><li>  <code>PrevHash</code> - SHA256 identifier identifying the previous entry in the chain </li></ul><br><p>  Let's declare our blockchain, which is just a slice of structures: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-type"><span class="hljs-type">Blockchain</span></span> []<span class="hljs-type"><span class="hljs-type">Block</span></span></code> </pre> <br><p>  So, how is hashing used in blocks and in blockchain?  We use hashes to define and save blocks in the correct order.  Due to the fact that the <code>PrevHash</code> field in each block refers to the <code>Hash</code> field in the previous block (that is, they are equal), we know the correct order of the blocks. </p><br><img src="https://habrastorage.org/webt/uh/qq/9p/uhqq9pcc817-yf9xsusbajckcjc.png" alt="image"><br><br><h2 id="heshirovanie-i-sozdanie-novyh-blokov">  Hashing and creating new blocks </h2><br><hr><br><p>  Why do we have to hash it?  We get a hash for two main reasons: </p><br><ul><li>  To save space.  Hashes are made from all the data in the block.  In our case, there are only a few data blocks, but imagine that we have data from hundreds, thousands or millions of previous records.  It is much more efficient to hash this data into one SHA256 line and hash hashes than to copy all the data from previous blocks over and over. </li><li>  Maintaining the integrity of the chain.  By keeping the previous hashes, as we do in the diagram above, we can ensure that the blocks in the blockchain are in the correct order.  If an attacker wants to join and manipulate data (for example, change the heart rate to correct the prices of life insurance), the hashes will start to change and everyone will know that the chain is ‚Äúbroken‚Äù and everyone will know that you cannot trust this chain. </li></ul><br><p>  Let's write a function that takes our <code>Block</code> data and creates a SHA256 hash for them. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">func</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">calculateHash</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">block</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Block</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">string</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">record </span></span>:= <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(block.Index) + block.Timestamp + <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(block.BPM) + block.PrevHash h := sha256.<span class="hljs-built_in"><span class="hljs-built_in">New</span></span>() h.<span class="hljs-built_in"><span class="hljs-built_in">Write</span></span>([]byte(record)) hashed := h.<span class="hljs-built_in"><span class="hljs-built_in">Sum</span></span>(nil) return hex.<span class="hljs-built_in"><span class="hljs-built_in">EncodeToString</span></span>(hashed) }</code> </pre> <br><p>  The <code>calculateHash</code> function combines the <code>Index</code> , <code>Timestamp</code> , <code>BPM</code> , <code>PrevHash</code> from the <code>Block</code> structure into one line, which is the argument of the function and is returned as a string representation of the SHA256 hash.  Now we can generate a new block with all the necessary elements using the <code>generateBlock</code> new function.  To do this, we will need to transfer the previous block so that we can get its hash and index, as well as transmit a new <code>BPM</code> pulse rate. </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oldBlock Block, BPM </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Block, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newBlock Block t := time.Now() newBlock.Index = oldBlock.Index + <span class="hljs-number"><span class="hljs-number">1</span></span> newBlock.Timestamp = t.String() newBlock.BPM = BPM newBlock.PrevHash = oldBlock.Hash newBlock.Hash = calculateHash(newBlock) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newBlock, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Note that the current time is automatically recorded in the block in <code>time.Now()</code> .  Also note that the function <code>calculateHash</code> was called.  In the <code>PrevHash</code> field, the hash value from the previous block is copied.  <code>Index</code> simply incremented by one from the value in the previous block. </p><br><h2>  Block check </h2><br><p>  Now we need to write a functional to check the validity of the previous blocks.  We do this by checking the <code>Index</code> to make sure that they are increasing as expected.  We also check that <code>PrevHash</code> would <code>PrevHash</code> match the <code>Hash</code> previous block.  Finally, we recalculate the hash of the current block to ensure its correctness.  Let's write the <code>isBlockValid</code> function, which performs all of these actions and returns a bool value.  The function returns <code>true</code> if all checks pass correctly: </p><br><pre> <code class="hljs kotlin">func isBlockValid(newBlock, oldBlock Block) bool { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oldBlock.Index+<span class="hljs-number"><span class="hljs-number">1</span></span> != newBlock.Index { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oldBlock.Hash != newBlock.PrevHash { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> calculateHash(newBlock) != newBlock.Hash { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  What if we run into a problem when the two nodes of our blockchain ecosystem added blocks to their chains, and we got them both.  Which one will we choose as the correct source?  We choose the longest chain.  This is a classic blockchain problem. </p><br><p>  So let's make sure that the new chain we are taking is longer than the current chain.  If so, we can rewrite our new chain, which has a new block or blocks. </p><br><img src="https://habrastorage.org/webt/ur/5j/nn/ur5jnnqkq7vm3kcu66odvlk7fmo.png" alt="image"><br><p>  We simply compare the length of the cuts of the chains: </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceChain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(newBlocks []Block)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(newBlocks) &gt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(Blockchain) { Blockchain = newBlocks } }</code> </pre> <br><p>  If you succeed, then you can pat yourself on the back!  We described the framework of the functional for our blockchain. </p><br><p>  Now we need a convenient way to view our blockchain and write to it, ideally in the browser, so that we can boast to our friends! </p><br><h2>  Web server </h2><br><p>  We assume that you are already familiar with how web servers work, and you have some experience with Go. </p><br><p>  Use the package <code>Gorrila/mux</code> , which was downloaded earlier.  Create a <code>run</code> function to start the server and call it later. </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { mux := makeMuxRouter() httpAddr := os.Getenv(<span class="hljs-string"><span class="hljs-string">"ADDR"</span></span>) log.Println(<span class="hljs-string"><span class="hljs-string">"Listening on "</span></span>, os.Getenv(<span class="hljs-string"><span class="hljs-string">"ADDR"</span></span>)) s := &amp;http.Server{ Addr: <span class="hljs-string"><span class="hljs-string">":"</span></span> + httpAddr, Handler: mux, ReadTimeout: <span class="hljs-number"><span class="hljs-number">10</span></span> * time.Second, WriteTimeout: <span class="hljs-number"><span class="hljs-number">10</span></span> * time.Second, MaxHeaderBytes: <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := s.ListenAndServe(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Please note that the port is configured from your <code>.env</code> file we created earlier.  Call the log.Println method to display information about server startup to the console.  We set up the server and call <code>ListenAndServe</code> .  The usual practice in Go. </p><br><p>  Now we need to write the function <code>makeMuxRouter</code> , which will define our handlers.  To view and record our blockchain in the browser, two simple routes are enough for us.  If we send a <code>GET</code> request to <code>localhost</code> , we review our chain.  If we send a <code>POST</code> request, we can write data. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">func</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">makeMuxRouter</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">http</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Handler</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">muxRouter </span></span>:= mux.<span class="hljs-built_in"><span class="hljs-built_in">NewRouter</span></span>() muxRouter.<span class="hljs-built_in"><span class="hljs-built_in">HandleFunc</span></span>(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, handleGetBlockchain).<span class="hljs-built_in"><span class="hljs-built_in">Methods</span></span>(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>) muxRouter.<span class="hljs-built_in"><span class="hljs-built_in">HandleFunc</span></span>(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, handleWriteBlock).<span class="hljs-built_in"><span class="hljs-built_in">Methods</span></span>(<span class="hljs-string"><span class="hljs-string">"POST"</span></span>) return muxRouter }</code> </pre> <br><p>  <code>GET</code> request handler: </p><br><pre> <code class="hljs vbscript">func handleGetBlockchain(w http.ResponseWriter, r *http.<span class="hljs-built_in"><span class="hljs-built_in">Request</span></span>) { bytes, <span class="hljs-built_in"><span class="hljs-built_in">err</span></span> := json.MarshalIndent(Blockchain, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">err</span></span> != nil { http.<span class="hljs-keyword"><span class="hljs-keyword">Error</span></span>(w, <span class="hljs-built_in"><span class="hljs-built_in">err</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Error</span></span>(), http.StatusInternalServerError) return } io.WriteString(w, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(bytes)) }</code> </pre> <br><p>  We will describe the blockchain in JSON format, which can be viewed in any browser at <code>localhost:8080</code> .  You can specify a port in the <code>.env</code> file. </p><br><p>  <code>POST</code> request is a bit more complicated and we need a new message structure <code>Message</code> . </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Message</span></span></span><span class="hljs-class"> struct { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BPM</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  The code for the blockchain write handler. </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleWriteBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m Message decoder := json.NewDecoder(r.Body) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := decoder.Decode(&amp;m); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { respondWithJSON(w, r, http.StatusBadRequest, r.Body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> r.Body.Close() newBlock, err := generateBlock(Blockchain[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(Blockchain)<span class="hljs-number"><span class="hljs-number">-1</span></span>], m.BPM) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { respondWithJSON(w, r, http.StatusInternalServerError, m) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isBlockValid(newBlock, Blockchain[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(Blockchain)<span class="hljs-number"><span class="hljs-number">-1</span></span>]) { newBlockchain := <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(Blockchain, newBlock) replaceChain(newBlockchain) spew.Dump(Blockchain) } respondWithJSON(w, r, http.StatusCreated, newBlock) }</code> </pre> <br><p>  The reason why we used a separate message structure is that the body of the <code>POST</code> request comes in <code>JSON</code> and we will use it to write new blocks.  This allows us to send a <code>POST</code> request of the following type and our handler will fill in the rest of the block for us: </p><br><pre> <code class="hljs json">{<span class="hljs-attr"><span class="hljs-attr">"BPM"</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>}</code> </pre> <br><p>  <code>50</code> is an example of a heart rate.  You can use your pulse value. </p><br><p>  After decoding the request body into the <code>var m Message</code> structure, we will create a new block, passing the previous side and the new pulse value to the <code>generateBlock</code> function, which we wrote earlier.  We will perform a quick check to verify the correctness of the new block with the <code>isBlockValid</code> function. </p><br><p>  <em>Notes:</em> </p><br><ul><li>  <em><code>spew.Dump</code> is a handy function that beautifully prints the structures to the console.</em>  <em>Very helpful in debugging.</em> </li><li>  <em>for testing requests, we like to use Postman.</em>  <em><code>curl</code> also <code>curl</code> well if you can't get away from the terminal.</em> </li></ul><br><p>  I would like to receive a notification when our <code>POST</code> requests are successful or ended with an error.  We use a small wrapper to get the result.  Remember that Go is never ignored errors. </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">respondWithJSON</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request, code </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, payload </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { response, err := json.MarshalIndent(payload, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { w.WriteHeader(http.StatusInternalServerError) w.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">"HTTP 500: Internal Server Error"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } w.WriteHeader(code) w.Write(response) }</code> </pre> <br><h2>  Almost done! </h2><br><p>  Let's combine all the developments in one <code>main</code> function: </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { err := godotenv.Load() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { t := time.Now() genesisBlock := Block{<span class="hljs-number"><span class="hljs-number">0</span></span>, t.String(), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>} spew.Dump(genesisBlock) Blockchain = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(Blockchain, genesisBlock) }() log.Fatal(run()) }</code> </pre> <br><p>  What's going on here? </p><br><ul><li>  <code>godotenv.Load()</code> allows us to read variables from a <code>.env</code> file </li><li>  genesisBlock is the most important part of the main main function.  We need to initialize the first block, since  previous block does not exist yet. </li></ul><br><h2>  All is ready! </h2><br><p>  All code you can pick up from <a href="">github</a> <br>  Let's check our code. <br>  We launch our <code>go run main.go</code> application in the terminal <br>  In the terminal, we see that the web server is working and we get the output of our initialized first block. </p><br><img src="https://habrastorage.org/webt/be/jt/qr/bejtqr4zwjp7ei_u2qcnehkxra4.png" alt="image"><br><p>  Now visit <a href="http://localhost:8080/">localhost: 8080</a> .  As expected, we see the first block. </p><br><img src="https://habrastorage.org/webt/9s/vd/zu/9svdzuyfuhj1pk-kp58p1hr_gyc.png" alt="image"><br><p>  Now let's send <code>POST</code> requests to add blocks.  Using Postman, we are going to add several new blocks with different <code>BPM</code> values. </p><br><p>  <em>curl command (from translator):</em> </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> -X POST http://localhost:8080/ -H <span class="hljs-string"><span class="hljs-string">'content-type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{"BPM":50}'</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/wj/df/ap/wjdfapcyu3jkbznctcerljwyjrs.png" alt="image"><br><p>  Let's update our page in the browser.  Now you can see new blocks in our chain.  New blocks contain <code>PrevHash</code> correspond to <code>Hash</code> of old blocks, as we expected! </p><br><img src="https://habrastorage.org/webt/ek/az/yl/ekazylw-knpucadiu9rnle9nluq.png" alt="image"><br><h2>  Further </h2><br><p>  Congratulations!  You have just created your blockchain with proper hashing and block checking.  Now you can study more complex blockchain problems, such as Proof of Work, Proof of Stake, Smart Contracts, Dapps, Side Chains and others. </p><br><p>  This lesson does not cover topics such as new blocks are added using Proof of Work.  This will be a separate lesson, but there are many blockchain and without mechanisms Proof of Work.  Now everything is modeled by recording and viewing blockchain data on a web server.  In this lesson there is no P2P component. </p><br><p>  If you want us to add the Proof of Work mechanism and work on the network, you can report it in the <a href="https://t.me/joinchat/FX6A7UThIZ1WOUNirDS_Ew">Telegram chat</a> or follow us on <a href="https://twitter.com/myCoralHealth">Twitter</a> !  These are the best ways to contact us.  We are waiting for new feedback and new suggestions for lessons.  We are glad to hear from you! </p><br><p>  To learn more about Coral Health and how we use blockchain in medical research, visit our <a href="https://mycoralhealth.com/">website</a> . </p><br><p>  <em>PS The author of the translation will be grateful for the errors and inaccuracies of the translation.</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/347930/">https://habr.com/ru/post/347930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347920/index.html">Mobile devices from the inside. Changing the tablet memory layout</a></li>
<li><a href="../347922/index.html">What really happened to Vista: an insider retrospective</a></li>
<li><a href="../347924/index.html">Experience of two attempts at putting JNCIE-SP</a></li>
<li><a href="../347926/index.html">Flask Mega-Tutorial, Part IX: Pagination (Edition 2018)</a></li>
<li><a href="../347928/index.html">FPGA for programmer, state machines (verilog)</a></li>
<li><a href="../347932/index.html">Useful to the designer and developer. Needed at hand news from the community, designed to improve your workflow. Issue number 7</a></li>
<li><a href="../347934/index.html">Security of third-party dependencies - check with snyk</a></li>
<li><a href="../347936/index.html">Olympiad "ITMO VKontakte": weekend in St. Petersburg and +10 points to the exam</a></li>
<li><a href="../347938/index.html">Chromium: using unreliable data</a></li>
<li><a href="../347940/index.html">Red Hat absorbs CoreOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>