<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compression of large arrays of prime numbers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The properties of primes rarely allow you to work with them differently than in the form of a pre-computed array ‚Äî and preferably as large as possible...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compression of large arrays of prime numbers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/sr/yf/y8/sryfy8c2vpyfx-euoq7v_v3p_sa.jpeg" alt="sandbox" align="left"><br><p>  The properties of primes rarely allow you to work with them differently than in the form of a pre-computed array ‚Äî and preferably as large as possible.  The natural storage format in the form of integers of a particular digit capacity suffers with some drawbacks that become significant as the data grows. <br></p><p></p><p>  Thus, the format of 16-bit unsigned integers with the size of such a table of about 13 kilobytes contains only 6542 prime numbers: after the number 65531, values ‚Äã‚Äãof higher bitness follow.  Such a table is suitable only as a toy. <br></p><p></p><p>  The most popular in programming format of 32-bit integers looks much more solid - it allows you to store about 203 million simple.  But such a table is already about 775 megabytes. <br></p><p></p><p>  Even more promising in 64-bit format.  However, with a theoretical power of the order of 1e + 19 values, the table would be 64 exabytes in size. <br></p><br><a name="habracut"></a><br><p></p><p>  It is not very hard to believe that our progressive humanity will ever in the foreseeable future calculate a table of primes of such a volume.  And the point here is not so much in the volumes even, but in the counting time of the algorithms that are available.  For example, if the table of all 32-bit simple ones can still be calculated independently in a few hours (Fig. 1), then for the table at least an order of magnitude greater will take several days.  But such volumes now are just an initial level. <br></p><br><br><img src="https://habrastorage.org/webt/ut/qn/gq/utqngqsvjfyolxj1afp9n--6jxw.jpeg" alt="fig.1"><br><br><p>  As can be seen from the diagram, the specific calculation time after the start-up jerk smoothly turns into asymptotic growth.  It is rather slow.  but this is growth, which means that the mining of each regular piece of data over time will be made more and more difficult.  If you want to make some significant breakthrough, you have to parallelize the work on the cores (and it is well parallelized) and hang it on supercomputers.  With the prospect of getting the first 10 billion simple in a week, and 100 billion - only in a year.  Of course, there are faster algorithms for calculating simple ones than the trivial enumeration used in my homework, but, in essence, this does not change matters: after two or three orders of magnitude, the situation becomes similar. <br></p><p></p><p>  So, it would be nice, once having done a counting job, to store its result in a ready-made tabular form, and use it as needed. <br></p><p></p><p>  In view of the obviousness of the idea, there are a lot of links to ready-made lists of prime numbers that have already been calculated by someone.  Alas, most of them are suitable only for student crafts: one such, for example, wanders from site to site and includes 50 million simple ones.  This number can only amaze the uninitiated: it has already been mentioned above that on a home computer in a few hours you can independently calculate the table of all 32-bit simple ones, and it is four times more.  Probably 15-20 years ago, such a list was indeed a heroic achievement for the non-professional community.  Nowadays, in the age of multi-core multi-gigahertz and multi-gigabyte devices, this is no longer impressive. <br></p><p></p><p>  I was lucky to get an acquaintance access to a much more representative simple table, which I will continue to use as an illustration and sacrifice for my field experiments.  In order to conspiracy call it <b>1TPrimo</b> .  It contains all the prime numbers less than a trillion. <br></p><p></p><p>  Using the example of 1TPrimo, it is easy to see what volumes you have to deal with.  With a capacity of about 37.6 billion values ‚Äã‚Äãin the format of 64-bit integers, this list takes 280 gigabytes.  By the way - on that part of it, which could be packed in 32 bits, it is only 0.5% of the number of numbers represented in it.  Whence it becomes absolutely clear that any serious work with prime numbers inevitably tends to total 64-bit (and more) bit depth. <br></p><p></p><p>  Thus, the grim trend is obvious: a serious table of prime numbers inevitably has a titanic volume.  And with this we must somehow fight. <br></p><p></p><p>  The first thing that comes to mind when looking at a table (Fig. 2) is that it consists of almost identical consecutive values ‚Äã‚Äãthat differ only in the last one or two decimal places: <br></p><br><p><br><img src="https://habrastorage.org/webt/y7/hk/f5/y7hkf5s75ii-jdujarftwhpd14i.jpeg" alt="fig.2">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </p><br><p>  Simple, from the most common, abstract considerations: if there is a lot of duplicate data in the file, then it should be compressed well by the archiver.  Indeed, the compression of the 1TPrimo table by the popular 7-zip utility with standard settings gave a rather high compression ratio: 8.5.  True, the processing time - with the huge size of the source table - on an 8-core server, with an average load of all cores of the order of 80-90% was 14 hours and 12 minutes.  Universal compression algorithms are designed for some abstract, generalized ideas about data.  In some particular cases, specialized compression algorithms based on the well-known features of the incoming data set can demonstrate much more efficient performance, which is the subject of this work.  And how effective - it will become clear below. <br></p><p></p><p>  The close numerical values ‚Äã‚Äãof neighboring primes suggest the decision not to store these values ‚Äã‚Äãthemselves, but the intervals (differences) between them.  At the same time, it is possible to obtain substantial savings due to the fact that the width of the intervals is much lower than the width of the original data (Fig. 3). <br></p><br><p><br><img src="https://habrastorage.org/webt/7-/lk/ka/7-lkkafdhzaus8yglobx1t5t25w.jpeg" alt="fig.3"><br><br></p><br><p>  And it seems that it does not depend on the digit capacity of interval-generating simple ones.  An "eye out" demonstrates that typical interval values ‚Äã‚Äãfor primes taken from various places in the 1TPrimo table are within units, tens, occasionally hundreds, and - as a first working sentence - could possibly fit into the range of 8-bit unsigned integers, i.e., bytes.  It would be very convenient, and in comparison with the 64-bit format, this would at once lead to 8-fold data compression - just somewhere at the level demonstrated by the 7-zip archiver.  Moreover, the simplicity of the compression and decompression algorithms is supposed to have a profound effect on the speed of both compression and data access, compared to 7-zip.  It sounds tempting. <br></p><p></p><p>  At the same time, it is absolutely clear that the data converted from their absolute values ‚Äã‚Äãto relative intervals between them are suitable only for restoring series of values ‚Äã‚Äãthat follow in succession from the very beginning of the table of primes.  But if you add a minimum block-index structure to such a table of intervals, then with minor additional overhead costs this will allow you to restore ‚Äî but block by block ‚Äî both the table element by its number, and the closest element by an arbitrarily specified value, and these operations along with the main operation sampling of sequences in general exhausts the lion‚Äôs share of possible requests for such data.  Of course, statistical processing will become more complicated, but nevertheless it will remain quite transparent, since  There is no special trick in recovering it on the fly from the available intervals when accessing the required data block. <br></p><p></p><p>  But alas.  A simple numerical experiment on 1TPrimo data shows that already at the end of the third ten million (this is less than a hundredth percent of 1TPrimo volume) - and then everywhere - the intervals between adjacent simple ones regularly fall outside the range of 0..255. <br></p><p></p><p>  Nevertheless, a slightly complicated numerical experiment reveals that the growth of the maximum interval between neighboring simple ones with the growth of the table itself goes very, very slowly - and this means that the idea is still good in some way. <br></p><p></p><p> A second, closer look at the interval table suggests that you can store not the difference itself, but half of it.  Since all primes greater than 2 are obviously odd, according to their differences they are obviously even.  Accordingly, the differences can be reduced by 2 without losing the value;  and for completeness, the unit can be subtracted from the obtained quotient in order to usefully dispose of the unclaimed otherwise zero value (Fig. 4).  This coercion of intervals will be called further monolithic, in contrast to the friable, porous initial form, in which all odd values ‚Äã‚Äãand zero were unclaimed. <br></p><br><p><br><img src="https://habrastorage.org/webt/ix/ob/fp/ixobfp-kfzmw2gkwjrkkmwcfxn4.jpeg" alt="fig.4"><br><br></p><br><p>  It should be noted that since the interval between the first two simple ones (2 and 3) does not fit into this scheme, then 2 will have to be excluded from the interval table and keep this fact in mind all the time. <br></p><p></p><p>  This simple technique allows to encode intervals from 2 to 512 in the range of values ‚Äã‚Äãof 0..255. Hope comes to life again that the difference method will allow to pack a much more powerful sequence of prime numbers.  And rightly so: the run of 37.6 billion values ‚Äã‚Äãpresented in the 1TPrimo list revealed only 6 (six!) Intervals that are not in the 2..512 range. <br></p><p></p><p>  But it was good news;  the bad thing is that these six intervals are scattered according to the list quite freely, and the first of them occurs already at the end of the first third of the list, turning the remaining two thirds into ballast unsuitable for this compression method (Fig. 5): <br></p><br><p><br><img src="https://habrastorage.org/webt/k_/0y/aw/k_0yaw46rbatmne64qzj0vp9mus.jpeg" alt="fig.5"><br><br></p><br><p>  This kind of flush (some unfortunate six of them for almost forty billions! - and on you ...) even with a spoonful of tar to compare - honor of tar to show.  But alas, this is a pattern, not an accident.  If we trace the first occurrence of the intervals between primes depending on the bit depth of the data, it becomes clear that this phenomenon lies in the genetics of prime numbers, although it progresses extremely slowly (Fig.6 *). <br></p><br><p><br><img src="https://habrastorage.org/webt/sj/c_/ah/sjc_ah1hgw7ud9xewa3_s47edhq.jpeg" alt="fig.6"><br><br></p><br><p>  * The schedule is compiled according to the thematic website of <a href="http://www.trnicely.net/gaps/gaplist.html">Thomas R. Nicely</a> , <br>  which are several orders higher than the power of the 1TPrimo list </p><br><p></p><p>  But even this very slow progress unambiguously hints: it is possible to confine ourselves to some predetermined interval width only on some predetermined power of the list.  That is, not suitable as a universal solution. <br></p><p></p><p>  However, the fact that the proposed method of compressing a sequence of primes allows an uncomplicated compact table with a capacity of almost 12 billion values ‚Äã‚Äãto be realized - this is already quite an outcome.  Such a table occupies a volume of 11.1 gigabytes - against 89.4 gigabytes in a trivial 64-bit format.  Surely for a number of applications such a solution may be sufficient. <br></p><p></p><p>  And what is interesting: the procedure for translating the 64-bit table 1TPrimo into the format of 8-bit intervals with a block structure, using only one processor core (for parallelization would have to resort to a significant complication of the program, and it was not worth it) and no more than 5 % of the processor load (most of the time was spent on file operations) took only 19 minutes. Against - let me remind you - 14 hours on eight cores with 80-90% of the load spent by the 7-zip archiver. <br></p><p></p><p>  Of course, only the first third of the table was subjected to this broadcast, in which the range of intervals does not exceed 512. Therefore, if you bring the full 14 hours to the same third, then 19 minutes should be compared against almost 5 hours of the 7-zip archiver.  With a comparable amount of compression (8 and 8.5), the difference is about 15 times.  Taking into account that the lion's share of the working time of the broadcast program was taken by file operations, on a faster disk system the difference would be even steeper.  And according to the mind, the running time of 7-zip on eight cores should be recalculated into one stream, and then the comparison will become really adequate. <br></p><p></p><p>  A sample from such a database differs very little in time from a sample from a table of unpacked data and is almost entirely determined by the time of file operations.  Specific figures are highly dependent on a specific hardware, on my server, on average, access to an arbitrary data block took 37.8 ¬µs, with sequential reading of blocks - 4.2 ¬µs per block, for full unpacking of the block - less than 1 ¬µs.  That is, comparing data unpacking with the work of a standard archiver does not make sense at all.  And this is a big plus. <br></p><p></p><p>  And finally, the observations made suggest another, third solution, which removes any limitations on data power: interval coding with variable length values.  This technique has long been widely used in applications related to compression.  Its meaning is that if in the input data it is found that some values ‚Äã‚Äãcome across often, some less often, and some rarely come up, then we can encode the first with short codes, the second with longer codes, and the third - very long (maybe even very long, because it does not matter: all the same, such data is very rare).  As a result, the total length of the received codes can be much shorter than the input data. <br></p><p></p><p>  Already looking at the graph of the appearance of the intervals in Fig. 7, one can make an assumption that if the intervals are 2, 4, 6, etc.  appear before the intervals, say, 100, 102, 104, etc., and then the first should occur much more often than the second.  And vice versa - if the intervals 514 come across only from 11.99 billionths, 516 - starting from 16.2 billions, and 518 - generally starting only from 87.7 billions, then they will continue to fall very rarely.  That is, a priori, we can assume an inverse relationship between the size of the interval and its frequency in the sequence of primes.  So, it is possible to construct a simple structure that implements variable length codes for them. <br></p><p></p><p>  Of course, the statistics of frequency of intervals should be decisive for choosing a specific coding method.  Fortunately, in contrast to arbitrary data, the frequency of the intervals between prime numbers - which themselves are strictly deterministic, once and for all a given sequence - is also strictly deterministic, once and for all a certain characteristic. <br></p><p></p><p>  Figure 7 shows the frequency response of the intervals for the whole 1TPrimo list: <br></p><br><p><br><img src="https://habrastorage.org/webt/7q/ga/ii/7qgaii-1mwxlmuvicojaklwrbuk.jpeg" alt="fig.7"><br><br></p><br><p>  Here we must again mention that the interval between the very first simple 2 and 3 is excluded from the graph: this interval is equal to 1 and occurs in the sequence of simple exactly once, regardless of the power of the list.  This interval is so distinctive that it is easier to remove 2 from the list of simple ones, than to constantly stumble upon reservations.  Sim is declared that the <b>number 2 is virtual simple</b> : it is not visible in the lists, but it is there.  Like that gopher. <br></p><p></p><p>  At first glance, the frequency graph fully confirms the a priori assumption given by the pair of paragraphs above.  It clearly shows the statistical heterogeneity of intervals and the high frequency of small values ‚Äã‚Äãcompared with large ones.  However, on the second, more convex view, the graph turns out to be much more interesting (Fig. 8): <br></p><br><p><br><img src="https://habrastorage.org/webt/qm/4_/xu/qm4_xuzdshet30cdd9ucm7t4q0m.jpeg" alt="fig.8"><br><br></p><br><p>  Quite unexpectedly, it turns out that the most common intervals are not 2 and 4, as it seemed to be from general considerations, but 6, 12 and 18, followed by 10 - and only then 2 and 4 with practically equal frequency (the difference in 7 after comma).  And further multiplicity of peak values ‚Äã‚Äãof the number 6 is traced throughout the entire graph. <br></p><p></p><p>  Even more interesting is that this inadvertently revealed nature of the schedule is universal - and, in all details, with all its kinks - throughout the sequence of simple intervals represented by the list of 1TPrimo, and there is a possibility that it is universal in general for any sequence of intervals of simple (of course such a bold statement needs proof, which I will with great pleasure transfer to the specialists in number theory).  Figure 10 presents a comparison of the full statistics of the intervals (a line of scarlet) with limited sampling intervals taken at several arbitrary locations in the 1TPrimo list (lines of other colors): <br></p><br><p><br><img src="https://habrastorage.org/webt/xs/jk/hd/xsjkhdqm8aztn2qztye3ftpf0yw.jpeg" alt="fig.9"><br></p><br><p>  It can be seen from this graph that all these samples repeat each other exactly, with only a small difference in the left and right parts of the figure: they seem to be slightly rotated counterclockwise around the point of the interval with a value of 24. This rotation is probably due to the fact that the higher in the left parts of the graphics are built on samples with lower bit depth.  In such samples there are still no, or rarely large intervals, which become frequent in the samples with higher bit depth.  Accordingly, their absence is in favor of the frequency of intervals with smaller values.  In samples with a higher bit depth, many new intervals appear with larger values, so the frequency of smaller intervals decreases slightly.  Most likely, the turning point, with an increase in the power of the list, will shift towards larger values.  Somewhere in the same place is the balance point of the graph, where the sum of all values ‚Äã‚Äãon the right is approximately equal to the sum of all values ‚Äã‚Äãon the left. <br></p><p></p><p>  This entertaining nature of the frequency of intervals suggests discarding the trivial structure of variable-length codes.  Usually such a structure consists of a packet of bits of various lengths and purposes.  For example, first comes a certain number of prefix bits set to a specific value, for example, 0. They are followed by a stop bit, which should mark the end of the prefix, and, accordingly, must be different from the prefix: 1 in this case.  The prefix may not have any length, that is, the sample may begin immediately with a stop bit, thus determining the shortest sequence.  The stop bit is usually followed by a suffix, the length of which is determined in some pre-defined manner by the prefix length.  It can be equal to the prefix length, it can be a specified number of times longer, or the dependence can be progressive - the choice is determined just by the frequency characteristics of the input data.  Since the length of the suffix is ‚Äã‚Äãalready defined by the prefix, the bits of the suffix can have any value and denote something.  Thus, the suffix in some way predetermined way (tabular, calculated, some other) determines the value that should be restored from parsed packet of bit sequences. <br></p><p></p><p>  In our case, the identified cyclical nature of the frequency response allows us to supplement the structure described above with another pendulum reflecting this cyclicity. <br></p><p></p><p> And here you should say another important thing.  At first glance, the observed cyclicity implies dividing the intervals into triples: <code>{2,4, <b>6</b> }</code> , <code>{8,10, <b>12</b> }</code> , <code>{14,16, <b>18</b> }</code> and so on (the values ‚Äã‚Äãwith the maximum frequency in each triples are highlighted in bold) .  However, in reality the cyclicality here is slightly different. <br></p><p></p><p>  I will not give the whole course of reasoning, of which, in fact, no: it was an intuitive guess, supplemented by a method of stupid searching variants, calculations and samples that took several days with interruptions.  The resulting cyclicality consists of <b>six</b> intervals <code>{2,4, <b>6</b> ,8,10, <b>12</b> }</code> , <code>{14,16, <b>18</b> ,20,22, <b>24</b> }</code> , <code>{26,28, <b>30</b> ,32,34, <b>36</b> }</code> and so on (intervals of maximum frequency are highlighted in bold again). <br></p><p></p><p>  In a nutshell, the proposed packaging algorithm is as follows. <br></p><p></p><p>  The division of intervals into sixes of even numbers allows us to represent any interval <code>g</code> as <code>g = i * 12 + t</code> , where <code>i</code> is the index of the six that includes this interval ( <code>i = {0,1,2,3, ...}</code> ) <code>t</code> - scam representing one of the values ‚Äã‚Äãfrom a rigidly defined, bounded and identical set for any six <code>{2,4,6,8,10,12}</code> .  The frequency response of the index highlighted above is almost exactly inversely proportional to its value, so it is logical to convert the six index into a trivial variable-length code structure, an example of which is given above.  The frequency characteristics of the scraper allow us to divide it into two groups that can be encoded with bit chains of different lengths: values ‚Äã‚Äã6 and 12, which occur most often, encode with one bit, values ‚Äã‚Äã2, 4, 8 and 10, which occur much less frequently, encode with two bits.  Of course, we need one more bit to distinguish these two options. <br></p><p></p><p>  An array containing bit packets is supplemented with fixed fields that specify the starting values ‚Äã‚Äãof the data presented in the block, and other values ‚Äã‚Äãrequired to restore an arbitrary simple or sequence of simple intervals from the intervals stored in the block. <br></p><p></p><p>  In addition to this block-index structure, the use of variable-length codes is complicated by additional costs compared to fixed-length intervals. <br></p><p></p><p>  When using intervals of a fixed size, determining a block in which a prime number should be searched for by its ordinal number is a rather simple task, since the number of intervals per block is known in advance.  But the search for a simple by the nearest value has no direct solution.  Alternatively, you can use any empirical formula that allows you to find an approximate block number with the required interval, after which you will have to search for the desired block by searching. <br></p><p></p><p>  For a table with variable length codes, the same approach is required for both tasks: both for sampling values ‚Äã‚Äãby number and for searching by value.  Since the length of the codes varies, it is never known beforehand how many differences are stored in any particular block, and in which block the desired value lies.  It was experimentally determined that with a block size of 512 bytes (which includes some number of bytes of the header), the capacity of the block can walk by 10-12 percent of the average value.  Smaller blocks give even more relative scatter.  At the same time, the average value of the block capacity itself tends to slow down as the table grows.  Selection of empirical formulas for inaccurate determination of the initial block for finding the desired value, both by number and value, is a nontrivial task.  Alternatively, you can use more complex and sophisticated indexing. <br></p><p></p><p>  That's all. <br></p><p></p><p>  Below, the subtleties of compression of the table of prime numbers using variable length codes and the structures associated with it are described more formally and in detail, the code for the functions of packing and unpacking intervals in the C language is given. <br></p><p></p><p>  Total. <br></p><p></p><p>  The amount of data translated from the 1TPrimo table to variable length codes, supplemented by a block-index structure, also described below, was 26,309,295,104 bytes (24.5GB), that is, the compression ratio reaches a value of 11.4.  It is obvious that with the increase in the digit capacity of data the compression ratio will grow. <br></p><p></p><p>  The broadcast time of 280 GB of the 1TPrimo table to the new format was 1 hour.  This is an expected result after experiments with packing single-byte intervals.  In both cases, the translation of the source table consists mainly of file operations and almost does not load the processor (in the second case, the load is still higher due to the higher numerical complexity of the algorithm).  The data access time is also not much different from single-byte intervals, but the time to unpack a full block of the same size took 1.5 ¬µs, due to the higher complexity of the algorithm for extracting variable length codes. <br></p><p></p><p>  The table (fig.10) summarizes the volumetric characteristics of the primes table mentioned in this text. <br></p><br><p><br><img src="https://habrastorage.org/webt/dc/jw/6o/dcjw6oz2efm88nqvzolxsz7mx6m.jpeg" alt="fig.10"></p><br><p></p><p><br></p><h3>  Description of the compression algorithm </h3><br><h4>  Terms and designations </h4><br>  <code>P (prime): P1=3, P2=5, P3=7 ... Pn, Pn1</code> are prime numbers by their ordinal numbers.  Once again (and last time) I emphasize that <code>P0=2</code> is a virtual prime number;  for the sake of formal uniformity, physically from the list of primes, this number is excluded. <br><p></p><p>  <code>G (gap)</code> - the interval between two consecutive primes <code>Gn = Pn1 - Pn; G={2,4,6,8 ...}</code>  <code>Gn = Pn1 - Pn; G={2,4,6,8 ...}</code> . <br></p><p></p><p>  <code>D (dense)</code> - the interval reduced to a monolithic form: <code>D = G/2 -1; D={0,1,2,3 ...}</code>  <code>D = G/2 -1; D={0,1,2,3 ...}</code> .  The six intervals in the reduced to a monolithic form look like <code>{0,1,2,3,4,5}, {6,7,8,9,10,11}, {12,13,14,15,16,17}</code> etc. <br></p><p></p><p>  <code>Q (quotient)</code> - an index of a six reduced to a monolithic form, <code>Q = D div 6; Q={0,1,2,3 ...}</code> <code>Q = D div 6; Q={0,1,2,3 ...}</code> <br></p><p></p><p>  <code>R (remainder)</code> is the remainder of the monolithic six <code>R = D mod 6. R</code> always has a value in the interval <code>{0,1,2,3,4,5}</code> . <br></p><p></p><p>  The values ‚Äã‚Äãof <code>Q</code> and <code>R</code> obtained by the above method from any arbitrary interval <code>G</code> , by virtue of their stable frequency characteristics, are subject to compression and storage in the form of bit packets of variable length, described below.  Bit chains encoding <code>Q</code> and <code>R</code> values ‚Äã‚Äãin a packet are created in different ways: the bit chain of the prefix <code>H</code> , flux <code>F</code> and auxiliary bit <code>S</code> used to encode the <code>Q</code> index, and the bit group of the infix <code>X</code> and the auxiliary bit <code>A</code> are used to encode the remainder <code>R</code> <br></p><p></p><p>  <code>A (arbiter)</code> is a bit that determines the size of the <code>X</code> infix: 0 is single-bit infix, 1 is two-bit. <br></p><p></p><p>  <code>X (infix)</code> - 1 or 2-bit infix, together with the arbiter <code></code> bit, reciprocally determining the value of <code>R</code> tabular manner (the table also shows the frequency of the first six with such infixes for reference): <br></p><br><p><br><img src="https://habrastorage.org/webt/kp/hk/a4/kphka4ymveajnxr8icfzgggln4e.jpeg" alt="infix bits"><br><br></p><br><p>  <code>F (fluxion)</code> is a fluxia, a derivative of the index <code>Q</code> variable length <code>L={0,1,2...}</code> , designed to distinguish between the semantics of bit chains <code>(), 0, 00, 000,</code> or <code>1, 01, 001</code> , and so on. d. <br></p><p></p><p>  The bit chain of units of length <code>L</code> is expressed by the value <code>2^L - 1</code> (the sign <code>^</code> means exponentiation).  In the notation of C, the same value can be obtained by the expression <code>1&lt;&lt;L - 1</code> .  Then the value of the fluxion of length <code>L</code> can be obtained from <code>Q</code> expression <br></p><p></p><p></p><pre> F = Q - (1 &lt;&lt; L - 1),
</pre><p></p><p>  and restore <code>Q</code> from flux expression <br></p><p></p><p></p><pre> Q = (1 &lt;&lt; L - 1) + F.
</pre><p></p><p>  As an example, for the values <code>Q = {0..15}</code> , the following fluxium bit chains will be obtained: <br></p><br><p><br><img src="https://habrastorage.org/webt/j0/kb/4y/j0kb4y3ob_yutugxxvpwlddqofc.jpeg" alt="bits of fluxia"><br><br></p><br><p>  The last two bit fields required for packing / retrieving values ‚Äã‚Äãare: <br></p><p></p><p>  <code>H (header)</code> is a prefix, a string of bits set to 0. <br></p><p></p><p>  <code>S (stop)</code> - stop bit set to 1, the final prefix. <br></p><p></p><p>  In fact, these bits are processed first in the bit chains, they allow you to determine the size of the fluxion and the beginning of the arbitrator and fluxia when you unpack it or specify the packing immediately after the stop bit. <br></p><p></p><p>  <code>W (width)</code> - the width of the entire code in bits. <br></p><p></p><p>  The complete structure of the bit packet is shown in Figure 11: <br></p><br><p><br><img src="https://habrastorage.org/webt/ke/7u/tz/ke7utzoka0xkdd9dzzux6yden7e.jpeg" alt="fig.11"><br><br></p><br><p>  The values ‚Äã‚Äãof <code>Q</code> and <code>R</code> restored from these chains allow us to restore the original value of the interval: <br></p><p></p><p></p><pre> D = Q * 6 + R,
 G = (D + 1) * 2,
</pre><p></p><p>  and the sequence of restored intervals allows you to restore the original prime numbers from a given basic block value (seed block intervals) by adding to it sequentially all the intervals of this block. <br></p><p></p><p>  To work with bit chains, a 32-bit integer variable is used in which the low-order bits are processed and, after using them, the bits are shifted to the left during packaging or to the right during decompression. <br></p><p></p><br><h4>  Block structure </h4><br><p></p><p>  In addition to bit chains, the block contains information necessary for sampling or for adding bits, as well as for determining the contents of a block. <br></p><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    typedef unsigned char BYTE; typedef unsigned short WORD; typedef unsigned int LONG; typedef unsigned long long HUGE; typedef int BOOL; #define TRUE 1 #define FALSE 0 #define BLOCKSIZE (256) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ :   , #define HEADSIZE (8+8+2+2+2) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   , #define BODYSIZE (BLOCKSIZE-HEADSIZE) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/           typedef struct { HUGE base; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,      HUGE card; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        WORD count; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      WORD delta; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ base+delta =      WORD offset; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        BYTE body[BODYSIZE]; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    } crunch_block; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,   put()  get() crunch_block block; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ NB:  len/val</span></span>  rev/rel     /<span class="hljs-regexp"><span class="hljs-regexp">/  ,    ,   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . static struct tail_t { BYTE len; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      S  A BYTE val; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,   A  - S BYTE rev; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    BYTE rel; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    } tails[6] = { { 4, 3, 2, 3 }, { 4, 7, 5, 3 }, { 3, 1, 0, 4 }, { 4,11, 1, 4 }, { 4,15, 3, 4 }, { 3, 5, 4, 4 } }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/             BOOL put(int gap) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1.      int Q, R, L; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   (),  (),   int val = gap /</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; Q = val / <span class="hljs-number"><span class="hljs-number">6</span></span>; R = val % <span class="hljs-number"><span class="hljs-number">6</span></span>; L = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .., <span class="hljs-number"><span class="hljs-number">0</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> val = Q + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (val) { val <span class="hljs-meta"><span class="hljs-meta">&gt;&gt;= </span></span><span class="hljs-number"><span class="hljs-number">1</span></span>; L++; } /<span class="hljs-regexp"><span class="hljs-regexp">/    L val = Q - (1 &lt;&lt; L) + 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  val &lt;&lt;= tails[R].len; val += tails[R].val; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      val &lt;&lt;= L; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   L += L + tails[R].len; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2.   val  L   buffer   put_index if (block.offset + L &gt; BODYSIZE * 8) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ !      return FALSE; Q = (block.offset /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,      R = block.offset % <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     block.offset += L; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      block.count++; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     block.delta += gap; if (R &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/        { val &lt;&lt;= R; val |= block.body[Q]; L += R; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     L = L /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> + ((L % <span class="hljs-number"><span class="hljs-number">8</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     while (L-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { block.body[Q++] = (char)val; val &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } return TRUE; } /<span class="hljs-regexp"><span class="hljs-regexp">/          int get_index; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      int get() { if (get_index &gt;= BODYSIZE * 8) return 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      int val = *((int*)&amp;block.body[get_index /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>]) &gt;&gt; get_index % <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-number"><span class="hljs-number">4</span></span>   if (val == <span class="hljs-number"><span class="hljs-number">0</span></span>) return -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> !       int Q, R, L, F, M, len; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> , , , ,     L = <span class="hljs-number"><span class="hljs-number">0</span></span>; while (!(val &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>)) { val &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; L++; } /<span class="hljs-regexp"><span class="hljs-regexp">/  -     if ((val &amp; 3) == 1) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       R = (val &gt;&gt; 2) &amp; 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   else R = ((val &gt;&gt; 2) &amp; 3) + 2; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   len = tails[R].rel; get_index += 2 * L + len; val &gt;&gt;= len; M = ((1 &lt;&lt; L) - 1); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   F = val &amp; M; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    Q = F + M; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   return 2 * (1 + (6 * Q + tails[R].rev)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         }</span></span></code> </pre><br><p></p><br><h4>  Enhancements </h4><br><p></p><p>  If you feed the resulting baseline intervals to the same 7-zip archiver, then after an hour and a half of intensive work on an 8-core server, he manages to compress the input file by almost 5%.  That is, in the database of intervals of variable length, from the point of view of the archiver, there is still some redundancy.  This means there is reason to speculate a little (in the good sense of the word) on the topic of further reducing data redundancy. <br></p><p></p><p>  The principal determinism of the sequence of intervals between simple numbers allows one to make accurate calculations of the coding efficiency by one or another method.  In particular, small (and rather chaotic) sketches made it possible to draw a fundamental conclusion about the advantages of coding sixes over triples, and about the advantages of the proposed method over trivial codes of variable length (fig.12): <br></p><br><p><br><img src="https://habrastorage.org/webt/w9/_l/9q/w9_l9qaibojgrxt5izuw4j7lxzc.jpeg" alt="fig.12"><br><br></p><br><p>  However, the annoying highs of the red graphics transparently hints that there may be other coding methods that would make the graph even flatter. <br></p><p></p><p>  Another direction suggests checking the frequency of consecutive intervals.  From general considerations: since the most common in the population of prime numbers are the intervals 6, 12, and 18, then they will probably also be more often found in pairs (doublets), triples (triplets), and similar combinations of intervals.  If the repeatability of doublets (and maybe even triplets ... well, all of a sudden!) Turns out to be statistically significant in the total mass of intervals, then it will make sense to translate them into some separate code. <br></p><p></p><p>  A full-scale experiment does reveal some predominance of individual doublets over others.  However, if absolute leadership is expected in a pair <code>(6,6)</code> - 1.37% of all doublets - then the other winners of this rating are much less obvious: <br></p><p><br><img src="https://habrastorage.org/webt/4m/jq/o-/4mjqo-jyxt27cpw6e6bnasgxl0s.jpeg" alt="doublet statistics"><br><br></p><br><p>  And since the doublet <code>(6,6)</code> symmetric, and all the remaining doublets are asymmetric and are found in the rating by mirror twins with the same frequency, it seems that the record record of the doublet <code>(6,6)</code> in this series should be divided in half between indistinguishable doubles <code>(6,6)</code> and <code>(6,6)</code> , which brings with them 0.68% far down, beyond the border of the prize list.  And this once again confirms the observation that no true guesses regarding prime numbers are possible without surprises. <br></p><p></p><p>  The statistics of triplets also demonstrates the leadership of such triples of intervals that do not quite fit into the speculative assumption emanating from the highest frequency of the intervals 6, 12, 18. In decreasing order of popularity, the leaders of the frequency among triplets are as follows: <br></p><p><br><img src="https://habrastorage.org/webt/nn/if/sw/nnifswq5tugkq5kypoe44qllyj4.jpeg" alt="triplet statistics"><br><br></p><p>  etc. <br></p><p></p><p>  I am afraid, however, that the results of my speculations will be of interest to not so much programmers, perhaps mathematicians, because of the unexpectedness of the proofs introduced by practice into intuitive guesses.  It is unlikely that any significant dividend in favor of a further increase in the compression ratio will be able to squeeze the frequency out of the mentioned percentages, while the complexity of the algorithm threatens to grow very significantly. <br></p><p></p><p></p><h4>  Restrictions </h4><br><p></p><p>  It was already noted above that the growth of the maximum value of the intervals in connection with the digit capacity of primes is very, very slow.  In particular, from Fig. 6, it can be seen that the interval between any prime numbers that can be represented in a 64-bit unsigned integer format will certainly be less than 1600. <br></p><p></p><p>  The described implementation allows you to properly pack and unpack any 18-bit interval values ‚Äã‚Äã(in fact, the first packaging error occurs with an input interval of 442358).  I do not have enough imagination to assume that the database of intervals of prime numbers is capable of growing to similar values: offhand it is somewhere around 100-bit integers, and it‚Äôs more accurate to calculate laziness.  In the fire case, to expand the range of intervals at times will be easy. <br></p><p></p><p>  Thank you for reading this place :) <br></p><br><p></p></div><p>Source: <a href="https://habr.com/ru/post/417753/">https://habr.com/ru/post/417753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417743/index.html">Legendary amplifiers ‚Äî historical anatomy of trends: ‚Äúcold‚Äù transistor sound</a></li>
<li><a href="../417745/index.html">Personal experience: Data Engineering at Upwork</a></li>
<li><a href="../417747/index.html">Re: "Comparison of JS frameworks: React, Vue and Hyperapp"</a></li>
<li><a href="../417749/index.html">Project Loon as a commercial project: the first contract is signed</a></li>
<li><a href="../417751/index.html">Kunstkamera: E-Meter ‚Äî The Scientology Thetan Device</a></li>
<li><a href="../417755/index.html">Study: 80% of ICO 2017 found to be fraudulent</a></li>
<li><a href="../417757/index.html">Creating a bot to participate in the AI ‚Äã‚Äãmini cup. GPU Experience</a></li>
<li><a href="../417759/index.html">Be my rubber duck</a></li>
<li><a href="../417761/index.html">GitLab moves from Azure to the Google Cloud Platform. Moving news and maintenance dates</a></li>
<li><a href="../417763/index.html">MVIDroid: review of the new MVI library (Model-View-Intent)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>