<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Porting C / C ++ library to JavaScript (xml.js)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article is a supplemented translation of the article ‚Äú HOWTO: Port a C / C ++ Library to JavaScript (xml.js) ‚Äù (by azakai ). The author of the ori...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Porting C / C ++ library to JavaScript (xml.js)</h1><div class="post__text post__text-html js-mediator-article">  The article is a supplemented translation of the article ‚Äú <a href="http://mozakai.blogspot.com/2012/03/howto-port-cc-library-to-javascript.html">HOWTO: Port a C / C ++ Library to JavaScript (xml.js)</a> ‚Äù (by <a href="http://mozakai.blogspot.com/p/about.html">azakai</a> ).  The author of the original article has a decent experience in porting C / C ++ libraries to JavaScript.  In particular, he successfully ported <a href="">lzma.js</a> and <a href="">sql.js.</a>  In his article, he describes the general scheme for porting C / C ++ code using the example of <a href="http://xmlsoft.org/">libxml</a> , an open library for validating XML. <br><a name="habracut"></a><br>  In addition, this article contains the complete sequence of actions that were required to port libxml in the Ubuntu 12.04 environment.  Including the necessary environment setting and <a href="https://github.com/kripken/emscripten/wiki">emscripten</a> . <br><br><h2>  Installing and Configuring Emscripten </h2><br>  Emscripten - compiler from LLVM bytecode to javascript.  C / C ++ code can be compiled into LLVM bytecode using the <a href="http://clang.llvm.org/">clang</a> compiler.  Some other languages ‚Äã‚Äãalso have compilers in LLVM bytecode.  Emscripten generates the corresponding JavaScript code, which can be executed by any JavaScript interpreter, for example, a modern browser.  With emscripten, the guys from Mozilla have recently successfully ported Doom. <br><br>  Emscripten provides: <strong>emconfigure</strong> - a utility for setting the environment and then running ./configure;  <strong>emmake</strong> is a utility for setting up the environment and then running make;  <strong>emcc</strong> - LLVM compiler in javascript; 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, let's set up the environment for working with emscripten (see the <a href="https://github.com/kripken/emscripten/wiki/Tutorial">manual</a> ). <br><br>  Install clang + llvm (&gt; = 3.0): <br><blockquote>  wget <a href="">llvm.org/releases/3.0/clang+llvm-3.0-i386-linux-Ubuntu-11_10.tar.gz</a> <br>  tar xfv clang + llvm-3.0-i386-linux-Ubuntu-11_10.tar.gz </blockquote><br>  Install node.js (&gt; = 0.5.5): <br><blockquote>  sudo apt-get install nodejs </blockquote><br>  Unload the current version of emscripten: <br><blockquote>  git clone git: //github.com/kripken/emscripten.git <br>  cd emscripten </blockquote><br>  Check the performance of the clang: <br><blockquote>  ../clang+llvm-3.0-i386-linux-Ubuntu-11_10/bin/clang tests / hello_world.cpp <br>  ./a.out <br>  <font>&gt;&gt; hello, world!</font> </blockquote><br>  Checking node.js operability: <br><blockquote>  node tests / hello_world.js <br>  <font>&gt;&gt; hello, world!</font> </blockquote><br>  Run emcc for the first time to create the configuration file ' <strong>~ / .emscripten</strong> ': <br><blockquote>  ./emcc </blockquote><br>  In the configuration file, you need to specify the clang + llvm directory, as well as the emscripten installation directory: <br><blockquote>  EMSCRIPTEN_ROOT = os.path.expanduser (' <strong>~ / path / emscripten</strong> ') # this helps projects using emscripten find it <br>  LLVM_ROOT = os.path.expanduser (' <strong>~ / path / clang + llvm-3.0-i386-linux-Ubuntu-11_10 / bin</strong> ') </blockquote><br>  You need to run emcc again to make sure that it is configured correctly.  In this case, it will display the message ' <strong>emcc: no input files</strong> ': <br><blockquote>  ./emcc <br>  <font>&gt;&gt; emcc: no input files</font> </blockquote><br>  Now you can verify that everything works correctly by compiling hello_wolrd.cpp using emcc: <br><blockquote>  ./emcc tests / hello_world.cpp <br>  node a.out.js <br>  &gt;&gt; hello, world </blockquote><br><h2>  Part 1: Compiling C / C ++ sources </h2><br>  Before you start porting, you should make sure that the source code of the project is compiled without errors by the C / C ++ compiler. <br><br>  Unload libxml from the repository and compile: <br><blockquote>  git clone git: //git.gnome.org/libxml2 <br>  cd libxml2 <br>  git checkout v2.7.8 <br>  CC = ~ / path / clang + llvm-3.0-i386-linux-Ubuntu-11_10 / bin / clang ./autogen.sh --without-debug --without-ftp --without-http --without-python - without-regexps --without-threads --without-modules <br>  make </blockquote><br>  The libxml includes a console utility <strong>xmllint</strong> for validating xml schemas.  It can be used to verify the correctness of the compiled code.  It is necessary to perform such checks, including to make sure that the original and ported versions work equally well.  Testing with xmllint looks like this: <br><blockquote>  $. / xmllint --noout --schema <a href="">test.xsd</a> <a href="">test.xml</a> <br>  &gt;&gt; test.xml validates </blockquote><br>  If everything works correctly, make a few changes to the test.xml file and then xmllint will display an error message. <br><br><h2>  Part 2: Configuration </h2><br>  To configure a project for compilation using emscripten, use the command: <br><blockquote>  ~ / path / emscripten / emconfigure ./autogen.sh --without-debug --without-ftp --without-http --without-python --without-regexps --without-threads --without-modules </blockquote><br>  emconfigure sets the environment variables so that ./configure uses the emcc compiler instead of gcc or clang.  It configures the environment so that ./configure works correctly, including configuration tests (which compile the native code). <br><br>  The default configuration results (without flags) include a lot of functionality that is not needed at this stage, for example, HTTP and FTP support.  We just want to validate xml-schemas, so you should configure the project, eliminating unnecessary functionality.  In general, it is a good idea to exclude unnecessary functionality when porting.  Due to this, the code will be smaller in size, which is important for the network environment.  In addition, some header files may require manual editing (those files that use newlib, not glibc). <br><br><h2>  Part 3: Build Project </h2><br>  Assembly is performed by the command: <br><blockquote>  ~ / path / emscripten / emmake make </blockquote><br>  emmake is similar to emconfigure: it also sets environment variables.  Thanks to emmake, LLVM bytecode instead of native code is generated during build.  This is done to avoid generating JavaScript code for each object file and then linking it.  Instead, the bytecode LLVM <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B2%25D1%2589%25D0%25B8%25D0%25BA">linker is</a> used. <br><br>  As a result of the assembly a lot of different files are built.  But they can not be executed.  As mentioned above, this is LLVM bytecode (it can be viewed with BC), so we need the next step. <br><br><h2>  Part 4: Conversion to JavaScript </h2><br>  xmllint depends on xmllint.o and libxml2.a.  LLVM linker does not support dynamic linking (late binding) and emcc ignores it.  Therefore, you will have to manually specify the libxml2.a static library for linking. <br><br>  A bit less obvious is the dependency on <a href="http://www.zlib.net/">libz</a> (open library for compression).  If you build without libz.a, an error will occur during the execution of an attempt to call the ‚Äúgzopen‚Äù function.  Accordingly, you need to build libz.a: <br><blockquote>  cd ~ / path <br>  wget <a href="">zlib.net/zlib-1.2.7.tar.gz</a> <br>  tar xfv zlib-1.2.7.tar.gz <br>  cd zlib-1.2.7 <br>  ~ / path / emscripten / emconfigure ./configure --static <br>  ~ / path / emscripten / emmake make </blockquote><br>  Now you can compile JavaScript code: <br><blockquote>  cd ~ / path / libxml2 <br>  ~ / path / emscripten / emcc -O2 xmllint.o .libs / libxml2.a ../zlib-1.2.7/libz.a -o xmllint.test.js --embed-file test.xml --embed-file test.xsd </blockquote><br>  Where: <br><ul><li>  emcc - replacement for gcc or clang (see above); </li><li>  -O2 - optimization flag.  LLVM- and advanced JavaScript-level optimizations are running, including Closure Compiler (in advanced mode); </li><li>  files to build; </li><li>  -o - the resulting xmllint.test.js file.  The ‚Äújs‚Äù suffix indicates emcc for the format of the generated code, in this case JavaScript; </li><li>  - embed-file - instructs emcc to include the contents of the specified file in the generated code and configure the virtual file system so that these files are accessible through standard stdio calls (fopen, fread, etc.).  This is the easiest way to access files from compiled code. </li></ul><br><br><h2>  Part 5: Testing JavaScript </h2><br>  The JavaScript console provided by Node.js, SpiderMonkey, or V8 can be used to run this code: <br><blockquote>  node xmllint.test.js --noout --schema test.xsd test.xml <br>  &gt;&gt; test.xml validates </blockquote><br>  The result should be exactly the same as the native code.  Similarly, if you add errors to the xml schema, xmllint should detect them. <br><br>  <strong>Important</strong> : all arguments used for the native and JavaScript assemblies must be exactly identical. <br><br><h2>  Part 6: Refactoring and reuse </h2><br>  Currently there are two files in the script for validation.  We also need a generic function to validate any XML file according to the scheme.  In fact, this is easy to do, though you need to take into account that the code is optimized using the Closure Compiler, which adds work. <br><br>  The first thing you need to do is call emcc with the --pre-js option.  It adds JavaScript code before the generated code (post-js, respectively, after).  The important thing is that --pre-js adds the code <strong>before the</strong> optimization is <strong>done</strong> .  This means that the code will be optimized together with the generated code, which is necessary for correct optimization.  On the other hand, the Closure Compiler optimizer can discard the functions we need as unused. <br><br>  Here is the script that needs to be enabled using the --pre-js option: <br><pre>  Module ['preRun'] = function () {
     FS.createDataFile (
       '/',
       'test.xml',
       Module ['intArrayFromString'] (Module ['xml']),
       true
       true);
     FS.createDataFile (
       '/',
       'test.xsd',
       Module ['intArrayFromString'] (Module ['schema']),
       true
       true);
   };
   Module ['arguments'] = ['--noout', '--schema', 'test.xsd', 'test.xml'];
   Module ['return'] = '';
   Module ['print'] = function (text) {
     Module ['return'] + = text + '\ n';
   }; </pre><br>  Consider this script: <br><ul><li>  Module is the object through which the code generated using emscripten interacts with other JavaScript code. </li><li>  It is important to use string names to access the module, for example Module ['name'] instead of Module.name.  In this case, Closure will leave the name unchanged. </li><li>  The first thing you need to do is change the Module.preRun that runs right before the generated code (but after setting up the environment).  In the preRun function, two files are created using the file system API ( <a href="https://github.com/kripken/emscripten/wiki/Filesystem-Guide">Emscripten FileSystem API</a> ).  For simplicity, the same file names are used as in previous tests (test.xml and test.xsd).  The contents of these files are set to Module ['xml'] and Module ['xsd'].  These variables must contain XML and XML Schema.  Strings are converted to an array using intArrayFromString. </li><li>  Install Module.arguments - the equivalent of the argument list for the console command.  The arguments must be exactly the ones we used earlier in testing.  The only difference is that test.xml and test.xsd files will contain user data. </li><li>  Module.print is called when the code tries to invoke an operation from stdio.  We save all output to the buffer to later read it. </li></ul><br>  Thus, we have ensured that the input files test.xml and test.xsd will contain the information entered by the user, and the validation results will be saved to the buffer. <br><br>  However, this is not all.  Compile the code: <br><blockquote>  ~ / path / emscripten / emcc -O2 xmllint.o .libs / libxml2.a ../zlib-1.2.7/libz.a -o xmllint.raw.js --pre-js pre.js </blockquote><br>  The command to compile looks like before, except that we no longer need to include files.  Instead, use the --pre-js flag to include the pre.js file. <br><br>  After compiling, xmllint.raw.js contains optimized and minified code.  For ease of use, wrap it with a JavaScript function: <br><pre>  function validateXML (xml, schema) {
     var Module = {
       xml: xml
       schema: schema
     };
     {{{GENERATED_CODE}}}
     return Module.return;
   } </pre><br>  GENERATED_CODE must be replaced by the result of the compilation (xmllint.raw.js).  The validateXML function assigns the corresponding arguments to the xml and schema fields.  In this way, we ensure that the test.xml and test.xsd files contain user data.  After the generated code is executed, the function will return validation results. <br><br>  That's all!  <a href="">xml.js</a> can be used from regular JavaScript code.  All that is needed is to simply include the js-file and call the function validateXML with xml and schema. </div><p>Source: <a href="https://habr.com/ru/post/143583/">https://habr.com/ru/post/143583/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../143574/index.html">Improving the "endless scrolling"</a></li>
<li><a href="../143575/index.html">Screwing Head Up Display to MonoDevelop or how the global menu is crookedly done in Ubuntu</a></li>
<li><a href="../143577/index.html">Structuring data: what to do with the Internet?</a></li>
<li><a href="../143578/index.html">About the trolls mythical, and not very ...</a></li>
<li><a href="../143580/index.html">Finish the zombies, help the fox</a></li>
<li><a href="../143584/index.html">Displaying OpenStreetMap Maps on iPhone 4 with Retina Display Using Leaflet</a></li>
<li><a href="../143585/index.html">Samsung and Apple Patent War: 50+ lawsuits in 10 countries</a></li>
<li><a href="../143586/index.html">JavaScript Packages - jpack</a></li>
<li><a href="../143587/index.html">FBI Report on Bitcoin Cryptocurrency</a></li>
<li><a href="../143588/index.html">The ultimate success of popular finance: Pebble raised $ 10 million in one month</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>