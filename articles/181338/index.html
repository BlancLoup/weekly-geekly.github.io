<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Adding animation to the ListView</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings, colleagues, 

 Today I came to you with a short article on adding animations to the ListView when scrolling. Not long ago, I wanted to add ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Adding animation to the ListView</h1><div class="post__text post__text-html js-mediator-article">  Greetings, colleagues, <br><br>  Today I came to you with a short article on adding animations to the ListView when scrolling.  Not long ago, I wanted to add to my list an animation similar to the one that can be seen in the G + client, but a bit different. <br><br>  And I wanted to make it so that the new elements do not just appear at the bottom, but come up below and a little to the right.  In general, I did it, but later, I looked at the report of Roman Guy and Chet Haas on Google IO 2013 and got an idea to add distortion while adding realism.  This required a slightly different approach, but, in general, the concept remained the same. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let us now, in order, I will talk about what was, how it has changed, and, actually, how it all works. <br><br>  To make it clear, in general, what I mean, below is the link to the video with the final animation.  Notice how the elements are deformed when they appear.  Since the video was recorded from the emulator, there is a slight tugging, everything is perfectly smooth on the device.  Also for clarity, I increased the duration of the animation to 900ms.  Usually you want it to last 300 ms. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/BAQJ7lVfC9s%3Ffeature%3Doembed&amp;xid=25657,15700021,15700043,15700186,15700190,15700253,15700256&amp;usg=ALkJrhhEyJN0moBM4GX2gTNY6tx11krA1g" frameborder="0" allowfullscreen=""></iframe><br><br><a name="habracut"></a><br><br><h4>  Simple movement </h4><br><br>  Since we want the elements to ‚Äúpop up‚Äù when they appear at the bottom or at the top of the list, the most logical place is to add code to the getView of our adapter. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) { animatePostHc(position, v); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { animatePreHc(position, v); }</code> </pre> <br><br>  Immediately, I note that I have the main focus on ICS +, so I will continue to talk mainly about it. <br><br>  Let's take a look at the animatePostHc method; <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@TargetApi</span></span>(Build.VERSION_CODES.ICE_CREAM_SANDWICH) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animatePostHc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position, View v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prevPosition &lt; position) { v.setTranslationX(animX); v.setTranslationY(animY); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v.setTranslationX(-animX); v.setTranslationY(-animY); } v.animate().translationY(<span class="hljs-number"><span class="hljs-number">0</span></span>).translationX(<span class="hljs-number"><span class="hljs-number">0</span></span>).setDuration(<span class="hljs-number"><span class="hljs-number">300</span></span>) .setListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InnerAnimatorListener(v)).start(); }</code> </pre><br><br>  Step by step.  We determine the direction in which our list is moving and make an appropriate shift.  Next, using the new animation API, we say that we want to move to (0, 0) in 300 ms. <br><br>  We also hang a handler that does the following: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InnerAnimatorListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnimatorListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> View v; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> layerType; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InnerAnimatorListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.v = v; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Animator animation)</span></span></span><span class="hljs-function"> </span></span>{ layerType = v.getLayerType(); v.setLayerType(View.LAYER_TYPE_HARDWARE, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationRepeat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Animator animation)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Animator animation)</span></span></span><span class="hljs-function"> </span></span>{ v.setLayerType(layerType, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationCancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Animator animation)</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre><br><br>  Since we want our animation to be smooth and good, it's best to set our element to HARDWARE LAYER while it is animating.  In this case, we create a whole layer in which our component is rendered as a single texture (this can be seen by turning on, for example, the hardwarew overdraw debug mode), which greatly accelerates rendering. <br><br>  In fact, starting with Jelly Bean, exactly the same thing can be done much easier, namely, by calling the animator's method withLayer (): <br><br><pre> <code class="java hljs">v.animate().withLayer().translationY(<span class="hljs-number"><span class="hljs-number">0</span></span>).translationX(<span class="hljs-number"><span class="hljs-number">0</span></span>).setDuration(<span class="hljs-number"><span class="hljs-number">300</span></span>).setListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InnerAnimatorListener(v)).start();</code> </pre><br><br>  But we do not live in a perfect world. <br><br>  We check - yes, it works.  But ... views are always animated, even when just opening the activation.  Let's limit the appearance of animations only to the time when we really scroll our ListView. <br><br>  For this, I added the animate boolean field to my adapter.  Now we just need to hang the handler on the ListView and enable / disable animations: <br><br><pre> <code class="java hljs">listView.setOnScrollListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OnScrollListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScrollStateChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AbsListView view, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scrollState)</span></span></span><span class="hljs-function"> </span></span>{ adapter.setAnimate(scrollState == SCROLL_STATE_FLING || SCROLL_STATE_TOUCH_SCROLL == scrollState); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AbsListView view, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstVisibleItem, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visibleItemCount, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> totalItemCount)</span></span></span><span class="hljs-function"> </span></span>{ } });</code> </pre><br><br>  We try.  Now is better.  However, there is a defect.  If you let the list scroll quickly, the animation looks ugly, because the animated components simply do not have time.  It is logical in this case simply to not show the animation when the list scrolls faster than what is permitted.  So I did, but I'll write about it a little later, because first I want to tell you about adding deformations to the animation, and then about the elimination of defects. <br><br><h4>  Distortion </h4><br>  As I said, the addition of this was inspired by this <a href="http://www.youtube.com/watch%3Fv%3DihzZrS69i_s">lecture on</a> Google I / O 2013. In general, I believe that every material (video, blog post, etc.) from Roman Guy is absolutely priceless. <br><br>  In order to add a slight distortion of the list item, we need to create a custom layout.  Do not worry, I'm not saying that we need to create it from scratch, we just need to expand the existing one.  In my example, each element of the list is RelativeLayout, so I expanded it by creating the SkewingRelativeLayout class: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SkewingRelativeLayout</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RelativeLayout</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> skewX = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SkewingRelativeLayout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, AttributeSet attrs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> defStyle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(context, attrs, defStyle); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SkewingRelativeLayout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, AttributeSet attrs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(context, attrs); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SkewingRelativeLayout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(context); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (skewX != <span class="hljs-number"><span class="hljs-number">0</span></span>) { canvas.skew(skewX, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.draw(canvas); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSkewX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> skewX)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.skewX = skewX; ViewCompat.postInvalidateOnLayout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre><br><br>  We have added a skew - distortion field.  Now, we have redefined our draw method, and in it, before drawing our component, we distort the canvas. <br><br>  Replace list items with SkewingRelativeLayout. <br><br>  Now for the animation ... In order to make a synchronous distortion and movement of our element, I had to slightly change the approach to its animation: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@TargetApi</span></span>(Build.VERSION_CODES.ICE_CREAM_SANDWICH) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animatePostHc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position, View v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startSkewX = <span class="hljs-number"><span class="hljs-number">0.15f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> translationX; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> translationY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prevPosition &lt; position) { translationX = animX; translationY = animY; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { translationX = -animX; translationY = -animY; } ObjectAnimator skewAnimator = ObjectAnimator.ofFloat(v, <span class="hljs-string"><span class="hljs-string">"skewX"</span></span>, startSkewX, <span class="hljs-number"><span class="hljs-number">0f</span></span>); ObjectAnimator translationXAnimator = ObjectAnimator.ofFloat(v, View.TRANSLATION_X, translationX, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); ObjectAnimator translationYAnimator = ObjectAnimator.ofFloat(v, View.TRANSLATION_Y, translationY, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); AnimatorSet set = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnimatorSet(); set.playTogether(skewAnimator, translationXAnimator, translationYAnimator); set.setDuration(<span class="hljs-number"><span class="hljs-number">300</span></span>); set.setInterpolator(decelerator); set.addListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnimatorWithLayerListener(v)); set.start(); }</code> </pre><br><br>  using ViewPropertyAnimator was replaced by three separate ObjectAnimator'a, each of which is responsible for its value (distortion, X offset, Y offset).  So that they work synchronously and on one interpolator, we use the class AnimatorSet. <br><br>  If we now try to run it, we will see how beautifully our elements are distorted. <br><br>  One problem I encountered when working with distortion is that I had to abandon the hardware layers, because when you add distortion at the edges of the distorted component, terrible black holes appear.  I could not overcome it and removed the hardware layers.  But it seems that even without them, my Galaxy Nexus works very smoothly. <br><br><h4>  Get rid of the defect by scrolling fast </h4><br>  After a series of experiments, I came to the conclusion that in order to get rid of unwanted defects, I need to perform two points: <br><ul><li>  Disable animation when scrolling exceeds a certain speed threshold. </li><li>  Cancel all already running animations in this case. </li></ul><br><br>  The second action is necessary, because the speed limit is very thin and comes unexpectedly, which can lead to the fact that one element went to animate, and the next - no longer.  It turns out that the first is superimposed on the second.  Ugliness. <br><br>  To calculate the speed, I modified the code a bit: <br><br><pre> <code class="java hljs">listView.setOnScrollListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OnScrollListener() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> previousFirstVisibleItem = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> previousEventTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> speed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> scrollState; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScrollStateChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AbsListView view, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scrollState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scrollState = scrollState; adapter.setAnimate(scrollState == SCROLL_STATE_FLING || SCROLL_STATE_TOUCH_SCROLL == scrollState); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AbsListView view, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstVisibleItem, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visibleItemCount, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> totalItemCount)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousFirstVisibleItem != firstVisibleItem) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> currTime = System.currentTimeMillis(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> timeToScrollOneElement = currTime - previousEventTime; speed = ((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span> / timeToScrollOneElement) * <span class="hljs-number"><span class="hljs-number">1000</span></span>; previousFirstVisibleItem = firstVisibleItem; previousEventTime = currTime; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scrollState == SCROLL_STATE_FLING &amp;&amp; speed &gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) { adapter.setAnimate(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); adapter.cancelAnimations(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { adapter.setAnimate(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } } } });</code> </pre><br><br>  As you can see, now when exceeding a certain threshold of speed (matched to the eye), we disable animation and cancel all animations.  I repeat that the magic number 16 is picked up by me and works in my case, but it depends on the size of the elements of your list, so it‚Äôs better not to hardcode it. <br><br>  In the adapter, I add a method: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancelAnimations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = anims.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { anims.get(i).cancel(); } }</code> </pre><br><br>  And I modify listener animations.  In the final version, it looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnimatorWithLayerListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnimatorListener</span></span></span><span class="hljs-class"> </span></span>{ View view; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimatorWithLayerListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View view)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.view = view; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Animator animation)</span></span></span><span class="hljs-function"> </span></span>{ ViewCompat.setHasTransientState(view, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Animator animation)</span></span></span><span class="hljs-function"> </span></span>{ ViewCompat.setHasTransientState(view, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); anims.remove(animation); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationCancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Animator animation)</span></span></span><span class="hljs-function"> </span></span>{ view.setTranslationX(<span class="hljs-number"><span class="hljs-number">0</span></span>); view.setTranslationY(<span class="hljs-number"><span class="hljs-number">0</span></span>); ((SkewingRelativeLayout) view).setSkewX(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationRepeat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Animator animation)</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre><br><br>  Now, when you cancel the animation, we instantly remove all offsets and distortions.  Immediately, it is worth noting that the onAnimationEnd method is always invoked: when canceled, and during normal termination.  Therefore, it makes no sense to duplicate what is in it for cancellation. <br><br>  It is also important that we set the ViewCompat.setHasTransientState (view, false); flag to our element.  This flag, starting with ICS, allows you to mark an item in the list as modifiable, and the ListView will take this into account in the internal view reuse.  ViewPropertyAnimator does it for us, but in the case of ObjectAnimator we need to do it with our hands. <br><br><h4>  Backwards Compatibiliy </h4><br>  Since we are good people and do not want to lose 39% of our users, we want to somehow please and Android 2.3 users.  I did not ask myself about the task of fully porting the solution, so I just made an alternative method that uses the old animation API. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animatePreHc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position, View v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prevPosition &lt; position) { v.clearAnimation(); v.startAnimation(AnimationUtils.loadAnimation(context, R.anim.pop_from_bottom)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v.clearAnimation(); v.startAnimation(AnimationUtils.loadAnimation(context, R.anim.pop_from_top)); } }</code> </pre><br><br>  And if I had set myself this goal, I most likely would simply use the <a href="https://github.com/JakeWharton/NineOldAndroids">JakeWharton NineOldAndroids</a> library, which is a quality backport of animation APIs up to version 1.6. <br><br><h4>  Conclusion </h4><br>  As always, I do not pretend to the absolute universality and impeccability of what I describe, but in my case it works very well, and I just want to share it. <br>  Perhaps if you have a very long list (I have a maximum of 10 items typed there), you will have to take an extra.  actions to minimize the creation of objects in getView.  Since AnimatorSet can be reused, it seems to me that some intelligent pool of objects can be organized, but this is all beyond what I wanted to tell you, dear colleagues, so let me bow for this. <br><br>  Z. Y.  if someone wants more complete sources, ask in the comments how time will be, I will drink this piece from the project and put it on github, although 95% of what needs to be done is reflected in this article. </div><p>Source: <a href="https://habr.com/ru/post/181338/">https://habr.com/ru/post/181338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../181328/index.html">Laravel 4 released</a></li>
<li><a href="../181330/index.html">GlacierWorks and Microsoft have created an interactive site on Everest</a></li>
<li><a href="../181332/index.html">How to beat Candy Crush Saga</a></li>
<li><a href="../181334/index.html">The Ministry of Culture proposes to fine users of file-sharing networks for 5000 rubles</a></li>
<li><a href="../181336/index.html">Arduino: Automatic staircase lighting</a></li>
<li><a href="../181342/index.html">Using artificial immune systems to solve symbolic regression</a></li>
<li><a href="../181344/index.html">A little more about 2D graphics for Android</a></li>
<li><a href="../181350/index.html">Warner Bros. and NBC Universal demanded the removal of the address of the file hosting Mega from the Google search results</a></li>
<li><a href="../181354/index.html">Scalable networks in Openstack. Part 2: VlanManager</a></li>
<li><a href="../181356/index.html">Fundamental problems of the economy on Bitcoin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>