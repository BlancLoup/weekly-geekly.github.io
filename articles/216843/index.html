<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We start to study Cortex-M on the example of STM32</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is the first in the planned cycle of articles on the study of programming microcontrollers. Studying various materials, I noted that almo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We start to study Cortex-M on the example of STM32</h1><div class="post__text post__text-html js-mediator-article">  This article is the first in the planned cycle of articles on the study of programming microcontrollers.  Studying various materials, I noted that almost all of them begin with the fact that the beginner is invited to download (or use the library with the development environment) to work with peripheral devices and use it to write their first program (usually blinking LED). <br><br>  I was very surprised.  If you believe these articles, for programming it is not necessary even to read the documentation for the programmable controller.  I was taught the tricks of <i>‚Äúiron programming‚Äù in a</i> completely different way. <br><br>  In this article, the path from the phrase ‚ÄúYes, I want to try!‚Äù To a joyful wink of a LED, will be much longer than that of other authors.  I will try to reveal the aspects of microcontroller programming that hide behind the use of library functions and ready-made examples. <br>  If you intend to seriously study the programming of microcontrollers, this article is for you.  Perhaps it may interest those who have played enough with the Arduino and want to get their hands on all the hardware capabilities of iron. <br><a name="habracut"></a><br><h4>  Microcontroller selection </h4><br>  Many may say that it‚Äôs better to start learning microcontrollers with AVR, PIC, 8051 or something else.  The issue is multifaceted and controversial.  I know enough examples when people studied Cortex-M, programmed AVR, ARM7, etc.  I myself began with the Cortex-M3.  If you are faced with a specific task, there is a lot of information on the Internet comparing various types of microcontrollers and the problems solved with their help.  On Habr√©, this question was also raised, for example, <a href="http://habrahabr.ru/post/120611/">here</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We assume that we figured out the type of microcontroller.  But the market presents a huge range of different modifications from different manufacturers.  They differ in many parameters - from the size of flash memory to the number of analog inputs.  For each task, the choice should be made individually.  There are no general recommendations and there can not be.  I will only note that it is worth starting a study with MC manufacturers having as large a range as possible.  Then, when choosing an MC for a specific task, there is a great enough chance that from the presented assortment something will suit you. <br><br>  I chose <b>STM32</b> (although I think it is better to start studying with MK from Texas Instruments - the documentation is very well written), because they are widespread among Russian electronics developers.  If you have problems and questions, you can easily find solutions on the forums.  Another advantage is a rich selection of demo boards from both the manufacturer and third-party organizations. <br><br><h4>  What is needed to learn? </h4><br>  Unfortunately, to start programming MK is not enough just one PC.  We'll have to get a demo board and programmer somewhere.  <s>Although this reduces competition in the labor market.</s> <br><br>  I myself use the <a href="http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1199/PF250374"><b>STM3220G-EVAL</b></a> demo board and the <a href="http://segger.com/jlink-pro.html"><b>J-Link PRO</b></a> programmer.  But for a start, it will be quite enough <a href="http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/PF252419"><b>STM32F4DISCOVERY</b></a> , which can be bought without any problems for a small amount. <br><br>  All examples will be exactly for the <b>STM32F4DISCOVERY</b> debug board.  At this stage, it will not matter to us that this motherboard is based on the MK Cortex-M4 core.  In the near future, we will not use its features and advantages over the Cortex-M3.  And what will happen next - we'll see. <br><br>  If you have any other motherboard based on STM32F2xx / STM32F4xx, you can work with it.  In the presentation of the material, I will try to describe in as much detail as possible <i>why</i> we are doing this way and not otherwise.  I hope no one will have problems with the transfer of examples to another iron. <br><br><h4>  Development environment </h4><br>  As already mentioned several times, for ARM microcontrollers there are a sufficient number of development environments, both paid and not so.  And again I want to omit the controversy about this.  I am using <a href="http://www.iar.com/Products/IAR-Embedded-Workbench/ARM/">IAR Embedded Workbench for ARM 6.60</a> .  All examples will be in this environment.  If you like (or is used in your organization) something else (Keil, Eclipse, CCS, CooCoc, etc.) then this also does not hurt you much.  On the features associated with the development environment, I will pay special attention. <br><div class="spoiler">  <b class="spoiler_title">Why a paid development environment?</b> <div class="spoiler_text">  Maybe someone will not be quite happy with the fact that I propose to use a paid development environment, but in IAR <a href="http://supp.iar.com/Download/SW/%3Fitem%3DEWARM-EVAL">there is an opportunity</a> to get a temporary license without functional limit, or an unlimited license with restriction on code size (32KB for MK is a lot). <br>  In addition, I immediately note that for some of the MK there are no free development environments.  And unfortunately, these MC in some areas are irreplaceable. <br></div></div><br>  I will not describe the installation process. <br><br><h4>  Where to begin? </h4><br><h5>  Project creation </h5><br>  First, create an empty project.  IAR allows you to create projects on ASM, C and C ++.  We will use C. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3e/820/16e/d3e82016e09453f89bebf8bda7d79c46.png"><br><br>  An empty project with a main file will appear in front of us. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a8/9ba/175/4a89ba1755e17eed7c304b04339fdcf5.png"><br><br>  Now you need to configure the project to start working with "our" MK and debugger.  The STM32F4DISCOVERY is installed on the MK <b>STM32F407VG</b> .  It must be selected in the project properties (General Options-&gt; Target-&gt; Device): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/444/716/7bd/4447167bd37ccd6b0295e53c1e687315.png"><br><br>  When a target programmable processor is selected, its description is loaded, which provides ample opportunities for debugging (this will be discussed below).  In addition, a configuration file is automatically attached with a description of the available address space for the linker.  If necessary, we will touch on the topic of the linker configuration file in the following articles. <br><br>  After that, you need to configure the debugger.  Debugging of the program takes place directly "in the gland".  This is done using the JTAG debugger.  You can learn more about how this happens on <a href="http://en.wikipedia.org/wiki/Joint_Test_Action_Group">Wikipedia</a> .  The ST-LINK / V2 debugger is integrated into the STM32F4DISCOVERY board.  To work with a debugger, it is necessary to select its driver in the menu <i>Debugger-&gt; Setup-&gt; Driver</i> .  It is also necessary to indicate that debugging should be done directly in the hardware.  To do this, check the <i>Debugger-&gt; Download-&gt; Use flash loader (s)</i> flag <br><img src="https://habrastorage.org/getpro/habr/post_images/e1d/c6a/5d4/e1dc6a5d430eb802d34decc0a9dc4706.png"><br><div class="spoiler">  <b class="spoiler_title">For those who saw the word Simulator</b> <div class="spoiler_text">  Theoretically, IAR allows you to debug programs using a simulator.  But I have never met him in practice. <br></div></div><br><br>  Now the project is ready for work (programming, pouring and debugging). <br><br><h5>  "TZ" for the first project </h5><br>  <i>Let's summarize the intermediate result: the</i> MC and the debug board are selected, the project is prepared.  It's time to decide on the task. <br><br>  We will not move away from the classics.  The first project will be a flashing LED.  Fortunately there are plenty of them on the board. What does this mean in terms of programming?  First of all, it is necessary to study the schematic diagram of the demo board and understand how the LED ‚Äústarts‚Äù. <br>  <a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM00039084.pdf">User manual</a> is available on the manufacturer's website.  In this description there is even a separate section on the LEDs on the board - <b>4.4 LEDs</b> .  For example, we will use <i>User LD3</i> .  Find it on the scheme: <br><img src="https://habrastorage.org/getpro/habr/post_images/493/b19/cc0/493b19cc0293f2294babdec8db907d40.png"><br><br>  The simplest analysis of the circuit suggests that in order to ‚Äúlight up‚Äù the LED it is necessary to submit a ‚Äú1‚Äù to the MK pin (which for a given MK corresponds to 3.3V).  Off is made by applying to this pin "0".  In the diagram, this pin is designated <b>PD13</b> (this is probably the most important information from this document). <br><br>  <b>As a result, we can write "TZ" for our first program:</b> <br>  <i>The program for MK should transfer the pin state of the MK PD13 from the state ‚Äú0‚Äù to the state ‚Äú1‚Äù and back with a certain periodicity visible to the human eye (an important note if you blink the LED too often the eye can not distinguish it).</i> <br><br><h5>  Before you start programming, or a little theory </h5><br>  Before proceeding with the implementation of our TK, it is necessary to understand how MK is managed. <br><br>  To begin with, any MK includes the core, memory, and peripheral blocks.  I think that everything is clear with memory.  I will only mention, in STM32 there is a flash memory in which the MK program is stored (in general, this is not a true statement, the program can be stored in external non-volatile memory, but for now we‚Äôll omit it) and other data, including user data.  There is also <a href="http://ru.wikipedia.org/wiki/SRAM_(%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C)">SRAM</a> - RAM. <br><br>  The kernel is the part of the microcontroller that executes one command flow.  In our MK core type - Cortex-M4.  Kernel MK can be compared with the processor in the PC.  It can only execute commands and transfer data to other units (this comparison does not take into account processors with integrated graphics accelerators). <br>  In this case, the manufacturer MK does not develop the kernel.  The core is purchased from <a href="http://ru.wikipedia.org/wiki/ARM_(%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">ARM Limited</a> .  The main difference between different MK - in the periphery. <br><br>  Peripheral blocks are blocks that interact with the "outside world" or perform specific functions that are inaccessible to the MC kernel.  Modern MK (including STM32) contain a huge range of peripheral blocks.  Peripheral units are designed to solve various tasks, from reading the voltage value from the analog input of the MC to data transmission to external devices via the SPI bus. <br>  Unlike the MK core, the peripheral units do not follow the instructions.  They only execute kernel commands.  In this case, the participation of the kernel when executing a command is not required. <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text">  As an example, you can take the UART block, which is designed to receive and transmit data from the MC to external devices.  From the core, it is only necessary to configure the block and give it the data for transmission.  After that, the kernel can continue to follow the instructions.  On the shoulders of the peripheral unit, the management of the corresponding output of the MC for data transmission in accordance with the protocol rests.  The peripheral unit itself translates the output of the MK to the required state "0" or "1" at the right time, making the transfer. <br></div></div><br><br><h6>  The interaction of the core with the peripheral unit </h6><br>  The interaction of the MK core with the peripheral unit is carried out with the help of special registers (there is still interaction through the interrupt mechanism and DMA, but more on that in the following posts).  From the point of view of the kernel, this is simply a chunk of memory with a specific address, <b>only this is not true</b> .  Writing data to a special register is equivalent to transmitting a command or data to a peripheral block.  Read - receive data from a block or read its state.  The description of peripheral blocks and their special registers takes the lion's share of the MC description. <br><br>  <b>IMPORTANT:</b> After writing data to a special register and subsequent reading, you can get completely different data.  For example, data transfer to a UART block for sending, and reading data received by a block from an external device, is performed using the same register. <br><br>  Special registers are usually divided into bit fields.  One (or several) bits control a specific parameter of the peripheral block, usually independently.  For example, different bits of the same register control the state of different outputs of the MC. <br><br><h6>  Remembering C </h6><br>  If you are a C language guru, feel free to skip this section.  It is intended primarily for those who have been taught (or who learned himself) to program for the PC.  Experience shows that people often do not remember important teams.  Here I will briefly remind you about bitwise operations and work directly with memory at its address. <br><br>  <b>Data recording by address in memory</b> <br><br>  Suppose that reading the description of the peripheral unit, we realized that for its correct operation it is necessary to write the number 0x3B into it.  Special register address 0x60004012.  The register is 32-bit. <br>  If you do not immediately know how to do this, I will try to describe the chain of reasoning to get the right command. <br><br>  The value 0x60004012 is nothing but the value of the pointer to the memory cell.  It is necessary to indicate this in our program, ie, to do type conversion according to the syntax of the C language: <br><br><pre><code class="cpp hljs">(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)(<span class="hljs-number"><span class="hljs-number">0x60004012</span></span>)</code> </pre> <br><br>  Thus, we have a pointer to an element.  Now we need to write the required value to this element.  This is done by dereferencing the pointer.  Thus we get the right command: <br><br><pre> <code class="cpp hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)(<span class="hljs-number"><span class="hljs-number">0x60004012</span></span>) = <span class="hljs-number"><span class="hljs-number">0x3B</span></span>;</code> </pre> <br><br>  <b>Setting arbitrary bits to 1</b> <br><br>  Suppose that you need to set "1" to 7 and 1 bits at 0x60004012, while not changing the value of all other bits in the register.  To do this, you must use a binary operation |.  Immediately give the correct answer: <br><br><pre> <code class="cpp hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)(<span class="hljs-number"><span class="hljs-number">0x60004012</span></span>) |= <span class="hljs-number"><span class="hljs-number">0x82</span></span>;</code> </pre> <br><br>  Pay attention to 2 facts.  Bits are counted from zero, not from the first.  This operation actually takes not less than 3 clocks - reading a value, modifying, writing.  Sometimes this is not permissible, since between reading and writing the value of one of the bits that we are forbidden to change could be changed by the peripheral block.  Do not forget about this feature, otherwise bugs can get, which are extremely difficult to catch. <br><br>  <b>Setting arbitrary bits to 0</b> <br><br>  Suppose you need to set ‚Äú0‚Äù to 7 and 1 bits at 0x60004012, while not changing the value of all the other bits in the register.  To do this, you must use the binary operation &amp;.  Immediately give the correct answer: <br><br><pre> <code class="cpp hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)(<span class="hljs-number"><span class="hljs-number">0x60004012</span></span>) &amp;= <span class="hljs-number"><span class="hljs-number">0xFFFFFF7D</span></span>;</code> </pre> <br><br>  Or its simpler writing (don't worry about the extra operation, the compiler will calculate everything in advance even with minimal optimization): <br><br><pre> <code class="cpp hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)(<span class="hljs-number"><span class="hljs-number">0x60004012</span></span>) &amp;= (~<span class="hljs-number"><span class="hljs-number">0x82</span></span>);</code> </pre> <br><h6>  Some features of programs for MK </h6><br>  Here I will try to describe some features of the programs for the MC, which is important to remember.  Things are pretty obvious, but still. <br>  <i>The program has no end</i> <br>  In difference from the majority of programs for the PC, the program for MK should not end, NEVER!  And what exactly MK should do after the completion of your program?  The question is practically rhetorical.  Therefore, do not forget to make sure that you do not forget the eternal cycle.  If desired, you can put the MK in sleep mode. <br>  <i>Use integer variables</i> <br>  Despite the fact that we use the MK with the core Cortex-M4, which hardware performs operations on floating-point numbers, I advise you to abandon their use.  In MK without the support of such operations, the computation time will be simply huge. <br>  <i>Avoid dynamic memory allocation</i> <br>  This is just a tip.  The reason is simple - there is little memory.  I have repeatedly met with libraries in which there were ‚Äúslow leaks‚Äù of memory.  It was very unpleasant when, after several weeks of stable operation, the MK hung up with an error.  It is better to think in advance about the architecture of your program so that you don‚Äôt have to use dynamic memory allocation. <br>  If you still want to use - carefully study the work of the memory manager or write your own. <br><br><h4>  Getting started! </h4><br>  Work on the program for MK always begins with reading the documentation.  For our MK <a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/reference_manual/DM00031020.pdf">Reference manual</a> is available on the manufacturer's website.  There are many pages, but you don‚Äôt need to read everything <i>yet</i> .  As already mentioned, most of the documentation is a description of the peripheral blocks and their registers.  I also want to draw attention to the fact that this Reference Manual was written not for one MK, but for several lines.  This suggests that the code will be portable when switching to other MCs in these lines (unless of course you try to use peripheral blocks that are not in the used MC). <br><br>  First of all, you need to decide which blocks to work with.  For this, it is enough to study the sections of the <i>Introduction</i> and <i>Main features</i> . <br><br>  Direct control of the state of the MK pins is performed using a GPIO block.  As stated in the documentation in the MK STM32 there can be up to 11 independent GPIO blocks.  Various GPIO peripheral blocks are called ports.  Ports are designated by letters from A to K. Each port can contain up to 16 pins.  As we noted earlier, the LED is connected to the PD13 pin.  This means that this pin is controlled by the GPIO peripheral block port D. Pin number is 13. <br><br>  No other peripheral blocks are needed this time. <br><br><h5>  Control peripheral clocking </h5><br>  To reduce the power consumption of the MK, almost all peripheral blocks are switched off after turning on the MK.  Switching on / off the block is performed by applying / stopping the clock signal to its input.  For correct operation, it is necessary to configure the MK clock signal controller so that a clock signal is supplied to the necessary peripheral unit. <br>  <b>Important: The</b> peripheral unit cannot start operation <b>immediately</b> after the clock signal is turned on.  It is necessary to wait several cycles until it ‚Äústarts‚Äù.  People who use libraries for peripherals often don‚Äôt even know about this feature. <br><br>  Registers <i>RCC XXX peripheral clock enable register</i> are responsible for turning on the clocking of peripheral blocks. AHB1, AHB2, AHB3, APB1 and APB2 buses can stand in the place of XXX.  After a careful study of the description of the relevant registers, it can be concluded that the clocking of the GPIOD peripheral unit is enabled by setting ‚Äú1‚Äù to the third bit of the <i>RCC AHB1 peripheral clock enable register register (RCC_AHB1ENR)</i> : <br><img src="https://habrastorage.org/getpro/habr/post_images/6d2/725/a24/6d2725a244894d73ae7ae05719ca26c0.png"><br><br>  Now you need to figure out how to find out the address of the register <i>RCC_AHB1ENR</i> . <br><br>  <i>Note: The</i> description of the system clocking MK STM32 worthy of a separate article.  If readers have a desire, I will cover this section in more detail in one of the following articles. <br><br><h5>  Determination of special register addresses </h5><br>  Determination of addresses of special registers should be started from reading the section <i>Memory map</i> in Reference manual.  You may notice that each block is allocated its own part of the address space.  For example, for an RCC block, this section is 0x4002 3800 - 0x4002 3BFF: <br><img src="https://habrastorage.org/getpro/habr/post_images/a8c/8f9/c75/a8c8f9c75f9888b03f21c4158e330fea.png"><br><br>  Following the link to the <i>Register map</i> of the <i>RCC</i> block we find the line with the register <i>RCC_AHB1ENR of</i> interest to us: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f26/3b6/bec/f263b6bec6b6381384e824be06b7a677.png"><br><br>  To get the address of the register, you must add <i>Addr</i> to the initial value of the address space of the RCC block <i>.</i>  <i>offset of the</i> desired register.  <i>Addres offset</i> is also indicated in the register description (see screenshot above). <br><br>  As a result, we determined the address of the register <i>RCC_AHB1ENR</i> - 0x4002 3830. <br><br><h5>  GPIO block </h5><br>  For general acquaintance with the GPIO unit, I strongly recommend to fully read the relevant section of the Reference Manual.  While you can not really pay attention to the <i>Alternate mode</i> .  This will be left for later. <br><br>  Now our task is to learn how to manage the state of the pin MK.  Let's go straight to the description of the GPIO registers. <br><br><h6>  Operation mode </h6><br>  First of all, it is necessary to set the operation mode of pin 13 of port D as <i>General purpose output mode</i> , which means that the GPIO block will control the state of pin MK.  The mode of operation of the MK pins is <i>controlled</i> by the register <i>GPIO port mode register (GPIOx_MODER) (x = A..I / J / K)</i> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e09/458/105/e0945810527691aecf2c9064e3e8893b.png"><br><br>  As can be seen from the description, in order to make the required settings, we need to write the value 01b to 26-27 bits of the <i>GPIOx_MODER</i> register.  Address register can be determined by the same method as described above. <br><br><h6>  Setting the parameters of the output pins of the GPIO port </h6><br>  The GPIO block allows you to apply additional settings for the output pin ports.  These settings are made in the registers: <br><ul><li>  <i>GPIO port output type register (GPIOx_OTYPER)</i> - set the type of output push-pull or open-drain </li><li>  <i>GPIO port output speed register (GPIOx_OSPEEDR)</i> - set the speed of the output </li></ul><br>  We will not change these parameters, since we are quite satisfied with the default values. <br><br><h6>  Setting the value on the pin MK </h6><br>  Finally, we come to the moment of controlling the state of the output of the MC.  There are two methods for setting the output value on a certain MK pin. <br><br>  <i>Use the register GPIO port bit set / reset register (GPIOx_BSRR)</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/abb/e3c/58c/abbe3c58ce5508c4524b9c3d5b278cae.png"><br><br>  Writing ‚Äú0‚Äù or ‚Äú1‚Äù in bits 0-16 results in a corresponding change in the state of the port pins.  In order to set a certain value at the output of one or several pins of the MK and not change the states of the others, it will be necessary to use the operation of modifying individual bits.  Such an operation is performed at least 3 cycles.  If it is necessary to record 1 in part of bits, and in other 0, then at least 4 cycles will be needed.  This method is preferable to use to change the state of output to the opposite, if its initial state is not known. <br><br>  <i>GPIO port bit set / reset register (GPIOx_BSRR)</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13c/765/1c8/13c7651c8f2fabc30ec843c9a45d11a6.png"><br><br>  Unlike the previous method, writing 0 to any of the bits in this register does not lead to anything (and indeed, all the bits are write-only!).  Writing 1 to bits 0-15 will result in setting ‚Äú1‚Äù at the corresponding MK output.  Writing 1 to bits 16-31 will result in setting ‚Äú0‚Äù at the corresponding output of the MC.  This method is preferable to the previous one if it is necessary to set a certain value on the ‚ÄúMK‚Äù pin, and not to change it. <br><br><h5>  Light the LED! </h5><br>  Finding the addresses of all the necessary registers, you can write a program that includes the LED: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//Enable port D clocking *(unsigned long*)(0x40023830) |= 0x8; //little delay for GPIOD get ready volatile unsigned long i=0; i++; i++; i++; i=0; //Set PD13 as General purpose output *(unsigned long*)(0x40020C00) = (*(unsigned long*)(0x40020C00)&amp; (~0x0C000000)) | (0x04000000); //Turn LED ON! *(unsigned long*)(0x40020C14) |= 0x2000; while(1); }</span></span></code> </pre><br>  You can compile ( <i>Project-&gt; Compile</i> ) and upload ( <i>Project-&gt; Download-&gt; Download active application</i> ).  Or, start debugging ( <i>Project-&gt; Dpwnload and Debug</i> ) and start execution (F5). <br>  The LED is on fire! <br><br><h5>  Blink LED </h5><br>  The flashing of the LED is nothing but alternate on and off with a delay between these actions.  The easiest way is to put the on and off in an eternal cycle, and insert a delay between them. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//Enable port D clocking *(unsigned long*)(0x40023830) |= 0x8; //little delay for GPIOD get ready volatile unsigned long i=0; i++; i++; i++; i=0; //Set PD13 as General purpose output *(unsigned long*)(0x40020C00) = (*(unsigned long*)(0x40020C00)&amp; (~0x0C000000)) | (0x04000000); while(1) { //Turn LED ON *(unsigned long*)(0x40020C14) |= 0x2000; //Delay for( i=0; i&lt;1000000 ;++i ); //Turn LED OFF *(unsigned long*)(0x40020C14) &amp;= ~0x2000; //Delay for( i=0; i&lt;1000000 ;++i ); } }</span></span></code> </pre><br>  The value of 1,000,000 in the delay was chosen experimentally so that the blinking period of the LED could be distinguished by the eye, but it would not be too long either. <br><br><h5>  We optimize the algorithm </h5><br>  The disadvantage of the chosen approach by the blinking LED is that the MK core spends most of the time in empty cycles, although it could do something useful (in our example, there are no other tasks, but in the future they will appear). <br><br>  In order to avoid this, a loop counter is usually used, and the state of the pin MK is switched when a certain number of cycles pass through the program. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//Enable port D clocking *(unsigned long*)(0x40023830) |= 0x8; //little delay for GPIOD get ready volatile unsigned long i=0; i++; i++; i++; i=0; //Set PD13 as General purpose output *(unsigned long*)(0x40020C00) = (*(unsigned long*)(0x40020C00)&amp; (~0x0C000000)) | (0x04000000); while(1) { i++; if( !(i%2000000) ) { //Turn LED ON *(unsigned long*)(0x4002014) |= 0x2020; } else if( !(i%1000000) ) { //Turn LED OFF *(unsigned long*)(0x4002014) &amp;= ~0x2000; } } }</span></span></code> </pre><br>  But even here it will not be without problems, with a change in the number of commands executed within the cycle, the period of blinking by the LED will change (or the period of execution of other commands in the cycle).  But at this stage we cannot fight it. <br><br><h5>  Something about debugging </h5><br>  IAR allows you to debug an application directly in the gland.  Everything looks almost the same as debugging a PC application.  There is a step-by-step mode, entering a function, viewing the value of variables (In debug mode, <i>View-&gt; Watch-&gt; Watch1 / 4</i> ). <br><br><img src="//habrastorage.org/files/31b/21c/bfc/31b21cbfcbe34a0f9352a0b5540b614e.PNG"><br><br>  But besides this, there is the possibility of viewing the values ‚Äã‚Äãof the core registers, special registers of peripheral blocks (View-&gt; Register), etc. <br>  I strongly recommend that you familiarize yourself with the debugger features while learning the MK programming. <br><br><h4>  A few words in conclusion </h4><br>  Probably, many will say that it‚Äôs not correct to manually enter addresses into the program, since the manufacturer provides files with definitions of registers and bit fields, libraries for working with peripherals, and other tools that make life easier for the developer.  I completely agree with this, but I still think that the first steps in programming MK should be done by digging up the documentation for manually, independently determining the necessary registers and bit fields.  In the future, this can not be used, but you need to be able to necessarily. <br>  I will give just a few reasons for this statement: <br><ul><li>  Sometimes there are errors in libraries from the manufacturer!  Once I almost ripped off the project due to this.  I re-soldered the chip several times, thinking a hundred had damaged the crystal during soldering (before this happened).  And the problem was that the address of the special register was incorrectly registered in the library.  Usually this happens with MK or MK lines only to those who have entered the market. <br></li><li>  Libraries for the operation of some manufacturers of the periphery do not realize all the capabilities of peripheral units.  This is especially the sin of <i>Luminary Micro</i> , which was later bought out by TI.  I had to write the initialization of the periphery manually. <br></li><li>  Many get used to start programming MK with the study of examples.  I believe that first it is necessary to determine the fact that allows you to implement MK.  This can only be understood by reading the documentation.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If something is not in the examples, this does not mean that iron does not support it. </font><font style="vertical-align: inherit;">The latest example is hardware support for PTP STM32. </font><font style="vertical-align: inherit;">Of course, you can find something online, but this is not included in the standard set from the manufacturer</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The drivers of peripheral blocks of some manufacturers are not so optimized that up to 20 clocks are spent on switching the state of a pin by means of the library. </font><font style="vertical-align: inherit;">This is a luxury for some tasks.</font></font><br></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to everyone who read my post, it turned out much more than I expected at the beginning. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waiting for your comments and reasoned criticism. </font><font style="vertical-align: inherit;">If the reader has a desire, I will try to continue the cycle of articles. </font><font style="vertical-align: inherit;">Maybe someone has ideas about topics that would be worth highlighting - I would be glad to hear them.</font></font></div><p>Source: <a href="https://habr.com/ru/post/216843/">https://habr.com/ru/post/216843/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../216829/index.html">10 slideshows with AgileDays 2014</a></li>
<li><a href="../216831/index.html">VK Friendly Link Analysis with Wolfram Mathematica</a></li>
<li><a href="../216833/index.html">Where "soap" in WPF comes from and how to deal with it</a></li>
<li><a href="../216837/index.html">Devise: login and registration in modal windows</a></li>
<li><a href="../216839/index.html">The colors and the difference between them in LESS / Sass</a></li>
<li><a href="../216845/index.html">Search for solutions for games with words. Boron application</a></li>
<li><a href="../216849/index.html">Setting up the development environment for OpenStack</a></li>
<li><a href="../216851/index.html">We control the machine via Bluetooth from a tablet or phone for Android</a></li>
<li><a href="../216853/index.html">Gateway between IRC and Google Hangouts</a></li>
<li><a href="../216857/index.html">Synchronization in Android applications. Part two</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>