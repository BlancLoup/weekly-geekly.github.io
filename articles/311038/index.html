<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Smart pointer for Pimpl</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pimpl (pointer to implementation, pointer to implementation) is a useful idiom common in C ++. This idiom has several positive aspects, however, in th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Smart pointer for Pimpl</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/ecb/cc1/5b2/ecbcc15b2ab1449c81397c079133c290.png"></div><br><p>  Pimpl (pointer to implementation, pointer to implementation) is a useful idiom common in C ++.  This idiom has several positive aspects, however, in this article it is considered only as a means of reducing the dependencies of the compilation time.  More information about the idiom itself can be found, for example, <a href="http://en.cppreference.com/w/cpp/language/pimpl">here</a> , <a href="https://habrahabr.ru/post/118010/">here</a> and <a href="https://habrahabr.ru/post/111602/">here</a> .  This article is about what a smart pointer to use when working with Pimpl and why it is needed. </p><a name="habracut"></a><br><p>  Consider the various options for implementing Pimpl: </p><br><h3>  Bare pointer </h3><br><p>  The easiest way, which many probably saw, is to use a bare pointer. </p><br><p>  Usage example: </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// widget.h class Widget { public: Widget(); ~Widget(); //... private: struct Impl; Impl* d_; }; // widget.cpp struct Widget::Impl { /*...*/ }; Widget::Widget(): d_(new Impl) {} Widget::~Widget() { delete d_; }</span></span></code> </pre> <br><p>  <b>Pros:</b> </p><br><ul><li>  no extra entities needed </li></ul><br><p>  <b>Minuses:</b> </p><br><ul><li>  the need to explicitly delete the pointer (no one can tell about a possible memory leak) </li><li>  not safe with respect to exceptions (if an exception occurs in the constructor after creating an Impl, a memory leak will occur) - in general, this is the main reason why you should use a smart pointer. </li></ul><br><h3>  Using <a href="http://en.cppreference.com/w/cpp/memory/auto_ptr">std :: auto_ptr</a> </h3><br><p>  Immediately it should be noted that auto_ptr is already prohibited and should not be used.  However, it is important to note its advantages over the bare pointer, as well as the problems associated with Pimpl. </p><br><p>  Usage example: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// widget.h class Widget { // ...   struct Impl; std::auto_ptr&lt;Impl&gt; d_; }; // widget.cpp struct Widget::Impl { /*...*/ }; Widget::Widget(): d_(new Impl) {} Widget::~Widget() {}</span></span></code> </pre> <br><p>  auto_ptr, like other smart pointers from the standard library, takes responsibility for managing the pointer lifetime.  Using the <a href="http://en.cppreference.com/w/cpp/language/raii">RAII</a> idiom, auto_ptr allows you to work with Pimpl safely with respect to exceptions, since when an exception occurs, its destructor is called, which frees the memory. </p><br><p>  Despite the automatic release of memory, auto_ptr has a very dangerous property when working with Pimpl.  When executing this code, surprisingly many will leak memory without any warnings: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// widget.h class Widget { public: Widget(); //...   private: struct Impl; std::auto_ptr&lt;Impl&gt; d_; }; // widget.cpp struct Widget::Impl { /*...*/ }; Widget::Widget(): d_(new Impl) {}</span></span></code> </pre> <br><p>  This is due to the fact that auto_ptr will delete the incomplete class.  More details on this issue can be found <a href="http://www.bnikolic.co.uk/blog/cpp-checked-delete.html">here</a> .  Since this problem does not only apply to auto_ptr, it is strongly recommended that you read and understand this issue.  The brief solution to the problem in this situation is the explicit declaration and definition of the destructor. </p><br><p>  <b>Pros:</b> </p><br><ul><li>  safe with exceptions </li></ul><br><p>  <b>Minuses:</b> </p><br><ul><li>  is prohibited </li><li>  possible memory leak when deleting an incomplete class <br><br></li></ul><br><h3>  Using <a href="http://ru.cppreference.com/w/cpp/memory/unique_ptr">std :: unique_ptr</a> </h3><br><p>  In C ++ 11, move semantic appeared, which allowed auto_ptr to be replaced by a smart pointer with the expected unique_ptr behavior. </p><br><p>  Usage example: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// widget.h class Widget { // ...   struct Impl; std::unique_ptr&lt;Impl&gt; d_; }; // widget.cpp struct Widget::Impl { /*...*/ }; Widget::Widget(): d_(std::make_unique&lt;Impl&gt;()) {} Widget::~Widget() {}</span></span></code> </pre> <br><p>  unique_ptr solves the problem of deleting an incomplete class when checking for completeness at the compilation stage.  Now silently delete the incomplete class will not work. </p><br><p>  However, to solve the problem, unique_ptr still has the disadvantage that it has the semantics of a regular pointer.  Consider an example: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// widget.h class Widget { public: // ...   void foo() const; // &lt;-   private: struct Impl; std::unique_ptr&lt;Impl&gt; d_; }; // widget.cpp struct Widget::Impl { int i = 0; }; Widget::Widget(): d_(std::make_unique&lt;Impl&gt;()) {} Widget::~Widget() {} void Widget::foo() const { d_-&gt;i = 42; // &lt;-      }</span></span></code> </pre> <br><p>  In most cases, the compilation of such code is undesirable. </p><br><p>  Although the pointer is used in the idiom Pimpl, the data it points to have semantics of belonging to the original class.  From the point of view of logical constancy, all data, including Impl data, in constant methods must be constant. </p><br><p>  <b>Pros:</b> </p><br><ul><li>  leak protection </li></ul><br><p>  <b>Minuses:</b> </p><br><ul><li>  violation of logical constancy <br><br></li></ul><br><h3>  Using std :: unique_ptr with <a href="http://en.cppreference.com/w/cpp/experimental/propagate_const">propagate_const</a> </h3><br><p>  In the experimental library, there is a wrapper for propagate_const pointers, which allows you to fix logical constancy. </p><br><p>  Usage example: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// widget.h class Widget { // ...   struct Impl; std::experimental::propagate_const&lt;std::unique_ptr&lt;Impl&gt;&gt; d_; }; // widget.cpp struct Widget::Impl { /*...*/ }; Widget::Widget(): d_(std::make_unique&lt;Impl&gt;()) {} Widget::~Widget() {}</span></span></code> </pre> <br><p>  Now the code from the previous example will cause compilation errors. </p><br><p>  It seems to be close to a complete solution to the problem, however, there is another small point. <br>  When writing a constructor, you must always explicitly create Impl.  This does not seem to be a big problem, since, most likely, the error will manifest itself at the first call to the class at runtime. </p><br><p>  <b>Pros:</b> </p><br><ul><li>  respect for logical constancy </li></ul><br><p>  <b>Minuses:</b> </p><br><ul><li>  possibility to forget to create Impl in the constructor </li><li>  propagate_const is not yet part of the standard 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li></ul><br><h3>  Using PimplPtr </h3><br><p>  Considering all the above minuses and advantages, for a complete solution it is necessary to provide a smart pointer that meets the following requirements: </p><br><ul><li>  security regarding exceptions </li><li>  protection against removing an incomplete class </li><li>  respect for logical constancy </li><li>  protection from uncreated impl </li></ul><br><p>  The first two points can be implemented using unique_ptr: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PimplPtr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ElementType = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T&gt;::element_type; <span class="hljs-comment"><span class="hljs-comment">// ... private: std::unique_ptr&lt;T&gt; p_; // &lt;-       };</span></span></code> </pre> <br><p>  The third point could be implemented using propagate_const, but, since it is not yet in the standard, you can easily implement the methods of accessing the pointer yourself: </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> ElementType* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p_.get(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ElementType* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ElementType&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *get(); } <span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ElementType*() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(); } <span class="hljs-function"><span class="hljs-function">ElementType* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p_.get(); } ElementType* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(); } ElementType&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *get(); } <span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ElementType*() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(); }</code> </pre> <br><p>  To execute the fourth item, you need to implement a default constructor that will create an Impl: </p><br><pre> <code class="cpp hljs"> PimplPtr(): p_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;T&gt;()) {}</code> </pre> <br><p>  If Impl does not have a default constructor, the compiler will say this, and the user will need another constructor: </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PimplPtr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unique_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp;&amp; p)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(p))</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br><p>  For greater clarity, it may be worth adding static checks in the constructor and destructor: </p><br><pre> <code class="cpp hljs"> PimplPtr(): p_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;T&gt;()) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Probably, you forgot to declare constructor explicitly"</span></span>); } ~PimplPtr() { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Probably, you forgot to declare destructor explicitly"</span></span>); }</code> </pre> <br><p>  And, to preserve the semantics of the move, you must add the appropriate constructor and operator: </p><br><pre> <code class="cpp hljs"> PimplPtr(PimplPtr&amp;&amp;) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; PimplPtr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(PimplPtr&amp;&amp;) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><p>  All code in its entirety: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> utils { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PimplPtr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ElementType = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T&gt;::element_type; PimplPtr(): p_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;T&gt;()) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Probably, you forgot to declare constructor explicitly"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PimplPtr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unique_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp;&amp; p)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(p))</span></span></span><span class="hljs-function"> </span></span>{} PimplPtr(PimplPtr&amp;&amp;) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; PimplPtr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(PimplPtr&amp;&amp;) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ~PimplPtr() { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Probably, you forgot to declare destructor explicitly"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> ElementType* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p_.get(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ElementType* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ElementType&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *get(); } <span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ElementType*() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(); } <span class="hljs-function"><span class="hljs-function">ElementType* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p_.get(); } ElementType* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(); } ElementType&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *get(); } <span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ElementType*() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T&gt; p_; }; } <span class="hljs-comment"><span class="hljs-comment">// namespace utils</span></span></code> </pre> <br><p>  Usage example: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// widget.h class Widget { // ...   struct Impl; utils::PimplPtr&lt;Impl&gt; d_; }; // widget.cpp struct Widget::Impl { /*...*/ }; Widget::Widget() {} Widget::~Widget() {}</span></span></code> </pre> <br><p>  Using the developed pointer helps to avoid some silly mistakes and focus on writing useful code. </p><br><p>  ¬ª <a href="">Source Code</a> </p></div><p>Source: <a href="https://habr.com/ru/post/311038/">https://habr.com/ru/post/311038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311026/index.html">Where do faces</a></li>
<li><a href="../311028/index.html">Monitoring Postgresql: Requests</a></li>
<li><a href="../311030/index.html">"Recently launched an online sales system for BMW": T-Systems on the role of Java and conferences in its activities</a></li>
<li><a href="../311034/index.html">Using ReFS features in Veeam Backup & Replication 9.5</a></li>
<li><a href="../311036/index.html">Ruby (n) vs Python: the most important questions and answers</a></li>
<li><a href="../311040/index.html">How we almost lost 5,000,000 hryvnia per month due to the ‚Äúwrong‚Äù hosting: client history</a></li>
<li><a href="../311042/index.html">The realities of the game designer in a large studio on the example of BioWare</a></li>
<li><a href="../311046/index.html">We measure battery consumption on mobile devices. Experiment in Yandex</a></li>
<li><a href="../311050/index.html">RamQA First Mitap</a></li>
<li><a href="../311062/index.html">GIS utilities: establishing a secure connection and signing messages using WCF</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>