<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Studying net / context in Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It‚Äôs no secret that Go‚Äôs main niche is network services: various servers, backends, microservices, distributed databases and file storages. This class...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Studying net / context in Go</h1><div class="post__text post__text-html js-mediator-article">  It‚Äôs no secret that Go‚Äôs main niche is network services: various servers, backends, microservices, distributed databases and file storages.  This class of programs very actively uses network requests, all the necessary functionality for which is in the standard library, but one aspect of the development of network architectures remains for many a dark spot - query contexts.  In this article I want to consider this aspect more closely and show what a powerful and important tool it is. <br><br><img src="https://habrastorage.org/files/2ef/8bf/eaf/2ef8bfeaf57045b3ae30b5474a6412d3.png"><br><a name="habracut"></a><br><h4>  What is context? </h4><br>  Let's start with the main question - what kind of concept is this, ‚Äúcontext‚Äù?  The context in this, sorry for the tautology, the context is some information about the object that is passed between the boundaries of the API functions.  The object usually refers to a network request, and the bounds of the API refer to various middleware, different packages and layers of abstractions, but the very concept of ‚Äúcontext‚Äù is not specific only to network requests.  But this article will be mainly about them. <br><br>  A typical example is to extract user data from a JWT token and further forward this information to the handlers for access checking, logging, and so on. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This concept of context, at least for network requests, is found in many languages ‚Äã‚Äãand frameworks ‚Äî in C # it is <a href="httpcontext(v%3Dvs.110).aspx">HttpContext</a> , in Java Netty - <a href="http://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html">ChannelHandlerContext</a> , in Python Twisted - <a href="https://twistedmatrix.com/documents/current/api/twisted.python.context.html">twisted.python.context,</a> and so on. <br><br><h4>  Contexts in Go </h4><br>  The standard Go library has an excellent <a href="http/">HTTP stack</a> , which allows you to quickly create multi-threaded servers without fear of <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B5%25D0%25BC%25D0%25B0_10000_%25D1%2581%25D0%25BE%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9">‚Äú10K connection problems‚Äù</a> and easily implement a wide variety of query processing scripts using the <a href="http/">Handler</a> interface.  But there is no context for the http handlers in the standard library. <br><br>  But Go, besides the main standard library, there are Go authors and a <a href="https://github.com/golang/go/wiki/SubRepositories">separate group of packages</a> that are developed outside the main Go code, and do not have a hard promise of backward compatibility, as in the standard library.  These are all packages that lie in <b>golang / x /</b> .  Among them, for a long time there is a <b>net / context</b> package that implements the very essence of contexts and about which we will talk today.  At the time of this writing, this package is already used, <a href="https://godoc.org/golang.org/x/net/context%3Fimporters">according to GoDoc</a> , in 1560 packages. <br><br>  In part, the lack of context in the standard library was the reason for the emergence of a whole zoo of web frameworks, each of which decided to transfer the request context in its own way. <br><br><h4>  Framework Zoo </h4><br>  Using the word "zoo" I exaggerate a little, because there is no particular problem.  Standard net / http is good as a foundation, but as soon as you start writing some web service, you sooner or later come to the need to implement more advanced functionality - complex routing with grouping, advanced logging, authorization processing and access control, etc. , and this naturally turns into a kind of framework - many will probably need the same functionality and will like the same approach.  But overall, there are usually a couple of the most popular frameworks, and they change from time to time, <a href="http-routing-benchmark">competing in zero-memory allocations and speeds</a> .  Now, the palm of popularity, like <a href="https://github.com/gin-gonic/gin">gin-gonic</a> . <br><br>  Each of the frameworks approached the problem of context transfer in its own way.  <a href="https://github.com/gorilla/context">GorillaToolkit</a> keeps a global map of values ‚Äã‚Äãfor each request, protecting requests to it by mutexes.  <a href="https://godoc.org/github.com/zenazn/goji/web">Goji</a> and others keep a separate map for each request.  <a href="https://github.com/gocraft/web">gocraft / web</a> works with contexts through reflection.  In the aforementioned Gin - <a href="">Context,</a> in general, the key structure with which all handlers work.  In <a href="https://godoc.org/github.com/labstack/echo">echo,</a> the concept of Context generally hung all the processing functions of the request. <br><br>  Each of these approaches can have its pros and cons, but they all have one minus - binding to the framework.  As mentioned above, the context is a concept rather abstract and not limited to http requests.  Let's break it down into examples. <br><br><h4>  Example </h4><br>  Let's start with a simple web service: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { w.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, handler) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":1234"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre> <br><pre> <code class="bash hljs">$ curl http://localhost:1234 Hello World</code> </pre><br><br>  But here we want a primitive PIN-code authorization, we will create a simple middleware using http.HandlerFunc: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needPin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h http.HandlerFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandlerFunc</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r.FormValue(<span class="hljs-string"><span class="hljs-string">"pin"</span></span>) != <span class="hljs-string"><span class="hljs-string">"9999"</span></span> { http.Error(w, <span class="hljs-string"><span class="hljs-string">"wrong pin"</span></span>, http.StatusForbidden) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } h(w, r) } } ... http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, needPin(handler)) ...</code> </pre><br><pre> <code class="bash hljs">$ curl http://localhost:1234 wrong pin $ curl http://localhost:1234?pin=9999 Hello World</code> </pre><br>  Great, but now we want to read the pin from the SQL database, not the hard drive.  Ok, for now let's add a global variable * sql.DB: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needPin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h http.HandlerFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandlerFunc</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pin <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := db.QueryRow(<span class="hljs-string"><span class="hljs-string">"SELECT pin FROM pins"</span></span>).Scan(&amp;pin); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { http.Error(w, <span class="hljs-string"><span class="hljs-string">"database error"</span></span>, http.StatusInternalServerError) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } ...</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Complete code</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ sqlite3 pins.db SQLite version 3.8.4.3 2014-04-03 16:53:12 Enter <span class="hljs-string"><span class="hljs-string">".help"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> usage hints. sqlite&gt; CREATE TABLE pins(pin STRING); sqlite&gt; INSERT INTO pins(pin) VALUES (<span class="hljs-string"><span class="hljs-string">"9999"</span></span>); sqlite&gt; ^D</code> </pre><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/mattn/go-sqlite3"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( db *sql.DB err error ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { w.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needPin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h http.HandlerFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandlerFunc</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pin <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := db.QueryRow(<span class="hljs-string"><span class="hljs-string">"SELECT pin FROM pins"</span></span>).Scan(&amp;pin); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { http.Error(w, <span class="hljs-string"><span class="hljs-string">"database error"</span></span>, http.StatusInternalServerError) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r.FormValue(<span class="hljs-string"><span class="hljs-string">"pin"</span></span>) != pin { http.Error(w, <span class="hljs-string"><span class="hljs-string">"wrong pin"</span></span>, http.StatusForbidden) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } h(w, r) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> db, err = sql.Open(<span class="hljs-string"><span class="hljs-string">"sqlite3"</span></span>, <span class="hljs-string"><span class="hljs-string">"./pins.db"</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> db.Close() http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, needPin(handler)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":1234"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre><br></div></div><br>  And then the list of our requirements and desires begins to grow: <br><br><ul><li>  Can every request with the wrong pin-code be logged to syslog? </li><li>  Can I still check and record the IP address? </li><li>  and it is possible to do sharding for different IP and run in different bases? </li><li>  Can i ...? </li></ul><br>  ‚ÄúOf course you can,‚Äù you think, and you write your own middleware for each new task, starting to assemble them into chains.  There are even separate packages for this, for example <a href="https://github.com/justinas/alice">Alice</a> .  But how to pass the authorization error from authMiddleware to logMiddleware?  And if you still need to run in <a href="http://vaultproject.io/">Vault</a> for temporary passwords, first extracting the token from the session?  And how to get rid of global variables and pass the connection object to the base to the handler? <br><br>  This is where the concept of context comes to the rescue.  Each middleware-function sets its values ‚Äã‚Äãin the context variable, and passes the request and the context further.  In this context, you are free to thrust anything at all ‚Äî authorization status, user name, access permissions, information retrieved from the initial request headers, a pointer to a connection to the database, a unique ID for further tracking, and so on. <br><br>  Usually context.Context is passed as a function parameter (both middleware and any function that works with a request).  In principle, you can save the Context as a structure field, but this must be done carefully, since the Context must be bound to the request ‚Äî created for each request and deleted after the processing of the request is completed. <br><br>  But <i>net / context</i> is not only about storing values, it is a unified approach to managing timeouts and canceling a request.  Let's take a closer look. <br><br><h4>  net / context inside </h4><br>  The net / context API is a bit unusual, so be prepared for surprise at the beginning. <br><br>  It is important to understand here, as usual, Go creates complex pipelines for processing the request - usually it is a gorutin that accepts a single request that generates one or more gorutins that processes this query or a stream of queries, which in turn return the result to the top.  This can be as simple synchronous calls of functions, possibly separated into separate packages, as well as entire cascades of new Gorutin and channels transmitting channels.  The main thing is that there are clear limits of responsibility of each middleware, each package, and each of them wants to know something about the request, and wants to do something about it. <br><br>  Therefore, the first and main principle of net / context operation is that <b>contexts are nested</b> and have a wooden structure.  Actually, the <a href="https://godoc.org/golang.org/x/net/context">main functions of the</a> package net / context and deal with those.  what creates new variations of context from an already existing one, gives rise to a new ‚Äúsubcontext‚Äù: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Background</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Context</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TODO</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Context</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithCancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent Context)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx Context, cancel CancelFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithDeadline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent Context, deadline time.Time)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context, CancelFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithTimeout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent Context, timeout time.Duration)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context, CancelFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent Context, key </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, val </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Context</span></span></span></span></code> </pre><br>  The second important point is that context.Context is an interface, and the net / context package provides only a few variations, but you are free to create your contexts of any complexity. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Context <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Deadline() (deadline time.Time, ok <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>) Done() &lt;-<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{} Err() error Value(key <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} }</code> </pre><br>  Let's take a look at the main types of existing contexts: <br><br><ul><li>  <b>context.Background ()</b> is an empty context, it has no values, no timeout or the ability to cancel;  as a rule, Background () is used in the function that first receives an incoming request and is the basis for all subsequent derived queries. <br>  Here is an example from camilstore: <br><pre> <code class="go hljs">client := oauth2.NewClient(context.Background(), google.ComputeTokenSource(<span class="hljs-string"><span class="hljs-string">""</span></span>))</code> </pre></li><li>  <b>context.TODO ()</b> is a special context, also empty, but used when it is unclear what context to use, or if the function has not yet been refactored to accept the context.  The TODO name was chosen specifically so that static code analyzers could easily find this case.  At the moment, however, the linter, which analyzes contexts is not yet in open source, <a href="https://twitter.com/Sajma/status/494161985219465217">but it is in Google and will be open in the future</a> . </li><li>  <b>context.WithCancel (parent Context) (ctx Context, cancel CancelFunc)</b> - returns a copy of the context of the <i>parent</i> with the new channel <i>Done</i> and the function CancelFunc, which initiates the closing of this channel. <br>  Let's see how it works: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//      ctx, cancel = context.WithCancel(context.Background()) defer cancel() //         Done,    go func() { time.Sleep(1 * time.Second) ctx.Done &lt;- struct{}{} }() //     res, err:= startLongQuery(ctx, w) if err != nil { http.Error(w, "cancelled", http.StatusInternalError) return } // ...encode res to json w.Write(encodedResult) } func startLongQuery(ctx context.Context, w http.ResponseWriter) (*Result, error) { resCh, transport := runLongQueryToJavaService(someArgs) select { case &lt;-ctx.Done(): //       transport.CancelRequest(req) &lt;-resCh return nil, ctx.Err() case result := &lt;-resCh: //   ,   Done,   return Result{result}, nil } }</span></span></code> </pre><br>  This example is deliberately simplified, and we will look at how to use the context for timeouts just below, but the idea should be clear. <br>  Forced Cancel can be useful, for example, in the case of a simultaneous request to different replicas of a service ‚Äî after the response of the fastest replica, requests to the others can be safely canceled so that resources are not wasted. </li><li>  <b>context.WithTimeout (parent Context, timeout time.Duration) (Context, CancelFunc) and context.WithDeadline (parent Context, deadline time.Time) (Context, CancelFunc)</b> - similar to WithCancel (), but they close Done after a timeout or achievement deadline  Actually, WithTimeout is WithDeadline with the time.Now (). Add (timeout) parameter. <br><br>  If you understand how WithCancel works, then there should be no problems with these two functions.  The example above will be simplified by a couple of lines, and you can do something like this: <br><br><pre> <code class="go hljs"> timeout, err := time.ParseDuration(req.FormValue(<span class="hljs-string"><span class="hljs-string">"timeout"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { ctx, cancel = context.WithTimeout(context.Background(), timeout) }</code> </pre><br>  to indicate how long to wait for a long query. </li><li>  <b>context.WithValue (parent Context, key interface {}, val interface {}) Context</b> - serves for the above task of storing data or resources associated with the context </li></ul><br><h4>  A little more about context.WithValue </h4><br>  Unlike the frameworks mentioned above, net / context does not use maps or any similar data structures due to its tree-like nested architecture.  One context carries one value plus a parent context.  The new meaning is already a new context.  Both the key and the value itself can be of any type. <br><br>  The standard mechanism for using this is that the key must be a non-exported type to avoid collisions with other packages / APIs that can work with the context.  For example: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> userIP <span class="hljs-comment"><span class="hljs-comment">// ,       type key int //   IP .         - ,    . const userIPKey key = 0</span></span></code> </pre><br>  The very context with the value looks like this (https://github.com/golang/net/blob/master/context/context.go#L433): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> valueCtx <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Context key, val <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} } <span class="hljs-comment"><span class="hljs-comment">//   Value   func (c *valueCtx) Value(key interface{}) interface{} { if c.key == key { return c.val } return c.Context.Value(key) }</span></span></code> </pre><br>  As you can see, for any nesting of the context, Value () will go up the context tree until it reaches the desired value of the desired type.  Well, or returns nil, since Value () is defined for all contexts (Context, as you remember, is an interface, and, therefore, is also defined for Background-context too). <br><br>  The complete code of the example package working with context values ‚Äã‚Äãmight be something like this: <br><br><div class="spoiler">  <b class="spoiler_title">full code</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Package userip provides functions for extracting a user IP address from a // request and associating it with a Context. package userip import ( "fmt" "net" "net/http" "golang.org/x/net/context" ) // FromRequest extracts the user IP address from req, if present. func FromRequest(req *http.Request) (net.IP, error) { ip, _, err := net.SplitHostPort(req.RemoteAddr) if err != nil { return nil, fmt.Errorf("userip: %q is not IP:port", req.RemoteAddr) } userIP := net.ParseIP(ip) if userIP == nil { return nil, fmt.Errorf("userip: %q is not IP:port", req.RemoteAddr) } return userIP, nil } // The key type is unexported to prevent collisions with context keys defined in // other packages. type key int // userIPkey is the context key for the user IP address. Its value of zero is // arbitrary. If this package defined other context keys, they would have // different integer values. const userIPKey key = 0 // NewContext returns a new Context carrying userIP. func NewContext(ctx context.Context, userIP net.IP) context.Context { return context.WithValue(ctx, userIPKey, userIP) } // FromContext extracts the user IP address from ctx, if present. func FromContext(ctx context.Context) (net.IP, bool) { // ctx.Value returns nil if ctx has no value for the key; // the net.IP type assertion returns ok=false for nil. userIP, ok := ctx.Value(userIPKey).(net.IP) return userIP, ok }</span></span></code> </pre><br></div></div><br>  What and how you will put in context depends on the specific task.  This can be both a simple user ID, a complex structure with a lot of information inside, and an object like sql.DB for working with a database. <br><br><h4>  Buns </h4><br>  Implementing a context as a universal interface allows you to be friends with code that uses contexts from other frameworks with code that uses net / context. <br><br>  Here is an example of a context using gorilla / context: <a href="">blog.golang.org/context/gorilla/gorilla.go</a> <br><br>  And here is an example of working with canceling a request in another framework, tomb: <a href="">blog.golang.org/context/tomb/tomb.go</a> <br><br>  Or the <a href="https://godoc.org/golang.org/x/net/trace">net / trace</a> package, as an example of using context to trace the life of a Dapper-style query.  The parent context generates context.WithValue (ctx, trace) and all subsequent calls and contexts that will be generated during the processing of the request will contain the ID of the trace, and already the net / trace code contains the necessary handlers that provide information about the traces on the web page paths <i>/ debug / requests</i> and <i>/ debug / events</i> . <br><br>  Obviously, the greatest benefit will be if all the code that communicates with external resources or generates new gorutiny, will use net / context.  For example, the Google code base on Go, which already has about 10 + million lines of code, uses context.Context everywhere.  The new RPC framework <a href="http://grpc.io/">gRPC</a> on Protobuf3, when it generates code for Go, also transmits context.Context everywhere. <br><br><h4>  Future plans </h4><br>  Here is <a href="https://groups.google.com/forum/">an active discussion of</a> future plans for net / context, and it is likely that the context will appear in the standard library in Go 1.7.  Perhaps with minor changes, perhaps without, but, in any case, there is interest and desire, so it‚Äôs worth keeping your finger on the pulse. <br><br>  The standard library, of course, will be backward compatible, and there will not be things like separation into http and ctxhttp, so as not to fragment the code base (although the <a href="http">ctxhttp</a> package now exists as an experiment).  Perhaps the Context field will be added to http.Request, and it may come to some other variant. <br><br>  The net word from net / context is likely to disappear. <br><br><h4>  Links </h4><br>  If you want to sort out and see more examples, I highly recommend the following links: <br><br>  Good article on contexts on the Go blog - <a href="http://blog.golang.org/context">blog.golang.org/context</a> <br>  Report on GothamGo 2014 about contexts - <a href="https://vimeo.com/115309491">vimeo.com/115309491</a> <br>  Another article on http.Handler and net / context - <a href="http-handler/">joeshaw.org/net-context-and-http-handler</a> <br>  Detailed slides of a good report on the topic net / context - <a href="http://go-talks.appspot.com/github.com/guregu/slides/kami/kami.slide">go-talks.appspot.com/github.com/guregu/slides/kami/kami.slide#1</a> <br>  Article on advanced pipelines and cancellations in Go - <a href="http://blog.golang.org/pipelines">blog.golang.org/pipelines</a> <br>  An overview of context implementations in various frameworks - <a href="https://www.nicolasmerouze.com/share-values-between-middlewares-context-golang/">www.nicolasmerouze.com/share-values-between-middlewares-context-golang</a> <br>  Source code net / context - <a href="https://github.com/golang/net/tree/master/context">github.com/golang/net/tree/master/context</a> </div><p>Source: <a href="https://habr.com/ru/post/269299/">https://habr.com/ru/post/269299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269289/index.html">How can you make a fault-tolerant storage system of data from domestic servers</a></li>
<li><a href="../269291/index.html">Job Search Guide for MDA Specialist (and a little about hierarchy analysis method, Xcore and Sirius)</a></li>
<li><a href="../269293/index.html">Implementation of monitoring and integration testing information system using Scalatest. Part 1</a></li>
<li><a href="../269295/index.html">PCEPTPDPTE</a></li>
<li><a href="../269297/index.html">Gaming Digest: September</a></li>
<li><a href="../269301/index.html">Pitfalls in the clouds, or failed test online editors on the docx file</a></li>
<li><a href="../269303/index.html">Learning React - for what, where, how?</a></li>
<li><a href="../269305/index.html">Rules of safe programming in C: past, present and future</a></li>
<li><a href="../269307/index.html">TemplateEngine.Docx - OpenSource .NET docx template engine for documents</a></li>
<li><a href="../269309/index.html">Apple fixed vulnerabilities in its products</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>