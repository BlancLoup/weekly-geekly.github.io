<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Framework in Marmalade (part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article, I began to talk about developing a small Framework for creating 2D games using the Marmalade tool system, which provides the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Framework in Marmalade (part 2)</h1><div class="post__text post__text-html js-mediator-article">  In the previous <a href="http://habrahabr.ru/post/161681/">article,</a> I began to talk about developing a small Framework for creating 2D games using the <a href="http://www.madewithmarmalade.com/">Marmalade</a> tool system, which provides the ability to develop and build applications for a number of platforms, including iOS and Android.  We learned how to work with graphic resources and built a small test application.  Today I want to talk about handling events. <br><a name="habracut"></a><br>  The main source of events on mobile platforms is the TouchPad, which provides the application with information about the user's interaction with the touch screen.  On most modern devices, Multitouch technology is supported, allowing you to track multiple touches simultaneously.  Of course, the gaming framework must correctly handle multitouch events. <br><br>  A slightly less significant source of events (on mobile platforms) is the keyboard.  Indeed, there are not so many buttons on a modern mobile device to receive any meaningful information from them.  But there is at least one keyboard event that we will have to work out in order for the application to behave adequately (at least when developing for Android).  It is about handling the s3eKeyAbsBSK event, triggered by pressing the ‚ÄúBack‚Äù button.  According to the development agreements on Android, clicking this button should close the current activity and return the interface to the previous one. <br><br>  In this article we will not consider other sources of events (such as an accelerometer), because, although they are used in the development of gaming applications, their consideration requires writing a separate article. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We‚Äôll start redesigning the Marmalade Framework by adding Touchpad event handling.  Add a description of the new files in the mkb file. <br><br><div class="spoiler">  <b class="spoiler_title">mf.mkb</b> <div class="spoiler_text"><pre><code class="cpp hljs">#!/usr/bin/env mkb ... files { [Main] (source/Main) ... TouchPad.cpp TouchPad.h } ...</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">TouchPad.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _TOUCHPAD_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _TOUCHPAD_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IwGeom.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"s3ePointer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_TOUCHES 11 struct Touch { int x, y; bool isActive, isPressed, isMoved; int id; }; class TouchPad { private: bool IsAvailable; bool IsMultiTouch; Touch Touches[MAX_TOUCHES]; public: static bool isTouchDown(int eventCode); static bool isTouchUp(int eventCode); bool isAvailable() const { return IsAvailable; } bool isMultiTouch() const { return IsMultiTouch; } Touch* getTouchByID(int id); Touch* getTouch(int index) { return &amp;Touches[index]; } Touch* findTouch(int id); int getTouchCount() const; bool init(); void release(); void update(); void clear(); }; extern TouchPad touchPad; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// _TOUCHPAD_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">TouchPad.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"TouchPad.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Desktop.h"</span></span></span><span class="hljs-meta"> TouchPad touchPad; bool TouchPad::isTouchDown(int eventCode) { return (eventCode &amp; emtTouchMask) == emtTouchDown; } bool TouchPad::isTouchUp(int eventCode) { return (eventCode &amp; emtTouchMask) == emtTouchUp; } void HandleMultiTouchButton(s3ePointerTouchEvent* event) { Touch* touch = touchPad.findTouch(event-&gt;m_TouchID); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (touch != NULL) { touch-&gt;isPressed = event-&gt;m_Pressed != 0; touch-&gt;isActive = true; touch-&gt;x = event-&gt;m_x; touch-&gt;y = event-&gt;m_y; touch-&gt;id = event-&gt;m_TouchID; } } void HandleMultiTouchMotion(s3ePointerTouchMotionEvent* event) { Touch* touch = touchPad.findTouch(event-&gt;m_TouchID); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (touch != NULL) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (touch-&gt;isActive) { touch-&gt;isMoved = true; } touch-&gt;isActive = true; touch-&gt;x = event-&gt;m_x; touch-&gt;y = event-&gt;m_y; } } void HandleSingleTouchButton(s3ePointerEvent* event) { Touch* touch = touchPad.getTouch(0); touch-&gt;isPressed = event-&gt;m_Pressed != 0; touch-&gt;isActive = true; touch-&gt;x = event-&gt;m_x; touch-&gt;y = event-&gt;m_y; touch-&gt;id = 0; } void HandleSingleTouchMotion(s3ePointerMotionEvent* event) { Touch* touch = touchPad.getTouch(0); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (touch-&gt;isActive) { touch-&gt;isMoved = true; } touch-&gt;isActive = true; touch-&gt;x = event-&gt;m_x; touch-&gt;y = event-&gt;m_y; } Touch* TouchPad::getTouchByID(int id) { for (int i = 0; i &lt; MAX_TOUCHES; i++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Touches[i].isActive &amp;&amp; Touches[i].id == id) return &amp;Touches[i]; } return NULL; } Touch* TouchPad::findTouch(int id) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!IsAvailable) return NULL; for (int i = 0; i &lt; MAX_TOUCHES; i++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Touches[i].id == id) return &amp;Touches[i]; } for (int i = 0; i &lt; MAX_TOUCHES; i++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!Touches[i].isActive) { Touches[i].id = id; return &amp;Touches[i]; } } return NULL; } int TouchPad::getTouchCount() const { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!IsAvailable) return 0; int r = 0; for (int i = 0; i &lt; MAX_TOUCHES; i++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Touches[i].isActive) { r++; } } return r; } void TouchPad::update() { for (int i = 0; i &lt; MAX_TOUCHES; i++) { Touches[i].isMoved = false; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (IsAvailable) { s3ePointerUpdate(); } } void TouchPad::clear() { for (int i = 0; i &lt; MAX_TOUCHES; i++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!Touches[i].isPressed) { Touches[i].isActive = false; } Touches[i].isMoved = false; } } bool TouchPad::init() { IsAvailable = s3ePointerGetInt(S3E_POINTER_AVAILABLE) ? true : false; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!IsAvailable) return false; for (int i = 0; i &lt; MAX_TOUCHES; i++) { Touches[i].isPressed = false; Touches[i].isActive = false; Touches[i].isMoved = false; Touches[i].id = 0; } IsMultiTouch = s3ePointerGetInt(S3E_POINTER_MULTI_TOUCH_AVAILABLE) ? true : false; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (IsMultiTouch) { s3ePointerRegister(S3E_POINTER_TOUCH_EVENT, (s3eCallback)HandleMultiTouchButton, NULL); s3ePointerRegister(S3E_POINTER_TOUCH_MOTION_EVENT, (s3eCallback)HandleMultiTouchMotion, NULL); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { s3ePointerRegister(S3E_POINTER_BUTTON_EVENT, (s3eCallback)HandleSingleTouchButton, NULL); s3ePointerRegister(S3E_POINTER_MOTION_EVENT, (s3eCallback)HandleSingleTouchMotion, NULL); } return true; } void TouchPad::release() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (IsAvailable) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (IsMultiTouch) { s3ePointerUnRegister(S3E_POINTER_TOUCH_EVENT, (s3eCallback)HandleMultiTouchButton); s3ePointerUnRegister(S3E_POINTER_TOUCH_MOTION_EVENT, (s3eCallback)HandleMultiTouchMotion); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { s3ePointerUnRegister(S3E_POINTER_BUTTON_EVENT, (s3eCallback)HandleSingleTouchButton); s3ePointerUnRegister(S3E_POINTER_MOTION_EVENT, (s3eCallback)HandleSingleTouchMotion); } } }</span></span></code> </pre><br></div></div><br>  As we can see, event handling is pretty low level.  The Touchpad module should hide this fact from the application developer.  In order to update the project, run the mkb file for execution again.  After the download is complete, we will see that the TouchPad module has been successfully added to the C ++ project. <br><br>  We make the necessary additions to the Desktop module. <br><br><div class="spoiler">  <b class="spoiler_title">Desktop.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _DESKTOP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _DESKTOP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;set&gt; #include "s3eKeyboard.h" #include "Scene.h" using namespace std; enum EMessageType { emtNothing = 0x00, emtTouchEvent = 0x10, emtTouchIdMask = 0x07, emtTouchMask = 0x70, emtMultiTouch = 0x14, emtTouchDown = 0x30, emtTouchUp = 0x50, emtTouchMove = 0x70, emtSingleTouchDown = 0x30, emtSingleTouchUp = 0x50, emtSingleTouchMove = 0x70, emtMultiTouchDown = 0x34, emtMultiTouchUp = 0x54, emtMultiTouchMove = 0x74, emtKeyEvent = 0x80, emtKeyAction = 0x82, emtKeyDown = 0x81, emtKeyPressed = 0x83, emtKeyReleased = 0x82 }; class Desktop { private: int width, height; bool isChanged; Scene* currentScene; bool isKeyAvailable; bool IsQuitMessageReceived; bool checkBounce(int id, int msg); void getScreenSizes(); static int32 ScreenSizeChangeCallback(void* systemData, void* userData); public: Desktop(): touches() {} void init(); void release(); void update(uint64 timestamp); void refresh(); int getWidth() const {return width;} int getHeight() const {return height;} Scene* getScene() {return currentScene;} void setScene(Scene* scene); void sendQuitMessage() {IsQuitMessageReceived = true;} bool isQuitMessageReceived(); set&lt;int&gt; touches; typedef set&lt;int&gt;::iterator TIter; }; extern Desktop desktop; #endif // _DESKTOP_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Desktop.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Desktop.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Iw2D.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"TouchPad.h"</span></span></span><span class="hljs-meta"> Desktop desktop; void Desktop::init() { IsQuitMessageReceived = false; getScreenSizes(); setScene(NULL); isKeyAvailable = (s3eKeyboardGetInt(S3E_KEYBOARD_HAS_KEYPAD) || s3eKeyboardGetInt(S3E_KEYBOARD_HAS_ALPHA)); s3eSurfaceRegister(S3E_SURFACE_SCREENSIZE, ScreenSizeChangeCallback, NULL); } void Desktop::release() { s3eSurfaceUnRegister(S3E_SURFACE_SCREENSIZE, ScreenSizeChangeCallback); touches.clear(); } int32 Desktop::ScreenSizeChangeCallback(void* systemData, void* userData) { desktop.isChanged = true; return 0; } void Desktop::setScene(Scene* scene) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (scene != NULL) { scene-&gt;init(); } currentScene = scene; } void Desktop::getScreenSizes() { width = Iw2DGetSurfaceWidth(); height = Iw2DGetSurfaceHeight(); isChanged = false; } bool Desktop::checkBounce(int id, int msg) { TIter p = touches.find(id); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (TouchPad::isTouchDown(msg)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p != touches.end()) return true; touches.insert(id); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p == touches.end()) return true; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (TouchPad::isTouchUp(msg)) { touches.erase(p); } } return false; } void Desktop::update(uint64 timestamp) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (isChanged) { getScreenSizes(); } int cnt = touchPad.getTouchCount(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (cnt &gt; 0) { for (int i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; MAX_TOUCHES; i++) { Touch* t = touchPad.getTouch(i); if (t-&gt;isActive) { int msg = (cnt &gt; 1)?emtMultiTouchUp:emtSingleTouchUp; if (t-&gt;isMoved) { msg = (cnt &gt; 1)?emtMultiTouchMove:emtSingleTouchMove; } if (t-&gt;isPressed) { msg = (cnt &gt; 1)?emtMultiTouchDown:emtSingleTouchDown; } if (!checkBounce(t-&gt;id, msg)) { if (currentScene != NULL) { currentScene-&gt;sendMessage(msg | (t-&gt;id &amp; emtTouchIdMask), t-&gt;x, t-&gt;y); } } } } } if (isKeyAvailable) { s3eKeyboardUpdate(); } if (currentScene != NULL) { currentScene-&gt;update(timestamp); } } void Desktop::refresh() { if (currentScene != NULL) { currentScene-&gt;refresh(); } } bool Desktop::isQuitMessageReceived() { if (s3eDeviceCheckQuitRequest()) { return true; } return IsQuitMessageReceived; }</span></span></span></span></code> </pre><br></div></div><br><br>  Here we defined a number of system events and added TouchPad event handling to the update method.  Attention should be paid to the checkBounce method, the task of which is to prevent bounce, by forming the correct sequence of pressing and releasing events of the TouchPad.  In addition, a screen size event handler has been added to Desktop (for example, as a result of changing its orientation). <br><br>  The Main module changes slightly. <br><br><div class="spoiler">  <b class="spoiler_title">Main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Main.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"s3e.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Iw2D.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IwGx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"TouchPad.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Desktop.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Scene.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Background.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Sprite.h"</span></span></span><span class="hljs-meta"> void init() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Initialise Mamrlade graphics system and Iw2D module IwGxInit(); Iw2DInit(); // Set the default background clear colour IwGxSetColClear(0x0, 0x0, 0x0, 0); touchPad.init(); desktop.init(); } void release() { desktop.release(); touchPad.release(); Iw2DTerminate(); IwGxTerminate(); } int main() { init(); { Scene scene; new Background(&amp;scene, "background.png", 1); new Sprite(&amp;scene, "sprite.png", 122, 100, 2); desktop.setScene(&amp;scene); int32 duration = 1000 / 25; // Main Game Loop while (!desktop.isQuitMessageReceived()) { // Update keyboard system s3eKeyboardUpdate(); // Update touchPad.update(); desktop.update(s3eTimerGetMs()); // Clear the screen IwGxClear(IW_GX_COLOUR_BUFFER_F | IW_GX_DEPTH_BUFFER_F); touchPad.clear(); // Refresh desktop.refresh(); // Show the surface Iw2DSurfaceShow(); // Yield to the opearting system s3eDeviceYield(duration); } } release(); return 0; }</span></span></span></span></code> </pre><br></div></div><br>  We removed the direct test for pressing the s3eKeyAbsBSK button and replaced the s3eDeviceCheckQuitRequest call in the loop condition with the call to the Desktop :: isQuitMessageReceived method.  Calls to Touchpad :: update and clear have been added to the main application loop.  In addition, initialization and termination calls were added for the TouchPad module to the init and release methods, respectively. <br><br>  We will place the processing of keyboard events in the Scene module. <br><br><div class="spoiler">  <b class="spoiler_title">Scene.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _SCENE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SCENE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;map&gt; #include &lt;set&gt; #include "s3eKeyboard.h" #include "AbstractSpriteOwner.h" #include "AbstractScreenObject.h" using namespace std; class Scene: public AbstractSpriteOwner { private: AbstractScreenObject* background; map&lt;s3eKey, int&gt; keys; bool isInitialized; uint64 lastTime; protected: virtual bool doKeyMessage(int msg, s3eKey key) {return false;} virtual void regKey(s3eKey key); public: Scene(); virtual bool init(); int getXSize(int xSize); int getYSize(int ySize); virtual int getXPos(int x) {return x;} virtual int getYPos(int y) {return y;} virtual void refresh(); virtual void update(uint64 timestamp); virtual bool isBuzy() {return false;} virtual bool sendMessage(int id, int x, int y); typedef map&lt;s3eKey, int&gt;::iterator KIter; typedef pair&lt;s3eKey, int&gt; KPair; }; #endif // _SCENE_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Scene.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Scene.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Desktop.h"</span></span></span><span class="hljs-meta"> Scene::Scene(): AbstractSpriteOwner() , isInitialized(false) , background(NULL) , keys() , lastTime(0) { regKey(s3eKeyBack); regKey(s3eKeyAbsBSK); } bool Scene::init() { bool r = !isInitialized; isInitialized = true; return r; } int Scene::getXSize(int xSize) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (background != NULL) { return (getDesktopWidth() * xSize) / background-&gt;getWidth(); } return xSize; } int Scene::getYSize(int ySize) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (background != NULL) { return (getDesktopHeight() * ySize) / background-&gt;getHeight(); } return ySize; } void Scene::refresh() { init(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (background == NULL) { for (ZIter p = zOrder.begin(); p != zOrder.end(); ++p) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p-&gt;second-&gt;isBackground()) { background = p-&gt;second; break; } } } AbstractSpriteOwner::refresh(); } void Scene::regKey(s3eKey key) { keys.insert(KPair(key, 0)); } void Scene::update(uint64 timestamp) { for (KIter p = keys.begin(); p != keys.end(); ++p) { int msg = 0; int32 keyState = s3eKeyboardGetState(p-&gt;first); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (keyState &amp; (S3E_KEY_STATE_DOWN | S3E_KEY_STATE_PRESSED)) { msg = emtKeyDown; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p-&gt;second == 0) { msg = emtKeyPressed; p-&gt;second = 1; } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (keyState == S3E_KEY_STATE_UP) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p-&gt;second == 1) { msg = emtKeyReleased; p-&gt;second = 0; } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (msg != 0) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (doKeyMessage(msg, p-&gt;first)) { lastTime = timestamp; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (timestamp - lastTime &gt;= 1000) { lastTime = 0; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((lastTime == 0)&amp;&amp;(msg == emtKeyPressed)) { switch (p-&gt;first) { case s3eKeyBack: case s3eKeyAbsBSK: desktop.sendQuitMessage(); break; } } } } } AbstractSpriteOwner::update(timestamp); } bool Scene::sendMessage(int id, int x, int y) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (AbstractSpriteOwner::sendMessage(id, x, y)) { return true; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (background != NULL) { return background-&gt;sendMessage(id, x, y); } return false; }</span></span></code> </pre><br></div></div><br>  For each key listed in the list of keys listened to, we check the status, generate keyboard events and pass to the override method doKeyMessage.  If this method does not handle the received events, we perform the default processing for s3eKeyBack and s3eKeyAbsBSK, which is to call the desktop.sendQuitMessage method, which causes the application to terminate. <br><br>  To complete the article, we need to add the handling of positional events to the Sprite class. <br><br><div class="spoiler">  <b class="spoiler_title">Sprite.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _SPRITE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPRITE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"AbstractScreenObject.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ISprite.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ISpriteOwner.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Locale.h"</span></span></span><span class="hljs-meta"> class Sprite: public AbstractScreenObject , public ISprite { protected: ISpriteOwner* owner; CIw2DImage* img; int capturedId; public: Sprite(ISpriteOwner* owner, int x, int y , int zOrder = 0); Sprite(ISpriteOwner* owner, const char* res, int x, int y, int zOrder = 0); virtual ~Sprite(); virtual bool sendMessage(int msg, uint64 timestamp = 0, void* data = NULL); virtual bool sendMessage(int msg, int x, int y); virtual void update(uint64 timestamp) {} virtual void refresh(); virtual void addImage(const char*res, int state = 0); virtual CIw2DImage* getImage(int id = 0); virtual int getState() {return 0;} virtual int getWidth(); virtual int getHeight(); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// _SPRITE_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sprite.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Sprite.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Locale.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Desktop.h"</span></span></span><span class="hljs-meta"> Sprite::Sprite(ISpriteOwner* owner, int x, int y , int zOrder): AbstractScreenObject(x, y) , owner(owner) , capturedId(-1) , img(NULL) { owner-&gt;addSprite((AbstractScreenObject*)this, zOrder); } Sprite::Sprite(ISpriteOwner* owner, const char* res, int x, int y, int zOrder): AbstractScreenObject(x, y) , owner(owner) , capturedId(-1) , img(NULL) { addImage(res, 0); owner-&gt;addSprite((AbstractScreenObject*)this, zOrder); } Sprite::~Sprite() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (img != NULL) { delete img; } } bool Sprite::sendMessage(int msg, uint64 timestamp, void* data) { return owner-&gt;sendMessage(msg, timestamp, data); } bool Sprite::sendMessage(int msg, int x, int y) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((msg &amp; emtTouchEvent) != emtTouchEvent) return false; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!isVisible) return false; int id = msg &amp; emtTouchIdMask; msg &amp;= emtTouchMask; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (capturedId &gt;= 0) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (id != capturedId) return false; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (msg == emtTouchDown) { capturedId = -1; } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (capturedId </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 0) { int X = owner-&gt;getXSize(owner-&gt;getXPos(getXPos())); int Y = owner-&gt;getYSize(owner-&gt;getYPos(getYPos())); if ((x &lt; X)||(y &lt; Y)) return false; X += owner-&gt;getXSize(getWidth()); Y += owner-&gt;getYSize(getHeight()); if ((x &gt; X)||(y &gt; Y)) return false; } switch (msg) { case emtTouchDown: capturedId = id; break; case emtTouchUp: capturedId = -1; break; } if (isBuzy()) { return true; } return sendMessage(msg) || owner-&gt;sendMessage(msg); } void Sprite::addImage(const char*res, int state) { img = Iw2DCreateImage(res); } CIw2DImage* Sprite::getImage(int id) { return img; } int Sprite::getWidth() { CIw2DImage* img = getImage(getState()); if (img != NULL) { return img-&gt;GetWidth(); } else { return 0; } } int Sprite::getHeight() { CIw2DImage* img = getImage(getState()); if (img != NULL) { return img-&gt;GetHeight(); } else { return 0; } } void Sprite::refresh() { init(); CIw2DImage* img = getImage(getState()); if (isVisible &amp;&amp; (img != NULL)) { CIwMat2D m; m.SetRot(getAngle()); m.ScaleRot(IW_GEOM_ONE); m.SetTrans(CIwSVec2(owner-&gt;getXSize(owner-&gt;getXPos(getXPos())), owner-&gt;getYSize(owner-&gt;getYPos(getYPos())))); Iw2DSetTransformMatrix(m); Iw2DSetAlphaMode(alpha); Iw2DDrawImage(img, CIwSVec2(0, 0), CIwSVec2(owner-&gt;getXSize(getWidth()), owner-&gt;getYSize(getHeight()))); } }</span></span></span></span></code> </pre><br></div></div><br>  In the sendMessage positional event handler, we check if the touch point falls into the sprite region and, if so, pass a non-positional event with the same code to the sprite.  Let me remind you that in AbstractSpriteOwner :: update we alternately call sendMessage for all sprites except the Background, in the reverse order of the Z-order (used to render the sprites). <br><br>  For drop-release events, special handling is used.  Having received an emtTouchDown event.  Sprite remembers the touch id and sends subsequent events with the same id to the handler of the same sprite, regardless of the touch coordinates. <br><br>  So, we have learned to handle events, but in order to show some noticeable activity related to their processing, we still have a lot of work to do.  In the next <a href="http://habrahabr.ru/post/161959/">article</a> we will learn how to work with resources and sound. <br><br>  Source texts of the current version of the project can be obtained <a href="https://github.com/GlukKazan/mf">here.</a> <br><br>  The following <a href="http://www.drmop.com/index.php/marmalade-sdk-tutorials/">materials were</a> used in developing the Marmalade Framework <a href="http://www.drmop.com/index.php/marmalade-sdk-tutorials/">.</a> <br></div><p>Source: <a href="https://habr.com/ru/post/161849/">https://habr.com/ru/post/161849/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../161833/index.html">How humiliating to do script work</a></li>
<li><a href="../161835/index.html">David Morgan-Mar's Esoteric Sortings</a></li>
<li><a href="../161839/index.html">Connecting pictures to problem descriptions on Github</a></li>
<li><a href="../161841/index.html">RealTimeBoard - a new way to collaborate</a></li>
<li><a href="../161843/index.html">Add a new tag to MODX Revolution</a></li>
<li><a href="../161853/index.html">The shortest overview of the mechanical keyboard Matias Tactile Pro 4.0</a></li>
<li><a href="../161855/index.html">Bitcoin has an official bank</a></li>
<li><a href="../161857/index.html">The need for proper goal setting</a></li>
<li><a href="../161859/index.html">Inferno Shell</a></li>
<li><a href="../161861/index.html">Evolution of Zeus. Part II</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>