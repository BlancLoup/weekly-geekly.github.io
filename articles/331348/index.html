<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ssh magic</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many people have known SSH for a long time, but, like me, not everyone is suspicious about the possibilities that lie behind these magical three lette...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ssh magic</h1><div class="post__text post__text-html js-mediator-article">  Many people have known SSH for a long time, but, like me, not everyone is suspicious about the possibilities that lie behind these magical three letters.  I would like to share my little experience of using SSH for solving various administrative tasks. <br><br>  Table of contents: <br><br>  1) <a href="https://habr.com/ru/post/331348/">Local TCP forwarding</a> <br>  2) <a href="https://habr.com/ru/post/331348/">Remote TCP forwarding</a> <br>  3) <a href="https://habr.com/ru/post/331348/">TCP forwarding chain through several nodes</a> <br>  4) <a href="https://habr.com/ru/post/331348/">TCP forwarding ssh connections</a> <br>  5) <a href="https://habr.com/ru/post/331348/">SSH VPN Tunnel</a> <br>  6) <a href="https://habr.com/ru/post/331348/">besparolnym in short</a> <br>  7) <a href="https://habr.com/ru/post/331348/">Thank you (links)</a> <br><a name="habracut"></a><br><a name="t1"></a><h2>  1) Local TCP forwarding </h2><br>  Let's start with a simple - local TCP forwarding: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/web/682/bbf/053/682bbf05346443ec9074a50a35c76c30.png" alt="image"><br><br>  We have a remote server ‚Äúhost2‚Äù with some application, say, a PostgreSQL server that accepts TCP connections on port 5432. At the same time, it is quite logical that there is a firewall on this server that does not allow direct connections from outside to port 5432, but there is SSH access (port 22 by default, I recommend to change it).  It is required to connect from our workstation "host1" by the client application to the PostgreSQL server on "host2". <br><br>  To do this, on ‚Äúhost1‚Äù in the console type: <br><br> <code>host1# ssh -L 9999:localhost:5432 host2</code> <br> <br>  Now on ‚Äúhost1‚Äù we can connect to the PostgreSQL server via local port 9999: <br><br> <code>host1# psql -h localhost -p 9999 -U postgres</code> <br> <br><div class="spoiler">  <b class="spoiler_title">If on "host1" Windows</b> <div class="spoiler_text">  For example, in PuTTy it is done like this: <br>  Go through the settings tree: Connection ‚Üí SSH ‚Üí Tunnels. <br>  Next, in the field ‚ÄúSource port‚Äù we drive 9999, in ‚ÄúDestination‚Äù - localhost: 5432, and click Add. <br>  Do not forget after that save session settings, if required. <br><img src="https://habrastorage.org/web/3d0/cdd/dce/3d0cdddce88847388d3b4bd5e8ebed01.png" alt="image"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">How it works</b> <div class="spoiler_text">  After successfully connecting to the SSH server on ‚Äúhost2‚Äù, on ‚Äúhost1‚Äù, the SSH client starts listening on port 9999. When connected to port 9999 on ‚Äúhost1‚Äù, the SSH server on ‚Äúhost2‚Äù connects to localhost (which is for ‚Äúhost2‚Äù itself) to port 5432 and sends the data received by the ssh client to ‚Äúhost1‚Äù on port 9999 over this connection. <br>  IMPORTANT!  All connections indicated on the diagrams with arrows are separate TCP connections (sessions). <br></div></div><br><div class="spoiler">  <b class="spoiler_title">SSH server setup</b> <div class="spoiler_text">  Port forwarding is usually already enabled in the default sshd settings. <br>  / etc / ssh / sshd_config: <br> <code>AllowTcpForwarding yes</code> <br> </div></div><br>  We can also connect to the application not on the ‚Äúhost2‚Äù itself, but on any machine accessible to it: <br><br><img src="https://habrastorage.org/web/6f4/2d2/af8/6f42d2af88084934b08d66c81561980b.png" alt="image"><br><br>  To do this, when forwarding ports, instead of ‚Äúlocalhost‚Äù, we indicate the name of the host, for example, ‚Äúhost3‚Äù: <br><br> <code>host1# ssh -L 9999:host3:5432 host2</code> <br> <br>  It is important to note here that ‚Äúhost3‚Äù must be known (if this is the name, not the IP address) and is available for the host2 machine. <br><br>  It is also possible through ‚Äúhost1‚Äù to provide access to any other node (let's call it ‚Äúhost1A‚Äù) to the service on ‚Äúhost3‚Äù: <br><br><img src="https://habrastorage.org/web/82d/7f8/345/82d7f834541042758af4fd65ba86aca9.png" alt="image"><br><br>  To do this, insert into the ssh connection command the IP address of the interface on which local port 9999 will be raised: <br><br> <code>ssh -L 0.0.0.0:9999:host3:5432 host2</code> <br> <br>  In this example, port 9999 will be open on all available on ‚Äúhost1‚Äù IPv4 interfaces. <br><br><a name="t2"></a><h2>  2) Remote TCP forwarding </h2><br>  But what to do if, for example, ‚Äúhost2‚Äù does not have a white IP address, is it behind NAT or in general all incoming connections to it are closed?  Or, for example, Windows is on ‚Äúhost2‚Äù and there is no possibility to install an SSH server? <br><br>  For this case, there is Remote TCP forwarding: <br><br><img src="https://habrastorage.org/web/0ed/834/76e/0ed83476e544420facb0898f014c854a.png" alt="image"><br><br>  Now you need to establish an ssh connection in the opposite direction - from ‚Äúhost2‚Äù to ‚Äúhost1‚Äù.  Those.  Our administrative workstation will be an SSH server and will be accessible via SSH with ‚Äúhost2‚Äù, and on ‚Äúhost2‚Äù we will need to connect with an SSH client: <br><br> <code>ssh -R 9999:localhost:5432 host1</code> <br> <br><div class="spoiler">  <b class="spoiler_title">If on "host2" Windows</b> <div class="spoiler_text">  For example, in PuTTy it is done like this: <br>  Go through the settings tree: Connection ‚Üí SSH ‚Üí Tunnels. <br>  Next, in the field ‚ÄúSource port‚Äù we drive in 9999, in ‚ÄúDestination‚Äù - localhost: 5432, and below we select ‚ÄúRemote‚Äù, and click Add. <br>  Do not forget after that save session settings, if required. <br><br><img src="https://habrastorage.org/web/724/8a7/87e/7248a787e21049abbde7fa45c36825cc.png" alt="image"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">How it works</b> <div class="spoiler_text">  After successful connection, on ‚Äúhost1‚Äù the SSH server starts listening to port 9999. When connected to port 9999 on ‚Äúhost1‚Äù, the SSH client on ‚Äúhost2‚Äù connects to localhost (which is also ‚Äúhost2‚Äù for itself) to port 5432 and sends over this connection the data received by the ssh server on "host1" on port 9999. <br></div></div><br>  Also, you will have additional security issues on ‚Äúhost1‚Äù if you do not trust the host2 node.  However, this is beyond the scope of this article. <br><br>  And, of course, you must somehow (yourself or with help) initiate an ssh connection from ‚Äúhost2‚Äù by entering the above command, and ‚Äúhost1‚Äù must have a white IP address and an open SSH port. <br><br>  After installing an ssh connection, everything works in the same way as the previous chapter. <br><br><a name="t3"></a><h2>  3) TCP forwarding chain through several nodes </h2><br>  In closed networks, it often happens that the node we need is directly unavailable.  Those.  we can go to the desired host only by the chain, for example, host1 ‚Üí host2 ‚Üí host3 ‚Üí host4: <br> <code>host1# ssh host2 <br> host2# ssh host3 <br> host3# ssh host4 <br> host4# echo hello host4</code> <br> <br>  This can occur, for example, if these nodes are gateways, or if only gateways to neighboring subnets are accessible on them. <br><br>  In this case, we can also do TCP forwarding along the chain: <br><br><img src="https://habrastorage.org/web/0fe/32b/cf5/0fe32bcf5e4b43e78bf7beff99ce0d8e.png" alt="image"><br><br>  Here, ports 9991, 9992, 9993 are chosen for clarity, in practice you can use the same port (for example, 9999), if it is free on all nodes. <br><br>  Total need to run the following command chain: <br><br> <code>host1# ssh -L 9991:localhost:9992 host2 <br> host2# ssh -L 9992:localhost:9993 host3 <br> host3# ssh -L 9993:localhost:5432 host4</code> <br> <br><div class="spoiler">  <b class="spoiler_title">How it works</b> <div class="spoiler_text">  After successful execution of the above commands, the following is done on the nodes: <br><br><ul><li>  ‚Äúhost1‚Äù: opens port 9991, when connected to which data is redirected via ssh connection to port 9992 to ‚Äúhost2‚Äù; </li><li>  ‚Äúhost2‚Äù: opens port 9992, when connected to which data is redirected via ssh connection to port 9993 to ‚Äúhost3‚Äù; </li><li>  on ‚Äúhost3‚Äù: opens port 9993, when connected to which data is redirected via ssh connection to port 5432 on ‚Äúhost4‚Äù; </li></ul><br>  Thus, when connecting to port 9991 to ‚Äúhost1‚Äù, data is redirected along the chain to ‚Äúhost4‚Äù to port 5432. <br><br>  IMPORTANT!  All connections indicated on the diagrams with arrows are separate TCP connections (sessions). <br></div></div><br><a name="t4"></a><h2>  4) TCP forwarding ssh connections </h2><br>  Sometimes it is necessary to connect via ssh to a server that is directly unavailable, and access is possible only through a chain of ssh servers (see previous chapter).  Now we have the necessary knowledge to do the following: <br><br><img src="https://habrastorage.org/web/c96/af2/47a/c96af247a87743eb8bad70a5d90419bf.png" alt="image"><br><br> <code>host1# ssh -L 2222:localhost:2222 host2 <br> host2# ssh -L 2222:host4:22 host3</code> <br> <br>  Thus, on port 2222 on ‚Äúhost1‚Äù we now have forvarding on the SSH port (22) on ‚Äúhost4‚Äù.  We can connect: <br><br> <code>host1# ssh -p 2222 localhost <br> host4# echo hello host4</code> <br> <br>  It would seem, why is it necessary?  For example, here's why: <br><br> <code>#    host4 <br> host1# scp -P 2222 /local/path/to/some/file localhost:/path/on/host4 <br> #    host4 <br> host1# scp -P 2222 localhost:/path/on/host4 /local/path/to/some/file <br> #     TCP forwarding  host4 <br> host1# ssh -p 2222 -L 9999:localhost:5432 localhost <br> host1# psql -h localhost -p 9999 -U postgres <br> #  ,     ssh   -p   , <br> #    scp -P   </code> <br> <br>  Well, in general, it's great that now ‚Äúhost4‚Äù is so close :) <br><br>  Conclusion: you can do TCP forwarding at a high level of nesting. <br><br><div class="spoiler">  <b class="spoiler_title">RSA fingerprint notes</b> <div class="spoiler_text">  In some cases, scp will not work until you first log in via ssh -p 2222 localhost and accept the remote server's RSA fingerprint. <br><br>  If you use the same port (2222) to access different remote servers, there will be RSA fingerprint errors that remain from the previous server.  It will need to be removed from ~ / .ssh / known_hosts. <br></div></div><br><a name="t5"></a><h2>  5) SSH VPN Tunnel </h2><br>  TCP port forwarding is a great opportunity.  But what if we need more?  Access over UDP, access to multiple ports and hosts, access to dynamic ports?  The answer is obvious - VPN.  And the almighty SSH from version 4.3 and here will come to our aid. <br><br>  Looking ahead, I‚Äôll say: this SSH functionality works well if you need a temporary solution for some administrative tasks.  This option is far from the most suitable for building permanent VPNs, since it assumes TCP-over-TCP, which will have a bad effect on the connection speed. <br><br><div class="spoiler">  <b class="spoiler_title">More about TCP forwarding</b> <div class="spoiler_text">  But TCP port forwarding using SSH, if there is enough of it, in many cases will gain VPN performance, since when TCP port forwarding only application data is transmitted, not the original packets along with the headers, see link: <a href="http://blog.backslasher.net/ssh-openvpn-tunneling.html">http: //blog.backslasher.net/ssh-openvpn-tunneling.html</a> <br></div></div><br>  <b>SSH server setup:</b> <br>  PermitTunnel is turned off by default in sshd settings, it needs to be enabled in / etc / ssh / sshd_config: <br> <code>PermitTunnel yes</code> <br>  or <br> <code>PermitTunnel point-to-point</code> <br> <br>  <b>IMPORTANT</b> : to raise the new network interface of the tunnel on both the ssh client and ssh server requires superuser rights.  You can argue about how insecure it is, but in most cases the settings on the ssh server are enough: <br><br> <code>PermitRootLogin without-password</code> <br> <br>  Thus, you prohibit root login with a password, and allow only by other means, for example, using the RSA key, which is much safer. <br><br>  Restart sshd: <br> <code>sudo service sshd restart # centos</code> <br>  or <br> <code>/etc/init.d/ssh restart # (debian/ubuntu)</code> <br> <br>  The tunnel rises when using the magic key -w: <br><br> <code>host1# sudo ssh -w 5:5 root@host2</code> <br> <br>  Where 5: 5 is the interface number on the local machine and on the remote one, respectively.  Here you may be confused that ifconfig will not issue a ‚Äútun5‚Äù in the interface list.  This is because it is in the "down" state, but if you call "ifconfig -a" or "ifconfig tun5", the interface will be visible: <br><br> <code>host1# ifconfig tun5 <br> tun5 Link encap:UNSPEC HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 <br> POINTOPOINT NOARP MULTICAST MTU:1500 Metric:1 <br> RX packets:0 errors:0 dropped:0 overruns:0 frame:0 <br> TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 <br> collisions:0 txqueuelen:500 <br> RX bytes:0 (0.0 b) TX bytes:0 (0.0 b)</code> <br> <br>  Assigning IP addresses to interfaces and raising them: <br><br> <code>host1# sudo ifconfig tun5 192.168.150.101/24 pointopoint 192.168.150.102 <br> host2# sudo ifconfig tun5 192.168.150.102/24 pointopoint 192.168.150.101</code> <br> <br>  If there is a firewall, do not forget to allow connections from the tun5 interface: <br><br> <code>host1# #     <br> host1# sudo iptables-save &gt; /tmp/iptables.rules.orig <br> host1# sudo iptables -I INPUT 1 -i tun5 -j ACCEPT <br> host2# #     <br> host2# sudo iptables-save &gt; /tmp/iptables.rules.orig <br> host2# sudo iptables -I INPUT 1 -i tun5 -j ACCEPT</code> <br> <br>  It is not necessary to do this on host1, here it is done only for ping to work in both directions. <br><br>  Enjoying ping: <br><br> <code>host1# ping 192.168.150.102 <br> host2# ping 192.168.150.101</code> <br> <br>  If we consider an earlier example with PostgreSQL, now the scheme will be as follows: <br><br><img src="https://habrastorage.org/web/6eb/45b/bb0/6eb45bbb0b604c61b0158981a832f47a.png" alt="image"><br><br>  And the command to connect to the PostgreSQL server will look like this: <br><br> <code>host1# psql -h 192.168.150.102 -U postgres</code> <br> <br>  Well, then you can do any of these nodes by the gateway, if you want to provide access not to one node, but to the network.  For example: <br><br> <code>host2# #  IP forwarding <br> host2# sudo sysctl -w net.ipv4.ip_forward=1 <br> host2# #  IP forwarding  host1 <br> host2# sudo iptables -I FORWARD 1 -s 192.168.150.101 -j ACCEPT <br> host2# #  IP forwarding  host1 <br> host2# sudo iptables -I FORWARD 1 -d 192.168.150.101 -j ACCEPT <br> host2# #  IP  host1 <br> host2# sudo iptables -t nat -A POSTROUTING -s 192.168.150.101 -j MASQUERADE</code> <br> <br> <code>host1# # ,  host2     192.168.2.x,      host1 <br> host1# #  host2     192.168.2.x <br> host1# sudo ip route add 192.168.2.0/24 via 192.168.150.2 <br> host1# #      host1 <br> host1# ping 192.168.2.1</code> <br> <br>  After the end of the work, do not forget to return net.ipv4.ip_forward and the firewall to its original state. <br><br> <code>host1# sudo iptables-restore &lt; /tmp/iptables.rules.orig <br> host2# sudo iptables-restore &lt; /tmp/iptables.rules.orig</code> <br> <br><div class="spoiler">  <b class="spoiler_title">Under the spoiler a more interesting case with the temporary sharing of the Internet</b> <div class="spoiler_text">  Suppose you need to set up a server in a closed network where Internet access is prohibited, but nevertheless you have a loophole there ‚Äî access via a single ssh server or chain of ssh servers.  Suppose you need Internet access to set up a server.  It is then easier to set up temporary Internet access yourself on the server that you need to set up than to ask the attendants to do this. <br><br>  Suppose there is ssh access from your host1 host machine to the host2 server, from it to host3, and from there to the host4 you need.  Then we do TCP forwarding for ssh (if you can connect directly to host4 from host1, skip this step): <br><br> <code>host1# ssh -L 2222:localhost:2222 host2 <br> host2# ssh -L 2222:host4:22 host3</code> <br> <br>  Next, connect to host4 and raise the tun5 interface: <br><br> <code>host1# sudo ssh -p 2222 -w 5:5 root@localhost <br> host1# #   host4  : sudo ssh -w 5:5 root@host4 <br> host1# sudo ifconfig tun5 192.168.150.101/24 pointopoint 192.168.150.102 <br> host4# sudo ifconfig tun5 192.168.150.102/24 pointopoint 192.168.150.101</code> <br> <br>  We look at the routing table on host4, let's say we see the following: <br><br> <code>host4# route -n <br> Kernel IP routing table <br> Destination Gateway Genmask Flags Metric Ref Use Iface <br> 192.168.150.0 0.0.0.0 255.255.255.0 U 0 0 0 tun5 <br> 192.168.56.0 0.0.0.0 255.255.255.0 U 1 0 0 eth0 <br> 0.0.0.0 192.168.56.254 0.0.0.0 UG 0 0 0 eth0</code> <br> <br>  <b>IMPORTANT</b> !  Next, we most likely want to make the default route interface tun5 with the gateway 192.168.150.101, through which the Internet will be available.  Therefore, at this stage it is important to know exactly which routes need to be added in order to replace the default route.  This is important because quite often routes to individual networks are not prescribed separately, but simply set a default route (0.0.0.0/0) with a gateway, through which all inter-network traffic goes.  Moreover, it is likely that your ssh connection to the server also uses the original default gateway. <br><br>  For simplicity, in this example, assume that no routes other than 192.168.56.0/24 are needed for normal operation of the server and that the previous ssh host host3 has an IP address from the same network. <br><br>  We memorize and write somewhere the original route table with the default gateway: <br> <code>host4# route -n &gt; routes.orig</code> <br> <br>  We configure our host1 to work as a gateway to the Internet for host4: <br><br> <code>host1# #  IP forwarding <br> host1# sudo sysctl -w net.ipv4.ip_forward=1 <br> host1# #     <br> host1# sudo iptables-save &gt; /tmp/iptables.rules.orig <br> host1# #  IP forwarding  host4 <br> host1# sudo iptables -I FORWARD 1 -s 192.168.150.102 -j ACCEPT <br> host1# #  IP forwarding  host4 <br> host1# sudo iptables -I FORWARD 1 -d 192.168.150.102 -j ACCEPT <br> host1# #  IP  host4 <br> host1# sudo iptables -t nat -A POSTROUTING -s 192.168.150.102 -j MASQUERADE</code> <br> <br><div class="spoiler">  <b class="spoiler_title">Just in case, you can register gray networks on the gateway from the current route by default.</b> <div class="spoiler_text">  If not spelled out: <br> <code>sudo ip route add 192.168.0.0/16 via 192.168.56.254 <br> sudo ip route add 10.0.0.0/8 via 192.168.56.254 <br> sudo ip route add 172.16.0.0/12 via 192.168.56.254</code> <br> </div></div><br><br>  Change the default route to host4 (CAUTION, see warning above!): <br><br> <code>host4# sudo ip route replace default via 192.168.150.101 <br> host4# route -n <br> Kernel IP routing table <br> Destination Gateway Genmask Flags Metric Ref Use Iface <br> 192.168.150.0 0.0.0.0 255.255.255.0 U 0 0 0 tun5 <br> 192.168.56.0 0.0.0.0 255.255.255.0 U 1 0 0 eth0 <br> 0.0.0.0 192.168.150.101 0.0.0.0 UG 0 0 0 tun5</code> <br> <br>  If we do not need the entire Internet, but only specific IP addresses / masks, then we can not change the default route, but add only the addresses we need through the gateway to tun5. <br><br>  Checking what the Internet is: <br><br> <code>host4# ping 8.8.8.8</code> <br> <br>  Fine.  It remains to configure the DNS.  There are many ways to do this, the easiest way is to edit the /etc/resolv.conf file and add lines to it: <br><br> <code>nameserver 8.8.8.8 <br> nameserver 8.8.4.4</code> <br> <br>  After that, the Internet should be fully accessible: <br><br> <code>host4# ping ya.ru</code> <br> <br>  After finishing work, do not forget to return everything to its original state: <br><br> <code>host1# #     host1 <br> host1# sudo iptables-restore &lt; /tmp/iptables.rules.orig <br> host1# #      net.ipv4.ip_forward</code> <br> <br> <code>host2# #   -  host4: <br> host2# sudo ip route replace default via 192.168.56.254 <br> host2# #     DNS-  /etc/resolv.conf</code> <br> </div></div><br><a name="t6"></a><h2>  6) besparolnym in short </h2><br>  I think everyone already knows that password authorization is not about us.  But just in case, I will shove here a brief instruction on setting up authentication using the RSA key: <br><br>  1. On client machines, we generate the user the RSA key: <br><br> <code>client1# ssh-keygen -t rsa</code> <br> <br>  By default, the private key is stored in ~ / .ssh / id_rsa, and the public key is saved in ~ / .ssh / id_rsa.pub.  Keep the private key as the apple of the eye and do not give it to anyone, do not copy it anywhere. <br>  When creating a key, you can set a password (passphrase) with which the key will be encrypted. <br><br>  2. Client public keys need to be saved on the ssh server in the file ~ / .ssh / authorized_keys (~ this is the home directory of the user that will log in), each on a separate line.  In order not to do this manually, on each client you can use the command: <br><br> <code>ssh-copy-id user@sshserver</code> <br> <br>  Where user is the user name on the server, sshserver is the name or IP address of the ssh server. <br><div class="spoiler">  <b class="spoiler_title">Permissions to the file ~ / .ssh / authorized_keys</b> <div class="spoiler_text">  UPD from <a href="https://habrahabr.ru/users/sabio/" class="user_link">sabio</a> : In case of manual creation of the ~ / .ssh / authorized_keys file on the ssh server, the following rights must be set: <br> <code>chmod 0700 ~/.ssh <br> chmod 0600 ~/.ssh/authorized_keys</code> <br> </div></div><br><br>  3. Check that you can log into the server using the key, without entering the password (not to be confused with the passphrase): <br> <code>ssh user@sshserver</code> <br>  I recommend not to close at least one active ssh session with the server until you finally finish the configuration and make sure that everything works. <br><br>  4. Disable the password entry in the / etc / ssh / sshd_config file on the SSH server: <br><br> <code>PasswordAuthentication no</code> <br> <br>  The ability to log in with a public key is usually already enabled by default: <br><br> <code>PubkeyAuthentication yes</code> <br> <br>  I usually also disable the following two options: <br><br> <code>GSSAPIAuthentication no <br> UseDNS no</code> <br> <br>  In some cases, this allows you to speed up the connection process (for example, when the server does not have Internet access). <br><br>  5. Restart sshd: <br> <code>service sshd restart</code> <br>  or <br> <code>/etc/init.d/ssh restart</code> <br> <br>  In case of errors, it is useful to look at the / var / log / secure log or use the -v, -vv or -vvv options to display the detailed connection log: <br> <code>ssh -vvv user@sshserver</code> <br> <br><a name="t7"></a><h2>  7) Thank you (links) </h2><br>  <a href="https://help.ubuntu.com/community/SSH_VPN">help.ubuntu.com/community/SSH_VPN</a> <br>  <a href="https://habrahabr.ru/post/87197/">habrahabr.ru/post/87197</a> <br>  <a href="http://blog.backslasher.net/ssh-openvpn-tunneling.html">blog.backslasher.net/ssh-openvpn-tunneling.html</a> </div><p>Source: <a href="https://habr.com/ru/post/331348/">https://habr.com/ru/post/331348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331338/index.html">UX Designer Life Rules</a></li>
<li><a href="../331340/index.html">Building information landscapes using service tires</a></li>
<li><a href="../331342/index.html">How to competently deploy Wi-Fi at the hotel: typical questions and solutions</a></li>
<li><a href="../331344/index.html">ArrayBuffer and SharedArrayBuffer in JavaScript, Part 1: Short Memory Management Course</a></li>
<li><a href="../331346/index.html">DevOops 2017 Piter: New conference from the JUG.ru Group, let's talk about DevOps</a></li>
<li><a href="../331350/index.html">CodeRush for Roslyn for XAML features</a></li>
<li><a href="../331352/index.html">Magic introduction to classification algorithms</a></li>
<li><a href="../331354/index.html">HelpDesk and ServiceDesk. What is it and why does your company need it</a></li>
<li><a href="../331356/index.html">Laws and projects that will change the face of Russian IT. Part II</a></li>
<li><a href="../331358/index.html">Configuring the TheOnionBox web interface to monitor Tor's relay node</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>