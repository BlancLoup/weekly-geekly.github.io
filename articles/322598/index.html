<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Doom engine source code analysis: rendering</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From designer to player screen 
 Maps were designed by a level designer in 2D using the Doom Editor (DoomED). LINEDEFS described closed sectors (SECTO...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Doom engine source code analysis: rendering</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/b57/7b7/ad1/b577b7ad14e577ffa0253d231f4d71d0.jpg" alt="image"><br><br><h2>  From designer to player screen </h2><br>  Maps were designed by a level designer in 2D using the Doom Editor (DoomED).  LINEDEFS described closed sectors (SECTORS in the source code), and the third dimension (height) was indicated sector-by-sector.  The first level of Doom E1M1 looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/965/380/ab6/965380ab6db13c6aac03b97b66229dd6.jpg" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      After completion of work on the map, it is cut using the <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2580%25D0%25B0%25D0%25B7%25D0%25B1%25D0%25B8%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25B0">binary space partitioning</a> method (BSP).  LINEDEF chose recursively and turned their planes into cutting planes.  That is, LINEDEF was cut into segments (SEGS) until only convex subsectors remained (SSECTOR in the code). <br><br>  <u>Interesting fact:</u> Both DoomED and iBSP were written on ... Objective-C on NextStep workstations.  Fifteen years later, the same language in the same operating system performs the game on a mobile device!  <i>[approx.</i>  <i>Trans .: in 2010, Doom came out on the iPhone]</i> I worked a little bit as a web archaeologist and I managed to find the source code for idbsp.  It is worth a <a href="">look</a> . <br><a name="habracut"></a><br>  Below is an example of a recursive separation of a first-level map. <br><br>  <u>Recursion level 1</u> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c1d/3a8/e20/c1d3a8e200b005edf1ff43d679875178.jpg" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/19c/2d6/8f9/19c2d68f9f21a8edee0baf9fa535cbb5.jpg" alt="image"><br><br>  Blue marked the selected wall, turned into a cutting plane (red).  The secant plane was chosen in such a way as to balance the BSP-tree, as well as to limit the number of generated SEGS.  Green bounding boxes were used later to drop entire map fragments. <br><br>  <u>Recursion level 2 (only for the right subspace)</u> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd5/4f6/f7b/bd54f6f7ba22b5f6d5edc6b0ad69de15.jpg" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/188/700/798/188700798ce3496ebdd26950a086e119.jpg" alt="image"><br><br>  As a result, the SECTORS sectors were divided into convex subsectors (denoted as SSECTORS), and LINEDEFS were cut into segments (denoted as SEGS): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1b/fd3/1f2/d1bfd31f2c554210a9ff9b099e389616.jpg" alt="image"><br><br><h2>  Work process in general </h2><br>  Here is the main rendering method ( <code>R_RenderPlayerView</code> ): <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> R_RenderPlayerView (player_t* player) { [..] R_RenderBSPNode (numnodes<span class="hljs-number"><span class="hljs-number">-1</span></span>); R_DrawPlanes (); R_DrawMasked (); }</code> </pre> <br>  Four operations are performed here: <br><br><ul><li>  <code>R_RenderBSPNode</code> : all subsectors on the map are sorted using the BSP tree.  Large fragments are discarded using bounding boxes (shown in green in the previous image). </li><li>  <code>R_RenderBSPNode</code> : visible SEGS segments are projected onto the screen through a lookup table and truncated using a clipping array.  Walls are drawn as columns of pixels.  The size of the column is determined by the distance from the point of view of the player, the position of the Y column through height is associated with the player.  The bases and the tops of the walls create planes visplanes.  These structures are used for floor and ceiling rendering (they are called in flats code). </li><li>  <code>R_DrawPlanes</code> : Planes visplanes are converted from columns of pixels to rows of pixels and rendered on the screen. </li><li>  <code>R_DrawMasked</code> : <code>R_DrawMasked</code> ‚Äúobjects‚Äù (enemies, objects, and transparent walls). </li></ul><br><h2>  Sort binary space decomposition </h2><br>  Two examples with E1M1 (the first Doom card) and BSP are as follows: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//        //   ax + by + c = 0  //    = (a,b) //   (    A  B): normal = (-1,0) c = 3500 //  A (  A   A1  A2): normal = (1,0) c = -2500 //  B (  B   B1  B2): normal = (-0.24,0.94) c = -650 //     (x,y)  //        .</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/dcd/156/a3e/dcd156a3e1a8176f93fade18d7143059.jpg" alt="image"><br><br>  Traversing a BSP tree always starts at the root node and sorts both subspaces.  Recursion is performed for both child nodes. <br><br>  <u>Example 1:</u> The player (green dot) looks through the window from the point p = (2300,1900): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/814/ed8/963/814ed89634da3c39772f5ec0572c3839.jpg" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/118/3e6/88c/1183e688cbb0276c930a96dd3d5e9900.jpg" alt="image"><br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//   = ( 2300, 1900 ) // R_RenderBSPNode     AB (-x + 3500 = 0): -2300 + 3500 = 1200  , ,      . (A ,  B). //  R_RenderBSPNode        :   A1/A2  B1/B2. // R_RenderBSPNode   A1/A2 (x - 2500 = 0): 2300 - 2500 = -200  ,        . (A1 ,  A2). // R_RenderBSPNode   B1/B2 (-0.24x +0.97y - 650 = 0): -0.24 * 2300 + 0.97 * 1900- 650 = 641  ,       . (B1 ,  B2). :        : { A1, A2, B1, B2 }</span></span></code> </pre> <br>  <u>Example 2:</u> The player (green dot) looks from the secret balcony at the point p = (5040, 2400): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/55e/7b9/8db/55e7b98dbb2545781d54a2633aca4b30.jpg" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/66a/8d7/e95/66a8d7e9513319ec3790e93f2e2de0ed.jpg" alt="image"><br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//   = ( 5040, 2400 ) // R_RenderBSPNode     AB (-x + 3500 = 0): -5040 + 3500 = -1540  ,        . (B ,  A). //  R_RenderBSPNode        :   A1/A2  B1/B2. // R_RenderBSPNode   B1/B2 (-0.24x +0.97y - 650 = 0): -0.24 * 5040 + 0.97 * 2400 - 650 = 468  ,       . (B1 ,  B2). // R_RenderBSPNode   A1/A2 (x - 2500 = 0): 5040 - 2500 = 2540  ,       . (A2 ,  A1). :        : { B1, B2, A2, A1 }</span></span></code> </pre> <br>  BSP trees allowed SEGS to be sorted from any point on the map at a constant speed, regardless of the player‚Äôs position.  The price for this was one multiplication and one summation for each plane.  In addition, due to the testing of the bounding boxes, large parts of the map are discarded. <br><br>  <u>Note:</u> Not immediately obvious, but BSP sorts all the SEGS segments around the player, even those that he does not look at.  When using BSP, it is necessary to apply the cut-off by the pyramid of visibility <br><br><h2>  Walls </h2><br>  When sorting BSP walls (SEGS) from near to far, only the nearest 256 walls are rendered.  The two vertices of each SEGS are converted into two corners (relative to the player‚Äôs position). <br><br>  <u>Note:</u> In 1993, only the most powerful 486DX machines had an FPU (floating point coprocessor), so the Doom slider computed all angles using a binary angle measurement (Binary Angular Measurement, BAM) that only worked with <code>int</code> numbers, the <code>float</code> format was rarely used .  For the same reason, accuracy exceeding the accuracy of integers was achieved using <code>fixed_t</code> , a binary format of 16.16 with a fixed comma (for more information, read <a href="http://gameprogrammer.com/4-fixed.html">here</a> and <a href="http://netwinder.osuosl.org/pub/netwinder/docs/nw/fix1FAQ.html">here</a> ). <br><br>  After converting the X-coordinates of the screen space to the corners, they were obtained using lookup tables ( <code>viewangletox</code> ).  Since BAM was executed in <code>int</code> , the corners were first scaled from 32 to 13 bits using a 19-bit offset to the right to fit into an 8KB lookup table. <br><br>  Then the walls were trimmed according to the clipping array ( <code>solidsegs</code> . Some articles on the Doom engine mention a linked list, but it doesn't look like it was used).  After trimming, the remaining space was interpolated and drawn as pixel columns: the height and Y coordinate of the pixel column were based on the SEGS sector height and the distance from the player's point of view, respectively. <br><br>  <u>Note on clipping surfaces:</u> Clipping of invisible surfaces was done using <code>angle2-angle1 &gt; 180</code> .  Only the walls in the visible area were rendered. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/217/c2a/ca4/217c2aca4104a103b8f3940c49df0a3f.jpg" alt="image"><br><br>  <u>Note:</u> Not all walls consist of a single texture.  The walls could have a lower texture, an upper texture, and a medium texture (which could be transparent or translucent).  As seen in the video below, it was convenient for simulating windows: the ‚Äúwindow‚Äù is actually a sector with high floors and a missing average texture. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/X0-37F4L5A4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <u>Interesting fact:</u> Since the walls were rendered as vertical columns, the textures of the walls were kept in memory rotated 90 degrees to the left.  This trick allowed for full use of the CPU's pre-caching feature: the process of reading a texel wall from RAM also pre-filled the CPU cache with eight adjacent texels on each side.  Since the subsequent read data was already in the RAM cache, a significant decrease in read latency was achieved.  You can read more about pre-caching and aligning data in memory in the book The Art of Assembly Language Programming (Section 3.2.4 Cache Memory). <br><br><h2>  Flat surfaces (floor and ceiling), or the infamous visplanes </h2><br>  When drawing the columns of the walls, the upper and lower coordinates of the screen space were used to generate ‚Äúvisplanes‚Äù, areas in the screen space (not necessarily continuous horizontally).  This is how visplane_t is declared in the Doom engine. <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// //    visplane? // typedef struct { fixed_t height; int picnum; int lightlevel; int minx; int maxx; byte top[SCREENWIDTH]; byte bottom[SCREENWIDTH]; } visplane_t;</span></span></code> </pre> <br>  The first part of the structure stores information about the ‚Äúmaterial‚Äù, ( <code>height, picnum, lightlevel</code> ).  The last four members define the covered area of ‚Äã‚Äãthe screen space. <br><br>  If two subsectors have the same material (height, texture and illumination level), the Doom engine tried to merge them together, but due to the visplante_t structure limitations this was not always possible. <br><br>  For the entire width of the screen, visplane can store a pixel column location (since visplanes are obtained by projecting walls onto the screen, they are created as columns of pixels). <br><br>  Here are the three main visplanes of the home screen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f1/69e/feb/7f169efeba1c9a9d6be9d4c5059d1c62.jpg" alt="image"><br><br>  The green plane is particularly interesting: it demonstrates that <code>visplane_t</code> can store discontinuous (but only in the horizontal direction) areas.  Since the column is continuous, the visplane can store it.  This limitation manifests itself in the engine: some subsectors can be merged and rendered using one visplane, but if there is something vertically between them, then merging is impossible. <br><br>  Here is a screenshot and a corresponding video showing the visplane fragmentation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b57/7b7/ad1/b577b7ad14e577ffa0253d231f4d71d0.jpg" alt="image"><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8VqLqbwjn8M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <u>Interesting fact:</u> The hard-coded visplanes limit ( <code>MAXVISPLANES</code> 128) was a big headache for modders, because the game was falling out and returning to DOS.  There may be two problems: <br><br><ul><li>  <code>"R_FindPlane: no more visplanes"</code> : The total number of different visplanes materials (height, texture and light level) is greater than 128. </li><li>  <code>R_DrawPlanes: visplane overflow (%i)</code> : the number of visplanes fragmented exceeded 128. </li></ul><br>  Why limit the number to 128?  Two stages of the rendering pipeline required performing a search on the visplanes list (using <code>R_FindPlane</code> ).  The search was linear, and perhaps for numbers greater than 128 turned out to be too expensive.  Lee Killough later extended this limit, replacing the linear search with a hash-chain implementation. <br><br><h2>  Objects and transparent walls </h2><br>  After all solid walls and walls with a ‚Äútransparent medium texture‚Äù, as well as the surfaces of ceilings and floors are rendered, only ‚Äúobjects‚Äù remain: enemies, barrels, ammunition and translucent walls.  They are rendered from the farthest to the nearest ones, but they are not projected into the screen space using the wall lookup table.  The rendering process is performed by computing 16.16 binary numbers with a fixed decimal point. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VzCHC1V5nWU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Note: This video shows one of the worst-case scenarios when some pixels have to be redrawn three times. <br><br><h2>  Profiling </h2><br>  Downloading Chocolate Doom to Instruments on Mac OS X allowed doing some profiling: <br><br>  It seems that the port [on the iPhone] rather accurately corresponds to the ‚Äúvanilla‚Äù Doom: most of the time, the walls ( <code>R_DrawColumn</code> ), the ceiling / floor ( <code>R_DrawSpan</code> ) and the objects ( <code>R_DrawMaskedColumn</code> ) are <code>R_DrawMaskedColumn</code> .  In addition to drawing, I noticed high resource costs for interpolating walls ( <code>R_RenderSegLoop</code> ) and converting the visplane from columns to rows of pixels ( <code>R_MakeSpans</code> ).  Then, finally, it comes to AI ( <code>R_MobjThinker</code> ) and the BSP tree <code>R_RenderBSPNode</code> ( <code>R_RenderBSPNode</code> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/960/1c2/2d7/9601c22d7e3f9e6aed93f71b41bbe52b.png" alt="image"><br><br>  With the help of the inverted call tree, you can see that most of the work really consists in traversing the BSP tree, rendering the walls and generating visplanes: <code>R_RenderBSPNode</code> (the second column is the percentage of time spent). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3b/a49/cbd/d3ba49cbdde4dbb803a6a7f4f0868fb9.png" alt="image"><br><br><h2>  Together </h2><br>  And finally, a video of generating the legendary first screen in which you can see in order: <br><br><ul><li>  Walls as rows of pixels, from near to far </li><li>  Flat surfaces as rows of pixels, from near to far </li><li>  Items from far to near. </li></ul><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wcHQMufUVWo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Interesting Facts </h2><br><ul><li>  Since Doom was developed on the NeXTSTEP system with a linear virtual memory model, id Software decided to abandon the <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2588%25D0%25B8%25D1%2580%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C">EMS</a> and <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25BE%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BD%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C">XMS</a> that were used in most games of that time.  Instead, developers used DOS / 4G, a memory expander that allowed software to access RAM in protected mode in a real-mode operating system (DOS). </li><li>  The NexT workstation was so powerful that it was able to run the editor, the game, and the debugger at the same time.  When the game was fairly stable, the code was sent over the network to a PC, where it was compiled under DOS / x86 by the Watcom compiler.  Thanks to DOS / 4G, the code was executed in the same memory model on both the PC and NeXT. </li><li>  An interesting video that complements the book "Masters of Doom": <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RDAzJLBB6pE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></li><li>  Many details can be explored on the sites of John Romero (John Romero) <a href="http://rome.ro/2006/12/apple-next-merger-birthday.html">rome.ro</a> and <a href="http://planetromero.com/2009/01/doom-history-1994">planetromero.com</a> . </li></ul><br><h2>  Recommended reading </h2><br><ul><li>  <a href="">The original source code</a> , released in 1997, is easy to read, but there are few or no comments, it does not compile, there is no source code for the audio subsystem (due to licensing issues). </li><li>  <a href="http://www.chocolate-doom.org/wiki/index.php/Chocolate_Doom">Chocolate Doom</a> : Oh, yes!  This is just a terrific port, it is based on SDL and compiles with brio on almost any platform.  This is the port I hacked to generate a video for the article. </li><li>  The book "Graphics Programming Black Book" by Michael Abrash.  It helps to understand BSP-trees and is a great source of inspiration.  This guy might even make you fall for an assembler. </li><li>  <a href="http://www.amazon.com/Masters-Doom-Created-Transformed-Culture/dp/0812972155">Masters of Doom</a> : the history of id Software with many details about creating Doom </li></ul></div><p>Source: <a href="https://habr.com/ru/post/322598/">https://habr.com/ru/post/322598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322584/index.html">JQuery Masonry - dynamic layout, typeset without ‚Äúholes‚Äù</a></li>
<li><a href="../322586/index.html">Penguin grub color</a></li>
<li><a href="../322588/index.html">Translation of the ESRI Interior Building Data Model Concept (BISDM)</a></li>
<li><a href="../322592/index.html">The experience of creating a course on Android development on Udemy</a></li>
<li><a href="../322596/index.html">Implementing OOP inheritance in classes that work with SQL and MS Entity Framework</a></li>
<li><a href="../322600/index.html">IoT Security: Securing Azure IoT Deployment</a></li>
<li><a href="../322602/index.html">Why i ignore google recruiters</a></li>
<li><a href="../322604/index.html">Query translation to SQL using LinqToSql in tests</a></li>
<li><a href="../322606/index.html">Experience preparing and passing the Oracle Certified Professional Java SE 8 Programmer 1Z0-810 exam</a></li>
<li><a href="../322608/index.html">Parsim weblancer using PROXY</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>