<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Thread issues. Edward A. Lee</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="annotation 
 Flows are a direct adaptation of the now dominant sequential model of computation to parallel systems. Programming languages ‚Äã‚Äãdo not req...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Thread issues. Edward A. Lee</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage3/36d/ec0/627/36dec06270f01632195bf0dcb51874ea.jpg"><br><h1>  annotation </h1><br>  Flows are a direct adaptation of the now dominant sequential model of computation to parallel systems.  Programming languages ‚Äã‚Äãdo not require (or require very little) syntax changes to support threads, and operating systems and architectures are continually evolving to increase the efficiency of their use.  Many technologists (engineers) seek to use multithreading intensively in software and expect to get a significant (predicted) increase in performance.  In this paper, I argue that this is not a good idea.  Although the use of threads seems to be a small step from sequential calculations, in fact, it is a huge step.  The use of streams destroys such inherent properties of sequential calculations as clarity, predictability and certainty (determinism).  Threads, as a computation model, are very non-deterministic, and the work of programs also becomes uncertain.  Although many of the studied techniques improve the computational model by reducing uncertainty more effectively, I argue that they do not completely solve the problem.  Instead of reducing uncertainty, we have to build a model of calculations based on full determinism in the interaction of software components.  Uncertainty should be explicitly and accurately entered where there is a need for it, instead of being removed where there is no need.  I argue the advantage of developing parallel component coordination languages.  I believe that such languages ‚Äã‚Äãwill be much more reliable, and programs will be more parallelized. <br><a name="habracut"></a><br><h1>  1. Introduction </h1><br>  Everyone knows that programming parallel systems is difficult.  In addition, following the imperative of parallel programming is becoming more and more difficult.  Many engineers predict that the end of Moore‚Äôs law will be canceled by increasing the parallelism of computing system architectures (multi-core, multi-processor) [15].  If we expect to continue to increase computing performance, programs should be able to use this parallelism.  One of the possible technical solutions is automating the use of parallelism in sequential programs at the hardware level, for example, dynamic dispatching or at the program level using automatic parallelization of sequential programs [6].  Nevertheless, many researchers agree that these techniques are ineffective and can use only a little parallelism of programs.  A more natural solution - programs must themselves become "more parallel." <br><br>  If we understand why parallel programming is so complicated, we have a greater chance to solve the problem.  Sutter and Larus [47] noted: ‚Äúpeople quickly become disillusioned with concurrency due to more complex code than in sequential programs.  Even neat people miss the possible alternation, even among a simple set of partially ordered operations. ‚Äù <br><br>  The physical world is largely parallel, and our survival depends on our ability to talk about parallel physical dynamics.  The problem is that we have chosen parallel programming abstractions that remotely resemble the parallelism of the physical world.  We began to use these computational abstractions in such a way that now we even forgot that they are not constant.  In this paper, I conclude that the difficulties of parallel programming are a consequence of the wrong choice of abstractions, and if we decided to abandon these abstractions, problems would become solvable. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The optimistic point of view is given by Barrosso [7], who concludes that technological forces will lead computing in servers and desktops to parallel multiprocessing (concurrent multiprocessing, CMP), and when technologies become mainstream, programming problems will be solved.  But we should not underestimate the difficulties.  One of the requirements of Stein (Stein) says: "replace the traditional metaphor of the <em>sequence of steps with the</em> concept of <em>combining interacting entities</em> " [46].  This article addresses this particular case. <br><br><h1>  2 Streams </h1><br>  In the practice of developing general-purpose software, we have reached the point at which the only approach to parallel programming dominates all others, namely, the streaming model of computing (or simply streams).  Threads are sequential processes that have shared memory.  They represent a key model of parallelism, supported by modern computers, programming languages ‚Äã‚Äãand operating systems.  The many commonly used parallel architectures of today (for example, SMP architecture - symmetric multiprocessors or shared memory processing) are a direct hardware implementation of the ‚Äúflow‚Äù abstraction. <br><br>  Some applications can use threads very effectively.  So-called ‚Äúembarrassingly parallel‚Äù applications (for example, applications that inherently spawn many independent processes, such as build utilities ‚Äî Parallel Virtual Machine (PVM), gmake, or a web server).  Due to the independence of these applications, programming them is relatively easy, and the abstraction used here is more ‚Äúprocesses‚Äù (which do not have shared memory) than ‚Äúthreads‚Äù.  When such applications share data, they do it using database abstractions that control concurrency using the transaction mechanism.  However, the client side of the application is quite complicated.  Again quoting Suter and Larus [47]: <br><br>  <em>‚ÄúThe world of client applications is not well structured.</em>  <em>Parallel computing processes can interact and share data in a variety of ways.</em>  <em>Heterogeneous code;</em>  <em>granularity, complexity of interactions;</em>  <em>Pointer data structures ‚Äî all of which make this type of program difficult for parallel programming. ‚Äù</em> <br><br>  Of course, threads are not the only opportunity for parallel programming.  In scientific computing, in which performance has long required and uses parallel programming.  Language extensions for data parallelism and the messaging library (PVM [23], MPI [39], OpenMP) - these technologies dominate threads in terms of parallel programming capabilities.  In fact, computer architectures aimed at scientific computing are often significantly different from general-purpose architectures.  For example, they usually support vectors and threads at the hardware level.  However, in this area, parallel programs remain laborious to write.  Languages ‚Äã‚ÄãC and Fortran dominate, despite the long history of much better parallel programming languages.  In distributed computing, streams are often not practical abstractions, since  creating the illusion of having shared memory can be too costly.  Even in spite of this fact, we have come a long way towards creating a distributed computing mechanism that emulates multithreaded programming.  CORBA and .NET, for example, dominate among distributed object-oriented techniques.  In them, software components interact with each other through an intermediary that behaves as if we had local objects in shared memory.  The abstraction of object-oriented data limits the use of shared memory illusions, so these techniques are fairly effective.  They make distributed programming look like multi-threaded programming. <br><br>  Embedded programming also uses a different parallelism model from threads.  Programmable digital signal processing systems often have a VLIW machine architecture.  Video signal processing is combined with SIMD, with VLIW and with streaming (streaming) processing.  Network handlers provide explicit hardware support for streaming data.  Nevertheless, in spite of a significant amount of innovative research, in practice, the programming models for the listed architectures remain primitive.  Developers write low-level assembler code that uses the specific properties of the hardware, and combine this code with the code in C only where performance is not critical. <br><br>  An interesting feature of many embedded system applications is that reliability and predictability are much more important than expressiveness (expressive capabilities) or performance.  This is debatable for universal computers, but this question lies aside from the subject of this work.  I will prove that achieving reliability and predictability is usually not possible with threads for many applications. <br><br><h1>  3 Flows as computational model </h1><br>  In this section, I will analyze the fundamentals of threads, without reference to specific libraries or languages, and show that the computation model based on them is essentially incorrect.  In the next section, I will review some of the proposed amendments to the model. <br><br>  Let the set N = {0,1,2, ...} be the set of natural numbers.  Also, let B = {0, 1} be the set of binary digits (bits), and B * the set of all sequences of bits of finite length.  Then <img src="https://habrastorage.org/storage3/a9e/2c8/9d8/a9e2c89d8b9115627656bc5cdf6f55f7.jpg">  - the set of all sequences of bits of infinite length (each of which is a function that maps N to B).  Also, let <img src="https://habrastorage.org/storage3/b6f/e40/7cd/b6fe407cd8c5a642367d12b8d0687f61.jpg">  [17].  We will use B ** to represent the state of the computer: its inputs (of which, potentially, is an infinite number) and its outputs (of which there can also be infinitely many).  Let be <img src="https://habrastorage.org/storage3/744/7be/59e/7447be59e1ed98e3828b76f26ff969d6.jpg">  denotes the set of all partial functions with a domain of definition and change - B ** (partial functions are functions that may or may not be defined on each element of their domain). <br><br>  <em>The imperative machine</em> ( <i>A, c</i> ) is a finite set <img src="https://habrastorage.org/storage3/9ad/b17/3d6/9adb173d6b22029f89be466b251a0a16.jpg">  atomic action and <em>control function</em> with: <img src="https://habrastorage.org/storage3/a84/147/13d/a8414713dad40df7672036b90b463720.jpg">  .  The set <i>A</i> represents the atomic actions (instructions) of the machine, and the function c reflects the sequence of execution of these actions.  We assume that <i>A</i> contains as one of the instructions a stop instruction <img src="https://habrastorage.org/storage3/e67/f87/01b/e67f8701bd6df0e0afe54bc0ddba144a.jpg">  .  That is, the stop instruction does not change the state of the machine. <br><br>  <em>A sequential program of</em> length m <img src="https://habrastorage.org/storage3/754/430/47e/75443047edcc250221cb7206776a86d0.jpg">  N is called a function <img src="https://habrastorage.org/storage3/d9b/c20/fa4/d9bc20fa41186e61afd405ece329ce6d.jpg">  where <img src="https://habrastorage.org/storage3/005/f11/58b/005f1158bc1257a9f7a2060f7e950f7c.jpg">  .  That is, a sequential program includes a finite number of normal instructions and an infinite number of stop instructions.  Note that the set of all sequential programs, which we denote by <i>P</i> , is a countable infinite set. <br><br>  The execution of this program is a <em>stream</em> .  It starts from the beginning. <img src="https://habrastorage.org/storage3/e6e/8de/552/e6e8de552a41479e325f4c9b627d7125.jpg">  which reflects the initial state of the machine and its inputs.  For all <img src="https://habrastorage.org/storage3/399/d34/add/399d34addfd0013b986d259e04290e51.jpg"><br><img src="https://habrastorage.org/storage3/c6e/9c6/822/c6e9c6822aacff3f7e7e99d060438aab.jpg">  (one) <br>  Here, <img src="https://habrastorage.org/storage3/099/5f0/31b/0995f031b7f54b1e910ab1e49787aab0.jpg">  is the index in the program <i>p of the</i> following instruction <img src="https://habrastorage.org/storage3/c58/591/7ea/c585917ea6d5d3912bcb7fcdccf381ee.jpg">  .  This instruction applies to the state. <img src="https://habrastorage.org/storage3/c0a/c4f/af6/c0ac4faf6601a6cea9ae8e017f599d03.jpg">  to get the next state <img src="https://habrastorage.org/storage3/832/16b/ba6/83216bba621ce6f58f1ea7fb696b89a8.jpg">  .  If for any <img src="https://habrastorage.org/storage3/524/d6e/544/524d6e5446bcff4b0670896798bbc711.jpg"><img src="https://habrastorage.org/storage3/b26/ab8/40a/b26ab840a337ac7d9824e3d8596adcac.jpg">  then <img src="https://habrastorage.org/storage3/c58/591/7ea/c585917ea6d5d3912bcb7fcdccf381ee.jpg">  = h and the program stops in the state <img src="https://habrastorage.org/storage3/c0a/c4f/af6/c0ac4faf6601a6cea9ae8e017f599d03.jpg">  (i.e. the state no longer changes).  If for all initial states the program <i>p</i> stops, then <i>p</i> describes the final function in <i>Q.</i>  If the program <i>p</i> stops only for some <img src="https://habrastorage.org/storage3/842/956/f07/842956f0743edd4dcbd0208342ea83b9.jpg">  , then it describes a partial function in <i>Q</i> (it is easy to show that <i>Q</i> is an uncountable set (even a subset of constant functions of the set <i>Q is</i> not countable, since B ** is uncountable in itself. And this can easily be demonstrated using the diagonal argument Cantor) Since the set of all finite programs <i>P</i> -. countable, we can conclude that not all functions in <i>Q</i> can be given final program Therefore, any sequential machine has limited expressiveness of Turing and Church [48] have shown that a variety of choices sequence..  tionary machines <i>(A,)</i> is reflected in the <i>P</i> programs that can give exactly the same subset of <i>the Q.</i> This subset is a subset <i>efficiently computable functions)).</i> <br><br>  Now we turn to the kernel of the sequential program.  Let the program and the initial state be given, as well as the sequence (1) defined.  If the sequence stops, then the function calculated by the program is defined.  Any two programs <i>p</i> and <i>p '</i> can be compared with each other.  They are equivalent if they compute the same partial function.  That is, they are equivalent if they stop for the same initial states and for these states have the same final state (in the classical theory, when the programs do not stop, they are considered equivalent, which creates serious problems for the application of the theory of computations to embedded systems software, in which programs never stop [34]).  Such an equivalence theory is important for any constructive formalism.  These essential program properties are lost when multiple threads are used.  Consider two programs <img src="https://habrastorage.org/storage3/776/35f/f0e/77635ff0e3826ffbc793ac7973aede74.jpg">  and <img src="https://habrastorage.org/storage3/d05/cd7/be2/d05cd7be206751244dd20e40ffd0a5c1.jpg">  that run in parallel.  What do we mean when we replace expression (1) with the formula: <br><img src="https://habrastorage.org/storage3/4f6/b39/396/4f6b39396f49a868977ba0199aa865a9.jpg">  (2) <br>  At each step n, each of the programs can perform the next atomic action.  Check now whether constructive equivalence theory is obtained.  That is, when two given multithreaded pairs of programs <img src="https://habrastorage.org/storage3/4aa/d0a/2d4/4aad0a2d4542d9acab5e0b9a9aaddb4c.jpg">  and <img src="https://habrastorage.org/storage3/192/089/73f/19208973fdb058c808b7afe26b03d4a5.jpg">  will be equivalent?  The extension of the basic theory determines them to be equivalent when <i>all the alternations</i> stop for the same initial state in the same final state.  The huge number of possible variations of alternations makes the proof of equivalence extremely difficult.  The exception is trivial cases, for example, the states B ** are divided, so the execution of each program does not affect the sections of other programs. <br><br>  Thus, if two programs <i>p</i> and <i>p '</i> are launched in a multithreaded environment, we can no longer judge their equivalence.  In fact, we need to be aware of all the other threads that can be started, and we should analyze all possible interlaces.  We can thus conclude that the equivalence theory cannot be applied to flows. <br><br>  Even more than that, implementing a multithreaded computational model is extremely difficult.  As evidence, one can mention the subtleties of the memory model of the Java language [41, 24], in which even a very trivial program can behave ambiguously. <br><br>  The core of the abstractions of computations represented in formula (1), on which all widely used programming languages ‚Äã‚Äãare based, emphasizes the deterministic composition of deterministic components.  These actions are deterministic, and their sequential composition is also deterministic.  Sequential launching, by the meaning, is a functional composition ‚Äî a simple model in which deterministic components produce deterministic results. <br><br>  Threads, on the other hand, are extremely non-deterministic.  The job of a programmer is to reduce this uncertainty.  We have, of course, developed supporting tools to reduce uncertainty.  Semaphores, monitors, and more advanced threading mechanisms (which will be discussed in the next section).  These techniques allow the programmer to greatly reduce uncertainty.  But this reduction is rarely satisfactory. <br><br>  Let us give another analogy, suppose that we asked a mechanical engineer to develop an internal combustion engine made of iron cans, hydrocarbons and oxygen molecules, moving randomly due to the effect of temperature.  Thermodynamics and chemistry tell us that this is possible in theory, but is it possible in practice? <br><br>  Let's look at the third analogy.  The everyday definition of <i>madness</i> is to do the same thing over and over again, expecting that the results will be different.  By this definition, we, in fact, demand that programmers of multi-threaded systems be insane.  If they were normal, they would not be able to understand their programs. <br><br>  I will prove that we should and can build a parallel model of computation in such a way that it is as specific as possible.  Uncertainty should be introduced carefully and only where necessary, as well as in sequential programming.  Threads use the opposite approach.  They make programs to absurdities vague and rely on a programming style that limits these uncertainties in order to achieve certain goals. <br><br><h1>  4 How bad is it in practice? </h1><br>  We have proven that threads are an extremely useless mathematical model of computation.  As for practice: many programmers today write programs that work. <br><br>  Is there a contradiction here?  In practice, the programmer is provided with the tools to reduce most of the uncertainty.  For example, object-oriented programming limits the visibility of certain parts of a program that determine its state.  This effectively splits the state space B ** into disjoint sets.  Where programs operate on the open parts of this state space, semaphores, mutually exclusive locks, and monitors (objects with mutually exclusive methods) provide mechanisms that programs can use to reduce even more uncertainty.  But in practice, these techniques make programs understandable only for very simple interactions. <br><br>  Consider the well-known and widely used pattern ‚ÄúObserver‚Äù [22].  The Java implementation of this pattern is shown in Listing 1. It shows two class methods in which, when the setValue () method is called, a value change notification is triggered (by calling the valueChanged () method for all objects that have been registered by calling the addListener () method . <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List listeners = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedList(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> interface Listener { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">valueChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Listener listener)</span></span></span><span class="hljs-function"> </span></span>{ listeners.add(listener); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue)</span></span></span><span class="hljs-function"> </span></span>{ value = newValue; Iterator i = listeners.iterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i.hasNext()) { ((Listener)i.next()).valueChanged(newValue); } } }</code> </pre> <br>  Listing 1. Java implementation of the Observer pattern, designed to run in one thread <br><br>  The code in Listing 1 is not thread safe, since  if multiple threads invoke the setValue () or addListener () method, it may happen that the listeners list is modified while the iterator goes through the list.  This will cause an error and, probably, an unexpected program termination. <br><br>  The simplest solution is to add the Java language synchronized to the definitions of the setValue () and addListener () methods.  The synchronized keyword implements mutual exclusion of methods, including instances of the ValueHolder class into monitors, which prevent simultaneous calling of these methods in any two threads.  When a synchronized method is called, the thread that calls it tries to block the object, to receive it exclusively.  If any other thread blocks the object, then the calling thread will stop until the lock is released. <br><br>  However, this decision is not reasonable, because  may lead to deadlocks.  Suppose we have an instance a of the ValueHolder class and an instance b of another class that implements the Listener interface.  The latter class can do anything in its valueChanged () method, including getting a lock on another monitor.  If he cannot get the lock, he will continue to block the object of the ValueHolder class.  In the meantime, another thread may call the addListener () method for object a.  Both streams will then be blocked without hope of unlocking.  This type of potential deadlock is hidden in many programs that use monitors. <br><br>  Consider the improved implementation shown in Listing 2. At the time the object is locked, the setValue () method makes a copy of the listeners list.  Since the addListeners () method is synchronous, it helps to avoid the occurrence of an error when modifying the list.  Further, the valueChanged () method is called outside of a synchronized block to avoid deadlock. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List listeners = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedList(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> interface Listener { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">valueChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> synchronized </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Listener listener)</span></span></span><span class="hljs-function"> </span></span>{ listeners.add(listener); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue)</span></span></span><span class="hljs-function"> </span></span>{ List copyOfListeners; synchronized(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { value = newValue; copyOfListeners = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedList(listeners); } Iterator i = copyOfListeners.iterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i.hasNext()) { ((Listener)i.next()).valueChanged(newValue); } } }</code> </pre><br>  Listing 2. Java implementation of the Observer pattern and attempts to make code thread-safe <br><br>  It is tempting to think that we have solved the problem, but in fact, the code is still incorrect.  Suppose two threads call the setValue () method.  One of them will set the value last, leaving this value in the field of the object.  But listeners can be notified that the value has changed in the reverse order.  "Listeners" can conclude that the final value contained in the object of the ValueHolder class is incorrect. <br><br>  Of course, this pattern can be implemented in Java so that it works steadily (I leave it as an exercise for the reader).  The fact is that even this simple and commonly used design pattern requires some rather complex analysis of possible call alternations.  I think most multithreaded programs have such errors.  Moreover, I believe that these errors today are not the main obstacles just because today's architectures and operating systems provide modest possibilities for parallel programming.  The cost (time) of switching process contexts is too high, so only a tiny percentage of possible alternations of thread instructions occur in practice.  My guess is that most multi-threaded general-purpose applications, in fact, contain many errors in the implementation of parallelism, because  Since the multi-core architecture becomes the most common, these errors will manifest as system crashes.  Such a scenario is very harsh for computer vendors: their next generation of machines is famous for the fact that programs on these machines often fall. <br><br>  These same vendors protect multi-threaded programming because they have support for concurrency and are willing to sell it to us.  For example, Intel is conducting an active campaign, as a result of which many of the leading academic programs on information technology will focus on multi-threaded programming.  If they succeed in their work, then the next generation of programmers will use multi-threaded programming more intensively, and then the next generation of computers will become almost useless. <br><br><h1>  5 Adjusting the flow model with more aggressive uncertainty reduction </h1><br>  In this section, I will discuss approaches for solving the problem described in the section header.  These approaches will preserve the thread-based computational model for programmers, but will provide them with more efficient mechanisms for eliminating the uncertainty of program behavior. <br><br>  The first technique is to improve the software engineering process.  This is important for obtaining reliable multithreaded programs.  This, however, is not enough.  Here is a warning from the Ptolemy project run by the Berkeley Institute.  At the beginning of the year 2000, my group began developing the Ptolemy II core [20], a programming environment that supports the parallel computing model.  One of the early goals was to allow the modification of parallel programs using the GUI in the mode of their execution.  The difficulty is to ensure the consistency of the flows in the conflicting program structure.  It was supposed to use a strategy with Java-streams and monitors. <br><br>  One of the goals of the pilot project was to verify whether effective software engineering practitioners would be useful for scientific research.  We developed a process that included: a rating system for the ‚Äúmaturity‚Äù of a program consisting of four levels: red, yellow, green, and blue;  project analysis, code analysis, nightly builds, regression testing, automated code markup [43].  The part of the core that guaranteed consistency in the presentation of the program structure was written in early 2000.  The analysis of the project was yellow on the entered scale, code analysis was green.  The analysis was carried out by experts in the field of parallel programming.  We wrote regression tests for 100% of the code.  The nightly builds and regression tests were run on a dual-processor SMP machine, which was manifested in the excellent behavior of the programs from the behavior on the single-processor development machines.  The Ptolemy II system has become widely used.  No problems were observed until deadlock appeared on April 26, 2004 (4 years after the start of development). <br><br>  Obviously, our relatively rigorous practice of designing parallel programs helped to identify and fix a lot of bugs related to parallel execution.  But in fact, such a serious bug as deadlock has not been identified, and this is alarming.  How many such problems remain?  How long is it necessary to test so that we can be sure that there are no bugs?  With regret, I must conclude that testing cannot reveal all the problems in a non-trivial multithreaded code. <br><br>  Of course, there are seemingly simple rules for eliminating the appearance of deadlocks [32].  For example, the lock is always in the same order.  But such a rule is very difficult to apply in practice, because  There are no specialized techniques in common languages ‚Äã‚Äãthat would show how the method was blocked by a call.  Therefore, it is necessary to conduct a study of the source code of all the methods that were called, as well as all the methods that were called in these methods, etc.  Even if we correct this language problem by making locks part of the method signature, this rule will make it very difficult to implement symmetric access (when interactions can be initiated from either end).  A solution to the problem in which the implementation of mutually exclusive locks would not be extremely difficult is unknown.  If programmers cannot understand their code, the code will not be reliable. <br><br>  One can conclude that the problem is how Java implements the threading model.  The synchronized keyword may not be the best tool to reduce uncertainty.  Indeed, the version of Java 5.0, introduced in 2005, introduced additional mechanisms for synchronizing threads.  They enriched the programmer‚Äôs toolkit to reduce uncertainty.  But these mechanisms (for example, semaphores) are still difficult to use, and it is very likely that their use will result in incomprehensible programs with cunning hidden errors. <br><br>  Only the construction of a competent software design process does not solve the problem.  Another approach that can help is the use of design patterns that have been specifically studied for parallel computing [32, 44].  Indeed, this is a huge help in the case when the programming task corresponds to one of the patterns.  However, there are two difficulties.  One is the implementation of a pattern, which can be very complex, even with detailed instructions.  Programmers will make mistakes, and there is no technology to automatically check the correctness of the template implementation.  More importantly, patterns can be difficult to combine.  Their properties are usually incompatible, so non-trivial programs that require the use of more than one pattern are unlikely to be understood. <br><br>  A more general case of using patterns in parallel computing is searching the database, especially using the transaction mechanism.  Transactions support asynchronous calculations on copies of data, followed by <em>commit</em> or abort (accepting or canceling a transaction).  The acceptance of a transaction is carried out in the event that no conflict has occurred during its implementation.  Transactions are distributed (usually for databases) or performed in software shared memory machines [45], or, most interestingly, performed in hardware shared memory machines [38].  In the latter case, the technique fits well with the cache alignment protocols, which are therefore necessary for these machines.  Transactions eliminate unplanned locks, but even despite their recent improvements (see [26]), still remain a very uncertain interaction mechanism.  They are well suited for situations that are in themselves uncertain, in which, for example, several participants compete for resources.  But they are not suitable for building deterministic parallel interactions. <br><br>  A particularly interesting use of templates was in MapReduce [19].  This template was used for large-scale distributed processing of large amounts of data by Google.  While most of the templates are granular general data structures and synchronization of access to them - MapReduce is a framework for constructing large distributed programs.  This template was developed based on high-level functions of Lisp and other functional languages.  Template parameters are part of the functionality of the system in the form of code, rather than "pieces" of data. <br><br>  Templates can be encapsulated by library experts in the same way as was done with MapReduce, parallel data structures in Java 5.0 and STAPL in C ++ [1].  This is a major improvement in the reliability of the implementation, but it requires the programmer to discipline to follow the rules for performing parallel interactions using these libraries.  Collapsing the capabilities of these libraries into languages ‚Äã‚Äãin which the syntax and semantics implement these restrictions can lead, ultimately, to a much easier process of developing parallel programs. <br><br>  High-level templates (such as MapReduce) provide interesting challenges and opportunities for developers of programming languages.  These templates perform more the role of <em>coordination languages</em> , rather than traditional programming languages.  New coordination languages ‚Äã‚Äãthat are compatible with existing languages ‚Äã‚Äã(Java, C ++) are more likely to replace traditional languages. <br><br>  A compromise could be the expansion of existing programming languages ‚Äã‚Äãwith keywords to support concurrency.  This will allow the use of most of the legacy functionality where parallel programming is not required, but will require changes in functionality to support parallelism.  This strategy is followed in Split-C [16] and Cilk [13] (C-like languages ‚Äã‚Äãwith multithreading support).  In Cilk, a programmer can use the keywords <em>cilk, spawn, sync</em> in his C program.  The goal of Cilk is to support dynamic multithreading in the context of shared memory, in which costs arise only when parallelism is actually used (that is, when using a single processor, there are practically no costs). <br><br>  A similar approach is to combine language extensions and the limitations of the expressiveness of existing languages ‚Äã‚Äãin order to achieve more consistent and predictable behavior.  For example, the Guava language [5] is a restriction of the Java language, in which unsynchronized objects are inaccessible from different streams.  Also, there is an explicit distinction between locks that guarantee data integrity (read locks) and locks that allow secure data modification (write locks).  These changes in language reduce a significant part of the uncertainty, without causing degradation of efficiency, but nevertheless the risk of deadlocks remains. <br><br>  Another approach, in which the emphasis is on avoiding mutual locks, is called <em>promises</em> , because  implemented by Mark Miller in the E programming language (see <a href="http://www.erights.org/">www.erights.org</a> ).  In it, instead of blocking access to shared data, the program interacts with the data broker (in such a way as if they directly accessed the data). <br><br>  Another approach leaves programming languages ‚Äã‚Äãand concurrency mechanisms unchanged, and instead introduces a formal analysis of programs to identify where potential errors occur in multi-threaded programs.  This is done in Blast [28] and Intel thread checker.  Such an approach can greatly assist in analyzing the behavior of programs that are difficult to understand.  Less formal debugging techniques, such as Valgrind, can also help.  In spite of this, formal and non-formal techniques still require considerable experience in application and suffer from scalability limitations. <br><br>  All the above techniques reduce some of the uncertainty of the flow programming model.  Nevertheless, even as a result of their use, very non-deterministic programs are obtained.  For applications that are characterized by uncertainty (servers, parallel access to the database, competition for resources), they are suitable.  But achieving certain goals through uncertainty is still difficult.  Performing deterministic parallel computing requires consideration of the problem from different angles.  Instead of working with such a highly non-deterministic mechanism as threads and placing the work on uncertainty reduction on the programmer, we should start working with deterministic mechanisms and introduce uncertainty only where necessary.  We will look at this approach in the following sections. <br><br><h1>  6 Alternatives to a streaming computation model </h1><br>  Consider again the Observer pattern, [22] shown in Listings 1 and 2. This is a trivial design pattern.  The implementation should be simple.  But, as shown above, it‚Äôs not easy to implement this pattern using threads. <br><br>  Consider Figure 1, which implements this rendezvous-based template (the concept of parallel programming) in Ptolemy II [20].  The signed rectangle in the upper left corner is the diagram designation, which is the Communicating Sequential Processes (CSP) - a formal language for describing patterns of interaction between parallel systems) -like [29] parallel program in which each component is a process and the interaction is carried out through a rendezvous.  Processes themselves are implemented in ordinary Java, so such an environment can be viewed as a coordination language (which, by chance, is a visual programming language).  The implementation of the rendezvous area on Ptolemy II was made on the basis of [2] and includes the ‚ÄúMerge‚Äù block, which implements the conditional rendezvous.  In the diagram, the Merge block determines that either of the two Value Producers (supplier / producer of values) can participate in the rendezvous with the Value Consumer and Observer.  That is, two possible tripartite rendezvous may occur.  These interactions can occur continuously in a random order. <br><img src="https://habrastorage.org/storage3/6e4/157/05c/6e415705ca2a4f974289bca2707d653b.png"><br>  Figure 1. Observer pattern implementation in a rendezvous-based coordination language of visual programming. <br><br>  To begin with, it should be noted that when you begin to understand the meanings of the icons, the diagram clearly expresses the Observer pattern.  In addition, everything in the program is deterministic, except for clearly non-deterministic interactions specified by the Merge block.  If this block were absent, we would have a program in which deterministic interactions between deterministic processes took place.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deadlock cannot occur (unless, of course, the lack of cycles in the diagram ensures that the dealock will not occur). Also, the three-participant rendezvous way of ensuring that the Value Consumer and Observer receive the values ‚Äã‚Äãin the correct order. The Observer pattern becomes simple (as it should be). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The trivial programming problem has become simple, and we can begin to look at interesting developments. Figure 2 shows the Observer pattern implemented using PN Director, which implements a parallelism model called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kahn's processing network (PN)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[31]. In this model, each icon is a process, but the place of interactions in the form of a rendezvous, the processes interact by sending messages with an infinite queue and locks for reading. In the original PN model [31], read locks ensured that each network would perform deterministic calculations. In our case, the model is supplemented by some primitive, which can be called a nondeterministic Merge, which explicitly unifies the threads. Note that the augmented model with apparent uncertainty is usually used for embedded software [18]. </font></font><br><img src="https://habrastorage.org/storage3/913/951/b38/913951b38dfbf82e01c99622751bdceb.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 2. Implementing the Observer pattern using the network parallelism model.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The model in Figure 2 has all the advantages characteristic of the model in Figure 1, and also has an additional property ‚Äî the Value Consumer may not explicitly support the Observer pattern. Notifications can be queued for further processing. In streaming implementation, you need to really try to implement this form of interaction.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A third implementation method can be introduced based on the nature of the uncertainty expressed by a non-deterministic union (merge). The principles of synchronous languages ‚Äã‚Äã[8] could guarantee correctness. In Ptolemy II, a similar model could be implemented using SR Director (synchronous / reactive), which is a synchronous model similar to Esterel [12], SIGNAL [10] and Luster [25]. The latter is successfully used for programming and designing parallel, with high security requirements, software for aircraft control applications [11]. Using a streaming programming model for this purpose would be stupid.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fourth implementation specializes in synchronizing non-deterministic events. In Ptolemy II, a similar model is called the DE director (discrete events, discrete events). It provides a specification for synchronization with strict semantics [33], related to the similar hardware description languages ‚Äã‚Äãsuch as VHDL, Verilog, and network modeling environments like Opnet Modeler. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In all four cases (rendezvous, PN, SR, DE) we started with complete determinism in the interactions. Non-determinism was neatly introduced exactly where necessary. This design style is very different from the flow style, which starts with a highly non-deterministic interaction mechanism and tries to reduce undesired non-determinism.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The implementations shown in Figures 1 and 2 use Java threads. However, the software model includes not only the thread model. Comparing with all the techniques described in the previous section, it is closest to MapReduce, which is a kind of data streaming for performing calculations. But, unlike MapReduce, it supports a strong coordination language, expressive enough to describe a wide range of interactions. In fact, two different coordination languages ‚Äã‚Äãare given here: with rendezvous semantics and with PN semantics.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This kind of parallelism is certainly not new. Component architectures in which data flows between components can be called "actor-oriented" [35]. They take many forms. Unix pipes (pipes) resemble PN, although they are more limited, since do not support cyclic graphs. Messaging packets (MPI, OpenMP) include opportunities for rendering rendezvous and PN, but in a less structured context, which places more emphasis on expressiveness than on deterministic interactions. The naive user of such packages may be discouraged by the unexpected result of the display of uncertainty.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Languages ‚Äã‚Äãsuch as Erlang [4] in their concurrency model make messaging an integral part of a general-purpose programming language. </font><font style="vertical-align: inherit;">Languages ‚Äã‚Äãlike Ada make rendezvous their integral part. </font><font style="vertical-align: inherit;">Functional languages ‚Äã‚Äã[30] and single assignment languages ‚Äã‚Äãalso emphasize deterministic computations, but they are ‚Äúless parallel‚Äù, so control and use of parallelism can be more complex. </font><font style="vertical-align: inherit;">Data parallelism also emphasizes deterministic interactions, but they require low-level software rewriting. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All of these approaches are part of the solution. </font><font style="vertical-align: inherit;">But it does not seem that any of them can become mainstream. </font><font style="vertical-align: inherit;">In the next section, I will argue.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7 Challenges and opportunities </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that alternatives to the flow model have existed for a long time, but flows still dominate among all the other approaches. There are many reasons for this. Probably one of the main ones is that the kernel of abstractions of computations is stuck in a consistent paradigm. Most widely used programming languages ‚Äã‚Äãfollow this paradigm.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntactically, threads are just a small extension of these languages ‚Äã‚Äã(as in Java) or just an external library. Semantically, they completely destroy the essential part of the determinism of language. It is regrettable that programmers are often guided by syntax rather than semantics. Generally accepted alternatives to threads, such as MPI and OpenMP, have the same key feature. They do not change the syntax of the language. Alternatives that completely replace these languages ‚Äã‚Äãwith their own syntax (for example, Erlang, Ada) do not have universal acceptance now and probably will not receive it at all. Even languages ‚Äã‚Äãwith minimal syntax modifications, such as Split-C or Cilk, remain esoteric.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The conclusion is that we should not replace conventional languages. We should build them instead. However, building on libraries alone is not enough. Libraries do not allow a variety of structures, enforcing patterns and complex composite properties.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I believe that the correct answer lies in the development of coordination languages. They introduce a new syntax, this syntax saves goals, but these goals are orthogonal to those that pursue traditional languages. While parallel general purpose languages ‚Äã‚Äã(Erlang, Ada) should include syntax for common operations (for example, arithmetic expressions), the coordination language may not include anything other than what is needed for coordination. The syntax can be very different. The ‚Äúprograms‚Äù shown in Figures 1 and 2 use visual syntax to implement actor-oriented coordination (in which data flows are more likely to pass between components than management). Although here the visual syntax is used only for pedagogical purposes, it is possible that ultimately visual syntax will be scalable and efficientas a specific part of UML for object-oriented programming. But even if not, it is easy to assume a textual syntax with a similar structure.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although coordination languages ‚Äã‚Äãwere invented long ago [40], but they too many times failed to become widely used. One of the reasons is the loss of homogeneity (homogeneity) of the architecture. The prevailing trend in the research of programming languages: any standing programming language should be of a general purpose. It must be at least expressive enough to express its own compiler. And then, supporters of the language will be considered as traitors if they yield to the new language. The wars of tongues are religious wars. Some of these wars are polytheistic.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, UML, for example, is often used in conjunction with C ++ and Java. Programmers are starting to use more than one language in which additional features are provided by different languages. The programs in Figures 1 and 2 follow this trend. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concurrency models with stronger determinism than flows (such as Kahn's processing network, CSP) have also existed for a long time. Some of them led to the creation of such programming languages ‚Äã‚Äãas Occam [21] (based on CSP), and some led to the creation of specialized development environments, for example, YAPI [18]. The rest did not have a strong influence on the mainstream programming. I believe that this can change if the parallelism models are used to create coordination languages, rather than to replace existing languages.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are many difficulties along the way. Developing a good language for coordination is no easier than developing a good general-purpose language. For example, it is easy to fall into the trap of false elegance using a set of primitives. It is well known that seven primitives are enough for creating a general purpose language [48], but there is not a single serious language built solely on these primitives.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 3 shows two implementations of simple parallel computing. The upper program shows an adaptation of the example [3]: Sequential outputs from data source 1 and 2 alternate with a specific sequence, reflected by a change of order in the Display block. However, this fairly simple functionality is achieved in a complex way. In fact, the understanding of the work of this model is comparable to the puzzle assembly. The program below is much easier to understand. The Commutator performs a rendezvous with each of the outputs in order from top to bottom and thus a similar alternation is achieved. A reasonable choice of language primitives allows a simple, direct and deterministic expression of deterministic goals. The upper model uses a non-deterministic mechanism, although it is more expressive to achieve deterministic goals. In this way,its use is irrational.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, coordination languages ‚Äã‚Äãrequire mechanisms for implementing scalability and modularity similar to those implemented in traditional languages. This can be done. For example, Ptolemy II is a modern type of system at the level of coordination languages ‚Äã‚Äã[49]. Moreover, it defines the preliminary forms of inheritance and polymorphism, which are adapted from object-oriented techniques [35]. Huge possibilities are hidden in the adaptation of high-level functions in coordination languages. This will allow the creation of similar MapReduce systems at the coordination level. Several many promising steps in this direction were made in [42].</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More importantly, in the long term, it is necessary to develop a theory of computation in order to obtain better justifications for parallel computations. Although significant progress has already been made in this direction, I believe that much more can be done. In Section 3, sequential calculations were modeled as the functional mapping of some bit sequences to others. The corresponding parallel model was introduced in [36], in which instead of the function </font></font><img src="https://habrastorage.org/storage3/e7d/1de/67a/e7d1de67a5376d3367685e2e1f16ebe5.jpg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parallel computations are defined by the function. </font></font><img src="https://habrastorage.org/storage3/421/c52/57a/421c5257a6b6ccabb25a837557f961d2.jpg"><br><img src="https://habrastorage.org/storage3/c19/271/f2a/c19271f2a43a7290d983f13f8d5283b3.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 3. Two ways to implement deterministic interlaces using a rendezvous.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the last formula, T is a partially or fully ordered set of tags, where the order can be time, a causal relationship, or more abstract dependency relationships. </font><font style="vertical-align: inherit;">Calculations performed on this model are mappings of an ‚Äúadvanced‚Äù bit combination into an ‚Äúadvanced‚Äù bit combination. </font><font style="vertical-align: inherit;">This basic formulation can be adapted to many models of parallel computing [9, 14, 37].</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8 Conclusion </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallelism in software applications is difficult. However, most of the difficulties are a consequence of the abstractions chosen and used. The dominant abstraction is threads. But most non-trivial multithreaded programs are difficult to understand. These software models can be improved through the use of design patterns, better atomicity of operations (transactions), language improvements, and formal methods. However, these techniques simply cut a huge surplus of non-determinism of the flow model. This model, as before, remains difficult to use.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we expect parallel programming to become mainstream and if we demand reliability and predictability from programs, then we must abandon threads as a programming model. More comprehensible and predictable models of parallelism should be developed. They should be based on the principle: deterministic goals should be achieved by deterministic means. Non-determinism must be carefully and explicitly entered where it is needed in the program. This principle, which seems obvious, is not used in the flow model. Flows must be transferred to the ‚Äúengine room‚Äù (engine room) in order to be used and distributed only by experienced suppliers of this technology.</font></font><br><br><h4>  Literature </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] P. An, A. Jula, S. Rus, S. Saunders, T. Smith, G. Tanase, N. Thomas, N. Amato, and L. Rauchwerger. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STAPL: An adaptive, generic parallel C ++ library. In Wkshp. on lang. and Comp. for Par. Comp. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(LCPC), pages 193‚Äì208, Cumberland Falls, Kentucky, 2001. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] F. Arbab. Reo: A channel-based coordination model for component composition. Mathematical Structures </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Computer Science, 14 (3): 329‚Äì366, 2004. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] F. Arbab. A behavioral model for software of components. L'Object, to appear, 2006. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4] J. Armstrong, R. Virding, C.Wikstrom, and M.Williams. Concurrent programming in Erlang. Prentice </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hall, second edition, 1996. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[5] DF Bacon, RE Strom, and A. Tarafdar. Guava: a dialect of java without data races. In ACM SIGPLAN</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">35. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ACM SIGPLAN Notices, pages 382‚Äì400, 2000. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[6] U. Banerjee, R. Eigenmann, A. Nicolau, and D. Padua. Automatic program parallelization. Proceedings </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of the IEEE, 81 (2): 211‚Äì243, 1993. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[7] LA Barroso. The price of performance. ACM Queue, 3 (7), 2005. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[8] A. Benveniste and G. Berry. The synchronous approach to reactive and real-time systems. Proceedings </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of the IEEE, 79 (9): 1270‚Äì1282, 1991. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[9] A. Benveniste, L. Carloni, P. Caspi, and A. Sangiovanni-Vincentelli. Heterogeneous reactive systems </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modeling and deployment. In EMSOFT. Springer, 2003.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[10] A. Benveniste and PL Guernic. Hybrid dynamical systems theory and the signal language. IEEE Tr. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on Automatic Control, 35 (5): 525‚Äì546, 1990. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[11] G. Berry. Synchronous languages ‚Äã‚Äãfor the development of safety-critical systems. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">White paper, Esterel Technologies, 2003. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[12] G. Berry and G. Gonthier. The esterel synchronous programming language: Design, semantics, implementation. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Science of Computer Programming, 19 (2): 87‚Äì152, 1992. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[13] RD Blumofe, CF Joerg, BC Kuszmaul, CE Leiserson, KH Randall, and Y. Zhou. Cilk: an </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">efficient multithreaded runtime system. In ACM SIGPLAN symposium on Principles and Practice of </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallel Programming (PPoPP), ACM SIGPLAN Notices, 1995.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[14] JR Burch, R. Passerone, and AL Sangiovanni-Vincentelli. Notes on agent algebras. Technical </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Report UCB / ERL M03 / 38, University of California, November 2003. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[15] M. Creeger. Multicore CPUs for the masses. ACM Queue, 3 (7), 2005. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[16] DE Culler, A. Dusseau, SC Goldstein, A. Krishnamurthy, S. Lumetta, T. v. Eicken, and K. Yelick. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallel programming in Split-C. In Supercomputing, Portland, OR, 1993. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[17] BA Davey and HA Priestly. Introduction to Lattices and Order. Cambridge University Press, 1990. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[18] EA de Kock, G. Essink, WJM Smits, P. van der Wolf, J.-Y. Brunel, W. Kruijtzer, P. Lieverse, and </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KA Vissers. Yapi: Application modeling for signal processing systems. In 37th Design Automation</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conference (DAC'00), pages 402‚Äì405, Los Angeles, CA, 2000. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[19] J. Dean and S. Ghemawat. MapReduce: Simplified data processing on large clusters. In Sixth Symposium </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on Operating System Design and Implementation (OSDI), San Francisco, CA, 2004. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[20] J. Eker, JW Janneck, EA Lee, J. Liu, X. Liu, J. Ludvig, S. Neuendorffer, S Sachs, and Y. Xiong. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taming heterogeneity ‚Äî the Ptolemy approach. Proceedings of the IEEE, 91 (2), 2003. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[21] J. Galletly. Occam-2. University College London Press, 2nd edition, 1996. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[22] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns: Elements of Reusable Object- </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oriented Software. Addison Wesley, 1994.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[23] A. Geist, A. Beguelin, J. Dongarra, W. Jiang, B. Manchek, and V. Sunderam. PVM: Parallel Virtual </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machine Guide for Network Parallel Computing. MIT Press, Cambridge, MA, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1994. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[24] A. Gontmakher and A. Schuster. Java consistency: nonoperational characterizations for Java memory </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">behavior. ACM Trans. Comput. Syst., 18 (4): 333‚Äì386, 2000. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[25] N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud. The synchronous data flow programming language </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">luster. Proceedings of the IEEE, 79 (9): 1305‚Äì1319, 1991. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[26] T. Harris, S. Marlow, SP Jones, and M. Herlihy. Composable memory transactions. In ACM Conference </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on Principles and Practice of Parallel Programming (PPoPP), Chicago, IL, 2005.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[27] J. Henry G. Baker and C. Hewitt. The incremental garbage collection of processes. In Proceedings </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of the Symposium on AI and Programming Languages, volume 12 of ACM SIGPLAN Notices, pages </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">55‚Äì59, 1977. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[28] TA Henzinger, R. Jhala, R. Majumdar, and S. Qadeer. Thread-modular abstraction refinement. In </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15th International Conference on Computer Aided Verification (CAV), volume 2725 of Lecture Notes </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Computer Science, pages 262-274. Springer-Verlag, 2003. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[29] CAR Hoare. Communicating sequential processes. Communications of the ACM, 21 (8), 1978. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[30] P. Hudak. Conception, evolution, and application of functional programming languages. ACM Computing </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surveys, 21 (3), 1989.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[31] G. Kahn and DB MacQueen. Coroutines and networks of parallel processes. In B. Gilchrist, editor, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Information Processing. North-Holland Publishing Co., 1977. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[32] D. Lea. Concurrent Programming in Java: Design Principles and Patterns. Addison-Wesley, Reading </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MA, 1997. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[33] EA Lee. Modeling concurrent real-time processes using discrete events. Annals of Software Engineering, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7: 25‚Äì45, 1999. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[34] EA Lee. What's ahead for embedded software? IEEE Computer Magazine, pages 18‚Äì26, 2000. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[35] EA Lee and S. Neuendorffer. Classes and subclasses in actor-oriented design. Conference on with In </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formal Methods and Models for CodeSign (MemoCode), San by Diego, CA, USA, 2004.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[36] EA Lee and A. Sangiovanni-Vincentelli. Framework for comparing models of computation. IEEE </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transactions on CAD, 17 (12), 1998. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[37] X. Liu. Semantic foundation of the tagged signal model. Phd thesis, EECS Department, University of </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">California, December 20 2005. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[38] H. Maurice and JEB Moss. Transactional memory: architectural support for lock-free data structures. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Proceedings of the 20th annual international symposium on Computer architecture, pages 289‚Äì300, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">San Diego, California, United States, 1993. ACM Press. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[39] Message Passing Interface Forum. MPI2: A message passing interface standard. International Journal </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of High Performance Computing Applications, 12 (1-2): 1-299, 1998.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[40] G. Papadopoulos and F. Arbab. Coordination models and languages. In M. Zelkowitz, editor, Advances </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Computers - The Engineering of Large Systems, volume 46, pages 329‚Äì400. Academic Press, 1998. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[41] W. Pugh. Fixing the Java memory model. ACM 1999 conference on Java Grande, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pages 89‚Äì98, San Francisco, California, United States, 1999. ACM Press. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[42] HJ Reekie. Toward effective programming for parallel digital signal processing. Ph.D. Thesis Research </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Report 92.1, University of Technology, Sydney, 1992. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[43] HJ Reekie, S. Neuendorffer, C. Hylands, and EA Lee. Software practice in the Ptolemy project. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Technical Report Series GSRC-TR-1999-01, Gigascale Semiconductor Research Center, University of</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">California, Berkeley, April 1999. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[44] DC Schmidt, M. Stal, H. Rohnert, and F. Buschmann. Pattern-Oriented Software Architecture - Patterns for Concurrent and Networked Objects. Wiley, 2000. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[45] N. Shavit and D. Touitou. Software transactional memory. In ACM symposium on Principles of Distributed </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computing, pages 204‚Äì213, Ottowa, Ontario, Canada, 1995. ACM Press. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[46] LA Stein. Challenging the computational metaphor: Implications for how we think. Cybernetics and </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systems, 30 (6), 1999. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[47] H. Sutter and J. Larus. Software and the concurrency revolution. ACM Queue, 3 (7), 2005. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[48] ‚Äã‚ÄãAM Turing. Computability and _-definability. Journal of Symbolic Logic, 2: 153‚Äì163, 1937.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[49] Y. Xiong. </font><font style="vertical-align: inherit;">An extensible type system for component-based design. </font><font style="vertical-align: inherit;">Ph.D. </font><font style="vertical-align: inherit;">Thesis Technical Memorandum </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UCB / ERL M02 / 13, University of California, Berkeley, CA 94720, May 1 2002.</font></font></div><p>Source: <a href="https://habr.com/ru/post/195262/">https://habr.com/ru/post/195262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../195248/index.html">Accelerators and business incubators in Russia: what to choose?</a></li>
<li><a href="../195250/index.html">Nokia's management asked Stephen Elop to reduce the size of his bonus, but he refused, citing his divorce</a></li>
<li><a href="../195254/index.html">Interface Designer: who exactly companies need</a></li>
<li><a href="../195256/index.html">YouTube starts supporting comments via Google+</a></li>
<li><a href="../195258/index.html">Humble Mobile Bundle 2</a></li>
<li><a href="../195264/index.html">A complete solution for video services, now for free!</a></li>
<li><a href="../195268/index.html">The history of drives in advertising. Part 1: 1956-1991</a></li>
<li><a href="../195270/index.html">iOS 7 makes iPhone waterproof</a></li>
<li><a href="../195274/index.html">Co-op streams from scratch in 33 rows on Haskell</a></li>
<li><a href="../195276/index.html">Digital good (direct electronic payments in the hands of musicians, artists and other creators)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>