<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>There is nothing wrong with types in C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After reading the article ‚Äú Strengthening type control: where in the typical C # project there is an unsolicited element of weak typing? I was rather ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>There is nothing wrong with types in C #</h1><div class="post__text post__text-html js-mediator-article"> After reading the article ‚Äú <a href="http://habrahabr.ru/post/200100/">Strengthening type control: where in the typical C # project there is an unsolicited element of weak typing?</a>  I was rather surprised by the fact that this approach was erroneous and that no one paid attention to it. <br><br>  The author of the post cites the idea that a method that returns a reference type, an object of which is created from a certain repository, must, one way or another, ensure that the returned object will not be null.  At the same time, in one of the examples he uses contracts, which contradicts their principles.  I want to make out the fallacy of this approach. <br><a name="habracut"></a><br>  We have a method <code>GetItem</code> , which gets an object from a certain repository and must, according to the author's intention, ensure that the object will not be null. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Item </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> itemId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataAccessor.getItemById(itemId); }</code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If the required object was not found in the repository, <code>dataAccessor</code> will return null, which will be given to the client, and without checking the value for null, it will receive a NullReferenceException.  So how can you guarantee that this will not happen? <br><br>  You can squeeze a null check inside the method and if the object is not found, throw Exception.  But with this we simply rename a NullReferenceException to, for example, ItemNotFoundException.  Moreover, the client is now obliged to add a try-catch block each time this method is accessed.  Customer writer will be very happy. <br><br>  Another option is to add a post-condition to the method.  Like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Item </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> itemId</span></span></span><span class="hljs-function">)</span></span> { Contract.Ensures(Contract.Result&lt;Item&gt;() != <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataAccessor.GetItemById(itemId); }</code> </pre><br><br>  It all becomes very bad and the kittens in the world becomes smaller.  After reading the contract, any person should understand that this method will always return an object, with any identifier provided.  But this is impossible.  The method cannot guarantee that the object with this Id is in the repository.  So you need to add a pre-condition that will help the poor thing and push all the problems to the client: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Item </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> itemId</span></span></span><span class="hljs-function">)</span></span> { Contract.Requires(dataAccessor.GetItemById(itemId) != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Contract.Ensures(Contract.Result&lt;Item&gt;() != <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataAccessor.GetItemById(itemId); }</code> </pre><br><br>  Fun, isn't it?  To get an object from the repository, you must first pull the object out of the repository, for which you need to pull the object out of the repository, for which ... <br><br>  The truth is that <s>there is</s> no <s>spoon, no</s> one can guarantee the existence of an object in the repository.  The only way to ensure the existence of any object is to create it and pinch its link.  Everything else is a bad design.  Data access layer should get the object from the repository and transfer to the client.  He does not know how to handle the absence of an object and is not at all aware of whether this is bad.  The logic level is responsible for this. <br><br>  The inability to guarantee the existence of an object out of sight, leads to the second idea given in the article by reference above.  Use a nullable container for reference types.  I rephrase: nullable reference.  Oil oily.  It was strange to learn about the popularity of this pattern. <br><br>  The reference type can refer to null.  Why insert one reference type into another and add the HasValue property to the container is absolutely not clear to me.  To check on HasValue?  What prevents access to the contents of the object without this check?  You can just as carelessly do not check for null through inequality.  Moreover, this pattern is not only useless, but also harmful.  Take a look at the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Maybe&lt;Item&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mbItem = GetMbItem(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mbItem.HasValue) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item = mbItem.Value; ModifyItem(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> item); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mbItem; }</code> </pre><br><br>  If the ModifyItem method has changed the object, the SomeMethod method will return the container with the old object.  Go then, look for this bug. <br><br>  In general, I consider the practice shown in that article harmful.  To check the reference to null, in C # there are standard tools, but in order to avoid NullReferenceException, you need to be careful.  Complicate the system for this is not necessary.  Working with repositories you need to monitor the integrity of the data and not run away from it.  If there is no object in the repository that must be there, it is much, much worse. </div><p>Source: <a href="https://habr.com/ru/post/200884/">https://habr.com/ru/post/200884/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../200872/index.html">Integration of LMS Moodle and Microsoft Active Directory. Part 1</a></li>
<li><a href="../200874/index.html">Immersive Mode (dive mode) in Android 4.4 KitKat</a></li>
<li><a href="../200878/index.html">Hash strings at compile time with annotation</a></li>
<li><a href="../200880/index.html">Multiplayer Games: Inside Look</a></li>
<li><a href="../200882/index.html">Six rules for effective management of promotion and "lead generation" using social media</a></li>
<li><a href="../200886/index.html">Install and configure XBMC on Raspberry Pi</a></li>
<li><a href="../200888/index.html">About informational freedom</a></li>
<li><a href="../200890/index.html">Introduction to OpenSceneGraph</a></li>
<li><a href="../200892/index.html">ERP for the university: problems of choice and implementation</a></li>
<li><a href="../200894/index.html">Information security and certification. If there is no difference - why pay more?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>