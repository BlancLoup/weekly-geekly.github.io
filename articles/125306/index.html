<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Closures and JavaScript objects. Reinvent the interpreter</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Usually, concepts or programming paradigms are explained either descriptively - ‚Äúchewing‚Äù new ideas with simple words, or metaphorically - likening th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Closures and JavaScript objects. Reinvent the interpreter</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage1/1c475b4f/d44a68c9/69554021/04a57dbc.jpg" align="left">  Usually, concepts or programming paradigms are explained either descriptively - ‚Äúchewing‚Äù new ideas with simple words, or metaphorically - likening them to familiar objects and concepts.  But neither the first nor the second method gives such an accurate and complete picture of the subject as a look from the point of view of low-level implementation. <br><br>  When in learning a language you reach non-trivial things, it can be useful to shift the level of abstraction in order to understand how everything is actually arranged.  After all, by and large, any constructions of languages ‚Äã‚Äãof arbitrarily high level are reduced to the good old machine code.  Writing in object-oriented or functional style is possible on pure C, and even in assembly language.  Roughly speaking, any high-level language is a set of syntactic candies and chocolates fixed at the level of the compiler or interpreter.  Increasing the level of abstraction allows you to write more complex programs with less effort, but to understand at the beginning of the path, what exactly is meant by inheritance or closure, how it all works and why it is much easier to figure out how all this is implemented. <br><br>  JavaScript, like no other language, needs just such an explanation.  The functional nature hidden behind the C-like syntax and the unusual prototype model of inheritance are at first very confusing.  Let's mentally lower the JavaScript level to a simple procedural, like C.  Starting from this ‚Äúnon-language‚Äù, we will reinvent functional and object-oriented programming. <br><a name="habracut"></a><br><h4>  Top-notch features </h4><br>  When the interpreter parses the text of the program, it creates in memory structures that contain the code and data for it that is directly understandable to the processor itself.  At run time, the basic data structures of the interpreter are <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D0%25B5%25D0%25BA_%25D0%25B2%25D1%258B%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25BE%25D0%25B2">the call stack</a> and the <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D0%25BD%25D0%25B5%25D1%2580%25D0%25B0%25D1%2581%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D1%2591%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C)">heap</a> .  The heap stores the program data, and the so-called <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D0%25B5%25D0%25BA%25D0%25BE%25D0%25B2%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25B0%25D0%25B4%25D1%2580">stack frames</a> (they are also activation frames, activation records, activation objects) are stored in the stack.  As a rule, a stack frame contains the return address, references to function arguments, and memory blocks allocated for local variables.  When the function finishes, the stack is reduced by one frame, and all the blocks in the heap referenced by the stack frame fields are made available to the garbage collector.  But not everything is so simple. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Consider the following code: <br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  1 var x = 10; var foo = function() { var y = 20; var bar = function() { var z = 30; return x+y+z; } return bar; } var baz = foo(); console.log(baz()); // 60</span></span></code> </pre> <br><br>  The variables <code>x</code> , <code>foo</code> and <code>baz</code> are global, and therefore are available everywhere, regardless of the stack depth.  At the moment of calling <code>foo</code> , a frame with local variables <code>y</code> and <code>bar</code> appears at the top of the stack, then, when exiting <code>foo</code> , this frame is lost, and at the time of calling <code>baz</code> , only <code>z</code> activated in the activation frame.  Where does the interpreter get <code>y</code> ?  In the C language (and all its descendants), this problem is solved very severely - the declaration of nested functions is prohibited.  In Pascal, on the contrary, there are nested functions, but there is no possibility to return a function at the output.  When people say that functions in imperative languages ‚Äã‚Äãare not first-class objects, <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B5%25D0%25BC%25D0%25B0_%25D1%2584%25D1%2583%25D0%25BD%25D0%25B0%25D1%2580%25D0%25B3%25D0%25B0">this is what</a> they mean.  Functional languages, on the other hand, allow you to do whatever you want with functions (the example above is real in JavaScript).  How do they do it? <br><br>  When returning the nested function <code>bar</code> from the external function <code>foo</code> , the stack frame created when <code>foo</code> called is stored in the <code>baz</code> variable as part of the execution context of the function <code>bar</code> .  Thus, a chain of scopes is formed that is completely independent of the call stack.  The specific implementation of the mechanism for forming this chain may, of course, be very different from this simplified description, but the main thing is that the variable <code>y</code> exists while the <code>baz</code> exists, despite the fact that when exiting <code>foo</code> reference to it disappears from the stack. <br><br>  The totality of all currently existing visibility chains (for each function defined in the current execution context, one chain) forms something like a three-dimensional tree.  If we return several nested functions, the branches of the tree diverge to the sides, sharing the variables of the external function, and if we call the external function several times, the branch goes up, creating independent copies of the free variables: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  2 var x = 'I am global!'; var foo = function (y) { var z = 'unchanged'; var getXYZ = function () { return 'x: '+x+' y: '+y+' z: '+z; } var setZ = function(newZ) { z = newZ; } return [getXYZ, setZ]; //   ,      , ? } var a = foo('Alice'); // *1* var b = foo('Bob'); // *2* console.log(a[0]()); // x: I am global! y: Alice z: unchanged a[1]('changed'); // *3* console.log(a[0]()); // x: I am global! y: Alice z: changed *4* console.log(b[0]()); // x: I am global! y: Bob z: unchanged x = 'Everybody can see me!'; // *5* console.log(a[0]()); // x: Everybody can see me! y: Alice z: changed console.log(b[0]()); // x: Everybody can see me! y: Bob z: unchanged</span></span></code> </pre> <br><img src="https://habrastorage.org/storage1/8c1b246c/5fd57ac8/4b484d23/c2c0ba5c.png"><br>  At the point * 1 *, the "tree of visibility" forks at the node <code>foo</code> , since we returned two nested functions.  They can communicate with each other through the variables <code>y</code> and <code>z</code> , which can be seen at the point * 3 *.  At the point * 2 * we enter the function <code>foo</code> a second time, and the tree grows up - copies of all local variables <code>foo</code> .  The ‚Äúgray‚Äù <code>getXYZ</code> and <code>setZ</code> are also reported via <code>y</code> and <code>z</code> in the ‚Äúgray‚Äù node <code>foo</code> , but they know nothing about <code>y</code> and <code>z</code> from the ‚Äúblack‚Äù node <code>foo</code> , which is clearly seen at * 4 *.  At the same time, the variable <code>x</code> level above is visible to all the leaves of the tree of visibility (* 5 *). <br><br>  Thus, at the time of writing the program, we define the structure of future trees of appearance, at the time of actually creating the branches of the tree, we can affect some variables inside it and leave them fixed (after calling <code>foo('Alice')</code> or <code>foo('Bob')</code> there is no way change the value of the variable <code>y</code> outside) and, as long as the tree branches exist, we can control its state only insofar as the leaves allow it. <br><br>  The need for these additional interpreter data structures is one of the main differences between the internal structure of functional languages ‚Äã‚Äãand imperative ones.  Since such structures are created implicitly, without the direct participation of the programmer, only the interpreter itself can free the memory from them.  Therefore, functional languages ‚Äã‚Äãcannot exist without garbage collectors, and imperative languages ‚Äã‚Äãcan.  By the way, the first garbage collector was written in 1959 for the Lisp language.  Oh yeah, I almost forgot - the reference to a function with its chain of scopes is called a <a href="http://en.wikipedia.org/wiki/Closure_(computer_science)">closure</a> . <br><br><h4>  Encapsulation and inheritance </h4><br>  So, slightly modifying the interpreter, we turned the primitive procedural language into a full-fledged functional language and understood how the closures are arranged.  Now it would be nice to teach him how to work with objects.  Although the PLO itself is more familiar to most than closures, there are many more problems with it.  The fact is that if in other languages ‚Äã‚Äãthere is a rigidly fixed set of constructions that uniquely defines the style and shades of the implementation of the object paradigm in this particular language, then in JavaScript you can fence anything and everything.  And the city ... Any self-respecting author of a book on JavaScript considers it his duty to provide at least four different ways to organize hierarchies of objects in order to demonstrate to the reader ‚Äúthe power and expressiveness of language‚Äù.  This is certainly cool, but familiar to Java, Ruby or C #, the brain is boiling from such anarchy.  While I was not confronted with JavaScript, I did not feel any need to figure out exactly how all these object things work ‚Äî they just worked, as written in the book.  With JavaScript, this number does not work. <br><br>  Let's ‚Äúforget‚Äù that there are already objects in JavaScript, and we will call them structures, as in C, and properties of objects as members of structures.  Also, for the time being, we will abandon the point notation and everywhere will refer to the members of the structure through square brackets.  Since we already have first-class functions that can be handled as freely as any variables, it is simpler to construct a structure containing both data and a function for processing them: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  3 var obj = { x: 10, y: 20, foo: function () {return x + y;} }; console.log(obj['foo']()); // !</span></span></code> </pre> <br><br>  In fact, everything is a little more complicated.  This example is not functional, since there is no <code>x</code> and <code>y</code> in the activation object (so called stack stack in JavaScript) of our <code>foo()</code> function.  There are no them and up the chain, there is only the variable <code>obj</code> .  To get to them, we will have to refer to them as <code>obj['x']</code> and <code>obj['y']</code> : <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  4 var obj = { x: 10, y: 20, foo: function () {return obj['x'] + obj['y'];} } console.log(obj['foo']()); // 30</span></span></code> </pre> <br><br>  Earned!  We put the data and the function that processes it into one structure.  But very often we need several objects with the same device, the same functions, but different values ‚Äã‚Äãof variables.  Create a function that generates such structures: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  5 function createObj(x, y) { var obj = {}; obj['x'] = x, obj['y'] = y, obj['foo'] = function () {return obj['x'] + obj['y'];} return obj; } var obj1 = createObj(1, 2); var obj2 = createObj(3, 4); console.log(obj1['foo']()); // 3 console.log(obj2['foo']()); // 7</span></span></code> </pre> <br><br>  Since the <code>createObj()</code> function returns a nested function as part of the <code>obj</code> object, each time it is called, a closure is created that contains copies of <code>x</code> , <code>y</code> and <code>foo</code> that are independent of each other (the tree of scopes grows up). What we have done is already very similar on the full object.  To note this matter, in the subsequent listings we will move to a more concise dot notation.  But OOP is not OOP without inheritance.  How to organize it?  We could write a function that would copy all the properties of the parent object into a descendant object.  Such inheritance is called cascading, but, strictly speaking, it is cloning rather than inheritance.  Changes in the implementation of the parent will not affect the descendant; in addition, if each descendant contains copies of the parent's methods, this will lead to unnecessary memory consumption.  Perhaps, it is better to simply store a reference to the parent in one of the properties of the child.  We also need a function to search for properties up the inheritance chain: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  6 function createObj(x, y) { var obj = {}; obj.x = x, obj.y = y, obj.foo = function () {return obj.x + obj.y;} return obj; } function createChild (parent) { var child = {}; child.__parent__ = parent; return child; } function lookupProperty (obj, prop) { if (prop in obj) return obj[prop]; else if (obj.__parent__) return lookupProperty (obj.__parent__, prop); } var a = createObj(1, 2); var b = createChild (a); console.log(lookupProperty(b, 'y')); // 2 console.log(lookupProperty(b, 'foo')()); // 3</span></span></code> </pre> <br><br>  It seems to be an order, but if we change the object <code>b</code> , for example like this: <code>bx = 10</code> , then we will see that nothing really works.  The <code>foo()</code> method still refers to the properties of its object, not the descendant object.  If we want to reuse methods during inheritance, we need to teach them to work with the properties of other objects.  You can pass an argument to the method that points to the current object.  It is also necessary to use the <code>lookupProperty()</code> function inside the method, because we do not know in advance whether the <code>x</code> and <code>y</code> properties are defined in the current object, or whether they will have to be searched upwards through the inheritance chain.  The functions <code>createChild()</code> and <code>lookupProperty()</code> remain unchanged: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  7 function createObj(x, y) { var obj = {}; obj.x = x, obj.y = y, obj.foo = function (currentObj) { return lookupProperty(currentObj, 'x') + lookupProperty(currentObj, 'y'); } return obj; } function createChild (parent) { var child = {}; child.__parent__ = parent; return child; } function lookupProperty (obj, prop) { if (prop in obj) return obj[prop]; else if (obj.__parent__) return lookupProperty (obj.__parent__, prop); } var a = createObj(1, 2); var b = createChild (a); bx = 10; console.log(lookupProperty(b, 'y')); // 2 console.log(lookupProperty(b, 'foo')(b)); // 12</span></span></code> </pre> <br><br>  So, we have just implemented delegating inheritance, completely without using the built-in features of JavaScript.  Our example is quite liberal - you can inherit an object, or you can create it from scratch, a descendant object can at any time break the chain of inheritance and cling to another object. <br><br>  Let's make changes to our interpreter to support the PLO.  Since inheritance is good, and it almost always makes sense to inherit anything from something, <code>lookupProperty()</code> should be made completely transparent by <code>lookupProperty()</code> it inside the interpreter.  We will not see her again, but we will remember that she is. <br><br>  Then, combine the <code>createObj()</code> and <code>createChild()</code> functions ‚Äî they are quite similar.  Both create a temporary object on entry and return it on exit.  We include the combined function in the root <code>Object</code> .  It will take two arguments - the parent object and the object describing the differences between the descendant and the parent (this approach is also called differential or differential inheritance). <br><br>  Finally, in order to not pass the current object through the arguments with each method call, we will automatically provide a reference to the object to which the method belongs.  Let's call it <code>this</code> , in accordance with the tradition of the PLO: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  8 var a = Object.create(null, { x: {value: 1}, y: {value: 2}, foo: {value: function() { return this.x + this.y; } } }); var b = Object.create(a, {x: {value: 10}}); console.log(b.x+', '+b.y+', '+b.foo()); // 10, 2, 12</span></span></code> </pre> <br><br>  We brought inheritance in accordance with the EcmaScript 5 standard. Unfortunately, the new standard does <a href="http://kangax.github.com/es5-compat-table/">not work everywhere</a> and is not very fast.  In addition, millions of lines of code have already been written, in which inheritance is done in the old manner, via <code>new</code> .  This scheme involves the use of constructors and prototypes.  They say that Brendan Ike introduced it into the language, so as not to shock the programmers who are accustomed to classical inheritance with the simplicity and straightforwardness of the scheme described above.  Perhaps a good smuggler would have come from Ike - he managed to push a functional language into mainstream programming, where the imperative languages ‚Äã‚Äãhad previously run the ball, disguised it with C-like syntax, and prototype inheritance, confusing it and making it look like a classical one. <br><br>  For classical OOP, there is a rigid boundary between classes and instances.  In the prototype OOP there is none at all, since there are no classes and any object can serve as a prototype.  To soften this distinction, a special type of function was created - constructors.  The hierarchy of constructors exists in parallel with the hierarchy of objects, each constructor "hangs" above its object, as a class above an instance.  A constructor is not a prototype of an object, and a prototype of a constructor has nothing to do with the prototype of the objects created by these constructors. <br><br>  Let's return to listing 7. To inscribe constructors in the inheritance scheme, we recall that everything in JavaScript, including functions, is an object.  That is, we can add properties to functions as to ordinary objects.  Add a <code>prototype</code> property that will point to the prototype of the created object in the case of a function being called as a constructor.  Then, as in the transition to Listing 8, rename the temporary variables <code>obj</code> , <code>child</code> and <code>currentObj</code> to <code>this</code> , hide their declaration and return to the interpreter, remove the <code>lookupProperty()</code> to the same <code>lookupProperty()</code> .  Since each constructor creates one specific type of objects, using a generic method like <code>Object.create()</code> meaningless, so we will call constructors by the type of objects they create, but with a capital letter, so as not to be confused with ordinary functions.  To let the interpreter know that we want to call a function as a constructor, we add the keyword <code>new</code> in front of its name.  Here's what we get: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  9 function A(x, y) { this.x = x, this.y = y, this.foo = function () { return this.x + this.y; } }; function B () {}; B.prototype = new A(1, 2); var b = new B(); console.log(b.x+', '+b.y+', '+b.foo()); // 1, 2, 3</span></span></code> </pre> <br><br>  The pair constructor + prototype (in this example: <code>B()+B.prototype</code> ) plays the same role as the class in the classic OOP.  Notice that in Listing 8, the a object serves solely to inherit <code>b</code> from it, and in Listing 9, we have completely got rid of the variable <code>a</code> , which means that we do not need the <code>A()</code> constructor either.  The <code>x</code> and <code>y</code> properties, which are different for each object, can be defined in the constructor <code>B</code> , and the common for all method <code>foo()</code> - in the prototype: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  10 function B (x, y) { this.x = x, this.y = y }; B.prototype.foo = function () { return this.x + this.y; } var b = new B(1, 2); console.log(b.x+', '+b.y+', '+b.foo()); // 1, 2, 3</span></span></code> </pre> <br><br>  The same for <code>Object.create()</code> : <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  11 var B = { foo: function() { return this.x + this.y; } }; var b = Object.create(B, {x: {value: 10}, y: {value: 20}}); console.log(b.x+', '+b.y+', '+b.foo()); // 10, 20, 30</span></span></code> </pre> <br><br><h4>  Conclusion </h4><br>  1. The execution of a JavaScript program is provided by three main data structures of the interpreter - the call stack, the scope chain and the inheritance chain.  The stack is the oldest and most primitive structure.  It is strictly linear ( <a href="http://en.wikipedia.org/wiki/Spaghetti_stack">although options are possible ...</a> ), but it is quick and simple.  The last two structures are more like trees than chains, but since only one function is performed at a time, and it can only move up through these trees, from its point of view these are precisely chains. <br><br>  2. The structure of the tree of scopes is static and is set at the time of writing the program.  The root of the tree is a global object.  The growth of the visibility chain is the same as the stack growth, when you call the next function.  But when returning to the calling function, the stack is always reduced, and the chain of scopes can continue to grow, returning the reference to the nested function and even start branching if there are several such functions or if the external function is executed several times.  Such long-lived nodes form a circuit. <br><br>  3. The inheritance tree grows from the Object object (UPD: in fact it grows from null. Since this object, to put it mildly, is not very informative, it is usually not taken into account. Thanks to <a href="https://habrahabr.ru/users/azproduction/" class="user_link">azproduction</a> for the amendment).  The main purpose of the inheritance tree is to search for properties up the prototype chain, if the property is not present in the object itself, what the lookupProperty () function did in our examples.  In the EcmaScript standard, this is <a href="http://javascript.ru/ecma/part8">the [[get]] method</a> .  The reference to the parent object (__parent__ in Listings 6 and 7) is called __proto__ in many implementations and is available to the programmer.  But its use is considered bad form.  The language standard does not provide for the possibility of changing parents, as in our self-made implementation of inheritance.  Object.prototype and Object .__ proto__ are completely different things.  Object.prototype is used only when calling a function as a constructor and sets the prototype of the returned object. <br><br>  4. In JavaScript, there are no modifiers private, protected or public to hide the implementation of the object.  However, such concealment can be implemented using closures.  <a href="http://javascript.crockford.com/private.html">So</a> or even <a href="http://webreflection.blogspot.com/2008/04/natural-javascript-private-methods.html">so</a> .  However, this is a rather dubious practice - reading and testing such code is more difficult.  In most modern dynamic languages, private is just a convention, and private properties can be accessed from outside if desired.  In JavaScript, it is customary to denote private properties by the underscore: _private.  In addition, <a href="http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth">modules</a> are often used.  This is a very convenient and practically standard alternative to particular methods and properties. <br><br>  5. The keyword this indicates the current object, which is quite obvious in the case of constructors and methods of objects.  In the case of a function not called as an object method, this default defaults to a global object.  Although the creation, transmission, and return of the objects pointed to by this are hidden inside the interpreter, the call () and apply () methods have the ears of the currentObj variable shown in Listing 7: the first argument of these methods will be visible inside this function as this. <br><br><h4>  List of additional literature </h4><br><ol><li>  <a href="http://jibbering.com/faq/notes/closures/">Javascript closures</a> </li><li>  <a href="http://dmitrysoshnikov.com/ecmascript/ru-javascript-the-core/">Javascript</a>  <a href="http://dmitrysoshnikov.com/ecmascript/ru-javascript-the-core/">Core</a> </li><li>  <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-6-closures/">Subtleties ECMA-262-3.</a>  <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-6-closures/">Closures</a> </li><li>  <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-3-this/">The subtleties of using this</a> </li><li>  <a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-1-lexical-environments-common-theory/">ECMA-262-5 in detail.</a>  <a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-1-lexical-environments-common-theory/">Lexical environments: Common Theory</a> </li><li>  Learning Javascript with Object Graphs: <a href="http://howtonode.org/object-graphs">Part 1</a> , <a href="http://howtonode.org/object-graphs-2">Part</a> <a href="http://howtonode.org/object-graphs">2</a> , <a href="http://howtonode.org/object-graphs-2">Part</a> <a href="http://howtonode.org/object-graphs-3">3</a> </li><li>  <a href="http://www.cs.rit.edu/~ats/books/ooc.pdf">Object Oriented C (pdf)</a> </li><li>  <a href="http://habrahabr.ru/blogs/javascript/120193/">Basics and Misconceptions About JavaScript</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/125306/">https://habr.com/ru/post/125306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../125298/index.html">REMAPPIM KEYBOARD AND MOUSE</a></li>
<li><a href="../125300/index.html">Children's HTTP DOS</a></li>
<li><a href="../125301/index.html">Emacs has broken the GPL since 2009</a></li>
<li><a href="../125302/index.html">Portraits painted by CNC machine</a></li>
<li><a href="../125303/index.html">How to connect two asterisk servers (part two. IAX2)</a></li>
<li><a href="../125308/index.html">Function K.O'Nsole.log for debugging in different browsers</a></li>
<li><a href="../125309/index.html">Review of pleasant things on "Freelance"</a></li>
<li><a href="../125310/index.html">Startup Genome Report translated into Russian!</a></li>
<li><a href="../125311/index.html">Twitter text advertising</a></li>
<li><a href="../125315/index.html">Foxconn to supply 1 million robots</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>