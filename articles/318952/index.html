<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Let's Encrypt and nginx: configuration in Debian and Ubuntu</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If suddenly this whole story has passed you, Let's Encrypt is a certification authority from the non-profit organization ISRG, which exists with the s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Let's Encrypt and nginx: configuration in Debian and Ubuntu</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/2a7/3ca/80c/2a73ca80c919473da68bd5ed0d205d83.png" alt="image"></p><br><p>  If suddenly this whole story has passed you, <a href="https://letsencrypt.org/">Let's Encrypt</a> is a certification authority from the non-profit organization ISRG, which exists <a href="https://www.eff.org/ru/deeplinks/2014/11/certificate-authority-encrypt-entire-web">with the support of EFF</a> and many companies, which has taken on the mission to give people free SSL / TLS certificates for websites and servers.  Certificates from Let's Encrypt are already used <a href="https://letsencrypt.org/stats/">on more than 10 million domains</a> . </p><br><p>  In addition to the obvious free of charge, the certificates from Let's Encrypt have a special advantage that any other commercial certification center lacks: if you once received a certificate from Let's Encrypt, then, other things being equal, it is forever.  You do not need to manually renew certificates once a year or two.  There is no need to remember that there are certificates somewhere.  Got it, set it up and forget it! </p><br><p>  An attentive reader will immediately want to argue: how is it, because it is known that certificates are issued with a validity of three months?  The thing is in automatic renewal of certificates, which is possible in the complete absence of human actions. </p><br><p>  The organization of automatic renewal of certificates in the article is paid close attention so that you can fully appreciate this fundamental advantage of Let's Encrypt. </p><a name="habracut"></a><br><h2 id="pochemu-eta-statya">  Why this article </h2><br><p>  The EFF website has <a href="https://certbot.eff.org/">brief instructions on how to use Certbot</a> , the recommended program for obtaining certificates, but they are most likely designed for those who log into their server via SSH only for urgent reasons.  More <a href="https://certbot.eff.org/docs/using.html">detailed documentation is also available</a> , but as long as you read it all and find everything that you really need to know ... In addition, it does not cover some of the important strategic issues of using certificates. </p><br><p>  Obviously, we need a short and clear instruction for those who are accustomed to the server console, but want to understand everything without wasting time. </p><br><h2 id="soderzhanie">  Content </h2><br><p>  From this article you will learn ... </p><br><ol><li>  How to install and <a href="https://habr.com/ru/post/318952/">configure Certbot</a> for regular use. </li><li>  What is required from nginx and <a href="https://habr.com/ru/post/318952/">how to configure nginx to get certificates</a> . </li><li>  <a href="https://habr.com/ru/post/318952/">How to get certificates</a> and <a href="https://habr.com/ru/post/318952/">how to verify the received certificate</a> . </li><li>  <a href="https://habr.com/ru/post/318952/">How to install a certificate</a> from Let's Encrypt in nginx. </li><li>  How to automatically <a href="https://habr.com/ru/post/318952/">renew certificates</a> . </li></ol><br><h2 id="caveat-emptor">  Caveat emptor </h2><br><p>  <em>You know everything about SNI?</em>  <em><a href="https://habr.com/ru/post/318952/">Read about the installation immediately.</a></em> </p><br><p>  In the instructions below, I assume that your sites will use SNI.  This TLS protocol extension allows browsers to provide the desired site name before receiving and verifying the SSL certificate from the server.  Thanks to SNI, you can host as many sites as HTTPS on a single IP.  But not everything is so simple - otherwise why would I write about it? </p><br><p>  There are a number of old browsers in principle not supporting SNI.  These include any version of IE in an <a href="https://support.microsoft.com/en-us/help/14223/windows-xp-end-of-support">already abandoned Windows XP</a> , embedded browser in <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D1%2581%25D1%2582%25D0%25BE%25D1%2580%25D0%25B8%25D1%258F_%25D0%25B2%25D0%25B5%25D1%2580%25D1%2581%25D0%25B8%25D0%25B9_Android">Android 2.3 and 2.2 from 2010,</a> as well as some other more exotic browsers and libraries like <a href="http://bugs.java.com/view_bug.do%3Fbug_id%3D6985179">Java version 1.6</a> and <a href="https://docs.python.org/2/library/ssl.html">Python up to version 2.7.9</a> . </p><br><p>  If you still want your site to open in IE in Windows XP, then this problem cannot be solved by just giving up SNI.  It is necessary to <a href="https://github.com/client9/sslassert/wiki/IE-Supported-Cipher-Suites">select ciphers in a</a> special way, already abandoning <a href="https://habr.com/ru/post/318952/">forward secrecy</a> and risking getting a <a href="https://www.ssllabs.com/ssltest/">low mark from SSL Labs</a> .  As you can guess, this issue deserves a separate discussion, if only because users of IE under XP can sympathize - half the Internet does not open up! </p><br><p>  A year ago, limited search for this technology by some search bots like Bing could keep you from switching to SNI, but now with the advent of dozens of sites with free certificates from Cloudflare that can‚Äôt open without SNI, the Bing bot ( <a href="https://www.bing.com/webmaster">which is easy to check</a> ) and <a href="https://www.ssllabs.com/ssltest/clients.html">bots other major search engines</a> have come to terms with reality.  Now you can not worry about it.  I note that Googlebot never had such problems. </p><br><p>  Another cause for excitement can be various means of accessing your site's API.  If you have had an API for a long time, then there is a small chance that there are some of your customers using older versions of Java or Python.  If you do not have these, then nothing to worry about.  If there is - my condolences. </p><br><h3 id="pochemu-luchshe-rasschityvat-na-sni">  Why rely on SNI? </h3><br><ol><li><p>  It's simple.  You do not need to constantly keep in mind the facts about the issued certificates.  For which domain the certificate was issued first.  To which certificate you need to <a href="https://habr.com/ru/post/318952/">add more domains</a> .  And so on ... You don't need to think about anything like that with SNI. </p><br></li><li>  Secrets remain secrets.  If you have one certificate for all domains, then anyone can very easily see the entire list, regardless of your desire.  If for each site its certificate, then there is no such problem. </li></ol><br><p>  For example, you can view domains in the Thematic Media certificate: </p><br><pre><code class="hljs perl">true | openssl s_client -showcerts -<span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> habrahabr.ru:<span class="hljs-number"><span class="hljs-number">443</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> | openssl x509 -text | <span class="hljs-keyword"><span class="hljs-keyword">grep</span></span> -o <span class="hljs-string"><span class="hljs-string">'DNS:[^,]*'</span></span> | cut -f2 -d:</code> </pre> <br><p>  At the time of this writing, this command will display a detailed list of all possible TM domains: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">habrastorage</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.org</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">api</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.geektimes</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">api</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.habrahabr</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">geektimes</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">habrahabr</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">id</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.tmtm</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lab</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.geektimes</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">m</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.geektimes</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">m</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.habrahabr</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">special</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.geektimes</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">special</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.habrahabr</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">www</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.geektimes</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">www</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.habrahabr</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span></code> </pre> <br><p>  No secrets and no secrets.  Do you want that? </p><br><h2 id="ustanovka-certbot">  Installing Certbot </h2><br><p>  If you are reading this text from the future, when Certbot is already in Debian stable and Ubuntu without a hitch, it‚Äôs all simple: </p><br><pre> <code class="hljs swift">apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> install certbot</code> </pre> <br><p>  Either use <code>aptitude</code> or another package manager for your distribution. </p><br><h3 id="ustanovka-v-jessie">  Installation in Jessie </h3><br><p>  If you still have Debian stable "jessie" that is relevant at the end of 2016, then everything is just a little more complicated. </p><br><ol><li><p>  You need to connect Debian Backports by adding a line to <code>/etc/apt/sources.list</code> : </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">deb</span></span> http://ftp.debian.org/debian/ jessie-backports main contrib non-free</code> </pre> <br></li><li><p>  Now you can install with the indication of the source: </p><br><pre> <code class="hljs pgsql">apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> install certbot -t jessie-backports</code> </pre> <br><p>  (The section is relevant until only <em>stretch</em> has become stable.) </p><br></li></ol><br><h3 id="ubuntu-versiy-nizhe-1610-yakkety">  Ubuntu versions below 16.10 (yakkety) </h3><br><pre> <code class="hljs pgsql">sudo <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>-apt-repository ppa:certbot/certbot sudo apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> sudo apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> install <span class="hljs-comment"><span class="hljs-comment">--upgrade letsencrypt</span></span></code> </pre> <br><p>  Further everywhere instead of <code>certbot</code> use <code>letsencrypt</code> . </p><br><h3 id="drugoy-distributiv">  Another distribution </h3><br><p>  If you have any other distribution kit, then additional installation instructions are <a href="https://certbot.eff.org/">on the official website Certbot</a> .  If you do without the package manager, then the installation usually comes down to ... </p><br><pre> <code class="hljs perl">wget -O /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/bin/certbot-auto https:<span class="hljs-regexp"><span class="hljs-regexp">//dl</span></span>.eff.org/certbot-auto <span class="hljs-keyword"><span class="hljs-keyword">chmod</span></span> +<span class="hljs-keyword"><span class="hljs-keyword">x</span></span> /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/bin/certbot-auto ln -<span class="hljs-keyword"><span class="hljs-keyword">s</span></span> /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/bin/certbot-auto /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/bin/certbot</code> </pre> <br><p>  Anywhere below you can use the <code>certbot-auto</code> command instead of the <code>certbot</code> command. </p><br><h2 id="certbot-i-webroot">  Certbot and webroot </h2><br><p>  We will receive certificates using the <em>webroot</em> method without reconfiguring or stopping the web server, which means nginx.  We need some directory in which <code>certbot</code> will write its files, and which one should be accessible from the network to the certifying server according to the <a href="https://en.wikipedia.org/wiki/Automated_Certificate_Management_Environment">ACME</a> protocol. </p><br><p>  In order not to write a long line of options each time, and even better not to remember them, we will write the basic settings into the configuration file that <code>certbot</code> expects to find in <code>/etc/letsencrypt/cli.ini</code> : </p><br><pre> <code class="hljs pgsql">authenticator = webroot webroot-<span class="hljs-type"><span class="hljs-type">path</span></span> = /var/www/html post-hook = service nginx reload <span class="hljs-type"><span class="hljs-type">text</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><p>  The last directive is needed to save us from the charms and beauties of ncurses, which is necessary so that you can compare the output of the commands here in this article and in yourselves. </p><br><p>  We also need to gently restart nginx (without interruption in service) when the certificates have been successfully renewed.  At the same time, nothing prevents the restarting of other services like Postfix that use the received certificates.  Commands are separated by a semicolon. </p><br><div class="spoiler">  <b class="spoiler_title">If a semicolon causes an error</b> <div class="spoiler_text"><p>  If you see this error: </p><br><pre> <code class="hljs vhdl">letsencrypt: <span class="hljs-literal"><span class="hljs-literal">error</span></span>: Unexpected <span class="hljs-literal"><span class="hljs-literal">line</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> /etc/letsencrypt/cli.ini: post-hook = service nginx reload; service postfix reload</code> </pre> <br><p>  Then you need to update <code>python-configargparse</code> .  The error was <a href="https://github.com/bw2/ConfigArgParse/commit/8a22034bbd0c74d55e869782d35efe939695fc73">fixed in 0.11.0</a> . </p></div></div><br><h3 id="chto-budet-delat-certbot">  What Certbot will do </h3><br><p>  It is expected that <code>certbot</code> will create the necessary files for checking domain rights in subdirectories down the hierarchy to the specified one.  Like these: </p><br><pre> <code class="hljs swift">/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/.well-known/acme-challenge/example.html</code> </pre> <br><p>  These files will need to be accessible from the network on the target domain at least over HTTP: </p><br><pre> <code class="hljs objectivec">http:<span class="hljs-comment"><span class="hljs-comment">//www.example.com/.well-known/acme-challenge/example.html</span></span></code> </pre> <br><p>  For the following checks, create some kind of file: </p><br><pre> <code class="hljs php">mkdir -p /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/.well-known/acme-challenge <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> Success &gt; /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/.well-known/acme-challenge/example.html</code> </pre> <br><h3 id="registraciya-v-lets-encrypt">  Sign up for Let's Encrypt </h3><br><p>  Registration needs to be done only once: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">certbot</span></span> register --email me<span class="hljs-variable"><span class="hljs-variable">@example</span></span>.com</code> </pre> <br><p>  There is nothing complicated. </p><br><h2 id="podgotovim-nginx-k-polucheniyu-sertifikatov">  Prepare nginx to receive certificates </h2><br><p>  In general, to obtain a certificate, it is necessary in all <code>server</code> blocks to add the following block to other <code>location</code> blocks: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /.well-known { <span class="hljs-attribute"><span class="hljs-attribute">root</span></span> /var/www/html; }</code> </pre> <br><p>  It is clear that to inscribe such a block explicitly for each site is a moveton, therefore we will create the file <code>/etc/nginx/acme</code> with the block contents above. </p><br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta"># cat /etc/nginx/acme location /.well-known { root /var/www/html; }</span></span></code> </pre> <br><p>  Then, for each domain and subdomain for which you need to get certificates, in the <code>server</code> block in front of all the <code>location</code> blocks, we specify: </p><br><pre> <code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> acme;</span></span></code> </pre> <br><p>  Hosts redirectors (for example, from the bare domain on www) can be skipped.  ACME server must take into account the standard redirection.  <a href="https://habr.com/ru/post/318952/">More on this below.</a> </p><br><p>  Reload nginx and check that our test file is visible: </p><br><pre> <code class="hljs 1c"><span class="hljs-meta"><span class="hljs-meta"># service nginx reload # curl -L http:</span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//www.example.com/.well-known/acme-challenge/example.html Success</span></span></span></span></code> </pre> <br><p>  After checking, it is better to delete the test file - <code>certbot</code> likes to delete everything unnecessary, and such a file will interfere and cause an error message (Unable to clean up challenge directory). </p><br><pre> <code class="hljs swift">rm /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/.well-known/acme-challenge/example.html</code> </pre> <br><p>  Now we are ready to <a href="https://habr.com/ru/post/318952/">receive our first certificate</a> . </p><br><h3 id="o-pereadresacii-s-kodami-301-i-302">  About redirects with codes 301 and 302 </h3><br><p>  As already mentioned, the ACME Boulder server takes into account redirection <a href="">with codes 301 and 302</a> .  In this sense, it does not matter where, ultimately, the files required for passing the checks are found.  Redirection is possible even <a href="">to non-standard ports</a> , without restrictions on the final HTTP or HTTPS protocol.  <a href="https://letsencrypt.org/docs/integration-guide/">Let's Encrypt</a> themselves <a href="https://letsencrypt.org/docs/integration-guide/">recommend using redirection to create a single point of verification of domain rights</a> . </p><br><p>  If you can get these files with <code>curl</code> with a limit of ten redirections, then Boulder will see these files.  There should be <a href="https://letsencrypt.org/docs/integration-guide/">no restrictions on IP addresses</a> . </p><br><pre> <code class="hljs swift">curl --location --<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>-redirs <span class="hljs-number"><span class="hljs-number">10</span></span> http:<span class="hljs-comment"><span class="hljs-comment">//example.com/.well-known/acme-challenge/example.html</span></span></code> </pre> <br><p>  This is convenient if you have a complex structure of redirections between different versions of sites.  It should be enough to connect that block with <code>location</code> only on the main site to get certificates for all the others. </p><br><pre> <code class="hljs swift">$ curl --head --silent --location --<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>-redirs <span class="hljs-number"><span class="hljs-number">10</span></span> http:<span class="hljs-comment"><span class="hljs-comment">//somewhere.example.net/... | grep ^HTTP HTTP/1.1 301 Moved Permanently HTTP/1.1 301 Moved Permanently HTTP/1.1 200 OK</span></span></code> </pre> <br><p>  Verification always begins with an HTTP request on port 80. </p><br><h3 id="esli-u-vas-uzhe-vsyo-zashifrovano">  If you have everything already encrypted ... </h3><br><p>  If you already have all the websites working over HTTPS, then the whole scheme will work if you have a forwarding server on port 80, saving <code>$request_uri</code> in the response. </p><br><p>  Another thing is that you can shorten the path and connect our block with the <code>location</code> in the default server for port 80, which does forwarding to HTTPS.  Then it will not be necessary to add anything to the configs of individual sites. </p><br><p>  An example of the configuration of such a forwarding all-in-a-HTTPS server: </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> server.example.com:<span class="hljs-number"><span class="hljs-number">80</span></span> default_server; <span class="hljs-attribute"><span class="hljs-attribute">include</span></span> acme; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">301</span></span> https://<span class="hljs-variable"><span class="hljs-variable">$host</span></span><span class="hljs-variable"><span class="hljs-variable">$request_uri</span></span>; } }</code> </pre> <br><p>  Such a config should be defined in <code>/etc/nginx/conf.d/default.conf</code> , aside from configs of specific sites. </p><br><p>  We start the server explicitly on the external IP in order not to reconfigure Apache to another port.  If this is not a problem for you, you can skip specifying the server name in the <code>listen</code> directive. </p><br><h3 id="esli-nuzhno-poluchit-sertifikat-dlya-domena-bez-sayta">  If you need to get a certificate for a domain without a website ... </h3><br><p>  A typical example is a certificate for servers dedicated to SMTP or IMAP, on which there are no sites at all.  Either use a universal forwarding service that is higher, or ... </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">server</span></span> { server_name smtp.example.com imap.example.com; <span class="hljs-keyword"><span class="hljs-keyword">listen</span></span> <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.example.com:<span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> acme; <span class="hljs-keyword"><span class="hljs-keyword">location</span></span> / { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span>; } }</code> </pre> <br><p>  Unfortunately, the ACME protocol requires that such a server be available during each check.  This is practically equivalent to continuous availability, due to the requirement to obtain and renew certificates without restarting the server.  Do not delete this config after receiving the certificate. </p><br><h3 id="esli-u-vas-tolko-apache2">  If you only have Apache2 ... </h3><br><p>  If you have Apache2, and there is no way to switch to your favorite nginx, then ... Add the following lines to <code>/etc/apache2/conf-available/certbot.conf</code> : </p><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">Alias</span></span> /.well-known/ /var/www/html/.well-known/ &lt;Directory /var/www/html/.well-known/&gt; Satisfy any &lt;/Directory&gt;</code> </pre> <br><p>  Then </p><br><pre> <code class="hljs swift">a2enconf certbot mkdir -p /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/.well-known service apache2 reload</code> </pre> <br><p>  And be sure to check this: </p><br><pre> <code class="hljs coffeescript">mkdir -p <span class="hljs-regexp"><span class="hljs-regexp">/var/www/html/</span></span>.well-known<span class="hljs-regexp"><span class="hljs-regexp">/acme-challenge echo Success &gt; /var/www/html/</span></span>.well-known<span class="hljs-regexp"><span class="hljs-regexp">/acme-challenge/example.html curl -L http:/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/localhost/</span></span>.well-known<span class="hljs-regexp"><span class="hljs-regexp">/acme-challenge/example.html &amp;&amp; rm /var/www/html/</span></span>.well-known/acme-challenge/example.html</code> </pre> <br><p>  There are many reasons why this scheme may not work for you in Apache2.  Pairs of text screens are not enough to describe them all.  Do not be angry - article about nginx. </p><br><h2 id="poluchaem-sertifikaty">  We get certificates </h2><br><p>  Let's Encrypt have <a href="https://letsencrypt.org/docs/rate-limits/">limits on the number of requests for certificates</a> , so we first try to get the necessary certificate in test mode: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">certbot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">certonly</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">--dry-run</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-d</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">example</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.com</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-d</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">www</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.example</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.com</span></span></code> </pre> <br><p>  At the end, the program should report on successful work: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">The</span></span> dry run was successful.</code> </pre> <br><p>  Now you can safely receive a certificate in fact.  Be sure to explicitly list all the necessary subdomains, such as www. </p><br><pre> <code class="hljs vhdl"># certbot certonly -d example.com -d www.example.com Saving debug log <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> /var/log/letsencrypt/letsencrypt.log Starting <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HTTPS connection (<span class="hljs-number"><span class="hljs-number">1</span></span>): acme-v01.api.letsencrypt.org Obtaining a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> certificate Performing the following challenges: http-<span class="hljs-number"><span class="hljs-number">01</span></span> challenge <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> example.com http-<span class="hljs-number"><span class="hljs-number">01</span></span> challenge <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> www.example.com Using the webroot path /var/www/html <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> unmatched domains. Waiting <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> verification... Cleaning up challenges Generating key (<span class="hljs-number"><span class="hljs-number">2048</span></span> bits): /etc/letsencrypt/keys/<span class="hljs-number"><span class="hljs-number">0001_</span></span>key-certbot.pem Creating CSR: /etc/letsencrypt/csr/<span class="hljs-number"><span class="hljs-number">0001_</span></span>csr-certbot.pem IMPORTANT NOTES: - Congratulations! Your certificate <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> chain have been saved at /etc/letsencrypt/live/example.com/fullchain.pem. Your cert will expire <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-number"><span class="hljs-number">2017</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">01</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">To</span></span> obtain a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> tweaked version <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> this certificate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the future, simply run certbot again. <span class="hljs-keyword"><span class="hljs-keyword">To</span></span> non-interactively renew *<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> your certificates, run <span class="hljs-string"><span class="hljs-string">"certbot renew"</span></span></code> </pre> <br><p>  Hooray!  With the receipt of the certificate is finished! </p><br><h3 id="esli-nuzhno-dobavit-poddomen-ili-domen-v-sertifikat">  If you need to add a subdomain or domain to the certificate </h3><br><p>  If you suddenly forgot to specify the <code>www</code> subdomain, or you need to add another domain or subdomain to the certificate (there can be <a href="https://letsencrypt.org/docs/rate-limits/">up to 100 in one certificate</a> ), then this is easy to do after receiving the certificate.  Just run the command again, adding the required name: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">certbot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">certonly</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-d</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">example</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.com</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-d</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">www</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.example</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.com</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-d</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shop</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.example</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.com</span></span></code> </pre> <br><p>  You will have no alternative to add this domain to the certificate.  If you want to avoid questions, you can immediately specify the key approving this behavior: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">certbot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">certonly</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">--expand</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-d</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">example</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.com</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-d</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">www</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.example</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.com</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-d</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shop</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.example</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.com</span></span></code> </pre> <br><p>  The operation can be repeated. </p><br><h2 id="proverim-poluchennyy-sertifikat">  Check the received certificate </h2><br><p>  Make sure that the received certificate is exactly what we need: </p><br><pre> <code class="hljs vhdl"># openssl x509 -<span class="hljs-literal"><span class="hljs-literal">text</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> /etc/letsencrypt/live/example.com/cert.pem Certificate: Signature Algorithm: ... Validity <span class="hljs-keyword"><span class="hljs-keyword">Not</span></span> Before: Jan <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">06</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">2017</span></span> GMT <span class="hljs-keyword"><span class="hljs-keyword">Not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">After</span></span> : Apr <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">06</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">2017</span></span> GMT X509v3 extensions: ... X509v3 Subject Alternative Name: DNS:example.com, DNS:www.example.com</code> </pre> <br><p>  Or, if you don‚Äôt need the details: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">cat</span></span> /etc/letsencrypt/live/*/cert.pem | openssl x509 -text | grep -o <span class="hljs-string"><span class="hljs-string">'DNS:[^,]*'</span></span> | cut -f2 -d:</code> </pre> <br><p>  The team should list the domains in the certificate. </p><br><h2 id="ustanovka-i-ispolzovanie-sertifikatov">  Installing and using certificates </h2><br><p>  Certbot does not overwrite certificates, but replaces them with links to the most current certificate options in a specific directory, which is the same with the first certificate domain (ie, <code>CN</code> ). </p><br><p>  Let's see what files we have: </p><br><pre> <code class="hljs dos"> # <span class="hljs-built_in"><span class="hljs-built_in">find</span></span> /etc/letsencrypt/live/ -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> l /etc/letsencrypt/live/example.com/fullchain.pem /etc/letsencrypt/live/example.com/chain.pem /etc/letsencrypt/live/example.com/privkey.pem /etc/letsencrypt/live/example.com/cert.pem</code> </pre> <br><p>  With this knowledge, we can set the SSL settings for nginx: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate</span></span> /etc/letsencrypt/live/example.com/fullchain.pem; <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate_key</span></span> /etc/letsencrypt/live/example.com/privkey.pem; <span class="hljs-attribute"><span class="hljs-attribute">ssl_trusted_certificate</span></span> /etc/letsencrypt/live/example.com/chain.pem;</code> </pre> <br><p>  As you can see, <code>cert.pem</code> is not used anywhere in the config, and this is not an error.  For nginx it is not needed. </p><br><p>  Full working example config: </p><br><pre> <code class="hljs apache"><span class="hljs-attribute"><span class="hljs-attribute">server</span></span> { server_name www.example.com; listen www.example.com:443 ssl; # default_server; #    default_server    SNI ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem; ssl_trusted_certificate /etc/letsencrypt/live/example.com/chain.pem; ssl_stapling <span class="hljs-literal"><span class="hljs-literal">on</span></span>; ssl_stapling_verify <span class="hljs-literal"><span class="hljs-literal">on</span></span>; resolver 127.0.0.1 8.8.8.8; #    http-  add_header Strict-Transport-Security <span class="hljs-string"><span class="hljs-string">"max-age=31536000"</span></span>; #  <span class="hljs-string"><span class="hljs-string">""</span></span>    http:// add_header Content-Security-Policy <span class="hljs-string"><span class="hljs-string">"img-src https: data:; upgrade-insecure-requests"</span></span>; #       #location / { # proxy_pass ...; #} }</code> </pre> <br><p>  Config for forwarding from a bare domain without www: </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> example.com; <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> example.com:<span class="hljs-number"><span class="hljs-number">443</span></span> ssl; <span class="hljs-attribute"><span class="hljs-attribute">access_log</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate</span></span> /etc/letsencrypt/live/example.com/fullchain.pem; <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate_key</span></span> /etc/letsencrypt/live/example.com/privkey.pem; <span class="hljs-attribute"><span class="hljs-attribute">ssl_trusted_certificate</span></span> /etc/letsencrypt/live/example.com/chain.pem; <span class="hljs-attribute"><span class="hljs-attribute">ssl_stapling</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">ssl_stapling_verify</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">resolver</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1</span></span> <span class="hljs-number"><span class="hljs-number">8.8.8.8</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> Strict-Transport-Security <span class="hljs-string"><span class="hljs-string">"max-age=31536000"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">expires</span></span> max; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">301</span></span> https://www.example.com<span class="hljs-variable"><span class="hljs-variable">$request_uri</span></span>; }</code> </pre> <br><p>  It is understood that you are using some kind of local server to cache DNS queries.  If this is not the case, then <code>127.0.0.1</code> in the <code>resolver</code> directive must be replaced with the IP of the DNS server being used. </p><br><p>  Cipher settings and stuff like that ( <code>ssl_dhparam</code> , <code>ssl_session_cache</code> ) are best kept outside the configs of individual servers. </p><br><h2 id="perfect-forward-secrecy">  Perfect Forward Secrecy </h2><br><p>  If you are worried that Certbot can steal keys from your certificate in spite of <a href="https://github.com/certbot/certbot">open source codes</a> , which means that in theory some villains will be able to decipher all traffic, then I hasten to reassure you.  If <a href="https://ru.wikipedia.org/wiki/Perfect_forward_secrecy">ciphers from the DHE and ECDHE families</a> are used to connect to your site, then a key leak will not allow you to decrypt traffic.  In these ciphers, the certificate key is used only for authentication, and is not used as a key for encryption.  All modern browsers support these ciphers. </p><br><p>  If for ECDHE on elliptic curves nothing needs to be done, then for DHE it would be possible to use enhanced parameters.  <a href="https://habrahabr.ru/post/325230/">It would be best to turn off DHE altogether.</a> </p><br><div class="spoiler">  <b class="spoiler_title">If for some reason you cannot do without DHE</b> <div class="spoiler_text"><p>  If for some reason you cannot do without DHE, then we first create the parameters: </p><br><pre> <code class="hljs cs">openssl dhparam -<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> /etc/ssl/<span class="hljs-keyword"><span class="hljs-keyword">private</span></span>/dhparam.pem <span class="hljs-number"><span class="hljs-number">2048</span></span></code> </pre> <br><p>  Then we write in <code>/etc/nginx/conf.d/ssl_dhparam.conf</code> one line: </p><br><pre> <code class="hljs swift">ssl_dhparam /etc/ssl/<span class="hljs-keyword"><span class="hljs-keyword">private</span></span>/dhparam.pem;</code> </pre> </div></div><br><h2 id="prodlenie-sertifikatov">  Certificate renewal </h2><br><p>  Certificates are issued <em>for three months</em> .  Not for half a year, not for a year, but only for three months.  Naturally this raises questions.  Do I need to go through this whole procedure in three months?  Is it necessary to do this always before the end of time?  Maybe you should still invest in a paid certificate to forget about it all and not remember a couple of years? </p><br><p>  But no, do not rush to look for payment instruments!  As promised at the beginning of the article, there are no problems with updating certificates. </p><br><p>  If you have Debian, you only need to add the <code>--allow-subset-of-names</code> key to the <code>--allow-subset-of-names</code> call in <code>/etc/cron.d/certbot</code> : </p><br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta">#    /etc/cron.d/certbot #  certbot -q renew,   certbot -q renew --allow-subset-of-names</span></span></code> </pre> <br><p>  If you have Debian and systemd, <a href="https://www.alexeykopytko.com/2017/free-ssl-from-letsencrypt/">see these instructions</a> . </p><br><p>  If you do not have Debian or do not have a file, then add only one line to the <code>crontab</code> from <code>root</code> ( <code>sudo crontab -e</code> ): </p><br><pre> <code class="hljs markdown">42 <span class="hljs-emphasis"><span class="hljs-emphasis">*/12 *</span></span> <span class="hljs-bullet"><span class="hljs-bullet">* *</span></span> certbot renew --quiet --allow-subset-of-names</code> </pre> <br><p>  According to the recommendations of Let's Encrypt, you should try to renew certificates twice a day.  This should be done at a randomly selected minute of that hour, which means that you need to replace <code>42</code> in this line with another number in the range between <code>0</code> and <code>59</code> .  Or you can do it the way it is done in <code>/etc/cron.d/certbot</code> . </p><br><h3 id="kak-eto-rabotaet">  How it works </h3><br><p>  In this command, the <code>--allow-subset-of-names</code> key is needed so that Certbot tries to get certificates for a partial set of domains. </p><br><p>  For example, you had on your server sites <em>www.example.com</em> and <em>shop.example.com</em> , passing under one certificate, but then you transferred <em>shop.example.com</em> to another server.  If you do not specify such a key, Certbot will fail with an error when you try to confirm the ownership of <em>shop.example.com</em> without receiving any certificate for you at all.  The certificate will expire and your site will go offline.  With this key, you still get certificates for at least a partial set of domains, leaving your sites online. </p><br><h2 id="vot-i-vsyo">  That's all </h2><br><p>  If you are close in spirit to <code>tee</code> and <code>sed</code> , then there is a much shorter <a href="https://www.alexeykopytko.com/2017/free-ssl-from-letsencrypt/">instruction on how to configure a bunch of Let's Encrypt and nginx</a> , provided the <code>hostname</code> correctly configured.  Just copy the commands and paste. </p><br><hr><br><p>  Found a bug?  <a href="https://habrahabr.ru/conversations/alexkbs/">Write in a personal, please.</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/318952/">https://habr.com/ru/post/318952/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318940/index.html">We're friends with Prometheus with Cach√©</a></li>
<li><a href="../318944/index.html">In search of free tickets, the study of the game Aeroflot: Mission 2017</a></li>
<li><a href="../318946/index.html">How to find a way to win the Russian AI Cup 2016, but in the wrong direction</a></li>
<li><a href="../318948/index.html">Finding GDI Object Leaks: How to Drive a Mastodon</a></li>
<li><a href="../318950/index.html">NativeScript, what kind of beast and what is it for?</a></li>
<li><a href="../318954/index.html">Processing preprocessor directives in Objective-C</a></li>
<li><a href="../318958/index.html">json-api-normalizer: an easy way to make friends with Redux and the JSON API</a></li>
<li><a href="../318960/index.html">Scala type classes (with a little overview of the cats library)</a></li>
<li><a href="../318962/index.html">About string formatting in modern C ++</a></li>
<li><a href="../318964/index.html">Towers of Hanoi - a theoretical solution without recursion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>