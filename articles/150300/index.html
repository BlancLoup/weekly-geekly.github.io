<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Time travel and programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Now not only science fiction writers write about time travel. After reflections of ancient philosophers, formulas of the general theory of relativity,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Time travel and programming</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/c51/043/64b/c5104364ba6c0613af91e5a00b29a37b.jpg"><br>  Now not only science fiction writers write about time travel.  After reflections of ancient philosophers, formulas of the general theory of relativity, wormhole models continue to appear new theories, and even projects.  Many of them, however, require black holes for their work, infinitely long cylinders, matter with negative mass and other artifacts.  Does all this bring us closer to creating a time machine?  It is difficult to talk about this objectively, without understanding the essence of the question - what time is.  For several centuries, this understanding has increased, in fact, slightly.  Perhaps with the advent of programming, the situation will change?  After all, there many answers await us. <a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Looking ahead</b> <div class="spoiler_text">  Soon we will be convinced that the flow of time and the execution of a computer program are practically the same thing.  Such an analogy allows us to illustrate the story with clear examples, and provides many interesting discoveries. <br></div></div><br>  Next article in the series: <a href="http://habrahabr.ru/post/178959/">‚ÄúTime Travel and Programming 2: Paradoxes‚Äù</a> <br><br><h3>  0. Time and space </h3><br>  To begin with, we need to determine in the first approximation what time is.  For now, without programming, be patient.  The term ‚Äútime‚Äù is usually understood as the visible course of events, the process of continuous change of the surrounding world.  In this case, the most important and obvious feature of these changes is missing.  What happened in the universe from the moment of the big bang to the present day?  From the point of singularity step by step (first elementary particles, then hydrogen atoms, ...) a complex multi-level system was formed, consisting of galaxies, stars, planets, at least one of which contains intelligent beings reading Habr from a computer screen.  These colossal changes would be simply impossible without some control mechanisms (embedded in reality itself).  The world does not just change - it gradually changes from simple to complex.  Therefore, <br>  <b>Time is the fundamental mechanism of development that governs the course of events.</b> <br><br>  Let's compare the Universe with a children's kaleidoscope toy.  There unique pictures flash - it seems to be also a permanent change.  There is also a causal link - the current position of the colored glass pieces (forming the picture) depends on the previous one.  What is the difference?  In simple terms - the lack of development (learning).  You can turn a kaleidoscope for even a million years - nothing qualitatively new will appear in it.  In nature, this does not happen: the cosmos, the biosphere evolve, science, society, any enterprise, team, man ‚Äî yes, in general, everything, any system ‚Äî is developing.  If the passage of time were ‚Äújust a movement‚Äù, the world would remain in a state of chaos, there would be no qualitative changes in it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If time is the result of purposeful changes, <b>what is space</b> ?  The object of these changes.  In other words, <b>space is a structure, time is a dynamic</b> .  I understand that a certain ‚Äúemptiness where everything is located‚Äù is associated more with space (and this ‚Äúall‚Äù is called ‚Äúmatter‚Äù).  But there is a geometric approach to the description of the nature of matter, where any particles and radiations are inhomogeneous spaces.  Like ripples on the surface of the lake. <br>  The concept of time as a physical field participating in all processes as a structuring principle can be found in the theory of "causal mechanics".  Its author is Soviet astronomer N.A.  Kozyrev, and about his heroic work, amazing experiments - you need to write a separate article. <br><br><h3>  1. Starting point </h3><br>  We have time and space on the one hand, and data and code on the other.  It is logical to relate them as follows: <br>  <b>Space is data, time is code.</b> <br>  As time changes space, code changes data.  We have already managed to deal with the fundamental property of time: it does not just change, but purposefully structures space, reducing its entropy (chaos).  The code that introduces chaos into the data certainly occurs (all sorts of randomizers), but for the most part, it processes the data in order to streamline it, or get new data - in general, something qualitatively new is output.  The simplest example: sorting an array.  The code describes the dynamics of reducing the structure of an array to a more ordered form.  In another example, the input data is a cloud of gas and dust, for 4.6 billion years <i>some code</i> transformed it into our solar system (it is clear that the code is somewhat more complicated than the bubble algorithm). <br>  The inseparability of time and space is also easy to illustrate. <br><pre><code class="cpp hljs">x; <span class="hljs-comment"><span class="hljs-comment">//  x?   ++; //  ?   x++; //   </span></span></code> </pre> <br>  Try to write the shortest (not empty) program: there will definitely be some action on some data (that is, the ‚Äúatom‚Äù of the program is a bundle of ‚Äúdata + action‚Äù). <br><br>  So, in the real world, space without time cannot exist.  As the hero of the story ‚ÄúTime Machine‚Äù said: ‚Äútry to imagine a cube that does not exist for a single moment!‚Äù This is an important conclusion: the space (data) exists only during the passage of time (code execution). <br><br><h3>  2. Basic concepts </h3><br>  <b>Atom: the</b> unit of code will be the command (containing the action on the data).  The unit of time flow is an event.  What is the team doing?  Changes data.  What makes an event?  Changes space.  Commands are added to the code, events are added to the chain. <br><br>  <b>Causality:</b> commands are logically related, and besides being executed sequentially, the result of one is often input to the other.  Also the event has input and output data (structure of the space before and after). <br><br>  <b>World line:</b> in physics it is a sequence of existence of a certain object.  It corresponds to the code execution flow, i.e.  code + data. <br><img src="https://habrastorage.org/storage2/15b/1f5/4c2/15b1f54c2a91ba0528e7f68f478f0723.jpg"><br>  So again, let's draw an analogy between a chain of commands and a thread of events.  An event is an ‚Äúaction on data‚Äù, i.e.  space change under time management.  The input data for it is the previous state of space (which, as we remember, is ‚Äúdata‚Äù), we get, again, the modified space. <br><br><h3>  3. Fractality </h3><br>  In the form of a diagram of actions you can draw a world line of any object.  For example, a room where a person sits: <br><img src="https://habrastorage.org/storage2/675/0f6/23a/6750f623ac9ea9152e54367ec8bed53c.jpg"><br>  Obviously, inside this stream, a lot of event chains flow in parallel: a person sits at a computer, a cat sleeps in a chair, tea cools down on the table, etc.  Each of these flows also has its own nested flows, you can trace this down to the movement of molecules, etc.  The principle of the nested doll, or fractality, which is applicable both to the structure and to the dynamics (and to both of them simultaneously).  Therefore, the Universe is ‚Äúinitially multithreaded‚Äù, since  contains an infinite number of parallel events.  And all these events are naturally representable as a hierarchical tree. <br><img src="https://habrastorage.org/storage2/bcb/4ea/964/bcb4ea964564a70107b2a5016a9ce442.jpg"><br><br>  Complete analogy with programs, most of which are not reduced to a linear sequence of commands and, as a rule, consists of various structural units nested into each other.  A function consists of calls to other functions, and each of them describes its own ‚Äúscope of activity‚Äù.  The decision-making algorithm operates with facts, the function calls embedded in it, calculate facts based on the data, calling for mathematical functions ... and so on. <br><br>  Since we have touched on multithreading, you may have a question about thread synchronization, transaction isolation levels.  Consider the example of "two writers."  There are two streams, one variable, both streams trying to write a number into it in parallel.  It is necessary to put lock on the record, i.  he will write down the first one, only then the second (he will have to wait).  Yes, the second one will overwrite the results of the first one.  It is clear that due to technical peculiarities there is no other way ... but do you have a feeling that the real world works differently? <br><img src="https://habrastorage.org/storage2/98a/cff/015/98acff0150b09d44ad317ce5f5fb0062.jpg"><br>  Instead of a variable, we now have some area of ‚Äã‚Äãspace.  Two streams recording numbers are the two rays of light entering there.  What will happen?  In simple terms, their energy is summed up.  There is no stream synchronization, the principle of superposition works.  Perhaps someday there will be computers in which, when simultaneously writing numbers 1 and 2 in a variable, the result will be 3. <br><br><h3>  4. Time machine </h3><br>  Time has properties: <br>  1. The principle of causality - the events follow in a strict order, in which the cause precedes the effect. <br>  2. The principle of alternativeness - for any event there are several options for the outcome. <br>  3. The principle of cyclicity - the events are repeated. <br><br>  With the first one, I think it is clear - without a causal link ‚Äútoday‚Äù would not depend on ‚Äúyesterday‚Äù, and the sequence of changes leading to some result would be impossible (imagine the code where the next command is chosen randomly). <br><br>  Thanks to the second, we live in a world of relative freedom of choice, and not total predetermination of events. <br><br>  The third is mentioned less frequently, although we observe the cyclical nature of time all the time, absolutely in all processes: heartbeats, breathing, day and night, seasons, ups and downs in production, economic fluctuations, the water cycle in nature, and much more.  Cyclicity follows from the very idea of ‚Äã‚Äãtime: if time is an algorithm, then it must have stages.  And they will be constantly repeated.  In the first approximation, we are talking about two stages (analysis-synthesis, decline-growth, etc.), which we, again, see in all processes (since this is a universal law). <br><br>  Already guessed, right?  These properties correspond exactly to the main position of structured programming: any executable algorithm can be represented by a set of 3 control structures: sequence, branch, loop.  This statement is proved by the Bem-Jakopini theorem (sometimes mistakenly attributed to Dijkstra).  We will consider these three constructions as a <b>basic set</b> . <br><img src="https://habrastorage.org/storage2/4b6/746/d0b/4b6746d0b1ed99a682341673b2dfa6ef.jpg"><br>  As you know, Dijkstra was an ardent opponent of the goto operator (unconditional transition), and advocated using only the basic set.  However, this statement is implicitly present in the code. <br>  First, the function calls: the address of the call point is put on the stack, and a transition occurs to the subroutine (another piece of code). <br>  Secondly, a cycle is a combination of a conditional operator and a conditional operator.  Yes, we are talking about different levels: the C code will not contain transitions, they will appear only at the level of machine instructions into which the program will be compiled.  It can be assumed that time itself is arranged in a similar way: in addition to the basic set, there is a <b>transition instruction</b> .  Without transitions (albeit implicit ones), the program would be primitive: just a sequence of commands, without cycles, without the ability to allocate code in functions and call them.  Similarly, the transition operator is a necessary component of the mechanism of time.  If we continue the analogy, then without it there would be no cyclicity in natural processes, and the possibility of a multi-level (modular) organization of process management.  In general, nothing would have worked.  Time travel is an important mechanism of reality. <br><br>  Let's see <b>what the move looks like</b> : <br><img src="https://habrastorage.org/storage2/cf8/7f0/dd4/cf87f0dd45a84a651cf4cdbe28e0494f.jpg"><br>  The diagram shows that the movement does not occur at the same point, but with a shift along the vertical axis (space), because these are lines not of code (time), but space + time (data + code). <br><br>  It should be noted that in addition to the jumps in time, there is the concept of <b>changing the speed of the flow of time</b> .  For example, the world around ‚Äúfroze‚Äù, and a person can see the wings of a flying bee, outrun the sound of the phrase he said, etc.  Here again, causal mechanics of Kozyrev comes to the rescue.  The influx of time into the system makes it more orderly, i.e.  the density of time (and the speed of processes) is higher where there is a more ordered structure.  <b>The rate of flow of time is the degree of ordering of the data.</b>  Where is it easier to find a book - on a neat shelf or in a dumped pile?  Who will find the solution faster - the one whose knowledge is put in order, or the one who has porridge in his head?  Returning to the array example.  Let there be two arrays now: chaotic and sorted.  The task is to find the given number in the array.  Obviously, in the second array it will be faster (the search code, of course, is different).  Relatively speaking, the second array is more ‚Äúdeveloped‚Äù than the first, and all processes occur in it faster. <br><br><h3>  5. Time Flows </h3><br>  Suppose space-time is beautifully described by the concept of OOP.  This, among other things, will mean that the data can exist not only in the form of parameters received and returned by functions, but also simply stored in the fields of objects.  We remember that space and time do not exist separately, therefore space (data) exists only during the course of time (code execution).  And this is the functional programming paradigm. <br>  We depict the sequence of events (as data that changes when passing through some code): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x = x++; x = x * x;</code> </pre><br>  The time code is not classes, not variables, but a set of functions describing data transformations (that is, space structures).  What was the original data is hard to say.  When the process was launched, countless threads of execution of the Time code were formed, and the space we see is just a slice of data transferred from one function to another. <br><br>  Alas, I am not at all knowledgeable about the FP, but I will still try to depict the example above without using variables: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x++; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x*x; }  : f3(f2(f(<span class="hljs-number"><span class="hljs-number">1</span></span>))) ‚Äì  ,  .</code> </pre><br>  The description of the course of time in the form of a program written in a functional programming language solves the <b>fundamental question: where does the past ‚Äústore‚Äù?</b>  <b>Is it right to understand that the present is ‚Äúthat which is,‚Äù and the past is ‚Äúits saved record‚Äù?</b>  <b>No and no again.</b>  <b>Nothing is stored anywhere; there is just a chain of functions through which the data passes.</b>  <b>Every moment of time it takes "input data", changes it, and "passes on."</b>  <b>We describe it as a sequence of code execution, but this is not quite true, because if the code is time, then it runs in some kind of ‚Äúovertime‚Äù.</b>  You read this article consistently, but it already exists all entirely.  The present is the point of our perception, physically the current moment is no different from any other, in the past or the future. <br><br>  Comparing event chains with function call chains, we did not take into account the possibility of splitting (Fork) and merging (Join) threads. <br><br><h3>  6. Tree of Worlds </h3><br>  I think everyone is familiar with Everett's theory of the "fissile universe."  At each event, reality is split into multiple copies, embodying all possible outcomes of the event.  We throw a coin, the Universe is immediately divided into two: in one reality an eagle drops out, in the other - tails (speaking of course, of course).  The position of the coin is the only difference between these realities.  However, after a while, the realities may diverge: for example, depending on the outcome, a person commits one or another act, which may further lead to even greater differences.  In general, it looks like a tree with a rapidly growing crown, the root of which is the moment of creation of the Universe.  The fact that there must be a process of merging realities that compensates for this proliferation does not reflect everything, and some theorists deny this possibility altogether.  But we will come back to it. <br><br>  The theory of parallel realities has two excellent illustrations in programming: multithreading and the SVN version control system. <br><br>  We have already said that we see around us a multitude of events flowing parallel to each other - they are separated by space (and they can also by time).  For example, we throw two coins at once, something falls independently of them on each other.  Now we are talking about the third type of separation of events, when they occupy the same space and time, but are in different branches of reality.  Splitting code execution flow (i.e. creating threads) in activity diagrams is known as a FORK operation. <br><img src="https://habrastorage.org/storage2/7b0/720/9fb/7b07209fb1481ea906b3db8f8e2f2fbe.jpg"><br>  And here is a very curious moment!  Threads in a program are created much less frequently than an if statement is encountered.  Perhaps something similar happens in reality?  Those.  parallel worlds are formed not for each and every event, but only at certain moments (determined by code, ie, by the flow of time).  Otherwise it would be strange: where we see if, Fork is actually hidden. <br><br>  The second example to the topic of parallel worlds is SVN.  For those who do not know, a brief explanation: when developing a software product, the code is stored on the server (in the repository).  Each developer on the disk has a local copy of it, and there are two main operations: Update ‚Äî download changes from the repository to yourself, Commit ‚Äî upload your changes to the server.  But for our topic the most interesting thing is not even in this, but in such things as <b>diff and branch</b> .  When a change occurs in the repository (even if one character was changed in one of the million files), a new revision is automatically created, with the number one less than the current one.  The server stores all revisions, and allows you to pump out not only the latest (HEAD) revision, but also any friend.  If SVN would make a copy of the entire repository for each change, it would work for a very long time, and disk space would end quickly.  Instead, he remembers only the difference, i.e.  in which files which lines have changed, deleted, or added.  This delta between the two revisions is called diff.  All that is on the server now is, ultimately, the sum of the diffs of all revisions.  Sometimes branches (branch) are made from the main project (called the trunk), which allows you to make changes independently to the trunk and the branches.  The fate of the branch is determined by the developers, based on its task.  In some cases, it merges back into the trunk.  The SVN toolkit works with revisions and branches exclusively in diff concepts.  We can always see the diff between revisions (i.e. what exactly has changed from the previous revision).  We can roll the commit made in one branch to another branch - while again we will see exactly diff. <br><br>  <b>What does this analogy with SVN give us?</b> <br>  Nature always seeks to follow the path of least energy.  I think that one of the reasons why Everett's theory fits hard in my head is this.  The idea that as a result of the collision of two atoms with the Universe (which is several dozens of orders of magnitude more) is removed a few full copies - any sensible person will seem at least strange.  But programmers here understand everything: only the difference between the Universes (diff) is copied and ‚Äústored‚Äù. <br><br>  <b>So what about JOIN?</b> <br>  The forces of nature are always symmetrical, and if realities can branch, then they can also stick together.  I adhere to the theory that the Universe arose as a result of the big bang, and sometime (very soon) will change its expansion to compression (two phases of the cycle: analysis and synthesis).  Here we are talking about space, and there is still a tree of parallel realities that expands along with space - it, too, should eventually be reduced to a point.  Without the mechanism of merging realities, this would be impossible. <br>  The existence of the force of attraction that seeks to unite reality can be illustrated by the following example. <br><img src="https://habrastorage.org/storage2/5ce/2dc/a4b/5ce2dca4bbaf3d9ddf108da9260135e3.jpg"><br>  You need to come to a specific address, and there are plenty of ways to do this.  There is a branching: in one reality, you fly on a flip-bubble, in another on a teleporter, in the third, on foot.  On the one hand, these realities seek to disperse, accumulate the maximum diff, because some events pull others along (they walked, they met their acquaintances ‚Äî they went to a cafe, flew on a flip, got into an anti-gravity pit ‚Äî they spilled coffee on clothes, flew home).  On the other hand, there is a goal (to get to a given point), which sets an event vector.  Deviations may be stronger than this vector, but not always.  Most likely, one way or another, you still get to the place - the reality collapsed. <br>  Purely physically, the fusion of realities can be described by the same principle of superposition, as in the example with two rays of light.  Here we come to another interesting conclusion: each point of space-time is the top not only for the bush of subsequent alternative events, but also the result of the merging of a number of preceding (parallel) events. <br><br><h3>  7. Laws of time </h3><br>  Consider some interesting features of work time (again, through the eyes of programmers). <br><br>  <b>Paradoxes are brunches</b> <br>  The most terrible paradox, which many fantastic characters fear, is the ‚Äúparadox of the grandfather‚Äù.  Consider it on the example of the movie "Back to the Future."  Marty moved from 1985  in 1955, and prevented the acquaintance of his parents.  A new branch appears (code execution flow, SVN branch, whatever), i.e.  alternative reality.  Marty will not be born in it, but our Marty will remain in this world.  Moving back to 1985, he will fall into the future of this alternative world.  But Marty coped with the task - he not only introduced the parents, but also influenced their character.  Back in 1985, he was shocked by the positive changes that had occurred to his family.  What happened?  He did not let the brunch get out of the trunk much (in terms of its birth), and also rolled a patch: <br>  ================================================= ================= <br>  - Hill Valley / McFlaev Family (revision 1) <br>  +++ Hill Valley / MacFlaev Family (working copy) <br>  <font color="#990000">- Swagger Biff Tannen - Chief</font> <font color="#990000"><br></font>  <font color="#990000">-Broken car</font> <font color="#990000"><br></font>  <font color="#990000">-Brother in tracksuit</font> <font color="#990000"><br></font> <br>  <font color="#009900">+ Beef rubs machines</font> <font color="#009900"><br></font>  <font color="#009900">+ Toita Statler in the garage</font> <font color="#009900"><br></font>  <font color="#009900">+ Brother in a jacket and trousers</font> <br>  ================================================= ================= <br><br>  <b>Time loops are recurrent calculations.</b> <br>  In the wonderful film ‚ÄúGroundhog Day‚Äù, poor fellow Phil lived the same day hundreds of times until he perfected him.  Every ‚Äûnext day‚Äú he did not start from scratch - he remembered all the previous ones, had accumulated experience (for example, playing the piano), and so it went on until a certain condition was triggered. <br><img src="https://habrastorage.org/storage2/4c4/5f2/507/4c45f25079aefda07d391d0d0c9084ec.jpg"><br>  In one day, Phil has been spinning for about 10 years ‚Äî that is,  "Some" three and a half thousand iterations.  Theoretically, they can be even more, but not infinitely.  Such a conclusion is dictated by the law of conservation of energy.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The time loop, which contains an infinite number of turns, is equivalent to the infinite energy density of events and the infinite information density in this fragment of history. </font><font style="vertical-align: inherit;">Most likely, a loop with an unconditional transition is just gradually ‚Äúde-energized‚Äù, since </font><font style="vertical-align: inherit;">it will be out of the main stream of time. </font><font style="vertical-align: inherit;">If we draw an analogy with the program, then there is a mechanism limiting the maximum number of iterations for cycles.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> At the end of the cycle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And what, such is the law of time: we have returned to the starting point, but already at a qualitatively new level. Whether to adhere to orthodox time paradigms, or to use any opportunities for new understandings - this is a choice. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why is it not a plowed field for programmers? Maybe the creator of Time was an IT person to the bone? It's all about logic. There are basic tasks, and there are their logical solutions. Store diff instead of full copy. Loop a set of actions instead of replicating it. Any technical specialist will face similar tasks in a wide variety of fields. The device of reality is not an exception, there were similar tasks there too, and ‚Äúsomeone‚Äù solved them. More precisely, everything is certainly the opposite: we, without knowing it, are repeating the decisions already laid down in reality (calling it logic, a systems approach, etc.).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the key to understanding the structure of reality falls into our hands. </font><font style="vertical-align: inherit;">About time you can not only shoot fiction, or documentaries (in fact, the issue, as a rule, empty). </font><font style="vertical-align: inherit;">To touch the secret of time does not need a LHC, or knowledge of quantum meme (although at a certain stage, it may not hurt). </font><font style="vertical-align: inherit;">Every programmer already has everything necessary for studying the nature of time - his way of thinking.</font></font><br><br>  <b>UPD</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have touched upon a very complex topic, which has caused quite a few discussions, the result of which - the answers and accents on what was said earlier - are offered for reading. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. The main idea of ‚Äã‚Äãthe article is not that the Universe is a computer, virtual reality, etc. </font><font style="vertical-align: inherit;">The starting point of the article is that </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time is a process control mechanism.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This is what builds up the chains of events according to a certain algorithm (therefore, time = code), due to which the orderliness of the Universe increases with time. One of the basic properties of this algorithm is cyclicity (there have already been examples). ALL PROCESSES in the Universe are cyclical. Yes, the movement of the Earth around the Sun is associated with gravity, and it would seem, what's the time? We can see this principle (the presence of a center and the rotation of elements around it) on any scale: from an atom (nucleus, electrons) to space (star systems, galaxies, according to one theory - the Universe itself, everything rotates). Rotational movement is the most fundamental, since all other types of movement are his particular cases. If the basis of physical reality is rotation - then there is cyclicality in everything. And this is a property of time (since we are talking about the dynamics of processes).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Comparing the time and the program, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we need to forget that the program is running</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The very idea of ‚Äã‚Äã‚Äúdoing‚Äù implies the existence of some current moment, ‚Äúpresent‚Äù - and it is only in our perception. If you look at eternity, we see world lines of objects stretched from the past to the future, i.e. any system exists "at once" in all moments. If we associate this world line with a certain sequence of code commands (time) and data (changed by this code) - can we really say that this code is executed consistently?</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first this action, then this, after some time - it will be this ... and now we are already talking about "the passage of time in time", i.e. describe time through itself - a vicious circle. Above the adequate paradigm of the flow of time need to think further. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Many questions about cyclicality. Once again: cycling is not a repetition of those events that have already happened. This is a repetition of the controls of time. It comes from the outside, from the system of which the object is a part. There are many such effects - the response to them gives rise to the rhythm of events. For example, a glass stands on the window, and it ‚Äúmeets‚Äù the sunrise regularly, in increments of the day. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Many are interested in the question of the actual movement (especially in the past), which did not have enough time to fully highlight the article (and whether the second one is not yet clear). Add a few words.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getting into the past is not ‚Äúrecover data‚Äù, and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will you recover it? </font><font style="vertical-align: inherit;">The line (t) of the runk (i.e., the ‚Äúarrow of time‚Äù), and the line of the branch that was branched from it when transferred to the past are all chains not of ‚Äúcode‚Äù, but of ‚Äúcode + data‚Äù. </font><font style="vertical-align: inherit;">Here you need to think in the functional programming paradigm: data outside of code execution DOES NOT EXIST! </font><font style="vertical-align: inherit;">There are no variables that need to be restored. </font><font style="vertical-align: inherit;">If you flew to another point of the ‚Äúcode execution graph‚Äù (ie, into the past), there will be the same data as ‚Äúthere were before‚Äù. </font><font style="vertical-align: inherit;">How to do it in practice? </font><font style="vertical-align: inherit;">Reasoning will lead us beyond the bounds of the programming topic </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. A small continuation of the article can be found </font></font><a href="http://timeacademy.ru/2-uncategorised/23-timeprograming"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/150300/">https://habr.com/ru/post/150300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150292/index.html">Android smartphones will control NASA satellites</a></li>
<li><a href="../150293/index.html">The backdoor for the brain has already been created!</a></li>
<li><a href="../150294/index.html">Original Samsung</a></li>
<li><a href="../150295/index.html">40 million installations of Web Of Trust</a></li>
<li><a href="../150298/index.html">Is Symmetric NAT So Scary?</a></li>
<li><a href="../150302/index.html">We learn Python quality</a></li>
<li><a href="../150303/index.html">Search@Mail.Ru, part two: review of data preparation architectures of large search engines</a></li>
<li><a href="../150305/index.html">‚ÄúRunet today‚Äù, August 27, 2012. Experts of the issue: Ilya Balandin, Pavel Nikonov</a></li>
<li><a href="../150306/index.html">Simple rules for simple layout.</a></li>
<li><a href="../150307/index.html">TsODy.RF - Russia's first magazine about data centers only</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>