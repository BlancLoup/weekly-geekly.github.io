<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.Net Binary serialization without reference to the assembly with the original type or how to negotiate with BinaryFormatter</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will share the experience of binary type serialization between assemblies, without reference to each other. As it turned out, there ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.Net Binary serialization without reference to the assembly with the original type or how to negotiate with BinaryFormatter</h1><div class="post__text post__text-html js-mediator-article">  In this article I will share the experience of binary type serialization between assemblies, without reference to each other.  As it turned out, there are real and "legitimate" cases when you need to deserialize the data without having reference to the assembly where they are declared.  In the article I will talk about the scenarios in which this was required, describe the solution method, and also describe intermediate errors made during the search. <br><br><h3>  Introduction  Formulation of the problem </h3><br>  We cooperate with a large corporation working in the field of geology.  Historically, corporations have written very different software for working with data coming from different types of equipment + data analysis + forecasting.  Alas, all this software is not always "friendly" among themselves, but more often it is not at all friendly.  In order to somehow consolidate information, a web-portal is now being created, where different programs upload their data in the form of xml.  And the portal is trying to create a plus-minus-full view.  An important caveat: since the portal developers are not strong in the subject areas of each of the applications, each team provided a parser / data converter module from its xml to the portal data structures. <br><a name="habracut"></a><br>  I work in a team that develops one of the applications and we pretty easily wrote a mechanism for exporting our data part.  But here, the business analyst decided that the central portal needed one of the reports that our program was building.  This is where the first problem appeared: the report is rebuilt every time and the results are not saved anywhere. <br>  ‚ÄúSo save!‚Äù The reader will probably think.  I thought so too, but I was seriously disappointed by the requirement that the report be built for the downloaded data.  There is nothing to do - you need to transfer the logic. <br><br><h2>  Stage 0. Refactoring.  No signs of trouble </h2><br>  It was decided to allocate the logic of building the report (in fact, this is a plate in 4 columns, but the logic is a car and a large truck) in a separate class, and the file with this class should be included by reference to the parser assembly.  By this we: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Avoid direct copying </li><li>  Defending against version discrepancies </li></ol><br>  Selecting logic in a separate class is not a difficult task.  But then everything was not so rosy: the algorithm was based on business objects, the transfer of which did not fit into our concept.  I had to rewrite the methods so that they took only simple types and operated on them.  It was not always simple and in places, which required decisions, the beauty of which remained in question, but in general, a reliable solution was obtained without obvious crutches. <br><br>  One detail remained, which, as is known, often serves as a cozy shelter for the devil: a legacy of previous generations of developers gave us a strange approach, according to which some data required for building a report is stored in the database in the form of .Net objects serialized in a binary way ( the questions ‚Äúwhy?‚Äù, ‚Äúkaaak?‚Äù, etc. alas, will remain unanswered due to the absence of addressees).  And the input of calculations, we, naturally, have to deserialize them. <br><br>  These types, from which it was impossible to get rid of, we also included "by reference", especially since they were rather uncomplicated. <br><br><h3>  Stage 1. Deserialization.  Remember the full name of the type </h3><br>  Having performed the above manipulations and performed a test run, I unexpectedly received a runtime error that <br><blockquote>  [A] Namespace.TypeA cannot be cast to [B] Namespace.TypeA.  Type A originates from 'Assembley. Application, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null' in the context 'Default' at location '...'.  Type B originates from 'Assmbley.Portal, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null' in the context 'Default' at location ''. </blockquote>  The very first Google links told me that the fact is that the BinaryFormatter writes not only data, but also type information to the output stream, which is logical.  And given that the full name of the type contains the assembly in which it is declared, the picture of what I was trying to deserialize was evidently a completely different one, from the point of view of .Net <br><br>  Scratching the back of my head, I, as it happens, made the obvious, but, alas, vicious, the decision to replace a specific TypeA type when deserializing with <b>dynamic</b> .  It all worked.  The results of the report converged into a little piece, tests on the build server passed.  With a sense of accomplishment, we send tasco testers. <br><br><h3>  Stage 2. The main.  Serialization between builds </h3><br>  Payback came quickly in the form of bugs registered by testers, which stated that the parser was on the portal side, fell with the exception that it could not load the Assembley.Application assembly (build from our application).  First thought - did not clean the references.  But - no, everything is fine, no one refers.  I try to run it again in the sandbox - everything works.  I begin to suspect a build error, but here, a thought comes up that does not please me: I change the output path for the parser to a separate folder, and not to the common bin-directory of the application.  And voila - I get the described exception.  Analysis of the model confirms vague guesses - deserialization is falling. <br><br>  Awareness was quick and painful: replacing a specific type with dynamic, did not change anything, BinaryFormatter still created the type from the outer assembly, only when the assembly with the type was lying next to, the runtime naturally loaded it, and when the assembly was not we get an error. <br><br>  There was a reason to become sad.  But googling gave hope in the form of a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.serializationbinder%3Fview%3Dnetframework-4.7.2">SerializationBinder Class</a> .  As it turned out, it allows us to determine the type in which our data is serialized.  To do this, create a successor and define the following method in it. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindToType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String assemblyName, String typeName</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  in which you can return any type for the given conditions. <br>  the BinaryFormatter class has the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter.binder%3Fview%3Dnetframework-4.7.2">Binder</a> property, where you can inject your implementation. <br><br>  It would seem - there is no problem.  But again, the details remain (see above). <br><br>  First, you must handle requests for <b>all</b> types (and standard ones too). <br><blockquote>  A rather interesting implementation variant was found on the Internet <a href="https://www.codeproject.com/Tips/1101106/How-to-Serialize-Across-Assemblies-with-the-Binary">here</a> , but there they are trying to use the default binder from BinaryFormatter, as a construct <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defaultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryFormatter().Binder</code> </pre> <br>  But in fact, the default Binder property is null.  Analysis of the source code showed that inside BinaryFormatter it is checked whether Binder is set, if yes - its methods are called, if not - internal logic is used, which ultimately boils down to <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assembly = Assembly.Load(assemblyName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FormatterServices.GetTypeFromAssembly(assembly, typeName);</code> </pre><br></blockquote>  Without further ado, I repeated the same logic in myself. <br><br>  This is what happened in the first implementation. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyBinder</span></span> : <span class="hljs-title"><span class="hljs-title">SerializationBinder</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindToType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> assemblyName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> typeName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (assemblyName.Contains(<span class="hljs-string"><span class="hljs-string">"&lt;ObligatoryPartOfNamespace&gt;"</span></span>) ) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bindToType = Type.GetType(typeName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bindToType; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bindToType = LoadTypeFromAssembly(assemblyName, typeName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bindToType; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadTypeFromAssembly</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> assemblyName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> typeName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(assemblyName) || <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(typeName)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assembly = Assembly.Load(assemblyName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FormatterServices.GetTypeFromAssembly(assembly, typeName); } }</code> </pre><br>  Those.  checked if the namespace belongs to the project - return the type from the current domain, if the system type - load from the corresponding assembly <br><br>  It looks logical.  We start testing: our type comes - we replace it, it is created.  Hooray!  A string comes - go along the branch with loading from the assembly.  Works!  Open virtual champagne ... <br><br>  But here ... Dictionary comes, with elements of custom types: since this is a system type, then ... obviously, we are trying to load it from the assembly, but since its elements are our types, with it, again with full qualification (assembly, version, key ) then we fall again.  (there should be a sad smile here). <br><br>  Clearly, you need to change the input name of the type, substituting references to the desired assembly.  I really hoped that for the type name, there is an analogue of the <a href="https://docs.microsoft.com/cs-cz/dotnet/api/system.reflection.assemblyname%3Fview%3Dnetframework-4.7.2">AssemblyName</a> class, but I did not find anything similar.  Writing a universal replacement parser is not an easy task.  After a series of experiments, I came up with the following solution: in a static constructor, I read types for replacement, and then I look for their names in the line with the name of the type being created, and when I find it, I replace the name of the assembly <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> The types that may be changed to local </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> protected static IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment"> _changedTypes; static MyBinder() { var executingAssembly = Assembly.GetCallingAssembly(); var name = executingAssembly.GetName().Name; _changedTypes = executingAssembly.GetTypes().Where(t =&gt; t.Namespace != null &amp;&amp; !t.Namespace.Contains(name) &amp;&amp; !t.Name.StartsWith("</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;")); //!t.Namespace.Contains(name) - .     ,         // "&lt;'      -     } private static string CorrectTypeName(string name) { foreach (var changedType in _changedTypes) { var ind = name.IndexOf(changedType.FullName); if (ind != -1) { var endIndex = name.IndexOf("PublicKeyToken", ind) ; if (endIndex != -1) { endIndex += +"PublicKeyToken".Length + 1; while (char.IsLetterOrDigit(name[endIndex++])) { } var sb = new StringBuilder(); sb.Append(name.Substring(0, ind)); sb.Append(changedType.AssemblyQualifiedName); sb.Append(name.Substring(endIndex-1)); name = sb.ToString(); } } } return name; } /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> look up the type locally if the assembly-name is "NA" </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="assemblyName"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="typeName"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public override Type BindToType(string assemblyName, string typeName) { typeName = CorrectTypeName(typeName); if (assemblyName.Contains("</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;ObligatoryPartOfNamespace&gt;</span></span></span><span class="hljs-comment">") || assemblyName.Equals("NA")) { var bindToType = Type.GetType(typeName); return bindToType; } else { var bindToType = LoadTypeFromAssembly(assemblyName, typeName); return bindToType; } }</span></span></code> </pre><br>  As you can see, I was repelled by the fact that PublicKeyToken is the last in the type description.  It may not be 100% reliable, but in my tests I have not found cases where it is not. <br><br>  So a string like <br><blockquote>  "System.Collections.Generic.Dictionary`2 [[SomeNamespace.CustomType, Assembley.Application, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null], [System.Byte [], mscorlib, Version = 4.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089]] ¬ª </blockquote><br>  turns into <br><blockquote>  "System.Collections.Generic.Dictionary`2 [[SomeNamespace.CustomType, Assembley.Portal, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null], [System.Byte [], mscorlib, Version = 4.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089]] ¬ª </blockquote><br>  Now everything has finally worked "like a clock."  Small technical details remained: if you remember, we included the files by reference from the main application.  But in the main application all these dances are not needed.  Therefore, the conditional compilation mechanism of the form was applied. <br><br><pre> <code class="cs hljs">BinaryFormatter binForm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryFormatter(); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> EXTERNAL_LIB binForm.Binder = new MyBinder(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Accordingly, in the assembly of the portal we define the EXTERNAL_LIB macro, but in the main application - no <br><blockquote><h4>  "Non-retreat" </h4><br>  In fact, in the process of coding, in order to quickly verify the decision, I made one miscalculation, which cost me, probably, a certain number of nerve cells: for starters, I was just a hardcore type replacement for Dicitionary.  As a result, after deserialization, an empty Dictionary was obtained, which also ‚Äúfell‚Äù when trying to perform some operations with it.  I was already beginning to think that you <i>could not fool BinaryFormatter</i> , I began desperate experiments with trying to write a heir to Dictionary.  Fortunately, I stopped almost at the right time and returned to writing a universal substitution mechanism and, having realized it, I realized that to create a Dictionary, it is not enough to redefine its type: you also need to take care of the types for KeyValuePair &lt;TKey, TValue&gt;, Comparer, which are also requested from Binder <br><br><br>  These are the adventures of binary serials.  I would be grateful for the feedback. </blockquote></div><p>Source: <a href="https://habr.com/ru/post/430646/">https://habr.com/ru/post/430646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430634/index.html">Creating a software module for the programmer XELTEK SuperPro 6100</a></li>
<li><a href="../430636/index.html">Cerebellum and basal nuclei instead of a crystal ball: how the brain predicts the future</a></li>
<li><a href="../430640/index.html">Red Sea: why Apple and other technology companies are falling</a></li>
<li><a href="../430642/index.html">The direction of "Photonics" at the Olympiad "I am a professional", or how to enter the magistracy without exams</a></li>
<li><a href="../430644/index.html">New vulnerability in Facebook leads to leakage of users' personal data.</a></li>
<li><a href="../430648/index.html">The history of Pac-Man</a></li>
<li><a href="../430650/index.html">Sex - seller of classic arcade games. And who is the buyer?</a></li>
<li><a href="../430654/index.html">devleads meetup: we assemble an effective team, optimize development, discuss current issues</a></li>
<li><a href="../430656/index.html">Certified SAFe¬Æ Program</a></li>
<li><a href="../430658/index.html">How it started - the birth of video games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>