<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.NET: Tools for working with multithreading and asynchrony. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I publish on Habr the original article, the translation of which is posted on the Codingsight blog. 

 I continue to create a text version of my speec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.NET: Tools for working with multithreading and asynchrony. Part 2</h1><div class="post__text post__text-html js-mediator-article">  <i>I publish on Habr the original article, the translation of which is posted on the <a href="https://codingsight.com/net-tools-for-working-with-multithreading-and-asynchrony-part-2/">Codingsight</a> blog.</i> <br><br>  I continue to create a text version of my speech on the multi-threading MAP.  The first part can be found <a href="https://codingsight.com/net-tools-for-working-with-multi-threading-and-asynchrony-part-1/">here</a> or <a href="https://habr.com/ru/post/452094/">here</a> , there it was more about the basic set of tools to start a thread or Task, ways to view their status and some sweet little things, like PLinq.  In this article I want to focus more on the problems that may arise in a multi-threaded environment and some ways to solve them. <br><br><h2>  Content </h2><br><ul><li>  <a href="https://habr.com/ru/post/459514/">About shared resources</a> </li><li>  <a href="https://habr.com/ru/post/459514/">Possible problems when working in a multithreaded environment</a> <ul><li>  <a href="https://habr.com/ru/post/459514/">Deadlock</a> </li><li>  <a href="https://habr.com/ru/post/459514/">Race-Condition</a> </li><li>  <a href="https://habr.com/ru/post/459514/">Busy wait</a> </li><li>  <a href="https://habr.com/ru/post/459514/">Thread starvation</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/459514/">Sync Tools</a> <ul><li>  <a href="https://habr.com/ru/post/459514/">Interlocked</a> </li><li>  <a href="https://habr.com/ru/post/459514/">Monitor.Enter, Monitor.Exit, lock</a> </li><li>  <a href="https://habr.com/ru/post/459514/">SpinLock SpinWait</a> </li><li>  <a href="https://habr.com/ru/post/459514/">Monitor.Wait, Monitor.Pulse [All]</a> </li><li>  <a href="https://habr.com/ru/post/459514/">ReaderWriterLockSlim</a> </li><li>  <a href="https://habr.com/ru/post/459514/">ResetEvent Family</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/459514/">findings</a> </li></ul><br><a name="habracut"></a><br><a name="SharedResources"></a><br><h2>  About shared resources </h2><br>  It is impossible to write a program that would work in several streams, but at the same time would not have a single shared resource: since  even if this happens at your level of abstraction, then going down one or more levels below it turns out that there is still a common resource.  I will give a few examples: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Example # 1:</b> <br><br>  Being afraid of possible problems, you forced streams to work with different files.  By file to stream.  It seems to you that the program does not have a single share. <br><br>  Having gone down several levels below, we understand that the hard disk is one, and the problems of providing access to it will have to be solved by its driver or operating system. <br><br>  <b>Example # 2:</b> <br><br>  After reading <i>example #</i> 1, you decided to place the files on two different remote machines with two physically different pieces of hardware and operating systems.  We keep 2 different connections via FTP or NFS. <br><br>  Having gone down several levels below, we understand that nothing has changed, and the problem of competitive access will have to be solved by the driver of the network card or the operating system of the machine running the program. <br><br>  <b>Example # 3:</b> <br><br>  Having lost a considerable part of the hair in an attempt to prove the possibility of writing a multi-threaded program, you refuse files altogether and decompose the calculations into two different objects, the links to each of which are available only to one stream. <br><br>  I kill the final dozen of nails in the coffin of this idea: one runtime environment and a garbage collector, a flow scheduler, physically one operational and memory, one processor are still shared resources. <br><br>  So, we found out that it is impossible to write a multi-threaded program without a single shared resource at all levels of abstraction across the width of the entire technology stack.  Fortunately, each of the levels of abstraction, as a rule, one way or another, partially or completely solves the problems of competitive access or simply prohibits it (for example, any UI framework prohibits working with elements from different streams), because problems often arise with shared resources on your level of abstraction.  To solve them introduce the concept of synchronization. <br><a name="Problems"></a><br><h2>  Possible problems when working in a multithreaded environment </h2><br>  Errors in the software can be divided into several groups: <br><br><ol><li>  The program does not give the result.  Falls or freezes. </li><li>  The program gives an incorrect result. </li><li>  The program gives the correct result, but does not satisfy one or another non-functional requirement.  Working too long or consuming too many resources. </li></ol><br>  In a multithreaded environment, the two main problems causing errors 1 and 2 are <b>deadlock</b> and <b>race condition</b> . <br><a name="Deadlock"></a><br><h3>  Deadlock </h3><br>  Deadlock - mutual lock.  There are many different variations.  The most frequent can be considered the following: <br><br><img src="https://habrastorage.org/webt/fl/ij/aj/flijajjtgsaczutpuk9t1filaig.png"><br><br>  While <b>Thread # 1 was</b> doing something, <b>Thread # 2</b> blocked resource <b>B</b> , a little later <b>Thread # 1</b> blocked resource <b>A</b> and is trying to block resource <b>B</b> , unfortunately this will never happen, because  <b>Thread # 2 will</b> release resource <b>B</b> only after it has blocked resource <b>A.</b> <br><a name="RaceCondition"></a><br><h3>  Race-Condition </h3><br>  Race-Condition - race condition.  The situation in which the behavior and the result of the calculations performed by the program depend on the work of the runtime thread scheduler. <br>  The trouble with this situation lies in the fact that your program may not work only once out of a hundred or even out of a million. <br><br>  The situation is aggravated by the fact that problems can go together, for example: with a certain behavior of the thread scheduler, a deadlock occurs. <br><br>  In addition to these two problems leading to obvious errors in the program, there are also some that may not lead to an incorrect result of the calculations, but more time or computing power will be spent to get it.  Two such problems are <b>Busy Wait</b> and <b>Thread Starvation</b> . <br><a name="BusyWait"></a><br><h3>  Busy wait </h3><br>  Busy-Wait is a problem in which the program consumes processor resources not for computing, but for waiting. <br><br>  Often such a problem in the code looks like this: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!hasSomethingHappened) ;</code> </pre> <br>  This is an example of extremely bad code, since  This code completely occupies one core of your processor without doing anything useful at all.  It can be justified if and only if it is critically important to handle the change in a value in another thread.  And speaking fast, I'm talking about a case where you can't even wait a few nanoseconds.  In other cases, that is, in all that a healthy brain can produce, it is wiser to use ResetEvent varieties and their Slim versions.  About them below. <br><br>  Perhaps some of the readers will offer to solve the problem of fully loading one core with useless waiting to add to a loop a construct like Thread.Sleep (1).  This will really solve the problem, but it will create another one: the response time to the change will be on average half a millisecond, which may not be much, but catastrophically more than the ResetEvent family synchronization primitives could be. <br><a name="ThreadStarvation"></a><br><h3>  Thread starvation </h3><br>  Thread-Starvation is a problem in which there are too many simultaneously running threads in the program.  What does it mean exactly those flows that are busy with calculations, and not just waiting for a response from any IO.  With this problem, all possible performance gains from using threads are lost, since  The processor spends a lot of time switching contexts. <br>  It is convenient to look for such problems with the help of various profilers, below is an example of a screenshot from the <a href="https://www.jetbrains.com/profiler/">dotTrace</a> profiler running in Timeline mode. <br><br> <a href=""><img src="https://habrastorage.org/webt/qy/n9/nk/qyn9nkwglryzuu60cipo8zdi0ra.png"></a> <br>  <i>(The picture is clickable)</i> <br><br>  In the program that does not suffer from stream hunger, pink color on the graphs, there will be no reflective streams.  In addition, in the Subsystems category it can be seen that the program of 30.6% was waiting for the CPU. <br><br>  When such a problem is diagnosed, it is solved quite simply: you run too many threads at one time, run less or not all at once. <br><a name="SyncPrimitives"></a><br><h2>  Sync Tools </h2><br><a name="Interlocked"></a><br><h3>  Interlocked </h3><br>  This is probably the most lightweight way to synchronize.  Interlocked is a set of simple atomic operations.  Atomic is called an operation at the time of which nothing can happen.  In the .NET Interlocked, it is represented by a static class of the same name with a number of methods, each of which implements one atomic operation. <br><br>  To realize the horror of non-atomic operations, try writing a program that launches 10 threads, each of which makes a million increments of the same variable, and at the end of their work output the value of this variable - unfortunately it will be very different from 10 million, moreover each time you start the program, it will be different.  This happens because even such a simple operation as an increment is not atomic, but involves extracting a value from memory, calculating a new one and writing it back.  Thus two threads can simultaneously do each of these operations, in which case the increment will be lost. <br><br>  The Interlocked class provides the Increment / Decrement methods, it is not difficult to guess what they are doing.  It is convenient to use them if you process data in several streams and consider something.  Such code will work much faster than the classic lock.  If for the situation described in the last paragraph to use Interlocked, then the program in any situation will consistently produce a value of 10 million. <br><br>  The CompareExchange method performs, at first glance, a rather unobvious function, but all of its presence allows for the implementation of many interesting algorithms, primarily the lock-free family. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareExchange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> location1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comparand</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  The method takes three values: the first is passed by reference and this is the value that will be changed to the second, if at the time of the comparison location1 coincides with comparand, then the original value of location1 will be returned.  It sounds quite confusing, so it's easier to write code that performs the same operations as CompareExchange: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original = location1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location1 == comparand) location1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original;</code> </pre><br>  Only implementation in the Interlocked class will be atomic.  That is, if we wrote such code ourselves, a situation might occur when the condition location1 == comparand has already been fulfilled, but by the time the expression1 executes the expression1 = value, another thread has changed the value of location1 and it will be lost. <br><br>  A good example of using this method can be found in the code that the compiler generates for any C # event. <br><br>  Let's write a simple class with one MyEvent event: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent; }</code> </pre><br>  <a href="https://www.jetbrains.com/decompiler/">Let's</a> build the project in the Release configuration and open the build with <a href="https://www.jetbrains.com/decompiler/">dotPeek</a> with the Show Compiler Generated Code option enabled: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventHandler MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent, (EventHandler) Delegate.Combine((Delegate) comparand, (Delegate) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>), comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (eventHandler != comparand); } [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The same algorithm but with Delegate.Remove } }</span></span></code> </pre><br>  Here you can see that behind the scenes, the compiler has generated a rather sophisticated algorithm.  This algorithm protects against the event of losing the subscription to an event when several threads subscribe to this event simultaneously.  Let's write down the add method in more detail, remembering what behind the scenes the CompareExchange method does. <br><br><pre> <code class="cs hljs">EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; <span class="hljs-comment"><span class="hljs-comment">// Begin Atomic Operation if (MyEvent == comparand) { eventHandler = MyEvent; MyEvent = Delegate.Combine(MyEvent, value); } // End Atomic Operation } while (eventHandler != comparand);</span></span></code> </pre><br>  So it is a little clearer, although, probably, still needs to be explained.  In words, I would describe this algorithm as follows: <br><br>  <i>If MyEvent is still the same as it was at the moment we started to execute Delegate.Combine, then write into it what the Delegate.Combine will return, and if not, it doesn‚Äôt matter, let's try again and repeat until it comes out.</i> <i><br></i> <br><br>  So no event subscription will be lost.  You will have to solve a similar problem if you suddenly want to implement a dynamic thread-safe lock-free array.  If several threads rush to add elements to it, then it is important that they all be added as a result. <br><a name="Lock"></a><br><h3>  Monitor.Enter, Monitor.Exit, lock </h3><br>  These are the most commonly used constructs for thread synchronization.  Implement the idea of ‚Äã‚Äãa critical section: that is, the code written between calls to Monitor.Enter, Monitor.Exit on one resource can be executed at a time only by one thread.  The lock statement is syntactic sugar around Enter / Exit calls wrapped in try-finally.  A nice feature of the implementation of the critical section in .NET is the ability to re-enter it for the same stream.  This means that such code will run without problems: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(a) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (a) { ... } }</code> </pre><br>  It is unlikely, of course, that someone will write this way, but if you blur this code into several methods in depth call-stack this feature can save you a few if-s.  In order for such a trick to become possible, .NET developers had to add a restriction - only an instance of the reference type could be used as a synchronization object, and implicitly add several bytes to each object to which the stream identifier will be written. <br><br>  This feature of the work of the critical section in c # imposes one interesting limitation on the operation of the lock operator: you cannot use the await operator inside the lock operator.  At first, I was surprised, because the similar try-finally Monitor.Enter / Exit construct is compiled.  What is the matter?  Here it is necessary to carefully reread the last paragraph again, and then add to it some knowledge of how async / await works: the code after await will not necessarily be executed on the same thread as the code before await, it depends on the synchronization context and the presence or no call to ConfigureAwait.  From this it follows that Monitor.Exit may run on a thread other than Monitor.Enter, which will cause a <b>SynchronizationLockException</b> to be thrown.  If you do not believe, then you can execute the following code in the console application: it will generate a SynchronizationLockException. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Monitor.Enter(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Monitor.Exit(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</code> </pre><br>  It is noteworthy that in a WinForms or WPF application, this code will work correctly if called from the main thread. Because  there will be a synchronization context that implements the return to the UI-Thread after await has completed.  In any case, you should not play with the critical section in the context of the code containing the await operator.  In these cases, it is better to use synchronization primitives, which will be discussed later. <br><br>  Talking about the work of the critical section in .NET, it is worth mentioning about another feature of its implementation.  The critical section in .NET works in two modes: spin-wait mode and kernel mode.  The spin-wait algorithm is conveniently represented as the following pseudocode: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!TryEnter(syncObject)) ;</code> </pre><br>  This optimization is aimed at the fastest capture of the critical section in a short time from the calculation that if the resource is now occupied, then it is about to be released.  If this does not happen in a short period of time, the thread waits in kernel mode, which, like returning from it, takes time.  The .NET developers maximally optimized the scenario of short locks, unfortunately, if many threads start to break the critical section between themselves, this can lead to a high and sudden CPU load. <br><a name="SpinLock"></a><br><h3>  Spinlock SpinWait </h3><br>  Since I already mentioned the spin-wait algorithm, it is worth mentioning the SpinLock and SpinWait structures from the BCL.  They should be used if there is reason to believe that there will always be an opportunity to take the lock very quickly.  On the other hand, it is hardly worth remembering about them before the results of the profiling show that it is the use of other synchronization primitives that is the bottleneck of your program. <br><a name="Pulse"></a><br><h3>  Monitor.Wait, Monitor.Pulse [All] </h3><br>  This pair of methods should be considered together.  With their help, you can implement various Producer-Consumer scripts. <br><br>  <i>Producer-Consumer is a multiprocess / multi-threaded design pattern with one or several threads / processes producing data and one or several processes / threads that process data.</i>  <i>Usually uses a shared collection.</i> <br><br>  Both of these methods can only be called if the caller currently has a blocking thread.  The Wait method releases the lock and hangs until another thread calls Pulse. <br><br>  To demonstrate the work, I wrote a small example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/0-/7k/uy/0-7kuyx2b8evi2iwzmt-6-capv0.png"><br>  <i>(I used the image, not the text, to visually show the order of instructions execution)</i> <br><br>  <u>Parsing:</u> Set a delay of 100ms at the start of the second thread, specifically to ensure that it starts later. <br>  - T1: Line # 2 stream starts <br>  - T1: Line # 3 stream enters critical section <br>  - T1: Line # 6 stream falls asleep <br>  - T2: Line # 3 stream starts <br>  - T2: Line # 4 hangs waiting for the critical section <br>  - T1: Line # 7 releases the critical section and freezes while waiting for Pulse to exit. <br>  - T2: Line # 8 enters critical section <br>  - T2: Line # 11 notifies T1 using the Pulse method <br>  - T2: Line # 14 exits the critical section.  Until then, T1 cannot continue execution. <br>  - T1: Line # 15 quits waiting <br>  - T1: Line # 16 exits critical section <br><br>  <i>There is an important remark in <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.monitor.pulse%3Fview%3Dnetcore-2.2">MSDN</a> regarding the use of the Pulse / Wait methods, namely: The Monitor does not store state information, which means that calling the Pulse method before calling the Wait method can lead to a deadlock.</i>  <i>If such a situation is possible, then it is better to use one of the classes of the ResetEvent family.</i> <br><br>  The last example clearly demonstrates the principle of the Wait / Pulse methods of the Monitor class, but still leaves questions about when it should be used.  A good example would be such an implementation of BlockingQueue &lt;T&gt;, on the other hand, the implementation of BlockingCollection &lt;T&gt; from System.Collections.Concurrent uses SemaphoreSlim for synchronization. <br><a name="ReaderWriterLockSlim"></a><br><h3>  ReaderWriterLockSlim </h3><br>  This is a favorite of me synchronization primitive, represented by the same name class of the namespace System.Threading.  It seems to me that many programs would work better, use their developers in this particular class, instead of the usual lock. <br><br>  <i>The idea: many threads can read, only one to write.</i>  <i>As soon as the stream declares the desire to write, new readings cannot be started, but will wait for the completion of the recording.</i>  <i>There is also the concept of upgradeable-read-lock, which can be used if in the process of reading you understand the need to write something, such a lock will be converted to write-lock in one atomic operation.</i> <br><br>  <i>The System.Threading namespace also has the ReadWriteLock class, but it is not highly recommended for new development.</i>  <i>The slim version will avoid a number of cases leading to deadlocks, besides it allows you to quickly seize the lock, because</i>  <i>supports spin-wait synchronization before leaving in kernel mode.</i> <br><br>  If you didn‚Äôt know about this class by the time you read this article, then I think now you have remembered quite a few examples from the code written recently that this approach to locks would allow the program to work efficiently. <br><br>  The interface of the ReaderWriterLockSlim class is simple and straightforward, but its use can hardly be called convenient: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } finally { @lock.ExitReadLock(); }</span></span></code> </pre><br>  I like to wrap it up in class, which makes it much more convenient to use it. <br>  The idea: to make Read / WriteLock methods that return an object with the Dispose method, then it will allow to use them in using and by the number of lines it is unlikely to be different from the usual lock. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RWLock</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WriteLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterWriteLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitWriteLock(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ReadLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitReadLock(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ReadLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> WriteLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WriteLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.Dispose(); }</code> </pre><br>  Such a trick will allow you to simply write further: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rwLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RWLock(); <span class="hljs-comment"><span class="hljs-comment">// ... using(rwLock.ReadLock()) { // ... }</span></span></code> </pre><br><a name="ResetEvent"></a><br><h3>  ResetEvent Family </h3><br>  To this family, I assign the classes ManualResetEvent, ManualResetEventSlim, AutoResetEvent. <br>  The classes ManualResetEvent, its Slim version and class AutoResetEvent can be in two states: <br>  - Non-signaled, in this state, all threads that caused WaitOne hang up, until the event transitions to a signaled state. <br>  - Signaled state, in this state, all threads that hang on the WaitOne call are released.  All new WaitOne calls on the event in the deflated state pass conditionally instantly. <br><br>  The AutoResetEvent class from the ManualResetEvent class is distinguished by the fact that it automatically goes into a cocked state after releasing exactly one stream.  If several threads hang pending AutoResetEvent, then the Set call will release only one arbitrary, unlike ManualResetEvent.  ManualResetEvent will release all threads. <br><br>  Consider the example of how AutoResetEvent works: <br><pre> <code class="cs hljs">AutoResetEvent evt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/ku/us/k2/kuusk2oupkj4_gftf8fixy_51pu.png"><br><br>  In the example, you can see that the event goes into a cocked state (non-signaled) automatically only by releasing the thread that hung on the WaitOne call. <br><br>  The class ManualResetEvent, unlike ReaderWriterLock, is not marked as obsolete and not recommended for use after the appearance of its Slim version.  The slim version of this class is effectively used for short expectations, since  It occurs in the Spin-Wait mode, the normal version is suitable for long. <br><br>  In addition to the classes ManualResetEvent and AutoResetEvent, there is also a class CountdownEvent.  This class is convenient for the implementation of algorithms, where, after the part that was managed to be parallelized, follows a part of bringing the results together.  This approach is known as <a href="https://en.wikipedia.org/wiki/Fork%25E2%2580%2593join_model">fork-join</a> .  A great <a href="http://dotnetpattern.com/threading-countdownevent">article is</a> devoted to the work of this class, so I will not analyze it in detail here. <br><a name="Conclusions"></a><br><h2>  findings </h2><br><ul><li>  When working with threads, two problems that lead to incorrect results or their absence are race condition and deadlock </li><li>  Problems that make the program spend more time or resources - thread starvation and busy wait </li><li>  .NET is rich in thread synchronization tools </li><li>  There are 2 lock wait modes - Spin Wait, Core Wait.  Some .NET thread synchronization primitives use both </li><li>  Interlocked is a set of atomic operations, used in lock-free algorithms, is the fastest synchronization primitive </li><li>  The lock operator and Monitor.Enter / Exit implement the idea of ‚Äã‚Äãa critical section - a code fragment that can be executed only by one thread at a time </li><li>  Monitor.Pulse / Wait methods are convenient for implementing Producer-Consumer scripts </li><li>  ReaderWriterLockSlim can be more effective than regular lock in scripts where parallel reading is permissible </li><li>  The family of classes ResetEvent can be useful for synchronizing threads </li></ul></div><p>Source: <a href="https://habr.com/ru/post/459514/">https://habr.com/ru/post/459514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459500/index.html">HTML is the web</a></li>
<li><a href="../459502/index.html">We continue to develop an adventure platform for Russians: interface features and summer preferences</a></li>
<li><a href="../459504/index.html">Young Game Designer Course: How to count the balance of characters and equipment without mathematics</a></li>
<li><a href="../459506/index.html">The Adventures of the Elusive Malvar, Part III: Intricate VBA Scripts for Laughter and Gain</a></li>
<li><a href="../459508/index.html">5 slides that are ignored by experienced presenters</a></li>
<li><a href="../459518/index.html">Explanation of a Python task with a job interview</a></li>
<li><a href="../45952/index.html">Online Counseling Systems Review</a></li>
<li><a href="../459520/index.html">Model of the natural series of numbers and its elements. Diamonds</a></li>
<li><a href="../459528/index.html">How we teach the French ecology and collect bottles</a></li>
<li><a href="../45953/index.html">Nikon introduces new flagship: D3X</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>