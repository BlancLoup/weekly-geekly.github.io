<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Productive PHP network server</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Have you tried to order a piglet with house wine roasted on a gun shambole at McDonalds and, for dessert, a girl next to you at a table for a pleasant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Productive PHP network server</h1><div class="post__text post__text-html js-mediator-article">  Have you tried to order a piglet with house wine roasted on a gun shambole at McDonalds and, for dessert, a girl next to you at a table for a pleasant conversation during the meal?  Did not even think about it ??  Just about - the article is about this, about the stereotypes of the programmer and the laziness driving progress.  But seriously - in the article we will write a very useful high-performance PHP network server for many people in a couple of hours.  I am absolutely serious <s>:-)</s> <br><img src="https://habrastorage.org/getpro/habr/post_images/cbb/70e/553/cbb70e5535838d7908d13eafc48db779.jpg"><br><a name="habracut"></a><br><h4>  In the good old days ... </h4><br>  In the good old days, when people were closer to nature, fresh beer pleased us with a pleasant bitterness and women smelled exquisitely - the programmers were closer to the hardware and wrote in C and, in moments of inspiration, in assembler.  But probably the most important thing is that programmers understood what tcp is, how it differs from udp, and how to effectively interact with the operating system kernel via the system call interface. <br><img src="https://habrastorage.org/getpro/habr/post_images/4f8/399/9fa/4f83999fa1c556fd57dde1bac21b00b0.jpg"><br><h4>  Laziness comes ... </h4><br>  But laziness was taking its own course and an approach to development was gradually formed - close to the ideology of the fictional abstract world from the <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25BB%25D0%25B0%25D1%2581%25D1%2582%25D0%25B5%25D0%25BB%25D0%25B8%25D0%25BD_%25D0%25BA%25D0%25BE%25D0%25BB%25D0%25B5%25D1%2586">Lord of the Rings</a> . <br><img src="https://habrastorage.org/getpro/habr/post_images/1f2/662/9ac/1f26629accd0083ef22159a082de27ef.jpg"><br>  People began to create objects in the programs of the fictional world, philosophical concepts, exchanging messages and increasingly began to break away from reality and nature.  And if in C ++ they tried to linger alone with nature through pointers and controlled work with memory, in Java and C # laziness took its toll and the programmers found themselves in an ideal, but far from efficient, universe of rubber women and non-alcoholic beer.  Philosophy lost in creating a universal API for working with all kinds of file systems or mandatory exception handling (Java). <br><img src="https://habrastorage.org/getpro/habr/post_images/a8d/231/d5d/a8d231d5d302ddb44cdfac20e8d90349.jpg"><br>  And now even on the sides it became scary to watch: developers generally ‚Äúspilled themselves‚Äù to such an extent that they do not use compilers :-) Many systems are created in weakly typed scripting languages ‚Äã‚Äãlike Python / PHP - which not only support OOP well, but are so powerful that allow one function to effectively load a file into a variable :-) <br><br><h4>  Processors and threads </h4><br>  Many people firmly believed in the hardware support for OOP at the processor level in the 90s, this never happened.  But laziness continues to influence and makes now piously believe in the effective implementation of programming language flows - taking into account the fashion on the reproduction of processor cores.  Those.  I don‚Äôt want to strain and just write ‚Äúnew thread‚Äù and everything will work efficiently and quickly. <br><img src="https://habrastorage.org/getpro/habr/post_images/180/a47/a5c/180a47a5cc492147e5fd033d7565f30d.jpg"><br><h4>  In the meantime ... </h4><br>  Meanwhile, the world is captured by effective solutions in C in the style of <a href="http://ru.wikipedia.org/wiki/Nginx">nginx</a> , <s><a href="http://ru.wikipedia.org/wiki/MongoDB">productive</a> NoSQL solutions are created ‚Äúclose to hardware‚Äù <a href="http://ru.wikipedia.org/wiki/MongoDB">,</a></s> and when it comes to speed and performance, the brain, obsessed with laziness and advertising, begins to move and feel something is not right!  ‚ÄúThey lie‚Äù about threads - they do not work effectively enough, even on multi-core glands.  Although theoretically they should! <br><br><h4>  Lost origins ... </h4><br>  Ask the developer now about the difference between <a href="http://linux.die.net/man/2/close">close</a> and <a href="http://linux.die.net/man/2/shutdown">shutdown</a> or about the differences in the process from the flow ... and more and more often you see what it means to ‚Äúexpressively bite your nails‚Äù :-) But to write a useful server, you need to understand well how the operating system works There are network protocols, how the nature of things is arranged in general and what a real beer is!  :-) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  It's not a programming language </h4><br>  And no matter, believe in what programming language you are going to make a useful network server.  It is important how deeply you understand what you are going to do and what immunity you have against advertising and your own technological laziness. <br><br><h4>  Compound processing </h4><br>  People <a href="http://linux.die.net/man/2/select">knew</a> how to efficiently handle network sockets when they were closer to nature.  Of course, the core of the operating system should deal with this and notify you when an event occurs: <br>  1) A new socket came in a listening connection ( <a href="http://linux.die.net/man/2/listen">listen</a> ) - and it can be taken into processing ( <a href="http://linux.die.net/man/2/accept">accept</a> ) <br>  2) You can read from the socket without blocking the process ( <a href="http://linux.die.net/man/2/write">read</a> ). <br>  3) You can write to the socket without blocking the process ( <a href="http://linux.die.net/man/2/write">write</a> ). <br><img src="https://habrastorage.org/getpro/habr/post_images/27f/0dc/7b4/27f0dc7b4e014912e04bc545c5508014.jpg"><br>  In the world of physical laws, other methods of processing connections, such as creating a bunch of threads or, excuse me, <a href="httpd.apache.org/">but sometimes they do this</a> because of laziness and perfectionism, processes - they work slower and ‚Äúeat‚Äù much more memory.  And although often ‚Äúexcuses‚Äù of the type: ‚Äúit is cheaper to buy one more piece of hardware than to teach a programmer to asynchronous processing of demultiplexed sockets‚Äù - they work, sometimes you find yourself in a situation where you need to solve the problem effectively on current equipment - reducing costs by 1-2 orders of magnitude. <br>  According to this principle, the well-known nginx works, processing tens of thousands of connections by several processes of the operating system. <br><br>  For me, it still remains a mystery why, despite the appearance in the same java about 10 years ago, <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/package-summary.html">libraries for solving server problems</a> "in the nginx style" - it has not received proper distribution and applications continue to "figure out" on streams, despite all the deadlock and waste of this approach!  :-) <br><img src="https://habrastorage.org/getpro/habr/post_images/f17/28f/a9c/f1728fa9c5393976e6c19fcadfa16505.jpg"><br><h4>  Why doesn't everyone do that? </h4><br>  Just laziness :-) Although it is also considered that asynchronous processing of demultiplexed sockets is much more difficult from a programming point of view than 50 lines in a separate process.  But below I will show how to write a similar server, even on a sharpened bit for other PHP tasks, to write a similar server - quite simply. <br><br><h4>  Php and sockets </h4><br>  In PHP, there is <a href="http://www.php.net/manual/en/intro.sockets.php">support for</a> "native expensive" BSD sockets.  But this extension, unfortunately, does not support ssl / tls. <br>  Therefore, it is necessary to climb into the streaming interface, streams, filled with abstractions, ‚Äúgoblins and necromorphs‚Äù, a bit alienated from nature and a healthy lifestyle.  If you take a shovel and discard a bunch of husks, behind this interface you can see network sockets and work quite effectively with them. <br><img src="https://habrastorage.org/getpro/habr/post_images/91d/b7a/bad/91db7abad5ab05ff8b7be37ed6428cd8.jpg"><br><h4>  Bits of code </h4><br>  I will not give the entire source code of the network server, but walk through the key parts of the code.  In general, the server steadily keeps without recompiling PHP up to 1024 open sockets in one process, taking about 18-20MB (this is dofiga by C standards, but believe me, there are PHP scripts that eat gigabytes) and straining only one processor core (yes, syscpu is noticeably larger, but without it).  If you rebuild PHP, then select can work with a much larger number of sockets. <br><br><h5>  Server core </h5><br>  Server core tasks: <br>  1) Check the array of tasks <br>  2) For each task create a connection <br>  3) Check that the socket in the task can be read or written without blocking the process <br>  4) Release the resources (socket, etc.) of the task <br>  5) Accept the connection from the control socket to add the task - without blocking the process <br><br>  In simple words, we fill in the core of the job server with sockets (for example, go around sites and collect data, etc.) and the core IN ONE PROCESS starts to walk hundreds of tasks at the same time. <br><br><h5>  The task </h5><br>  The task is an object in the OOP terminology of the <a href="http://en.wikipedia.org/wiki/Finite-state_machine">FSM</a> type.  There is a <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D1%2580%25D0%25B0%25D1%2582%25D0%25B5%25D0%25B3%25D0%25B8%25D1%258F_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">strategy</a> inside the object - let's say: ‚Äúgo to this address, create a request, download the answer, parse, etc.  returns to the beginning and at the end write the result in NoSQL. ‚Äù  Those.  You can create a task from simple loading of content to a complex chain of load testing with numerous branches - and this is all, I recall, living in the object of the task. <br>  Tasks in this implementation are put through a separate control socket on port 8000 - json-objects are written to the tcp-socket and then begin their movement in the server core. <br><br><h5>  The principle of processing jobs and sockets </h5><br>  The main thing is not to allow the server process to block while waiting for a response in a function when reading or writing information to a network socket, while waiting for a new connection to a control socket or somewhere in complex calculations / cycles.  Therefore, all job sockets are checked in the select system call and the OS kernel notifies us only when an event occurs (or by timeout). <br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { $ar_read = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; $ar_write = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; $ar_ex = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     $ar_read[] = $this-&gt;controlSocket; foreach ($this-&gt;jobs as $job) { //job cleanup if ( $job-&gt;isFinished() ) { $key = array_search($job, $this-&gt;jobs); if (is_resource($job-&gt;getSocket())) { //""   stream_socket_shutdown($job-&gt;getSocket(),STREAM_SHUT_RDWR); fclose($job-&gt;getSocket()); } unset($this-&gt;jobs[$key]); $this-&gt;jobsFinished++; continue; } //  ""   ,      if ($job-&gt;isSleeping()) continue; //    if ($job-&gt;getStatus()=='DO_REQUEST') { $socket = $this-&gt;createJobSocket($job); if ($socket) { $ar_write[] = $socket; } //      } else if ($job-&gt;getStatus()=='READ_ANSWER') { $socket = $job-&gt;getSocket(); if ($socket) { $ar_read[] = $socket; } //      } else if ( $job-&gt;getStatus()=='WRITE_REQUEST' ) { $socket = $job-&gt;getSocket(); if ($socket) { $ar_write[] = $socket; } } } //              30  $num = stream_select($ar_read, $ar_write, $ar_ex, 30);</span></span></code> </pre> <br>  Further, when the event occurred and the OS notified us, we start processing sockets in non-blocking mode.  Yes, it is possible to optimize a little more work around the array of tasks, index tasks by the socket number and win 10ms - but for now ... just guessed, laziness :-) <br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_array($ar_write)) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($ar_write <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $write_ready_socket) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getJobs() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $job) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($write_ready_socket == $job-&gt;getSocket()) { $dataToWrite = $job-&gt;readyDataWriteEvent(); $count = fwrite($write_ready_socket , $dataToWrite, <span class="hljs-number"><span class="hljs-number">1024</span></span>); <span class="hljs-comment"><span class="hljs-comment">//        $job-&gt;dataWrittenEvent($count); } } } } if (is_array($ar_read)) { foreach ($ar_read as $read_ready_socket) { ///// command processing /// //    ,   if ($read_ready_socket == $this-&gt;controlSocket) { $csocket = stream_socket_accept($this-&gt;controlSocket); //  -   ,    .   . if ($csocket) { $req = ''; while ( ($data = fread($csocket,10000)) !== '' ) { $req .= $data; } //      $this-&gt;processCommand(trim($req), $csocket); stream_socket_shutdown($csocket, STREAM_SHUT_RDWR); fclose($csocket); } continue; /// ///// } else { //        $data = fread($read_ready_socket , 10000); foreach ($this-&gt;getJobs() as $job) { if ($read_ready_socket == $job-&gt;getSocket()) { //   .   ,   . $job-&gt;readyDataReadEvent($data); } } } } } }</span></span></code> </pre><br>  The socket itself is also initiated in non-blocking mode, it is important to set the flags, both of them!  STREAM_CLIENT_ASYNC_CONNECT | STREAM_CLIENT_CONNECT: <br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createJobSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BxRequestJob $job)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//Check job protocol if ($job-&gt;getSsl()) { //https $ctx = stream_context_create( array('ssl' =&gt; array( 'verify_peer' =&gt; false, 'allow_self_signed' =&gt; true ) ) ); $errno = 0; $errorString = ''; //      30-60,  -  TCP-   ,    ,   ...  $socket = stream_socket_client('ssl://'.$job-&gt;getConnectServer().':443',$errno,$errorString,30,STREAM_CLIENT_ASYNC_CONNECT|STREAM_CLIENT_CONNECT,$ctx); if ($socket === false) { $this-&gt;log(__METHOD__." connect error: ". $job-&gt;getConnectServer()." ". $job-&gt;getSsl() ."$errno $errorString"); $job-&gt;connectedSocketEvent(false); $this-&gt;connectsFailed++; return false; } else { $job-&gt;connectedSocketEvent($socket); $this-&gt;connectsCreated++; return $socket; } } else { //http ...</span></span></code> </pre><br>  Well, let's look at the code of the task itself - it should be able to work with partial answers / requests.  To begin, let the server core tell us what we want to write to the socket. <br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    function readyDataWriteEvent() { if (!$this-&gt;dataToWrite) { if ($this-&gt;getParams()) { $str = http_build_query($this-&gt;getParams()); $headers = $this-&gt;getRequestMethod()." ".$this-&gt;getUri()." HTTP/1.0\r\nHost: ".$this-&gt;getConnectServer()."\r\n". "Content-type: application/x-www-form-urlencoded\r\n". "Content-Length:".strlen($str)."\r\n\r\n"; $this-&gt;dataToWrite = $headers; $this-&gt;dataToWrite .= $str; } else { $headers = $this-&gt;getRequestMethod()." ".$this-&gt;getUri()." HTTP/1.0\r\nHost: ".$this-&gt;getConnectServer()."\r\n\r\n"; $this-&gt;dataToWrite = $headers; } return $this-&gt;dataToWrite; } else { return $this-&gt;dataToWrite; } }</span></span></code> </pre><br>  Now we write the query, determining how much is left. <br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//      ,      function dataWrittenEvent($count) { if ($count === false ) { //socket was reset $this-&gt;jobFinished = true; } else { $dataTotalSize = strlen($this-&gt;dataToWrite); if ($count&lt;$dataTotalSize) { $this-&gt;dataToWrite = substr($this-&gt;dataToWrite,$count); $this-&gt;setStatus('WRITE_REQUEST'); } else { //     ,      $this-&gt;setStatus('READ_ANSWER'); } } }</span></span></code> </pre><br>  After receiving the request, we read the answer.  It is important to understand when the answer is read in full.  You may need to set a timeout for reading - I did not need it. <br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,           function readyDataReadEvent($data) { ////////// Successfull data read ///// if ($data) { $this-&gt;body .= $data; $this-&gt;setStatus('READ_ANSWER'); $this-&gt;bytesRead += strlen($data); ///// ////////// } else { //////////           ///// ////////// redirect if ( preg_match("|\r\nlocation:(.*)\r\n|i",$this-&gt;body, $ar_matches) ) { $url = parse_url(trim($ar_matches[1])); $this-&gt;setStatus('DO_REQUEST'); } else if (...) { //    ,     $this-&gt;jobFinished = true; ... } else if (...) { $this-&gt;setSleepTo(time()+$this-&gt;sleepInterval); $this-&gt;sleepInterval *=2; $this-&gt;retryCount--; $this-&gt;setStatus('DO_REQUEST'); } $this-&gt;body = ''; ...</span></span></code> </pre><br>  In the last snippet, we can hierarchically direct the FSM according to the embedded strategy, implementing various job options for the job. <br>  At the time of writing the class, the feeling did not leave the impression that you are writing a plugin for nginx ;-) <br><br><h4>  Result </h4><br>  You can see how easy and succinctly we managed to solve the problem of simultaneous work with hundreds and thousands of tasks and sockets in just one PHP process.  Imagine if we raise for this server how many PHP processes, how many cores on the server - yes, these are thousands of clients served.  And there is no garden with threads and inefficient switching of the processor context and increased memory requirements.  The PHP server process consumes only about 20MB of memory, and works like a horse :-) <br><img src="https://habrastorage.org/getpro/habr/post_images/63b/acf/d86/63bacfd86c296d9f7996dffec382fcd4.jpg"><br><h4>  Results </h4><br>  Understanding the benefits that the kernel of the operating system can bring us to efficiently handle network sockets - we adjusted to it and implemented a high-performance PHP server - servicing hundreds of open network sockets in one process.  If necessary, you can recompile PHP and process thousands of sockets in one process. <br>  Expand the range of knowledge, do not be lazy under the yoke of stereotypes - using even scripting weakly typed languages ‚Äã‚Äãyou can make productive servers - the main thing is to know how and not to be afraid to experiment :-) Good luck to all! </div><p>Source: <a href="https://habr.com/ru/post/198540/">https://habr.com/ru/post/198540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198526/index.html">GeeXboX is fully ported to Raspberry Pi</a></li>
<li><a href="../198530/index.html">Moscow City Court began to satisfy the first claims of anti-piracy copyright holders</a></li>
<li><a href="../198532/index.html">Fukami, part 1: turnips with tentacles</a></li>
<li><a href="../198534/index.html">Hadoop Part 1: Deploying a Cluster</a></li>
<li><a href="../198536/index.html">How I chose SED - what vendors are silent about</a></li>
<li><a href="../198542/index.html">Developer meeting with students of MIPT or "How to assemble Badoo on the knee"</a></li>
<li><a href="../198544/index.html">PHP RUtils - a small library for processing Russian text</a></li>
<li><a href="../198548/index.html">Google protects sites from DDoS attacks and helps circumvent censorship</a></li>
<li><a href="../198550/index.html">IBM Zurich told how electronic blood works</a></li>
<li><a href="../198556/index.html">Speech recognition from Yandex. Under the hood of Yandex.SpeechKit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>