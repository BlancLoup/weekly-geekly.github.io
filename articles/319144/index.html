<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>learnopengl. Lesson 1.7 - Transformations</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Now we know how to create objects, paint them and apply textures to them, but they are still pretty boring because they are static objects. We can try...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>learnopengl. Lesson 1.7 - Transformations</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" align="left" width="300">  Now we know how to create objects, paint them and apply textures to them, but they are still pretty boring because they are static objects.  We can try to make them move by changing the coordinates of the vertices for each frame, but this is rather dreary and requires processor calculations.  There is a much more convenient way to perform transformations on an object - this is the use of matrices.  But this does not mean that we will now talk about kung fu and the artificial digital world. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text"><p>  Part 1. Start <br><br></p><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br><p>  Part 2. Basic lighting <br><br></p><br><ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Texture Cards</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple light sources</a> </li></ol><br><p>  Part 3. Loading 3D Models 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </p><br><ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp library</a> </li><li>  <a href="https://habrahabr.ru/post/338436/">Mesh mesh class</a> </li><li>  <a href="https://habrahabr.ru/post/338998/">3D model class</a> </li></ol><br><p>  Part 4. OpenGL advanced features <br><br></p><br><ol><li>  <a href="https://habrahabr.ru/post/342610/">Depth test</a> </li><li>  <a href="https://habrahabr.ru/post/344238/">Stencil test</a> </li><li>  <a href="https://habrahabr.ru/post/343096/">Mixing colors</a> </li><li>  <a href="https://habrahabr.ru/post/346964/">Face clipping</a> </li><li>  <a href="https://habrahabr.ru/post/347354/">Frame buffer</a> </li><li>  <a href="https://habrahabr.ru/post/347750/">Cubic cards</a> </li><li>  <a href="https://habrahabr.ru/post/350008/">Advanced data handling</a> </li><li>  <a href="https://habrahabr.ru/post/350156/">Advanced GLSL</a> </li><li>  <a href="https://habrahabr.ru/post/350782/">Geometric shader</a> </li><li>  <a href="https://habrahabr.ru/post/352962/">Instancing</a> </li><li>  <a href="https://habrahabr.ru/post/351706/">Smoothing</a> </li></ol><br><p>  Part 5. Advanced Lighting <br><br></p><br><ol><li>  <a href="https://habrahabr.ru/post/353054/">Advanced lighting.</a>  <a href="https://habrahabr.ru/post/353054/">Model Blinna-Phong.</a> </li><li>  <a href="https://habrahabr.ru/post/353632/">Gamma Correction</a> </li><li>  <a href="https://habrahabr.ru/post/353956/">Shadow maps</a> </li><li>  <a href="https://habr.com/post/354208/">Omnidirectional shadow maps</a> </li></ol></div></div><br><p>  Matrices are very powerful mathematical constructions that are scary at first, but once you get used to them, they will immediately become extremely useful.  During the discussion of matrices, you also need to delve a little into mathematics.  Also, for more mathematically inclined readers, I‚Äôll post links to additional resources on this topic. </p><br><p>  Anyway, to fully understand the transformations, we must first deal with vectors.  The main task of this chapter is to give you the basic mathematical knowledge that we will need later. </p><br><h2 id="vektora">  Vectors </h2><br><p>  In the simplest definition, vectors are nothing more than directions.  A vector may have a <strong>direction</strong> and a <strong>magnitude</strong> (also sometimes called a modulus or length).  You can think of vectors as directions on a treasure map: ‚ÄúTake 10 steps to the left, now 3 steps to the north and now 5 steps to the right.‚Äù  In this example, ‚Äúto the left‚Äù is the direction, and ‚Äú10 steps‚Äù is the length of the vector.  The directions on this treasure map are made up of 3 vectors.  Vectors can be of any dimension, but two-component and four-component vectors are most often used.  If a vector is two-component, then it describes the direction on a plane (or on a 2D graph), if the vector is three-component, then it describes a direction in a three-dimensional world. </p><br><p>  Below you can see 3 vectors, each of which is represented as <strong>(x, y)</strong> as arrows on a 2D graph.  Since it is more intuitive to represent vectors in 2D (than in 3D), then you can think of 2D vectors as 3D vectors, but with a zero z coordinate.  As long as the vector describes the direction, the position of the vector does not change its value.  On the graph you can see that the vectors <strong>v</strong> and <strong>w are the</strong> same, although the positions differ: </p><br><p><img src="https://habrastorage.org/files/fc2/7d1/5f8/fc27d15f81174d15916b453410eb9582.png" alt="Schedule"></p><br><p>  When mathematicians describe vectors, they prefer to use lower case letters with a small dash on top.  Example: </p><br><p><img src="https://habrastorage.org/files/ead/689/f5e/ead689f5e38d4eafa72dff7d5a39c7e0.png" alt="Formula"></p><br><p>  Since vectors often describe a direction, sometimes they are hard to imagine as a position.  Usually we visualize the vector as follows: we set the center to <strong>(0, 0, 0)</strong> , and then indicate the direction described by the point.  Thus, a <strong>positional vector is</strong> obtained (we can also take another point as the center, and then say ‚ÄúThis vector points to a point in space from this point‚Äù).  The positional vector <strong>(3, 5)</strong> will point to the point <strong>(3, 5)</strong> on the graph with the base <strong>(0, 0)</strong> .  With the help of vectors, we can describe both directions and positions in two-dimensional and three-dimensional spaces. </p><br><p>  We can also perform some mathematical operations on vectors. </p><br><h3 id="skalyarnye-vektornye-operacii">  Scalar vector operations </h3><br><p>  A scalar is a single number (or a one-component vector if you want to continue working with vectors).  When adding / subtracting / multiplying or dividing a vector by a scalar, we simply add / subtract / multiply or divide each element of the vector by this scalar.  Example: </p><br><p><img src="https://habrastorage.org/files/cca/ec6/e9d/ccaec6e9db40474eae499f792369cdbe.png" alt="Formula"></p><br><p>  Where instead of addition there can be subtraction, multiplication or division. </p><br><h3 id="obratnyy-vektor">  Reverse vector </h3><br><p>  The inversion (negation) of a vector is the receipt of a vector whose direction is opposite to the original one.  The reverse vector for the vector pointing to the northeast will be the vector pointing to the southwest.  To reverse the vector, we simply multiply the vector by -1.  Example: </p><br><p><img src="https://habrastorage.org/files/2f8/6ae/e43/2f86aee4331046b396f63b0e27d02338.png" alt="Formula"></p><br><h3 id="slozhenie-i-vychitanie">  Addition and subtraction </h3><br><p>  The addition of two vectors is done <strong>componentwise</strong> .  Example: </p><br><p><img src="https://habrastorage.org/files/406/f3b/4b6/406f3b4b640e489cab8e1aca60015ba4.png" alt="Formula"></p><br><p>  Visually, the sum of the vectors <strong>v = (4,2)</strong> and <strong>k = (1,2)</strong> looks like this: </p><br><p><img src="https://habrastorage.org/files/8d1/d38/519/8d1d3851982542eba1f3fc7f9e77e86d.png" alt="Schedule"></p><br><p>  As with ordinary addition and subtraction, the subtraction of vectors is also an addition, but with the inverse second vector: </p><br><p><img src="https://habrastorage.org/files/02f/ee2/703/02fee27030124fb68c90ffa3825bc383.png" alt="Formula"></p><br><p>  Subtracting vectors from each other generates a vector, which is the difference in the positions of the operands: </p><br><p><img src="https://habrastorage.org/files/cb9/d25/0fa/cb9d250fac344a78972079869fd07898.png" alt="Schedule"></p><br><h3 id="dlina">  Length </h3><br><p>  To obtain the length (modulus) of a vector, we use the <strong>Pythagorean theorem</strong> , which you may remember from school.  A vector forms a triangle if you present its components as the sides of a triangle: </p><br><p><img src="https://habrastorage.org/files/d1e/e3e/236/d1ee3e2362d24a91a086c60ea156f7e3.png" alt="Schedule"></p><br><p>  Since the length of the sides <strong>(x, y) is</strong> known, and we want to know the length of the hypotenuse, then we do it as follows: </p><br><p><img src="https://habrastorage.org/files/7ab/9e6/8cb/7ab9e68cbd1e4459bad6bb0e116437a6.png" alt="Formula"></p><br><p>  Where || v ||  Is the length of the vector <strong>v</strong> .  Such a formula is easily expanded in 3D by adding <strong>z ^ 2</strong> .  Length calculation example: </p><br><p><img src="https://habrastorage.org/files/6e1/323/51d/6e132351d43045b9ad059d4cd7950eeb.png" alt="Formula"></p><br><p>  Calculated value: 4.47 </p><br><p>  There is also a special kind of vectors called <strong>unit vectors</strong> .  A feature of such vectors is that their length is always equal to 1. We can convert any vector into a unit by dividing this vector by its length: </p><br><p><img src="https://habrastorage.org/files/deb/66d/c06/deb66dc06d7f43b283235f6548ecb880.png" alt="Formula"></p><br><p>  Such a vector is called <strong>normalized</strong> .  Unit vectors are denoted with a small roof above the letter.  It is also easier to work with them, since we only have to take care of the direction of such a vector. </p><br><h2 id="umnozhenie-vektora-na-vektor">  Vector multiplication by vector </h2><br><p>  The multiplication of two vectors is rather strange.  Normal multiplication is not applicable because it has no visual meaning, but we have 2 specific approaches from which to choose during multiplication: the first is a scalar product, which is depicted as a point, and the second is a vector product, which is depicted as a cross. </p><br><h3 id="skalyarnoe-proizvedenie">  Scalar product </h3><br><p>  The scalar product of two vectors is equivalent to the scalar product of the lengths of these vectors multiplied by the cosine of the angle between them.  If this sentence confuses you, then look at the formula: </p><br><p><img src="https://habrastorage.org/files/482/fd3/bdc/482fd3bdc8fe4341b50ab639e244c3ac.png" alt="Formula"></p><br><p>  Where the angle between the vectors is described as <strong>theta</strong> .  Why can this be interesting?  Well, imagine if the vectors v and k are unit vectors.  Accordingly, the formula is reduced to: </p><br><p><img src="https://habrastorage.org/files/077/4a7/816/0774a781626b4dd99dde449ed81e959c.png" alt="Formula"></p><br><p>  Now the dot product defines only the angle between the two vectors.  You may remember that the <strong>cos</strong> function becomes 0, with an angle of 90 degrees and 1 with an angle of 0. This makes it easy to check whether the vectors are orthogonal or parallel to each other (orthogonality means that the vectors are rectangular).  If you want to learn more about <strong>sin</strong> or <strong>cosine</strong> , then I recommend the <a href="https://www.khanacademy.org/math/trigonometry/basic-trigonometry/basic_trig_ratios/v/basic-trigonometry">Khan Academy video</a> about basic trigonometry. </p><br><blockquote>  You can also calculate the angle between two non-unit vectors, but for this you have to divide the result by the lengths of these vectors in order to stay with <strong>cos</strong> only. </blockquote><p>  So how to count the scalar product?  Scalar product is the multiplication of the components of the vectors and the subsequent addition of the results.  Example: </p><br><p><img src="https://habrastorage.org/files/b89/f81/a00/b89f81a00f5f4a58b594deb06e6b9ed9.png" alt="Formula"></p><br><p>  To calculate the angle between the vectors, we need to invert the cosine function (cos ^ -1) in this case - it is 143.1 degrees.  Thus, we effectively calculated the angle between these two vectors.  Scalar work is very useful when working with light. </p><br><h3 id="vektornoe-proizvedenie">  Vector product </h3><br><p>  A vector product is possible only in three-dimensional space and takes two non-parallel vectors as input, and returns a vector that is orthogonal to the input.  If the input vectors are orthogonal to each other, then the vector product will create 3 orthogonal vectors.  Next, you will learn why this may be useful.  The following image shows how this looks like three-dimensional space: </p><br><p><img src="https://habrastorage.org/files/422/528/4c1/4225284c1f5d4e58bb0bfdfd27de0604.png" alt="Formula"></p><br><p>  Unlike other operations, the vector product is not very intuitive without going into linear algebra, so it‚Äôs best to just remember the formula.  The following is a vector product between two orthogonal vectors A and B. </p><br><p><img src="https://habrastorage.org/files/5e9/599/44d/5e959944d6284b82a62b932297313739.png" alt="Formula"></p><br><p>  As you can see, there is not much meaning in this formula.  In any case, after all these steps, you get a vector that will be orthogonal to the input. </p><br><h2 id="matricy">  Matrices </h2><br><p>  Now, after we have discussed almost everything about vectors, it is time to delve into the matrices.  A matrix is ‚Äã‚Äãusually quadrangles from a set of numbers, symbols, and / or expressions.  Here is an example of a 2x3 matrix: </p><br><p><img src="https://habrastorage.org/files/706/b8a/18b/706b8a18b7db4e01a81a01eba5d4e1c8.png" alt="Matrix"></p><br><p>  The elements of the matrix are accessed using <strong>(i, j)</strong> , where i is a row and j is a column.  That is why the matrix above is called 2x3 (3 columns and 2 rows).  Such a system is the opposite of that used in 2D graphs <strong>(x, y)</strong> .  To obtain the value of 4 from the matrix above, we must specify the index <strong>(2, 1)</strong> (second row, first column). </p><br><p>  Matrices, in fact, are nothing more than quadrangular arrays of mathematical expressions.  They also have a very nice set of mathematical properties and, like the vectors, have several operations - addition, subtraction and multiplication. </p><br><h3 id="slozhenie-i-vychitanie-1">  Addition and subtraction </h3><br><p>  The addition of the matrix with a scalar is performed as follows: </p><br><p><img src="https://habrastorage.org/files/e02/b5b/fa0/e02b5bfa006f4e13a6191725d2c636af.png" alt="Matrix formula"></p><br><p>  The scalar is simply added throughout the elements of the matrix.  The same thing happens when subtracting: </p><br><p><img src="https://habrastorage.org/files/0d5/d85/513/0d5d855135414aef9886488b4efb8a0f.png" alt="Matrix formula"></p><br><p>  Addition and subtraction between two matrices is performed elementwise.  Thus, addition and subtraction operations can only be applied to matrices of the same size.  Example: </p><br><p><img src="https://habrastorage.org/files/533/646/971/533646971a28467dad87b9851f4c0a32.png" alt="Matrix formula"></p><br><p>  Same as with subtraction: </p><br><p><img src="https://habrastorage.org/files/fa0/85c/f4c/fa085cf4ce9e4c48a8a776871805a7b1.png" alt="Matrix formula"></p><br><h3 id="umnozhenie-matricy-na-skalyar">  Matrix multiplication by scalar </h3><br><p>  As well as addition and subtraction, the matrix is ‚Äã‚Äãmultiplied by a scalar by multiplying each element of the matrix by a scalar.  Example: </p><br><p><img src="https://habrastorage.org/files/16a/880/e02/16a880e021f5456eb87da5c6cf8c23fa.png" alt="Matrix formula"></p><br><h2 id="umnozhenie-matric">  Matrix multiplication </h2><br><p>  Matrix multiplication is not very difficult, but not so simple.  Multiplication has several limitations: </p><br><ol><li>  You can only multiply matrices, where the number of columns of the first matches the number of rows of the second matrix. </li><li>  Matrix multiplication is not commutative.  A * B! = B * A. </li></ol><br><p>  Here is an example of multiplying two 2x2 matrices: </p><br><p><img src="https://habrastorage.org/files/074/04d/eac/07404deac8b74800bd07bc7990960c27.png" alt="Matrix formula"></p><br><p>  Now, maybe you are trying to understand what is going on here?  Matrix multiplication is a combination of normal multiplication and addition using the rows of the left matrix with the columns of the right matrix.  The following image should bring some clarity: </p><br><p><img src="https://habrastorage.org/files/4c5/54a/02b/4c554a02b2294220bbc970af7d7ea355.png" alt="Matrix formula"></p><br><p>  In the beginning we take the top row of the left matrix and the left column of the right matrix.  The row and column we choose determines which element of the resulting matrix we are going to calculate.  If we took the first row of the left matrix, then we are going to work with the top row of the resulting matrix, then we select the column in the right matrix, it determines which column of the resulting matrix we are working with.  To calculate the bottom-right element, we must select the bottom row of the left matrix and the right column of the right matrix. </p><br><p>  To calculate the resulting value, we multiply the elements of the row and column using ordinary multiplication.  The results of the multiplication are then added up and we get the result.  This is where the first limit comes from. </p><br><p>  The result is a matrix of size <strong>(n, m)</strong> , where n is the number of rows in the left matrix, and m is the number of columns in the right matrix. </p><br><p>  If you have a problem - do not worry.  Just keep on calculating with your hands and return to this lesson when difficulties arise.  Soon the multiplication of matrices will be on the machine. </p><br><p>  Let's close the matrix multiplication question with one big example.  For the presentation of the algorithm used colors.  For training, try to calculate the result yourself, and then compare it with the result in the example. </p><br><p><img src="https://habrastorage.org/files/275/396/c24/275396c24e3c4b1ea5e3310cb1edf720.png" alt="Matrix formula"></p><br><p>  As you can see the multiplication of matrices is a rather dreary process with a lot of places to go wrong.  And these problems only grow with increasing size.  If you are still craving more mathematical properties of matrices, I highly recommend the <a href="https://www.khanacademy.org/math/algebra2/algebra-matrices">Khan Academy video</a> . </p><br><h3 id="umnozhenie-matricy-na-vektor">  Matrix vector multiplication </h3><br><p>  We have already used vectors in past lessons.  We used them to represent positions, colors, and texture coordinates.  Now let's dive a little into the rabbit hole and tell you that the vector is actually just an <strong>Nx1</strong> matrix, where <strong>N</strong> is the number of components of the vector.  If you think about it a little, it makes sense.  The vectors, just like matrices, are an array of numbers, but only with 1 column.  And how will this information help us?  Well, if we have an <strong>MxN</strong> matrix, we can multiply it by the Nx1 vector, since the number of columns of the matrix is ‚Äã‚Äãequal to the number of rows of the vector. </p><br><p>  But why should we even be able to multiply the matrix by the vector?  Quite a lot of different 3D / 2D transformations can be performed by multiplying the matrix by a vector, obtaining a modified vector.  If you are still not sure that you fully understand the text above, here are some examples: </p><br><h2 id="edinichnaya-matrica">  Unit matrix </h2><br><p>  In OpenGL, they usually work with <strong>4x4</strong> transformation matrices for the reason that most vectors have 4 components.  The simplest transformation matrix that can be discussed is the <strong>identity matrix</strong> .  The identity matrix is ‚Äã‚Äãan NxN matrix, filled with zeros, but with 1 diagonally.  As we can see, this matrix does not change the vector at all: </p><br><p><img src="https://habrastorage.org/files/e0a/b15/18e/e0ab1518ebea46e7922bf4c61c8be2d9.png" alt="Matrix"></p><br><p>  Vector looks intact.  This becomes obvious from the multiplication rules: the first resultant element is each element of the first row of the matrix, multiplied by each element of the vector.  Since each element of the line is 0, except for the first one, we get 1 * 1 + 0 * 2 + 0 * 3 + 0 * 4 = 1. The same applies to the remaining 3 elements of the vector. </p><br><p>  You may ask, why would a transformation matrix, which transforms nothing, be needed at all?  The identity matrix is ‚Äã‚Äãoften the starting point for generating other transformation matrices and if we delve into linear algebra, this is also a very convenient matrix for proving theorems and solving linear equations. </p><br><h2 id="matrica-masshtabirovaniya">  Scaling matrix </h2><br><p>  When we scale a vector, we increase the length of the arrow by the amount of scaling, keeping the direction.  While we are working in 2 or 3 dimensions, we can define a vector scaling of 2 or 3 values, each of which scales one of the axes <strong>(x, y</strong> or <strong>z)</strong> . </p><br><p>  Let's try to scale the vector <strong>v = (3,2)</strong> .  We will scale the vector along the x axis by <strong>0.5</strong> , which will make it 2 times narrower;  and scale the vector along the y axis by <strong>2</strong> , which will increase the height by 2 times.  Let's see how it will look like if we scale the vector by (0.5, 2).  We write the result as <strong>s</strong> . </p><br><p><img src="https://habrastorage.org/files/a3f/a6e/e4f/a3fa6ee4f1da4b779c013cfe0e8a7e0d.png" alt="Schedule"></p><br><p>  Remember that OpenGL often works in 3D space, so for 2D you can leave the Z coordinate equal to 1. The scaling operation that we just performed is <strong>non-uniform</strong> , since the scaling value for each axis is different.  If the scaling value were the same, then such a transformation is called <strong>homogeneous</strong> . </p><br><p>  Let's build a transformation matrix that will scale for us.  We have already seen on the identity matrix that the diagonal element will be multiplied by the corresponding element of the vector.  What if we replace the units in the unit matrix for triples?  In this case, we multiply all elements of the vector by this value.  Accordingly, if we represent the scaling values ‚Äã‚Äãas (S1, S2, S3), then we will be able to determine the scaling matrix for any vector <strong>(x, y, z)</strong> : </p><br><p><img src="https://habrastorage.org/files/176/58d/4e5/17658d4e58c34d679a7e88724c2284db.png" alt="Matrix formula"></p><br><p>  Note that the 4th element of the vector is 1. This component is denoted as <strong>w</strong> and will later be used for other tasks. </p><br><h3 id="matrica-sdviga">  Shear matrix </h3><br><p>  Shift is the process of adding one vector to another to obtain a new vector with a different position, that is, <strong>a</strong> vector <strong>shift</strong> based on a shift vector.  We have already discussed vector addition, so for you this will not be something new. <br>  As with the scaling matrix in the 4x4 matrix there are several positions for performing the required operations, for shifting these are the top 3 elements of the fourth column.  If we represent the shift vector as (Tx, Ty, Tz), then we can define the shift matrix as follows: </p><br><p><img src="https://habrastorage.org/files/68c/2ae/5bc/68c2ae5bca1d40438498f01c063b4fcd.png" alt="Matrix"></p><br><p>  This works because all the values ‚Äã‚Äãof the vector are multiplied by the <strong>w</strong> components of the vector and added to the initial values.  This would not be possible using 3x3 matrices. </p><br><blockquote>  <strong>Homogeneous coordinates</strong> <br>  The component of the vector <strong>w is</strong> also called a <strong>homogeneous coordinate</strong> .  To obtain a 3D vector from a homogeneous coordinate, we divide the <strong>x</strong> , <strong>y,</strong> and <strong>z</strong> coordinates by <strong>w</strong> .  This is usually not noticed, since <strong>w is</strong> most of the time 1.0.  Using homogeneous coordinates has several advantages: they allow us to perform shifts on 3D vectors (without the <strong>w</strong> components, this would be impossible) and in the next chapter we will use the value of <strong>w</strong> to create 3D visualizations. <br>  Also, when the homogeneous coordinate is 0, then the vector is considered to be <strong>a direction vector</strong> , since the vector with the <strong>w</strong> component equal to 0 cannot be shifted. </blockquote><p>  With the shift matrix, we can move objects in all 3 directions <strong>(x, y, z)</strong> , which makes this matrix extremely useful for our tasks. </p><br><h3 id="matrica-vrascheniya">  Rotation matrix </h3><br><p>  The last couple of transformations were fairly easy to understand and view in 2D or 3D space, but the rotations are a bit more intricate.  If you want to know how exactly these matrices are formed - then I recommend the Khan Academy video about <a href="https://www.khanacademy.org/math/linear-algebra/matrix_transformations">linear algebra</a> . </p><br><p>  To begin with, let's define what this is - rotation of a vector.  Rotation in 2D and 3D is determined by the <strong>angle</strong> .  The angle can be expressed in angles or radians, in which a full revolution is 360 degrees or 2Pi, respectively.  I prefer to work with degrees, since they are more logical for me. </p><br><blockquote>  Most rotational functions require an angle in radians, but the benefit of converting from one system to another is quite simple: <br>  Degrees = radians * (180.0f / PI) <br>  Radians = degrees * (PI / 180.0f) <br>  Where PI is approximately 3.14159265359 </blockquote><p>  Rotation on a half circle - requires us to rotate 360/2 = 180 degrees.  Rotation 1/5 to the right requires us to rotate 360/5 = 72 degrees to the right.  Here is an example of a conventional 2D vector, where <strong>v is</strong> rotated 72 degrees to the right of <strong>k</strong> . </p><br><p><img src="https://habrastorage.org/files/291/99e/cbf/29199ecbfe804b91850749110018dd9f.png" alt="Example"></p><br><p>  Rotation in 3D is described by the angle <strong>and</strong> <strong>axis of rotation</strong> .  The angle determines how much the vector will be rotated about the given axis.  When rotating 2D vectors in the 3D world, for example, we set the rotation axis - Z. </p><br><p>  With the help of trigonometry, we can transform vectors into rotated at a certain angle.  This is usually done with a clever combination of <strong>sin</strong> and <strong>cos</strong> functions.  A discussion of how the transformation matrix is ‚Äã‚Äãgenerated is beyond the scope of our lesson. </p><br><p>  The rotation matrix is ‚Äã‚Äãdefined for each axis in 3D space, where the angle is shown as theta. <br>  Rotation matrix around the X axis: </p><br><p><img src="https://habrastorage.org/files/d50/22a/48e/d5022a48e910426b875ac78bde60acf6.png" alt="Rotation matrix"></p><br><p>  The rotation matrix around the Y axis: </p><br><p><img src="https://habrastorage.org/files/caf/325/15b/caf32515b86b4cfdbfddec2c0ecc8188.png" alt="Rotation matrix"></p><br><p>  The rotation matrix around the Z axis: </p><br><p><img src="https://habrastorage.org/files/b28/2fa/c76/b282fac763104e5f8ea27b43c5e28545.png" alt="Rotation matrix"></p><br><p>  With the help of rotation matrices, we can rotate our vectors along one of three axes.  You can also combine them, for example, at the beginning turn on the X axis, and then Y. True, this approach will quickly lead to a problem called the hinge lock problem.  We will not go into details, but it is better to use rotation along a specific axis, for example <strong>(0.662, 0.2, 0.722)</strong> (note that this is a single vector), instead of combining rotation along specific axes.  The matrix for such transformations exists and looks like this, where (Rx, Ry, Rz) is the axis of rotation: </p><br><p><img src="https://habrastorage.org/files/d63/846/156/d638461566f14757b25aa70528d3509f.png" alt="Matrix"></p><br><p>  Mathematical discussions about generating such a matrix are beyond the scope of this lesson.  Just keep in mind that even such a matrix does not completely solve the problem of the hinge lock (it's just harder to get).  In order to completely solve this problem, we will have to work with rotations using quaternions, which are not only safer, but also much more friendly from the point of view of calculations.  Be that as it may, the Quaternion discussion is set aside for a later lesson. </p><br><h3 id="kombinirovanie-matric">  Matrix Combination </h3><br><p>  In order to maximize the utility of using matrices for transformations, we need to combine transformation matrices into one matrix.  Let's see if we can generate a transformation matrix that will include several transformations.  For example, we have a vector <strong>(x, y, z)</strong> and we want to scale it 2 times and shift by <strong>(1, 2, 3)</strong> .  To do this, we need scaling and offset matrices.  As a result, we get something like: </p><br><p><img src="https://habrastorage.org/files/ce1/b4b/138/ce1b4b1386d94a2d9626231004abf666.png" alt="Combining"></p><br><p>  Notice that during the multiplication of matrices, we first perform a shift, and then scaling.  Matrix multiplication is not commutative, which means that the order of multiplication is important.  During matrix multiplication, the right matrix is ‚Äã‚Äãmultiplied by a vector, so you need to read the multiplications from right to left.  It is recommended to scale at the beginning, then rotate and shift at the end, during the union of the matrices, otherwise they can deny each other.  For example, if you first shift and then scale, then the shift matrix will also scale! </p><br><p>  As a result, the transformation matrix is ‚Äã‚Äãapplied as follows: </p><br><p><img src="https://habrastorage.org/files/ccd/303/e8b/ccd303e8b49b45cb8b15f1c4d9c94da9.png" alt="Combined graphics"></p><br><p>  Excellent, the vector is scaled 2 times and shifted by <strong>(1, 2, 3)</strong> . </p><br><h2 id="na-praktike">  On practice </h2><br><p>  After we discussed the whole theory, it is time to put it into practice.  OpenGL does not have built-in support for matrix or vector transformations, so we will have to use our own math classes and functions.  In these lessons we abstract from subtle mathematical details and simply use ready-made mathematical libraries.  Fortunately, there is already an easy-to-use and sharpened math library called OpenGL called GLM. </p><br><h3 id="glm">  GLM </h3><br><p>  GLM is an abbreviation for Open <strong>GL M</strong> athematics.  This library is a header, which means that we just need to include the required header files.  No need to bother with any linking or compilation.  GLM can be downloaded from the <a href="http://glm.g-truc.net/0.9.5/index.html">official site</a> .  Copy the root directory with the header files to your <strong>includes</strong> folder and you can start. </p><br><p>  Most of the GLM functionality can be found in the 3 header files: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;glm/glm.hpp&gt; #include &lt;glm/gtc/matrix_transform.hpp&gt; #include &lt;glm/gtc/type_ptr.hpp&gt;</span></span></span></span></code> </pre> <br><p>  Let's see if we can apply our knowledge in the transformations to shift the vector <strong>(1, 0, 0)</strong> to <strong>(1, 1, 0)</strong> (note that we denoted from <strong>glm :: vec4</strong> with a homogeneous coordinate of 1.0): </p><br><pre> <code class="cpp hljs">glm::<span class="hljs-function"><span class="hljs-function">vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; glm::mat4 trans; trans = glm::translate(trans, glm::vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vec = trans * vec; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; vec.x &lt;&lt; vec.y &lt;&lt; vec.z &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  In the beginning, we created a vector called <strong>vec</strong> using the built-in GLM vector class.  Then we define <strong>mat4</strong> , which is the 4x4 identity matrix.  Then we create the transformation matrix by passing our unit matrix to the function <strong>glm :: translate</strong> , along with the shift vector. <br>  Then we multiply our vector by the transformation matrix and output the result.  If you still remember how the shift matrix works, then you understand that the resulting vector must be <strong>(1 + 1, 0 + 1, 0 + 0)</strong> , which is <strong>(2, 1, 0)</strong> .  The code above displays <strong>210</strong> , which means that the shift matrix has done its job. </p><br><p>  Let's try to do something more interesting and try to scale and then rotate an object from the last lesson.  At the beginning we will rotate the container <strong>90</strong> degrees counterclockwise.  Then scale it to <strong>0.5</strong> in order to reduce it by 2 times.  Let's build a transformation matrix for this. </p><br><pre> <code class="cpp hljs">glm::mat4 trans; trans = glm::rotate(trans, <span class="hljs-number"><span class="hljs-number">90.0f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); trans = glm::scale(trans, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>));</code> </pre> <br><p>  At the beginning, we reduce the container by 0.5, along each axis, and then rotate the container 90 degrees in the Z coordinate.  Notice that the texture also turned.  Since we pass the matrix to each of the GLM functions, GLM automatically multiplies the matrices, resulting in a transformation matrix. </p><br><blockquote>  Some versions of GLM take angles in radians, not degrees.  If you have such a version, convert the degrees to radians using <strong>glm :: radians (90.0f)</strong> . </blockquote><p>  The next big question is how to pass the transformation matrix to the shader?  We have already said that GLSL is of type <strong>mat4</strong> .  So it remains for us to accept <strong>mat4</strong> as the uniform variable and multiply the position vector by this matrix. </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 position; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 texCoord; out vec3 ourColor; out vec2 TexCoord; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> mat4 transform; void main() { gl_Position = transform * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f); ourColor = <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; TexCoord = vec2(texCoord.x, <span class="hljs-number"><span class="hljs-number">1.0</span></span> - texCoord.y); }</code> </pre> <br><blockquote>  GLSL also has <strong>mat2</strong> and <strong>mat3 types</strong> , which provide the same operations as vectors.  All operations covered in this article are available in matrix types. </blockquote><p>  We added uniform and multiplied the positional vector by the transformation matrix before passing it to <strong>gl_Position</strong> .  Our container should now be less than 2 times and turn 90 degrees.  But do we still need to pass the transformation matrix to the shader? </p><br><pre> <code class="cpp hljs">GLuint transformLoc = glGetUniformLocation(ourShader.Program, <span class="hljs-string"><span class="hljs-string">"transform"</span></span>); glUniformMatrix4fv(transformLoc, <span class="hljs-number"><span class="hljs-number">1</span></span>, GL_FALSE, glm::value_ptr(trans));</code> </pre> <br><p>  At the beginning we get the position of the uniform variable and then send the matrix data to it using the <strong>glUniform</strong> function with the postfix <strong>Matrix4fv</strong> .  The first argument must be a variable position.  The second argument tells OpenGL how many matrices we are going to send, in our case 1. The third argument tells you if you want to transpose the matrix.  OpenGL developers often use an internal matrix format called column-major ordering, which GLM uses by default, so we do not need to transpose the matrices, we can leave <strong>GL_FALSE</strong> .  The last parameter is the data itself, but GLM does not store the data exactly as OpenGL wants to see it, so we convert it using <strong>value_ptr</strong> . </p><br><p>  We created a transformation matrix, declared uniform in the vertex shader, and sent the matrix in the shader with which we adjust the vertex coordinates.  The result should be something like this: </p><br><p><img src="https://habrastorage.org/files/2f0/43d/676/2f043d676a4a45fb970eccba9eb3ed97.png" alt="Result"></p><br><p>  Fine!  Our container is really turned left and 2 times smaller, so the transformation was successful.  And now let's make our container rotate in real time, and also move it to the lower right corner.  In order to do this, you will have to perform calculations at each iteration of the main loop.  We use the GLFW function to get time to change the angle over time: </p><br><pre> <code class="cpp hljs">glm::mat4 trans; trans = glm::translate(trans, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); trans = glm::rotate(trans,(GLfloat)glfwGetTime() * <span class="hljs-number"><span class="hljs-number">50.0f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre> <br><p>  Keep in mind that earlier we could declare a transformation matrix anywhere, but now we create it at each iteration so that we can update the rotation for each frame.  This means that we must recreate the transformation matrix at each iteration of the game cycle.  Usually, when there are several objects on stage, their transformation matrices are recreated with new values ‚Äã‚Äãat each iteration of the drawing. </p><br><p>  Now we rotate the object around the center <strong>(0, 0, 0)</strong> , and then move the rotated version to the bottom-right corner of the screen.  Remember that the real sequence of applying transformations is read in the reverse order: even in the code we shift at the beginning and then rotate, then the transformations are applied in the reverse order, at the beginning of the turn, then the shift.  Understanding all these transformations and how they affect objects is rather difficult.  Try experimenting with transformations and get used to them quickly. </p><br><p>  If you did everything right, then you get something like this: </p><br><div class="oembed"><div><div style="left: 0px; width: 100%; height: 0px; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0px; left: 0px; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://learnopengl.com/video/getting-started/transformations.mp4" type="video/mp4"></video></div></div></div><br><p>  That's all.  A shifted container that rotates over time, and all this is done with a single transformation matrix!  Now you can see why matrices are so strong in the graphic world.  We can define an infinite number of transformations and combine them into one matrix for subsequent reuse.  Using such transformations in the vertex shader allows us not to change the vertex data, which saves us processor time, since we do not need to send data to the buffer. </p><br><p>  If you could not get the correct result or you are stuck somewhere, then take a look at the <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/transformations">source code</a> together with the <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/transformations%26amp%3Btype%3Dvertex">vertex</a> and <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/transformations%26amp%3Btype%3Dfragment">fragment</a> shaders. </p><br><p>  In the next lesson, we will discuss how to use matrices to define different coordinate spaces for our vertices.  This will be a new step in the world of 3D graphics in real time! </p><br><h3 id="uprazhneniya">  Exercises </h3><br><ul><li>  Change the last transformation of the sequence of actions, see what happens, try to justify why this is the result.  <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/transformations-exercise1">Decision</a> </li><li>  Try drawing another container with <strong>glDrawElements</strong> , but just place the container in a different place with a different transformation.  Let it be in the upper right corner and instead of rotating - it changed its size (here you can use the sin function): <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/transformations-exercise2">Solution</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/319144/">https://habr.com/ru/post/319144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319134/index.html">Thinking in the style of React</a></li>
<li><a href="../319136/index.html">JS classes with protected, multiple inheritance, getters / setters, and impurities</a></li>
<li><a href="../319138/index.html">How to start implementing Hadoop in the company</a></li>
<li><a href="../319140/index.html">Third-party applications that use the Google Hangouts API will stop working after April 25, 2017</a></li>
<li><a href="../319142/index.html">Ludum Dare # 37: First Experience and Participation Experience</a></li>
<li><a href="../319146/index.html">How IT professionals work. Nikita Abdullin, security analyst at Riscure</a></li>
<li><a href="../319148/index.html">What to do if the cables have ears, or a steganographic proxy</a></li>
<li><a href="../319150/index.html">Non-standard XMPP protocol support with Smack</a></li>
<li><a href="../319152/index.html">Script for removing old drivers</a></li>
<li><a href="../319154/index.html">nanoCAD Plus 8.1: what does the user expect in the new version of the Russian CAD system?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>