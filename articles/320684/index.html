<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A little about Swift runtime or where NSObject disappeared</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello friends! I am one of those who are bored just to pull the strings sticking out of the black box, I want to see everything with my own eyes, how ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A little about Swift runtime or where NSObject disappeared</h1><div class="post__text post__text-html js-mediator-article">  Hello friends!  I am one of those who are bored just to pull the strings sticking out of the black box, I want to see everything with my own eyes, how it works under the hood.  We will talk to you about runtime, yes yes runtime.  For our experiences, let's consider the good old grandfather of Objective C and the revolutionary, but still under development, Swift.  We need to dive with you almost at the very bottom of the abstractions that Apple programmers have thoughtfully invented.  Let's see a little about why it was even necessary to develop a new language.  I heard a lot of negative reviews at the very beginning, especially from the already well-experienced Objective C developers. If you look closely at the new Swift language, it is in my opinion more significant and more serious.  First, he wrote in C ++, in contrast to C, which is the basis of Objective C. I here express only my purely personal prejudices, which you can agree with, and you can argue. <br><a name="habracut"></a><br>  In my opinion C ++ at the moment, the most serious development language that allows you to do anything, but more elegant than in C.  I think therefore it was he who was chosen as the basis for writing Swift, <b>LLDB,</b> and so on.  I will not review the functionality of the Swift language now, just to highlight a few points, everything else can be read in the specialized documentation.  In my opinion, it is much more functional and easier for a novice programmer, in fact, this was one of the goals of its development, to lower the threshold of entry for new developers.  Remember how your hair got up after the first acquaintance with Objective C brackets, especially if you had previously written in concise C # or Java.  Of course, it was not done without the cunning that programmers invented in my opinion just to stand out.  But this is all the lyrics, let's get down to business.  First, let's analyze the base class of grandfather Objectice C because we compare it with Swift. <br><br>  For those who know all this, you can still go out for a smoke.  As we know in Objective-C, any class, either directly or indirectly, must inherit from NSObject or NSProxy.  The NSObject class implements the informal protocol NSObject.  We will return to it when we consider the SwiftObject.  Looking ahead, I‚Äôll say that it is this protocol that will greatly help to make two languages ‚Äã‚Äãfriends, here it is the power of polymorphism!  I propose to do so, we will look at all the methods of the NSObject class in pieces.  And after that, I dare to conclude what is wrong with this great NSObject.  I will not torment you for a long time! <br><habracut><br><pre><code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class">&gt; </span></span>{ Class isa OBJC_ISA_AVAILABILITY; } + (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)load; + (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)initialize; - (<span class="hljs-keyword"><span class="hljs-keyword">instancetype</span></span>)init <span class="hljs-meta"><span class="hljs-meta">#if NS_ENFORCE_NSOBJECT_DESIGNATED_INITIALIZER NS_DESIGNATED_INITIALIZER #endif ; + (instancetype)new OBJC_SWIFT_UNAVAILABLE(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"use object initializers instead"</span></span></span><span class="hljs-meta">); + (instancetype)allocWithZone:(struct _NSZone *)zone OBJC_SWIFT_UNAVAILABLE(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"use object initializers instead"</span></span></span><span class="hljs-meta">); + (instancetype)alloc OBJC_SWIFT_UNAVAILABLE(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"use object initializers instead"</span></span></span><span class="hljs-meta">); - (void)dealloc OBJC_SWIFT_UNAVAILABLE(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"use 'deinit' to define a de-initializer"</span></span></span><span class="hljs-meta">); - (void)finalize; ....</span></span></code> </pre> <br>  The first two methods do not often come across an ordinary developer Objectice C. I will not dwell on them, I will just say a few words.  The <b>load</b> method is called when the class or category is loaded into the runtime, does not obey the classical inheritance rules, and blocks the application at the time of execution.  The <b>initialize</b> method is called in deferred mode, before the first use of the class, does not block the operation of the application, obeys the classical inheritance rules. <br><br>  All subsequent methods are responsible for creating and initializing the object.  Also discuss them a little.  The <b>allocWithZone</b> method <b>is</b> responsible for allocating memory for our object.  Inside, he calls our favorite malloc.  He is still from bearded times when the memory was divided into zones.  Now all objects are created in one zone, because the alloc method has appeared, which inside itself calls <b>allocWithZone</b> and passes it the default zone - <b>NSDefaultMallocZone</b> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The <b>dealloc</b> and <b>finalize</b> methods are called when the object is deleted.  It is in these methods that all the related resources are cleared and finally free and the memory goes to the free memory pool.  I note that <b>finalize</b> is not normally used and <b>dealloc is called on the thread where the last release occurred</b> . <br><br>  Go to the next pack of methods. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>; - (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)mutableCopy; + (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)copyWithZone:(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> _NSZone *)zone OBJC_ARC_UNAVAILABLE; + (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)mutableCopyWithZone:(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> _NSZone *)zone OBJC_ARC_UNAVAILABLE;</code> </pre><br>  Well, probably even to someone who never wrote to obzhaktiv si it is not difficult to guess what they are for copying.  Everything is clear with zones, these are ancient methods that are no longer relevant.  In fact, in order to copy something from us, we still need to implement the <b>NSCopying</b> protocol, and if you just call these methods, everything will fall.  But we will discuss this later.  In the meantime, move on to the next pack. <br><br><pre> <code class="objectivec hljs">+ (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)instancesRespondToSelector:(SEL)aSelector; + (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)conformsToProtocol:(Protocol *)protocol; - (IMP)methodForSelector:(SEL)aSelector; + (IMP)instanceMethodForSelector:(SEL)aSelector; - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)doesNotRecognizeSelector:(SEL)aSelector; + (<span class="hljs-built_in"><span class="hljs-built_in">NSMethodSignature</span></span> *)instanceMethodSignatureForSelector:(SEL)aSelector OBJC_SWIFT_UNAVAILABLE(<span class="hljs-string"><span class="hljs-string">""</span></span>); - (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)allowsWeakReference UNAVAILABLE_ATTRIBUTE; - (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)retainWeakReference UNAVAILABLE_ATTRIBUTE; + (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)isSubclassOfClass:(Class)aClass; + (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(<span class="hljs-number"><span class="hljs-number">10.5</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">9.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); + (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(<span class="hljs-number"><span class="hljs-number">10.5</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">9.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); + (Class)superclass; + (Class)<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> OBJC_SWIFT_UNAVAILABLE(<span class="hljs-string"><span class="hljs-string">"use 'aClass.self' instead"</span></span>);</code> </pre><br>  Here it is introspection, in person.  The key to secure code in obzhivek si.  These methods allow us to evaluate an object or class, which protocols it implements, to which selectors it can react, and so on.  Go ahead <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)forwardingTargetForSelector:(SEL)aSelector OBJC_AVAILABLE(<span class="hljs-number"><span class="hljs-number">10.5</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">9.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)forwardInvocation:(<span class="hljs-built_in"><span class="hljs-built_in">NSInvocation</span></span> *)anInvocation OBJC_SWIFT_UNAVAILABLE(<span class="hljs-string"><span class="hljs-string">""</span></span>); - (<span class="hljs-built_in"><span class="hljs-built_in">NSMethodSignature</span></span> *)methodSignatureForSelector:(SEL)aSelector OBJC_SWIFT_UNAVAILABLE(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre><br>  The first two methods will be called up to the moment when everything crashes down on you if you do not implement anything in them.  This happens when our object does not understand what you want from it and call a method that it does not have.  If you do this meaningfully, then be kind enough to determine one of these methods and decide what to do with the call to the selector, where to send it so to speak.  This is actually called a message forwarding mechanism.  About this, too, can be read, a bunch of articles, and there are three methods.  I will not dwell on this, otherwise we will lose the main essence of this article. <br><br>  Let's look at the latest methods. <br><br><pre> <code class="objectivec hljs">+ (<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)hash; + (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)description; + (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)debugDescription;</code> </pre><br>  I think the hash method is known to everyone, it is used to compare objects, to distribute objects among nests in collections, and so on.  The <b>description</b> and <b>debugDescription methods</b> must be redefined if you want to see in the logs not just the addresses where your object is located, but some meaningful information for it. <br><br>  Fuh, that I already got tired to describe these methods.  Let us now take a closer look at this class, here it stands at the head of all classes in obzhivek si, basically.  What's wrong with him?  What I do not like him?  Yes, everything is wrong with him! <br><br>  How it says our principles of OOP: inheritance, encapsulation, polymorphism!  But there for some reason it does not say that inherit everything from one class, may the Java and C # developers forgive me.  I think programmers with experience building architectures, came up against various pitfalls of architectural solutions that initially seemed very thoughtful.  I would say that inheritance is like a time bomb, which will ultimately reduce all your thoughtful architecture to zero or will already tie your hands for development.  In many books on architecture it is written that choose a composition instead of inheritance.  This is a more flexible approach, but inheritance is also a very powerful thing that you need to know how to handle.  Namely, it is correct to separate abstractions and to lay for further expansion.  Looking ahead, I‚Äôll say that Swift lost this base class that is accessible to the programmer. <br><br>  In fact, it is, and it is called <b>SwiftObject</b> from which all classes that need to interact with Objective C, written in swift, are inherited.  We will talk more about it.  Many will probably say: what is this guy carrying?  Inheritance is a cool thing, reusing a code that is bad in it.  I think this topic I will put in a separate article, while we talk about something else.  For example, why do I need the copy method if I don‚Äôt want to copy anything?  However, I can call it, and by itself everything will fall if I do not implement the NSCopying puncture.  Let's talk more about inheritance.  There is an <b>init</b> method that I should call if I want to initialize an object, but there is a <b>dealloc</b> method that is called by myself!  For this is the method of the life cycle of an object and you do not need to call it with your hands, never!  But no one bothers me to do this, isn't it great?  Yes, that's not great at all.  It turns out that the NSObject class itself allows us to do what we don‚Äôt need to do, or to know what we don‚Äôt need to know about.  I can develop the topic further and further, but I think it is already clear that NSObject is an ugliness that should not be and therefore it is missing in the Swift language for the programmer.  Formally, of course, the base class remained only for the IOS platform, but in order to make friends with each other, these two languages: the old Objective C and the ambitious Swift.  Let's probably look at him with one eye. <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwiftObject</span></span></span><span class="hljs-class"> + (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initialize</span></span></span><span class="hljs-class"> </span></span>{} + (<span class="hljs-keyword"><span class="hljs-keyword">instancetype</span></span>)allocWithZone:(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> _NSZone *)zone { assert(zone == nullptr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _allocHelper(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } + (<span class="hljs-keyword"><span class="hljs-keyword">instancetype</span></span>)alloc { <span class="hljs-comment"><span class="hljs-comment">// we do not support "placement new" or zones, // so there is no need to call allocWithZone return _allocHelper(self); } + (Class)class { return self; } - (Class)class { return (Class) _swift_getClassOfAllocated(self); } + (Class)superclass { return (Class) _swift_getSuperclass((const ClassMetadata*) self); } - (Class)superclass { return (Class) _swift_getSuperclass(_swift_getClassOfAllocated(self)); } + (BOOL)isMemberOfClass:(Class)cls { return cls == (Class) _swift_getClassOfAllocated(self); } - (BOOL)isMemberOfClass:(Class)cls { return cls == (Class) _swift_getClassOfAllocated(self); } - (instancetype)self { return self; } - (BOOL)isProxy { return NO; } - (struct _NSZone *)zone { auto zone = malloc_zone_from_ptr(self); return (struct _NSZone *)(zone ? zone : malloc_default_zone()); } - (void)doesNotRecognizeSelector: (SEL) sel { Class cls = (Class) _swift_getClassOfAllocated(self); fatalError(/* flags = */ 0, "Unrecognized selector %c[%s %s]\n", class_isMetaClass(cls) ? '+' : '-', class_getName(cls), sel_getName(sel)); } - (id)retain { auto SELF = reinterpret_cast&lt;HeapObject *&gt;(self); swift_retain(SELF); return self; } - (void)release { auto SELF = reinterpret_cast&lt;HeapObject *&gt;(self); swift_release(SELF); } - (id)autorelease { return _objc_rootAutorelease(self); } - (NSUInteger)retainCount { return swift::swift_retainCount(reinterpret_cast&lt;HeapObject *&gt;(self)); } - (BOOL)_isDeallocating { return swift_isDeallocating(reinterpret_cast&lt;HeapObject *&gt;(self)); } - (BOOL)_tryRetain { return swift_tryRetain(reinterpret_cast&lt;HeapObject*&gt;(self)) != nullptr; } - (BOOL)allowsWeakReference { return !swift_isDeallocating(reinterpret_cast&lt;HeapObject *&gt;(self)); } - (BOOL)retainWeakReference { return swift_tryRetain(reinterpret_cast&lt;HeapObject*&gt;(self)) != nullptr; } // Retaining the class object itself is a no-op. + (id)retain { return self; } + (void)release { /* empty */ } + (id)autorelease { return self; } + (NSUInteger)retainCount { return ULONG_MAX; } + (BOOL)_isDeallocating { return NO; } + (BOOL)_tryRetain { return YES; } + (BOOL)allowsWeakReference { return YES; } + (BOOL)retainWeakReference { return YES; } - (void)dealloc { swift_rootObjCDealloc(reinterpret_cast&lt;HeapObject *&gt;(self)); } - (BOOL)isKindOfClass:(Class)someClass { for (auto isa = _swift_getClassOfAllocated(self); isa != nullptr; isa = _swift_getSuperclass(isa)) if (isa == (const ClassMetadata*) someClass) return YES; return NO; } + (BOOL)isSubclassOfClass:(Class)someClass { for (auto isa = (const ClassMetadata*) self; isa != nullptr; isa = _swift_getSuperclass(isa)) if (isa == (const ClassMetadata*) someClass) return YES; return NO; } + (BOOL)respondsToSelector:(SEL)sel { if (!sel) return NO; return class_respondsToSelector((Class) _swift_getClassOfAllocated(self), sel); } - (BOOL)respondsToSelector:(SEL)sel { if (!sel) return NO; return class_respondsToSelector((Class) _swift_getClassOfAllocated(self), sel); } + (BOOL)instancesRespondToSelector:(SEL)sel { if (!sel) return NO; return class_respondsToSelector(self, sel); } - (BOOL)conformsToProtocol:(Protocol*)proto { if (!proto) return NO; auto selfClass = (Class) _swift_getClassOfAllocated(self); // Walk the superclass chain. while (selfClass) { if (class_conformsToProtocol(selfClass, proto)) return YES; selfClass = class_getSuperclass(selfClass); } return NO; } + (BOOL)conformsToProtocol:(Protocol*)proto { if (!proto) return NO; // Walk the superclass chain. Class selfClass = self; while (selfClass) { if (class_conformsToProtocol(selfClass, proto)) return YES; selfClass = class_getSuperclass(selfClass); } return NO; } - (NSUInteger)hash { return (NSUInteger)self; } - (BOOL)isEqual:(id)object { return self == object; } - (id)performSelector:(SEL)aSelector { return ((id(*)(id, SEL))objc_msgSend)(self, aSelector); } - (id)performSelector:(SEL)aSelector withObject:(id)object { return ((id(*)(id, SEL, id))objc_msgSend)(self, aSelector, object); } - (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2 { return ((id(*)(id, SEL, id, id))objc_msgSend)(self, aSelector, object1, object2); } - (NSString *)description { return _getDescription(self); } - (NSString *)debugDescription { return _getDescription(self); } + (NSString *)description { return _getClassDescription(self); } + (NSString *)debugDescription { return _getClassDescription(self); } - (NSString *)_copyDescription { // The NSObject version of this pushes an autoreleasepool in case -description // autoreleases, but we're OK with leaking things if we're at the top level // of the main thread with no autorelease pool. return [[self description] retain]; } - (CFTypeID)_cfTypeID { // Adopt the same CFTypeID as NSObject. static CFTypeID result; static dispatch_once_t predicate; dispatch_once_f(&amp;predicate, &amp;result, [](void *resultAddr) { id obj = [[NSObject alloc] init]; *(CFTypeID*)resultAddr = [obj _cfTypeID]; [obj release]; }); return result; } // Foundation collections expect these to be implemented. - (BOOL)isNSArray__ { return NO; } - (BOOL)isNSDictionary__ { return NO; } - (BOOL)isNSSet__ { return NO; } - (BOOL)isNSOrderedSet__ { return NO; } - (BOOL)isNSNumber__ { return NO; } - (BOOL)isNSData__ { return NO; } - (BOOL)isNSDate__ { return NO; } - (BOOL)isNSString__ { return NO; } - (BOOL)isNSValue__ { return NO; } @end</span></span></code> </pre><br>  That damm!  What we see, and we see that the SwiftObject class implements the informal protocol NSObject, but the implementation of the methods is completely different.  Now we know the enemy in person, all Swift classes that are not explicitly inherited from NSObject are now implicitly inherited from the SwiftObject class.  Immediately make an amendment that this is the case only for the platform in which interaction with Objectice C is necessary. On non-Objective-C platforms (Linux for example), this is not necessary because it is not necessary. <br><br>  How we learned this is another story.  I think you can also tell a little.  As you know, Swift language is in the public domain on the Apple repository.  No one bothers to download it and build it yourself from the source, which we actually did.  But we went a little further.  Well-known Xcode, starting with version 8, allows you to slip your toolchain.  Feel yes, what does that mean?  This means that you can compile Swift with debug information and embed it in Xcode. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a8a/bf7/e5f/a8abf7e5f4bd590c43f4f026ba9d106e.jpg" alt="image"><br><br>  My colleague did just that, which allowed us to debug the Swift source code directly from Xcode. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bc/b4a/8ea/0bcb4a8eaf21f8a2506ffa0a528a284b.jpg" alt="image"><br><br>  We are a little distracted, we will continue our reasoning.  It is already obvious that the metadata generated in Objective C and generated in Swift are of a different nature.  Any programmer who has written for a long time on Objectice C and at least a little picking rantaym knows this structure <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> objc_class { Class isa OBJC_ISA_AVAILABILITY; <span class="hljs-meta"><span class="hljs-meta">#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE;</span></span></code> </pre><br>  We all know that all objects end up in varying degrees in the form of this structure.  Our favorite NSObject with you is an abstraction that saves the programmer from direct interaction with this structure.  You can read more about it, there are a lot of articles written during the existence of the language, even in Russian.  Let's go back to our swift.  Now a special <b>Metadata</b> class has appeared for storing metadata, which is quite voluminous and provides the basis for all metadata in Swift.  A more detailed description of its structure put in a separate article.  Another point, despite the fact that all Swift objects are able to structure their metadata, they still generate Objective C metadata for compatibility.  That is, each Swift object has two sets of metadata. <br><br>  Let's summarize a bit.  We figured out that NSObject is ugly, and there is no place for it in a new language.  Therefore, in Swift, you can create classes without inheriting them from anything, but in fact for compatibility, they still inherit from SwiftObject.  Making friends with the SwiftObject class and the NSObject class allowed the informal protocol NSObject.  Which allows you to cast the Swift object into id and pass it in Objective C. But it would be nice if it worked there, so each Swift object generates, in addition to its metadata, also Objective C metadata. That's how it is!  Thanks to all!  Health and good mood! </habracut></div><p>Source: <a href="https://habr.com/ru/post/320684/">https://habr.com/ru/post/320684/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320672/index.html">Intellectual system ELIS</a></li>
<li><a href="../320674/index.html">Automatic visualization of the python code. Part Two: Implementation</a></li>
<li><a href="../320676/index.html">Dagger 2. Part Three. New facets of the possible</a></li>
<li><a href="../320678/index.html">Correct problem detection with Zabbix</a></li>
<li><a href="../320682/index.html">Nested logical expressions</a></li>
<li><a href="../320686/index.html">The practice of metaprogramming in C ++: binary search tree at compile time</a></li>
<li><a href="../320690/index.html">Notify at any cost about the fall of the site. Practical advice</a></li>
<li><a href="../320692/index.html">Three product lines and version control</a></li>
<li><a href="../320694/index.html">Hack.me: Another platform for honing skills in the field of information security</a></li>
<li><a href="../320696/index.html">Native Android and iOS code in Qt using the status bar example</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>