<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Managing Microservices with Kubernetes and Istio</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A small story about the advantages and disadvantages of microservices, the concept of Service Mesh and Google tools that allow you to run microservice...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Managing Microservices with Kubernetes and Istio</h1><div class="post__text post__text-html js-mediator-article">  A small story about the advantages and disadvantages of microservices, the concept of Service Mesh and Google tools that allow you to run microservice applications without clogging your head with endless settings of policies, accesses and certificates and quickly find errors hiding not in code, but in microservice logic. <br><br><img src="https://habrastorage.org/webt/os/ta/tg/ostatgvg9ytjgcicnno567t2x_q.jpeg"><br><br>  The article is based <a href="http://2017.devoops.ru/2017/spb/talks/2ua9mgbox2ggisyumaokyk/">on the Craig Box report</a> at our last DevOops 2017 conference. The video and translation of the report is under the cut. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RnBXQpo6Mjs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Craig Box (Craig Box, <a href="https://twitter.com/craigbox">Twitter</a> ) - DevRel from Google, responsible for the direction of microservices and tools Kubernetes and Istio.  His current story is about managing microservices on these platforms. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's start with a relatively new concept called Service Mesh.  This term is used to describe the network of microservices interacting with each other, of which the application consists. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/91b/eb1/7c6/91beb17c6f784bdf2b8d433b44512285.jpg"><br><br>  At a high level, we view the network as a pipe that simply moves bits.  We do not want to worry about them or, for example, about MAC addresses in applications, but we strive to think about the services and connections that they need.  If you look at it from an <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2582%25D0%25B5%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C_OSI">OSI</a> point of view, then we have a third-level network (with routing and logical addressing functions), but we want to think in terms of the seventh (with access to network services). <br><br>  What should a real network of the seventh level look like?  Perhaps we want to see something like tracing traffic around problem services.  To be able to connect to the service, and at the same time the level of the model was raised up from the third level.  We want to get an idea of ‚Äã‚Äãwhat is happening in the cluster, find unintended dependencies, find out the root causes of failures.  We also need to avoid unnecessary overhead, for example, a connection with a high latency or a connection to servers with cold or not fully heated caches. <br><br>  We need to ensure that traffic between services is protected from trivial attacks.  Mutual TLS authentication is required, but without embedding the appropriate modules in each application we write.  It is important to be able to control what surrounds our applications not only at the connection level, but also at a higher level. <br><br>  Service Mesh is a layer that allows us to solve the above problems in the micro-service environment. <br><br><h2>  Monolith and microservices: pros and cons </h2><br>  But first we ask ourselves, why should we solve these problems at all?  How did we do software development before?  We had an application that looks something like this - like a monolith. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c6/385/111/8c63851119c38df240c57cf399a8c344.jpg"><br><br>  It's great: all the code is on our palm.  Why not continue to use this approach? <br>  Yes, because the monolith has its own problems.  The main difficulty is that if we want to rebuild this application, we must redeploy each module, even if nothing has changed.  We have to create an application in the same language or in compatible languages, even if different teams are working on it.  In fact, the individual parts cannot be tested independently of each other.  It's time to change, it's time microservices. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d19/ccb/fd5/d19ccbfd59552751e2171ba6b89ac9bc.jpg"><br><br>  So, we have divided the monolith into pieces.  You may notice that in this example we have removed some of the unnecessary dependencies and stopped using the internal methods called from other modules.  We created services from models that were used earlier, creating abstractions in cases where we need to save state.  For example, each service must have an independent state so that when you access it you don‚Äôt worry about what is happening in the rest of our environment. <br><br>  What was the result? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd2/4da/729/cd24da7292ffd1e23eb4e56ca2842c5f.jpg"><br><br>  We left the world of giant apps, getting what really looks great.  We accelerated development, stopped using internal methods, created services and now we can scale them independently, make the service more without the need to consolidate everything else.  But what is the price of change that we lost in the process? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b4/234/b49/2b4234b49b4dcb5f79840391ee0f5a36.jpg"><br><br>  We had reliable calls within applications, because you just called a function or module.  We have replaced a reliable call inside the module with an unreliable remote procedure call.  But not always the service on the other side is available. <br><br>  We were safe, using the same process inside the same machine.  Now we connect to services that can be on different machines and on an unreliable network. <br><br>  The new approach to the network may be the presence of other users who are trying to connect to services.  Delays have increased, and at the same time their measurement capabilities have decreased.  Now we have step-by-step connections in all services that create one module call, and we can no longer just look at the application in the debugger and find out exactly what caused the crash.  And this problem must somehow be solved.  Obviously, we need a new set of tools. <br><br><h2>  What can be done? </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/fd0/857/5a9/fd08575a99e8a4f4baf64d916eef077b.jpg"><br><br>  There are several options.  We can take our application and say that if <a href="https://en.wikipedia.org/wiki/Remote_procedure_call">RPC</a> does not work the first time, then you should try again, and then again and again.  Wait a while and try again or add a jitter.  We can also add the entry - exit traces to say that there was a start and end of the call, which for me is equivalent to debugging.  You can add infrastructure to provide authentication of connections and teach all of our applications to work with TLS encryption.  We will have to take on the burden of maintaining individual commands and constantly keep in mind the various problems that may arise in SSL libraries. <br><br>  Maintaining consistency across multiple platforms is a thankless task.  I would like the space between applications to become reasonable, so that the possibility of tracking appears.  We also need the ability to change the configuration at run time in order not to recompile or not to restart the migration application.  Here these Wishlist and implements Service Mesh. <br><br><h2>  Istio </h2><br>  Let's talk about <a href="https://istio.io/">Istio</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc8/cdf/0fe/fc8cdf0fe52823fcd092a2dd8de2aeb6.jpg"><br><br>  Istio is a complete framework for connecting, managing and monitoring the microservice architecture.  Istio is designed to work on top of Kubernetes.  He himself does not deploy software and does not care to make it available on the machines that we use for this purpose with containers in Kubernetes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ddb/e05/1e8/ddbe051e8e8f90273b1bd686d1f5c90e.jpg"><br><br>  In the figure we see three different slices of machines and the blocks that make up our microservices.  We have a way to group them together using the mechanisms provided by Kubernetes.  We can target and say that a specific group, which may have automatic scaling, is attached to a web service or may have other deployment methods, will contain our web service.  At the same time, we do not need to think about machines, we operate with terms of the level of access to network services. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/966/45b/f3c/96645bf3c0ff9d2104622a84edcafeeb.png"><br><br>  This situation can be represented as a diagram.  Consider an example where we have a mechanism that does some image processing.  On the left is the user, the traffic from which comes to us in microservice. <br><br>  To receive payment from the user, we have a separate payment microservice that calls an external API, which is located outside the cluster. <br><br>  To handle user logins to the system, we have an authentication microservice, and it has states saved, again, outside of our cluster in the <a href="https://cloud.google.com/sql/%3Futm_source%3Dgoogle%26utm_medium%3Dcpc%26utm_campaign%3Demea-ru-all-ru-dr-skws-all-all-trial-e-gcp-1003963%26utm_content%3Dtext-ad-none-any-DEV_c-CRE_253527309029-ADGP_Hybrid%2B%257C%2BAW%2BSEM%2B%257C%2BSKWS%2B~%2BEXA_1%253A1_RU_RU_Storage_SQL_cloud%2Bsql-KWID_43700016973789357-kwd-18507329590-userloc_1012017%26utm_term%3DKW_cloud%2520sql-ST_cloud%2Bsql%26ds_rl%3D1245734%26gclid%3DEAIaIQobChMItZTL2Ir_3AIVCYuyCh0pWAgOEAAYASAAEgK_VvD_BwE%26dclid%3DCMuw9NmK_9wCFUwX4Aodi5EC6g">Cloud SQL database</a> . <br><br>  What does Istio do?  Istio improves Kubernetes.  You set it up using the alpha function in Kubernetes called Initializer.  When deploying software, kubernetes will notice it and ask if we want to change and add another container inside each kubernetes.  This container will handle the paths and routing, be aware of all changes to the application. <br><br>  This is how the scheme looks like with Istio. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/398/f41/c6d/398f41c6dcbe3e0dea4741e71204d7bd.jpg"><br><br>  We have external machines that provide inbound and outbound proxies for traffic in a particular service.  We can unload functions that we already talked about.  We do not need to teach the application how to perform telemetry or tracing using TLS.  But we can add other things inside: automatic interruption, speed limit, <a href="https://martinfowler.com/bliki/CanaryRelease.html">canary release</a> . <br><br>  All traffic will now pass through proxy servers on external machines, and not directly to services.  Kubernetes does everything on the same IP address.  We will be able to intercept traffic that would go to the front or end services. <br><br>  The external proxy that uses Istio is called <a href="https://www.envoyproxy.io/">Envoy</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a00/3ed/04f/a003ed04fc566d4f27b1e5df70e3ae21.jpg"><br><br>  Envoy is actually older than Istio, it was developed in Lyft.  Works in production for over a year, launching the entire infrastructure of microservices.  We chose Envoy for the Istio project in collaboration with the community.  Thus, Google, IBM and Lyft are the three companies that are still working on it. <br><br>  Envoy is written in C ++ version 11. It has been in production for more than 18 months before becoming an open source project.  It does not take a lot of resources when you connect it to your services. <br><br>  Here are a few things that Envoy can do.  This is the creation of a proxy server for HTTP, including HTTP / 2 and protocols based on it, such as gRPC.  It can also redirect to other protocols at the binary level.  Envoy controls your infrastructure zone so you can make your part autonomous.  It can handle a large number of network connections with retries and waits.  You can set a certain number of attempts to connect to the server before stopping the call and send your servers information that the service is not responding. <br><br>  No need to worry about restarting the application to add configuration to it.  You simply connect to it using an API that is very similar to kubernetes, and change the configuration at runtime. <br><br>  The Istio team contributed a lot to the UpStream Envoy Platform.  For example, injection error notification.  We made it so that we could see how the application behaves if the number of object requests that failed has been exceeded.  They also implemented the graphical display and traffic sharing features to handle cases when canary deployment is used. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/068/0e1/351/0680e13511f2d5dc5eeac4bada02c05c.jpg"><br><br>  The figure shows what the Istio system architecture looks like.  We will take only two microservices that we mentioned earlier.  Ultimately, everything in the scheme is very similar to the software-defined network.  The Envoy proxy, which we deployed with applications, migrates traffic using IP tables in the namespace.  The control panel is responsible for managing the console, but it does not handle the traffic itself. <br>  We have three components.  Pilot, who creates the configuration, looks at the rules that can be changed using the Istio control panel API, and then updates Envoy so that it behaves like a cluster discovery service.  Istio-Auth serves as a certificate authority and sends TLS certificates to proxy servers.  The application does not require SSL, they can connect via HTTP, and the proxy will handle all of this for you. <br><br>  Mixer processes requests to make sure that you comply with the security policy, and then transmits telemetry information.  Without making any changes to the application, we can see everything that happens inside our cluster. <br><br><h2>  Advantages of Istio </h2><br>  So let's talk more about the five things we get from Istio.  First consider <b>the traffic management</b> .  We can separate traffic control from infrastructure scaling, so earlier we could do something like 20 application instances and 19 of them will be on the old version, and one on the new, that is, 5% of the traffic will fall on the new version.  With Istio, we can deploy any number of instances that we need, and at the same time indicate what percentage of traffic should be sent to new versions.  Simple separation rule. <br><br>  Everything can be programmed on the fly using rules.  Envoy will be updated periodically as the configuration changes, and this will not lead to service failures.  Since we work at the level of access to network services, we can look at the packages, and in this case it is possible to climb into the user agent, which is located on the third level of the network. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/810/1a1/7d5/8101a17d596613c7cc6871ce0f7d238a.png"><br><br>  For example, we can say that any traffic from the iPhone follows a different rule, and we are going to send a certain amount of traffic to a new version that we want to test for a specific device.  The internal calling microservice can determine which specific version it needs to connect to, and you can transfer it to another version, for example, 2.0. <br><br>  The second advantage is <b>transparency</b> .  When you have a presentation inside a cluster, you can understand how it is done.  We do not need to create a toolkit for metrics during the development process.  Metrics are already in each component. <br><br>  Some believe that it is enough to keep a record of logs for monitoring.  But in fact, all we need is to have such a universal set of indicators that can be fed to any monitoring service. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/099/627/ab5/099627ab5e7b0615bb2e3725ce118160.jpg"><br><br>  This is the Istio toolbar, created using the Prometheus service.  Do not forget to deploy it inside the cluster. <br><br>  The example in the screenshot shows a number of monitored parameters specific to the entire cluster.  You can display more interesting things, for example, what percentage of applications gives more than 500 errors, which means failure.  The response time is aggregated in all calling and answering instances of services within the cluster; this functionality does not require any configuration.  Istio knows that Prometheus supports, and he knows what services are available in your cluster, so Istio-Mixer can send metrics to Prometheus without additional settings. <br>  Let's see how it works.  If you call a specific service, the proxy service sends information about that call to the Mixer, which captures parameters such as waiting for a response time, code status, and IP.  It normalizes them and sends them to any servers that you have configured.  Especially for displaying the main indicators, there is a Prometheus service and FLUX DB adapters, but you can also write your own adapter and output data in any format for any other application.  And you will not have to change anything in the infrastructure if you want to add a new metric. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/477/8cf/7ea/4778cf7ea5f78c0d8dca61aaaf7756c5.jpg"><br><br>  If you want to conduct a more in-depth study, then use the <a href="https://zipkin.io/">Zipkin</a> distributed tracing <a href="https://zipkin.io/">system</a> .  Information on all calls that are routed through the Istio-Mixer can be sent to the Zipkin.  There you will see the whole chain of microservice calls when answering the user and you will easily find a service that delays the processing time. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c0/820/3e5/1c08203e54bc8fc2cb3a0f6da427e497.jpg"><br><br>  At the application level, there‚Äôs almost no need to worry about tracing.  Envoy itself sends all the necessary information to Mixer, which sends it to the trace, for example, to Zipkin, <a href="https://cloud.google.com/trace/">stackdriver trace</a> from Google or any other user application. <br><br>  Let's talk about <b>fault tolerance and efficiency</b> . <br><img src="https://habrastorage.org/getpro/habr/post_images/da4/c03/b1b/da4c03b1b08ebbc652e332c680b79599.jpg"><br><br>  Timeouts between calls to services are needed to test the health of, first of all, load balancers.  We introduce errors in this relationship and see what happens.  Consider an example.  Suppose there is a connection between service A and service B. We are waiting for a response from the video service 100 milliseconds and give only 3 attempts if the result is not obtained.  In fact, we are going to take it for 300 milliseconds before it reports a failed connection attempt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2c8/858/101/2c885810146ca5a44c88b42b2b1552c5.jpg"><br><br>  Further, for example, our movie service should see the movie rating through another microservice.  The timeout rating is 200 milliseconds and two call attempts are given.  Calling the video service may cause you to wait 400 milliseconds in case the star rating is out of access.  But, we remember, after 300 ms the movie service will report that it is non-working, and we will never know the real reason for the failure.  Using timeouts and testing what happens in these cases is a great way to find all sorts of ingenious bugs in your microservice architecture. <br><br>  Let's see now what's with efficiency.  The kubernetes balancer itself operates only at the level of the fourth layer.  We invented an input constructor for load balancing from layer two to layer seven.  Istio is implemented as a balancer for the network layer with access to network services. <br><br>  We perform TLS-offloading, so we use modern, well-doped SSL in Envoy, with which we don‚Äôt have to worry about vulnerabilities. <br><br>  Another advantage of Istio is <b>security</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/902/a1d/fcc/902a1dfcc83b7bbb4bc3d49463c5682b.jpg"><br><br>  What are some basic security features in Istio?  Service Istio-Auth works in several directions.  A common framework and identification standards for <a href="https://spiffe.io/">SPIFFE</a> services are <a href="https://spiffe.io/">used</a> .  If we are talking about traffic flow, then we have the Istio Certificate Authority, which issues certificates for service accounts that we run inside the cluster.  These certificates are SPIFFE compliant and are distributed by Envoy using the kubernetes protection mechanism.  Envoy uses keys for two-way TLS authentication.  Thus, backend applications receive identifiers on the basis of which a policy can already be organized. <br><br>  Istio independently maintains root certificates so that you don‚Äôt worry about revocation and expiration.  The system will respond to automatic scaling, so by entering a new entity, you get a new certificate.  No manual settings.  You do not need to configure a firewall.  Users will use network policy and kubernetes to implement firewalls between containers. <br><br>  Finally, the <b>application of policies</b> .  Mixer is an integration point for infrastructure backends, which you can expand with Service Mesh.  Services can easily move within a cluster, be deployed in multiple environments, in the cloud or locally.  Everything is designed for the operational control of calls that go through Envoy.  We can allow and prohibit specific calls, set preconditions for the missed calls, limit their speed and number.  For example, you allow 20 free queries per day for some of your services.  If the user has made 20 requests, the subsequent ones are not processed. <br><br>  Prerequisites may include such things as, for example, passing an authentication server, ICL and its presence in the white list.  Quota management can be used when it is required that everyone who uses the service has the same access speed.  Finally, Mixer collects telemetry processing results for requests and responses.  This allows manufacturers and users to look at this telemetry using services. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/202/d7a/975/202d7a975db3a50477ac367ea4d6f1e4.jpg"><br><br>  Remember the first slide with the photo app from which we started studying Istio?  All of the above is hidden under such a simple form.  At the top level, everything you need will be automatically executed.  You will deploy the application and will not worry about how to define a security policy or configure some routing rules.  The application will work exactly as expected. <br><br><h2>  How to start working with Istio </h2><br>  Istio supports previous versions of kubernetes, but the new function of the initializer, which I talked about, is in versions 1.7 and higher.  This is the alpha function in kubernetes.  I recommend using Google Container Engine Alpha clusters.  We have clusters that you can turn on for a certain number of days and at the same time use all the production capabilities in them. <br><br>  First of all, Istio is an open source project on github.  We have just released version 0.2.  In version 0.1, it was possible to manage objects within the kubernetes namespace of the same name.  Since version 0.2, we support working in our own namespace and the kubernetes cluster.  We also added access to manage services that run on virtual machines.  You can deploy Envoy on a virtual machine and secure the services that run on it.  In the future, Istio will support other platforms, such as <a href="https://www.cloudfoundry.org/">Cloud Foundry</a> . <br><br>  A quick guide to installing the framework is <a href="https://istio.io/docs/setup/kubernetes/quick-start/">here</a> .  If you have a cluster running the Google Container Engine on 1.8 with alpha functions enabled, then installing Istio is just one command. <br><br><blockquote>  If you liked this report, come on October 14 to the <a href="https://devoops.ru/">DevOops 2018</a> conference (Peter): there you can not only listen to the reports, but also chat with any speaker in the discussion area. </blockquote></div><p>Source: <a href="https://habr.com/ru/post/423011/">https://habr.com/ru/post/423011/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../422999/index.html">Create your own dataset with aliens</a></li>
<li><a href="../423003/index.html">Peskov: Roscomnadzor requirements for Facebook are not super complex</a></li>
<li><a href="../423005/index.html">How Yandex.DZen, the caching plugin for WordPress and hosting have increased my pressure</a></li>
<li><a href="../423007/index.html">‚ÄúFaint, but good‚Äù: how we took the students to practice</a></li>
<li><a href="../423009/index.html">SENS-Diagnosis. Protein glycation biomarkers</a></li>
<li><a href="../423013/index.html">How to organize your dependencies in a Vue application</a></li>
<li><a href="../423015/index.html">Git: Common Errors and Corrections</a></li>
<li><a href="../423017/index.html">Reel: ten cult reel tape recorders - tell and show</a></li>
<li><a href="../423021/index.html">Online hackathon from Naviaddress</a></li>
<li><a href="../423023/index.html">Why do developers need to teach</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>