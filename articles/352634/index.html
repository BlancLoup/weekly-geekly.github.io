<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Network Optimization for Unreal Engine 4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago, in the official group UE4 in vk, I asked which topics would be interesting for the community to talk about them :) One of the popular...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Network Optimization for Unreal Engine 4</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/0b/kf/4o/0bkf4ofgpa3hpke5cn4nvpjb4la.jpeg"></p><br><p>  Not so long ago, in the official group UE4 in vk, I <a href="https://vk.com/unreal_engine_4%3Fw%3Dwall-68573701_222873">asked</a> which topics would be interesting for the community to talk about them :) One of the popular requests was to work with the network on the engine. </p><br><p>  In the beginning, I did not plan to somehow disclose or mention this topic, but then I thought that it would be nice to issue a ‚ÄúBest Practices‚Äù even for myself and my team. </p><br><p>  So, if you're wondering how we made the network for our <strong><a href="http://awa.my.com/">Armored Warfare: Assault</a></strong> , welcome under cat. </p><a name="habracut"></a><br><hr><br><p>  It is impossible to imagine the Unreal Engine apart from the Unreal Tournament, a leitmotif going through all versions of the engine.  As a result, one of the strengths of the UE4 is a powerful network toolkit integrated into the engine at the basic level.  By my personal assessment, the only engine that would equally scrupulously approach questions at the same level is the Quake 3 engine. </p><br><p>  The presence of high-quality technology does not deprive us of the need to think when developing.  Unfortunately, I have seen quite a few projects where an irresponsible attitude to the organization of the work of the network led to disastrous results. </p><br><p>  <em>This article is never a ‚Äúbeginner‚Äôs guide‚Äù or ‚Äúa detailed description of how things work.‚Äù</em>  <em>No, this is a certain exaggerated view of the principles that allow you to effectively optimize the network.</em> </p><br><h2 id="kak-vsyo-ustroeno">  How things are arranged </h2><br><p>  To start working on multiplayer in UE4, you will need to understand the three available communication paths: </p><br><ul><li>  Replication of variables: from server to client, and not otherwise.  The client cannot under any circumstances change the variable so that it changes its value on the server. </li><li>  RPC: from server to client. </li><li>  RPC: from client to server. </li></ul><br><p>  The third way is the only way to report any data from the client to the server.  Variable replication (first path) is used to synchronize ector states between the server and clients.  Sending RPC from server to client (second path) - event model for sending specific data. </p><br><p>  In short, everything works like this.  Each replicated ector has a NetUpdateFrequency parameter that sets how many times per second the ector will check its state for ‚Äúwhat would I exchange over the network‚Äù.  By default, this parameter is insanely <strong>100.f</strong> , which means: if your ector is replicated, attempts to synchronize and send data will be every tick. </p><br><p>  The consequences are obvious and sad: it becomes an elementary task to hammer in the network with packages.  The load on the server CPU increases.  Everything lags, ‚Äúnothing works,‚Äù ‚Äúthe character is teleported,‚Äù ‚Äúother players are trembling,‚Äù and so on, in the very simple way, on seemingly simple projects. </p><br><p>  So we come to the very first rule: <strong>set adequate NetUpdateFrequency for all replicable ectors</strong> . </p><br><p>  What is "adequate" - the question, as always, is open.  For a hardcore quake shooter, everything that concerns a character ‚Äî his movement and weapon ‚Äî must be synchronized with the maximum frequency.  But this is a specific case, and if you are working on such a project, you will not have enough ‚Äúbasic‚Äù knowledge and approaches - dig deeper if you want to get a quality product. </p><br><p>  In a certain "average" case - arcades, MOBA, mobile toys, as well as "slow shooters" a la tanks and others - the frequency of network updates can and should be much lower.  In AW: Assault, we use the frequency of updating the state of the tank <strong>10 times per second</strong> .  I also know projects that work based on the frequency of network updates of the main character 6-8 times per second. </p><br><p>  Other objects - various "capture points", "flags", "cartridges", "game states" - can be updated even less often.  A good example: by default, the PlayerState engine class is replicated only once per second, and <strong>rightly so</strong> .  If suddenly a change in the ector state should be delivered as quickly as possible, there is always the possibility to call <strong>ForceNetUpdate ()</strong> . </p><br><p>  I note that the ector components inherit its network update frequency, so the immediately occurring "separation" of one ector into parts with different update rates is not a trivial task.  More precisely: if a component requires a different frequency than the ector as a whole is able to live, you must carefully cut it into a separate entity.  If a component can live on the network ‚Äúslower‚Äù than its owner, the owner does not update every tick - this is a normal situation. </p><br><p>  Rule two: <strong>reliable RPC should be seriously justified</strong> .  In our department there is a joke that every reliable rpc function is issued ‚Äúagainst the signature‚Äù of the manager.  In every joke share jokes. </p><br><p>  We must remember that it is expensive.  Highly.  The overhead for RPC as such is not as large as the possible consequences.  Handle carefully, as with a bottle of nitroglycerin.  Especially in the case of <strong>multicast</strong> .  The worst thing that can happen after you have ceased to "teleport" is to disconnect the client from the server due to an overflow of such a thing as a reliable buffer.  The network architecture built on such events becomes hypersensitive to ping and packet loss. </p><br><p>  A simple example: you want to send a notification about an action from the server to the client.  Suppose you are doing an alcoholic simulator online, and your character has every tick regen liver that exists as a separate component.  All customers really need to know every step of the "treatment" to beautifully show it on the screen (multicast, reliable).  Each tick you send RPC LiverHealed (float HealedHeath).  You test in the editor on two clients: beauty, everyone is happy.  And here, a live situation: the client pledged, the loss of packets, it is necessary to send all the RPC that had accumulated in half a second, and you discover how the patient happily flies out from the server. </p><br><p>  Obviously, at a minimum, there is no need to send every server tick to RPC, if NetUpdateFrequency is many times less - it will just stop the queue.  It is necessary to accumulate these values ‚Äã‚Äãand send less often.  And think again, is it reliable data, and if so, can you manage to replicate the variable, and if not, make unreliable.  In many cases, it is also worth considering whether the client himself can not calculate whether an event occurred, based on his data about the game world (the same treatment for a character's liver is the change in her health for a client tic). </p><br><h2 id="konceptualnye-lovushki">  Conceptual traps </h2><br><p>  Or rather, a couple of things worth mentioning. </p><br><ul><li><del>  When the variable - the replicated UObject, is reset, OnRep will not be called and will cease to be called on the client in the future.  It sounds like a bug, and honestly, I do not remember why it works that way.  Enough to know about it and take into account when developing. </del>  <em>I checked on a synthetic test for UE 4.18: everything works as it should, so the information is no longer relevant.</em> </li><li>  Calling client RPC on the server does not perform the function on the server, only sends the command to execute it on the client.  If you need to execute it on the server, you must manually call Implementation. </li><li>  If the ector is rarely updated over the network (for example, PlayerState), use a reliable RPC there twice with caution.  During the time between synchronizations, you can easily get a buffer if you don‚Äôt think about it.  Ideally, such special networking classes should tick and update over the network in single order frequency. </li></ul><br><h2 id="setevye-triki-i-priyomy">  Network tricks and receptions </h2><br><p>  Aimed at optimizing the load on the network, as well as optimizing the load on the CPU. </p><br><h3 id="globalnye-steyty">  Global states </h3><br><p>  By the way, the third rule: <strong>if you can do without replicating ectors, do it</strong> . </p><br><p>  Two examples from our AW: Assault, which implement this rule, but in different ways: </p><br><ul><li>  Destroyable trees.  They are not critical for gameplay, so they simply do not replicate.  Each client will drop his own tree, based on the data available to him.  It is not at all scary that the real picture of the world in this regard varies between the server, clients and between clients. </li><li>  Destructible objects of the environment.  Fences, cars, fences.  They directly affect the gameplay, you can ‚Äúhide‚Äù behind them until the object is destroyed.  Therefore, it is required that these objects on all clients reflect the real state of affairs.  This global state is used for synchronization. </li></ul><br><p>  In the second example, the whole concept can be described as: </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** Array of bit masks for minimization of space used for destructible actors states. Replication handled by OnRep_DestructableMasks method */</span></span> UPROPERTY(ReplicatedUsing=OnRep_DestructableMasks) TArray&lt;int32&gt; DestructedActorsMasks; <span class="hljs-comment"><span class="hljs-comment">/** Handles replication of destructible actors masks */</span></span> UFUNCTION() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRep_DestructableMasks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p>  <strong>Each int32 encodes the state of as many as 32 objects</strong> .  On stage we can have over a thousand such objects.  In the case of coding up to 1024 objects, it would be possible to manage with only two int32 (multiplication of bit masks), but we have so far left the array replication, since  even the current solution works without network load.  At the stage of loading the map, the transfer of conditional forty ints over the network is not too big data, and during the battle not so many objects die at the same time.  The engine takes care of optimal replication of an array when some of its fields change. </p><br><p><img src="https://habrastorage.org/webt/qr/z6/6o/qrz66o3-i_rj3fr3t8jhni_sfy8.jpeg"></p><br><p>  This approach works on the basis that static objects have a clear loading order both on the server and on the client.  They can be cached into an array and replicate only the indices of modified objects.  And let now only binary logic is implemented (alive / destroyed), such an approach will be justified even if additional fields appear (for example, "health" and "penetrability"), since  These are homogeneous ectors living in large numbers on the map. </p><br><p>  Want to make a completely destructible world of walls?  Work with them through such states.  <strong>Several ints in the form of bit masks will enable to encode thousands of destructible objects</strong> .  The ‚Äústandard‚Äù path through the replication of each such ector separately will easily kill you both the network and the server‚Äôs CPU (for checking who needs to be replicated there and to whom, and who will not). </p><br><h3 id="upakovka-dannyh">  Data packing </h3><br><p>  In general, I have already touched on this topic in the paragraph above, only indirectly: there we pack information about the state of thousands of objects on the scene into an array of bit masks.  However, the same technique should be used for flags inside replicable ectors. </p><br><p>  At a certain stage, we came to the conclusion that there were more than a dozen of the usual replicated Boolean flags in a tank.  These are the usual gameplay states ‚Äúis a tank drowning‚Äù, ‚Äúarson‚Äù, ‚Äútarget is locked‚Äù, ‚Äúdead‚Äù and others. </p><br><p>  As a result, our core programmer wrote a <strong>proxy class for replicating such states</strong> .  Usage looks like this: </p><br><pre> <code class="cpp hljs"> RepOwnerFlags .Add(&amp;bEnableLockTarget) .Add(&amp;bCanMove) .Add(&amp;bIsDrowning) .Add(&amp;bInWater) .Build(); RepPublicFlags .Add(&amp;bIsDying, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"OnRep_IsDying"</span></span>) .Add(&amp;bIsMoving, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"OnRep_IsMoving"</span></span>) .Add(&amp;bIsTurning, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"OnRep_IsTurning"</span></span>) .Add(&amp;bIsInFire) .Add(&amp;bIsEngineBurning, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"OnRep_IsEngineBurning"</span></span>) .Add(&amp;bHasMinimapObservers) .Build();</code> </pre> <br><p>  RepOwnerFlags and RepPublicFlags are replicable class variables that <strong>act</strong> as a <strong>wrapper for uint64</strong> .  The variables themselves have become ordinary, not replicable from the point of view of the engine: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/** Notifies of death */</span></span> UFUNCTION() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRep_IsDying</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** Identifies if pawn is in its dying state */</span></span> UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Death) <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bIsDying;</code> </pre> <br><p>  It is also a good idea to <strong>pack bool's in uint8: 1 inside replicated structures</strong> , if there are several of them. </p><br><p>  And yes, the same rule applies for RPC functions.  You send some bulls - pack them.  With floats in a vector and int8 (if possible) instead of int32, the same situation. </p><br><h3 id="zhirnye-ektory">  Fat ectors </h3><br><p>  It is easy to imagine a situation where starting replication of an ector takes a decent amount of time.  For example, data on tank armor in our case (inside the tank consists of a large number of pieces, with their parameters, depending on the leveling). </p><br><p>  When a large chunk of data arrives for replication from the ector, the network is considered overloaded, and <strong>no other ectors are replicated all this time</strong> . </p><br><p>  In this case, a good way to avoid network saturation is to place this data piece by piece in an array and <strong>replicate it in chunks</strong> , checking for probable saturation: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AMyActor::ReplicateSubobjects(class UActorChannel **Channel, class FOutBunch **Bunch, FReplicationFlags **RepFlags) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> NetDriver = Channel-&gt;Connection-&gt;GetDriver(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int32 i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MyDataArray.Num(); i++) { <span class="hljs-comment"><span class="hljs-comment">// Check for saturation if (((Channel-&gt;Connection-&gt;QueuedBits) + Channel-&gt;Connection-&gt;SendBuffer.GetNumBits() + Bunch-&gt;GetNumBits()) &gt;= 0) { return WroteSomething; } auto DataObject = MyDataArray[i]; if (DataObject != nullptr) { WroteSomething |= Channel-&gt;ReplicateSubobject(DataObject, **Bunch, **RepFlags); } } return WroteSomething; }</span></span></code> </pre> <br><p>  MyDataArray is the same data.  This approach allows you to avoid the "hang" of the entire network when creating an ector over the network. </p><br><p>  It is worth considering that in this case the ector will be created, shown and revived before all its properties are replicated.  If these properties determine its appearance and behavior, it is a good idea to hide it until the end of the full network initialization. </p><br><h3 id="uslovie-a-ne-rezultat">  Condition, not result </h3><br><p>  From the point of view of network optimization, it will be correct for clients to replicate the condition that generates the calculations, and not the final result of such calculations.  For example, information about the point where a character ‚Äúlooks‚Äù can generate all calculations about rotation and aiming, which can be calculated and smoothed over on the client. </p><br><p>  On the other side of the coin is client optimization.  The less the client thinks, the more pleasant it is to play on the same mobile phones. </p><br><h3 id="kvantizaciya-vektorov">  Vector Quantization </h3><br><p>  It is rarely necessary to replicate a vector with complete accuracy.  Therefore, <strong>for the replication of vectors, you should use special classes</strong> optimized for this case: FVector_NetQuantize, FVector_NetQuantize10, FVector_NetQuantize100 and FVector_NetQuantizeNormal. </p><br><p>  From personal practice: accuracy above FVector_NetQuantize100 was never required, the vast majority for the network use FVector_NetQuantize and FVector_NetQuantizeNormal. </p><br><h3 id="ne-ispolzovanie-setevoy-relevantnosti">  (Un) use of network relevance </h3><br><p>  If you do not know why you need network relevance for game characters, <strong>it is better to turn it off</strong> .  The default settings in the engine are calculated more for quake-like shooters (UT ears, which I have already mentioned).  They are not suitable for games with an open (visually) world, and the case with ‚Äúfat‚Äù ectors is also not very pleasant. </p><br><p>  The server, based on NetCullDistanceSquared (distance squared) between the ector and the player, decides whether this ector should exist on a specific client.  If the distance between them is greater, the ector will be removed from the client; if less, it is re-created on the client.  This operation is performed <strong>with a timeout</strong> of 5 seconds (default value RelevantTimeout). </p><br><p>  The key here is to <strong>re-create</strong> .  In the case of a fat ector, this process can either clog the network or lead to a frieze for the time the object is spawned (if its resources have been unloaded from memory).  In the case of an open world, this is also an appearance in the middle of the location ‚Äúfrom nowhere‚Äù.  If your actors are constantly running "on the border" (by default, it runs 150 meters from your character), this process can be unpleasant. </p><br><p>  At the same time, properly configured relevancy can significantly save you traffic and nerves, <strong>if the gameplay allows for such a setting</strong> .  In the case of our AWA, network relevance is not used in any way: unlike the usual scheme of many, ‚Äúa tank is visible on the client only when it is detected,‚Äù here you can see the enemy‚Äôs tank through the entire map. </p><br><p>  Of course, you can manage relevance not only on the basis of the built-in mechanism, but also by redefining <strong>AActor :: IsNetRelevantFor</strong> (...).  Sometimes this is necessary not so much because of network optimization considerations, but rather to protect against cheaters.  On the example of MOBA: characters hidden in the fog of war should not be replicated to the client in order to avoid the most banal maphacks.  <strong>No data - no candy.</strong> </p><br><h2 id="otladka-seti">  Network debugging </h2><br><h3 id="pleytesty">  Playtests </h3><br><p>  Play  Test it.  Check.  Not in the editor and greenhouse conditions, but in real - with a client assembled and a server deployed in combat conditions.  <strong>A local server on a development machine is a bad idea</strong> , especially if later you plan to use virtual machines, where usually there are ~ 4000 flops of performance. </p><br><p>  And yes, no matter how convenient the network testing in the editor is, the real build, especially when it comes to consoles or mobile devices, is still a separate universe.  Customer behavior in non-ideal conditions will be different. </p><br><h3 id="network-profiler">  Network profiler </h3><br><p>  Included with the engine is a great utility: <strong><a href="https://docs.unrealengine.com/en-us/Gameplay/Tools/NetworkProfiler">NetworkProfiler</a></strong> </p><br><p>  Just recently, this is how we searched for the cause of disconnect on one particular tank: </p><br><p><img src="https://habrastorage.org/webt/wi/eu/us/wieuusfgm6twuerz9nkgyg-pw20.png"></p><br><p>  Profiler has its own oddities and works limitedly on mobile devices, but gives an <strong>understanding of the overall picture of your network data</strong> . </p><br><p>  It is most useful for detecting suspiciously ‚Äúfat‚Äù data and network spikes.  <strong>Required.</strong> </p><br><h3 id="simulyaciya-plohoy-seti">  Bad Network Simulation </h3><br><p>  Playtests can only reveal obvious network problems.  Unfortunately, the real problems begin when your paying user sits in a distant village, he has a Wi-Fi router and a three-meter antenna on the house through which the Internet goes to this router, and a cell phone tower is three kilometers away.  With <strong>packages in this configuration</strong> , <strong>anything can happen</strong> , despite the fact that the ping will be quite adequate. </p><br><p>  UE4 out of the box can simulate various network conditions, such as ping delay, packet loss, or the wrong order.  Read more about it here: <strong><a href="https://www.unrealengine.com/en-US/blog/finding-network-based-exploits">Finding Network-based Exploits</a></strong> </p><br><p>  The epic article provides an example of configuring the network by specifying parameters in ini, which is not very convenient for testing.  Moreover, for full testing it is more convenient to have several presets and switch between them at runtime, without restarting the editor. </p><br><p>  This is done like this: in the <strong>UE4 / Engine / Binaries /</strong> folder you create a file, for example, network_bad.txt, of such content </p><br><pre> <code class="cpp hljs">Net PktLoss=<span class="hljs-number"><span class="hljs-number">1</span></span> Net PktOrder=<span class="hljs-number"><span class="hljs-number">0</span></span> Net PktDup=<span class="hljs-number"><span class="hljs-number">0</span></span> Net PktLag=<span class="hljs-number"><span class="hljs-number">120</span></span> Net PktLagVariance=<span class="hljs-number"><span class="hljs-number">0</span></span> p.netshowcorrections <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  Now you can call <strong><em>exec network_bad.txt</em></strong> directly in the editor console and apply the described settings.  As you already understood, this is just a set of console commands "packed" into a file. </p><br><h3 id="monitoring-traffika">  Traffic monitoring </h3><br><p>  Raise dedicited.  You are arranging playtest on it.  See traffic on a single port.  Estimate how much is the average traffic per entry and exit. </p><br><p>  This item is very obvious, but for some reason, many people neglect it. </p><br><h2 id="posleslovie">  Afterword </h2><br><p>  I tried to briefly talk about all the things that I consider to be fundamentally important at a general level when working on multiplayer in the archive.  You can talk endlessly about lag compensation, network interpolation / extrapolation, network architecture features, but all this will be based on the same principles and approaches described above.  Yes, and deserves a separate article. </p><br><p>  Our result on AW: Assault - the ability <strong>to play on the 3G network</strong> without any problems and significant lags.  Even Edge (albeit with a stable connection) can be called sufficient.  In my opinion, these are very decent numbers for 16 player multiplayer.  In addition to the thickness of the channel, we are also not very critical to ping, unlike many other games. </p><br><p>  If you have something to add, refute or discuss - welcome to the comments!  :) </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/352634/">https://habr.com/ru/post/352634/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352624/index.html">The Metrix has you ...</a></li>
<li><a href="../352626/index.html">Storage options for cryptographic keys</a></li>
<li><a href="../352628/index.html">Rumors about the cancellation of the Kotelnikov theorem are greatly exaggerated</a></li>
<li><a href="../352630/index.html">As Google Adwords experts helped me to throw away 150,000 UAH (about $ 6000) per month or why I will not ...</a></li>
<li><a href="../352632/index.html">True implementation of a neural network from scratch. Part 2. Recognition of numbers</a></li>
<li><a href="../352636/index.html">20 modules for Node.js, which is useful to know</a></li>
<li><a href="../352640/index.html">The golden rule of git rebase</a></li>
<li><a href="../352644/index.html">GitLab 10.6 released: CI / CD for GitHub and in-depth integration with Kubernetes</a></li>
<li><a href="../352646/index.html">3CX voice application development: an introduction for beginners</a></li>
<li><a href="../352648/index.html">TeamLead Conf review: 2 days with 2 tracks, 25 reports, 474 participants, the pain is immeasurable</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>