<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Taming the Snake with Reactive Flows</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The web is moving very fast these days and we all know it. Today, Reactive Programming is one of the hottest topics in web development and with framew...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Taming the Snake with Reactive Flows</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cc/d9/59ccd967bd07b010702016.png"></div><br>  The web is moving very fast these days and we all know it.  Today, Reactive Programming is one of the hottest topics in web development and with frameworks such as Angular or React, it has become much more popular, especially in the modern world of JavaScript.  The community has undergone a massive transition from imperative programming paradigms to functional reactive paradigms.  Nevertheless, many developers try to deal with this and are often overwhelmed by its complexity (large API), a fundamental shift in thinking (from imperative to declarative) and a multitude of concepts. <br><br>  Although this is not the simplest topic, but as soon as we are able to understand it, we will ask ourselves how we could live without it? <br><a name="habracut"></a><br>  This article is not intended to be introduced into reactive programming, and if you are a complete newbie to it, we recommend the following resources: <br><br><ul><li>  Introduction to Reactive Programming ( <a href="https://egghead.io/courses/introduction-to-reactive-programming">Introduction to Reactive Programming</a> ) by Andr√© Staltz </li><li>  RxJS 5 Thinking Reactively ( <a href="https://www.youtube.com/watch%3Fv%3D3LKMwkuK0ZE">RxJS 5 Thinking Reactively</a> ) by <a href="https://twitter.com/BenLesh">Ben Lesh</a> </li><li>  RxJS 5 Ultimate ( <a href="https://chrisnoring.gitbooks.io/rxjs-5-ultimate/content/">RxJS 5 Ultimate</a> ) by <a href="https://twitter.com/chris_noring">Chris Noring</a> </li><li>  Learning RxJS ( <a href="https://www.learnrxjs.io/">Learn RxJS</a> ) by <a href="https://twitter.com/btroncone">Brian Troncone</a> </li><li>  RxJS 5 <a href="https://gist.github.com/btroncone/d6cf141d6f2c00dc6b35">Example Operators</a> ( <a href="https://gist.github.com/btroncone/d6cf141d6f2c00dc6b35">RxJS 5 Operators By Example</a> ) by <a href="https://twitter.com/btroncone">Brian Troncone</a> </li></ul><br>  The purpose of this publication is to learn to think reactively by building a classic video game that we all know and love - Snake.  That's right, a video game!  This is a fun but complex system that contains a lot of external state, for example: an account, timers or player coordinates.  For our version, we will widely use Observables (observables) and use several different operators to completely avoid third-party influences on the external state.  At some point, you may be tempted to save the state outside the Observable stream, but remember that we want to use reactive programming and not rely on a separate external variable that preserves the state. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Note</b>  We will use <b>HTML5</b> and <b>JavaScript</b> exclusively with <a href="http://reactivex.io/rxjs/">RxJS</a> to convert the software event loop into an application based on a reactive event. <br><br>  The code is available on <a href="https://github.com/thoughtram/reactive-snake">Github</a> , and <a href="https://stackblitz.com/edit/reactive-snake%3Ffile%3Dmain.ts">here</a> you can find a demo version.  I urge you to clone the project, tinker with it a bit and implement interesting new game functions.  If you do, email me on <a href="https://twitter.com/elmd_">Twitter</a> . <br><br>  <b>Content</b> <br><br><ul><li>  A game </li><li>  Scene setting </li><li>  Identification of source streams </li><li>  Snake Control <br><ul><li>  Direction Flow ($ direction) </li></ul></li><li>  Length tracking <br><ul><li>  BehaviorSubject as salvation </li><li>  Account implementation (score $) </li></ul></li><li>  Snake Taming (snake $) </li><li>  Making apples <br><ul><li>  Event broadcasting </li></ul></li><li>  Putting it all together <br><ul><li>  Maintain performance </li><li>  Scene display </li></ul></li><li>  Future work </li><li>  Special thanks to </li></ul><br>  <b>A game</b> <br><br>  As mentioned earlier, we are going to recreate Snake, a classic video game from the late 1970s.  But instead of simply copying the game, we add a little variation to it.  This is how the game works. <br><br>  As a player, you control a line that looks like a hungry snake.  The goal is to eat as many apples as you can to grow as long as possible.  Apples can be found in random positions on the screen.  Every time a snake eats an apple, its tail becomes longer.  The walls won't stop you!  But listen, you should try to avoid getting into your own body at all costs.  If you do not, the game is over.  How long can you survive? <br><br>  Here is a preliminary example of what we are going to do: <br><br><img src="https://habrastorage.org/webt/59/cc/bc/59ccbc8207c44059095846.gif"><br><br>  For this particular implementation, the snake is represented as a line of blue squares, where its head is painted black.  Can you tell what the fruit looks like?  Exactly, red squares.  All entities are square, and this is not because they look prettier, but because they are very simple geometric figures and they are easily drawn.  The graphics are not very brilliant, but hey, this is about a transition from imperative programming to reactive programming, and not about game art. <br><br>  <b>Scene setting</b> <br><br>  Before we start working with the functionality of the game, we need to create a <font color="#2978a1"><b>canvas</b></font> element (canvas) that gives us powerful drawing APIs from JavaScript.  We will use the canvas to draw our graphics, including the playing field, the snake, apples and basically everything we need for our game.  In other words, the game will be fully displayed in the <font color="#2978a1"><b>canvas</b></font> element. <br><br>  If this is completely new to you, check out <a href="https://egghead.io/courses/learn-html5-graphics-and-animation">this</a> course on Keith Peters egghead. <br><br>  The <font color="#2978a1"><b>index.html</b></font> file is fairly simple, because most of the magic happens in javascript. <br><br><pre><code class="markdown hljs"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">head</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">charset</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"utf-8"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">title</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>Reactive Snake<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">title</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">head</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"/main.bundle.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span></span><span class="xml"><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span></span><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><br>  The script (script) that we add to the body (body) is essentially the result of the build process and contains all of our code.  However, you may be wondering why there is no such element in the <font color="#2978a1"><b>body</b></font> as <font color="#2978a1"><b>canvas</b></font> .  This is because we will create this element using javascript.  In addition, we add several constants that define the number of <font color="#2978a1"><b>rows</b></font> and <font color="#2978a1"><b>columns</b></font> , as well as the <font color="#2978a1"><b>width</b></font> and <font color="#2978a1"><b>height of the</b></font> canvas. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> COLS = <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ROWS = <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GAP_SIZE = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CELL_SIZE = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CANVAS_WIDTH = COLS * (CELL_SIZE + GAP_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CANVAS_HEIGHT = ROWS * (CELL_SIZE + GAP_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCanvasElement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canvas = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'canvas'</span></span>); canvas.width = CANVAS_WIDTH; canvas.height = CANVAS_HEIGHT; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> canvas; }</code> </pre><br>  With this we can call this function, create a <font color="#2978a1"><b>canvas</b></font> element on the fly and add it to the <font color="#2978a1"><b>body of</b></font> our page: <br><br><pre> <code class="hljs mel">let <span class="hljs-keyword"><span class="hljs-keyword">canvas</span></span> = createCanvasElement(); let ctx = <span class="hljs-keyword"><span class="hljs-keyword">canvas</span></span>.getContext(<span class="hljs-string"><span class="hljs-string">'2d'</span></span>); document.body.appendChild(<span class="hljs-keyword"><span class="hljs-keyword">canvas</span></span>);</code> </pre><br>  Notice that we also get a reference to <font color="#2978a1"><b>CanvasRenderingContext2D</b></font> by calling <font color="#2978a1"><b>getContext ('2d')</b></font> on the <font color="#2978a1"><b>canvas</b></font> element.  This 2D rendering context for the canvas allows us to draw, for example, rectangles, text, lines, paths, and more. <br><br>  We are ready to move!  Let's start work on the basic mechanics of the game. <br><br>  <b>Identification of source streams</b> <br><br>  Based on the example and description of the game, we know that we need the following functions: <br><br><ul><li>  Control the snake with the arrow keys </li><li>  Player Tracking </li><li>  Snake tracking (including food and movement) </li><li>  Tracking apples on the field (including the creation of new apples) </li></ul><br>  Reactive programming deals with programming based on data streams, input data streams.  Conceptually, when a reactive program is executed, it sets up monitoring of the source of information, and responds to changes, such as user interaction with the application, when you press a key on the keyboard or just the next stage of the interval.  So the whole thing is to understand <b>what can change</b> .  These <i>changes</i> often define <b>source threads</b> .  The main task is to determine the source streams, and then put them together to calculate everything you need, for example, the state of the game. <br><br>  Let's try to find our source streams by looking at the above functions. <br><br>  First of all, user input will definitely change over time.  The player moves the hungry snake using the arrow keys.  This means that our first source thread is <font color="#2978a1"><b>keydown $</b></font> , which will trigger a value change whenever a key is pressed. <br><br>  Then we need to keep track of the player's score.  The score mainly depends on how many apples the snake ate.  We can say that the score depends on the length of the snake, because whenever the snake grows, we want to increase the score by <font color="#2978a1"><b>1</b></font> .  Therefore, our next source thread is <font color="#2978a1"><b>snakeLength $</b></font> . <br><br>  Again, it is important to determine the <b>main streams</b> from which we can calculate everything you need, for example, an account.  In most cases, source streams are combined and converted into more specific data streams.  In a minute we will see it in action.  For now, let's continue defining our main streams. <br><br>  At the moment we have received user input events and an account.  We are left with more <b>game</b> or <b>interactive</b> streams, such as a snake or apples. <br><br>  Let's start with the snake.  The basic mechanism of a snake is simple: it moves with time, and the more apples it eats, the more it grows.  But what exactly is the <b>flow of a</b> snake?  At the moment we can forget about what she eats and grows, because first of all it is important that she depends on <b>the time factor</b> when she moves <b>with time</b> , for example, <font color="#2978a1"><b>5</b></font> pixels every <font color="#2978a1"><b>200 ms</b></font> .  So our <b>source stream</b> is an interval that sends a value after each time period, and we call it <font color="#2978a1"><b>ticks $</b></font> .  This stream also determines the speed of our snake. <br><br>  And last but not least: apples.  Arranging apples on the field considering everything is quite simple.  This stream mainly depends on the snake.  Every time the snake moves, we check whether the snake‚Äôs head collides with an apple or not.  If so, we remove this apple and generate a new one in an arbitrary position on the field.  As mentioned, we do not need to enter a new data stream for apples. <br><br>  Great, that's all for the main streams.  Here is a brief overview of all the threads we need for our game: <br><br><ul><li>  <font color="#2978a1"><b>keydown $</b></font> : keystroke events (KeyboardEvent) </li><li>  <font color="#2978a1"><b>snakeLength $</b></font> : represents the length of the snake (Number) </li><li>  <font color="#2978a1"><b>ticks $</b></font> : the interval that represents the movement of the snake (Number) </li></ul><br>  These source streams form the basis for our game, from which we can calculate all the other values ‚Äã‚Äãwe need, including the score, the condition of the snake and the apples. <br><br>  In the following sections, we will take a closer look at how to implement each of these source streams and apply them to generate the data we need. <br><br>  <b>Snake Control</b> <br><br>  Let's dive right into the code and implement the control mechanism for our snake.  As mentioned in the previous section, control depends on keyboard input.  It turns out to be terribly simple, and the first step is to create an <i>observable</i> sequence from keyboard events.  For this we can use the <font color="#2978a1"><b>fromEvent ()</b></font> operator: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keydown$ = Observable.fromEvent(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>, <span class="hljs-string"><span class="hljs-string">'keydown'</span></span>);</code> </pre> <br>  This is our very first source thread, and it will trigger a <font color="#2978a1"><b>KeyboardEvent</b></font> every time a user presses a key.  Notice that literally every <font color="#2978a1"><b>keydown</b></font> triggers an event.  Therefore, we also receive events for the keys that do not interest us at all, and these are basically all the other keys, except for the arrow keys.  But before solving this particular problem, we define a permanent map of directions: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> Point2D <span class="hljs-comment"><span class="hljs-comment">{ x: number; y: number; }</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> Directions <span class="hljs-comment"><span class="hljs-comment">{ [key: number]: Point2D; }</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DIRECTIONS: Directions = <span class="hljs-comment"><span class="hljs-comment">{ 37: { x: -1, y: 0 }</span></span>, <span class="hljs-comment"><span class="hljs-comment">// Left Arrow 39: { x: 1, y: 0 }, // Right Arrow 38: { x: 0, y: -1 }, // Up Arrow 40: { x: 0, y: 1 } // Down Arrow };</span></span></code> </pre><br>  Looking at the <font color="#2978a1"><b>KeyboardEvent</b></font> object, we can assume that each key has a unique <font color="#2978a1"><b>keyCode</b></font> .  To get the codes for the arrow keys, we can use <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode">this</a> table. <br><br>  Each direction is of type <font color="#2978a1"><b>Point2D</b></font> , which is simply an object with x and y properties.  The value for each property can be <font color="#2978a1"><b>1</b></font> , <font color="#2978a1"><b>-1</b></font> or <font color="#2978a1"><b>0</b></font> , indicating where the snake should be.  Later we will use the direction to get a new grid position for the head and tail of the snake. <br><br>  <b>Direction Flow ($ direction)</b> <br><br>  So, we already have a thread for <font color="#2978a1"><b>keydown</b></font> events, and each time a player presses a key, we need to match the value, which is the <font color="#2978a1"><b>KeyboardEvent</b></font> , to one of the direction vectors above.  To do this, we can use the <font color="#2978a1"><b>map ()</b></font> operator to project each keyboard event onto the direction vector. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> direction$ = keydown$ .map((<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>: KeyboardEvent) =&gt; DIRECTIONS[<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.keyCode])</code> </pre><br>  As mentioned earlier, we will receive <b>every</b> keystroke event, because we do not filter out those that do not interest us, for example, the character keys.  However, it can be argued that we are already filtering events by viewing them on a map of directions.  For each <font color="#2978a1"><b>keyCode</b></font> that is not defined on this map, it will be returned as <font color="#2978a1"><b>undefined</b></font> .  However, this does not actually filter the values ‚Äã‚Äãin the stream, so we can use the <font color="#2978a1"><b>filter ()</b></font> operator to process only the desired values. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> direction$ = keydown$ .map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event: KeyboardEvent</span></span></span><span class="hljs-function">) =&gt;</span></span> DIRECTIONS[event.keyCode]) .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">direction</span></span></span><span class="hljs-function"> =&gt;</span></span> !!direction)</code> </pre><br>  Well, that was easy.  The code above works fine and works as expected.  However, there is more to improve.  Have you guessed what? <br><br>  Well, one idea is that we want to prevent the snake from going in the opposite direction, for example.  right to left or top to bottom.  In fact, it does not make sense to allow this behavior, because the rule number one is to avoid getting into your own tail, remember? <br><br>  The solution is quite simple.  We cache the previous direction and when a new event is triggered, we check if the new direction is different from the opposite one.  Here is a function that calculates the <font color="#2978a1"><b>next</b></font> ( <i>next</i> ) direction: <br><br><pre> <code class="hljs lua">export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nextDirection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(previous, next)</span></span></span></span> { let isOpposite = (previous: Point2D, <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>: Point2D) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>.x === previous.x * <span class="hljs-number"><span class="hljs-number">-1</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>.y === previous.y * <span class="hljs-number"><span class="hljs-number">-1</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isOpposite(previous, <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> previous; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>; }</code> </pre><br>  This is the first time that we are tempted to save a state outside the Observable ( <i>observable</i> ) source of information, because we somehow need to correctly track the previous direction ... The easy solution is to simply save the previous direction in the external state variable.  But wait!  After all, we wanted to avoid this, right? <br><br>  To avoid an external variable, we need a way to sort the aggregate infinite Observables.  RxJS has a very convenient operator that we can use to solve our problem - <font color="#2978a1"><b>scan ()</b></font> . <br><br>  The <font color="#2978a1"><b>scan ()</b></font> operator is very similar to <font color="#2978a1"><b>Array.reduce ()</b></font> , but instead of only returning the last value, it initiates the sending of each intermediate result.  With <font color="#2978a1"><b>scan (),</b></font> we can basically accumulate values ‚Äã‚Äãand infinitely reduce the flow of incoming events to a single value.  Thus, we can track the previous direction, without relying on the external state. <br><br>  Let's apply this and look at our final <font color="#2978a1"><b>direction $</b></font> stream: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> direction$ = keydown$ .map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event: KeyboardEvent</span></span></span><span class="hljs-function">) =&gt;</span></span> DIRECTIONS[event.keyCode]) .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">direction</span></span></span><span class="hljs-function"> =&gt;</span></span> !!direction) .scan(nextDirection) .startWith(INITIAL_DIRECTION) .distinctUntilChanged();</code> </pre><br>  Note that we use <font color="#2978a1"><b>startWith ()</b></font> to initiate the initial value before starting to send values ‚Äã‚Äãfrom the source Observable ( <font color="#2978a1"><b>keydown $</b></font> ).  Without this operator, our Observable will start sending values ‚Äã‚Äãonly when the player presses the key. <br><br>  The second improvement is to initiate the sending of values ‚Äã‚Äãonly when the new direction differs from the previous one.  In other words, we only need <b>different values</b> .  You may have noticed in the above fragment <font color="#2978a1"><b>distinctUntilChanged ()</b></font> .  This operator does the dirty work for us and suppresses duplicate items.  Note that <font color="#2978a1"><b>distinctUntilChanged ()</b></font> only filters out the same values, unless another is selected between them. <br><br>  The following diagram visualizes our flow <font color="#2978a1"><b>direction $</b></font> and how it works.  The values ‚Äã‚Äãcolored blue represent the initial values, yellow means that the value was changed on the Observable stream, and the values ‚Äã‚Äãsent in the <b>result</b> stream are orange. <br><br><img src="https://habrastorage.org/webt/59/cc/c6/59ccc6b7d1f3d695893790.png"><br><br>  <b>Length tracking</b> <br><br>  Before we implement the snake itself, let's figure out how to track its length.  Why do we need length first?  Well, we use this information for account modeling.  It would be correct to say that in the imperative world we simply check whether there was a collision whenever the snake moves, and if so, we increase the score.  Thus, there is actually no need to track the length.  However, such an approach would introduce another external state variable, which we want to avoid at any cost. <br><br>  In the jet world, the solution is slightly different.  One simple approach may be to use the <font color="#2978a1"><b>snake $</b></font> stream, and each time it sends a value, we know that the snake has increased in length.  Although it really depends on the implementation of <font color="#2978a1"><b>snake $</b></font> , as long as we do not implement this stream.  From the very beginning, we know that the snake depends on <font color="#2978a1"><b>ticks $</b></font> because it moves a certain distance over time.  Thus, snake $ will accumulate an array of body segments, and since it is based on <font color="#2978a1"><b>ticks $</b></font> , it will generate a value every <font color="#2978a1"><b>x</b></font> milliseconds.  However, even if the snake does not encounter anything, <font color="#2978a1"><b>snake $</b></font> will still send values.  This is because the snake is constantly moving across the field, and therefore the array will always be different. <br><br>  This can be a bit tricky to understand, because there are certain dependencies between different threads.  For example, <font color="#2978a1"><b>apples $</b></font> will depend on <font color="#2978a1"><b>snake $</b></font> .  The reason for this is that every time a snake moves, we need an array of segments of its body to check if any of these parts collide with an apple.  While the <font color="#2978a1"><b>apples $</b></font> thread will accumulate an array of apples, we need a collision modeling mechanism, which at the same time avoids circular dependencies. <br><br>  <b>BehaviorSubject as salvation</b> <br><br>  The solution to this problem is that we will implement <i>the broadcast mechanism</i> using the <font color="#2978a1"><b>BehaviorSubject</b></font> .  RxJS offers various types of Subjects ( <i>items</i> ) with different functionalities.  Thus, the <font color="#2978a1"><b>Subject</b></font> class provides the basis for creating more specialized <font color="#2978a1"><b>Subjects</b></font> .  In a nutshell, a Subject is a type that implements both the Observer ( <i>Observer</i> ) and Observable (Observable) types.  Observables define data flow and create data, while Observers can subscribe to Observables and receive data. <br><br>  <font color="#2978a1"><b>BehaviorSubject</b></font> is a more specialized Subject providing a value that changes over time.  Now, when the Observer subscribes to the <font color="#2978a1"><b>BehaviorSubject</b></font> , it will receive the last value sent, and then all subsequent values.  Its uniqueness lies in the fact that it includes the <b>initial value</b> , so that all Observers will receive at least one value when subscribing. <br><br>  Let's continue and create a new <font color="#2978a1"><b>BehaviorSubject</b></font> with an initial value of <b>SNAKE_LENGTH</b> : <br><br><pre> <code class="hljs perl">// SNAKE_LENGTH specifies the initial <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> of <span class="hljs-keyword"><span class="hljs-keyword">our</span></span> snake let <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>$ = new BehaviorSubject&lt;number&gt;(SNAKE_LENGTH);</code> </pre><br>  From this place there was only a small step to implement snakeLength $: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snakeLength$ = length$ .scan((<span class="hljs-keyword"><span class="hljs-keyword">step</span></span>, snakeLength) =&gt; snakeLength + <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>) .share();</code> </pre><br>  In the above code, we see that <font color="#2978a1"><b>snakeLength $ is</b></font> based on <font color="#2978a1"><b>length $</b></font> , which is our <font color="#2978a1"><b>BehaviorSubject</b></font> .  This means that whenever we pass a new value to a Subject using <font color="#2978a1"><b>next ()</b></font> , it will send the value to <font color="#2978a1"><b>snakeLength $</b></font> .  In addition, we use <font color="#2978a1"><b>scan ()</b></font> to accumulate length over time.  Cool, but you might be wondering what kind of <font color="#2978a1"><b>share () it is</b></font> , isn't it? <br><br>  As already mentioned, <font color="#2978a1"><b>snakeLength $</b></font> will later be used as input for <font color="#2978a1"><b>snake $</b></font> , but at the same time acts as the source stream for the player‚Äôs account.  As a result, we will eventually <b>recreate</b> this source stream with a second subscription to the same Observable.  This is because the <font color="#2978a1"><b>length $</b></font> is <b>cold</b> Observable ( <i>cold Observable</i> ). <br><br>  If you are completely unfamiliar with hot and cold Observables ( <i>hot and cold observers</i> ), we wrote an article about the <a href="https://blog.thoughtram.io/angular/2016/06/16/cold-vs-hot-observables.html">Cold vs Hot Observables</a> . <br><br>  The point is that we use <font color="#2978a1"><b>share ()</b></font> to allow multi-subscriptions to Observable, which would otherwise re-create its source with each subscription.  This statement automatically creates a Subject between the source and all future subscribers.  As soon as the number of subscribers goes from zero to one, it connects the Subject to the Observable base source and initiates sending all its notifications.  All future subscribers will be connected to this intermediate Subject, so it is effective that there is only one subscription to the cold Observable below.  This is called <b>multicasting (multicast)</b> and will help you to stand out. <br><br>  Awesome!  Now that we have a mechanism that we can use to transfer values ‚Äã‚Äãto several subscribers, we can go ahead and realize a <font color="#2978a1"><b>score $</b></font> . <br><br>  <b>Account implementation (score $)</b> <br><br>  The implementation of a player‚Äôs account is as simple as possible.  Armed with <font color="#2978a1"><b>snakeLength $</b></font> , we can now create a stream, the <font color="#2978a1"><b>score $</b></font> , which simply accumulates the player‚Äôs account using <font color="#2978a1"><b>scan ()</b></font> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> score$ = snakeLength$ .startWith(<span class="hljs-number"><span class="hljs-number">0</span></span>) .scan(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">score, _</span></span></span><span class="hljs-function">) =&gt;</span></span> score + POINTS_PER_APPLE);</code> </pre><br>  In essence, we use <font color="#2978a1"><b>snakeLength $,</b></font> or rather, <font color="#2978a1"><b>length $</b></font> , to notify subscribers that a collision has occurred, and if this was the case, we simply increase the score by <font color="#2978a1"><b>POINTS_PER_APPLE</b></font> , the constant number of points per apple.  Note that <font color="#2978a1"><b>startWith (0)</b></font> must be added before <font color="#2978a1"><b>scan ()</b></font> to avoid specifying an initial value. <br><br>  Let's look at a more visual representation of what we have just implemented: <br><br><img src="https://habrastorage.org/webt/59/cc/cd/59cccd2f6688b797892359.png"><br><br>  Looking at the above diagram, you may wonder why the initial value of the <font color="#2978a1"><b>BehaviorSubject</b></font> appears only on <font color="#2978a1"><b>snakeLength $</b></font> and is missing in the <font color="#2978a1"><b>score $</b></font> .  This is due to the fact that the first subscriber will force <font color="#2978a1"><b>share ()</b></font> to subscribe to the underlying data source and, since the original data source immediately sends the value, this value will already be sent by the time subsequent subscriptions have occurred. <br><br>  Wonderful.  From this point on, let's implement the flow for our snake.  Isn't it exciting? <br><br>  <b>Snake Taming (snake $)</b> <br><br>  By this moment we have already learned a lot of operators and now we can use them to implement our <font color="#2978a1"><b>snake $</b></font> stream.  As discussed at the beginning of this article, we need some kind of <i>ticker</i> that keeps our hungry snake moving.  It turns out that there is a convenient operator for this <font color="#2978a1"><b>interval (x)</b></font> , which sends values ‚Äã‚Äãevery <font color="#2978a1"><b>x</b></font> milliseconds.  Let's call each value a <i>tick</i> . <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ticks$ = <span class="hljs-type"><span class="hljs-type">Observable</span></span>.interval(<span class="hljs-type"><span class="hljs-type">SPEED</span></span>);</code> </pre><br>  From this moment until the realization of the final thread, <font color="#2978a1"><b>snake $ is</b></font> quite a bit.  For each tick, depending on whether the snake has eaten an apple or not, we want to either move it forward or add a new segment.  Therefore, we can use the <font color="#2978a1"><b>scan ()</b></font> function already familiar to us to accumulate an array of body segments.  But, as you may have guessed, a question arises before us.  Where <font color="#2978a1"><b>do $</b></font> <font color="#2978a1"><b>direction</b></font> or <font color="#2978a1"><b>snakeLength $</b></font> threads come into play? <br><br>  Absolutely legitimate question.  The direction, like the length of the snake, is easily accessible inside our <font color="#2978a1"><b>snake $</b></font> stream, if we store this information in a variable outside the observed stream.  But again, we violate our rule not to change the external state. <br><br>  Fortunately, RxJS offers another very convenient operator named <font color="#2978a1"><b>withLatestFrom ()</b></font> .  This is the operator used to join the threads, and this is exactly what we are looking for.  This operator applies to the primary stream, which controls when data will be sent to the result stream.  In other words, you can think of <font color="#2978a1"><b>withLatestFrom ()</b></font> as a way to regulate the sending of secondary stream data. <br><br>  Considering the above, we have the tools necessary for the final implementation of a hungry <font color="#2978a1"><b>snake $</b></font> : <br><br><pre> <code class="hljs ruby">let snake$ = ticks$ .withLatestFrom(direction$, snakeLength$, (<span class="hljs-number"><span class="hljs-number">_</span></span>, direction, snakeLength) =&gt; [direction, snakeLength]) .scan(move, generateSnake()) .share();</code> </pre><br>    ‚Äî  <font color="#2978a1"><b>ticks$</b></font> ,   ,        ,       <font color="#2978a1"><b>direction$</b></font> ,    <font color="#2978a1"><b>snakeLength$</b></font> .  ,        , ,       ,        <i></i> . <br><br>  ,   <b></b>  ( <i>  </i> )  <font color="#2978a1"><b>withLatestFrom</b></font> ,  ,  <i></i>    .    ,    ,      . <br><br>      <font color="#2978a1"><b>move()</b></font> ,          .   ,        <a href="">GitHub</a> . <br><br>  ,     : <br><br><img src="https://habrastorage.org/webt/59/cc/ce/59ccceca68ddb431512285.png"><br><br>    <i></i>  <font color="#2978a1"><b>direction$</b></font> ?   ,   <font color="#2978a1"><b>withLatestFrom()</b></font>  ,    <b></b>  ,          Observable ( <i></i> ),  <b></b>    . <br><br> <b> </b> <br><br>   ,           ,        .      ,     . <br><br>       ,   <font color="#2978a1"><b>direction$</b></font> , <font color="#2978a1"><b>snakeLength$</b></font> , <font color="#2978a1"><b>score$</b></font>  <font color="#2978a1"><b>snake$</b></font> .     ,       .     ,   .  . <br><br>    ,     . -,  ,     . ,      ,   .       .    ? <br><br> ,     <font color="#2978a1"><b>scan()</b></font>    .     ,   ,   ,  ,   .   ,       <b></b> .      <font color="#2978a1"><b>distinctUntilChanged()</b></font>    . <br><br><pre> <code class="hljs ruby">let apples$ = snake$ .scan(eat, generateApples()) .distinctUntilChanged() .share();</code> </pre><br>  Cool!  ,   ,  <font color="#2978a1"><b>apples$</b></font>   ,   ,         .   ,        ,   <font color="#2978a1"><b>snake$</b></font> ,      <font color="#2978a1"><b>snakeLength$</b></font> ,  ,     . <br><br> <b> </b> <br><br>      <b></b> , ?       .     <font color="#2978a1"><b>eat()</b></font> : <br><br><pre> <code class="hljs matlab">export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(apples: Array&lt;Point2D&gt;, snake)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">head</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[0]</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(let i = 0; i &lt; apples.length; i++)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(checkCollision(apples[i], head)</span></span></span><span class="hljs-function">) { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apples</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">splice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, 1)</span></span></span><span class="hljs-function">; // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-function">$.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(POINTS_PER_APPLE)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[...apples, getRandomPosition(snake)]</span></span></span><span class="hljs-function">; } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apples</span></span></span><span class="hljs-function">; }</span></span></code> </pre><br>     <font color="#2978a1"><b>length$.next(POINTS_PER_APPLE)</b></font>    .      ,              ( ES2015).  ES2015    ,        .     ,      ,       . <br><br>  <i></i>      ,  <font color="#2978a1"><b>applesEaten$</b></font> .     <font color="#2978a1"><b>apples$</b></font>   ,      ,     - <b></b> ,  <font color="#2978a1"><b>length$.next()</b></font> .       <font color="#2978a1"><b>do()</b></font> ,        . <br><br>  .   -  <b></b>  () ,  <font color="#2978a1"><b>apples$</b></font> .          ,     ,    . ,  RxJS    ,   <font color="#2978a1"><b>skip()</b></font> . <br><br>  ,  <font color="#2978a1"><b>applesEaten$</b></font>    <i></i>    ,           .       <b></b> . <br><br><pre> <code class="hljs ruby">let appleEaten$ = apples$ .skip(<span class="hljs-number"><span class="hljs-number">1</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">do</span></span>(() =&gt; length$.<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(POINTS_PER_APPLE)) .subscribe();</code> </pre><br> <b>  </b> <br><br>           ,   , ,       ‚Äî <font color="#2978a1"><b>scene$</b></font> .      <font color="#2978a1"><b>combineLatest</b></font> .      <font color="#2978a1"><b>withLatestFrom</b></font> ,    . -,    : <br><br><pre> <code class="hljs ruby">let scene$ = Observable.combineLatest(snake$, apples$, score$, (snake, apples, score) =&gt; ({ snake, apples, score }));</code> </pre><br>  ,     ,     ,  <b></b>   Observables ( <i></i> )    .      ,         ,      .    ,     . <br><br><img src="https://habrastorage.org/webt/59/cc/d1/59ccd1cc82f11776726599.png"><br><br> <b> </b> <br><br>    ,    -    .  <i></i>   ,             60   . <br><br>    ,   ,   <font color="#2978a1"><b>ticks$</b></font> ,   .      : <br><br><pre> <code class="hljs pgsql">// <span class="hljs-type"><span class="hljs-type">Interval</span></span> expects the period <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> be <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> milliseconds which <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> why we devide FPS <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> Observable.interval(<span class="hljs-number"><span class="hljs-number">1000</span></span> / FPS)</code> </pre><br>   ,  JavaScript  .         ,   .  ,         .     ,     ,        .         ,   .      . <br><br>  ,    <font color="#2978a1"><b>requestAnimationFrame</b></font> ,           .         Observable?    ,   ,  <font color="#2978a1"><b>interval()</b></font> ,      <font color="#2978a1"><b>Scheduler</b></font> ( <i></i> ).   , <font color="#2978a1"><b>Scheduler</b></font> ‚Äî  ,  <b></b>  -   . <br><br>  RxJS   , ,   ,  <font color="#2978a1"><b>animationFrame</b></font> .       <font color="#2978a1"><b>window.requestAnimationFrame</b></font> . <br><br>  Fine!      ,    Observable <font color="#2978a1"><b>game$</b></font> : <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// Note the last parameter const game$ = Observable.interval(1000 / FPS, animationFrame)</span></span></code> </pre><br>         16 ,  60 FPS. <br><br> <b> </b> <br><br>     <font color="#2978a1"><b>game$</b></font>  <font color="#2978a1"><b>scene$</b></font> .    ,      ? ,       ,      ,       60   .    <font color="#2978a1"><b>game$</b></font>   <b></b> ,   ,    ,     <b></b>   <font color="#2978a1"><b>scene$</b></font> .  ? ,     <font color="#2978a1"><b>withLatestFrom</b></font> . <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Note the last parameter const game$ = Observable.interval(<span class="hljs-number"><span class="hljs-number">1000</span></span> / FPS, animationFrame) .withLatestFrom(scene$, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_, scene)</span></span></span><span class="hljs-function"> =&gt;</span></span> scene) .takeWhile(scene =&gt; !isGameOver(scene)) .subscribe({ next: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scene)</span></span></span><span class="hljs-function"> =&gt;</span></span> renderScene(ctx, scene), complete: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> renderGameOver(ctx) });</code> </pre><br> ,   <font color="#2978a1"><b>takeWhile()</b></font>    .      ,       Observable.      game$   , <b></b> <font color="#2978a1"><b>isGameOver()</b></font>   <font color="#2978a1"><b>true</b></font> . <br><br>         : <br><br> <a href="https://stackblitz.com/edit/reactive-snake%3Ffile%3Dmain.ts"><img src="https://habrastorage.org/webt/59/cc/d7/59ccd73e64718368364492.png"></a> <br><br> <b> </b> <br><br>   ,          ,      .  ,  ,     <b></b>  <b></b> ,    <b></b> . <br><br>  Be in touch! <br><br> <b> </b> <br><br>   <a href="https://twitter.com/MrJamesHenry">James Henry</a>  <a href="https://twitter.com/brechtbilliet">Brecht Billiet</a>     . </div><p>Source: <a href="https://habr.com/ru/post/338910/">https://habr.com/ru/post/338910/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338900/index.html">Financial Literacy Fair Fin-Fair.ru</a></li>
<li><a href="../338902/index.html">CSV-library Adaptive Table Layout</a></li>
<li><a href="../338904/index.html">30 new resources for android developer (summer 2017)</a></li>
<li><a href="../338906/index.html">Graphical interface or chat bot in project management: what is more effective? .. Practical experiment</a></li>
<li><a href="../338908/index.html">Analytics in the public sector: features of large storage systems</a></li>
<li><a href="../338912/index.html">From the life of werewolves</a></li>
<li><a href="../338914/index.html">Sugar Javascript</a></li>
<li><a href="../338918/index.html">Indeed, what is a CRM system?</a></li>
<li><a href="../338920/index.html">DevFest North in St. Petersburg on September 30</a></li>
<li><a href="../338922/index.html">Simulate Mixed Circuits on System Verilog</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>