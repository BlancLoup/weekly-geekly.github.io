<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SOA: send a request to the server? What could be easier?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="You may have heard about Booking.com, that they are experimenting a lot and often deploy without testing . And also that there is one large repository...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SOA: send a request to the server? What could be easier?</h1><div class="post__text post__text-html js-mediator-article">  You may have heard about Booking.com, that they <strong>are experimenting a lot and often deploy without testing</strong> .  And also that there is one large repository for 4 GB, it has 4 million lines of pearl-barley code, and generally a monolithic architecture. <br><br>  At the same time, Booking.com is changing.  This is not to say that this is a cardinal change in leaps and bounds, but a slow and confident transformation.  The stack is changing, Java is gradually being introduced in those places where this is relevant.  Including the term <strong>service-oriented architecture</strong> (SOA) is heard more and more often in internal discussions. <br><br>  Further, <strong>Ivan Kruglov's</strong> story ( <a href="https://habrahabr.ru/users/vian/">@vian</a> ) about these changes in terms of the interaction of internal components at <strong>Highload Junior ++ 2017</strong> .  Having fallen into the trap of cyclically dependent workers, it was necessary to qualitatively figure out what was happening, and by what means you could fix it all. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/gd/0u/gq/gd0ugqfwnpls263k_w0smloosvq.jpeg"><br><a name="habracut"></a><br><br><h2>  Advantages of the transition to service-oriented architecture </h2><br><img src="https://habrastorage.org/webt/kq/mz/rc/kqmzrccm_70aeoxantjghm5glko.png"><br><br>  The first 3 advantages of service-oriented architecture ‚Äî <strong>weak connectivity, independent deployment, independent development</strong> ‚Äî are generally understood, I will not dwell on them in detail.  Let's go straight to the next one. <br><br>  <strong>Faster onboarding</strong> <br><br>  In a company that is in the phase of intensive growth, a lot of attention is paid to the topic of quickly incorporating a new employee into the workflow.  Service-oriented architecture here can help by focusing a new employee on a specific small area.  It is easier for him to get knowledge about a separate part of the entire system. <br><br>  <strong>Faster development</strong> <br><br>  The last point summarizes the rest.  From the transition to a service-oriented architecture, we, if we are not able to significantly speed up the development, then at least maintain the current pace at the expense of less connected components. <br><br><h2>  Cons transition to service-oriented architecture </h2><br>  <strong>Reduced flexibility</strong> <br><br>  By flexibility, I mean flexibility in the redistribution of human resources.  For example, in a monolithic architecture, in order to make some change in the code and break anything, you need to have knowledge of how a large area works.  With this approach, it turns out that it becomes easy to transfer a person between projects, because with a high degree of probability this person in the new project will already know a fairly large area.  From a management point of view, the system is more flexible. <br><br>  In a service-oriented architecture, everything is a little different.  If your teams use different technological stacks in different teams, then <strong>switching between teams may be equivalent to switching to another company,</strong> where everything can be completely different. <br><br>  This is a managerial minus, the remaining minuses are technical. <br><br>  <strong>The complexity of making atomic changes</strong> (not only in the data) <br><br>  In a distributed system, we lose the possibility of transactions and atomic changes to the code.  One commit to several repositories will not stretch. <br><br>  <strong>Difficult debugging</strong> <br><br>  A distributed system is fundamentally more difficult to debug.  Elementary, we have no debugger in which it would be possible to see where we will go further, where the data will go in the next step.  Even in the elementary task of analyzing logs, when there are 2 servers, each of which has its own logs, it is difficult to understand what it is related to. <br><br>  It turns out that in the service-oriented architecture, the <strong>infrastructure as a whole is more complicated</strong> .  Many supporting components appear, for example, a distributed logging system and a distributed tracing system are needed. <br><br>  This article will focus on another drawback. <br><br>  <strong>Remote Procedure Call (RPC)</strong> <br><br>  It results from the fact that, if in a monolithic architecture, in order to do some operation, it is enough to call the desired function, then in SOA you will have to make a remote call. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WASm5325GQg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Just want to say what I will and will not talk about.  I will not talk about the interaction of Booking.com with the outside world.  My report focuses on the internal components of Booking.com and their interaction. <br><br><img src="https://habrastorage.org/webt/am/jn/jz/amjnjzgx7n4fndxcdlrwrmvd7uq.png"><br><br>  Moreover, if we take a hypothetical service consumer, in which the application through the client library and transport interacts with the server at the service provider and back, my focus is the framework that provides the interaction of these two components. <br><br><img src="https://habrastorage.org/webt/cu/qh/ev/cuqhevi138gz1ra8i5ff9h6slpw.png"><br><br><h2>  The story of one problem </h2><br>  I want to tell one story.  Here I refer to my report ‚Äú <a href="https://habrahabr.ru/post/323094/">Search architecture on Booking.com</a> ‚Äù, in which I talked about how the search developed on Booking.com, and at one of the stages we decided to create our own samopisny Map-Reduce framework (highlighted in red in the figure below) . <br><br><img src="https://habrastorage.org/webt/at/7h/by/at7hby0uoqbdpuotqkrsznh-a_k.png"><br><br>  This Map-Reduce framework should work as follows (see the diagram below).  At the entrance there had to be a search query that arrives at the master node, which divides this request into several subqueries and sends them to the workers.  A worker performs his work, forms the result and sends it back to the master.  The classical scheme: on the Master - the reduce function, on the Worker - the Map phase.  So it was supposed to work in theory. <br><br><img src="https://habrastorage.org/webt/ae/lo/s4/aelos47qyp7kvczf9keczbsbqdg.png"><br><br>  In practice, we did not have a hierarchy, that is, all the workers were equivalent.  When a client flew in, he randomly chose a worker (in Fig. This is worker 4).  Within the framework of the request, this worker became a master and divided this request into subqueries and also randomly chose his 2nd and 5th worker for himself as an apprentice. <br><br><img src="https://habrastorage.org/webt/8v/_s/p3/8v_sp3n3tqpz3bimajfilicfex8.png"><br><br>  With the second query, the same thing: randomly select the 1st worker, he divides it and sends it to the 3rd and 5th. <br><br>  But there was such a feature that this query tree was multilevel, and the 5th worker could also decide to divide his query into several subqueries.  He also chose some nodes from the same cluster as an apprentice. <br><br>  Since the nodes are chosen randomly, it could turn out that he takes and selects the first node and the second node as his sub-apprentice.  The figure shows that between the 1st and 5th workers there is a cyclical relationship, when the 1st worker needs the resources from the 5th to fulfill the request, and the 5th needs the resources from the 1st, which not to be. <br><br>  So do not.  This is a <strong>recipe for a disaster</strong> that has happened here. <br><br><img src="https://habrastorage.org/webt/fi/sg/dw/fisgdw4nybwe_bimh61w6zn0mua.png"><br><br>  At a certain point in the cluster, a chain reaction was started, due to which all the machines left the cluster within 5-10 seconds.  <strong>The cluster fell into a deadlock</strong> .  Even if we removed all incoming traffic to it, it remained in a blocked state. <br><br>  In order to bring it out of this state, we needed to restart all the machines in the cluster.  It was the only way.  We did it lively, because we did not know the reason for our problem.  We were afraid to switch traffic to another cluster, to another data center, because we were afraid to launch the same chain reaction.  <strong>The choice was between the loss of 50% and 100% of traffic</strong> , we chose the first. <br><br><h3>  Demo </h3><br>  It is easiest to explain what happened through a demonstration.  Just want to say that this demonstration does not 100% reflect what was in that system, because it is no longer there.  We refused it, including due to architectural problems.  In my example, the key points are reflected, but it does not emulate the situation completely. <br><br><img src="https://habrastorage.org/webt/vy/sp/-6/vysp-6a7tfmlfwreie0tpmmovc0.png"><br><br>  Two parameters are backlog = 2048 and listen = 2048 while you take as data, then understand why they are important here. <br><br>  <strong>Scenario</strong> <br><br>  All my demos will take place under the same scenario.  The graph shows a plan of action. <br><br><img src="https://habrastorage.org/webt/po/js/ql/pojsqlsl1fr5qh_evj6aaoxikwo.png"><br><br>  There are 3 phases here: <br><br><ol><li>  From 0 to 3500 requests per second; <br></li><li>  From 3500 to 4500 requests per second. <br>  In the second phase, the zone is highlighted in green when the server reaches the saturation point.  It is interesting to see how he reacts at this moment. <br></li><li>  Server response after the saturation point, when the number of requests per second increases to 7000. <br></li></ol><br>  I will demonstrate this all with the help of a samopisny tool that can be found on my GitHub.  This is how it looks. <br><br><img src="https://habrastorage.org/webt/1m/1t/ae/1m1taesybnnz6iqn-obk-dbkel0.png"><br><br>  Explanation: <br><br><ul><li>  Histogram of query results for the last 10 seconds: <br><ul><li>  <strong>*</strong> means that some number of requests completed successfully; </li><li>  <strong>E</strong> - requests completed with an error. </li></ul></li><li>  On the left are time intervals from 0 to ~ 1 s on a logarithmic scale. <br></li><li>  The current RPS and the desired RPS are highlighted in yellow. <br></li></ul><br>  <strong>Go!</strong> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WASm5325GQg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  We started with 2500 requests per second, the number is growing - 2800, 2900. One can see the normal distribution somewhere around 5 ms. <br><br>  When the server comes to <strong>a saturation zone</strong> , requests become slower.  They flow, flow, flow, and then at some point there is a <strong>sharp degradation of the</strong> quality of service.  All requests have become erroneous.  Everything became bad, the system fell. <br><br>  In the resulting state, <strong>100% of the requests failed</strong> , and they were clearly divided into 2 categories: <strong>slow failures</strong> , which take ~ 0.5 s, and very <strong>fast</strong> (~ 1 ms). <br><br>  Query graphs look something like the figure below.  At a certain point, a qualitative change occurred, all positive requests were replaced with negative ones, and the 99th percentile of response time significantly degraded. <br><br><img src="https://habrastorage.org/webt/ap/ms/vp/apmsvpmkeffna0jdzupttz031u0.png"><br><br>  <strong>Steps</strong> <br><br>  To begin with, the system processes requests in a normal state when it is not under load.  Once again, the explanation is simplified. <br><br><img src="https://habrastorage.org/webt/cz/i-/1y/czi-1yiz-3bbs-9g0gb1sxn1cfk.png"><br><br><ul><li>  Nginx at the entrance receives a request. <br></li><li>  In nginx there are 24 workers. <br></li><li>  The request is being processed for some time in nginx. <br></li><li>  Nginx redirects the request to uWSGI. <br></li><li>  96 uWSGI workers are Perl processes that also take some time. <br></li><li>  The sum of the time that the request spent in nginx and in uwsgi is <br></li></ul><br>  Let's look closely at the degradation zone, in which requests flow into slower ones.  The pause is set in an interesting moment, because if you pay attention to the number of in-flight requests (requests that are happening right now), there are 94 of them. Let me remind you that we have 96 uWSGI workers. <br><br><img src="https://habrastorage.org/webt/2r/ba/qn/2rbaqn2vad3gsbin9tabalmtoxk.png"><br><br>  It is at this point that a significant degradation of quality service occurs.  That is, all requests abruptly become very slow, and everything ends up with an error. <br><br><img src="https://habrastorage.org/webt/-x/xq/e3/-xxqe38gsetmpnkplj5srlbw4ha.png"><br><br>  We return to the chart. <br><br><ul><li>  When a request enters nginx, it first enters the queue, which is associated with <br>  <strong>TCP socket</strong> , which is at the input of nginx. <br></li><li>  Further, when the nginx worker connects to uWSGI, the request also spends some time in the queue associated with <br>  <strong>Unix socket</strong> uWSGI. <br></li></ul><br>  The total request time is made up of these 4 components. <br><br>  There is a feature here.  <strong>nginx is great fast software</strong> .  In addition, nginx workers are asynchronous, so nginx is able to process the queue very quickly, which is in the TCP socket. <br><br>  The uWSGI workers are synchronous, on the contrary.  In fact, these are barley-based processes, and when the number of requests that arrive in the system begins to exceed the number of available workers, a queue begins to form in the Unix socket. <br><br>  In Setup, I focused on 2 parameters: backlog = 2048 and listen = 2048. They determine the length of this queue, which in this case will be up to 2048 long. <br><br>  The request begins to spend significant time in the unix socket, just sitting in a queue and waiting for its chance that the worker at uWSGI will be released and start processing it.  At this point, a timeout of 500 ms occurs.  The client side tears up the connection, but <strong>tears it up only to nginx</strong> . <br><br>  From the point of view of uWSGI, nothing happens.  For him, this is a <strong>fully established connection</strong> , since the requests are small, they all lie in the buffer.  When the worker is released and takes the record, from his point of view, this is <strong>an absolutely valid request</strong> that he continues to execute. <br><br>  This is not the case in the figure, but if at this moment you look at the server, it will be <strong>100% loaded</strong> , it will continue to process these dangling connections, dangling requests. <br><br>  That is, it turns out that the client does the work, sends requests, but receives 100% errors.  The server, for its part, receives requests, honestly processes them, but when it tries to send back the data, nginx says to him: ‚ÄúNo one needs this answer!‚Äù <br><br>  That is, the client and the server are trying to talk, but <strong>do not hear each other</strong> . <br><br>  <strong>Next stage</strong> <br><br><img src="https://habrastorage.org/webt/ad/ye/ws/adyewsrcqkbyt7jnzteyavh6rbs.png"><br><br>  All requests degraded into erroneous, their number per second continues to grow.  At this moment, the nginx worker, trying to connect to socket uWSGI, gets error 502 (Bad Gateway), since the queue is full. <br><br><img src="https://habrastorage.org/webt/en/pw/f2/enpwf2inlwdybef-0i2rhmiv8yc.png"><br><br>  Since in this case the request time is limited only by processing in nginx, the answer is very, very fast.  In fact, nginx only needs to parse the HTTP protocol, make a connection to the unix socket and that's it. <br><br>  Here I want to return you to the original problem and tell you in more detail what is happening there. <br><br>  The following happens.  For some reason, some workers have become slow, we will not dwell on why, take it as given.  Because of this, the uWSGI workers start to end and form a queue in front of them. <br><br><img src="https://habrastorage.org/webt/io/gw/lz/iogwlzmogjm0n6zkjxpzi3yo6x4.png"><br><br>  When a client request arrives, the 1st worker sends the request to the 5th one, and this request must defend its turn.  After he defended his turn and began to be processed by the 5th worker, the 5th worker in turn also divided his request into subqueries.  The subquery arrives at the first worker, in which he must also defend the queue. <br><br>  Now there is a timeout on the side of the 1st worker.  At the same time the request is broken, but the 5th worker does not know anything about it.  He successfully continues to process the original request.  And the 1st worker takes Retry to the same request. <br><br>  In turn, the 5th worker continues to process, there also happens a timeout, because we have defended a queue in the 1st.  It terminates its request and also makes Retry. <br><br>  I think it is clear that if the process continues, spinning this flywheel, in the end the whole system will be crammed with requests that are not needed by anyone.  In fact, it turned out a <strong>system with positive feedback</strong> .  This put our system. <br><br>  When we analyzed this case, which, by the way, took a lot of time, because it was completely incomprehensible what was happening, we thought: since we spend a lot of time in the unix socket (we have a very long 2048 items), let's try it is less, so that each worker has only 1 element. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WASm5325GQg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Let's now see how an absolutely same system behaves with a single changed parameter - the queue length. <br><br>  The scenario is the same as last time: starting with 2500, we also raise requests: 2900, 3000, 3100, 3200. We enter the zone when the system is not stable.  Inquiries are slowly falling down, but not degrading so fundamentally.  This system is stabilized literally in the region of 45 ms.  It continues to successfully process requests, but at the same time some part of them leads to errors. <br><br>  On the graph it looks like this. <br><br><img src="https://habrastorage.org/webt/oa/fv/ml/oafvml8bsrxqofvpdvzh6msjn8c.png"><br><br>  At a certain point in time, the system has stabilized the number of requests that it can successfully process.  At the same time, at the time of stabilization, erroneous requests began to form.  This is the number of requests that the system is not able to process at the moment. <br><br>  It turns out that due to the length of the queue, the system will always take only the request that is most likely to be successfully executed.  According to statistics, this volume of requests is always fixed.  The rest of the system simply ignores and gives error 502. <br><br>  In the third phase, when the number of requests sharply bullying, the system still retains its performance.  Moreover, it retains its quality of service, that is, the p99 response time does not grow, it has stabilized. <br><br>  This is what we started in production with, I will tell you more about this.  I experimented with the queue length and it turned out that the queue length determines, at least in our system, the worst response time. <br><br><img src="https://habrastorage.org/webt/j3/e0/9z/j3e09zm5dl6b4ayn4pvrwuki5lg.png"><br><br>  The system has stabilized at a slightly higher response time, but it is still stabilized.  If you try to limit the queue literally at 20, then the response time does not practically grow at all, changing only by a few milliseconds. <br><br><h2>  How we solved our problem </h2><br>  <strong>In the short term:</strong> <br><br>  Reducing the queue length, first of all, <strong>conditionally broke the cycle</strong> .  Conventionally, then the cyclic dependence is still present, but the properties have changed.  The fact is that a particular server, if it does not have enough resources to process an incoming request, will simply reject the request.  And this will be done very quickly, with a minimum of overhead.  If there are enough resources in this server, the request will be accepted.  As a result, the cycle, if this particular server is loaded, breaks. <br><br>  Moreover, there is one more nuance.  In the first example, there were 2 error classes ‚Äî very fast (~ 1 ms) and very slow (~ 500 ms).  By reducing the length of the queue, all slow errors were translated into a series of cheap ones, that is, we made them very fast.  Thanks to this, we have become <strong>cheap replays</strong> .  The situation has ceased to repeat, when we, by doing Retry, in fact once again load some second component. <br><br>  <strong>In the long run, of</strong> course, we had to switch to a 2-step architecture, which would coincide with the logical architecture.  This we did in the next iteration, when we developed a replacement for the search service. <br><br><h2>  Build a predictable RPC system </h2><br>  Now let's talk about what components you need and what you need to keep if you want to build a predictable RPC system - a framework with predictable system behavior in boundary conditions.  I'll tell you about what we have, what approaches we use, without reference to a specific service. <br><br><img src="https://habrastorage.org/webt/ql/4u/ts/ql4utsxe4orhse_ieepqtt3rj0w.png"><br><br>  Returning to the first diagram (the interaction between the client and server), we have already touched the first 2 bricks that need to be properly configured: <br><br><ol><li>  <strong>Queues</strong> on the server side; <br></li><li>  <strong>Timeouts</strong> on the client side. <br></li></ol><br>  We have already dealt with slow errors - we transferred them to the category of fast ones, what to do with fast errors? <br><br>  It is necessary to consider 2 different cases. <br><br>  <strong>First, what to do when the system is in the <em>saturation phase</em> ?</strong> <br><br>  Here, in fact, nothing can be done!  When the system is in the saturation phase, it has run out of resources, and it cannot process anything new.  For example, I can carry 100 kg, but give me 101 kg, and I will fall. <br><br>  This is a very good feature, because here it is, in fact, about 2 very important, in my opinion, component of any framework: <br><br><ol><li>  <strong>Fail fast.</strong>  That is, if some kind of error occurs, we do it very quickly. <br></li><li>  Mild degradation ( <strong>Graceful degradation</strong> ).  If there is a significant load, the system will always consistently successfully handle a certain percentage of requests, instead of completely dropping. <br></li></ol><br>  <strong>Secondly, what to do if the <em>queue overflows briefly</em> ?</strong> <br><br>  This is possible if, for example, there was some kind of delay in the network, requests accumulated in it, and some of them arrive at the server at once, briefly filling the queue. <br><br>  In this case, a very simple and reliable mechanism is to take and repeat (Retry).  One more brick falls on our diagram. <br><br><h3>  Retry </h3><br><img src="https://habrastorage.org/webt/bc/uy/b-/bcuyb-gkaacznhkuj_odmhxyxdi.png"><br><br>  In my practice, <strong>Retry is a powerful mechanism</strong> that allows in many cases to get off the water.  For example, on the chart above, this is the number of errors on the server side, and below is the number of errors on the client side.  It can be seen that for some reason the server constantly generates errors, but on the client side nothing is visible. <br><br>  Quite often it happens that even if we have any problems on the server side for any reason, they don‚Äôt reach the client due to competent Retry. <br><br>  When we talk about Retry, it is important to keep in mind: <br><br><ul><li>  Retry should not be infinite.  It should always be <strong>limited to the budget</strong> .  We usually use 3 attempts. <br></li><li>  It is safe to repeat only <strong>idempotent operation</strong> .  This is the operation that no matter how many times you use it, the result will be the same. <br></li></ul><br>  When we send an HTTP request, everything that happened until the moment when we sent data to the server, that is, in fact, was written to the socket - this is a safe operation, because we haven't sent anything to the server yet.  For example, if you had some kind of error when you tried to convert a DNS address, or simply the server is not available, then this is normal. <br><br>  Everything that happened after that is questionable, because the HTTP standard for read operations performed by the GET method are idempotent by default, which is not the case for POST. <br><br>  This is in theory, but in practice it comes out in different ways, depending on the system.  For example, there are a number of systems that write: ‚ÄúSending GET requests somewhere there.‚Äù Therefore, we must look at a specific system. <br><br><ul><li>  Another important point - <strong>fast replay is not effective</strong> (in my practice). <br></li></ul><br>  Imagine that a short-term problem has occurred on the network, for example, a route is being rebuilt, some host has become unavailable for a short period of time.  If you repeat it once, after the second, third, then you will burn your budget in just a few milliseconds.  It is not effective.  You have not given any chance for the system to recover. <br><br><h3>  Back-off </h3><br>  We‚Äôll put another brick on the diagram into the service consumer block - back-off. <br><br><img src="https://habrastorage.org/webt/fa/y1/cx/fay1cx6jcxhm73nkkeeird9mile.png"><br>  The main idea behind the back-off is to <strong>insert a pause between attempts</strong> in order to increase the chances of success.  So we give the system a chance, and wait on our side, hoping that the system will recover itself. <br><br>  I know several back-off algorithms: <br><br><ul><li>  Fixed - when between attempts an equivalent interval.  For example, the first request failed, we retreated for 100 ms, tried the second, again did not work, again miss 100 ms. <br></li><li>  Exponential.  For example, the first time we indent by 10 ms, then by 20, 40, etc. <br></li></ul><br>  Another important factor when we talk about back-offs is the <strong>randomization of indentation intervals - jitter.</strong> <br><br>  Imagine that 100 requests are flying to you that arrive at one moment and briefly overload the server.  All requests receive an error.  Now we indent for 100 ms, and the same requests again go to the server.  The situation, in fact, repeats itself - they just overload the server. <br><br>  If the server locally add some randomized delta to the indent, it turns out that all the second requests will be spread out over time and arrive at the server more than once.  The server will have much more chances to process them. <br><br>  We use an exponential randomized interval in Booking.com (see example).  For example, the first indent is 53 ms, then 129 ms, 555 ms, etc. <br><br><h3>  Timeout </h3><br>  The next brick is server-side timeouts, more precisely, <strong>timeout consistency on the client and server sides.</strong> <br><br><img src="https://habrastorage.org/webt/ks/8a/v-/ks8av-4ipaartssrk08n2mtxc6e.png"><br><br>  I have already touched on this topic.  It is important that when the client falls off, the server does not continue to process that request. <br><br>  In modern frameworks there is such a mechanism as cancellation of the request - <strong>request cancellation</strong> .  Our framework, unfortunately, does not have such properties, so we had to work around this problem. <br><br>  When our client flies to the server, it sets the HTTP header - <strong>X-Booking-Timeout-Ms</strong> , which says what its timeout is.  After that, the server takes this data and sets its local server timeout based on the client and some delta to allow the request to fly to the server: <br><br>  <strong>server timeout = client timeout + delta</strong> <br><br>  It turns out that when a client falls off after 100 ms, the server will fall off, for example, literally after 110 ms.  That is, the request is canceled. <br><br>  The diagram already has 5 elements that are not needed when the system is stable.  They are required when everything is bad, in fact, as backups.  These components are not needed in normal life, but when they are needed, <strong>they are really needed</strong> . <br><br>  There are people who still do not make backups.  But those who have had negative experience, periodically restore backups.  We are essentially for these purposes, that is, in order to test our entire stack, we use Chaos Monkey. <br><br><h3>  Chaos monkey </h3><br>  Initially, the idea of ‚Äã‚ÄãChaos Monkey was that we turn off the data center and see how our system responds.  We have not yet reached such a scale - our scale is more modest.  But there are interesting things you want to talk about. <br><br><img src="https://habrastorage.org/webt/sa/og/cu/saogcuauzasihkmhtof4ra_ppxc.png"><br>  We have 3 types of Chaos Monkey. <br><br>  <strong>1. HTTP client verification</strong> <br><br>  We expect a special behavior from the client when, for example, 502 responses from nginx arrive to it.  We know that this is a cheap answer, so the client automatically repeats it.  To test this logic, a certain percentage of requests take and artificially eject 502 responses.  In my opinion, we have this 1% artificially created errors in production. <br><br>  That is, Chaos Monkey really spoils 1% of internal requests in order to make sure that when real requests come, the system will correctly process them. <br><br>  <strong>2. Mild degradation of applications</strong> <br><br>  The second type of Chaos Monkey is more interesting.  What does soft degradation of applications mean? <br><br>  Imagine that there is a search page, it has the main search functionality, which is our main business.  This functionality is bound by minor components that also make remote calls. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If this minor component falls, we don‚Äôt want the entire page to fall. We expect from a developer who writes minor components that he will develop the system so that when an error from a minor request arrives, we do not generate a 500th answer for our client. To do this, our servers periodically generate 400th responses that mean that the request was incorrectly formed, and therefore the HTTP client forwards it to the topmost stack into the application, which is visible to the developer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This mechanism Chaos Monkey works for us only within the company. It is clear that if we run this in business, we can lower the conversion, which is not good.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we are really talking about the failure of part of the functionality, we always have a list of critical queries, for example, the same basic search query, which does not participate in this logic. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Readiness for delays in replication</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The last kind of Chaos Monkey stands a little apart. We have a data retrieval system, to which the client comes and says: ‚ÄúI have 1000 records, give me all of them!‚Äù But this system uses MySQL for data storage and it may turn out that some of these records have only been recorded and the master record did not have time to fly to the slave. Therefore, from time to time it happens that the system responds that it has 900 and 100 does not yet, because they did not have time to fly to the slave and appear later.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the Chaos Monkey mechanism, we test this functionality. </font><font style="vertical-align: inherit;">The system generates the correct 200th answer, but emulates the logical error that some of the records are simply missing. </font><font style="vertical-align: inherit;">This also works in production. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We return to the chart. </font></font><br><br><img src="https://habrastorage.org/webt/k2/-p/n1/k2-pn1dctddsxznxech3bxcjfi4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, the components are much larger. </font><font style="vertical-align: inherit;">Only from what I know:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the server side, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prioritization of requests</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throttling is</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> needed </font><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the client side, there is such an interesting thing as a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">circuit breaker</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , when the client locally decides not to send a request to the server so that just the service consumer knows who he is talking to.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">discovery</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> logic </font><font style="vertical-align: inherit;">, smart </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">load balancing</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and much more.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is if we talk only about the stack above the transport, and there is still a lot of everything inside the transport that needs to be properly configured in order for the system to work predictably.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Predictable HTTP request sending is a difficult task! There are so many components that need to be properly configured. All systems are different, there are no silver bullets. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In short, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test and test</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! In my opinion, the only way to make the system work is to put it in boundary conditions and see how it will react. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Booking, we had to slightly reinvent the wheel and write our own framework. Most likely, you do not work with Perl, so you are lucky a little more. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Look</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> at frameworks such as gRPC and Finagle. If you prefer proxy servers, then Linkerd and Envoy. I‚Äôll say right away that I don‚Äôt have any experience with production systems, I cannot recommend anything concrete.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Last - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">experiment with the queues</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In our experience, we realized that the length of the queue can drastically change the behavior of the system, which happened to us. </font><font style="vertical-align: inherit;">So put a note - try to play. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But please do not copy my example - take and check. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is an important point - if you want to experiment, control over the client is important, because your system behavior is changing, and it is important that your client adapt as well. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What I showed only works when there is a web server behind nginx that works through a unix socket. </font><font style="vertical-align: inherit;">TCP socket behaves differently. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's all for today, and below are links that can help sort out the details:</font></font><br><br><ul><li> <a href="https://github.com/ikruglov/slapper"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/ikruglov/slapper</font></font></a> <br></li><li> <a href="https://landing.google.com/sre/book.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SRE book</font></font></a> <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resiliency patterns </font></font><br><ul><li> <a href="https://developers.redhat.com/blog/2017/05/16/it-takes-more-than-a-circuit-breaker-to-create-a-resilient-application/">https://developers.redhat.com/blog/2017/05/16/it-takes-more-than-a-circuit-breaker-to-create-a-resilient-application/</a> <br></li><li> <a href="https://www.youtube.com/watch%3Fv%3DdlixGkelP9U">https://www.youtube.com/watch?v=dlixGkelP9U</a> <br></li><li> <a href="https://www.youtube.com/watch%3Fv%3DmodXC5IWTJI">https://www.youtube.com/watch?v=modXC5IWTJI</a> <br></li></ul></li><li> circuit breaker <br><ul><li> <a href="https://landing.google.com/sre/book/chapters/handling-overload.html">SRE book Chapter 21 ‚Äî Handling Overload</a> <br></li><li> <a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker">https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker</a> <br></li></ul></li><li> back-off <br><ul><li> <a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">https://www.awsarchitectureblog.com/2015/03/backoff.html</a> <br></li></ul></li><li> tcp_abort_on_overflow <br><ul><li> <a href="http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html">http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html</a> <br></li><li> <a href="https://www.frozentux.net/ipsysctl-tutorial/chunkyhtml/tcpvariables.html">https://www.frozentux.net/ipsysctl-tutorial/chunkyhtml/tcpvariables.html</a> <br></li><li> <a href="https://github.com/ton31337/tools/wiki/Is-net.ipv4.tcp_abort_on_overflow-good-or-not%3F">https://github.com/ton31337/tools/wiki/Is-net.ipv4.tcp_abort_on_overflow-good-or-not%3F</a> <br></li></ul></li></ul><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This year we decided to combine the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HighLoad ++ Junior</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Backend Conf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> programs </font><font style="vertical-align: inherit;">- now the topics of both conferences will be considered as part of the </font></font><a href="http://backendconf.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Backend Conf RIT ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">So do not worry, nothing is missing and we still look forward to your requests for reports. </font><font style="vertical-align: inherit;">And the impatience is growing, registration in the speakers is open only until </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">April 9</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/352132/">https://habr.com/ru/post/352132/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352122/index.html">Modern PHP without frameworks</a></li>
<li><a href="../352124/index.html">Interview with cosmonautics popularizer, ballistic programmer Anton Gromov</a></li>
<li><a href="../352126/index.html">CodeFest 2018: We Hire Talents</a></li>
<li><a href="../352128/index.html">ES6: useful tips and non-obvious techniques</a></li>
<li><a href="../352130/index.html">What tools for teamwork make ordinary employees of the Dream Team?</a></li>
<li><a href="../352134/index.html">Once again about JetBrains Open Day in Moscow</a></li>
<li><a href="../352136/index.html">As I was looking for the perfect tool for designing conversational interfaces, or Finding the Holy Grail</a></li>
<li><a href="../352138/index.html">Artificial Intelligence and Neural Networks for .NET Developers</a></li>
<li><a href="../352144/index.html">How to speed up PostgreSQL 10</a></li>
<li><a href="../352146/index.html">IPv6 in every home: Your own IPv6 broker server (6in4)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>