<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Vacation programmatically, or as I did not participate in the competition for programming on JS. Part two</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part of this description of an attempt to solve an interesting competitive problem, I talked about preparing data for analysis and about ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Vacation programmatically, or as I did not participate in the competition for programming on JS. Part two</h1><div class="post__text post__text-html js-mediator-article"><p>  In the <a href="https://habrahabr.ru/company/megalenta/blog/302020/">first part of</a> this description of an attempt to solve an interesting competitive problem, I talked about preparing data for analysis and about several experiments.  Let me remind you that the condition of the <a href="https://habrahabr.ru/company/hola/blog/282624/">problem</a> was to most likely determine the presence of a word in the dictionary, without having access to this dictionary at the time of the program execution and with a restriction on the program size (including data) in 64K. <br><img src="https://habrastorage.org/files/c4f/f96/10b/c4ff9610be6d4b0aa0d08f4939775b1a.jpg" alt="image"><br>  Like last time, there is a lot of SQL, JS, as well as neural networks and a Bloom filter under the cat. </p><a name="habracut"></a><br><p>  Let me remind you that the last experiment described was an attempt to solve the problem through building a decision tree.  The next technology tested was the relationship search algorithm included in the Microsoft Data Mining package.  Here is the result of his work: </p><br><img src="https://habrastorage.org/files/6ac/da7/e20/6acda7e201ea412ba6cf70bdb9ac9b0e.png" alt="image"><br><p>  The picture shows that the algorithm shows us that, in his opinion, if the word 6 has vowels and there are no letters "Z", "X" and "J", then with a probability of 97.5% there is no word in the dictionary.  Checking how much test data covers all the rules - it turns out that most.  I'm happy with the result, take the rules, switch from DataGrip to WebStorm and write JS-code. <br>  The code to check looks like this: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wordStat=getWordStat(word); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrongRules=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> trueRules=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWordStat</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">word</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    var result={vowels:0,consonants:0}; for (var i=0;i&lt;word.length;i++) { result[word[i]]=result[word[i]]?(result[word[i]]+1):1; if ('aeiouy'.indexOf(word[i])&gt;-1)result.vowels++; else if (word[i]!="'")result.consonants++; } return result; } for (i=0;i&lt;rules.length;i++) { var passed=0; var rulesCount=0; for (var rule in rules[i]){ rulesCount++; if((wordStat[rule.toLowerCase()]?wordStat[rule.toLowerCase()]:0)==rules[i][rule])passed++; } if (passed==rulesCount&amp;&amp;rulesCount!=0) { return false; } }</span></span></code> </pre> <br><p>  I don‚Äôt think about data packing, I‚Äôm just building in Excel json type </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rules= [ {<span class="hljs-string"><span class="hljs-string">"Consonants"</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-string"><span class="hljs-string">"H"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-string"><span class="hljs-string">"X"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-string"><span class="hljs-string">"J"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Consonants"</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-string"><span class="hljs-string">"H"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-string"><span class="hljs-string">"V"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-string"><span class="hljs-string">"Q"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>} ]</code> </pre> <br><p>  Another moment of truth ... And another disappointment - 65%.  There is no question about 97.5%. <br>  I check how much data and how it is eliminated by the rules - I get a lot of false negative and false positives.  I begin to understand what were my two main "puncture".  I did not take into account the repetitions of words and the proportions of arrays.  Those.: <br>  1) initially suggested that the probability of testing on test words will coincide with the probability in the test sets.  But the words in the test sets are repeated and these repetitions greatly reduce the picture, if I am mistaken on these words.  By the way, the thought immediately appears to consider all repeated words to be correct. <br>  2) the mining algorithms did everything correctly: they saw ten thousand correct words for a million wrong words and were delighted with the probability of 99%.  I did the wrong thing by feeding the algorithm incommensurable volumes of right and wrong words.  For example, check the above rule <strong>{"Consonants": 6, "H": 0, "X": 0, "J": 0}:</strong> </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> isvalid,<span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> formining10 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Vowels=<span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Z=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> X=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> J=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> isvalid</code> </pre> <br><table><thead><tr><th>  isValid </th><th>  count </th></tr></thead><tbody><tr><td>  0 </td><td>  5117424 </td></tr><tr><td>  one </td><td>  44319 </td></tr></tbody></table><br><p>  Indeed, the difference is more than 100 times, and the algorithm recognized it correctly.  But I can not ignore the 44K correct words, because  when checking the proportions will be approximately equal.  So, it is necessary to feed the same size arrays of correct and incorrect words.  But after all, 600K of incorrect words will not be enough ... I will take another 10M test words, but already with repetitions, i.e.  without removing either positive or negative duplicates.  The only thing I do is clean the "garbage" through the filters described in the first article (non-existent pairs / triples).  I feed the mining ... Alas, he does not find adequate rules in this situation, and when he tries to build a decision tree, he says that he hasn‚Äôt found anything good.  Let me remind you that I cut off all the "obvious" wrong options even before the mining data was fed through the wrong pairs / triples. </p><br><p>  Returning to the "descriptive" method. <br>  Let me remind you that in the first part of an article for mining, I created on the basis of the dictionary a table with a string corresponding to a word, a column ‚Äî the number of the character in the word, and the cell values ‚Äã‚Äãis the ordinal number of the letter in the alphabet (27 for the apostrophe).  From this table I make a "map" for each length, i.e.  for how long on which place this or that letter cannot be found.  For example, "7'4" means that in the words of seven letters the apostrophe cannot be the fourth character, and "15b14" means that in the words of the 15 letters "b" has never been seen before the last one. </p><br><p>  Create a table with letter positions for each word length. </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word),<span class="hljs-string"><span class="hljs-string">''''</span></span> letter, <span class="hljs-keyword"><span class="hljs-keyword">charindex</span></span>(<span class="hljs-string"><span class="hljs-string">''''</span></span>,word) <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpl from words where charindex('''',word)&gt;0 union select length=len(word),'a' letter, charindex('a',word) number from words where charindex('a',word)&gt;0 ... union select length=len(word),'z' letter, charindex('z',word) number from words where charindex('z',word)&gt;0</span></span></code> </pre> <br><p>  Make a Cartesian product of letters, lengths and positions, and then left join existing ones </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> l.length,a.letter,l.length <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> allchars a <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">21</span></span>) n <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">21</span></span>) l <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpl t on a.letter=t.letter and t.number=n.number and t.length=l.length where t.letter is not null</span></span></code> </pre> <br><p>  Next, we supplement the position number in the word "trimmed" half-measure from the first part to check for nonexistent combinations of two and three characters in the word. <br>  Choose pairs and triples: </p><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  . cright  cwrong ‚Äì     . create table stat2(letters char(2),pos int,cright int,cwrong int) create table stat3(letters char(3),pos int,cright int,cwrong int) create table #tmp2(l varchar(2),valid int,invalid int) create table #tmp3(l varchar(3),valid int,invalid int) -- declare @i INT set @i=0 while @i&lt;20 begin set @i=@i+1 truncate table #tmp2 truncate table #tmp3 -- insert into #tmp2 select substring(word,@i,2),0,count(*) from wrongwords where len(word)&gt;@i group by substring(word,@i,2) -- insert into #tmp3 select substring(word,@i,2),count(*),0 from words where len(word)&gt;@i group by substring(word,@i,2) insert into stat2 -- select e.letters2,@i,r.valid,l.invalid from allchars2 e left join #tmp2 l on ll=e.letters2 left join #tmp3 r on rl=e.letters2 end declare @i INT set @i=0 while @i&lt;19 begin set @i=@i+1 truncate table #tmp2 truncate table #tmp3 -- insert into #tmp2 select substring(word,@i,3),0,count(*) from wrongwords where len(word)&gt;@i+1 group by substring(word,@i,3) -- insert into #tmp3 select substring(word,@i,3),count(*),0 from words where len(word)&gt;@i+1 group by substring(word,@i,3) -- insert into stat3 select e.letters3,@i,r.valid,l.invalid from allchars3 e left join #tmp2 l on ll=e.letters3 left join #tmp3 r on rl=e.letters3 print @i end</span></span></code> </pre><br><p>  I copy the result to Excel, play with the number in the correct and incorrect words, leaving only the theoretically most likely (found at least in 5-10 words) and the most useful (correct / incorrect ratio at least 1: 300). <br>  I do the pivot table.  The result looks like this: <br><img src="https://habrastorage.org/files/0d3/78b/783/0d378b7838d0434390e7ab1b30364744.png" alt="image"></p><br><p>  I make the data for the program: pair + bitmask (see the formula at the top of the picture). <br><img src="https://habrastorage.org/files/b5f/4a3/992/b5f4a3992fed4e6b879129fc3bd5ba48.png" alt="image"></p><br><p>  The download code is similar to that described in the first part, but the check is changing. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (letters <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> letters2Map) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (word.indexOf(letters)&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((letters2Map[letters] &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) ==<span class="hljs-number"><span class="hljs-number">1</span></span>) { result = <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k=<span class="hljs-number"><span class="hljs-number">0</span></span>;k&lt;<span class="hljs-number"><span class="hljs-number">21</span></span>;k++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((letters2Map[letters] &amp; <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">2</span></span>,k+<span class="hljs-number"><span class="hljs-number">1</span></span>))==<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">2</span></span>,k+<span class="hljs-number"><span class="hljs-number">1</span></span>))&amp;&amp; (letters[<span class="hljs-number"><span class="hljs-number">0</span></span>] == word[k<span class="hljs-number"><span class="hljs-number">-1</span></span>]) &amp;&amp; (letters[<span class="hljs-number"><span class="hljs-number">1</span></span>] == word[k])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } } }</code> </pre><br><p>  Check: again, no more than 65%.  There is a desire to "cheat a little" and improve the result, based on the logic of the generator: </p><br><ol><li>  Treat all repetitions as correct words, since  wrong ones repeat much less often.  There are some strange clear leaders in repetition among the wrong ones, but they can be simply described as exceptions. </li><li>  Monitor the proportions correctly / incorrectly in packages of 100 words and align them after a 60/40 skew. </li></ol><br><p>  But both of these options are a) unreliable and b) ‚Äúunsportsmanlike,‚Äù so I leave them for later. <br>  I want to make the last check without restriction on the amount of data to make sure that it is impossible to solve the problem in a descriptive way.  To do this, I decide to add all "neighboring" pairs and triples of characters to the checks.  I start with the pairs, fill the table: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> @i <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> @i=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> @i&lt;<span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> @i=@i+<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> stat2_1 <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,@i,<span class="hljs-number"><span class="hljs-number">2</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,@i+<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>),@i,<span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*),<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> words <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)&gt;@i+<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,@i,<span class="hljs-number"><span class="hljs-number">2</span></span>),<span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,@i+<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  I save the result simply in the text, I check on the data - the result is about 67%. <br>  It should be borne in mind that if the word is not eliminated as incorrect, the result is considered positive.  This means that even 67% is achieved only due to the fact that about half of the words are obviously positive, which means that I eliminate a little more than a third of the wrong words.  Since I went through almost all the available options for determining the incorrectness of a word through a combination of letters, I come to the disappointing conclusion that this method can only work as an additional filter, and it is necessary to return to neural networks.  Well, it does not work out to create rules for identifying incorrect words like "numismatograph" and "troid". </p><br><p>  Since, because of too long training, the options with the presence of incorrect words in the set disappear, I decide to try <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D0%25B9%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B5%25D1%2582%25D1%258C_%25D0%25A5%25D0%25BE%25D0%25BF%25D1%2584%25D0%25B8%25D0%25BB%25D0%25B4%25D0%25B0">the Hopfield network</a> .  I find the <a href="https://github.com/cazala/synaptic/wiki/Architect">synaptic</a> implementation ready.  I test on a small set - the result is surprisingly good.  I check the array on all words of 5 characters - the result exceeds 80%.  At the same time, the library can even build a function that will check the data without connecting the library itself: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> run = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ F = { <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, ... <span class="hljs-number"><span class="hljs-number">370</span></span>: <span class="hljs-number"><span class="hljs-number">-0.7308188776194796</span></span>, ... <span class="hljs-number"><span class="hljs-number">774</span></span>: <span class="hljs-number"><span class="hljs-number">8.232535948940295e-7</span></span> }; F[<span class="hljs-number"><span class="hljs-number">0</span></span>] = input[<span class="hljs-number"><span class="hljs-number">0</span></span>]; ... F[<span class="hljs-number"><span class="hljs-number">26</span></span>] += F[<span class="hljs-number"><span class="hljs-number">0</span></span>] * F[<span class="hljs-number"><span class="hljs-number">28</span></span>]; F[<span class="hljs-number"><span class="hljs-number">26</span></span>] += F[<span class="hljs-number"><span class="hljs-number">1</span></span>] * F[<span class="hljs-number"><span class="hljs-number">29</span></span>]; ... F[<span class="hljs-number"><span class="hljs-number">53</span></span>] = (<span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.exp(-F[<span class="hljs-number"><span class="hljs-number">26</span></span>]))); F[<span class="hljs-number"><span class="hljs-number">54</span></span>] = F[<span class="hljs-number"><span class="hljs-number">53</span></span>] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - F[<span class="hljs-number"><span class="hljs-number">53</span></span>]); F[<span class="hljs-number"><span class="hljs-number">55</span></span>] = F[<span class="hljs-number"><span class="hljs-number">56</span></span>]; F[<span class="hljs-number"><span class="hljs-number">56</span></span>] = F[<span class="hljs-number"><span class="hljs-number">57</span></span>]; ... F[<span class="hljs-number"><span class="hljs-number">773</span></span>] = (<span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.exp(-F[<span class="hljs-number"><span class="hljs-number">746</span></span>]))); F[<span class="hljs-number"><span class="hljs-number">774</span></span>] = F[<span class="hljs-number"><span class="hljs-number">773</span></span>] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - F[<span class="hljs-number"><span class="hljs-number">773</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> output = []; output[<span class="hljs-number"><span class="hljs-number">0</span></span>] = F[<span class="hljs-number"><span class="hljs-number">53</span></span>]; ... output[<span class="hljs-number"><span class="hljs-number">24</span></span>] = F[<span class="hljs-number"><span class="hljs-number">773</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; }</code> </pre> <br><p>  I am naively happy (once again) and check on the whole array.  Let me remind you, in the last part for learning networks I created a table in which words are represented by a sequence of blocks of 5 bits, where each block is a binary representation of the sequence number of a letter in the alphabet.  Since the paged data for 21 * 5 input neurons will greatly exceed 64K, I decide to split the long words into two parts and feed each of them. </p><br><p>  Learning script: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> synaptic = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'synaptic'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs=<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Neuron = synaptic.Neuron, Layer = synaptic.Layer, Network = synaptic.Network, Trainer = synaptic.Trainer <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hopfield</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> synaptic.Layer(size); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> output = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> synaptic.Layer(size); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.set({ <span class="hljs-attr"><span class="hljs-attr">input</span></span>: input, <span class="hljs-attr"><span class="hljs-attr">hidden</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">output</span></span>: output }); input.project(output, synaptic.Layer.connectionType.ALL_TO_ALL); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> trainer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> synaptic.Trainer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.learn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">patterns</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> set = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> patterns) set.push({ <span class="hljs-attr"><span class="hljs-attr">input</span></span>: patterns[p], <span class="hljs-attr"><span class="hljs-attr">output</span></span>: patterns[p] }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> trainer.train(set, { <span class="hljs-attr"><span class="hljs-attr">iterations</span></span>: <span class="hljs-number"><span class="hljs-number">50000</span></span>, <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-number"><span class="hljs-number">.000000005</span></span>, <span class="hljs-attr"><span class="hljs-attr">rate</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">log</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> }); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.feed = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pattern</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> output = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.activate(pattern); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pattern = [], error = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> output) { error[i] = output[i] &gt; <span class="hljs-number"><span class="hljs-number">.5</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> - output[i] : output[i]; pattern[i] = output[i] &gt; <span class="hljs-number"><span class="hljs-number">.5</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">pattern</span></span>: pattern, <span class="hljs-attr"><span class="hljs-attr">error</span></span>: error .reduce(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; }) }; } } hopfield.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> synaptic.Network(); hopfield.prototype.constructor = hopfield; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myPerceptron=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> hopfield(<span class="hljs-number"><span class="hljs-number">11</span></span>*<span class="hljs-number"><span class="hljs-number">5</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'formining.csv'</span></span>).toString().split(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> trainingSet=[]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(i%<span class="hljs-number"><span class="hljs-number">10000</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testdata=array[i].split(<span class="hljs-string"><span class="hljs-string">","</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newtestdata1=[] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newtestdata2=[] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(testdata[<span class="hljs-number"><span class="hljs-number">0</span></span>]?<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       testdata.splice(0, 1); //    ,    newtestdata1.push(0); for(var j=0;j&lt;11*5;j++){ newtestdata1.push(parseInt(testdata[j]?1:0)?1:0); } if(length&gt;11) { // ,      newtestdata1.push(1); // "1"  ,      newtestdata2.push(1); for(var j=11*5;j&lt;22*5;j++){ newtestdata2.push(parseInt(testdata[j]?1:0)?1:0); } // "0"  ,      newtestdata2.push(0); } else { // "0"  ,     newtestdata1.push(0); } trainingSet.push(newtestdata1); if(length&gt;11){ trainingSet.push(newtestdata2); } } myPerceptron.learn(trainingSet);</span></span></code> </pre> <br><p>  The cycle for getting the result is the same, only instead of trainingSet.push there will be a forecast through myPerceptron.activate (newtestdataX) and a bit-by-bit comparison with the last element of the line with the word in which I saved the result (the data file, of course, will also be different - with adding the wrong words). <br>  I check. <br>  Catastrophe. <br>  Not a single correct answer.  More precisely, all questions get a positive response.  Returning to a set of five characters.  Works fine.  I remove the second part of the word - it still does not work as it should.  By experimenting, I stumble upon a strange feature: the array on five characters works fine exactly until I mix it up.  That is, the algorithm is well trained solely due to the good location of the stars.  In any other situation on a large amount of data, regardless of the settings, this particular algorithm selects the factors in such a way that they give a positive answer with almost any data set. <br>  Once again I get upset.  Only a day remained until the end of the contest, but I decide to continue the search.  Stumble upon a bloom <a href="http://developers-club.com/posts/112069/">filter</a> .  I put a deliberately large size (10,000,000).  I check.  95%.  Hooray!  I reduce to a million - the result worsens to 81%.  I decide to replace the words with their <a href="">hash</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitwise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; str.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ch = str.charCodeAt(i); hash = ((hash&lt;&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>)-hash) + ch; hash = hash &amp; hash; <span class="hljs-comment"><span class="hljs-comment">// Convert to 32bit integer } return hash; } function binaryTransfer(integer, binary) { binary = binary || 62; var stack = []; var num; var result = ''; var sign = integer &lt; 0 ? '-' : ''; function table (num) { var t = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; return t[num]; } integer = Math.abs(integer); while (integer &gt;= binary) { num = integer % binary; integer = Math.floor(integer / binary); stack.push(table(num)); } if (integer &gt; 0) { stack.push(table(integer)); } for (var i = stack.length - 1; i &gt;= 0; i--) { result += stack[i]; } return sign + result; } function unique (text) { var id = binaryTransfer(bitwise(text), 61); return id.replace('-', 'Z'); }</span></span></code> </pre> <br><p>  The result was 88%.  I upload data - a lot.  I think how to reduce.  Reduce the size of the filter to 500,000 - the result worsens to 80%.  I suppose you need to reduce the number of words. <br>  The logical first step is to remove more than 100K duplicate words with "'s".  But I would like to do something more substantial.  I will not list all the tested options for reducing the dictionary, I‚Äôll dwell on the last one I chose as a worker: </p><br><p>  The basic idea is to remove words from the dictionary that are already contained in other words, but with prefixes and endings, and add a bit mask to the absorbing words, which will say whether the correct words are the same as this, but without first / last 1/2/3/4 letters.  Then at the time of verification we will take the word and try it with all possible prefixes and endings. </p><br><p>  For example (option with "'s"), the word "sucralfate's4" means that the word "sucralfate" still exists, and the word "suckstone16" means that there is also the word "stone", and "suctorian's12" means that both "suctorian" and "suctoria" will also be correct. <br>  It remains only a little - to figure out how to create such a directory.  The result is the following algorithm: </p><br><p>  We make tables with prefixes and endings </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word,p=<span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word),<span class="hljs-number"><span class="hljs-number">1</span></span>),w=<span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-comment"><span class="hljs-comment">#a1 from words where len(word)&gt;2 select word,p=substring(word,1,1),w=substring(word,2,len(word)-1) into #b1 from words where len(word)&gt;2 select word,p=substring(word,len(word)-1,2),w=substring(word,1,len(word)-2) into #a2 from words where len(word)&gt;3 select word,p=substring(word,len(word)-2,3),w=substring(word,1,len(word)-3) into #a3 from words where len(word)&gt;4 select word,p=substring(word,len(word)-3,4),w=substring(word,1,len(word)-4) into #a4 from words where len(word)&gt;5 select word,p=substring(word,1,2),w=substring(word,3,len(word)-2) into #b2 from words where len(word)&gt;3 select word,p=substring(word,1,3),w=substring(word,4,len(word)-3) into #b3 from words where len(word)&gt;3 select word,p=substring(word,1,4),w=substring(word,5,len(word)-4) into #b4 from words where len(word)&gt;4</span></span></code> </pre> <br><p>  General table for the result </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word, <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word),<span class="hljs-number"><span class="hljs-number">1</span></span>) s1, <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)<span class="hljs-number"><span class="hljs-number">-1</span></span>) sw1, <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) s2, <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)<span class="hljs-number"><span class="hljs-number">-2</span></span>) sw2, <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) s3, <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)<span class="hljs-number"><span class="hljs-number">-3</span></span>) sw3, <span class="hljs-keyword"><span class="hljs-keyword">IIF</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)<span class="hljs-number"><span class="hljs-number">-3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>),<span class="hljs-string"><span class="hljs-string">''</span></span>) s4, <span class="hljs-keyword"><span class="hljs-keyword">IIF</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)<span class="hljs-number"><span class="hljs-number">-4</span></span>),<span class="hljs-string"><span class="hljs-string">''</span></span>) sw4, <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) p1,<span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)<span class="hljs-number"><span class="hljs-number">-1</span></span>) pw1, <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) p2,<span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)<span class="hljs-number"><span class="hljs-number">-2</span></span>) pw2, <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) p3,<span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)<span class="hljs-number"><span class="hljs-number">-3</span></span>) pw3, <span class="hljs-keyword"><span class="hljs-keyword">IIF</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>),<span class="hljs-string"><span class="hljs-string">''</span></span>) p4,<span class="hljs-keyword"><span class="hljs-keyword">IIF</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(word,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(word)<span class="hljs-number"><span class="hljs-number">-4</span></span>),<span class="hljs-string"><span class="hljs-string">''</span></span>) pw4, se1=<span class="hljs-literal"><span class="hljs-literal">null</span></span>,se2=<span class="hljs-literal"><span class="hljs-literal">null</span></span>,se3=<span class="hljs-literal"><span class="hljs-literal">null</span></span>,se4=<span class="hljs-literal"><span class="hljs-literal">null</span></span>,pe1=<span class="hljs-literal"><span class="hljs-literal">null</span></span>,pe2=<span class="hljs-literal"><span class="hljs-literal">null</span></span>,pe3=<span class="hljs-literal"><span class="hljs-literal">null</span></span>,pe4=<span class="hljs-literal"><span class="hljs-literal">null</span></span>,excluded=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpwords from words where len(word)&gt;2</span></span></code> </pre> <br><p>  Indices not to wait forever </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> a1 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpwords(word) create index p0 on #tmpwords(s1) create index p1 on #tmpwords(sw1) create index p2 on #tmpwords(s2) create index p3 on #tmpwords(sw2) create index p4 on #tmpwords(s3) create index p5 on #tmpwords(sw3) create index p6 on #tmpwords(s4) create index p7 on #tmpwords(sw4) create index p20 on #tmpwords(p1) create index p30 on #tmpwords(pw1) create index p21 on #tmpwords(p2) create index p31 on #tmpwords(pw2) create index p41 on #tmpwords(p3) create index p51 on #tmpwords(pw3) create index p61 on #tmpwords(p4) create index p71 on #tmpwords(pw4)</span></span></code> </pre> <br><p>  We count and save the number of words with each prefix and the end of each length: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-comment"><span class="hljs-comment">#a11 from #a1 a join words w on w.word=aw and len(w.word)&gt;2 group by p having count(*)&gt;1 select p into #a21 from #a2 a join words w on w.word=aw and len(w.word)&gt;2 group by p having count(*)&gt;1 select p into #a31 from #a3 a join words w on w.word=aw and len(w.word)&gt;2 group by p having count(*)&gt;1 select p into #a41 from #a4 a join words w on w.word=aw and len(w.word)&gt;2 group by p having count(*)&gt;1 select p into #b11 from #b1 a join words w on w.word=aw and len(w.word)&gt;2 group by p having count(*)&gt;1 select p into #b21 from #b2 a join words w on w.word=aw and len(w.word)&gt;2 group by p having count(*)&gt;1 select p into #b31 from #b3 a join words w on w.word=aw and len(w.word)&gt;2 group by p having count(*)&gt;1 select p into #b41 from #b4 a join words w on w.word=aw and len(w.word)&gt;2 group by p having count(*)&gt;1</span></span></code> </pre> <br><p>  Mark the words absorbers in the table with the result </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">update</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> se1=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpwords w join #a11 a on ap=w.s1 join #tmpwords t on t.word=w.sw1 update w set se2=1 from #tmpwords w join #a21 a on ap=w.s2 join #tmpwords t on t.word=w.sw2 update w set se3=1 from #tmpwords w join #a31 a on ap=w.s3 join #tmpwords t on t.word=w.sw3 update w set se4=1 from #tmpwords w join #a41 a on ap=w.s4 join #tmpwords t on t.word=w.sw4 update w set pe1=1 from #tmpwords w join #b11 a on ap=w.p1 join #tmpwords t on t.word=w.pw1 update w set pe2=1 from #tmpwords w join #b21 a on ap=w.p2 join #tmpwords t on t.word=w.pw2 update w set pe3=1 from #tmpwords w join #b31 a on ap=w.p3 join #tmpwords t on t.word=w.pw3 update w set pe4=1 from #tmpwords w join #b41 a on ap=w.p4 join #tmpwords t on t.word=w.pw4</span></span></code> </pre> <br><p>  Create a combined result in order to select the most frequent options. </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s1 p,<span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) cnt <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-comment"><span class="hljs-comment">#suffixes from #tmpwords where se1 is not NULL group by s1 union all select s2,count(*) from #tmpwords where se2 is not NULL group by s2 union all select s3,count(*) from #tmpwords where se3 is not NULL group by s3 union all select s4,count(*) from #tmpwords where se4 is not NULL group by s4 select p1,count(*) cnt into #prefixes from #tmpwords where pe1 is not NULL group by p1 union all select p2,count(*) from #tmpwords where pe2 is not NULL group by p2 union all select p3,count(*) from #tmpwords where pe3 is not NULL group by p3 union all select p4,count(*) from #tmpwords where pe4 is not NULL group by p4</span></span></code> </pre> <br><p>  We leave only those that occur in more than 100 words. </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> *,<span class="hljs-string"><span class="hljs-string">'s'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">IIF</span></span>(cnt&gt;<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) excluded <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-comment"><span class="hljs-comment">#result from #suffixes union all select *,'p' type, IIF(cnt&gt;100,0,1) excluded from #prefixes</span></span></code> </pre> <br><p>  Reset statistics </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">update</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpwords set se1=null,se2=null,se3=null,se4=null,pe1=null,pe2=null,pe3=null,pe4=null</span></span></code> </pre> <br><p>  Remove the "extra" consoles and endings </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-comment"><span class="hljs-comment">#a11 a join #result r on rp=ap and r.type='s' and excluded=1 delete a from #a21 a join #result r on rp=ap and r.type='s' and excluded=1 delete a from #a31 a join #result r on rp=ap and r.type='s' and excluded=1 delete a from #a41 a join #result r on rp=ap and r.type='s' and excluded=1 delete a from #b11 a join #result r on rp=ap and r.type='p' and excluded=1 delete a from #b21 a join #result r on rp=ap and r.type='p' and excluded=1 delete a from #b31 a join #result r on rp=ap and r.type='p' and excluded=1 delete a from #b41 a join #result r on rp=ap and r.type='p' and excluded=1</span></span></code> </pre><br><p>  Update statistics for the remaining most frequently encountered. </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">update</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> se1=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpwords w join #a11 a on ap=w.s1 join #tmpwords t on t.word=w.sw1 update w set se2=1 from #tmpwords w join #a21 a on ap=w.s2 join #tmpwords t on t.word=w.sw2 update w set se3=1 from #tmpwords w join #a31 a on ap=w.s3 join #tmpwords t on t.word=w.sw3 update w set se4=1 from #tmpwords w join #a41 a on ap=w.s4 join #tmpwords t on t.word=w.sw4 update w set pe1=1 from #tmpwords w join #b11 a on ap=w.p1 join #tmpwords t on t.word=w.pw1 update w set pe2=1 from #tmpwords w join #b21 a on ap=w.p2 join #tmpwords t on t.word=w.pw2 update w set pe3=1 from #tmpwords w join #b31 a on ap=w.p3 join #tmpwords t on t.word=w.pw3 update w set pe4=1 from #tmpwords w join #b41 a on ap=w.p4 join #tmpwords t on t.word=w.pw4</span></span></code> </pre> <br><p>  Mark "absorbed" words </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">update</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> excluded=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpwords w join #a11 a on ap=w.s1 join #tmpwords t on t.word=w.sw1 update t set excluded=1 from #tmpwords w join #a11 a on ap=w.s1 join #tmpwords t on t.word=w.sw1 update t set excluded=1 from #tmpwords w join #a21 a on ap=w.s2 join #tmpwords t on t.word=w.sw2 update t set excluded=1 from #tmpwords w join #a31 a on ap=w.s3 join #tmpwords t on t.word=w.sw3 update t set excluded=1 from #tmpwords w join #a41 a on ap=w.s4 join #tmpwords t on t.word=w.sw4 update t set excluded=1 from #tmpwords w join #b21 a on ap=w.p2 join #tmpwords t on t.word=w.pw2 update t set excluded=1 from #tmpwords w join #b31 a on ap=w.p3 join #tmpwords t on t.word=w.pw3 update t set excluded=1 from #tmpwords w join #b41 a on ap=w.p4 join #tmpwords t on t.word=w.pw4</span></span></code> </pre><br><p>  Profit :-) </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> excluded,<span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) cnt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpwords group by excluded</span></span></code> </pre> <br><table><thead><tr><th>  excluded </th><th>  cnt </th></tr></thead><tbody><tr><td>  0 </td><td>  397596 </td></tr><tr><td>  one </td><td>  232505 </td></tr></tbody></table><br><p>  The directory shrank to 23,2505 lossless entries. <br>  Now we need to make a check.  It became very complicated and slowed down due to the need to iterate through all possible prefixes and endings: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    result=bloom.test(unique(word)) if(result){ return true; } //     for(var i=0;i&lt;255;i++) { //    - result=bloom.test(unique(word+i)) if(result){ return true; } //     for (var part in parts ){ //1-,2- var testword=(parts[part]==2?part:"")+word+(parts[part]==1?part:""); //       ,    4  bitmask=Math.pow(2,(parts[part]-1)*4+part.length); //    if(i&amp;bitmask==bitmask){ result=bloom.test(unique(testword+i)) if (result){ return true } } }</span></span></code> </pre> <br><p>  I run.  The result has worsened.  But he had to improve!  There is no time left, the debugger on the webstorm is terribly buggy, I don‚Äôt have time to figure it out.  There is no sense to send what is, but it was interesting.  I hope you do too.  "Holiday" ends, it's time to go back to <del>  my sheep </del>  your <a href="http://megalenta.ru/">project</a> .  Thanks for attention. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/302066/">https://habr.com/ru/post/302066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302046/index.html">Dash Financing and Management System</a></li>
<li><a href="../302050/index.html">Embedding PyPy Code in C Applications</a></li>
<li><a href="../302056/index.html">Telegram Site Helper 2.0 - chat assistant for a site based on Telegram</a></li>
<li><a href="../302060/index.html">IT & Security Forum 2016 is over</a></li>
<li><a href="../302062/index.html">[PF] Print PDF under .NET, vector approach, practice</a></li>
<li><a href="../302068/index.html">Overview of options for organizing access to corporate network services from the Internet</a></li>
<li><a href="../302070/index.html">Cross-platform mobile development: questions for adults</a></li>
<li><a href="../302072/index.html">CTCrypt 2016 - cryptography for every taste</a></li>
<li><a href="../302074/index.html">Analysis of the tasks of the second qualifying round of the RCC 2016</a></li>
<li><a href="../302076/index.html">C # - is there something extra?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>