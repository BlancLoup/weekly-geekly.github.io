<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>History of programming languages: 100% "pure" C, without a single "plus"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The popularity of the C programming language is difficult to overestimate, especially recalling its past merits. Probably, every developer, at least, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>History of programming languages: 100% "pure" C, without a single "plus"</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/305/b0b/d00/305b0bd00e47c78c27ff05c266e6e563.jpg" alt="image" width="650"><br><br>  The popularity of the C programming language is difficult to overestimate, especially recalling its past merits.  Probably, every developer, at least, knows about its existence, and, as a maximum, tried to program on it.  C is the predecessor of languages ‚Äã‚Äãsuch as C ++, Objective-C, C #, Java. <br><br>  Microsoft has chosen C-like syntax for developing its native language for its .Net platform.  Moreover, C is written many operating systems. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of course, C is not perfect: the creators of the language - Ken Thompson and Dennis Ritchie - have been refining it for a long time.  Standardization of C is still ongoing.  It exists more than 45 years and is actively used. <br><br>  Not one but often two programming languages ‚Äã‚Äãare often associated with it - C / C ++.  However, the following discussion deals specifically with ‚Äúpure‚Äù C. <br><a name="habracut"></a><br>  The C language dates back to the language ALGOL (stands for ALGorithmic Language), which was established in 1958 in conjunction with the committee of European and American computer scientists at a meeting at the Swiss High School of Technical Zurich.  The language was the answer to some of the shortcomings of the FORTRAN language and an attempt to correct them.  In addition, the development of C is closely related to the creation of the UNIX operating system, on which Ken Thompson and Dennis Ritchie also worked. <br><br><h4>  UNIX </h4><br>  The Multiple Access Computer, Man and Computer project, began as a purely research at MIT in 1963. <br><br>  As part of the MAS project, the CTSS (Compatible Time-Sharing System) operating system was developed.  In the second half of the 60s, several other time-sharing systems were created, for example, BBN, DTSS, JOSS, SDC and Multiplexed Information and Computing Service (MULTICS) including. <br><br>  Multics is a joint development of MIT, Bell Telephone Laboratories (BTL) and General Electric (GE) to create a time-sharing OS for the GE-645 computer.  The last computer running Multics turned off on October 31, 2000. <br><br>  However, BTL departed from this project in early 1969. <br><br>  Some of his employees (Ken Thompson, Dennis Ritchie, Stew Feldman, Doug McIlroy, Bob Morris, Joe Ossanna) wanted to continue working independently.  Thompson worked on the Space Travel game on the GE-635.  It was written first for Multics, and then rewritten in Fortran under GECOS on GE-635.  The game modeled the bodies of the solar system, and the player had to put the ship somewhere on the planet or satellite. <br><br>  Neither the software nor the hardware of this computer was suitable for such a game.  Thompson was looking for an alternative, and rewrote the game under the ownerless PDP-7.  The memory was 8K of 18-bit words, and there was also a vector display processor for outputting beautiful graphics for that time. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f6/7b0/c8c/4f67b0c8c5d65b48520a64bd61364145.jpg" alt="image" width="500"><br>  <i><a href="">Image</a> from slideshare.net</i> <br><br>  Thompson and Ritchie were fully cross-assembler at GE and transferred the code to punched tapes.  Thompson did not actively like it, and he began writing an OS for the PDP-7, starting with the file system.  This is how UNIX appeared. <br><blockquote>  Thompson wanted to create a comfortable computing environment, designed in accordance with his design, using any means available.  His ideas, which, obviously looking back, absorbed many of the innovations of Multics, including the concept of process as the basis of management, the tree-like file system, the command interpreter as a user program, a simplified representation of text files and generalized access to devices. </blockquote><br>  PDP-7 UNIX also marked the beginning of the high-level language B, which was created under the influence of the BCPL language.  Dennis Ritchie said that B is C without types.  BCPL was placed in 8 KB of memory and was thoroughly reworked by Thompson.  In gradually grew in C. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a73/e8b/1cf/a73e8b1cffbda9a174d42614d30675dc.jpg" alt="image" width="500"><br>  <i><a href="">Image</a> from it-world.com</i> <br><blockquote>  By 1973, the C language was strong enough, and most of the UNIX kernel, originally written in assembler PDP-11/20, was rewritten in C.  It was one of the very first operating system kernels, written in a language other than assembly language. </blockquote><br>  It turns out that C is a ‚Äúby-product‚Äù obtained during the creation of the UNIX operating system. <br><br><h4>  Progenitors of C </h4><br>  Inspired by the language ALGOL-60, the Mathematical Laboratory of the University of Cambridge, together with the Computer Department of the University of London, created in 1963 the CPL (Combined Programming Language) language. <br><br>  The CPL language was considered difficult, and in response to this, Martin Richardson created the BCPL language in 1966, the main purpose of which was to write compilers.  Now it is practically not used, but in due time because of good portability it played an important role. <br><blockquote>  BCPL was used in the early 1970s in several interesting projects, including the OS6 operating system and partly in the nascent Xerox PARC development. </blockquote><br>  BCPL served as the ancestor of the Bee language (B), developed in 1969 by the well-known AT &amp; T Bell Telephone Laboratories, no less familiar by Ken Thompson and Dennis Ritchie. <br><br>  Like the rest of the operating systems of the time, UNIX was written in assembler.  Debugging programs in assembler real flour.  Thompson decided that a high level language was needed for further OS development and came up with a small language B. Thompson took BCPL as a basis.  Language B can be considered as C without types. <br><br>  In many <a href="http://givi.olnd.ru/chist/">details,</a> BCPL, B, and C are different syntactically, but for the most part they are similar.  Programs consist of a sequence of global declarations and function declarations (procedures).  In BCPL, procedures can be nested, but cannot refer to non-static objects defined in the procedures that contain them.  B and C avoid such a restriction by introducing a stricter one: there are no nested procedures at all.  Each of the languages ‚Äã‚Äã(with the exception of the most ancient versions of B) supports separate compilation and provides the means to include text from named files. <br><br>  In contrast to the ubiquitous syntax change that occurred during the creation of B, the main semantics of BCPL ‚Äî its type structure and the rules for evaluating expressions ‚Äî remained untouched.  Both languages ‚Äã‚Äãare typeless, or rather they have a single data type - ‚Äúword‚Äù or ‚Äúcell‚Äù, a set of bits of fixed length.  Memory in these languages ‚Äã‚Äãis an array of such cells, and the meaning of the contents of the cell depends on the operation that is applied to it.  For example, the "+" operator simply adds its operands using the machine instruction add, and other arithmetic operations are also indifferent to the meaning of its operands. <br><br>  Neither BCPL, nor B, nor C allocate character data in the language;  they consider strings as vectors of integers and supplement the general rules with several conventions.  In both BCPL and B, a string literal means the address of a static region initialized with string characters packed into cells. <br><br><h4>  How was C created </h4><br>  In 1970, Bell Labs acquired the PDP-11 computer for the project.  Since B was ready to work on the PDP-11, Thompson rewrote the UNIX part to B. <br><br>  But model B and BCPL implied costs when working with pointers: the rules of a language, defining a pointer as an index in an array of words, made pointers indexes of words.  Each execution of a pointer during execution generated a pointer scaling to the address of the byte that the processor was expecting. <br><br>  Therefore, it became clear that in order to cope with symbols and byte addressing, as well as prepare for the upcoming hardware support for floating-point calculations, typing is needed. <br><br>  In 1971, Ritchie began to create an expanded version of B. At first, he called it NB (New B), but when the language became very different from B, the name was changed to C. That's what Ritchie himself <a href="http://givi.olnd.ru/chist/">wrote</a> about it: <br><br><blockquote> I wanted the structure not only to characterize an abstract object, but also to describe a set of bits that could be read from the catalog.  Where could the compiler hide the pointer to the name that semantics require?  Even if the structures were conceived more abstract, and the place for pointers could be hidden somewhere, as if I solved the technical problem of correctly initializing these pointers when allocating memory for a complex object, perhaps a structure containing arrays that contain structures, and so to arbitrary depth? <br><br>  The solution consisted in a decisive jump in the evolutionary chain between the typeless BCPL and the typed C. It excluded the materialization of the pointer in the repository, and instead generated its creation when the name of the array was mentioned in the expression.  The rule that has been preserved in today's C is that the values ‚Äã‚Äã‚Äì arrays, when they are mentioned in the expression, are converted into pointers to the first of the objects that make up this array. <br><br>  The second innovation, which most clearly distinguishes C from its predecessors, is this more complete type structure and especially its expressiveness in the syntax of declarations.  NB offered the basic types int and char together with arrays of them and pointers to them, but no other ways to build them. <br><br>  A generalization was required: for an object of any type, it should be possible to describe a new object that combines several such objects into an array, gets it from a function, or is a pointer to it. </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/2b2/5c3/4d0/2b25c34d0f1bc0ace16e20af4876adfb.gif" alt="image" width="400"><br>  <i><a href="">Image</a> from the Book of C Language: M. Waite, S. Prata, D. Martin</i> <br><br>  For any object of this composite type, there was already a way to point to an object that is part of it: index the array, call a function, use an indirect call operator with the pointer.  Similar reasoning led to the syntax of a name declaration, which reflects the syntax of the expression where these names are used.  So <br><blockquote>  int i, * pi, ** ppi; </blockquote>  declares an integer, a pointer to an integer, and a pointer to a pointer to an integer.  The syntax of these declarations reflects the fact that i, * pi, and ** ppi all result in an int type when used in an expression.  In a similar way <br><blockquote>  int f (), * f (), (* f) (); </blockquote>  declare a function that returns an integer, a function that returns a pointer to an integer, a pointer to a function that returns an integer; <br><blockquote>  int * api [10], (* pai) [10]; </blockquote>  declare an array of pointers to integer, a pointer to an array of integers. <br><br>  In all these cases, the declaration of a variable resembles its use in an expression, whose type is what is at the beginning of the declaration. <br><br><h4>  70s: ‚ÄúTime of Troubles‚Äù and False Dialects </h4><br>  By 1973, the language was stable enough for UNIX to be rewritten.  The transition to C provided an important advantage: portability.  By writing a C compiler for each of the machines in Bell Labs, the development team could port UNIX to them. <br><br>  Regarding the emergence of C language, Peter Moylan writes in his book ‚ÄúThe case against C‚Äù: ‚ÄúA language was needed that could circumvent some of the hard and fast rules built into most high-level languages ‚Äã‚Äãand ensure their reliability.  We needed a language that would allow us to do something that before it could be implemented only in assembly language or at the level of machine code. ‚Äù <br><br>  C continued to develop in the 70s.  In 1973‚Äì1980s, the language grew a bit: the structure of types received unsigned, long types, union and enumeration, the structures became close to object ‚Äì classes (all that was needed was notation for literals). <br><br>  The first book on C.  The C Programming Language, written by Brian Kernighan and Dennis Ritchie and published in 1978, became the bible of C programmers.  In the absence of an official standard, this book ‚Äî also known as K &amp; R, or ‚ÄúWhite Paper,‚Äù as C fans love to call it ‚Äî has actually become the standard. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff7/5d2/8a2/ff75d28a2ce537d68e319f7917607670.jpg" alt="image"><br>  <i><a href="">Image</a> from learnc.info</i> <br><br>  In the 70s, C programmers were few and most of them were UNIX users.  However, in the 1980s, C went beyond the narrow confines of the UNIX world.  C compilers have become available on various machines running different operating systems.  In particular, C began to spread on the fast-growing IBM PC platform. <br><br>  K &amp; R <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8_(%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">introduced the</a> following language features: <br><br>  ‚Ä¢ structures (data type struct); <br>  ‚Ä¢ long integer (data type long int); <br>  ‚Ä¢ unsigned integer (unsigned int data type); <br>  ‚Ä¢ operator + = and similar ones (old operators = + introduced the C compiler vocabulary analyzer into error, for example, when comparing expressions i = + 10 and i = + 10). <br><br>  K &amp; R C is often considered the most important part of the language that the C compiler must support.  For many years, even after the release of ANSI C, it was considered the minimum level that programmers should adhere to, wishing to achieve maximum portability from their programs, because not all compilers supported ANSI C at that time, and good code in K &amp; R C was also true for ANSI C. <br><br>  Along with the growing popularity, problems appeared.  The programmers who wrote the new compilers took as their basis the language described in K &amp; R.  Unfortunately, in K &amp; R some features of the language were described vaguely, so the compilers often interpreted them at their discretion.  In addition, the book did not clearly distinguish between what is a feature of the language and what is a feature of the UNIX operating system. <br><br>  After publishing K &amp; R C, several features were added to the language, supported by AT &amp; T compilers, and some other manufacturers: <br><br>  ‚Ä¢ functions that do not return a value (with the void type), and pointers that do not have a type (with the void * type); <br>  ‚Ä¢ functions that return associations and structures; <br>  ‚Ä¢ names of the fields of these structures in different namespaces for each structure; <br>  ‚Ä¢ assignment of structures; <br>  ‚Ä¢ constants specifier (const); <br>  ‚Ä¢ a standard library that implements most of the functions introduced by various manufacturers; <br>  ‚Ä¢ enumeration type (enum); <br>  ‚Ä¢ fractional single precision number (float). <br><br>  The situation was worsened by the fact that after the publication of K &amp; R, C continued to develop: new possibilities were added to it and old ones were cut out of it.  Soon there was an obvious need for an exhaustive, accurate and up-to-date description of the language.  Without such a standard, dialects of the language began to appear, which interfered with portability - the strongest side of the language. <br><br><h4>  Standards </h4><br>  In the late 1970s, the C language began to crowd out BASIC, which at that time was the leader in the field of microcomputer programming.  In the 1980s, it was adapted to the IBM PC architecture, which led to a significant jump in its popularity. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e2b/954/36a/e2b95436ac125638f8b90da78ee3fd7c.gif" alt="image" width="500"><br><br>  The development of the C language standard was undertaken by the American National Standards Institute (ANSI).  When it was in 1983, a committee X3J11 was formed, which was engaged in the development of the standard.  The first version of the standard was released in 1989 and was named C89.  In 1990, making small changes to the standard, it was adopted by the International Organization for Standardization ISO.  Then he became known under the ISO / IEC 9899: 1990 code, but the name associated with the year of adoption of the standard, C90, was fixed among the programmers.  The latest version of the standard is ISO / IEC 9899: 1999, also known as C99, which was adopted in 2000. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ad/ad2/fc9/7adad2fc954c433a3adb991136c6797d.png" alt="image" width="500"><br><br>  Among the innovations of the standard C99 is worth paying attention to the change in the rule regarding the place of declaration of variables.  Now new variables could be declared in the middle of the code, and not just at the beginning of the composite block or in the global scope. <br><br>  Some features of C99: <br><br>  ‚Ä¢ inline functions; <br>  ‚Ä¢ declaration of local variables in any program text operator (as in C ++); <br>  ‚Ä¢ new data types, such as long long int (to facilitate the transition from 32-bit to 64-bit numbers), the explicit Boolean data type _Bool, and the complex type to represent complex numbers; <br>  ‚Ä¢ arrays of variable length; <br>  ‚Ä¢ support for limited pointers (restrict); <br>  ‚Ä¢ named initialization of structures: struct {int x, y, z;  } point = {.y = 10, .z = 20, .x = 30}; <br>  ‚Ä¢ support for single-line comments beginning with //, borrowed from C ++ (many C compilers supported them earlier as an add-on); <br>  ‚Ä¢ several new library functions, such as snprintf; <br>  ‚Ä¢ Several new header files, such as stdint.h. <br><br>  The C99 standard is now more or less supported by all modern C compilers.  Ideally, code written in C in compliance with the standards and without the use of hardware- and system-dependent calls, became both hardware-and platform-independent code. <br><br>  In 2007, work began on the following C standard.  December 8, 2011 published a new standard for the C language (ISO / IEC 9899: 2011).  Some features of the new standard are already supported by GCC and Clang compilers. <br><br>  The main features of C11: <br><br>  ‚Ä¢ multithreading support; <br>  ‚Ä¢ improved Unicode support; <br>  ‚Ä¢ generic macros (type-generic expressions, allow static overload); <br>  ‚Ä¢ anonymous structures and unions (simplify accessing nested structures); <br>  ‚Ä¢ object alignment control; <br>  ‚Ä¢ static statements (static assertions); <br>  ‚Ä¢ removal of the dangerous gets function (in favor of secure gets_s); <br>  ‚Ä¢ quick_exit function; <br>  ‚Ä¢ _Noreturn function specifier; <br>  ‚Ä¢ A new exclusive file open mode. <br><br>  Despite the existence of a standard of 11 years, many compilers still do not fully support even the C99 version. <br><br><h4>  What is C criticized for? </h4><br>  It has a fairly high threshold of entry, which makes it difficult to use it in learning as a first programming language.  When programming in C, you need to take into account many details.  ‚ÄúBeing born in a hacker environment, it stimulates an appropriate programming style, often unsafe, and encourages writing confusing code, <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8_(%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">‚Äù</a> Wikipedia <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8_(%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">writes</a> . <br><br>  More profound and reasoned criticism was <a href="http://oberon2005.oberoncore.ru/paper/arg_vs_c.pdf">expressed by</a> Peter Moylan.  He devoted a total of 12 pages to C criticism.  Let's give a couple of fragments: <br><br><h5>  Problems with modularity </h5><blockquote>  Modular programming in the C language is possible, but only if the programmer adheres to a number of fairly rigid rules: <br><br>  ‚Ä¢ Each module must have exactly one header file.  It should contain only exported function prototypes, descriptions and nothing else (except comments). <br><br>  ‚Ä¢ The external caller about this module should be aware only of the comments in the header file. <br><br>  ‚Ä¢ To verify integrity, each module must import its own header file. <br><br>  ‚Ä¢ To import any information from another module, each module must contain #include lines, as well as comments indicating what is actually being imported. <br><br>  ‚Ä¢ Function prototypes can only be used in header files.  (This rule is necessary because C has no mechanism for checking that a function is implemented in the same module as its prototype; so using a prototype may mask the ‚Äúmissing function‚Äù error - ‚Äúmissing function‚Äù). <br><br>  ‚Ä¢ Any global variable in the module, and any function other than the one imported through the header file must be declared static. <br><br>  ‚Ä¢ A compiler warning ‚Äúfunction call without prototype‚Äù should be provided;  such a warning should always be considered an error. <br><br>  ‚Ä¢ The programmer must ensure that each prototype specified in the header file has a function implemented under the same name in the same module (that is, non-static in conventional C terminology).  Unfortunately, the nature of C language does not automatically verify this. <br><br>  ‚Ä¢ You should be suspicious of any use of the grep utility.  If the prototype is not located in its place, then this is most likely a mistake. <br><br>  ‚Ä¢ Ideally, programmers working in the same team should not have access to each other‚Äôs source files.  They should only share object modules and header files. <br><br>  The obvious difficulty is that few people will follow these rules, because the compiler does not require them to strictly observe.  A modular programming language at least partially protects good programmers from the chaos that bad programmers create.  And the C language is not able to do this. </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/135/237/9bd/1352379bd6d07c7b02b05956b355ddc9.png" alt="image"><br>  <i><a href="">Image</a> from smartagilee.com</i> <br><br><h5>  Pointer issues </h5><blockquote>  Despite all the advances in the theory and practice of data structures, pointers remain a real stumbling block for programmers.  The work with pointers accounts for a significant part of the time spent on debugging the program, and it is they that create most of the problems that complicate its development. <br><br>  You can distinguish between important and unimportant pointers.  Important in our understanding is the pointer needed to create and maintain a data structure. <br><br>  A pointer is considered unimportant if it is not necessary to implement the data structure.  In a typical C program, unimportant pointers are much more than important ones.  There are two reasons for this. <br><br>  The first is that among programmers using C, it has become a tradition to create pointers even where other methods of access are already inferior to them, for example, when viewing array elements. <br><br>  The second reason is the rule of the C language, according to which all parameters of functions should be passed by value.  When you need the equivalent of a Pascal VAR parameter or an Ada language inout parameter, the only solution is to pass a pointer.  This largely explains the poor readability of C programs. <br><br>  The situation is exacerbated when it is necessary to pass an important pointer as an input / output parameter.  In this case, the function must be passed a pointer to a pointer, which creates difficulties even for the most experienced programmers. </blockquote><br><h4>  C - alive </h4><br>  According <a href="http://www.tiobe.com/tiobe_index">to the data of</a> June 2016, the TIOBE index, which measures the growth in popularity of programming languages, showed that C ranks 2nd: <br><br><img src="https://habrastorage.org/files/1da/6f3/ca6/1da6f3ca6abe4d76a55a95df6e35d968.png"><br><br>  Let someone say that Sy is outdated, that his wide distribution is the result of luck and active PR.  Let someone say that without UNIX, the C language would never have been created. <br><br>  However, C has become a kind of standard.  He, one way or another, passed the test of time, unlike many other languages.  C-developers are still in demand, and the IT community remembers the creators of the language with a kind word. </div><p>Source: <a href="https://habr.com/ru/post/304034/">https://habr.com/ru/post/304034/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304024/index.html">"Cut the Gordian knot" or overcoming the problems of encrypting information in Windows</a></li>
<li><a href="../304026/index.html">JSON and PostgreSQL 9.5: with even more powerful tools</a></li>
<li><a href="../304028/index.html">In St. Petersburg to be: reports of the "confrontation" NeoQUEST-2016</a></li>
<li><a href="../304030/index.html">Testing. Errors in certification or ISTQB I really need</a></li>
<li><a href="../304032/index.html">Cloud Storage: API Update</a></li>
<li><a href="../304036/index.html">Full list of extensions for SQL Server Management Studio (SSMS)</a></li>
<li><a href="../304038/index.html">Typography in the design of emails</a></li>
<li><a href="../304040/index.html">Go language, microservices and DevOps - the good company?</a></li>
<li><a href="../304042/index.html">Skeletal animation in games. Technician and Resource Overview</a></li>
<li><a href="../304044/index.html">Ghost buttons in UX design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>