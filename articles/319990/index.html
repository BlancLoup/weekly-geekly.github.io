<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimization of mechanics and graphics in the game of the genre "simulator" on iOS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The rise of simulator games as a genre several years ago showed that any routine can be gamified. The apotheosis was the HYIP around the Goat Simulato...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimization of mechanics and graphics in the game of the genre "simulator" on iOS</h1><div class="post__text post__text-html js-mediator-article">  The rise of simulator games as a genre several years ago showed that any routine can be gamified.  The apotheosis was the HYIP around the Goat Simulator, which was honored to be <a href="http://www.polygon.com/2015/6/8/8747203/bill-hader-apple-video-wwdc-angry-bird-goat-sumilator">mentioned</a> in the key presentation of WWDC 2015. We did not stand aside from this trend, having participated in the development of the engine for a series of applications simulating the work of the subway. <br><br>  <a href="http://go.everydaytools.mobi/SgGFV2">Subway Simulator</a> - a series of simulation games subway.  The very first version of the game, released in 2014, although it was rather abstract, confirmed the demand for a product of a similar subject, and a rather high one - the project took a leading position in its niche almost immediately after launch.  Subsequent updates and new versions of the product were aimed at making the Subway Simulator more realistic: the simulation of trains and stations reached a new level, and also ‚Äúlocalized‚Äù versions of the game appeared, displaying the subways of <a href="http://go.everydaytools.mobi/fYsDyY">New York</a> , <a href="http://go.everydaytools.mobi/pQpzoM">Beijing</a> , <a href="http://go.everydaytools.mobi/cgAxNQ">Moscow</a> and other cities.  At the moment, the total number of installations of the first version of the game on iOS has almost reached the millionth value.  Simultaneously, the game becomes available for other platforms. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9fe/688/195/9fe688195ed54d549bbcb49d0e10b78e.png"></div><a name="habracut"></a><br>  When developing an engine based on the simulation of movement in a space of sufficiently large dimensions, it is necessary to take into account the limits of memory for adequate work on the device.  In games that require significant resource consumption, optimization becomes the determining factor for the user experience.  With its help you can provide a realistic, attractive picture and a smooth gameplay process.  This article will focus on our work on the Subway Simulator 3D simulator and various types of optimization that were used to minimize memory consumption without losing quality. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Application development was conducted on the most accessible Unity game engine.  Considering the fact that periodic updates of the models of new stations to the engine are planned for updates, we stopped at the most trivial, but the only possible solution - the modular core of the game. <br><br>  The principle of work with him, in fact, is the same as that of the classic runners. <br><br>  There is a player‚Äôs prefab (in this case, the train composition, into which the required model of train is loaded, and other parameters - speed, wear, power, sound, etc.). <br><br>  There are blocks, or tiles, of objects, each of which has an object for nesting the model, as well as pivots of the zero coordinate of the model and its opposite end, which will automatically calculate the location for the spawn of the next block. <br><br>  The game features several types of blocks: <br><br>  <i>The tunnel</i> ‚Äî linear or twisted ‚Äî doesn't matter. <br>  <i>The station</i> is a block with its own list of events and cut scenes for the game.  Contains passenger prefabs. <br>  <i>Custom event block</i> - may contain a tunnel with a fork, where, say, the train needs an emergency stop, slow down, etc. <br><br>  The essence of the engine: <br><br><img src="https://habrastorage.org/files/536/c9d/2ee/536c9d2ee26442439e842442e92aba44.png"><br><br>  As can be seen from the diagram, the main character is the train.  Accordingly, in relation to him we are building a path.  First of all, the Route Controller is connected with the train, which builds a dynamic route line along which the train moves.  The line itself is built on pre-prepared Transform'am in each block, with each Transform located exactly in the middle of the rail track. <br><br>  The dynamic component of the gameplay is the most resource-intensive;  to properly optimize it, we had to apply a variety of solutions.  Consider them below. <br><br><h3>  The implementation of the movement of the train </h3><br>  When creating a train engine, the main question is how much detail the process of movement should be recreated.  Here you need to be well aware of the train as a physical body, to understand that this is a multi-ton object that requires gradual acceleration and stopping, that its position and tilt are determined depending on the degree of rotation of the track. <br><br>  To imitate the movement of a train in full compliance with the laws of physics would be problematic.  At a minimum, we would have to take into account the friction of WheelColliders, which in Unity do not always behave adequately, especially if we are talking about more complex and larger wheeled vehicles than just a car.  And this is just one of many factors.  The most serious obstacle is that such detailed miscalculations of physics would give too much load on the engine.  This would have a bad effect on performance, and it would add more bugs. <br><br>  In our opinion, the optimal way out is to make movement in physics only as an offset in position along a given route. <br><br>  Rotation of the train in the simulator is calculated based on the difference between the two angles - the current and the previous one.  The greater the difference - the stronger the train will lean to the side, which will give the corresponding roll. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ target.position = Vector3.Lerp(target.position, currentPoint.position, lerpSpeed * Time.deltaTime); <span class="hljs-comment"><span class="hljs-comment">//     -   if (Vector3.Distance (PivotTrain.position, target.position) &lt; damper) { //    ,       float DeltaR = Roll - (currentPoint.rotation.z - previousPoint.rotation.z); //      if (!(DeltaR &gt; 0.05f || DeltaR &lt; -0.05f)) Roll = Mathf.Lerp(Roll, currentPoint.localRotation.z - previousPoint.localRotation.z, 10 * Time.deltaTime); //   NextCall (); } private void NextCall() { //   ,      ,         if(!CurrentPoints[0].GetComponent&lt;itemWay&gt;().Last) previousPoint = currentPoint; CurrentPoints [0].GetComponent&lt;itemWay&gt; ().EndBlock (); CurrentPoints.Remove (CurrentPoints [0]); currentPoint = CurrentPoints [0]; }</span></span></code> </pre> <br>  The train is shaken by animating the cameras (the driver shakes his head at a pace that is determined by the speed of movement) and shakes the animation of the model itself depending on the speed or degree of braking.  Cycling animation of a camera or object is quite easy to do with ordinary TweenPosition or TweenTransform, which are standard components in the NGUI engine. <br><br>  The main thing is that the animation dependence on the speed of the composition is respected.  An example of dependence, taking into account the coefficients of the train speed, is given below: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ speed = TrainEngine.Instance.speed; maxSpeed = TrainEngine.Instance.maxSpeed; tweenRot.dutation = (speed / maxSpeed) * <span class="hljs-number"><span class="hljs-number">10</span></span>; tweenRot.from.y = speed / (maxSpeed)/<span class="hljs-number"><span class="hljs-number">30</span></span>; tweenRot.to.y = -tweenRot.from.y; }</code> </pre><br><img src="https://habrastorage.org/files/261/018/39f/26101839f46b4261a369916f25c1a9aa.png"><br><br>  With physics figured out, move on to the next problem.  When creating a block-based engine, you should keep in mind the need to read the distance from the object of the operating unit to the train.  Ideally, you need to keep the number of operations to calculate the distance to a minimum. <br><br>  The logic of the work of our engine implies that at each particular moment the distance is calculated only between the train and the blocks nearest to it.  The remaining tunnels and stations are in the pool (Object Pooling) and do not interact with the main controller in any way.  As soon as the train has passed the active unit, the last from the active sheet is redirected to the passive one. <br><br>  lenghtBegin - block length, after which we can remove it and build a path further <br>  ItemType - block type <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceCheck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Vector3.Distance(transform.position, player.transform.position) &gt; lenghtBegin)) { <span class="hljs-comment"><span class="hljs-comment">//  ActiveBlock=false; Model.SetActive(false); //   ,      WayController.Instance.ReturnBlock(ItemType); //   WayController.Instance.GenerateWay(); } } WayController.cs //    public void GenerateWay() { //             if (CurrentLenght &lt; LenghtTunnel) { RespawnTunnel (); } else { //   RespawnStation(); } } //  ,      .       public void RespawnTunnel() { countLinear++; if (countLinear &gt; LenghtLinear) { countLinear = 0; if (turnTunnel!=null) LoadTurn (Random.Range (0, turnTunnel.Count)); else LoadLinear (Random.Range(0,frontTunnel.Count));  } else { LoadLinear (Random.Range(0,frontTunnel.Count)); } } //     public void LoadLinear(int num) { if (RespList) RespBlock.Add(frontTunnel [num]); //     CurrentBlock.Add (frontTunnel [num]); //         CurrentBlock [CurrentBlock.Count-1].ChangePosition (); CurrentBlock [CurrentBlock.Count - 1].transform.SetParent (RootTransform); frontTunnel.Remove (frontTunnel [num]); } //    -  ,  -         public void ChangePosition() { Model.SetActive (true); this.transform.position = new Vector3 (WayController.Instance.EndBuild.position.x, WayController.Instance.EndBuild.position.y, WayController.Instance.EndBuild.position.z); this.transform.rotation = Quaternion.Euler (WayController.Instance.EndBuild.eulerAngles.x,WayController.Instance.EndBuild.eulerAngles.y, WayController.Instance.EndBuild.transform.eulerAngles.z); rotationTile = EndPos.rotation.eulerAngles.y; WayController.Instance.BuildWay (EndPos.position,rotationTile); SetWayPoint (); } //             public void SetWayPoint() { for (int i = 0; i &lt; WayPoints.Count; i++) RouteController.Instance.CurrentPoints.Add (WayPoints [i]); } t = target.position - transform.position; toRot = Quaternion.LookRotation(t); transform.rotation = rot;  pos = transform.position + transform.forward * speed * Time.deltaTime; //    RigidBody     rbTrain.MovePosition (pos);</span></span></code> </pre> <br>  Next, the Route Controller script should work directly with the Way Controller.  It is the Way Controller that determines the list of objects that the Route Controller will process and deliver to the train as a target of movement. <br><br>  The main convenience of the version of the engine that we use is that it is enough to drive in the necessary values ‚Äã‚Äãin order to change the character of movement on the line at once.  For example, to make the spans between stations longer or shorter, if the statistics show that the current duration of the trip does not suit the users.  If there are new station models, you can simply add them to the list of engine models, and then set the beginning and end of the Pivot in each. <br><br>  If the application used static locations - flashing and updating would be a very time consuming and lengthy process.  In this version, with a minimum number of actions, we can download a version with a new station or additional models, without using a server.  Although, of course, with large volumes of updates, the server remains the only correct solution. <br><br><h3>  Debugging Metrics </h3><br>  Another traffic issue was the relationship between distance and metric in Unity.  If the path of our train will always be generated in blocks continuously forward, sooner or later the object will be in such coordinates that an adequate frame miscalculation will be impossible. <br><br>  The cabin of the train, consisting of several meshes, began to shake in the literal sense of the word when the coordinates reached too high values. <br><br>  This is due to the fact that in Unity there is no concept of infinite space, only conditional boundaries, to which you can easily calculate the coordinate values.  The farther we go from these boundaries, the more error will be rendering the scene. <br><br>  Based on this, we decided to supplement the game engine with respawn - in other words, make it so that when arriving at the station, the train returns with it and the nearest rebuilt tunnel blocks to the zero point of coordinates.  This decision reduces the likelihood of errors in the miscalculation of the movement, if the player rolls, say, half an hour or more. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RespawnStation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StationResp [<span class="hljs-number"><span class="hljs-number">0</span></span>].SetTriggers (<span class="hljs-literal"><span class="hljs-literal">false</span></span>); StationResp [<span class="hljs-number"><span class="hljs-number">0</span></span>].transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3 (<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); StationResp [<span class="hljs-number"><span class="hljs-number">0</span></span>].transform.localRotation = Quaternion.identity; EndBuild.transform.position = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(StationResp [<span class="hljs-number"><span class="hljs-number">0</span></span>].EndPos.position.x,StationResp [<span class="hljs-number"><span class="hljs-number">0</span></span>].EndPos.position.y,StationResp [<span class="hljs-number"><span class="hljs-number">0</span></span>].EndPos.position.z); EndBuild.transform.rotation = Quaternion.Euler (StationResp [<span class="hljs-number"><span class="hljs-number">0</span></span>].EndPos.eulerAngles.x,StationResp [<span class="hljs-number"><span class="hljs-number">0</span></span>].EndPos.eulerAngles.y, StationResp [<span class="hljs-number"><span class="hljs-number">0</span></span>].EndPos.eulerAngles.z); Train.transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3 (RespPoint.localPosition.x, RespPoint.localPosition.y, RespPoint.localPosition.z); Train.transform.localRotation = RespPoint.localRotation; WayController.Instance.RebuildBlocks (); }</code> </pre> <br>  The work done with the engine significantly unloaded the memory, but we did not stop there.  The next step was to optimize the visual and sound of the application. <br><br><h3>  Texture compression </h3><br>  The first versions of Subway Simulator included a static location with pre-configured light sources (including in Realtime).  It quickly became clear that such a concept only works as long as the game does not use multi-poly models and a large number of textures, both for the interface and for locations, trains and people.  Otherwise, it is necessary to choose another option that would provide good quality with moderate memory costs. <br><br>  First of all, shaders with pre-baked light maps (LightMaps) were written - we wanted to abandon the illumination of lighting in principle, replacing it with special shaders on materials and searchlights on the train. <br><br>  When texturing was used the method described <a href="https://habrahabr.ru/post/259835/">here</a> .  In our implementation, everything turned out quite simple, but the effect on performance was the most beneficial. <br><br>  We compressed each of the location textures to 256x256 using RGB Compressed PRVTC 4 bit compression.  But LightMaps (lighting maps) were arranged in pairs in one image on separate RGB channels. <br><br>  Also, a channel mixing shader was added, through which on the necessary material the object will display the map we need of three variations.  For clarity, here is a screenshot of a part of the shader code that mixes RGB for textures: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutputStandard o)</span></span></span><span class="hljs-function"> </span></span>{ fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; fixed4 light = tex2D (_Light, IN.uv2_Light); fixed4 g = tex2D (_MainTex2, IN.uv_MainTex); fixed a = (c.r+c.g+cb)/<span class="hljs-number"><span class="hljs-number">3</span></span>; fixed3 r; rr = ((g.r+(cr-a))*_R)+((g.g+(cr-a))*_G)+((g.b+(cr-a))*_B)+((g.a+(cr-a))*_A); rg = ((g.r+(cg-a))*_R)+((g.g+(cg-a))*_G)+((g.b+(cg-a))*_B)+((g.a+(cg-a))*_A); rb = ((g.r+(cb-a))*_R)+((g.g+(cb-a))*_G)+((g.b+(cb-a))*_B)+((g.a+(cb-a))*_A); o.Albedo = r.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Emission = ((light.r*_N1)+(light.g*_N2)+(light.b*_N3)+(light.a*_N4))*r.rgb; o.Alpha = ca; }</code> </pre> <br>  As a result, the color of the picture itself is compressed, but the alpha channel map, lighting and contrast remain of an acceptable size, so there is almost no deterioration from the screens of mobile devices. <br><br><img src="https://habrastorage.org/files/19e/6d8/bdb/19e6d8bdbe5047bbb9fa41f0c64547ef.png" width="360"><img src="https://habrastorage.org/files/84a/2f0/572/84a2f0572b564e6c88b0e46d839a3c3e.png" width="360"><br><br>  Above is an example of the distribution of textures.  The left image stores only the color in itself, we compress it as much as possible (for textures of medium-sized locations, the limit is usually just 256 pixels).  The right image keeps the contrast and LightMaps in three RGB channels. <br><br>  We used the same method of packing textures with trains, because in the application each composition has 4 separate colors in the resolution of 512 by 512. Thus, we managed to reduce memory consumption by both locations and trains - in total, almost doubled. <br><br>  It is also very useful to perform compression of 2-bit compression for any small location objects.  With large objects this solution does not work - visible artifacts may appear. <br><br>  The screenshot below is an example of an unsuccessful attempt at such compression: the artifacts are clearly visible in the upper part of the location. <br><br><img src="https://habrastorage.org/files/a05/77d/f4f/a0577df4fb51432abdc0f4ab11522381.png"><br><br><h3>  Compression of sound and models </h3><br>  Within the framework of additional optimization, we squeezed all sounds to the maximum value - 1. The testing experience showed that there is practically no loss in sound quality from mobile devices.  Exposing the Mono-mode of all sound files also reduced the memory consumption by almost one and a half times. <br><br>  For reference: it is better to use Decompress On Load for long sounds and Compressed In Memory for short ones. <br><br><img src="https://habrastorage.org/files/7d9/dde/2b7/7d9dde2b7339455f885be0112671cca5.png"><br><br><h3>  Prototype modeling </h3><br>  The task of a good simulator is not only to interest the user in the detailed mechanics of the gameplay, but also to provide a decent picture.  Based on what was decided to simulate several trains and stations with their real copies.  Thanks to the sketches and schemes that are in open access, at the moment, it was possible to very realistically implement 3 models of trains, and several stations of the Moscow and Beijing metro. <br><br>  The average indicators of the polygoning stations are 25-30 thousand polygons and 12-20 thousand polygons near the trains.  As we said above, we additionally applied texture compression and a hard limit on the amount of material per object.  Since the number of textures and models is quite large, we abandoned the illumination errors, having stopped only on previously prepared shadow maps in the textures. <br><br>  The result of the simulation can be seen below: <br><br><img src="https://habrastorage.org/files/c12/551/6fa/c125516fa6814e1ebb9b66e40e24c854.png"><br><br><img src="https://habrastorage.org/files/4be/376/9da/4be3769da019494cb82048571686c2ae.png"><br><br><img src="https://habrastorage.org/files/c10/257/548/c102575485c64bafa0a0e19f0a1424f8.jpg"><br>  <i>Metro station "Novoslobodskaya" photo</i> <br><br><img src="https://habrastorage.org/files/102/ffa/fb9/102ffafb926444df97f5b40d4dec846d.png"><br>  <i>Metro station "Novoslobodskaya", screenshot</i> <br><br><h3>  Conclusion </h3><br>  When changing the game engine from static to dynamic maps with loading of individual blocks of location, it was possible to significantly reduce the memory consumption of the application during operation.  The application can now run on weaker devices and at the same time produce an acceptable number of frames per second. <br><br>  Packing textures and atlases into separate spectra of the RGB channel helped to reduce the weight of the application.  This is especially important for those cases where there are so many textures in the applications that even the presence of atlases does not save.  When developing games of the ‚Äúsimulator‚Äù genre, this problem is particularly acute, since the authenticity of the environment requires the maximum number of photographically accurate elements.  In our case, thanks to this stage of compression and packing, we managed to keep in a decent quality all the most necessary details in the game. <br><br>  As for the implementation of mechanics, here, due to the dynamic loading of the location, it became possible to control the process of passing gameplay by the player and the length of the sessions.  Based on the data on how many users, on average, play at one level or another, you can identify weak and strong places and expand or trim the gameplay accordingly.  Also, thanks to the dynamic engine, it became possible in the future to add new stations to the engine directly from the server, without a full reassembly of the application. <br><br>  We hope the proposed solutions will be of interest to readers.  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/319990/">https://habr.com/ru/post/319990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319980/index.html">How SEO-agency spent 600 thousand rubles. on advertising and what came of it</a></li>
<li><a href="../319982/index.html">Creating a native watchface for Gear S3 / S2</a></li>
<li><a href="../319984/index.html">Is your service RESTful? All you need / need to know about web services and REST</a></li>
<li><a href="../319986/index.html">Windows 10 Creators Update: Increased Security and Advanced IT Tools</a></li>
<li><a href="../319988/index.html">Lessons of the year to combat information security breaches</a></li>
<li><a href="../319994/index.html">From the life of parallelist</a></li>
<li><a href="../319996/index.html">OdataToEntity is an easy way to create .Net Core OData services</a></li>
<li><a href="../319998/index.html">Containers and virtualization: faster, more efficient, more reliable</a></li>
<li><a href="../320000/index.html">A fresh selection of resources for a mobile application marketer: books and blogs</a></li>
<li><a href="../320002/index.html">Linux-2017: the most promising distributions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>