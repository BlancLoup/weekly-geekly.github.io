<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ idioms. Type erasure</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Want to get an idea of ‚Äã‚Äãhow boost :: function , boost :: any is arranged ‚Äúunder the hood‚Äù? Learn or refresh what is hidden behind the incomprehensibl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ idioms. Type erasure</h1><div class="post__text post__text-html js-mediator-article">  Want to get an idea of ‚Äã‚Äãhow <i>boost :: function</i> , <i>boost :: any</i> is arranged ‚Äúunder the hood‚Äù?  Learn or refresh what is hidden behind the incomprehensible phrase ‚Äútype erasure‚Äù?  In this article I will try to summarize the motivation behind this idiom and the key elements of implementation. <br><a name="habracut"></a><br><h4>  Motivation </h4><br>  How to put objects of unrelated types in one container?  For example, the options read from the command line are immediately ‚Äúdecomposed‚Äù into different types and put into a single container.  Or to store ‚Äúsomething‚Äù of an arbitrary type inside a single object with the only restriction - the presence of the ‚Äú()‚Äù operator in the stored ‚Äúsomething‚Äù?  How, in general, ‚Äúto erase‚Äù the type of any object, hiding it behind an object of another, some general type? <br><br><h4>  void * </h4><br>  In fact, C ++ has a built-in mechanism for hiding the type of any object behind a common type.  This is inherited from C, pointer <i>void *</i> . <br><br>  It can be used, for example, as follows: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; }; A a; B b; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt; v; v.push_back(&amp;a); v.push_back(&amp;b); <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;A*&gt;(v[<span class="hljs-number"><span class="hljs-number">0</span></span>])-&gt;foo(); <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;B*&gt;(v[<span class="hljs-number"><span class="hljs-number">1</span></span>])-&gt;bar(<span class="hljs-number"><span class="hljs-number">3.5</span></span>);</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Or so: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void_any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: void_any(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* h, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) : size_(size) { h_ = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(size); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(h_, h, size); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*&amp; h)</span></span></span><span class="hljs-function"> </span></span>{ h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(size_); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(h, h_, size_); } ~void_any(){ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(h_); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size_; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* h_; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> some_int=<span class="hljs-number"><span class="hljs-number">675321</span></span>; <span class="hljs-function"><span class="hljs-function">void_any </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">va</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;some_int, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pi; va.get(pi); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)pi &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><br>  This scheme will work, but I think its drawbacks are obvious.  You can make a mistake when casting, pass an incorrect size to the constructor, you cannot use it with <i>rvalue</i> expressions.  We make the user remember what type of object is stored in the pointer and ‚Äúmanually‚Äù lead to this type.  Well, the main drawback, perhaps, is that we do not use the type system of the language in which we are writing.  It's like nailing with a screwdriver.  It is possible, but uncomfortable.  So how to be? <br><br><h4>  Patterns and Inheritance </h4><br>  You've probably already guessed that without templates there is no cost.  Yes, indeed, it is possible to transfer an object of any type to the template class constructor (template function) and thus hide its type, but this will not solve the second problem, namely, hide an object of any type behind an object of the <b>same</b> type. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_t</span></span></span><span class="hljs-class">{</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">some_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; s1; <span class="hljs-keyword"><span class="hljs-keyword">some_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; s2;</code> </pre><br>  In the fragment above, <i>s1</i> and <i>s2</i> after instantiation are objects of completely different, unrelated types. <br>  Fortunately, C ++ is not limited to templates alone.  And inheritance and dynamic polymorphism will come to our aid.  Read the next section to understand how. <br><br><h4>  Implementation </h4><br>  So, from words to business.  It is already clear to us that our ‚Äúwrapper‚Äù should not be a template, but at the same time it should be capable of accepting an object of any type in the constructor.  How is this possible?  Correctly, with the help of the template designer. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; any(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; t); <span class="hljs-comment"><span class="hljs-comment">//‚Ä¶ };</span></span></code> </pre><br>  But now how to keep what they gave us in the constructor?  Our class does not know anything about type T, which parameterizes the constructor, so we cannot write like this: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//... private: T t_; };</span></span></code> </pre><br>  To solve this problem, we will store a pointer to an abstract auxiliary structure, and transferred to us in the constructor <i>t</i> , we give to the template structure that inherits from the abstract auxiliary base. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: any(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; t) : held_(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> holder&lt;T&gt;(t)){} <span class="hljs-comment"><span class="hljs-comment">//‚Ä¶ private: struct base_holder { virtual ~base_holder(){} }; template&lt;typename T&gt; struct holder : base_holder { holder(const T&amp; t) : t_(t){} T t_; }; private: base_holder* held_; };</span></span></code> </pre><br>  Fine!  Now we can save an object of any type in the <i>‚Äúany‚Äù</i> class.  The matter is small, now the saved object must, if necessary, be somehow ‚Äúpulled out‚Äù from the depths of our wrapper.  To do this, unfortunately, we will have to use <i>RTTI</i> .  Add a function that returns information about the type of stored value in our auxiliary structures. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">base_holder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//... virtual const std::type_info&amp; type_info() const = 0; }; template&lt;typename T&gt; struct holder : base_holder { //... const std::type_info&amp; type_info() const { return typeid(t_); } };</span></span></code> </pre><br>  Now write the function of returning the original object will not be difficult. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-function"><span class="hljs-function">U </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(U) != held_-&gt;type_info()) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"Bad any cast"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;holder&lt;U&gt;* &gt;(held_)-&gt;t_; }</code> </pre><br><br>  Why <i>RTTI</i> need to be used unfortunately?  Because I would like to write something like this to transfer the type check to compile time: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">U </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::enable_if&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same&lt;U, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">static_cast</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;holder&lt;U&gt;* &gt;(held_)-&gt;t_)&gt;::value&gt;::type* = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;holder&lt;U&gt;* &gt;(held_)-&gt;t_; }</code> </pre><br><br>  Why is this solution not suitable?  The fact is that <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;U, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;holder&lt;U&gt;* &gt;(held_)-&gt;t_)&gt;::value</code> </pre><br>  will always be <i>true</i> , regardless of what type of object is actually stored in <i>holder</i> .  Such code will be compiled and even run without crashes (if lucky) <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">any </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; a.cast&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;();</code> </pre><br>  But the results will not be what the programmer expects. <br><br>  The <i>boost :: function</i> class uses the same type erase principle.  Cosmetic differences lie in the fact that <i>function</i> is a template parameterized by the types of the return value and arguments, and a function appears in auxiliary structures <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> return_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg_type1, .., arg_typeN)</span></span></span></span>;</code> </pre><br><br><h4>  Listing </h4><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; any(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; t) : held_(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> holder&lt;T&gt;(t)){} ~any(){ <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> held_; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-function"><span class="hljs-function">U </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(U) != held_-&gt;type_info()) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"Bad any cast"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;holder&lt;U&gt;* &gt;(held_)-&gt;t_; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">base_holder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~base_holder(){} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">type_info&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">holder</span></span></span><span class="hljs-class"> :</span></span> base_holder { holder(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; t) : t_(t){} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">type_info&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(t_); } T t_; }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: base_holder* held_; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">any </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; a.cast&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-function"><span class="hljs-function">any </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"abcd"</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; b.cast&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; e) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/207294/">https://habr.com/ru/post/207294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207282/index.html">Automator script loading images on Habrastorage</a></li>
<li><a href="../207284/index.html">How is the cost of advertising on TV: the example of the United States</a></li>
<li><a href="../207286/index.html">Hidden features of Xcode 5</a></li>
<li><a href="../207288/index.html">Syncman - deploy and synchronize projects on a remote server</a></li>
<li><a href="../207290/index.html">Kingston HyperX 3K SH103S3B / 240 SSD Overview</a></li>
<li><a href="../207296/index.html">Our sales leader 2013 - controller KUB-Micro / 60</a></li>
<li><a href="../207298/index.html">STARTTOSPEAK.COM - we start talking about the project!</a></li>
<li><a href="../207304/index.html">Registration on the site: from the beginning to the afternoon</a></li>
<li><a href="../207306/index.html">Overview of data encryption in the clouds for Windows</a></li>
<li><a href="../207308/index.html">Instruction as a sequence of methods</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>