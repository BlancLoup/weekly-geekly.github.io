<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Default structures and constructors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The default constructor is a fairly simple construction, which comes down to the creation of a constructor with no parameters. So, for example, if you...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Default structures and constructors</h1><div class="post__text post__text-html js-mediator-article">  The default constructor is a fairly simple construction, which comes down to the creation of a constructor with no parameters.  So, for example, if you declare a non-static class and do not declare a custom constructor (no matter with or without parameters), the compiler will independently generate a constructor without parameters.  However, when it comes to default constructors for structures (for significant types), then everything becomes not so simple. <br><br>  Here is a simple example of how you answer the following question: <i>how many of the relevant types are from.</i>  <i>NET</i> <i>Framework</i> <i>contains default constructors?</i>  The intuitive answer seems to be ‚Äú <i>everything</i> ‚Äù, and you will be wrong, because in fact, <i>none of the significant types.</i>  <i>NET</i> <i>Framework</i> <i>does not contain a default constructor</i> . <br><br><a name="habracut"></a><br>  But let's take everything in order and start by comparing such concepts as the default constructor and the default values. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When it comes to classes, everything is simple: if the constructor is not explicitly declared, the C # compiler will generate a parameterless constructor, which is called the default constructor;  the default value of any variable (or field) of the reference type is <b>null</b> . <br><br>  But when it comes to structures, then everything becomes a bit more complicated.  The default value of an instance of a significant type is the ‚Äúzero‚Äù representation of all its fields, i.e.  all numeric fields are 0, and all reference fields are <b>null</b> .  From the point of view of the C # language, the default constructor of a meaningful type does the same thing - it returns an instance of the structure with a default value.  This means that the following code is equivalent: <br><br><pre><code class="cs hljs">Size size1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Size(); Size size2 = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(Size);</code> </pre> <br><br>  In this case, for both lines of code, the compiler will generate the same <b>iniobj</b> instruction, which will lead to an identical result in both cases - resetting all the fields in the <b>Size</b> structure. <br><br>  The C # language specification says that the user is not allowed to create a default constructor explicitly, since any structure contains it implicitly.  However, this is not quite true: if we get a list of <b>Size</b> constructors, we will not see a constructor without parameters.  What is called the default constructor in C # is actually a ‚Äúzeroing‚Äù of the object and is not a constructor in the usual sense of the word and does not contain any specialized code in the <b>Size</b> type. <br><br>  Similar mixing of concepts exists not only when calling the operator <b>new</b> , but also when initializing structure fields in the constructor.  So, for constructors of structures, the same rules of obligatory initialization of all fields of the structure are applied, similar to the rules for local variables (definite assignment rules).  This means that before the completion of the body of the constructor, all fields of the structure must be explicitly or implicitly initialized: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> SomeStruct { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _i; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> _d; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeStruct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//  ‚Äú  ‚Äù { _i = i; //  _d  ! } }</span></span></span></span></code> </pre><br><br>  Calling <b>this</b> <b>()</b> looks exactly like calling the default constructor and prevents a compilation error due to the fact that it resets (and therefore initializes) all fields of the structure.  In fact, the call to <b>this</b> <b>()</b> turns into the same <b>initobj</b> instruction used earlier to get the default value of the structure instance. <br><br>  Such a mix of default constructor concepts to obtain a default value for significant types is common on the .NET platform, but is not required.  Some languages, such as ‚Äúbare‚Äù IL or Managed C ++, support full-fledged custom constructors for meaningful types that allow you to initialize the state of a structure in an arbitrary way, and not just with default values. <br>  Although the C # language does not allow you to create default constructors for structures, it allows you to use them.  When the C # compiler encounters the instruction ‚Äú <b>new</b> <b>SomeType</b> ‚Äù, the generated code depends on whether the specified type is a class or structure, and also on whether the structure contains a full default constructor or not: <br><br><pre> <code class="cs hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-comment"><span class="hljs-comment">// 1 Size size = new Size(); // 2 CustomValueType cvt = new CustomValueType(); // 3</span></span></code> </pre><br><br>  In the first case, the default constructor of the <b>StringBuiilder</b> class will be called using the <b>newobj</b> instruction, but the result of creating an instance of a meaningful type depends on its implementation. <br><br>  Both the <b>Size</b> and <b>CustomValueType</b> types are significant types, and the <b>CustomValueType</b> type contains a default constructor (we will see later how to achieve this).  In line 2, the <b>size</b> variable is initialized with default values ‚Äã‚Äãusing the <b>initobj</b> instruction, and in line 3 the constructor of the <b>CustomValueType</b> type is <b>invoked</b> using the <b>call</b> <b>Custom</b> <b>CustomValueType</b> <b>..ctor instruction</b> . <br><br><h4>  Creating a structure with a default constructor </h4><br>  To generate the structure, we will use the <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.aspx">System.Reflection.Emit</a> module, which supports all the necessary functionality.  The process of creating a new type begins creating the <b>AssemblyBuilder</b> object, inside which a <b>DynamicModuleBuilder</b> instance is <b>created</b> , in which a type is already being created.  This order is explained by the fact that the assembly, in fact, contains only the metadata of the assembly (dependencies, etc.) and modules, which, in turn, already contain custom types. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateValueTypeWithDefaultConstructor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outputString = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Hello, value type's default ctor!"</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    var assemblyName = new AssemblyName("StructEmitter"); var appDomain = AppDomain.CurrentDomain; var assemblyBuilder = appDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.RunAndSave); var moduleBuilder = assemblyBuilder.DefineDynamicModule( assemblyName.Name, Path.ChangeExtension(assemblyName.Name, "dll")); var typeBuilder = moduleBuilder.DefineType(name, TypeAttributes.Public, typeof(ValueType)); //     var constructorBuilder = typeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new Type[] { }); var ilGenerator = constructorBuilder.GetILGenerator(); //   Console.WriteLine    ilGenerator.EmitWriteLine(outputString); ilGenerator.Emit(OpCodes.Ret); //assemblyBuilder.Save(); // ""      return typeBuilder.CreateType(); }</span></span></code> </pre><br><br>  The <b>GenerateValueTypeWithDefaultConstructor</b> method takes the type name and the string displayed on the console (the line is needed to write a unit test that checks the operation of this method).  After that, we generate a simple meaningful type with a constructor invoking the <b>Console</b> <b>.WriteLine</b> with the specified string. <br>  After that, we can create this type using <a href="http://msdn.microsoft.com/en-us/library/system.activator.createinstance.aspx">Activator.CreateInstance</a> or save the generated assembly with <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.assemblybuilder.save.aspx">AssemblyBuilder.Save</a> and use it in the usual way.  After that, it will be possible to use the generated type in the usual way and calmly call the default constructor of a significant type: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//        Activtor.CreateInstance var type = CustomStructEmitter .GenerateValueTypeWithDefaultConstructor("CustomValueType"); var cvt1 = Activator.CreateInstance(type); //      var cvt2 = new CustomValueType();</span></span></code> </pre><br><br><h4>  Default constructor invocation rules </h4><br>  There are several points of use of the C # structures with the current default constructor. <br><br>  One of the main reasons for the lack of user default constructors for structures is a drop in performance when working with arrays. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomValueType[<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre><br><br>  To create an array, the <b>newarr</b> instruction is <b>used</b> ; in this case, all elements of the array are initialized with default values, which in the case of significant types means ‚Äúzeroing‚Äù of all fields of all array instances.  Even if the type used contains a real default constructor (as in our case), in the interests of performance they will not be called anyway. <br><br>  To call the constructor of all elements, you need to do this explicitly: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//        array.Initialize();</span></span></code> </pre><br><br>  But even if the developers of the CLR and the languages ‚Äã‚Äãof the .NET platform would go to a drop in performance by invoking dozens of custom designers, this would not have saved all problems. <br>  Let's look at the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;CustomValueType&gt;(<span class="hljs-number"><span class="hljs-number">50</span></span>);</code> </pre><br><br>  This constructor takes a capacity (capacity) of the list, which means that an array of the appropriate size will be created inside it, which, in turn, will cause at least 50 default constructors to be called, although the current size of the list will still be 0. To solve this problem, would separate the process of allocating memory for an array from the process of creating an instance of a significant type inside it.  Such a technique is used in the C ++ language with the help of the <a href="http://ru.wikipedia.org/wiki/New_(C%252B%252B)">host operator <b>new</b></a> , but this would clearly add more problems than good, so it‚Äôs reasonable enough that the .NET developers didn‚Äôt go for it. <br><br>  <b>NOTE</b> <br>  On the .NET platform, the problem with lists, arrays, and enums still exists.  Details can be found in the article <a href="http://sergeyteplyakov.blogspot.com/2011/10/blog-post_26.html">"Problems of transferring a list of listings or Why abstractions flow</a> . <a href="http://sergeyteplyakov.blogspot.com/2011/10/blog-post_26.html">"</a> <br><br>  Working with arrays is not the only place where an existing constructor of a significant type will not be called.  The following table makes it clear when such a constructor will be called, and when not. <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  var cvt = new CustomValueType(); //  var cvt = Activator.CreateInstance(typeof(CustomValueType)); //   var cvt = default(CustomValueType); static T CreateAsDefault&lt;T&gt;() { return default(T); } //   CustomValueType cvt = CreateAsDefault&lt;CustomValueType&gt;(); static T CreateWithNew&lt;T&gt;() where T : new() { return new T(); } //  !! CustomValueType cvt = CreateWithNew&lt;CustomValueType&gt;(); //   var array = new CustomValueType[5];</span></span></code> </pre><br><br>  I want to draw attention to the mismatch of behavior in the following case: it is known that instantiating a generic parameter occurs using <a href="http://msdn.microsoft.com/en-us/library/wccyzw83.aspx">Activator</a> .  However, when creating an instance of the <b>CustomValueType</b> type using <b>Activator</b> <b>.CreateInstance,</b> our default constructor will be invoked, but when calling the <b>CreateWithNew</b> method and creating an instance of a significant type using <b>new</b> <b>T</b> <b>()</b> , it will not. <br><br><h4>  Conclusion </h4><br>  So, we found out the following: <br><ol><li>  The default constructor in C # is the instruction for zeroing the value of an object. </li><li>  From the point of view of the CLR, default constructors exist and the C # language even knows how to call them. </li><li>  The C # language does not allow creating custom constructors by default for structures, since this would lead to a drop in performance when working with arrays and significant confusion. </li><li>  Working in languages ‚Äã‚Äãthat support the creation of constructors by default, they still do not need to be declared for the same reasons that they are prohibited in most languages ‚Äã‚Äãof the .NET platform. </li><li>  Significant types are not as simple as they seem: in addition to <a href="http://sergeyteplyakov.blogspot.com/2011/07/blog-post.html">problems with variability</a> (mutability), significant types even with default constructors and that is not all simple. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/152118/">https://habr.com/ru/post/152118/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../152113/index.html">Rapoo E6300 - sophisticated BT-keyboard</a></li>
<li><a href="../152114/index.html">"Trendy" ads in contextual advertising</a></li>
<li><a href="../152115/index.html">Great plugin to check the layout</a></li>
<li><a href="../152116/index.html">Easy way to record technical subjects with LibreOffice Math</a></li>
<li><a href="../152117/index.html">Selectel lies again</a></li>
<li><a href="../152119/index.html">LispyScript - Lisp JavaScript</a></li>
<li><a href="../152122/index.html">Test automation for Android applications</a></li>
<li><a href="../152123/index.html">User queries to the database in MODx Revolution</a></li>
<li><a href="../152125/index.html">Sectioning: Shot and forget</a></li>
<li><a href="../152126/index.html">Kotlin M3 released</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>