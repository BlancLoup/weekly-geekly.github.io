<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Problems using Math.random ()</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In English there is an abbreviation - TIFU. We cannot bring its exact value here, but you can easily find it on the web. And after the "literary proce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Problems using Math.random ()</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/dde/292/490/dde292490b55a8c0824ecc6cc038f999.png" alt="image"><br><br>  In English there is an abbreviation - TIFU.  We cannot bring its exact value here, but you can easily find it on the web.  And after the "literary processing" TIFU can be translated as "today I ruined everything."  In the context of this post, this phrase refers to the use of the Math.random () function in the V8 JavaScript engine.  Although it did not happen today, but a couple of years ago.  Yes, and I broke the wood is not my fault, the root of evil lies in the very function. <br><br><blockquote>  ‚ÄúMany of the random number generators used today do not work very well.  Developers usually try not to understand how such subroutines are arranged.  And it often happens that some old, unsatisfactory working method is blindly adopted over and over again by many programmers, who often simply do not know about its inherent flaws. ‚Äù 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Donald Knuth, The <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D1%2581%25D0%25BA%25D1%2583%25D1%2581%25D1%2581%25D1%2582%25D0%25B2%25D0%25BE_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">Art of Programming</a> , volume 2. </blockquote><br>  I hope that by the end of this post you will agree with two statements: <br><br><ul><li>  We were idiots because we used a pseudo-random number generator in V8 without understanding its limitations.  And if it is very lazy, then it is safer to use <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8_%25D1%2581%25D1%2582%25D0%25BE%25D0%25B9%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B3%25D0%25B5%25D0%25BD%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_%25D0%25BF%25D1%2581%25D0%25B5%25D0%25B2%25D0%25B4%25D0%25BE%25D1%2581%25D0%25BB%25D1%2583%25D1%2587%25D0%25B0%25D0%25B9%25D0%25BD%25D1%258B%25D1%2585_%25D1%2587%25D0%25B8%25D1%2581%25D0%25B5%25D0%25BB">cryptographically resistant pseudo-random number generators</a> . </li><li>  In V8, a new implementation of Math.random () is needed.  The work of the current algorithm, wandering from one programmer to another, cannot be considered satisfactory due to the weak, unobvious degradation often encountered in real projects. </li></ul><br>  I want to emphasize that the V8 engine itself is a wonderful product and its creators are very talented.  I in no way blame them.  Just this situation illustrates how much small nuances influence the development process. <br><a name="habracut"></a><br>  The work of the <a href="https://eng.betable.com/">Betable</a> project depends on random numbers.  Among other things, they are used to generate identifiers.  Since the architecture is a system of distributed microservices, it was easier to implement random identifiers than sequential ones.  For example, each API request generates random <i>request identifiers</i> .  They are placed in subqueries in headers, logged and used to compare and correlate all the events taking place in all services, as a result of a single query.  There is nothing difficult in generating random identifiers.  Requirement one: <br><br>  <i>The probability of double generating the same identifier ‚Äî the occurrence of a collision ‚Äî must be <b>extremely small</b> .</i>  The probability of a collision is influenced by two factors: <br><br><ol><li>  The size of the identification space is the number of possible unique identifiers. </li><li>  Method of generating identifiers - how the identifier is chosen from the common space. </li></ol><br>  Ideally, we need a large space from which uniformly distributed identifiers are randomly selected (since we assume that any ‚Äúrandom‚Äù process uses a <i>uniform distribution</i> ). <br><br>  We considered the probability of a collision from the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D1%2580%25D0%25B0%25D0%25B4%25D0%25BE%25D0%25BA%25D1%2581_%25D0%25B4%25D0%25BD%25D0%25B5%25D0%25B9_%25D1%2580%25D0%25BE%25D0%25B6%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">paradox of birthdays</a> and accepted that the size of the request identifier would be 22 characters long, chosen from a dictionary containing 64 letters.  For example, <i>EB5iGydiUL0h4bRu1ZyRIi</i> or <i>HV2ZKGVJJklN0eH35IgNaB</i> .  Since each identifier character can take one of 64 values, our identification space is 64 <sup>22</sup> ‚âà 2 <sup>132</sup> .  With this amount of space, if identifiers are randomly generated at a speed of <b>1 million per second</b> , then the probability of a collision occurring <b>within 300 years</b> will be <b>1 to 6 billion</b> . <br><br>  Well, the space was big enough.  How do we randomly generate?  The answer is: with a decent pseudo-random generator (PRNG), which can usually be found in many standard libraries.  At the top level of our stack is the Node.js service, which in turn uses the V8 engine developed by Google for Chrome.  All compatible ECMAScript (JavaScript) implementations should use Math.random (), which returns a random number from 0 to 1 without any arguments. Based on the sequence of these numbers from 0 to 1, you need to generate a random word consisting of 64 characters of the alphabet.  This is a fairly common task for which a standard solution has been developed: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ALPHABET = <span class="hljs-string"><span class="hljs-string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'</span></span>; random_base64 = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">random_base64</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rand = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * ALPHABET.length); str += ALPHABET.substring(rand, rand+<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; }</code> </pre> <br>  <a href="https://gist.github.com/mmalone/153e9c1872cd2927ca66">Link</a> <br><br>  No need to criticize this code, everything is in order, it does exactly what it should.  Go ahead.  We developed a procedure for generating random identifiers with an extremely low probability of a collision.  We test, commit, push, test, deploy.  The above example got into production, and we forgot about it.  But once a letter came from a colleague, which reported that the incredible happened: <br><br><img src="https://cdn-images-1.medium.com/max/800/1*urW__HeiLoVmMS1hlIrc_Q.png" alt="image"><br><br><img src="https://cdn-images-1.medium.com/max/800/1*02xH3GhW9l5zUfXLAqGaHQ.png" alt="image"><br><br>  "Anyone who allows the use of arithmetic methods to generate random numbers commits a sin."  John von Neumann spoke about the obvious: the statement that deterministic methods (for example, arithmetic) cannot generate random numbers is a tautology.  So what is PRNG? <br><br><h1>  What are pseudo random number generators? </h1><br>  Let's consider a <a href="https://gist.github.com/mmalone/6ef9fabe1a7540ae89e8">simple PRNG</a> and the results of its work: <br><br><img src="https://habrastorage.org/files/a73/c40/05d/a73c4005d8dc4f4b8864ab8374e71c64.jpg"><br><br>  This illustration explains Von Neumann‚Äôs thought: it is obvious that the generated sequence of numbers is not random.  For many tasks this is quite enough.  But we need an algorithm that generates numbers that <i>seem</i> random.  Technically, they should seem independent and equally distributed random variables, evenly distributed over the entire range of the generator.  In other words, we need to <i>safely pretend</i> that our <i>pseudo-random</i> numbers are <i>truly</i> random. <br><br>  If the result of the generator is very difficult to distinguish from a truly random sequence, then it is called a <b>high-quality</b> generator.  Otherwise - <b>low quality</b> .  For the most part, quality is determined empirically, by running statistical tests for randomness.  For example, the number of zeros and ones is estimated, the number of collisions is calculated, the Monte Carlo method is used to calculate œÄ, etc. Another, more pragmatic method of assessing the quality of PRNG is to analyze its work in practice and compare it with true random numbers. <br><br>  In addition to the non-randomness of the result, the simple algorithm we consider demonstrates other important features common to all PRNGs.  If you generate numbers for a long time, sooner or later the same sequence will begin to repeat.  This property is called periodicity, and all PRNGs ‚Äúsuffer‚Äù with it. <br><br>  <b>The period</b> , or <b>cycle length</b> , is the length of the sequence of numbers created by the generator before the first repetition. <br><br>  You can consider PRNG as a highly compressed codebook containing a sequence of numbers.  Any spy could use it as a one-time pad.  The initial position in this ‚Äúbook‚Äù is seed ().  Gradually you will reach its end and return to the beginning, completing the cycle. <br><br>  Long cycle length does not guarantee high quality, but rather contributes to it.  Often it is guaranteed by some mathematical proof.  Even when we cannot accurately calculate the length of the cycle, we are quite able to determine its upper limit.  Since the next state of the PRNG and its result are deterministic functions of the current state, the cycle length cannot be greater than the number of possible states.  To achieve the maximum length, the generator must go through all possible states before returning to the current one. <br><br>  If the PRNG state is described as <b>k-bit</b> , then the cycle length is <b>‚â§ 2 <sup>k</sup></b> .  If it really reaches this value, then such a generator is called <b>a full-cycle generator</b> .  In good PRNGs, the cycle length is close to this upper bound.  Otherwise you will waste your memory. <br><br>  Let's now analyze the number of unique random values ‚Äã‚Äãgenerated by PRNG using some deterministic transformation of the output.  Suppose we need to generate three random numbers from 0 to 15, like 2, 13, 4 or 5, 12, 15. We can have 16 <sup>3</sup> = 4096 such triple combinations, but the simple generator we are considering can produce only 16 combinations: <br><br><img src="https://habrastorage.org/files/c86/e76/0d4/c86e760d4dbb4386b71972df5b20f7b4.jpg"><br><br>  So we come to another property of all PRNGs: the number of <b>unique values</b> that can be generated from a pseudo-random sequence is <b>limited by the length of the loop of the sequence</b> . <br><br>  It doesn't matter what values ‚Äã‚Äãwe generate in this case.  They can be 16 combinations of four values ‚Äã‚Äã(or any other length), 16 unique matrix arrays, etc. No more than 16 unique values ‚Äã‚Äãof any type. <br><br>  Recall our algorithm for generating random identifiers consisting of 22 characters taken from a 64-character dictionary.  It turns out that we generate combinations of 22 numbers from 0 to 63. And here we are confronted with the same problem: the number of possible unique identifiers is limited by the size of the internal state of the PRNG and the length of its cycle. <br><br><h1>  Math.random () </h1><br>  Let's return to our sheep.  Having received a letter about the occurrence of a collision, we quickly revised our mathematical calculations on the paradox of birthdays and checked the code.  Nothing criminal was found, which means that the problem lies deeper.  Began to understand. <br><br>  Here is what Math.random () says in <a href="http://www.ecma-international.org/ecma-262/6.0/">the ECMAScript specification</a> : <br><br><blockquote>  Returns a positive numeric value greater than or equal to 0 but less than 1, chosen randomly or pseudo-randomly with an approximately uniform distribution in this range, using an algorithm or strategy that is implementation-specific. </blockquote><br>  Specification is poor.  Firstly, nothing is said about accuracy.  Since ECMAScript uses IEEE 754 binary64 double-precision floating-point numbers, we can expect an accuracy of 53 bits (that is, random values ‚Äã‚Äãtake the form x / 2 <sup>53</sup> , where x = 0 ... 2 <sup>53</sup> - 1).  Mozilla‚Äôs SpiderMonkey engine is of <a href="">the same opinion</a> , but it‚Äôs not.  As will be shown below, the accuracy of Math.random () in V8 is only 32 bits (values ‚Äã‚Äãtake the form x / 2 <sup>32</sup> , where x = 0 ... 2 <sup>32</sup> - 1).  However, this is not important, since we need six bits to generate random letters from our dictionary. <br><br>  But what turned out to be really important for us is that the specification does not define a specific algorithm.  There are no requirements for the minimum cycle length, so goodbye, quality: the distribution should only be "approximately uniform."  So, to find the cause of the collision, you need to analyze the specific algorithm used by the V8.  We didn't find anything in the documentation, so we had to access the source code. <br><br><h1>  Pseudo-random number generator in V8 </h1><br>  "I had to put up with the <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B8%25D1%2585%25D1%2580%25D1%258C_%25D0%259C%25D0%25B5%25D1%2580%25D1%2581%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0">whirlwind of Mersenne</a> , because it is used by everyone (Python, Ruby, etc.)."  This brief description of <a href="http://www.deanmcnamee.com/about">Dina McNami</a> is the only informative review on the <a href="https://codereview.chromium.org/126113">analysis of the</a> PRNG <a href="https://codereview.chromium.org/126113">code</a> in V8, when it was <a href="https://github.com/v8/v8/commit/aa176ce815355f5c7e9d4b91e8f5627f12e7109b">first committed</a> on June 15, 2009. <br><br>  Over the past six years, the PRNG code in the V8 has been reworked and aligned.  Previously, it was a <a href="">native code</a> , and now it is in <a href="">user space</a> .  But the algorithm remained unchanged.  The current implementation uses an internal API and is rather confusing, so consider a more readable implementation of the same algorithm: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MAX_RAND = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state = [seed(), seed()]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mwc1616 = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mwc1616</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r0 = (<span class="hljs-number"><span class="hljs-number">18030</span></span> * (state[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>)) + (state[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r1 = (<span class="hljs-number"><span class="hljs-number">36969</span></span> * (state[<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>)) + (state[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | <span class="hljs-number"><span class="hljs-number">0</span></span>; state = [r0, r1]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = ((r0 &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) + (r1 &amp; <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>)) | <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = x + MAX_RAND; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x / MAX_RAND; }</code> </pre><br>  <a href="https://gist.github.com/mmalone/ce523298670da66acaa1">Link.</a> <br><br>  It looks obscure, we will understand. <br><br>  There is one clue.  In older versions of the V8, there was a comment: "The random number generator uses the MWC algorithm of George Marsaglia."  In the search engine found the following: <br><br><ul><li>  <a href="https://en.wikipedia.org/wiki/George_Marsaglia">George Marsalya</a> was a mathematician, most of his career was engaged in the study of PRNG.  He also developed <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D1%2581%25D1%2582%25D1%258B_diehard">Diehard tests</a> to measure the quality of random number generators. </li><li>  MWC means <a href="https://en.wikipedia.org/wiki/Multiply-with-carry">multiply-wit-carry</a> .  This is a class of pseudo-random number generators <a href="http://digitalcommons.wayne.edu/cgi/viewcontent.cgi%3Farticle%3D1725%26context%3Djmasm">developed by Marsalya</a> .  They are very similar to the classical <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25B9%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25BD%25D0%25B3%25D1%2580%25D1%2583%25D1%258D%25D0%25BD%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4">linear congruential generators</a> (LCG), an example of which we considered above.  And if you believe paragraph 3.6 of <a href="http://www.iro.umontreal.ca/~lecuyer/myftp/papers/handstat.pdf">this document</a> , the MWC is fully consistent with the LCG.  The only difference is that MWCs can generate sequences with a longer cycle length with a comparable number of processor cycles. </li></ul><br>  So if you need a PRNG, then the MWC seems like a good choice. <br><br>  But the algorithm implemented in V8 is unlike the typical MWC.  Probably, the reason is that this is not MWC, but two MWC generators at once - one in line 5, the second in line 6 - jointly generating one random number in line 9. I will not spread all the calculations here, but each of these subgenerators has a cycle length of approximately 2 <sup>30</sup> , which gives a total length of the generated sequence of approximately 2 <sup>60</sup> . <br><br>  But we have, as you remember, <sup>2,132</sup> possible identifiers.  Assume that the condition of uniform distribution.  Then the probability of a collision after randomly generated 100 million identifiers should be less than 0.4%.  But collisions began to occur much earlier.  Probably, we were mistaken somewhere with our analysis.  Perhaps the problem lies in the uniform distribution - there is probably some additional structure in the generated sequence. <br><br><h1>  The story of two generators </h1><br>  Let's look again at the identifier generation code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ALPHABET = <span class="hljs-string"><span class="hljs-string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'</span></span>; random_base64 = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">random_base64</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rand = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * ALPHABET.length); str += ALPHABET.substring(rand, rand+<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; }</code> </pre><br>  <a href="https://gist.github.com/mmalone/153e9c1872cd2927ca66">Link</a> <br><br>  Of great importance is the scaling method in the sixth row.  It is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random">recommended by MDN</a> for scaling random numbers and is used very widely ( <a href="">example 1</a> , <a href="">example 2</a> , <a href="https://github.com/mbostock/d3/wiki/Math">example 3</a> , <a href="http://stackoverflow.com/questions/4959975/generate-random-value-between-two-numbers-in-javascript">example 4</a> , <a href="http://www.w3schools.com/jsref/jsref_random.asp">example 5</a> , <a href="http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript">example 6</a> ).  The method is known as <i>multiply-and-floor, take-from-top</i> .  He received the last name because the lower bits of the random number are cut off, and the left bits - the top, top, - are used as a scaled integer result. <br><br>  Note: if the ratio of the output range of the PRNG to the scalable range is a fractional number, then this method works with a small offset (biased).  This is usually solved by using the <a href="https://gist.github.com/mmalone/d710793137ed0d6b8cb4">deviation sample</a> used in standard libraries of <a href="">other</a> <a href="https://github.com/python/cpython/blob/3.5/Lib/random.py">languages</a> . <br><br><img src="https://habrastorage.org/files/12b/93b/e05/12b93be05e5f48aa9941230a81714a31.jpg"><br><br>  Notice what the problem is?  Two generators are rather strangely mixed in the V8 algorithm.  Numbers from two streams are not combined modulo 2 (xor).  Instead, the lower 16 bits of the output of each subgenerator are simply concatenated.  That seems to be the problem.  When we multiply Math.random () by 64 and bring it to the smallest one (floor), then we will have the upper 6 bits.  <b>These bits are generated exclusively by one of the two MWC generators.</b> <br><br><img src="https://habrastorage.org/files/6dc/118/436/6dc1184366ca40a78585f07d0403c99c.jpg"><br><br>  <i>Bits from PRNG No. 1 are highlighted in red, and PRNG No. 2 from blue.</i> <br><br>  If we independently analyze the first generator, then we will see that its internal state is 32 bits long.  This is not a full cycle generator, the actual length is about 590 million: 18.030 * 2 <sup>15</sup> - 1, the details of the calculations can be found here - <a href="http://digitalcommons.wayne.edu/cgi/viewcontent.cgi%3Farticle%3D1725%26context%3Djmasm">link 1</a> , <a href="https://en.wikipedia.org/wiki/Multiply-with-carry">link 2</a> .  That is, we can generate no more than 590 million unique identifiers of the request.  And if they were chosen randomly, then <b>after 30 thousand generations the probability of a collision would be 50%</b> . <br><br>  But if this were so, we would almost immediately begin to notice collisions.  But we did not notice them.  To understand why this did not happen, let's recall the example of generating combinations of three numbers using 4-bit LCG. <br><br><img src="https://habrastorage.org/files/c86/e76/0d4/c86e760d4dbb4386b71972df5b20f7b4.jpg"><br><br>  In this case, the paradox of birthdays is not applicable - the sequence cannot even be called a random sequence, so we cannot <i>pretend</i> .  Obviously, there will be no duplicates before the 17th combination.  The same thing happens with PRNG in V8: under certain conditions, the <i>lack of randomness reduces the likelihood</i> that we will see a collision. <br><br>  That is, the determinism of the generator has played into our hands.  But this is not always the case.  The main conclusion we made is that even in a high-quality PRNG, it is impossible to assume the randomness of the distribution if the cycle length is not <i>much more</i> than the number of values ‚Äã‚Äãgenerated by you. <br><br>  If you need N random values, then you need to use PRNG with a cycle length of at least N <sup>2</sup> .  The reason for this is that, given the period of PRNG, excessive uniformity can reduce performance in some important statistical tests (especially in tests for the presence of collisions).  To prevent this from happening, the sample size N must be proportional to the square root of the period length.  You can read more about this on page 22 of the wonderful <a href="http://www.iro.umontreal.ca/~lecuyer/myftp/papers/handstat.pdf">work of</a> Pierre Lecuyet, in the chapter on random number generators. <br><br>  In cases like ours, when they are trying to generate unique values ‚Äã‚Äãusing several independent sequences from one generator, they are concerned not so much about randomness, but about the fact that the sequences do not match.  Suppose we have N sequences with length L from a generator with period P. Then the probability of coincidence will be equal to <br><br><img src="https://habrastorage.org/files/baa/a08/105/baaa08105e084762b5869f0328e180dd.png"><br><br>  For sufficiently large values ‚Äã‚Äãof P, the probability will be approximately equal to LN <sup>2</sup> / P (details: <a href="http://xorshift.di.unimi.it/">link 1</a> , <a href="http://www.mathpages.com/home/kmath580/kmath580.htm">link 2</a> ).  So, we need a long cycle, otherwise we will erroneously pretend that our sequence is random. <br><br>  In short, if you use Math.random () in V8 and you need a sufficiently high-quality sequence of random numbers, then do not use more than 24 thousand numbers.  And if you generate in several powerful threads and you need to avoid coincidences, then generally forget about Math.random (). <br><br><h1>  Brief history MWC1616 </h1><br>  ‚ÄúThe MWC generator concatenates two 16-bit multiply-with-carry-generator [...] has a period of 2 <sup>60</sup> and seems to pass all tests for randomness.  The favorite individual generator is faster than the KISS containing it. ‚Äù  This is an excerpt from the MWC1616 algorithm description underlying Math.random () in V8.  Judging by the words of Marsaly, it satisfies most of the main criteria by which PRNG is chosen. <br><br>  The MWC1616 was <a href="https://groups.google.com/forum/">introduced</a> in 1997 as a simple main generator.  The phrase "it seems to pass all tests for randomness" gives the empiricality of the Marsala methodology.  He seems to have trusted the algorithm since he passed the Diehard tests.  Unfortunately, the tests that he used in the late 1990s were not good enough, at least based on modern standards.  If you run the MWC1616 through a more modern testing framework like <a href="http://simul.iro.umontreal.ca/testu01/tu01.html">TestU01</a> , the result will be <a href="https://gist.github.com/mmalone/8b43c628c39cc39aa205">disastrous</a> .  Even <a href="https://en.wikipedia.org/wiki/Lehmer_random_number_generator">the MINSTD generator</a> shows better results, but it became outdated in the 1990s.  Probably, Diehard's tests were simply not detailed enough, so Marsalla made such a conclusion. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// January 12, 1999 / V8 PRNG: ((r0 &lt;&lt; 16) + (r1 ^ 0xFFFF)) % 2^32 var x = ((r0 &lt;&lt; 16) + (r1 &amp; 0xFFFF)) | 0; // January 20, 1999: (r0 &lt;&lt; 16) + r1) % 2^32 var x = ((r0 &lt;&lt; 16) + r1) | 0;</span></span></code> </pre><br>  <a href="https://gist.github.com/mmalone/178e4e9484231b343a1a">Link</a> <br><br>  As far as I know, the concatenation procedure for two subsets of the generated bits, performed in MWC1616, has no mathematical basis.  Usually, bits from subgenerators are combined using modulo arithmetic (for example, xor).  It seems that Marsalla attended to the lack of a mathematical basis soon after the publication of his algorithm as a component of one of the versions of <a href="https://eprint.iacr.org/2011/007.pdf">the KISS generator</a> .  January 12, 1999 released version MWC1616, used in the V8.  And on January 20, Marsala published <a href="https://groups.google.com/forum/">another version of</a> his algorithm.  In it, the upper bits of the second generator are not discarded, the streams are mixed more precisely. <br><br>  Both versions of the algorithm appeared on different resources, which caused confusion.  A later (improved) version called <i>MWC with Base b = 2 <sup>16</sup></i> is published on <a href="http://numerical.recipes/">Numerical Recipes</a> under the heading "When You Have Only 32-Bit Computing."  And instead of introducing one of the algorithms, it was suggested ‚Äúto use a better compiler!‚Äù.  Pretty dull advice with regards to the algorithm that is better used in V8.  For an inexplicable reason, the version of January 20 is given in Wikipedia as an <a href="https://en.wikipedia.org/wiki/Random_number_generation">example of a</a> computational method for generating random numbers.  The older version of January 12th <a href="http://simul.iro.umontreal.ca/testu01/guideshorttestu01.pdf">was included twice in TestU01</a> , first under the name MWC1616, and then MWC97R.  Also, this algorithm is used as one of the generators <a href="">in the R language</a> . <br><br>  In general, MWC is used quite widely.  And I hope this article will serve as a warning to many developers, becoming the development and confirmation of Knut‚Äôs observations: <br><br><ul><li>  In general, you need to independently analyze the work of PRNG in order to understand the limitations of the algorithms used or implemented. </li><li>  Do not use MWC1616, it is of little use to it. </li></ul><br>  There are many more useful options.  Let's look at a couple. <br><br><h1>  CSPRNG Alternative </h1><br>  So, we had to quickly replace Math.random () with something.  There are many other PRNGs for JavaScript, but we had two conditions: <br><br><ul><li>  The generator must have a sufficiently long period to generate <sup>2,132</sup> identifiers. </li><li>  It should be thoroughly tested and have good support. </li></ul><br>  Fortunately, the standard library Node.js has another generator that meets our requirements: <a href="https://nodejs.org/api/crypto.html">crypto.randomBytes ()</a> , a cryptographically secure PRNG (CSPRNG) that calls <a href="">RAND_bytes</a> , used in OpenSSL.  According to the <a href="https://wiki.openssl.org/index.php/Manual:Rand%25283%2529">documents</a> , it issues a random number using the SHA-1 hash with an internal state of 8184 bits, which is regularly re-randomized (reseed) from various entropic sources.  In a web browser, <a href="https://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues">crypto.getRandomValues ‚Äã‚Äã()</a> should do the <a href="https://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues">same</a> . <br><br>  This solution has three drawbacks: <br><br><ul><li>  CSPRNG almost always uses non-linear transformations, and therefore they run slower than non-cryptographic alternatives. </li><li>  Many CSPRNG systems cannot be randomized (seed), which makes it impossible to create a reproducible sequence (for example, for testing purposes). </li><li>  CSPRNG may unpredictably stand out against all other quality measures, some of which may be more important for your project. </li></ul><br>  However, there are advantages: <br><br><ul><li>  In most cases, CSPRNG's performance is quite enough (on my machine, I can get about 100 MB / s of random data in Chrome using crypto.getRandomValues ‚Äã‚Äã()). </li><li>              . ,    ,   ,   . </li><li>     ¬´ ¬ª,   ,             . </li></ul><br>      ,         - .         ,     CSPRNG.   ,   ,           .     CSPRNG     (       ),    <a href="http://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/">urandom</a> ,    ( Linux  ,  OpenSSl,   OS X ‚Äî  <a href="https://www.schneier.com/yarrow.html">Yarrow</a> ). <br><br>   ,     crypto.randomBytes().   ,         .   ,               .     OpenSSL   / ,       ?      Math.random()  crypto.randomBytes(),   . <br><br>    Chrome    Math.random()    CSPRNG,    crypto.randomBytes().   , <a href="">WebKit    </a> .           . <br><br><h1>  PRNG  V8 </h1><br>    ,   Math.random()  V8 ,    .          ,         .      ,    : <br><br><img src="https://habrastorage.org/files/18e/faa/afe/18efaaafef9e45b88fc02e797e7fa2c8.png"><br><br><img src="https://habrastorage.org/files/8c5/207/60a/8c520760a17141039b256e298adfdb4d.png"><br><br> <i> ‚Äî       Safari,  ‚Äî  V8.       <a href="http://bl.ocks.org/mmalone/bf59aa2e44c44dde78ac"> </a> :</i> <br><br><img src="https://habrastorage.org/files/10e/94d/207/10e94d207cc745dbae799befeb32d545.png"><br><br> <i>  œÄ    -, 10 <sup>10</sup> . <a href="https://gist.github.com/mmalone/796d959dcf5b780106f4"></a> .</i> <br><br> ,   ,   Math.random()  - .  ‚Äî <i> </i> .       ,         MWC1616.   . <br><br>             .     ,     : <br><br><ul><li> <b>      </b> (seed) ‚Äî  ,   1024 .         .  99,9%     2 <sup>1024</sup>  ,     . </li><li>  <b>Speed</b>       ‚Äî 25       . </li><li> <b>  </b> . ,    1024      JavaScript    256  (    32    64- ).   ,     ,   ,   . </li><li> <b>  </b> .    ‚Äî  ,      2 <sup>50</sup>   ,   .   2 <sup>100</sup>     2 <sup>50</sup>   ,      . </li><li> <b>    </b> .   ‚Äî <a href="http://simul.iro.umontreal.ca/testu01/tu01.html">TestU01</a> .  ,  <a href="https://www.phy.duke.edu/~rgb/General/dieharder.php">Dieharder</a> .      BigCrush   .  <a href="http://csrc.nist.gov/groups/ST/toolkit/rng/documentation_software.html"> NIST</a>  <a href="https://www.gnu.org/software/hurd/user/tlecarrour/rng-tools.html">rngtest</a>    ,      . </li></ul><br>   PRNG,      .  <a href="https://en.wikipedia.org/wiki/Xorshift">xorshift</a> (  )          .   ,   xorgens4096,  <a href="">  JavaScript</a> .     4096 ,    2 <sup>4096</sup>    Chrome    <a href="http://jsperf.com/prng-performance/2"></a> ,  MWC1616.  ,    BigCrush. <br><br>  <a href="http://vigna.di.unimi.it/ftp/papers/xorshift.pdf"> </a> ,     xorshift-      ,     BigCrush.     xorshift*.    ,     <a href="https://gist.github.com/mmalone/173e20becc755ebb2658"> </a> .  xorshift1024*    ,    . Xorshift64*    ,    ,   MWC1616.     -  ‚Äî <a href="http://www.pcg-random.org/">PCG</a> ‚Äî       . <br><br>  ,    .  , ,   .      MT19937, <a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf"></a>   1990-.      <a href="https://en.wikipedia.org/wiki/Mersenne_Twister">    </a> .  ,       .    ,      .     2 <sup>19937</sup> ‚Äì 1,    2               .   <a href="https://gist.github.com/banksean/300494">  JavaScript</a> .       Math.random()  Chrome   . <br><br> ,       -       .       ,          .   ‚Äî    .     MWC1616,  ! <br><br><h1>  Results </h1><br>    .    : <br><br><ul><li>   V8  Math.random()   MWC1616.       16 ,           ( 2 <sup>30</sup> ).         .       ,     .        . </li><li>         ,      PRNG.   (     ) ‚Äî <a href="http://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/">urandom</a> .     <a href="https://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues">crypto.getRandomValues()</a> . </li><li>       ,       ,  MWC1616.  V8     .   , ,    ‚Äî   (MT19937). </li></ul><br>  ,  <a href=""> Mozilla LCG-</a>  Java- util.Random   ,  MWC1616.         SpiderMonkey. <br><br>          .  Take care of yourself! </div><p>Source: <a href="https://habr.com/ru/post/274253/">https://habr.com/ru/post/274253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274241/index.html">Security Scanners: Automatic Vulnerability Classification</a></li>
<li><a href="../274245/index.html">GlassRAT: Trojan analysis from China using RSA Security Analytics and RSA ECAT</a></li>
<li><a href="../274247/index.html">Sociology of algorithms: How financial markets and high-frequency trading are connected (Part 1)</a></li>
<li><a href="../274249/index.html">Authorization in Ubuntu through Microsoft Azure AD / Office 365</a></li>
<li><a href="../274251/index.html">Build and configure FreeRADIUS 3 with SQLITE support</a></li>
<li><a href="../274255/index.html">Authorization in CentOS through Microsoft Azure AD / Office 365</a></li>
<li><a href="../274257/index.html">Free practical course on bash and other good news</a></li>
<li><a href="../274263/index.html">Audience segmentation when developing games</a></li>
<li><a href="../274265/index.html">Apple has taken security measures after a failed year</a></li>
<li><a href="../274267/index.html">Key features of the 802.11ac standard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>