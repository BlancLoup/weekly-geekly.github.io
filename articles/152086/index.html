<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>From serial to parallel code in five steps with Intel¬Æ Advisor XE</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you have been developing multi-threaded applications for a long time, you have probably come across the parallelization of already existing sequent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>From serial to parallel code in five steps with Intel¬Æ Advisor XE</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/storage2/6b1/d48/b08/6b1d48b0847cc32e6c89b176563342c5.png"><br>  If you have been developing multi-threaded applications for a long time, you have probably come across the parallelization of already existing sequential code.  Or vice versa, you are new to parallel programming, and you are faced with the task of optimizing the project and improving scalability, which can also be solved by parallelizing individual sections of the program. <br><br>  The new Intel Advisor XE tool will help you parallelize the application, spending at least a minimum of time and effort. <br><br>  Advisor XE was released in September this year as part of the package for developers <a href="http://habrahabr.ru/company/intel/blog/151398/">Intel Parallel Studio XE 2013</a> .  The literal translation of the name - "adviser" - quite succinctly describes its purpose.  The tool helps the programmer to analyze the possibility of code parallelization: to find the most suitable sections for this and evaluate the intended useful effect - is it worth it to do this at all?  In addition, Advisor XE will tell you where errors may occur, such as data races.  And all this without a real modification of the program!  But first things first. <br><a name="habracut"></a><br>  Advisor XE is available for Windows * and Linux * and works with C ++, C #, and Fortran.  In this post, I will use the Windows * version - it has easy integration into Microsoft Visual Studio * (for those who want, there is also its own interface without integration).  As an example, I took the Tachyon program included in the Advisor XE example set.  It performs 2D rendering and ray tracing, producing the following image: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/58d/034/454/58d034454e15001e644bb2cfd2f788a9.png" alt="image"><br><br>  In Visual Studio Advisor XE adds its own toolbar, which provides quick access to its functions.  So, open your project, build it in the ‚ÄúRelease‚Äù mode and open the ‚ÄúAdvisor XE Workflow‚Äù: <br><br><img src="https://habrastorage.org/storage2/619/58f/e6a/61958fe6a17376fabd46f8e2c8f12065.png"><br><br>  Advisor XE Workflow guides the developer through the five steps of evaluating the application, after which he will be able to make a sensible decision on whether to parallelize this code and where to do it. <br><br><h4>  Stage 1. Profiling (Survey Target) </h4><br>  The first thing Advisor XE does is launch your application and profile it, i.e.  evaluates performance and searches for ‚Äúhot spots‚Äù ‚Äîfunctions, loops, and individual instructions that consume most of the processor resources.  This is necessary in order to concentrate efforts on the most critical for the performance areas, since their parallelization will bring the greatest effect.  To begin profiling, click the ‚ÄúCollect Survey Data‚Äù button in the Advisor XE Workflow window: <br><br><img src="https://habrastorage.org/storage2/60b/581/ec8/60b581ec8daf6a32b2c799dd0b04604a.png"><br><br>  Advisor XE runs the application, waits until it is finished, and ‚Äúfinalizes‚Äù the collected data.  After that, the user is presented with a list of functions and places in the code in a hierarchical form, for each of which the CPU time is displayed in seconds and percentages.  Separately shown is the intrinsic time of the function and the time including the nested functions: <br><br><img src="https://habrastorage.org/storage2/38a/3f6/154/38a3f61540030f8c755e8010693c5e99.png"><br><br>  Those places where the ‚Äúhot spot‚Äù is a cycle are marked with a special icon.  This is convenient because  Loops often become the object of parallelization if, for example, they process large amounts of independent data. <br><br>  The profiling data gives the programmer a first estimate of the load distribution within the application.  This allows you to make a meaningful, digit-based assumption about which parts of the code will be useful to parallelize. <br><br>  In our example, we will stop the selection at the topmost in the stack of calls of the function containing the cycle - parallel_thread.  It (including nested functions) accounts for 80.9% of the CPU time spent.  By the way, double clicking on the ‚Äúhot‚Äù function will take you to the source view, where there will also be information about using the CPU, but for specific lines of code. <br><br><h4>  Stage 2. Annotations (Annotate Sources) </h4><br>  When the first assumption about the future implementation of multithreading is made, you need to inform the "advisor".  The so-called annotations are used for this - special macros (or function calls, depending on the language), which are understandable by the Advisor, but do not affect the functioning of your program. <br><br>  In Visual Studio, annotations are added using the context menu - just select the block of code you like and launch the Annotation Wizard: <br><br><img src="https://habrastorage.org/storage2/36a/b92/22a/36ab9222adeed7f4d20bb66fef524280.png"><br><br>  Advisor XE annotations are of several types.  To simulate the loop parallelization, we will need two main ones - ‚ÄúAnnotate Site‚Äù and ‚ÄúAnnotate Task‚Äù. <br><br>  ‚ÄúAnnotate Site‚Äù is used to mark the boundaries of a parallel region in the code.  For C ++, it is represented by macros ANNOTATE_SITE_BEGIN and ANNOTATE_SITE_END.  In our example, we will parallelize the for loop, breaking the iteration space into smaller chunks, so that each such chunk can run in parallel with the others. <br><br>  ‚ÄúAnnotate Task‚Äù is used to mark the boundaries of a single task using the ANNOTATE_TASK_BEGIN and ANNOTATE_TASK_END macros.  A task is a block of code that can be executed repeatedly by different threads.  Tasks are executed in parallel with other tasks and the rest of the code in a parallel region. <br><br>  So proceed to the markup.  We enclose the whole for loop in a parallel region.  And we denote the cycle body as a task, since  it will be executed in parallel (in the model) over different iterations: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;advisor-annotate.h&gt; ... static void parallel_thread (void) { ANNOTATE_SITE_BEGIN(allRows); for (int y = starty; y &lt; stopy; y++) { ANNOTATE_TASK_BEGIN(eachRow); m_storage.serial = 1; m_storage.mboxsize = sizeof(unsigned int)*(max_objectid() + 20); m_storage.local_mbox = (unsigned int *) malloc(m_storage.mboxsize); memset(m_storage.local_mbox,0,m_storage.mboxsize); drawing_area drawing(startx, totaly-y, stopx-startx, 1); for (int x = startx; x &lt; stopx; x++) { color_t c = render_one_pixel (x, y, m_storage.local_mbox, m_storage.serial, startx, stopx, starty, stopy); drawing.put_pixel(c); } if(!video-&gt;next_frame()) { free(m_storage.local_mbox); return; } free(m_storage.local_mbox); ANNOTATE_TASK_END(eachRow); } ANNOTATE_SITE_END(allRows); }</span></span></span></span></code> </pre> <br><br>  In order for the C ++ program to be compiled with annotations, you need to include the header file advisor-annotate.h. <br><br><h4>  Step 3. Check Efficiency (Check Suitability) </h4><br>  In the third step, Advisor XE does the re-profiling.  The difference from the first profiling is that now it is not information about ‚Äúhot functions‚Äù that is collected, but the parallel execution of the application is simulated and its potential operation speed is estimated. <br><br>  The program is executed in the same way as without annotations - in single-threaded mode.  The speed of work and the correctness of the results do not suffer.  However, annotations allow the tool to simulate a multi-threaded execution of annotated code and give an evaluation of the effectiveness in numbers to the programmer‚Äôs court: <br><br><img src="https://habrastorage.org/storage2/450/686/945/4506869453699ecbf57fb0968bb0c8af.png"><br><br>  The result of evaluating the effectiveness (or suitability analysis) gives us a lot of interesting information: <br><ul><li>  Acceleration of the entire program compared with the sequential execution (in our example, 1.48x) </li><li>  Acceleration of a separate parallel region (in the example 7.88 on 8 cores) </li><li>  Scalability estimation for 2-32 processor cores </li><li>  Details about parallel regions and tasks (execution time, number of tasks, etc.) </li></ul><br>  This information can be obtained for a different number of cores by switching the corresponding checkbox.  Those.  even working on a dual-core laptop, you can evaluate how the program will scale on a multi-core server. <br><br>  In fairness, I must say that the results will not always be so rosy.  It may turn out that the predicted positive effect from parallelization is not so high, or even zero.  But this result will also be useful, since  you will be convinced of the inefficiency of the chosen approach, and you will look for other ways.  This is the purpose of Advisor XE - to give the opportunity to try many approaches to parallelization, spending a minimum of time and effort, and choose the best one. <br><br>  It may happen that all the approaches tested do not give an acceptable result.  This may give you the idea of ‚Äã‚Äãchanging the structure of the code so that it is easier to parallelize.  Of course, Advisor XE will not provide extensive consultations on this score, but you should pay attention to the list of tips - perhaps some information will prompt you to think correctly. <br><br><h4>  Step 4. Check Correctness </h4><br>  Turning a single-threaded program into a multi-threaded program can lead to new bugs, such as data races.  To facilitate verification and debugging in a ‚Äúlive‚Äù program, Advisor XE allows you to assess the correctness of the solution modeled by the programmer.  To do this, you need to recompile the program in the ‚ÄúDebug‚Äù mode and run the Advisor XE - ‚ÄúCheck Correctness‚Äù correctness check. <br><br>  Validation will slow down the execution of the program, since the executable file is subjected to binary instrumentation, which helps Advisor XE to track the program for errors.  Therefore, it makes sense to reduce the load on the application, if possible - to reduce the size of the input data, to reduce the frequency of updating frames, etc. <br><br><img src="https://habrastorage.org/storage2/a62/c7b/e63/a62c7be6308e8af60610458c83f01254.png"><br><br>  As a result of the check, the Correctness Report appears.  It includes a list of errors, their type, a parallel region in which they appear.  By double-clicking on the error, you can go to the source view, where additional information appears, for example, call stacks: <br><br><img src="https://habrastorage.org/storage2/294/ee0/e6f/294ee0e6fe7f66df771199334e6630f3.png"><br><br>  In our example, the data race was discovered - the global variable g_updates is incremented in the video :: next_frame () function.  While the program does not affect the performance, because in reality the code is still single-threaded.  However, it is obvious that the problem will have to be resolved, and this will have an impact on performance - synchronization objects may appear that hold back scalability, or vice versa, localization of variables will have a positive effect. <br><br>  To check this out, Advisor XE has another type of annotation - ‚ÄúLock Annotations‚Äù.  They are used to model critical sections.  In our example, g_updates is modified in the video :: next_frame () function, which is called in our parallelized loop.  Therefore, we can protect it with synchronization annotations here: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel_thread</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ANNOTATE_SITE_BEGIN(allRows); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = starty; y &lt; stopy; y++) { ANNOTATE_TASK_BEGIN(eachRow); m_storage.serial = <span class="hljs-number"><span class="hljs-number">1</span></span>; m_storage.mboxsize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*(max_objectid() + <span class="hljs-number"><span class="hljs-number">20</span></span>); m_storage.local_mbox = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(m_storage.mboxsize); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(m_storage.local_mbox,<span class="hljs-number"><span class="hljs-number">0</span></span>,m_storage.mboxsize); <span class="hljs-function"><span class="hljs-function">drawing_area </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(startx, totaly-y, stopx-startx, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = startx; x &lt; stopx; x++) { <span class="hljs-keyword"><span class="hljs-keyword">color_t</span></span> c = render_one_pixel (x, y, m_storage.local_mbox, m_storage.serial, startx, stopx, starty, stopy); drawing.put_pixel(c); } ANNOTATE_LOCK_ACQUIRE(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!video-&gt;next_frame()) { ANNOTATE_LOCK_RELEASE(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(m_storage.local_mbox); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ANNOTATE_LOCK_RELEASE(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(m_storage.local_mbox); ANNOTATE_TASK_END(eachRow); } ANNOTATE_SITE_END(allRows); }</code> </pre><br><br>  After the done changes, we reassemble the program and check it again.  It is possible to check for correctness - whether the problem is solved, and for performance - what the effect of parallelization will be in view of the presence of a critical section.  In our example, the introduction of the critical section had almost no effect on performance. <br><br><h4>  Step 5. Implement Parallelization (Add Parallel Framework) </h4><br>  The last stage of code parallelization is actually parallelization, i.e.  selection of streaming API, direct encoding and debugging.  This step is only conditionally included in the ‚Äúworkflow‚Äù Advisor XE, so as not to forget, so to speak.  The ‚ÄúAdvisor‚Äù is intended only for modeling and providing the developer with analytical information, on the basis of which he will have a clearer idea of ‚Äã‚Äãwhere to go next - what should be modified and how, what effect to expect and what problems may arise.  Then you have to act yourself. <br><br>  But do not be discouraged - in the package Intel Parallel Studio XE there are many more tools that will help in other stages.  To implement a parallel loop on the model in the above example, you can use a set of high-level "parallel frameworks" that allow you to abstract from the independent creation of threads and load distribution between them.  For example, you can convert a serial loop to a parallel one using Intel Cilk Plus.  You will need to use the Intel compiler.  And as a synchronization primitive you can take tbb :: spin_mutex from the Intel TBB library.  The code of the cycle (already parallel) will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel_thread</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> continue_work = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; cilk_for (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = starty; y &lt; stopy; y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (continue_work) { storage m_storage; m_storage.serial = <span class="hljs-number"><span class="hljs-number">1</span></span>; m_storage.mboxsize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*(max_objectid() + <span class="hljs-number"><span class="hljs-number">20</span></span>); m_storage.local_mbox = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(m_storage.mboxsize); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(m_storage.local_mbox,<span class="hljs-number"><span class="hljs-number">0</span></span>,m_storage.mboxsize); <span class="hljs-function"><span class="hljs-function">drawing_area </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(startx, totaly-y, stopx-startx, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = startx; x &lt; stopx; x++) { <span class="hljs-keyword"><span class="hljs-keyword">color_t</span></span> c = render_one_pixel (x, y, m_storage.local_mbox, m_storage.serial, startx, stopx, starty, stopy); drawing.put_pixel(c); } { tbb::spin_mutex::<span class="hljs-function"><span class="hljs-function">scoped_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lockUntilScopeExit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MyMutex)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!video-&gt;next_frame()) { continue_work = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-built_in"><span class="hljs-built_in">free</span></span> (m_storage.local_mbox); } } }</code> </pre><br><br><h4>  findings </h4><br>  Advisor XE will be useful where there is already a working code that needs to be partially parallelized.  For example, there is an old science application in Fortran that needs to be optimized for a new server or cluster.  The main advantage of the tool is the ability to quickly simulate multi-threaded execution.  After conducting several experiments, you can determine the code points on which it is worthwhile to concentrate efforts, and understand what to expect from this ‚Äî how much parallelization can be useful for, how much scalability can be achieved.  Doing the same thing ‚Äúfor real‚Äù, creating threads and reshaping the code, takes a lot more effort. <br><br>  You can download the trial version of Intel Advisor XE from the product site: <br>  <a href="http://software.intel.com/en-us/intel-advisor-xe">http://software.intel.com/en-us/intel-advisor-xe</a> . <br><br>  Intel Parallel Studio XE 2013: <br>  <a href="http://software.intel.com/en-us/intel-parallel-studio-xe/">http://software.intel.com/en-us/intel-parallel-studio-xe/</a> <br><br>  Intel Cilk Plus <br>  <a href="http://software.intel.com/en-us/intel-cilk-plus-archive">http://software.intel.com/en-us/intel-cilkplus-archive</a> <br><br>  Intel Threading Building Blocks <br>  <a href="http://software.intel.com/en-us/intel-tbb">http://software.intel.com/en-us/intel-tbb</a> <br>  <a href="http://threadingbuildingblocks.org/">http://threadingbuildingblocks.org/</a> </div><p>Source: <a href="https://habr.com/ru/post/152086/">https://habr.com/ru/post/152086/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../152080/index.html">Reverse tethering (get internet on android from linux pc)</a></li>
<li><a href="../152081/index.html">Apple invites former Google Maps employees to work</a></li>
<li><a href="../152082/index.html">Ubuntu 12.10 will advertise and music store</a></li>
<li><a href="../152083/index.html">Rambler-Kart API Update</a></li>
<li><a href="../152085/index.html">Pistol Laser Gun for Nintendo</a></li>
<li><a href="../152089/index.html">Ultrabooks Acer Aspire S5 video review</a></li>
<li><a href="../152092/index.html">ZeroNights 2012: Do you want hardcore?</a></li>
<li><a href="../152093/index.html">Software Freedom Day in Novosibirsk</a></li>
<li><a href="../152096/index.html">What is really needed for successful development?</a></li>
<li><a href="../152097/index.html">Alarm and smart home hardware with wifi / ethernet and 2 x usb host</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>