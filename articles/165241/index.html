<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What inquiries got into QUERY CACHE</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We all know that QUERY CACHE is very useful if you need to optimize frequently repeated database queries, provided that there is a low number of DML o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What inquiries got into QUERY CACHE</h1><div class="post__text post__text-html js-mediator-article"> We all know that <code>QUERY CACHE</code> is very useful if you need to optimize frequently repeated database queries, provided that there is a low number of DML operations (if you are not at all familiar with this functionality, translation of official documentation for setting up this database structure can be read <a href="http://habrahabr.ru/post/41166/">here</a> ).  When you configure query caching options on the server, the question often arises as to what exactly is contained in <code>QUERY CACHE</code> 's at the moment.  Finding the answer to this question at one time put me in a dead end.  The only practical answer that I considered absolutely correct at the time, I found <a href="http://stackoverflow.com/questions/4187794/how-to-list-cached-queries-in-mysql-qcache-queries-in-cache">here</a> .  The answer read as follows: <br><blockquote>  there is no way to find out what queries are now cached </blockquote><br>  those.  This method does not exist.  Only after some time I realized that this was not at all the case, and there is a completely legal way of obtaining the contents of this database structure without patching the source codes.  This way is to write a small plugin for <code>INFORMATION_SCHEMA</code> . <br><a name="habracut"></a><br><h4>  Query Cache General Information </h4><br>  To simplify a bit, the <code>QUERY CACHE</code> data structure consists of: <br>  - data pool <br>  - hash tables with a list of "query structures" <br>  - hash tables with a list of "table structures" <br>  - various locks to control this structure. <br>  It is precisely because of the last item (locks) that <code>QUERY CACHE</code> often recommended to be disabled on servers in a multi-core architecture and active DML, since the overhead associated with properly maintaining this cache may exceed its usefulness.  In general, the memory area used by <code>QUERY CACHE</code> is a complexly connected graph of structures of type <code>Query_cache_block</code> .  A large number of links appeared, most likely, in an evolutionary way in the name of optimizing the algorithms for cleaning and adding data.  To write a plugin, we need only a couple of "trees".  The first part describes the descendants of the <code>HASH Query_cache::queries</code> hash tables of query structures, and the second descendants of the <code>HASH Query_cache::tables</code> hash tables of table structures.  For simplicity, we will present the <code>QUERY CACHE</code> pool data as follows: <br><img src="https://habrastorage.org/storage2/15c/220/e3f/15c220e3fab81553e2ea64f61ac5ff32.png"><br>  The description of this structure, of course, varies somewhat from version to version, but the basic idea remains unchanged for many versions: a hash table with a list of ‚Äúquery structures‚Äù is used to search for queries and extract the calculated result for them, a hash table with a list of ‚Äútable structures‚Äù it is used to delete the data of the changed tables from the query cache (there are many more connections between the two structures described, but for simplicity of description I will omit them, since in this context they are not interesting to us). <br>  According to the received scheme, the main information we are interested in (marked in red) is contained in the structure <br><div class="spoiler">  <b class="spoiler_title">Query_cache_query</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Query_cache_query</span></span></span><span class="hljs-class"> {</span></span> ulonglong limit_found_rows; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uchar* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> ... }</span></span>;</code> </pre><br>  - SQL query and number of records obtained as a result of its execution <br></div></div><br>  it remains only to pull it out. <br><br><h4>  General information about plugins </h4><br>  As I said before: to get this information, we will use the officially provided MySQL framework - <code>INFORMATION_SCHEMA Plugins</code> .  The first job description for the <code>QUERY CACHE</code> structure was produced by <code>Roland Bouman</code> on his blog.  His article, quite old, unfortunately has not been preserved to date.  For those who are not familiar with how to write plugins, I recommend reading <a href="http://habrahabr.ru/post/131410/">this</a> post in Habr√©, from the MySQL <a href="https://habrahabr.ru/users/petropavel/" class="user_link">petropavel</a> developer or the book <code>MySQL 5.1 Plugin Development</code> written with the participation of the same author.  In this article I will try to pay more attention to the details of the implementation of this particular plugin under MySQL 5.5.29 - the latest version of the server at the moment.  The minimum plugin for <code>INFORMATION_SCHEMA</code> should include: <br>  - <code>ST_FIELD_INFO</code> - table structure description <br>  - <code>mysql_declare_plugin</code> - macro of the plugin library descriptor with the type <code>MYSQL_INFORMATION_SCHEMA_PLUGIN</code> and indicating the name of the resulting table <br>  - <code>st_mysql_information_schema</code> - the structure of the descriptor of the plugin itself <br>  - the initialization function of the plug-in, which specifies the procedure that fills the resulting table <br>  - and the function of deinitialization. <br>  For convenience, we will write a plugin that fills in two tables: a list of queries in the cache and the memory <code>QUERY_CACHE_RESULTS</code> they <code>QUERY_CACHE_RESULTS</code> , and a list of database tables that are used to cache <code>QUERY_CACHE_TABLES</code> queries.  To simplify the code, we exclude from the plug-in the management of session variables, pushing through predicates and other useful, but not very important for us, features that can be added later. <br><br><h4>  We connect request cache </h4><br>  The <code>QUERY CACHE</code> implementation of the MySQL server is an instance of the <code>Query_cache::query_cache</code> .  This object is global: its implementation is in <code>sql_cache.cc</code> .  This cache is described in the depths of MySQL, so for the ability to connect our plugin to this structure we will have to compile with the directive <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MYSQL_SERVER</span></span></code> </pre> <br>  This macro will make our plugin incompatible with other versions of MySQL, and even more - even if you try to apply it to the same version but compiled with different compilation directives, at best you will get an error when connecting this plugin, at worst the server will crash. <code>ABORT</code> when trying to execute it.  Even if you put it together with the sources, you still need to be extremely careful, as the plugin runs in the memory of the database server, and the errors of this plug-in when working with memory will lead to the collapse of the entire MySQL server.  We have activated this directive in order to gain access to the notorious hash tables described above, since they are not included in the public section for the <code>Query_cache</code> class, and we will have to inherit to work with them. <br><div class="spoiler">  <b class="spoiler_title">Add a couple of new methods for accessing private class variables.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MySQL_IS_Query_Cache</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Query_cache { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">HASH *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_queries_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;queries; } <span class="hljs-function"><span class="hljs-function">HASH *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_tables_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;tables; } };</code> </pre><br>  - now we can directly work with these hash tables in our plugin. <br></div></div><br>  The main methods for working with objects of type <code>HASH</code> described in the file <code>hash.h</code>  We need only the <code>my_hash_element</code> method, since the plugin does not support parsing the <code>WHERE</code> and we always <code>my_hash_element</code> a complete table containing the entire list of queries available at the moment.  The algorithms for applying predicate filtering and others will be left to the server. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  QUERY_CACHE_TABLES </h4><br>  This view will display a list of all tables, the results of queries for which were cached, respectively, there will be only two columns in it: <br><div class="spoiler">  <b class="spoiler_title">schema name and table name</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_SCHEMA_NAME_LENGTH 127 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_TABLE_NAME_LENGTH 127 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COLUMN_SCHEMA_NAME 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COLUMN_TABLE_NAME 1 ST_FIELD_INFO query_cache_table_fields[]= { {</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SCHEMA_NAME"</span></span></span><span class="hljs-meta">, MAX_SCHEMA_NAME_LENGTH, MYSQL_TYPE_STRING, 0, 0, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Schema Name"</span></span></span><span class="hljs-meta">}, {</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"TABLE_NAME"</span></span></span><span class="hljs-meta">, MAX_TABLE_NAME_LENGTH, MYSQL_TYPE_STRING, 0, 0, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Table Name"</span></span></span><span class="hljs-meta">}, {0,0, MYSQL_TYPE_STRING, 0, 0, 0} };</span></span></code> </pre><br>  - by default, we will make the maximum length of these elements no more than 127 characters, I think this is reasonable <br></div></div><br><br><h4>  QUERY_CACHE_RESULTS </h4><br>  In the table containing SQL queries, as well as information on the result of their execution, we will add five columns: <br><div class="spoiler">  <b class="spoiler_title">SQL directly, number of lines in the response, as well as information about the memory used by the response</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_STATEMENT_TEXT_LENGTH 1024 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COLUMN_STATEMENT_TEXT 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COLUMN_FOUND_ROWS 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COLUMN_RESULT_BLOCKS_COUNT 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COLUMN_RESULT_BLOCKS_SIZE 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COLUMN_RESULT_BLOCKS_SIZE_USED 4 ST_FIELD_INFO query_cache_result_fields[]= { {</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"STATEMENT_TEXT"</span></span></span><span class="hljs-meta">, MAX_STATEMENT_TEXT_LENGTH,MYSQL_TYPE_STRING, 0, 0, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Cached statement text"</span></span></span><span class="hljs-meta">}, {</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FOUND_ROWS"</span></span></span><span class="hljs-meta">, 21, MYSQL_TYPE_LONGLONG, 0, 0, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Result row count"</span></span></span><span class="hljs-meta">}, {</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"RESULT_BLOCKS_COUNT"</span></span></span><span class="hljs-meta">, 21, MYSQL_TYPE_LONG, 0, 0, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Result Blocks count"</span></span></span><span class="hljs-meta">}, {</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"RESULT_BLOCKS_SIZE"</span></span></span><span class="hljs-meta">, 21, MYSQL_TYPE_LONGLONG, 0, 0,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Result Blocks size"</span></span></span><span class="hljs-meta">}, {</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"RESULT_BLOCKS_SIZE_USED"</span></span></span><span class="hljs-meta">, 21, MYSQL_TYPE_LONGLONG, 0, 0,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Result Blocks used size"</span></span></span><span class="hljs-meta">}, {0,0, MYSQL_TYPE_STRING, 0, 0, 0} };</span></span></code> </pre><br>  - the query text is artificially limited to 1024 characters, if necessary you can increase this parameter <br></div></div><br><br><h4>  We save data </h4><br>  After that, we proceed to the immediate filling of the table with data.  Wherever we store string values, you must specify an encoding. <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// character set information to store varchar values CHARSET_INFO *cs = system_charset_info;</span></span></code> </pre><br>  To access the <code>Query_cache::query_cache</code> you need <br><div class="spoiler">  <b class="spoiler_title">set the appropriate lock</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// query_cache defined in sql_cache.h is MySQL Query Cache implementation; MySQL_IS_Query_Cache *qc = (MySQL_IS_Query_Cache *)&amp;query_cache; HASH *h_queries; query_cache.lock(); h_queries = qc-&gt;get_queries_hash();</span></span></code> </pre><br>  - h_queries object we are looking for, by iterating which we will be able to access all queries from <code>QUERY CACHE</code> (in the figure <code>HASH queries</code> ) <br></div></div><br>  Access to the data structure of <code>HASH tables</code> can be obtained <br><div class="spoiler">  <b class="spoiler_title">the same way</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// query_cache defined in sql_cache.h is MySQL Query Cache implementation; MySQL_IS_Query_Cache *qc = (MySQL_IS_Query_Cache *)&amp;query_cache; HASH *h_tables; query_cache.lock(); h_tables = qc-&gt;get_tables_hash();</span></span></code> </pre></div></div><br>  Further with <code>HASH tables</code> everything is simple.  We iterate the resulting hash table and <br><div class="spoiler">  <b class="spoiler_title">save the elements we need</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; h_tables-&gt;records; i++) { query_cache_block_hash = my_hash_element(h_tables, i); query_cache_block_current = (Query_cache_block*)query_cache_block_hash; Query_cache_table* query_cache_table = query_cache_block_current-&gt;table(); <span class="hljs-comment"><span class="hljs-comment">// get tables data const char *schema_name = (const char*)query_cache_table-&gt;db(); size_t schema_name_length = strlen(schema_name)&gt;MAX_SCHEMA_NAME_LENGTH?MAX_SCHEMA_NAME_LENGTH:strlen(schema_name); is_query_cache_tables-&gt;field[COLUMN_SCHEMA_NAME]-&gt;store((char*)schema_name, schema_name_length, cs); ... }</span></span></code> </pre></div></div><br>  In case of errors when saving, as well as in the case of the regular end of the procedure, do not forget to unlock the <code>query_cache.unlock()</code> block.  This lock is global for the entire database instance; when it is installed, all other requests that apply to <code>QUERY CACHE</code> will wait for your plugin to finish. <br>  With the receipt of SQL queries, everything is a bit more complicated, and additional manipulations are required.  The block resulting from the iteration of the hash table does not contain the information we need.  It contains only a link to structures of type <code>Query_cache_query</code> , reaching which we will get only part of the information we need, namely <br><div class="spoiler">  <b class="spoiler_title">query text and number of records in the result set</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// get statement data statement_text = (const char*)query_cache_query-&gt;query(); ulonglong found_rows = query_cache_query-&gt;found_rows();</span></span></code> </pre></div></div><br>  Information about the amount of memory used for caching the results of this query is available through the <code>result</code> variable for the <code>query_cache_query</code> object.  This will be a link to <br><div class="spoiler">  <b class="spoiler_title">first memory area</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> Query_cache_block *first_result_block = query_cache_query-&gt;result();</code> </pre></div></div><br>  dedicated to storing its result.  In order to get information about all the allocated memory areas, you need to go through the linked list, which is cyclic and will eventually lead us to the first <code>Query_cache_block</code> block <code>Query_cache_block</code> .  It is also worth considering that the status of the block received as a result of this call may be unrelated to <code>Query_cache_block::RES_INCOMPLETE</code> . <br><div class="spoiler">  <b class="spoiler_title">Crawl result</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// loop all query result blocks for current query while( (result_block= result_block-&gt;next) != first_result_block &amp;&amp; result_block-&gt;type != Query_cache_block::RES_INCOMPLETE) /* This type of block can be not lincked yet (in multithread environment)*/ { result_blocks_count++; result_blocks_size += result_block-&gt;length; result_blocks_size_used += result_block-&gt;used; }</span></span></code> </pre><br>  - in fact, can we go to an unrelated block in such a way or not, I do not know, but it is better to err <br></div></div><br><div class="spoiler">  <b class="spoiler_title">We collect the server and enjoy the result</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">install</span></span> <span class="hljs-keyword"><span class="hljs-keyword">plugin</span></span> QUERY_CACHE_RESULTS <span class="hljs-keyword"><span class="hljs-keyword">soname</span></span> <span class="hljs-string"><span class="hljs-string">'query_cache_results.so'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> <span class="hljs-keyword"><span class="hljs-keyword">plugin</span></span> QUERY_CACHE_TABLES <span class="hljs-keyword"><span class="hljs-keyword">soname</span></span> <span class="hljs-string"><span class="hljs-string">'query_cache_tables.so'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> plugins; +<span class="hljs-comment"><span class="hljs-comment">--------------------------+--------+--------------------+------------------------+---------+ | Name | Status | Type | Library | License | +--------------------------+--------+--------------------+------------------------+---------+ ... | QUERY_CACHE_RESULTS | ACTIVE | INFORMATION SCHEMA | query_cache_results.so | GPL | | QUERY_CACHE_TABLES | ACTIVE | INFORMATION SCHEMA | query_cache_tables.so | GPL | +--------------------------+--------+--------------------+------------------------+---------+ 24 rows in set (0.00 sec) select * from pivot limit 10; ... 10 rows in set (0.00 sec) select * from pivot p1, pivot p2 limit 1000; ... 1000 rows in set (0.00 sec) select * from information_schema.query_cache_tables; +-------------+------------+ | SCHEMA_NAME | TABLE_NAME | +-------------+------------+ | test | pivot | +-------------+------------+ 1 row in set (0.00 sec) select * from information_schema.query_cache_results \G *************************** 1. row *************************** STATEMENT_TEXT: select * from pivot p1, pivot p2 limit 1000 FOUND_ROWS: 1000 RESULT_BLOCKS_COUNT: 1 RESULT_BLOCKS_SIZE: 9992 RESULT_BLOCKS_SIZE_USED: 9985 *************************** 2. row *************************** STATEMENT_TEXT: select * from pivot limit 10 FOUND_ROWS: 10 RESULT_BLOCKS_COUNT: 1 RESULT_BLOCKS_SIZE: 512 RESULT_BLOCKS_SIZE_USED: 208 2 rows in set (0.00 sec)</span></span></code> </pre></div></div><br><br>  PS Since I am a DB developer and writing C ++ code is not even my secondary specialty, the solution described can be quite crooked and non-optimal, for this reason I will be happy to hear your comments on the code in PM. <br><br>  PPS For self-assembly and experiments, I post the source of the plugin on github, following the advice of users in the comments: <a href="https://github.com/mcshadow/mysql_query_cache">github.com/mcshadow/mysql_query_cache</a> </div><p>Source: <a href="https://habr.com/ru/post/165241/">https://habr.com/ru/post/165241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../165227/index.html">PowerShell Web Access: Configuring</a></li>
<li><a href="../165231/index.html">Microsoft R & D office robbed, only iPad tablets stolen</a></li>
<li><a href="../165233/index.html">How to make a non-standard pop-up window when clicking on a label in iOS maps</a></li>
<li><a href="../165237/index.html">Guide to using Dependency Injection in symfony2</a></li>
<li><a href="../165239/index.html">Simple-Science - Simple Experiments (Digest # 13)</a></li>
<li><a href="../165243/index.html">Yet another python Chat client</a></li>
<li><a href="../165247/index.html">Android updates: why is Cyanogen so much faster than Google / OEMs?</a></li>
<li><a href="../165251/index.html">Programming on Android for a web developer or a quick start for the little ones. Part 2</a></li>
<li><a href="../165253/index.html">EU opens center on fighting cybercrime</a></li>
<li><a href="../165257/index.html">Confirmed certificates from Coursera</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>