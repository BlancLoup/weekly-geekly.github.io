<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RabbitMQ tutorial 6 - Remote procedure call</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In continuation of the fifth lesson in the study of the basics of RabbitMQ, I publish the translation of the sixth lesson from the official site . All...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RabbitMQ tutorial 6 - Remote procedure call</h1><div class="post__text post__text-html js-mediator-article">  In continuation of the <a href="http://habrahabr.ru/post/201178/">fifth lesson</a> in the study of the basics of RabbitMQ, I publish the translation of the sixth lesson from the <a href="http://www.rabbitmq.com/tutorials/tutorial-six-python.html">official site</a> .  All examples are written in python (pika version 0.9.8 is used), but still they can be implemented on most <a href="http://www.rabbitmq.com/devtools.html">popular PL</a> . <br><br>  In the <a href="http://habrahabr.ru/post/150134/">second lesson,</a> we looked at the use of task queues to distribute resource-intensive tasks among several subscribers. <br><br>  But what if we want to run a function on a remote machine and wait for the result?  Well, that's another story.  This pattern is commonly known as Remote Procedure Call or RPC, hereinafter referred to as RPC. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this guide, we will build using RabbitMQ, an RPC system that will include a client and a scalable RPC server.  Since we do not have a real time-consuming task requiring distribution, we will create a simple RPC server that returns Fibonacci numbers. <br><a name="habracut"></a><br><h4>  Client interface </h4><br>  To illustrate the use of the RPC service, create a simple client class.  This class will contain a <i>call</i> method that will send RPC requests and block until a response is received: <br><br><pre><code class="python hljs">fibonacci_rpc = FibonacciRpcClient() result = fibonacci_rpc.call(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"fib(4) is %r"</span></span> % (result,)</code> </pre> <br><blockquote><h5>  RPC Note </h5><br>  Although RPC is a fairly common pattern, it is often criticized.  Problems usually arise when the developer does not know exactly what function he is using: local or slow, performed by RPC.  Confusion, like this, can lead to unpredictable system behavior, and also introduces unnecessary complexity in the debugging process.  Thus, instead of simplifying software, incorrect use of RPC can lead to unattended and unreadable code. <br><br>  Based on the above, the following recommendations can be made: <br><ul><li>  Make sure that it is obvious which function is called in each case: local or remote; </li><li>  Document your system.  Make the dependencies between the components explicit; </li><li>  Handle errors.  How should the client respond if the RPC server does not respond within a long period of time? </li><li>  If in doubt, do not use RPC.  If possible, use an asynchronous pipeline instead of a blocking RPC when the results are asynchronously transferred to the next level of processing. </li></ul></blockquote><br><h4>  Results queue </h4><br>  In general, making RPC through RabbitMQ is easy.  The client sends the request and the server responds to the request.  To get a response, the client must submit a queue to post the results along with the request.  Let's see how it looks in code: <br><br><pre> <code class="python hljs">result = channel.queue_declare(exclusive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) callback_queue = result.method.queue channel.basic_publish(exchange=<span class="hljs-string"><span class="hljs-string">''</span></span>, routing_key=<span class="hljs-string"><span class="hljs-string">'rpc_queue'</span></span>, properties=pika.BasicProperties( reply_to = callback_queue, ), body=request) <span class="hljs-comment"><span class="hljs-comment"># ...-       callback_queue ...</span></span></code> </pre><br><h4>  Message Properties </h4><br>  The AMQP protocol has 14 predefined message properties.  Most of them are used extremely rarely, with the exception of the following: <br><br><ul><li>  <i>delivery_mode</i> : marks the message as ‚Äúpersistent‚Äù (with a value of 2) or ‚Äútemporary‚Äù (any other value).  You must remember this property in the <a href="http://habrahabr.ru/post/150134/">second lesson</a> ; </li><li>  <i>content_type</i> : used to describe the presentation format (mime).  For example, for frequently used JSON format, it is considered good practice to set this property in application / json; </li><li>  <i>reply_to</i> : usually used to specify a result queue; </li><li>  <i>correlation_id</i> : property used to match RPC responses with queries. </li></ul><br><br><h4>  Correlation id </h4><br>  In the method presented above, we suggested creating a response queue for each RPC request.  This is somewhat redundant, but, fortunately, there is a better way - let's create a common queue of results for each client. <br><br>  This raises a new question, getting an answer from this queue is not entirely clear to which query this answer corresponds.  And here the <i>correlation_id</i> property comes in handy.  We will assign this property a unique value with each request.  Later, when we retrieve the resulting response from the response queue, based on the value of this property, we will be able to uniquely match the request with the response.  If we meet an unknown value in the <i>correlation_id</i> property, we can safely ignore this message, since it does not match any of our requests. <br><br>  Could you ask why we plan to simply ignore unknown messages from the response queue instead of interrupting the script?  This is due to the likelihood of a race condition on the server side.  Although this is unlikely, a scenario is quite possible in which the RPC server will send us an answer, but will not have time to send a confirmation of the processing of the request.  If this happens, the restarted RPC server will process the request again.  That is why on the client we have to correctly handle duplicate responses.  In addition, RPC ideally should be idempotent. <br><br><h4>  Results </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/016/c2d/982/016c2d98222564716931fea17f8ea2be.png" alt="image"><br><br>  Our RPC will work as follows: <br><br>  - When the Client starts, it creates an anonymous, unique results queue; <br>  - To make an RPC request, the Client sends a message with two properties: <i>reply_to</i> , where the value is the result queue and the <i>correlation_id</i> set to a unique value for each request. <br>  - The request is sent to the <i>rpc_queue queue</i> ; <br>  - The server is waiting for requests from this queue.  When a request is received, the Server performs its task and sends a message with the result back to the Client using the queue from the <i>reply_to</i> property; <br>  - The client is waiting for the result from the results queue.  When a message is received, the Client checks the <i>correlation_id</i> property.  If it matches the value from the query, then the result is sent to the application. <br><br><h4>  Putting it all together </h4><br>  Server code rpc_server.py: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python import pika connection = pika.BlockingConnection(pika.ConnectionParameters( host='localhost')) channel = connection.channel() channel.queue_declare(queue='rpc_queue') def fib(n): if n == 0: return 0 elif n == 1: return 1 else: return fib(n-1) + fib(n-2) def on_request(ch, method, props, body): n = int(body) print " [.] fib(%s)" % (n,) response = fib(n) ch.basic_publish(exchange='', routing_key=props.reply_to, properties=pika.BasicProperties(correlation_id = \ props.correlation_id), body=str(response)) ch.basic_ack(delivery_tag = method.delivery_tag) channel.basic_qos(prefetch_count=1) channel.basic_consume(on_request, queue='rpc_queue') print " [x] Awaiting RPC requests" channel.start_consuming()</span></span></code> </pre><br><br>  Server code is pretty simple: <br><br><ul><li>  (4) As usual, we establish a connection and declare a queue; </li><li>  (11) We declare our function that returns Fibonacci numbers, which takes only positive integers as an argument (this function is unlikely to work with large numbers, most likely it is the slowest possible implementation); </li><li>  (19) We declare the <i>on_request</i> callback function for <i>basic_consume</i> , which is the core of the RPC server.  It is executed when the request is received.  After completing the work, the function sends the result back; </li><li>  (32) We will probably want to run more than one server someday.  To evenly distribute the load across multiple servers, we set up <i>prefetch_count</i> . </li></ul><br><br>  Client code rpc_client.py: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python import pika import uuid class FibonacciRpcClient(object): def __init__(self): self.connection = pika.BlockingConnection(pika.ConnectionParameters( host='localhost')) self.channel = self.connection.channel() result = self.channel.queue_declare(exclusive=True) self.callback_queue = result.method.queue self.channel.basic_consume(self.on_response, no_ack=True, queue=self.callback_queue) def on_response(self, ch, method, props, body): if self.corr_id == props.correlation_id: self.response = body def call(self, n): self.response = None self.corr_id = str(uuid.uuid4()) self.channel.basic_publish(exchange='', routing_key='rpc_queue', properties=pika.BasicProperties( reply_to = self.callback_queue, correlation_id = self.corr_id, ), body=str(n)) while self.response is None: self.connection.process_data_events() return int(self.response) fibonacci_rpc = FibonacciRpcClient() print " [x] Requesting fib(30)" response = fibonacci_rpc.call(30) print " [.] Got %r" % (response,)</span></span></code> </pre><br><br>  Client code is somewhat more complicated: <br><br><ul><li>  (7) We establish a connection, a channel, and declare a unique queue of results for the responses received; </li><li>  (16) We subscribe to the results queue to receive responses from the RPC; </li><li>  (18) The ' <i>on_response</i> ' callback function, executed when each response is received, performs a rather trivial task ‚Äî for each incoming reply, it checks whether the <i>correlation_id</i> matches what we expect.  If so, it stores the response in <i>self.response</i> and aborts the loop; </li><li>  (23) Next, we define our <i>call</i> method, which, in fact, performs an RPC request; </li><li>  (24) In this method, we first generate a unique <i>correlation_id</i> and save it ‚Äî the ' <i>on_response</i> ' callback function will use this value to track the desired response; </li><li>  (25) Next, we place the request with the properties <i>reply_to</i> and <i>correlation_id</i> into a queue; </li><li>  (32) Next, the process of waiting for a response begins; </li><li>  (33) And, at the end, we return the result back to the user. </li></ul><br><br>  Our RPC service is ready.  We can start the server: <br><br><pre> <code class="bash hljs">$ python rpc_server.py [x] Awaiting RPC requests</code> </pre><br>  To get Fibonacci numbers, run the Client: <br><br><pre> <code class="bash hljs">$ python rpc_client.py [x] Requesting fib(30)</code> </pre><br>  The presented RPC implementation is not the only one possible, but it has the following advantages: <br><br><ul><li>  If the RPC server is too slow, you can easily add one more.  Try running the second rpc_server.py in a new console; </li><li>  On the client side, RPC requires sending and receiving only one message.  No synchronous call to <i>queue_declare is required</i> .  As a result, an RPC client costs one request-response cycle for one RPC request. </li></ul><br><br>  Our code, however, is simplified and does not even try to solve more complex (but certainly important) problems like these: <br><br><ul><li>  How should the Client react if the server is not running? </li><li>  Should the client have a timeout for RPC? </li><li>  If the Server at some point ‚Äúbreaks down‚Äù and throws an exception, should it be transferred to the Client? </li><li>  Protection against invalid incoming messages (for example, checking the permissible limits) before processing. </li></ul><br><br><h4>  All guide articles </h4><br>  <a href="http://habrahabr.ru/post/149694/">RabbitMQ tutorial 1 - Hello World</a> (python) <br>  <a href="http://habrahabr.ru/post/150134/">RabbitMQ tutorial 2 - Task Queue</a> (python) <br>  <a href="http://habrahabr.ru/post/200870/">RabbitMQ tutorial 3 - Publish / Subscribe</a> (php) <br>  <a href="http://habrahabr.ru/post/201096/">RabbitMQ tutorial 4 - Routing</a> (php) <br>  <a href="http://habrahabr.ru/post/201178/">RabbitMQ tutorial 5 - Topics</a> (php) <br>  RabbitMQ tutorial 6 - Remote procedure call (this article, python) </div><p>Source: <a href="https://habr.com/ru/post/236221/">https://habr.com/ru/post/236221/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../236213/index.html">A pair of crutches for Notepad ++ Arduino IDE (for Dummies)</a></li>
<li><a href="../236215/index.html">In an hour, you hold a webinar: Google Hangouts on Air</a></li>
<li><a href="../236217/index.html">Data center at home</a></li>
<li><a href="../236219/index.html">30 useful services for web developers and designers v2</a></li>
<li><a href="../23622/index.html">Pro guest</a></li>
<li><a href="../236223/index.html">[Translation] Cross-Storage: Make local data available between domains</a></li>
<li><a href="../236227/index.html">We will help with engineering analysis and calculations</a></li>
<li><a href="../236229/index.html">NASA completed construction of the first Orion reusable spacecraft module</a></li>
<li><a href="../23623/index.html">Leperosarium - myth check</a></li>
<li><a href="../236231/index.html">Gigabit L3 Switch with PoE for $ 480 - simple and straightforward</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>