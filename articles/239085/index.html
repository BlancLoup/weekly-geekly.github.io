<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Such a different Blur</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I'll tell you about the different implementations of the blur effect on GLSL. 

 To begin with, I want to warn you right away - I have set restriction...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Such a different Blur</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b7c/089/bf3/b7c089bf3b7e40bc8de36c605b2b3e4a.png"><br><br>  I'll tell you about the different implementations of the blur effect on GLSL. <br><a name="habracut"></a><br>  To begin with, I want to warn you right away - I have set restrictions for myself to use the GLSL version no higher than 1.1.  This is necessary in order for the application to work on as many devices and systems as possible.  So, for example, I had at my disposal an iMac with a Radeon HD 6750M and the most supported version of GLSL 1.2, a laptop with Kubuntu on intel hd 4000 with version GLSL 1.3 and a desktop with GeForce gtx560. <br>  I will try to describe the effects in simple words and without complicated formulas, the main goal is to give examples of blurring methods.  The article is a preparatory to the next two articles. <br><br><h4>  Gaussian blur </h4><br>  Consider the classic Gaussian blur.  Where just about him was not written, perhaps this is the most popular way to blur gamedev and not only.  But I can not not consider it, at least in brief. <br>  What is a blur in general?  Roughly speaking, this is the averaging of neighboring pixels, that is, considering the current pixel, we find the average color of all its neighbors in a certain radius.  But if you use a simple arithmetic average (uniform distribution), then the blur will not be very beautiful.  Therefore, it is common to multiply neighbors by coefficients, the values ‚Äã‚Äãof which obey the normal distribution law (it is the Gauss distribution, hence the name blur). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/976/7a6/b7d/9767a6b7d92d4901be8485c412da38bb.png"><img src="https://habrastorage.org/files/a23/a98/f5f/a23a98f5f40c43efaf4b6a2d0f4bbd4e.png"><br>  <i>blur with a uniform and normal distribution, respectively</i> <br><br>  Gaussian blur has one important property - separability.  This makes it possible to divide the algorithm into two parts - a blur along the x coordinate and a blur along y.  Thus, the coefficients do not need to be calculated for all neighbors, it suffices to find for one column or row.  The coefficients can be found by the <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B0%25D1%2583%25D1%2581%25D1%2581%25D0%25BE%25D0%25B2%25D0%25B0_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">Gauss</a> formula: <br><img src="https://habrastorage.org/getpro/habr/post_images/678/856/4cc/6788564ccfa581c12997f21079b9312b.png" alt="image">  , <br>  where Œº is the mathematical expectation, and œÉ is the variance. <br><br>  The implementation of such a blur is quite simple, we need two buffers of the same format and a pre-calculated array of blur coefficients: <br><ol><li>  Render the scene to the first buffer </li><li>  Render the image to the second buffer with a vertical shading blur </li><li>  Render again to the first horizontal blur </li></ol><div class="spoiler">  <b class="spoiler_title">Shaders</b> <div class="spoiler_text">  Vertex: <pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 110 attribute vec2 vertex; attribute vec2 texCoord; varying vec2 vTexCoord; void main() { gl_Position = vec4(vertex, 0.0, 1.0); vTexCoord = texCoord; }</span></span></code> </pre> <br>  Fragment: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 110 const int MAX_KOEFF_SIZE = 32; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   ( ) uniform sampler2D texture; //  uniform int kSize; //  uniform float koeff[MAX_KOEFF_SIZE]; // uniform vec2 direction; //       aspect ratio,  (0.003, 0.0) -   (0.0, 0.002) -  varying vec2 vTexCoord; //    void main() { vec4 sum = vec4(0.0); //  vec2 startDir = -0.5*direction*float(kSize-1); //    for (int i=0; i&lt;kSize; i++) //    sum += texture2D(texture, vTexCoord + startDir + direction*float(i)) * koeff[i]; //  gl_FragColor = sum; }</span></span></span></span></code> </pre></div></div><br><br><h4>  Bokeh effect </h4><br>  Actually, this is the main reason for writing this article - I wanted to tell you how easy it is to get <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25BE%25D0%25BA%25D0%25B5">this effect</a> .  The algorithm is similar to the previous one, but there are differences: <br><ul><li>  The normal distribution law can be replaced by a uniform </li><li>  Another third pass is added. </li><li>  Blur now occurs not vertically and horizontally, but along three vectors, the angle between which is 120 ¬∞ </li><li>  In addition to the amount of color, the shader also contains the maximum color for all samples, after which both colors are mixed in a given proportion </li></ul><div class="spoiler">  <b class="spoiler_title">Shader</b> <div class="spoiler_text">  Vertex remains the same, fragmentary: <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 110 uniform sampler2D texture; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  uniform vec2 direction; // ,   : (0, 1), (0.866/aspect, 0.5), (0.866/aspect, -0.5),          uniform float samples; // , float -        uniform float bokeh; //   [0..1] varying vec2 vTexCoord; //    void main() { vec4 sum = vec4(0.0); //  vec4 msum = vec4(0.0); //    float delta = 1.0/samples; //     float di = 1.0/(samples-1.0); //  for (float i=-0.5; i&lt;0.501; i+=di) { vec4 color = texture2D(texture, vTexCoord + direction * i); //     sum += color * delta; //  msum = max(color, msum); //    } gl_FragColor = mix(sum, msum, bokeh); //        }</span></span></span></span></code> </pre></div></div><br> <a href=""><img src="https://habrastorage.org/files/2fa/f27/75b/2faf2775b0a94d2fa53946bfdec1d8cf.png"></a> <br>  <i>blur with different bokeh ratio: 0.2, 0.5, 0.8 (the image is clickable)</i> <br><br>  Experimentally, I found out that the best mixing ratio, providing a more or less beautiful effect close to the real one, is 0.5. <br>  Disadvantages of this method: <br><ul><li>  One draw call has more and about a third more samples than the previous method. </li><li>  Bokeh shape - only regular polygons with an even number of angles </li><li>  Cannot be applied in the blur depth algorithm. </li></ul><br><br>  There are several other ways to make this effect, here's one of them: we pass through the texture with a special shader, in which we reveal the most contrasting places and write their coordinates into the buffer, then blur the texture in any way without the bokeh effect, after which we render the sprites directly on top of it in the coordinates found in the first step.  The advantages of this method - the shape of the bokeh can be of any shape, of the drawbacks - we need geometric shaders, which eliminates weak devices, and you can‚Äôt draw on each pixel of the bokeh - we get a wild fill rate. <br><br><h4>  Depth Blur </h4><br>  The full name of the effect is the depth of the sharply depicted space, or DoF (Depth Of Field).  The name speaks for itself - everything that is in focus - clearly, out of focus - is blurry.  At first glance, the effect seems simple, but there are moments that complicate it both in terms of the cost of resources and in terms of implementation.  One of its drawbacks is that it is impossible to apply previous approaches, due to the fact that it does not have the property of separability, and therefore it cannot be divided into several passes (blurring vertically and horizontally).  Sometimes you can cheat: first render the background and blur it, then front without blur.  Of course it will not be a full effect, but there will be a feeling of blur in depth.  But if the scene is filled with objects across the depth, you will have to blur it in a more ‚Äúhonest‚Äù way.  But completely honest methods are usually not used - there are too many samples, therefore, as a rule, a small cloud of points is taken as samples within a certain radius from the considered one.  The most optimal distribution of such points is called the Poisson disk - it is distinguished from the completely random distribution of points by the fact that the points are approximately equal distance from each other.  There are many ways to get a Poisson disk, I use this one for myself: <br><ul><li>  let r be the radius of the disk, then the upper boundary of the disk is yMax = r, and the lower limit is yMin = -r. </li><li>  in the yR loop from yMin to yMax, do the following: </li><li>  find xMax = cos (asin (yR / r)) * r and xMin = -xMax. </li><li>  in a nested loop with xR from xMin to xMax, we find a point with coordinates (xR, yR). </li><li>  then we will shift the coordinates of this point by a random variable from -r / 4 to r / 4 </li><li>  the points thus obtained are the sought ones. </li></ul>  What is this algorithm?  We simply roughly divide the circle with a grid and go line by line along the nodes of this grid from left to right from top to bottom.  The coordinates of these nodes are randomly slightly shifted and we get the desired Poisson disk. <br>  In fact, this is not exactly a Poisson disk, but it is very similar to it, compare yourself (on the left is my implementation, on the right is the points generated by <a href="http://www.jasondavies.com/poisson-disc/">this</a> algorithm) <br><img src="https://habrastorage.org/files/3f6/54c/cab/3f654ccabb3b4345a4f0c33c54818637.png"><br><div class="spoiler">  <b class="spoiler_title">C ++ implementation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> yMax = r; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> yMin = -r; yMin += <span class="hljs-built_in"><span class="hljs-built_in">fmod</span></span>(yMax-yMin, <span class="hljs-number"><span class="hljs-number">1</span></span>)/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y=yMin; y&lt;yMax; y++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">asin</span></span>(y/r))*r; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMin = -xMax; xMin += <span class="hljs-built_in"><span class="hljs-built_in">fmod</span></span>(xMax-xMin, <span class="hljs-number"><span class="hljs-number">1</span></span>)/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x=xMin; x&lt;xMax; x++) points.append(QPoint(x+floatRand(-r/<span class="hljs-number"><span class="hljs-number">4</span></span>, r/<span class="hljs-number"><span class="hljs-number">4</span></span>), y+floatRand(-r/<span class="hljs-number"><span class="hljs-number">4</span></span>, r/<span class="hljs-number"><span class="hljs-number">4</span></span>))); }</code> </pre> </div></div><br>  There are a lot of points in the pictures above, in fact, about 10-20 are enough.  Once the points are obtained, they can be sampled.  But first, let's talk about the power of blur. <br>  Information about the strength of the blur for each pixel will be stored in the alpha channel.  The strength of the blur varies from -1 to 1, where one is the maximum blur, zero - no blur.  I used HDR texture (RGBA16F), but this information can be encoded into an ordinary 8-bit alpha channel: <br><br>  a = depth * 0.5 + 0.5 - coding <br>  a = depth * 2.0-1.0 - decoding, where depth is the blur power [-1..1] <br><br>  The depth parameter (blur power) can be calculated using the formula: (focalDistance + zPos) / focalRange, where focalDistance is the focal length, focalRange is the range or depth of the blur.  Negativeness of the depth value indicates that the current object or fragment is in front of the focus, if depth is positive, then it is beyond the focus.  By the way, in fact, it is not necessary to store a sign, it will double the range of values ‚Äã‚Äã(it can be critical for an 8-bit texture), but it will be impossible to understand in the shader if there is a fragment in front of or behind the focus - because of this artifacts may occur. <br><br>  So, by making a sample using the Poisson disc, we get information about the color of the pixel and how hard it is to blur it.  Remember the sample rates in the two previous algorithms?  So, now in the role of these coefficients is the power of blurring (of course modulo).  The blur power also affects the blur radius of the current fragment.  You should also talk about the parasitic effect arising in the current implementation - if the depth limit is sharp (transition between far and near objects), then something like a moir√© or halo can be observed between them, in this case we simply adjust the coefficient. <br><br>  As an additional improvement of the algorithm, you can use the second texture - smaller and slightly blurred.  This will reduce the number of samples and improve the quality of the blur. <br><br>  Thanks <a href="http://habrahabr.ru/users/chaos_optima/" class="user_link">Chaos_Optima</a> , I forgot to write about the lack of this method: it appears on the borders of nearby objects, when they begin to blur, their borders remain sharp. <br><div class="spoiler">  <b class="spoiler_title">Shader</b> <div class="spoiler_text">  In a fragmentary scene render shader: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blur = clamp((focalDistance+zPos)/focalRange, <span class="hljs-number"><span class="hljs-number">-1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); gl_FragColor = vec4(color, blur);</code> </pre> <br>  The vertex blur shader is the same as in the previous methods, fragmentary: <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 110 const int MAX_OFFSET_SIZE = 128; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      uniform sampler2D texture; //     uniform sampler2D lowTexture; //       uniform int offsetSize; //      uniform vec2 offsets[MAX_OFFSET_SIZE]; //   varying vec2 vTexCoord; //    void main() { float currentSize = texture2D(texture, vTexCoord).a; //    vec4 resulColor = vec4 (0.0); //  for (int i=0; i&lt;offsetSize; i++) { vec4 highSample = texture2D(texture, vTexCoord+offsets[i]*currentSize); //  vec4 lowSample = texture2D(lowTexture, vTexCoord+offsets[i]*currentSize); float sampleSize = abs(highSample.a);//     highSample.rgb = mix(highSample.rgb, lowSample.rgb, sampleSize); //          highSample.a = highSample.a &gt;= currentSize ? 1.0 : highSample.a; //  (,       ) sampleSize = abs(highSample.a); resultColor.rgb += highSample.rgb * sampleSize; //  resultColor.a += sampleSize; //   } gl_FragColor = resultColor/resultColor.a; }</span></span></span></span></code> </pre></div></div><br><img src="https://habrastorage.org/files/746/beb/329/746beb3290ed4aa6b22b1e5940e54e83.png"><br>  <i>the result of the shader is a blurry stick</i> <br><br><h4>  Links </h4><br><ul><li>  <a href="http://encelo.netsons.org/2008/04/15/depth-of-field-reloaded/">encelo.netsons.org/2008/04/15/depth-of-field-reloaded</a> - one of the ways to make DoF </li><li>  <a href="http://www.gamedev.net/topic/563149-real-time-bokeh-high-quality-dof/">www.gamedev.net/topic/563149-real-time-bokeh-high-quality-dof</a> - I realized that I had invented another bicycle after I came across this page and read the last post. </li><li>  <a href="http://steps3d.narod.ru/tutorials/depth-of-field-tutorial.html">steps3d.narod.ru/tutorials/depth-of-field-tutorial.html</a> - implementation of the Dof </li><li>  <a href="http://www.jasondavies.com/poisson-disc/">www.jasondavies.com/poisson-disc</a> - how to generate a Poisson disk </li><li>  <a href="http://openglinsights.com/">openglinsights.com</a> - this book covers the implementation of DoF with the bokeh effect on GLSL 4.2 </li></ul></div><p>Source: <a href="https://habr.com/ru/post/239085/">https://habr.com/ru/post/239085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../239073/index.html">My java library implementation for the BTC-e exchange</a></li>
<li><a href="../239077/index.html">Windows 10: new features and functions in the command line</a></li>
<li><a href="../239079/index.html">Installing Laravel 5 on Windows XP, creating a project and deploying a project on Heroku</a></li>
<li><a href="../239081/index.html">Parsim in Python: Pyparsing for beginners</a></li>
<li><a href="../239083/index.html">Gingerbread for the people. Legal foundation for free culture and science</a></li>
<li><a href="../239087/index.html">Golf from Moscow.pm for everyone</a></li>
<li><a href="../239089/index.html">We get into the computer without using input tools, look for the Joker and connect to the server on Android - in tasks NeoQUEST-2014!</a></li>
<li><a href="../239093/index.html">Native segue from left to right in iOS</a></li>
<li><a href="../239097/index.html">IB in American. Part 4. We deal with the "fit" and "overlap" and complete this review.</a></li>
<li><a href="../239103/index.html">Ciklum Android Practice Leaders Meet-Up // Groovy on Android, Dnepropetrovsk, October 9</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>