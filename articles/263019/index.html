<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Web application for generating photo mosaic with lightweight threads on Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a translation of Sau Shon Chang‚Äôs blog post. In the first half, his approach to creating photo mosaic on Go is described, and in the second ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Web application for generating photo mosaic with lightweight threads on Go</h1><div class="post__text post__text-html js-mediator-article">  <i>This is a translation of Sau Shon Chang‚Äôs blog post.</i>  <i>In the first half, his approach to creating photo mosaic on Go is described, and in the second half, the program is accelerated by adding competition (channels, gorutiny).</i> <i><br></i>  <i>For inaccuracies of the translation, write in lichku.</i> <br><br>  A few months ago, my good friend <a href="https://twitter.com/indianguru">Satish Talim</a> suggested a great idea - to create several competitions on Go to pump Go programmers' skills.  The idea of ‚Äã‚Äãthe project is to come up with a programming task every month (or so), which will be a fresh and interesting challenge for the Go community.  The winners will receive prizes, but more importantly, this is an attempt to help each other and myself in particular.  Satish asked me to come up with a task and I came up with it with pleasure for the <a href="http://golang-challenge.com/go-challenge3/">third competition</a> (challenge # 3). <br><br>  Being a web application programmer for most of my career, it was a natural thought to come up with a web application competition.  And recently on the hackathon, <a href="https://developer.yahoo.com/blogs/ydn/creating-photo-mosaics-yahoo-boss-image-search-7453.html">I wrote a script on Ruby for generating mosaic</a> , so I thought to combine these ideas together in the task of creating a web application for generating photo mosaic. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/bc3/3df/49c/bc33df49c36546acac8155694b2ef4f5.png"><br><a name="habracut"></a><br>  Honestly, at the time of publishing the task, my web application was not written yet.  I started writing it after the competition was over.  Writing a photo application for photo mosaic took me about two days.  But it was not finished, because I wanted to go further and add competitiveness to Go to speed up the program.  This blog post is the result of what I did. <br><br>  All code from this post can be found at <a href="https://github.com/sausheong/mosaic">github.com/sausheong/mosaic</a> .  I note that the code on the githaba is slightly different from what is presented below. <br><br>  The demo can be viewed at <a href="http://mosaic.saush.com/">mosaic.saush.com</a> .  <i>(Approx. Trans. - do not frighten the application with large pictures, the server is weak, so it willingly falls even with pictures in 4 MB).</i>  It is hosted on Digital Ocean using Docker via Tutum.  The performance of the demo on the server is not as high as in this post, because it uses only 1 CPU VM and 512 MB. <br><br><h1>  Create photomosaic. </h1><br>  Photographic mosaics or photo mosaic is a picture (usually a photograph), which was divided into rectangular sections (usually of the same size), each of which is replaced by a new picture.  If you look from afar or squint, then you can see the original picture.  And if you look closer, we will see that the big picture actually consists of hundreds or even thousands of small tiles-pictures. <br><br>  The basic idea is simple - the web application allows the user to upload the necessary image, on the basis of which a mosaic will be generated.  To make it easier, I assumed that the images are preloaded in the directory and have the desired size. <br><br>  Let's start with the algorithm for photo mosaic.  A web application consists of simple steps and can be written without the use of third-party libraries. <br><br><ol><li>  Create a database of images, hash tiles, scanning the directory with images.  Then we create a display, where the file name is the key, and the average color of the image is the value.  The average color value is calculated for a tuple of 3 elements: red, green, blue (RGB), - for each pixel and adds the values ‚Äã‚Äãof all red, green and blue pixels divided by the total number of pixels.  <i>(Note: the author uses the term tuple, but Go has no tuples per se, and arrays are very similar in properties. Not to be confused with slices).</i> </li><li>  Cut the target image into small tiles of the desired size. </li><li>  For each section of the target image, we calculate the average color of the upper left pixel and assume that this is the average color of the entire section. </li><li>  We are looking for a suitable tile from the database of tiles, which best of all coincides with the average color of the corresponding section of the target image, and place it at a suitable place in photomazyk.  To find the best match, we calculate the Euclidean distance between two colors [3] of the tuple by converting each color [3] of the tuple to a point in three-dimensional space. </li><li>  Delete the found tiles from the database so that the remaining tiles remain unique. </li></ol><br>  I placed all the written code for creating a mosaic in a single file mosaic.go.  Let's get acquainted with each function from this file. <br><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//     func averageColor(img image.Image) [3]float64 { bounds := img.Bounds() r, g, b := 0.0, 0.0, 0.0 for y := bounds.Min.Y; y &lt; bounds.Max.Y; y++ { for x := bounds.Min.X; x &lt; bounds.Max.X; x++ { r1, g1, b1, _ := img.At(x, y).RGBA() r, g, b = r+float64(r1), g+float64(g1), b+float64(b1) } } totalPixels := float64(bounds.Max.X * bounds.Max.Y) return [3]float64{r / totalPixels, g / totalPixels, b / totalPixels} }</span></span></code> </pre> <br>  We start with the <b>averageColor</b> function, which calculates the values ‚Äã‚Äãof all the red, green and blue pixels of the image, then sums them (separately) and divides each sum of values ‚Äã‚Äãby the total number of pixels of the image.  Then we return [3] a tuple (actually an array of 3 elements) consisting of these values. <br><br>  Next, look at the function to reduce the image ( <b>resize</b> ) <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//       newWidth func resize(in image.Image, newWidth int) image.NRGBA { bounds := in.Bounds() width := bounds.Max.X - bounds.Min.X ratio := width / newWidth out := image.NewNRGBA(image.Rect(bounds.Min.X/ratio, bounds.Min.X/ratio, bounds.Max.X/ratio, bounds.Max.Y/ratio)) for y, j := bounds.Min.Y, bounds.Min.Y; y &lt; bounds.Max.Y; y, j = y+ratio, j+1 { for x, i := bounds.Min.X, bounds.Min.X; x &lt; bounds.Max.X; x, i = x+ratio, i+1 { r, g, b, a := in.At(x, y).RGBA() out.SetNRGBA(i, j, color.NRGBA{uint8(r), uint8(g), uint8(b), uint8(a)}) } } return *out }</span></span></code> </pre><br>  The <b>tilesDB</b> function creates a database of images by scanning the image directory. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//  tilesDB   func tilesDB() map[string][3]float64 { fmt.Println("Start populating tiles db ...") db := make(map[string][3]float64) files, _ := ioutil.ReadDir("tiles") for _, f := range files { name := "tiles/" + f.Name() file, err := os.Open(name) if err == nil { img, _, err := image.Decode(file) if err == nil { db[name] = averageColor(img) } else { fmt.Println(":", err, name) } } else { fmt.Println("cannot open file", name, err) } file.Close() } fmt.Println("Finished populating tiles db.") return db }</span></span></code> </pre><br>  The tile database is a display with a string in the key and [3] a tuple (in this case, an array of three elements) in the value.  I open each image file in the directory and calculate the average color of the image to fill in the display value data.  The tile database is used to search for a suitable tile in the image directory.  It is passed to the nearest function, along with the target color value [3] of the tuple. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//      func nearest(target [3]float64, db *map[string][3]float64) string { var filename string smallest := 1000000.0 for k, v := range *db { dist := distance(target, v) if dist &lt; smallest { filename, smallest = k, dist } } delete(*db, filename) return filename }</span></span></code> </pre><br>  Each value in the database is compared with the target colors, then the value with the smallest difference is returned as the most suitable tile.  The value found is removed from the database.  The <b>distance</b> function calculates the Euclidean distance between two [3] tuples. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//       func distance(p1 [3]float64, p2 [3]float64) float64 { return math.Sqrt(sq(p2[0]-p1[0]) + sq(p2[1]-p1[1]) + sq(p2[2]-p1[2])) } //   func sq(n float64) float64 { return n * n }</span></span></code> </pre><br>  Finally, scanning and loading a database of tiles when creating each photo mosaic will look awkward.  I want to do this only once, and then clone this database when creating a photo mosaic.  The initial tile database <b>TILESDB</b> is created as a global variable and is declared at the beginning of the web application. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> TILESDB <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>][<span class="hljs-number"><span class="hljs-number">3</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> <span class="hljs-comment"><span class="hljs-comment">//         func cloneTilesDB() map[string][3]float64 { db := make(map[string][3]float64) for k, v := range TILESDB { db[k] = v } return db }</span></span></code> </pre><br><h1>  Web application photo mosaic </h1><br>  After preparing the functions for generating photo mosaics, you can start writing my web application.  The web application will be in the source file named <b>main.go.</b> <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"html/template"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"bytes"</span></span> <span class="hljs-string"><span class="hljs-string">"encoding/base64"</span></span> <span class="hljs-string"><span class="hljs-string">"image"</span></span> <span class="hljs-string"><span class="hljs-string">"image/draw"</span></span> <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() files := http.FileServer(http.Dir(<span class="hljs-string"><span class="hljs-string">"public"</span></span>)) mux.Handle(<span class="hljs-string"><span class="hljs-string">"/static/"</span></span>, http.StripPrefix(<span class="hljs-string"><span class="hljs-string">"/static/"</span></span>, files)) mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, upload) mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/mosaic "</span></span>, mosaic) server := &amp;http.Server{ Addr: <span class="hljs-string"><span class="hljs-string">"127.0.0.1:8080"</span></span>, Handler: mux, } <span class="hljs-comment"><span class="hljs-comment">//     TILESDB = tilesDB() fmt.Println("Mosaic server started.") server.ListenAndServe() } //    func upload(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles("upload.html") t.Execute(w, nil) } // HandlerFunc mosaic       func mosaic(w http.ResponseWriter, r *http.Request) { t0 := time.Now() //    POST  r.ParseMultipartForm(10485760) // max body in memory is 10MB file, _, _ := r.FormFile("image") defer file.Close() tileSize, _ := strconv.Atoi(r.FormValue("tile_size")) //      original, _, _ := image.Decode(file) bounds := original.Bounds() //      newimage := image.NewNRGBA(image.Rect(bounds.Min.X, bounds.Min.Y, bounds.Max.X, bounds.Max.Y)) //    db := cloneTilesDB() // source point       0, 0    sp := image.Point{0, 0} for y := bounds.Min.Y; y &lt; bounds.Max.Y; y = y + tileSize { for x := bounds.Min.X; x &lt; bounds.Max.X; x = x + tileSize { //        r, g, b, _ := original.At(x, y).RGBA() color := [3]float64{float64(r), float64(g), float64(b)} //      nearest := nearest(color, &amp;db) file, err := os.Open(nearest) if err == nil { img, _, err := image.Decode(file) if err == nil { //       t := resize(img, tileSize) tile := t.SubImage(t.Bounds()) tileBounds := image.Rect(x, y, x+tileSize, y+tileSize) //     draw.Draw(newimage, tileBounds, tile, sp, draw.Src) } else { fmt.Println("error:", err, nearest) } } else { fmt.Println("error:", nearest) } file.Close() } } buf1 := new(bytes.Buffer) jpeg.Encode(buf1, original, nil) originalStr := base64.StdEncoding.EncodeToString(buf1.Bytes()) buf2 := new(bytes.Buffer) jpeg.Encode(buf2, newimage, nil) mosaic := base64.StdEncoding.EncodeToString(buf2.Bytes()) t1 := time.Now() images := map[string]string{ "original": originalStr, "mosaic": mosaic, "duration": fmt.Sprintf("%v ", t1.Sub(t0)), } t, _ := template.ParseFiles("results.html") t.Execute(w, images) }</span></span></code> </pre><br>  The basic logic of creating photo <b>mosaic</b> is described in the <b>mosaic</b> function which is a handler.  First I get the downloaded file and the size of the tiles from the form. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    POST  r.ParseMultipartForm(10485760) //   10  file, _, _ := r.FormFile("image") defer file.Close() tileSize, _ := strconv.Atoi(r.FormValue("tile_size"))</span></span></code> </pre><br>  Next, I decode the downloaded target image and create a new image for photo mosaic. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//      original, _, _ := image.Decode(file) bounds := original.Bounds() //      newimage := image.NewNRGBA(image.Rect(bounds.Min.X, bounds.Min.Y, bounds.Max.X, bounds.Max.Y))</span></span></code> </pre><br>  I also clone the initial database of tiles and determine the initial points of each tile (needed further for the <a href="http://golang.org/pkg/image/draw/">image / draw</a> package) <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    db := cloneTilesDB() // source point       0, 0    sp := image.Point{0, 0}</span></span></code> </pre><br>  Now we are ready to iterate over all the tiles of the selected size in the target image. <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y := bounds.Min.Y; y &lt; bounds.Max.Y; y = y + tileSize { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x := bounds.Min.X; x &lt; bounds.Max.X; x = x + tileSize { <span class="hljs-comment"><span class="hljs-comment">//        r, g, b, _ := original.At(x, y).RGBA() color := [3]float64{float64(r), float64(g), float64(b)} //      nearest := nearest(color, &amp;db) file, err := os.Open(nearest) if err == nil { img, _, err := image.Decode(file) if err == nil { //       t := resize(img, tileSize) tile := t.SubImage(t.Bounds()) tileBounds := image.Rect(x, y, x+tileSize, y+tileSize) //     draw.Draw(newimage, tileBounds, tile, sp, draw.Src) } else { fmt.Println("error:", err, nearest) } } else { fmt.Println("error:", nearest) } file.Close() } }</span></span></code> </pre><br>  For each section, select the upper left pixel and decide that this is the average color of the section.  Further we look for the tile most suitable for color in a DB.  Tiled DB gives the name of the file, the size of which we change to the specified.  The resulting tile is placed in the mosaic (newimage) created earlier. <br><br>  After the photo mosaic is created, I will re-encode it in JPEG format, and then re-encode it into base64 string. <br><br><pre> <code class="go hljs">buf1 := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(bytes.Buffer) jpeg.Encode(buf1, original, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) originalStr := base64.StdEncoding.EncodeToString(buf1.Bytes()) buf2 := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(bytes.Buffer) jpeg.Encode(buf2, newimage, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) mosaic := base64.StdEncoding.EncodeToString(buf2.Bytes()) t1 := time.Now() images := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{ <span class="hljs-string"><span class="hljs-string">"original"</span></span>: originalStr, <span class="hljs-string"><span class="hljs-string">"mosaic"</span></span>: mosaic, <span class="hljs-string"><span class="hljs-string">"duration"</span></span>: fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%v "</span></span>, t1.Sub(t0)), } t, _ := template.ParseFiles(<span class="hljs-string"><span class="hljs-string">"results.html"</span></span>) t.Execute(w, images)</code> </pre><br>  The original target image and photo mosaic are sent to the <b>results.html</b> template for display on the next page.  As you can see, the picture is displayed in the data URL as embedded base64 content directly on the web page. <br><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">http-equiv</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Content-Type"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/html; charset=utf-8"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>Mosaic<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'container'</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"col-md-6"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"data:image/jpg;base64,{{ .original }}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"100%"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"lead"</span></span></span><span class="hljs-tag">&gt;</span></span>Original<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"col-md-6"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"data:image/jpg;base64,{{ .mosaic }}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"100%"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"lead"</span></span></span><span class="hljs-tag">&gt;</span></span>Mosaic ‚Äì {{ .duration }} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"col-md-12 center"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"btn btn-lg btn-info"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/"</span></span></span><span class="hljs-tag">&gt;</span></span>Go Back<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">br</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Screenshot of the created mosaic: <br><img src="https://habrastorage.org/files/182/00c/889/18200c889c124d12a7546183b8e9d466.png"><br>  <i>Basic photomosaic</i> <br><br>  Now that we have a basic web application for generating photo mosaic, let's add a version with lightweight streams and simultaneous execution of functions. <br><br><h1>  Competitive web application photo mosaic </h1><br>  One of the most frequent tasks in using competitiveness is improving performance.  The web application I wrote creates a photo mosaic from a 151 KB JPEG image in 2.25 seconds.  The speed does not hit and can definitely be improved by adding lightweight streams.  In this example, I will use a fairly simple algorithm for simultaneous execution of gorutin. <br><br><ol><li>  We divide the original image into 4 parts </li><li>  We process them simultaneously </li><li>  We combine the result back into one mosaic </li></ol><br>  This can be represented in this form: <br><img src="https://habrastorage.org/files/bf2/ff9/4e8/bf2ff94e871d4bc6aeaf817e4d3882f6.png"><br>  <i>Competitive algorithm</i> <br><br>  I note that this is not the only way to improve performance using lightweight streams, but it is the only simple and direct way. <br><br>  The only function that we will change is the <b>mosaic</b> handler.  Previously, we had the only handler for creating photo mosaic.  In the competitive version of the web application, photo mosaic needs to be divided into two new functions that will divide ( <b>cut</b> ) and combine ( <b>combine</b> ) a picture.  We will call <b>cut</b> and <b>combine</b> from the <b>mosaic</b> function. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mosaic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { t0 := time.Now() r.ParseMultipartForm(<span class="hljs-number"><span class="hljs-number">10485760</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   10  file, _, _ := r.FormFile("image") defer file.Close() tileSize, _ := strconv.Atoi(r.FormValue("tile_size")) original, _, _ := image.Decode(file) bounds := original.Bounds() db := cloneTilesDB() //  c1 := cut(original, &amp;db, tileSize, bounds.Min.X, bounds.Min.Y, bounds.Max.X/2, bounds.Max.Y/2) c2 := cut(original, &amp;db, tileSize, bounds.Max.X/2, bounds.Min.Y, bounds.Max.X, bounds.Max.Y/2) c3 := cut(original, &amp;db, tileSize, bounds.Min.X, bounds.Max.Y/2, bounds.Max.X/2, bounds.Max.Y) c4 := cut(original, &amp;db, tileSize, bounds.Max.X/2, bounds.Max.Y/2, bounds.Max.X, bounds.Max.Y) //  c := combine(bounds, c1, c2, c3, c4) buf1 := new(bytes.Buffer) jpeg.Encode(buf1, original, nil) originalStr := base64.StdEncoding.EncodeToString(buf1.Bytes()) t1 := time.Now() images := map[string]string{ "original": originalStr, "mosaic": &lt;-c, "duration": fmt.Sprintf("%v ", t1.Sub(t0)), } t, _ := template.ParseFiles("results.html") t.Execute(w, images) }</span></span></code> </pre><br>  The cut image is processed by the <b>cut</b> function. <br><br><img src="https://habrastorage.org/files/3b2/43a/38d/3b243a38d3e5478fb360f715d6a7ebf3.png"><br>  <i>Splitting the target image into 4 parts</i> <br><br>  The original image is cut into 4 quadrants in order to process them simultaneously. <br><br><pre> <code class="go hljs">c1 := cut(original, &amp;db, tileSize, bounds.Min.X, bounds.Min.Y, bounds.Max.X/<span class="hljs-number"><span class="hljs-number">2</span></span>, bounds.Max.Y/<span class="hljs-number"><span class="hljs-number">2</span></span>) c2 := cut(original, &amp;db, tileSize, bounds.Max.X/<span class="hljs-number"><span class="hljs-number">2</span></span>, bounds.Min.Y, bounds.Max.X, bounds.Max.Y/<span class="hljs-number"><span class="hljs-number">2</span></span>) c3 := cut(original, &amp;db, tileSize, bounds.Min.X, bounds.Max.Y/<span class="hljs-number"><span class="hljs-number">2</span></span>, bounds.Max.X/<span class="hljs-number"><span class="hljs-number">2</span></span>, bounds.Max.Y) c4 := cut(original, &amp;db, tileSize, bounds.Max.X/<span class="hljs-number"><span class="hljs-number">2</span></span>, bounds.Max.Y/<span class="hljs-number"><span class="hljs-number">2</span></span>, bounds.Max.X, bounds.Max.Y)</code> </pre><br>  You probably noticed that these are normal functions without gorutin, how can they be performed simultaneously?  The point is that the <b>cut</b> function internally creates an anonymous Gorutina and returns the channel. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(original image.Image, db *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">][3]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, tileSize, x1, y1, x2, y2 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> &lt;-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chan</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Image</span></span></span></span> { c := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> image.Image) sp := image.Point{<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { newimage := image.NewNRGBA(image.Rect(x1, y1, x2, y2)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y := y1; y &lt; y2; y = y + tileSize { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x := x1; x &lt; x2; x = x + tileSize { r, g, b, _ := original.At(x, y).RGBA() color := [<span class="hljs-number"><span class="hljs-number">3</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(r), <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(g), <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(b)} nearest := nearest(color, db) file, err := os.Open(nearest) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { img, _, err := image.Decode(file) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t := resize(img, tileSize) tile := t.SubImage(t.Bounds()) tileBounds := image.Rect(x, y, x+tileSize, y+tileSize) draw.Draw(newimage, tileBounds, tile, sp, draw.Src) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"error:"</span></span>, err) } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"error:"</span></span>, nearest) } file.Close() } } c &lt;- newimage.SubImage(newimage.Rect) }() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c }</code> </pre><br>  The logic is exactly the same as in the original web application.  I create a channel in the <b>cut</b> function and declare an anonymous Gorutina, which sends the result of the calculations to this channel.  Then return this channel.  Thus, the channel is immediately returned to the <b>mosaic</b> handler function, and the photo <b>mosaic</b> segment is sent to this channel as soon as it is completely processed. <br><br>  I divided the original image into 4 parts and converted them separately into a photo mosaic.  It is time to put the pieces back into a single picture. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r image.Rectangle, c1, c2, c3, c4 &lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> image.Image)</span></span></span><span class="hljs-function"> &lt;-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chan</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { c := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   go func() { var wg sync.WaitGroup img := image.NewNRGBA(r) copy := func(dst draw.Image, r image.Rectangle, src image.Image, sp image.Point) { draw.Draw(dst, r, src, sp, draw.Src) wg.Done() } wg.Add(4) var s1, s2, s3, s4 image.Image var ok1, ok2, ok3, ok4 bool for { select { case s1, ok1 = &lt;-c1: go copy(img, s1.Bounds(), s1, image.Point{r.Min.X, r.Min.Y}) case s2, ok2 = &lt;-c2: go copy(img, s2.Bounds(), s2, image.Point{r.Max.X / 2, r.Min.Y}) case s3, ok3 = &lt;-c3: go copy(img, s3.Bounds(), s3, image.Point{r.Min.X, r.Max.Y/2}) case s4, ok4 = &lt;-c4: go copy(img, s4.Bounds(), s4, image.Point{r.Max.X / 2, r.Max.Y / 2}) } if (ok1 &amp;&amp; ok2 &amp;&amp; ok3 &amp;&amp; ok4) { break } } //       wg.Wait() buf2 := new(bytes.Buffer) jpeg.Encode(buf2, newimage, nil) c &lt;- base64.StdEncoding.EncodeToString(buf2.Bytes()) }() return c }</span></span></code> </pre><br>  As in the cut function, the main logic of connecting the image is in the gorutin, and the channel is created only for receiving data. <br><br>  In the anonymous Gorutina, another anonymous function has been created, with which the <b>copy</b> variable is assigned.  This function copies the photo mosaic segment into the final mosaic.  Later it will be launched as a separate gorutin, so it is impossible to know when it will be executed.  To solve this problem and synchronize the execution of the copy function, we will use <a href="http://golang.org/pkg/sync/">WaitGroup</a> .  Create a <b>wg</b> variable of the <b>WaitGroup</b> type, then use the <b>Add</b> method and set the counter to 4. Each time the <b>copy</b> function is executed, the <b>Done</b> method is called, which reduces the counter value by 1. The <b>Wait</b> method is called strictly before the image is encoded to ensure the generation of all four pieces of the mosaic for a solid picture. <br><br>  Recall that the <b>combine</b> function accepts 4 channels of <b>cut</b> functions containing segments of photomasaics.  In fact, it is not clear exactly when the segments appear in the channels.  You can try to get these segments sequentially, but this is not like a competitive approach.  But I would like to start processing the segment as soon as it is received using the select statement. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1, s2, s3, s4 image.Image <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ok1, ok2, ok3, ok4 <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> s1, ok1 = &lt;-c1: <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(img, s1.Bounds(), s1, image.Point{r.Min.X, r.Min.Y}) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> s2, ok2 = &lt;-c2: <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(img, s2.Bounds(), s2, image.Point{r.Max.X / <span class="hljs-number"><span class="hljs-number">2</span></span>, r.Min.Y}) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> s3, ok3 = &lt;-c3: <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(img, s3.Bounds(), s3, image.Point{r.Min.X, r.Max.Y / <span class="hljs-number"><span class="hljs-number">2</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> s4, ok4 = &lt;-c4: <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(img, s4.Bounds(), s4, image.Point{r.Max.X / <span class="hljs-number"><span class="hljs-number">2</span></span>, r.Max.Y / <span class="hljs-number"><span class="hljs-number">2</span></span>}) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ok1 &amp;&amp; ok2 &amp;&amp; ok3 &amp;&amp; ok4) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } }</code> </pre><br>  This is an infinite loop that at each iteration tries to choose a case with ready data (if data came simultaneously from several channels, then Go randomly selects one case and executes it).  When you receive an image.Image for the channel, we run the <b>copy and copy</b> gorutina function.  I note that the channel takes several values.  The second value (ok1, ok2, ok3 or ok4) informs us about the fact of receiving data from the channel.  The endless loop is interrupted after receiving data from all four channels. <br><br>  Next, remember the type of WaitGroup, which was used earlier.  Remember, the <b>combine</b> function connects the obtained parts of photo mosaic in separate mountain fields, which may not be completed at the same time.  Therefore, the Wait method of the WaitGroup type blocks the encoding of the image until all the parts are assembled together. <br><br>  A screenshot with the same picture and the result of the mosaic generation: <br><br><img src="https://habrastorage.org/files/515/2e6/98d/5152e698d7f64d5eb77cb617f8fb4501.png"><br>  <i>Competitive web application photo mosaic</i> <br><br>  Your keen eye can notice the differences between the generated photo mosaics.  The final mosaic is assembled from 4 parts and the algorithm does not soften rough edges.  However, the performance difference is obvious - the base application generated a mosaic in 2.25 seconds, and the competitive implementation does the same thing four times faster, in 646 milliseconds. <br><br>  The attentive reader could note that both web applications run only on one processor core.  As Rob Pike writes in his article ‚Äú <a href="http://blog.golang.org/concurrency-is-not-parallelism">Competitiveness - not parallelism</a> ,‚Äù this is how I took a simple algorithm and divided it into lightweight threads without a parallel call!  None of the gorutin is running in parallel (after all, only 1 CPU is used), despite the fact that they run independently. <br><br>  Of course, it would be cruel not to take the last step, which will show how to run all this on several cores of your processor.  To do this, simply install <b>GOMAXPROCS</b> in <b>runtime</b> equal to the number of cores of your processor.  Changes need to be entered in the <b>main.go</b> file.  Remember to import the <a href="http://golang.org/pkg/runtime/">runtime</a> package before making changes. <br>  <i>(Note. Trans. - not relevant, since Go 1.5 version. The fact is that up to 1.5, the default value of GOMAXPROCS was 1, as the author says. Starting from 1.5, the default GOMAXPROCS will be equal to the number of your cores)</i> <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//      fmt.Println("Number of CPUs:", runtime.NumCPU()) runtime.GOMAXPROCS(runtime.NumCPU()) fmt.Println("Starting mosaic server ...") mux := http.NewServeMux() files := http.FileServer(http.Dir("public")) mux.Handle("/static/", http.StripPrefix("/static/", files)) mux.HandleFunc("/", upload) mux.HandleFunc("/mosaic", mosaic) server := &amp;http.Server{ Addr: "127.0.0.1:8080", Handler: mux, } TILESDB = tilesDB() fmt.Println("Mosaic server started.") server.ListenAndServe() }</span></span></code> </pre><br>  Compiled and uploaded our cat image again: <br><br><img src="https://habrastorage.org/files/ffc/b59/134/ffcb59134cd04228a30c4b42d6b18fb6.png"><br>  <i>Competitive web photo-photo application launched on 8 CPUs</i> <br><br>  As you can see, the speed has increased by 3 times: from 646 milliseconds to 216 milliseconds!  And if we compare this time with our original web application that generated the mosaic in 2.25 seconds, the performance increased 10 times!  This is a real comparison.  We did not run our original application on 8 cores, but if we had done this, we would not have seen a performance boost, since it did not use competition. <br><br>  It is also interesting to note that we used the same algorithm for single-threaded and competitive implementation of the photo mosaic generation algorithm.  In fact, we did not make changes to the mosaic.go file.  It is a testament. </div><p>Source: <a href="https://habr.com/ru/post/263019/">https://habr.com/ru/post/263019/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263007/index.html">The digest of interesting materials from the world of web development and IT for the last two weeks ‚Ññ168 (July 5 - 19, 2015)</a></li>
<li><a href="../263009/index.html">Parsing formats: 3d models from the inside</a></li>
<li><a href="../263011/index.html">Some potential buyers need to know about Bitrix</a></li>
<li><a href="../263015/index.html">Wolfram Language (Mathematica) is just a toy</a></li>
<li><a href="../263017/index.html">Conference C ++ Siberia in Novosibirsk</a></li>
<li><a href="../263021/index.html">Reflection in Cach√©</a></li>
<li><a href="../263025/index.html">Pro model, logic, OOP, development and the rest</a></li>
<li><a href="../263027/index.html">The principle of separation of responsibility and ORM</a></li>
<li><a href="../263031/index.html">How to make the browser cache not as useless as usual</a></li>
<li><a href="../263033/index.html">Forget about DAO, use the Repository</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>