<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Nostalgia: how ‚Äúsaving on paper‚Äù works</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Admit it, who as a child sat for hours on end playing a game of Dandy or Segou? And who, as the game progressed, wrote down the passwords on a piece o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Nostalgia: how ‚Äúsaving on paper‚Äù works</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/caa/4ae/250/caa4ae250d549edd8613e5d4c27746b0.jpg" align="right">  Admit it, who as a child sat for hours on end playing a game of Dandy or Segou?  And who, as the game progressed, wrote down the passwords on a piece of paper or in a specially created notebook?  If this is you, and since you are reading this site, then you probably have at least once the question: ‚Äúhow does it work?‚Äù <br><br>  I will try to explain the principles of the classic mechanisms for generating passwords using examples from the games of my childhood.  I apologize in advance for the fact that all the examples will be from the NES platform (yes, the one that is ‚ÄúDandy‚Äù), although the subject is not limited to it.  It so happened that I did not find enough motivation in myself to do a little more research and write a little more text. <br><a name="habracut"></a><br>  Examples will be given in order from simple to complex.  At first, there will be little code, but the further you go, the more difficult it is to explain the algorithms in human language and the easier it is to explain them in technical language, so don‚Äôt be hard on it. <br><br><img src="https://habrastorage.org/storage2/e17/59a/a66/e1759aa663cfbed7aa2ead6f9a8fcf62.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Code book </h1><br><img src="https://habrastorage.org/storage2/783/44d/394/78344d394bc732c5b4715bc453b299ec.png" align="right">  I still remember the passwords of some levels from the games of my childhood ‚Äî for example, BCHK from Trolls in Crazyland (Doki! Doki! Yuuenchi), 4660 from Choujin Sentai - Jetman.  It can be said that these passwords are ideal in terms of convenience: they are easy to remember and difficult to make a mistake when entering.  But how much information can they contain, and what is the chance to accidentally pick up such a password? <br><br>  In the first case, the alphabet of the password is 24 characters.  If you count the number of combinations of characters, it will be 24 <sup>4</sup> - not so little, considering that there are only 12 levels in the game, and, in fact, besides the level number, the password does not store anything in itself.  We take into account several secret passwords and calculate the probability of finding a password on one attempt: (12 + 4) / 24 <sup>4</sup> , which is equal to ~ 5.7 √ó 10 <sup>-14</sup> .  In other words, an average of 17592186044416 passwords will have to be tried before we pick up any real one. <br><br><img src="https://habrastorage.org/storage2/f15/62f/918/f1562f918e1d2fcaa2cea2b119a76ac6.png" align="left">  In the second case, everything is different.  Obviously, a set of 4 digits gives us exactly 10,000 (10 <sup>4</sup> ) combinations.  The game contains five levels that can be completed in a different order and two levels of difficulty.  Those.  The password stores information about the levels and difficulty levels passed.  Thus, the number of existing passwords is 2 √ó 2 <sup>5</sup> , i.e.  64. Hence the probability of choosing a password is 0.0064, i.e.  more than half a percent.  Is it enough?  On average, approximately every 156th password will be correct, and given the fairly high search speed, searches will not last long.  And, frankly, in childhood we often ‚Äúbrute force‚Äù the game, when we didn‚Äôt want to start from the very beginning. <br><br>  In fact, it is senseless to evaluate the information capacity of such passwords, since they are only keys of a kind, i.e.  games simply store all possible passwords, and the index of the entered password receive information about the level and so on.  But for the sake of interest I will say that their theoretical capacity is 48 and 13 bits (log <sub>2</sub> 24 <sup>4</sup> and log <sub>2</sub> 10 <sup>4</sup> ). <br><br>  And yet, how exactly are the passwords processed?  In the first case, the entered password is not subjected to any transformations at all, but is simply searched for in the stored password array. <br><div class="spoiler">  <b class="spoiler_title">Show code</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* s_passwords[<span class="hljs-number"><span class="hljs-number">12</span></span>] = { <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">"BLNK"</span></span>, <span class="hljs-comment"><span class="hljs-comment">// ... "MZSX" }; // ... if (strncmp(pass, s_secretPassword1, 4) == 0) { callSecret1(); return 0; } // ... for (int level = 0; level &lt; 12; level++) { if (strncmp(pass, s_passwords[level], 4) == 0) { return level; } } return -1;</span></span></code> </pre> </div></div><br><br>  And in the second case, the game comes a bit more cunning, and first the password is converted into a <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE-%25D0%25B4%25D0%25B5%25D1%2581%25D1%258F%25D1%2582%25D0%25B8%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25B4">binary-decimal code</a> , which reduces its size exactly twice.  This makes it possible in the game itself to reduce the size of passwords in half. <br><div class="spoiler">  <b class="spoiler_title">Show code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">uint16 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toBCD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pass)</span></span></span><span class="hljs-function"> </span></span>{ uint16 result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { result &lt;&lt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; result |= (pass[i] - <span class="hljs-string"><span class="hljs-string">'0'</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xF</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } s_passwords[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">32</span></span>] = { { <span class="hljs-number"><span class="hljs-number">0x0000</span></span>, <span class="hljs-comment"><span class="hljs-comment">// ... 0x4660 }, { 0x7899, // ... 0x5705 } }; // ... const uint16 pass = toBCD(passStr); for (int difficulty = 0; difficulty &lt; 2; difficulty++) { for (int clearedLevels = 0; clearedLevels &lt;= 0x1F; clearedLevels++) { if (pass == s_passwords[difficulty][clearedLevels]) { setState(difficulty, clearedLevels); return true; } } } return false;</span></span></code> </pre></div></div><br><br><h1>  Numbers and numbers </h1><br><img src="https://habrastorage.org/storage2/1fb/5a8/195/1fb5a8195782c94c81370f16cdd96af6.png" align="right">  I do not dare to ignore the classics: I am sure that many played in the original ‚ÄúPrince of Persia‚Äù, and not only on the ‚ÄúDandy‚Äù.  Game passwords are also sequences of decimal digits, but this time they do encode some data. <br><br>  Namely, two values ‚Äã‚Äãare coded: time and level number.  Because  The password is 8 digits long, i.e.  100,000,000 combinations, and the game has 14 levels and 60 possible times (totaling 840 variants), it can be assumed that it is difficult to choose.  But in reality this is not so, and in order to understand why, let's first examine the principle of its generation. <br><br>  So, first the game creates an array of 8 elements that can store values ‚Äã‚Äãfrom 0 to 9. Then, two random values ‚Äã‚Äãare generated - also from 0 to 9 - and are written to this array by indices 2 and 5. These random values ‚Äã‚Äãare increments, which will be added to the saved values ‚Äã‚Äãmodulo 10. This increases the number of possible passwords by 100 times, which obviously complicates the identification of patterns. <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint8 rand0 = rand() % <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint8 rand1 = rand() % <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pass[<span class="hljs-number"><span class="hljs-number">8</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, rand0, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, rand1, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>};</code> </pre><br>  Next, the level index is encoded (i.e., its minus one number): the sum of the two higher bits of the index and the second increment modulo 10 is recorded at index 7, and the sum of the two lower bits and the first increment - index 1. <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//       pass[7] = ((level &gt;&gt; 2) + rand1) % 10; //     pass[1] = ((level &amp; 3) + rand0) % 10;</span></span></code> </pre><br>  It was the turn of time.  It is a bit simpler with it: the sum of tens and the first increment modulo 10 is recorded at index 0, and the sum of units and the second increment at index 3. It turns out that with increments equal to zero, time is recorded in decimal digits as is.  And, since the ceiling of tens is 9, then the maximum possible value of time is 99, and not an ‚Äúhonest‚Äù 60 minutes. <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//     pass[0] = ((time / 10) + rand0) % 10; //     pass[3] = ((time % 10) + rand1) % 10;</span></span></code> </pre><br>  Data recorded, it remains to calculate the checksum to verify the validity of the password. <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//    sum = pass[0] + pass[1] + pass[2] + pass[3]; sum += (sum % 10) + pass[5]; sum += (sum / 10) + pass[7]; //    pass[4] = sum % 10; pass[6] = sum / 10;</span></span></code> </pre><br>  For example, the legend of the password of the 13th level with the 32nd remaining minutes is ‚Äú96635134‚Äù. <br><img src="https://habrastorage.org/storage2/e8e/a68/cc6/e8ea68cc6a8ab133bd2803764d45cb2d.png"><br><br>  It becomes obvious that for selecting a password it is enough that the checksum matches the coded data.  Then, if you do not take into account its specifics, you can calculate the probability to choose a password: exactly 1% (one divided by the number of possible values ‚Äã‚Äãof the sum) is quite a lot. <br><br>  But this is just an ordinary amount!  And for different data it may turn out the same.  If you change any valid password so that the sum of the first 4 digits remains the same - it will do.  What can we say about the fact that the ordinary amount of the distribution is not even, and the maximum value of this amount will never exceed 72. <br><br>  Taking into account the specifics of such a sum, it turns out that with linear enumeration the probability of its coincidence with the data is very high.  That is why on thematic forums in the network you can often find people's memories of how cleverly they picked up passwords for Prince of Persia. <br><br><h1>  Positional number systems </h1><br><img src="https://habrastorage.org/storage2/dae/21a/635/dae21a635d4411f6655ad39d917e38de.png" align="right">  Surely many are familiar with <a href="http://ru.wikipedia.org/wiki/Base64">Base64</a> and <a href="http://ru.wikipedia.org/wiki/Base32">Base32</a> .  By definition, these are positional number systems with bases 64 and 32, respectively.  The principle is simple: we divide the bit stream into values ‚Äã‚Äãof a fixed bit length, and then, using a defined dictionary, we take the symbols as indexes by the values ‚Äã‚Äãobtained. <br><br>  Many password systems are based on this principle.  And the next game, on the example of which I will describe the password generation algorithm, will be Takahashi Meijin no Bouken Jima IV, in common people better known as Adventure Island 4. <br><br><img src="https://habrastorage.org/storage2/ea0/878/c44/ea0878c444cd52dc9d7bb40a115ab20b.png" align="left">  The state of the game includes a set of available items (up to 12), abilities (up to 3), special items (up to 6), collected hearts (up to 8), location with an egg and information about the levels completed.  But in fact, for everything except hearts and special items, one value is responsible - the progress index.  This is an index in the array, where each element stores information about available items, abilities, and so on.  Simply put, it is this byte that defines the set of items, abilities, and stages completed. <br><br>  The first step of the algorithm is to build an array of four bytes.  The value of progress is written to the first byte.  Interestingly, only certain values ‚Äã‚Äãare permissible. <br><br>  The second byte is recorded mask of available special items - 6 high byte bits.  The remaining low 2 bits is written constant, equal to one.  I guess this is the password format version.  And perhaps just a constant of stricter verification of entered passwords. <br><br>  The third byte is the index of the location where the egg is set (for those who did not play, a kind of checkpoint).  If the egg is not set anywhere, then the value is 0xFF.  The index of the location with the egg can also take only certain values ‚Äã‚Äã- there are only those locations where the egg can be installed. <br><br>  And, finally, the mask of the collected hearts and half-hearts is copied to the fourth byte. <br><br><div class="spoiler">  <b class="spoiler_title">Show tables</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//        const uint8 s_itemsInProgress[] = { 0x8000, 0xC000, 0xC000, 0xC000, 0xE000, 0xF000, 0xF000, 0xF000, 0xF000, 0xF800, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFE00, 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFF80, 0xFF80, 0xFF80, 0xFFC0, 0xFFC0, 0xFFE0, 0xFFE0, 0xFFF0, 0xFFF0, 0xFFF0, 0xFFFC, 0xFFFE, 0xFFFF, 0xFFFF }; //        const uint8 s_powersInProgress[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0 }; //     const uint8 s_accessibleEggLocations[] = { 0x04, 0x07, 0x16, 0x1B, 0x2F, 0x31, 0x41, 0x43, 0x45, 0x47, 0x4E, 0x52, 0x57, 0x87, 0x98, 0x9C, 0x9E, 0xA0, 0xA1, 0xA2, 0xA4, 0xB1, 0xB3, 0xB5, 0xFF, 0x0C }; //    const uint8 s_accessibleProgressValues[] = { 0, 1, 4, 5, 6, 9, 10, 11, 14, 15, 16, 17, 20, 21, 22, 23, 26, 27, 28, 29 };</span></span></code> </pre></div></div><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint8 s_version = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... uint8 data[4] = {progress, specItems | s_version, eggLocation, hearts};</span></span></code> </pre><br>  Then the password is encoded in the same way as Base32, but with a different alphabet: 5 bits are taken from this array in turn and written into separate bytes of an array of eight elements.  In this case, using the operation "xor" is considered a checksum, which is written to the last byte of the array. <br><br>  The coding table index is added to the free bits of the sixth byte.  At the beginning of the game, this index is calculated randomly (value from 0 to 3), but only one will be used within one pass.  Those.  There may be 4 variants of the same password. <br><br><pre> <code class="cpp hljs"> uint8 password[<span class="hljs-number"><span class="hljs-number">8</span></span>] = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>; i++) { password[i] = takeBits(data, <span class="hljs-number"><span class="hljs-number">5</span></span>); password[<span class="hljs-number"><span class="hljs-number">7</span></span>] ^= password[i]; } password[<span class="hljs-number"><span class="hljs-number">6</span></span>] |= (tableIndex &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>); password[<span class="hljs-number"><span class="hljs-number">7</span></span>] ^= password[<span class="hljs-number"><span class="hljs-number">6</span></span>];</code> </pre><br>  The last stage: one of the four Base32 coding tables is taken by index, and the resulting array is converted to text.  Array elements are used as character indexes. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* s_encodeTables[] = { <span class="hljs-string"><span class="hljs-string">"3CJV?N4Y0FP78BS1GW2QL6ZM9TR5KDXH"</span></span>, <span class="hljs-string"><span class="hljs-string">"JT1W9M3DV5?ZKX6GC0FB2SPHR4N8LY7Q"</span></span>, <span class="hljs-string"><span class="hljs-string">"R0CXM8TWB3G56PKY4FVND7QL2JZ19HS?"</span></span>, <span class="hljs-string"><span class="hljs-string">"8JWB3PD0?RVG5L2KX4QFZ9TN1S6MH7YC"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> passwordStr[<span class="hljs-number"><span class="hljs-number">11</span></span>] = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { passwordStr[index++] = s_encodeTables[tableIndex][password[i]]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">3</span></span> || i == <span class="hljs-number"><span class="hljs-number">5</span></span>) { passwordStr[index++] = <span class="hljs-string"><span class="hljs-string">'-'</span></span>; } }</code> </pre><br><br>  There are 32 <sup>8</sup> possible password options.  It is easy to count the number of suitable passwords - just multiply the number of valid values ‚Äã‚Äãfor each of the variables being coded.  So, we can encode 26 egg locations, 20 different progress values, 256 (2 <sup>8</sup> ) combinations of collected hearts, 64 (2 <sup>6</sup> ) combinations of special items and 4 password options.  Total: 26 √ó 20 √ó 256 √ó 64 √ó 4 = 34078720 passwords.  From here the probability to pick up the password is ~ 0.03% - we need an average of 32,264 attempts. <br><br><h1>  Graphic chaos </h1><br><img src="http://habrastorage.org/storage2/9e0/e47/c64/9e0e47c64d5744e947c7e66ef2ed1257.png" align="left">  In some cases, developers show originality and use graphical passwords.  They could be encountered, for example, in the games of the Mega Man series.  Of course, the convenience of such passwords is doubtful - especially from the habit.  But this is nothing compared to the long passwords in Japanese, which, alas, I did not have the strength to cover in this article. <br><br>  As an example, I will take the game Power Blade 2. It uses a password consisting of 12 bonus icons located in a 4x3 grid.  There are a total of 8 different icons, including an empty one.  In fact, the difference between a character password and a graphic password of this kind is only in the representation of its elements, if you replace the icons with symbols, the essence will not change. <br><br>  Each icon corresponds to a number from 0 to 7, in accordance with their order of appearance when the password is typed: <br><table><tbody><tr><td>  0 </td><td>  one </td><td>  2 </td><td>  3 </td><td>  four </td><td>  five </td><td>  6 </td><td>  7 </td></tr><tr><td><img src="http://habrastorage.org/storage2/ecf/134/0d9/ecf1340d9c06bb59b702350a88812dfe.png"></td><td><img src="http://habrastorage.org/storage2/eee/cca/c93/eeeccac930c9f29527a20d31391aeb94.png"></td><td><img src="http://habrastorage.org/storage2/035/422/dab/035422dabe10facf995abfb5bd4e746d.png"></td><td><img src="http://habrastorage.org/storage2/2f8/60d/6ae/2f860d6ae87470e903815dd0fa8cfb93.png"></td><td><img src="http://habrastorage.org/storage2/0a8/00a/21a/0a800a21af8e2cc5284ebf6cc8f57a60.png"></td><td><img src="http://habrastorage.org/storage2/991/0ca/21d/9910ca21d7a58cb32bb07718238bdbf1.png"></td><td><img src="http://habrastorage.org/storage2/9c2/f3d/60b/9c2f3d60b6792e51b55959a4be3f78b0.png"></td><td><img src="http://habrastorage.org/storage2/517/bf4/6b1/517bf46b1f4abc4866b4094decf71623.png"></td></tr></tbody></table><br>  It is easy to calculate that we have 8 <sup>12</sup> combinations, although the game saves only information about the levels completed and the costumes available.  Only 5 levels (not counting the final), which can be held in random order, and 4 costumes.  Those.  5 bits and 4 bits respectively, 9 bits in total.  The password also has a capacity of 12 √ó log <sub>2</sub> 8, i.e.  36 bits is more than enough. <br><br>  Starting the generation of a password, the game, as usual, forms an array.  At this time, immediately of the 12 elements, each of which corresponds to a password cell.  Each cell has a capacity of 3 bits, and the game records 2 bits of value in them, leaving the low bit for the checksum. <br><br><pre> <code class="cpp hljs"> uint8 pass[<span class="hljs-number"><span class="hljs-number">12</span></span>] = {}; <span class="hljs-comment"><span class="hljs-comment">//     pass[7] = (clearedLevelsMask &amp; 0x3) &lt;&lt; 1; //    pass[9] = (clearedLevelsMask &amp; 0xC) &gt;&gt;&gt; 1; //    pass[11] = (clearedLevelsMask &amp; 0x10) &gt;&gt;&gt; 2; //     pass[8] = (suitsMask &amp; 0x3) &lt;&lt; 1; //     pass[10] = (suitsMask &amp; 0xC) &gt;&gt;&gt; 1;</span></span></code> </pre><br>  Then a 6-bit checksum is considered, which is the arithmetic sum of all the elements of the array.  This sum is then bitwise recorded in the reserved low bits of the cells. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">uint8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcChecksum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8* pass)</span></span></span><span class="hljs-function"> </span></span>{ uint8 checksum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">12</span></span>; i++) { checksum += pass[i]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { pass[i + <span class="hljs-number"><span class="hljs-number">6</span></span>] |= (checksum &gt;&gt; i) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre><br>  The result is something like this: <br><img src="http://habrastorage.org/storage2/707/fde/758/707fde75892bc9585b4c55b6ed6e5023.png"><br><br>  The data are prepared, the next step is a permutation of one of the 5 tables.  Associated with cryptography, is not it?  Depending on the mask of the levels passed, the permutation table is selected.  Tables contain indices of elements in accordance with their new order. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> s_swizzleTableFinal[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> s_swizzleTables[][] = { {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>}, {<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>}, {<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>}, {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swizzlePassword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint8* pass, uint8 clearedLevelsMask)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint8* swizzTable = (clearedLevelsMask == <span class="hljs-number"><span class="hljs-number">0x1F</span></span>) ? s_swizzleTableFinal : s_swizzleTables[clearedLevelsMask % <span class="hljs-number"><span class="hljs-number">4</span></span>]; uint8 swizzledPass[<span class="hljs-number"><span class="hljs-number">12</span></span>] = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">12</span></span>; i++) { swizzledPass[i] = pass[swizzTable[i]]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">12</span></span>; i++) { pass[i] = swizzledPass[i]; } }</code> </pre><br>  The last step is to apply the increment table.  Those.  each cell is summed with the corresponding element of the table modulo 8. It is precisely because of this that the icons will be different even for the same values. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyIncrementTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint8* pass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">12</span></span>; i++) { pass[i] = (pass[i] + s_incrementTable[i]) % <span class="hljs-number"><span class="hljs-number">8</span></span>; } }</code> </pre><br>  Here we have a ready-made password.  And it turns out that 15 bits out of 36 are used in this password. But why? <br><br>  The fact is that these bits are not so unused.  The password decoding procedure takes information from them about the collected L and E bonuses, as well as their current quantity, but then checks that all these values ‚Äã‚Äãare zero.  Hence we can assume that it was originally planned to save this information, but then it was decided to abandon it. <br><br>  Whether this is the result of gameplay balancing, or simply a disabled developer tool is unknown.  Read more about it <a href="http://roman-pro.livejournal.com/186785.html">here</a> . <br><br><h1>  Variable lengths </h1><br>  Somewhere at home I have a notebook, painted with passwords of the main RPG of my childhood - Little Ninja Brothers.  Despite the fact that this game is nothing supernatural, it took me several years to complete.  After all, it was my first RPG, and at first I didn‚Äôt even know that it was possible to ‚Äúswing‚Äù there, so it took about half a year to defeat the second boss without pumping (the benefit is the opportunity to play together). <br><br>  At one time, this particular game made me think about the structure of the password system - once, all the day, sitting in front of the TV, I looked for patterns in passwords and tried to determine their dependence on current characteristics.  As a result, I even managed to pick up one password and increase the amount of money, but this was the only successful case. <br><br>  After a while, in the process of becoming an IT specialist in me, I once remembered that incident.  And, since he was very inquisitive and loved to break his head, decided during the university holidays, by all means find out the mechanism for generating passwords.  Now it would be enough for me to do this, but then it took a whole week, but the goal was nevertheless achieved. <br><br><img src="http://habrastorage.org/storage2/1d6/485/22c/1d648522cd11e507e802b4d3b199f790.png" align="right">  This case is more interesting than the previous ones, if only because the password has a variable length: as the game progresses, new characters are added.  Moreover, the password stores much more data than in all previous ones taken together.  As can be seen from the screenshot, the alphabet is 32 characters, and the maximum length of the entered password is 54 characters.  This gives us 32 <sup>54</sup> possible passwords of maximum length, and taking into account the variable length, there are 32 <sup>1</sup> + 32 <sup>2</sup> + ... + 32 <sup>54</sup> variants.  If you count the amount of information that can accommodate one password of maximum length, it will be 270 bits (log <sub>2</sub> 32 <sup>54</sup> ). <br><br>  So, what kind of data does the password store?  Since this is an RPG, there are a lot of characteristics, and almost all of them need to be saved. <br><br><div class="spoiler">  <b class="spoiler_title">Feature List</b> <div class="spoiler_text"><img src="http://habrastorage.org/storage2/1b3/cfe/7a1/1b3cfe7a16ee9e37f1890a2b506c5c1f.png"><img src="http://habrastorage.org/storage2/2c0/3a1/5b7/2c03a15b7befc6234b74003a330b1638.png"><br><br><img src="http://habrastorage.org/storage2/e13/710/5e2/e137105e25300b48da5de90bab9c7d36.png"><img src="http://habrastorage.org/storage2/b6f/1e7/f13/b6f1e7f13d44b55e221270c2013458bf.png"><br><br>  Specifications: <br><ul><li>  Character level (max. 50) </li><li>  Experience amount (max. 65535) </li><li>  Maximum health (max. 255) </li><li>  Amount of money (max. 99999) </li><li>  The number of M-bonuses (max. 6) </li></ul><br>  Equipment: <br><ul><li>  Received prism bells (red, orange, yellow, green, blue, blue, purple) </li><li>  Available artifacts (antidote, mind) </li><li>  Type of strike (‚Äúiron claws‚Äù, ‚Äúcrushing blow‚Äù, ‚Äúmega-blow‚Äù, ‚Äúfire strike‚Äù, ‚Äúdull blow‚Äù, ‚Äúgolden claws‚Äù, ‚ÄúLi strike‚Äù, ‚Äúprism claws‚Äù) </li><li>  Existing sword (‚Äúhawk sword‚Äù, ‚Äútiger sword‚Äù, ‚Äúeagle sword‚Äù, ‚Äúprism sword‚Äù) </li><li>  Shield ("scaly", "mirror", "fiery", "prismatic") </li><li>  Rob (‚Äúwhite‚Äù, ‚Äúblack‚Äù, ‚Äúrobe li‚Äù, ‚Äúsacred robe‚Äù) </li><li>  Talisman ("Œ±", "Œ≤", "Œ≥", "œÉ", "œâ") </li><li>  Amulet ("I", "II", "III", "IV") </li><li>  Lamp type (match, candle, torch, piece of sun) </li><li>  Available types of shuriken ("single", "serial", "boomerangs", "fixer" <sup><font color="grey">(could not translate)</font></sup> ) </li></ul><br>  Items and stuff: <br><ul><li>  The number of buns (an analogue of a light healing potion, up to 8 pcs.) </li><li>  The number of meat buns (similar to a strong therapeutic potion, up to 1 pc.) </li><li>  Number of helicopters (danalog portal to the city, up to 8 pcs.) </li><li>  The number of drugs (allows you to resurrect the second player, up to 1 pc.) </li><li>  The number of skateboards (allows you to escape from the battlefield, up to 8 pcs.) </li><li>  Number of bombs (up to 8) </li><li>  Is there a dragster (this is such a racing car) </li><li>  Number of batteries for dragster </li><li>  Available number of special hits for both players </li></ul></div></div><br>  In fact, not all of this data is saved, and not all stored data is listed.  Not mentioned remained visited cities, the current location and a couple of bits with information about game events occurred.  In turn, the level and health are not preserved, since these two quantities directly depend on the amount of experience and are redundant data.  Also, the number of spetsudars of the second player is not saved, since  It is essentially optional. <br><br>  So how does all this work?  To begin with, the game stores an array of pointers to the bytes of variables that need to be saved.  According to these pointers, the game forms an array of bytes, which is then subjected to encoding.  This array is divided into 4 groups of 8 bytes (6 bytes in the last group). <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> s_groupsBytes[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* s_passDataMap[<span class="hljs-number"><span class="hljs-number">30</span></span>] = { <span class="hljs-comment"><span class="hljs-comment">// Group 1 &amp;currLocation, &amp;bells, &amp;moneyLo, &amp;expLo &amp;moneyMed, &amp;expHi, &amp;moneyHi, &amp;kicks, // Group 2 &amp;visitedCitiesLo, &amp;visitedCitiesHi, &amp;mBonusCount, &amp;tStarsTypes, &amp;punch, &amp;usedTreasures, &amp;tStars, &amp;treasures, // Group 3 &amp;sword, &amp;bombs, &amp;shield, &amp;skboards, &amp;robe, &amp;dragster, &amp;talisman, &amp;meatbuns, // Group 4 &amp;amulet, &amp;sweetbuns, &amp;light, &amp;batteries, &amp;whirlyBirds, &amp;medicine };</span></span></code> </pre><br>  To make passwords as compact as possible, all null values ‚Äã‚Äãare ignored.  To this end, for each of the four groups of the array, a mask of nonzero values ‚Äã‚Äãis compiled - one byte, where the i-th bit indicates whether the i-th element of the array should be included in the password.  In a formed array, this mask will go in front of the group to which it corresponds. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">uint8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">valuesMask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8* data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> group)</span></span></span><span class="hljs-function"> </span></span>{ uint8 valuesMask = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startIndex = group * <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = startIndex + s_groupsBytes[group] - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= startIndex; i--) { valuesMask &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data[i] != <span class="hljs-number"><span class="hljs-number">0</span></span>) { valuesMask |= <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> valuesMask; }</code> </pre><br>  The same operation at the end applies to groups in the case when all group values ‚Äã‚Äãare zero: there is a four-bit mask (4 high bits of a byte), where the i-th bit (from high to low) indicates that the password is included i-th array group.  This mask will be written in the header, right in front of these groups. <br><br>  In addition, there is a length table, where each byte of the array corresponds to its significant number of bits.  Those.  as a result, not the entire array of bytes will be encoded, but only the used bits of the values.  The same technique is used for masks of nonzero values ‚Äã‚Äã- the number of mask bits used corresponds to the number of bytes in the group. <br><br>  The resulting array is an analogue of the bit stack: adding variables occurs by ‚Äúfront substitution‚Äù - for N added bits a logical right shift to N is applied to the entire array, and the variable value is written to the bits released at the beginning. <br><br><img src="http://habrastorage.org/storage2/751/2f0/e37/7512f0e37004653f4e1889d65588da49.png"><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> s_bitLengths[] = { <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pushBits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint8* data, uint8 value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitCount)</span></span></span><span class="hljs-function"> </span></span>{ shiftRight(data, bitCount); writeBits(data, value, bitCount); } <span class="hljs-comment"><span class="hljs-comment">// ... uint8 encodedData[30] = {}; uint8 groupsMask = 0; for (int i = 3; i &gt;= 0; i--) { groupsMask &gt;&gt;= 1; uint8 currMask = valuesMask(passData, i); if (currMask != 0) { groupsMask |= 0x80; const uint8 valuesCount = s_groupsBytes[i]; const int startIndex = i * 8; for (int j = startIndex + valuesCount - 1; j &gt;= startIndex; j--) { if (passData[j] != 0) { pushBits(encodedData, passData[j], s_bitLengths[j]); } } pushBits(encodedData, currMask, valuesCount); } }</span></span></code> </pre><br>  Then 4 bytes are added to the beginning of the array, which are a kind of header.      ,        ‚Äî 8-    0  31,         32. <br><br>      , ,     ,   .    20- ,   ,     . <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">uint32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcChecksum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint8* data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ uint32 sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { sum += data[i] * (i + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; } <span class="hljs-comment"><span class="hljs-comment">// ... const uint8 increment = rand() % 32; shiftRight(encodedData, 32); encodedData[3] = increment; uint32 checksum = calcChecksum(&amp;encodedData[3], (encodedDataBitLength + 7) / 8); encodedData[0] = checksum &amp; 0xFF; encodedData[1] = (checksum &gt;&gt; 8) &amp; 0xFF; encodedData[2] = ((checksum &gt;&gt; 16) &amp; 0xF) | groupsMask;</span></span></code> </pre><br>   ,     ,   Base32.                  ,       ,        . <br><br><pre> <code class="cpp hljs"> uint8 password[<span class="hljs-number"><span class="hljs-number">54</span></span>] = {}; uint8* header = encodedData; uint8* body = &amp;encodedData[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// Encode header (3 bytes + increment = 6 chars) for (int i = 0; i &lt; 5; i++) { password[i] = takeBits(header, 3, 5); } password[5] = increment; const int charCount = (((byteCount + 1) * 8 + 4) / 5) - 1; // Encode password data for (var i = 0; i &lt; charCount; i++) { password[i + 6] = takeBits(body, byteCount, 5); }</span></span></code> </pre><br>     ,   ,     . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Apply increment skipping increment char for (var i = 0; i &lt; password.length; i++) { if (i != 5) { password[i] = (password[i] + increment) % 32; } }</span></span></code> </pre><br> , ,  :     . <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span>* s_passwordCharTable = <span class="hljs-string"><span class="hljs-string">L"‚ÄîBCD\u25a0FGH+JKLMN\u25cfPQRST\u25b2VWXYZ234567"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; charCount; i++) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; s_passChars[password[i]]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i % <span class="hljs-number"><span class="hljs-number">6</span></span> == <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre><br><br><div class="spoiler"> <b class="spoiler_title">      </b> <div class="spoiler_text">  NES    ,     ,    ,     .   ,      ¬´¬ª  . <br><br>    :  ,     (    ¬´Base32¬ª)      4- .              . <br><br> ,    ,   9  (  ) ‚Äî 8   +    .  ,            , ..   18-,       ,    .       ,     ,     . <br><br>   0x12 (,    4  ),     ,      .  Because    ,     ,        . <br><br><pre> <code class="cpp hljs"> uint8 data[<span class="hljs-number"><span class="hljs-number">32</span></span>] = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; index &lt; <span class="hljs-number"><span class="hljs-number">34</span></span>; index++) { <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> = index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">register</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !(mask &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> = <span class="hljs-number"><span class="hljs-number">9</span></span>; index = <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">register</span></span> == <span class="hljs-number"><span class="hljs-number">9</span></span> &amp;&amp; !(mask &amp; <span class="hljs-number"><span class="hljs-number">0x40</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> = <span class="hljs-number"><span class="hljs-number">18</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ! mask = register; } if (register == 18 &amp;&amp; !(mask &amp; 0x20)) { //        register = 27; index = register; } if (register == 27 &amp;&amp; !(mask &amp; 0x10)) { return; } decodeValue(input, &amp;data[index]); }</span></span></code> </pre><br>  ,          .          ?  ,        , , ,    ,   3- ,      (        ),        ,  ,          . <br><br>  -      ,   ,     !      :   ,     .    ‚Äî          ,    . <br></div></div><br><br><h1>    </h1><br>  JavaScript           <br> <a href="http://consolgames.ru/passgens/adventureisland4.html">Adventure Island 4</a> (Takahashi Meijin no Bouken Jima IV)  <a href="http://consolgames.ru/passgens/powerblade2.html">Power Blade 2</a> ,      <a href="http://consolgames.ru/passgens/littleninjabrothers.html">  Little Ninja Brothers</a>   . <br><br>      , -    . <br><br>    Prince of Persia   <a href="http://cah4e3.shedevr.org.ru/cheatsbase_passg.php"></a> . <br><br><div class="spoiler"> <b class="spoiler_title">  ...</b> <div class="spoiler_text"><img src="http://habrastorage.org/storage2/5db/560/11d/5db56011d7486be63b3be9a9fd20d1d5.png"><img src="http://habrastorage.org/storage2/3fb/79d/fc9/3fb79dfc9eb3a9543cd13e801dc17f24.png"><br><br><img src="http://habrastorage.org/storage2/d6c/5a1/868/d6c5a1868002d7024b643f049fc231d6.png"><img src="http://habrastorage.org/storage2/60e/e7e/7b3/60ee7e7b38096399793c451685559ab5.png"><br><br><img src="http://habrastorage.org/storage2/825/307/973/825307973a84decbcf881e78699ef044.png"><img src="http://habrastorage.org/storage2/1ea/735/249/1ea7352496cb4f5dd5a3c5217a5e59c4.png"><br><br><img src="http://habrastorage.org/storage2/1f3/20c/0e4/1f320c0e414c4c1176f8b130c620c710.png"><img src="http://habrastorage.org/storage2/423/f9b/a87/423f9ba87a03e42fcac704452555b913.png"><br><br><img src="http://habrastorage.org/storage2/b7c/279/719/b7c279719bd76e48752bc304348fc618.png"><img src="http://habrastorage.org/storage2/06e/56a/b68/06e56ab6855002d7beb96823440a6a7b.png"><br><br><img src="http://habrastorage.org/storage2/96b/0d4/c25/96b0d4c255398d9cdc1266fdf14e7ab5.png"><img src="http://habrastorage.org/storage2/4f1/02b/afc/4f102bafcd074355edcb8ef9230134f6.png"><br></div></div><br><br><h1>  Links </h1><br><ul><li> <a href="http://cah4e3.shedevr.org.ru/cheatsbase_passg.php">  </a>   NES- CaH4e3'. </li><li> <a href="http://griever.magicteam.net/passgen/"> </a>  Griever'. </li><li> <a href="http://tasvideos.org/PasswordGenerators.html"> </a>   tasvideos.org. </li><li> <a href="http://roman-pro.livejournal.com/tag/passgens">  </a>  <a href="http://passgens.narod.ru/"> </a>   <a href="https://habrahabr.ru/users/roman_pro/" class="user_link">roman_pro</a> . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/150958/">https://habr.com/ru/post/150958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150950/index.html">Building Command Line Applications (CLI)</a></li>
<li><a href="../150951/index.html">How to get your web screenshots service - version 1.1</a></li>
<li><a href="../150954/index.html">Combing "Similar posts"</a></li>
<li><a href="../150955/index.html">Kinect for Windows SDK. Part 1. Sensor</a></li>
<li><a href="../150957/index.html">There was a native ŒºTorrent client for Android</a></li>
<li><a href="../150960/index.html">Changes in the new version of the Twitter API will affect all</a></li>
<li><a href="../150964/index.html">ASUS Announces Discontinuing Eee-PC Netbooks</a></li>
<li><a href="../150965/index.html">LilacServer - a box for creating websites in Java</a></li>
<li><a href="../150966/index.html">Generating Design Ideas with a Genetic Algorithm</a></li>
<li><a href="../150967/index.html">"All day phone" - Motorola has updated the line of RAZR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>