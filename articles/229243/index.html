<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We broadcast a video stream from an IP camera using WebRTC</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The solution to the problem of online broadcasting from an IP camera, generally speaking, does not require the use of WebRTC. The camera itself is a s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We broadcast a video stream from an IP camera using WebRTC</h1><div class="post__text post__text-html js-mediator-article">  The solution to the problem of online broadcasting from an IP camera, generally speaking, does not require the use of WebRTC.  The camera itself is a server, has an IP address and can be connected directly to the router in order to distribute video content.  So why use WebRTC technology? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ae/b83/a78/3aeb83a7806668c721fc2584a8ea6059.jpg" alt="image"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are at least two reasons for this: <br><br>  1. As the number of viewers of the Ethernet broadcast increases, there will increasingly be a lack of channel thickness, and then the resources of the camera itself. <br><br>  2. As mentioned above, the IP camera is a server.  But according to what protocols can she give the video to the desktop browser?  Mobile device?  Most likely this will be HTTP streaming, where video frames or JPEG images are transmitted via HTTP.  HTTP streaming, as we know, is not quite suitable for streaming real-time video, although it has proven itself well in on-demand video, where stream interactivity and delay are not particularly important.  In fact, if you watch a movie, delaying a video in a few seconds will not make it worse, unless you watch this movie at the same time as someone else.  "Oh no!  Jack killed her!  - writes Alice in the chat to Bob a spoiler 10 seconds before the tragic denouement ‚Äù. <br><br>  Or it will be RTSP / RTP and H.264, in this case a video player plugin, such as VLC or QuickTime, must be installed in the browser.  This plugin will take and play the video, as the player itself.  But we need a real browser streaming without installing additional crutches / plug-ins. <br><br>  To begin with, take an IP camera to find out what exactly sends this device in the direction of the browser.  As the test will be the camera D-Link DCS 7010L: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33d/3b2/4c3/33d3b24c3ba6ec691943e46a6e16e953.jpg" alt="image"><br><br>  You can read more about installing and configuring the camera below, but here we just see what it uses for video streaming.  When you get into the admin panel of the camera via the web interface, we see something like this (pardonte the landscape): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b8f/6c6/cab/b8f6c6cabd664f9bfd9d6c36ed530af0.jpg" alt="image"><br><br>  The picture opens in all browsers and evenly podlagivaet about once a second.  Considering that both the camera and the laptop on which we are watching the stream are connected to the same router, everything should be smooth and beautiful, but this is not so.  It looks like HTTP.  Launch Wireshark to confirm your guess: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/261/48f/738/26148f738c234375e7a20a99e1253429.jpg" alt="image"><br><br>  Here we see the sequence of TCP fragments with a length of 1514 bytes <br><br><img src="https://habrastorage.org/getpro/habr/post_images/da5/1d1/37b/da51d137b8e1efad191abc3f3ea50edd.jpg" alt="image"><br><br>  and the final HTTP 200 OK with the received JPEG length: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce1/8d3/287/ce18d32877fa258137c19f78a2665957.jpg" alt="image"><br><br>  Next, go to <b>Chrome / Developer Tools / Network</b> and see in real time how GET requests and pictures sent via HTTP flash: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bae/6a4/ca7/bae6a4ca7cc30456c81866ae650e7703.jpg" alt="image"><br><br>  This streaming we do not need.  Not smooth, jerks HTTP requests.  How many such requests per second will the camera handle?  There is reason to believe that at 10 viewers before the camera will safely be bent or begin to terribly fail and issue slides. <br><br>  If you look at the HTML pages of the camera‚Äôs admin panel, you‚Äôll see this interesting code: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(browser_IE) DW(<span class="hljs-string"><span class="hljs-string">'&lt;OBJECT CLASSID="CLSID:'</span></span>+AxUuid+<span class="hljs-string"><span class="hljs-string">'" CODEBASE="/VDControl.CAB?'</span></span>+AxVer+<span class="hljs-string"><span class="hljs-string">'#version='</span></span>+AxVer+<span class="hljs-string"><span class="hljs-string">'" width="0" height="0" &gt;&lt;/OBJECT&gt;'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mpMode == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> RTSPName = g_RTSPName1; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mpMode == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> RTSPName = g_RTSPName2; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mpMode == <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> RTSPName = g_RTSPName3; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o=<span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(g_isIPv6) <span class="hljs-comment"><span class="hljs-comment">//because ipv6 not support rtsp. var host = g_netip; else var host = g_host; o+='&lt;object id="qtrtsp_object" width="0" height="0" codebase="http://www.apple.com/qtactivex/qtplugin.cab" '; o+='classid="clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B" type="video/quicktime"&gt;'; o+='&lt;param name="src" value="http://'+host+":"+g_Port+'/qt.mov" /&gt;'; o+='&lt;param name="autoplay" value="true" /&gt;'; o+='&lt;param name="controller" value="false" /&gt;'; o+='&lt;param name="qtsrc" value="rtsp://'+host+':'+g_RTSPPort+'/'+RTSPName+'"/&gt;'; o+='&lt;/object&gt;'; //alert(o); DW(o); }</span></span></code> </pre> <br><br>  RTSP / RTP is just what you need to play a video properly.  But will it work in a browser?  - Not.  But if you install the QuickTime plugin, everything will work.  But we are doing a clean browser streaming. <br><br>  Here you can also mention Flash Player, which can receive an RTMP stream converted from RTSP, RTP, H.264 via a suitable server like Wowza.  But Flash Player is also known to be a browser plugin, although it is incomparably more popular than VLC or QuickTime. <br><br>  In this case, we will test the same RTSP / RTP re-streaming, but a WebRTC-compatible browser will be used as a playback device without any additional browser plug-ins and other crutches.  We will set up a relay server that will take the stream from the IP camera and give it to the Internet to an arbitrary number of users using WebRTC-enabled browsers. <br><br><h4>  IP camera connection </h4><br>  As mentioned above, a simple IP camera D-Link DCS-7010L was chosen for testing.  The key selection criterion here was device support for the RTSP protocol, since it is for him that our server will take the video stream from the camera. <br><br>  We connect the camera to the router with the supplied patch cord.  After turning on the power and connecting to the router, the camera took the IP address via DHCP, in our case it was 192.168.1.34 (If you go into the settings of the router, you will see that the DCS 7010L device is connected - this is it).  It's time to test the camera. <br><br>  Open the specified IP address in the browser <a href="http://192.168.1.34/">192.168.1.34</a> to get into the web-based administrator interface of the camera.  By default, there is no password. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d37/8d2/89a/d378d289a1ca038570dee98f2a570173.jpg" alt="image"><br><br>  As you can see, in the admin panel video from the camera is broadcast regularly.  At the same time, periodic jerking is noticeable.  This is what we will fix using WebRTC. <br><br><h4>  Camera setup </h4><br>  First, in the camera settings, we disable authentication - as part of testing, we will give the stream to anyone who asks.  To do this, go to the <b>Setup - Network</b> settings in the web interface of the camera and set the value of the <b>Authentication</b> option <b>to Disable</b> . <br><br>  In the same place, we check the value of the port of the RTSP protocol, by default it is equal to 554. The format of the transmitted video is determined by the profile used.  In the camera, you can specify up to three pieces, we will use the first one, live1.sdp - by default it is configured to use H.264 for video and G.711 for audio.  If necessary, you can change the settings in the <b>Setup - Audio and Video</b> section. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c53/2ec/83f/c532ec83fd0f067a2a978f935c97518a.jpg" alt="image"><br><br>  Now you can test the camera via RTSP.  Open VLC Player (you can use any other RTSP-supporting QuickTime, Windows Media Player, RealPlayer, etc.) and in the Open URL dialog set the RTSP camera address: rtsp: //192.168.1.34/live1.sdp <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e20/c62/623/e20c62623fa35be86969a93f3edad952.jpg" alt="image"><br><br>  Well, everything works as it should.  The camera regularly plays the video stream in the player via the RTSP protocol. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/679/67d/e8a/67967de8a1c21a9a003dbbe0e6e46b7d.png" alt="image"><br><br>  By the way, the stream plays quite smoothly and without artifacts.  We are waiting for the same from WebRTC. <br><br><h4>  Server installation </h4><br>  So, the camera is installed, tested with desktop players and ready to be broadcast via the server.  Using whatismyip.com, we define the external IP address of the camera.  In our case, it was 178.51.142.223.  It remains to tell the router that, when accessing via RTSP on port 554, incoming requests are transmitted to the IP camera. <br><br>  We hammer in the corresponding settings in a router ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f9/de2/9d0/1f9de29d061c15e77aef156ddfdb211b.jpg" alt="image"><br><br>  ... and check the external IP address and RTSP port using telnet: <br><br>  telnet 178.51.142.223 554 <br><br>  Making sure that this port is responding, we proceed to install the WebRTC server. <br><br>  For hosting will be responsible virtual server on Centos 64 bit on <a href="http://aws.amazon.com/ec2/">Amazon EC2</a> . <br>  In order not to have performance problems, choose an m3.medium instance with one VCPU: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce0/7c7/e23/ce07c7e231c8df933446e49184e8f957.jpg" alt="image"><br><br>  Yes, yes, there is still Linode and DigitalOcean, but in this case I wanted to make myself amazed. <br>  Looking ahead, I'll write that in the Amazon EC2 control panel you need to add a few rules (forward ports), without which the example will not work.  These are ports for WebRTC (SRTP, RTCP, ICE) traffic and ports for RTSP / RTP traffic.  If you try, the Amazon rules should have something similar for incoming traffic: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c4/ca1/db5/4c4ca1db5890bfef09b7da15beba6ee4.jpg" alt="image"><br><br>  With DigitalOcean, by the way, everything will be easier, just open these ports on the firewall or silence the last one.  According to the latest operating experience of DO instances, they still give out a static IP address and do not bother with NATs, which means that port forwarding is not needed, as in the case of Amazon. <br><br>  We will use WebRTC Media &amp; Broadcasting Server from <a href="http://flashphoner.com/">Flashphoner</a> as the server software that broadcasts the RTSP / RTP stream in WebRTC.  Streaming server is very similar to <a href="http://wowza.com/">Wowza</a> , which can give RTSP / RTP stream to Flash.  The only difference is that this stream will be sent to WebRTC, and not to Flash.  Those.  an honest DTLS will pass between the browser and the server, an SRTP session is established and the stream encoded in VP8 will go to the viewer. <br><br>  We need SSH access to install. <br><br><div class="spoiler">  <b class="spoiler_title">Under the spoiler - a detailed description of the commands executed</b> <div class="spoiler_text">  1. Download the server installation archive: <br>  $ wget <a href="">flashphoner.com/downloads/builds/WCS/3.0/x8664/wcs3_video_vp8/FlashphonerMediaServerWebRTC-3.0/FlashphonerMediaServerWebRTC-3.0.868.tar.gz</a> <br>  2. Deployed: <br>  $ tar -xzf FlashphonerMediaServerWebRTC-3.0.868.tar.gz <br>  3. Installed: <br>  $ cd FlashphonerMediaServerWebRTC-3.0.868 <br>  $. / install.sh <br>  During the installation, the external IP address of the server was entered: 54.186.112.111 and internal 172.31.20.65 (the one that Private IP). <br>  4. Started the server: <br>  $ service webcallserver start <br>  5. Checked the logs: <br>  $ tail - f /usr/local/FlashphonerWebCallServer/logs/server_logs/flashphoner.log <br>  6. Make sure that the server has started and is ready for operation: <br>  $ ps aux |  grep flashphoner <br>  7. Install and run apache: <br>  $ yum install httpd <br>  $ service httpd start <br>  8. Download web-files and place them in the standard Apache folder / var / www / html <br>  cd / var / www / html <br>  $ wget <a href="">github.com/flashphoner/flashphoner_client/archive/wcs_media_client.zip</a> <br>  $ unzip webrtc_media_client.zip <br>  9. Enter the IP address of the server in the config flashphoner.xml: <br>  10. Stopped the firewall. <br>  $ service iptables stop <br></div></div><br><br>  In theory, instead of point 10, it would be correct to set all the necessary ports and firewall rules, but for testing purposes we decided to simply disable the firewall. <br><br><h4>  Server Tuning </h4><br>  Recall that the structure of our WebRTC broadcast is as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8da/ed9/41e/8daed941e517da707799749f8f15e618.png" alt="image"><br><br>  We have already made the installation of the main elements of this diagram, it remains to adjust the interaction arrows. <br><br>  The connection between the browser and the WebRTC server is provided by the web client that is on the <a href="https://github.com/flashphoner/flashphoner_client/tree/wcs_media_client">github</a> :.  A set of JS, CSS and HTML files is simply thrown into <b>/ var / www / html</b> during the installation phase (see paragraph 9 below under the spoiler). <br><br>  The interaction between the browser and the server is configured in the XML configuration file flashphoner.xml.  There you need to enter the IP address of the server so that the web client can connect to the WebRTC server via HTML5 Websockets (point 9 above). <br><br>  Setting up the server ends here, you can check its operation: <br><br>  Open the index.html web-client page in a browser (for this, on the same server, Amazon installed Apache with the command <b>yum -y install httpd</b> ): <br><br> <b><code><a href="http://54.186.112.111/wcs_media_client/%3Fid%3Drtsp"></a> 54.186.112.111/wcs_media_client/?id=rtsp://webrtc-ipcam.ddns.net/live1.sdp</code></b> <br> <br>  Here <b>webrtc-ipcam.ddns.net</b> is a free domain obtained through the dynamic DNS server <a href="http://noip.com/">noip.com</a> , which refers to our external IP address.  We told the router to redirect RTSP requests to 192.168.1.34 in accordance with the rules of NAT network address translation (see also above). <br>  The <b>id = rtsp: //webrtc-ipcam.ddns.net/live1.sdp parameter</b> specifies the URL of the stream to play.  The WebRTC server will request the streams from the camera, process them and give it to the browser for playback via WebRTC.  Maybe your router supports DDNS.  If not, then the IP camera itself has such support: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/acc/e9a/5ba/acce9a5ba09d1bdb2533d20f19d110bc.jpg" alt="image"><br><br>  And so DDNS support looks in the router itself: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c49/fe2/242/c49fe2242d93b2600d7e8b9ad02290a4.jpg" alt="image"><br><br>  Now you can start testing and evaluate the results. <br><br><h4>  Testing </h4><br>  After opening the link, the browser connects to the WebRTC server, which sends the request to the IP camera to receive the video stream.  The whole process takes a few seconds. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/17b/ed4/6a7/17bed46a7cc09a5fb271a75d5c9c04e2.png" alt="image"><br><br>  At this time, the browser connects to the server via webboxes, then the server requests the IP camera via RTSP, receives the H.264 stream via RTP and transcodes it into VP8 / SRTP - which ultimately reproduces the WebRTC browser. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/037/bbb/1da/037bbb1da16c61c5854b613940e5c243.jpg" alt="image"><br><br>  Further, after a short wait, an already familiar picture is displayed. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6dc/b07/e4b/6dcb07e4be50cde9f5a1a1a726dd765c.jpg" alt="image"><br><br>  At the bottom of the video, the URL of the video stream is displayed, which can be copied and opened for viewing from another browser or tab. <br><br><h4>  Make sure that this is really WebRTC. </h4><br>  Suddenly, we were deceived, and the video from the IP camera is going over HTTP again?  We will not idly contemplate the picture, but check that we really get traffic.  Of course, we are again launching Wireshark and the debugging console in Chrome.  In the Chrome browser console, we can observe the following: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/403/db2/553/403db2553de3de32644793274b668076.jpg" alt="image"><br><br>  At this time, nothing flashes and can not see any pictures transmitted via HTTP.  All we see this time is Websocket frames and most of them are ping / pong types for maintaining a Websocket session.  Interesting frames: connect, prepareRtspSession and onReadyToPlay - in this order the connection to the server is established: first connect via Websocket, and then request the stream to play. <br><br>  This is what <b>chrome</b> shows <b>: // webrtc-internals</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/460/524/3fb/4605243fbcc315bdbc362442d1665a17.jpg" alt="image"><br><br>  According to the readings of the graphs, we have a bitrate from the 1Mbps IP camera.  There is also outgoing traffic, most likely these are RTCP and ICE packets.  RTT to Amazon server is about 300 milliseconds. <br><br>  Now let's take a look at Wireshark, there you can clearly see UDP traffic from the server‚Äôs IP address.  In the picture below there are 1468 byte packets.  This is WebRTC.  More precisely, SRTP packets carrying VP8 video frames that we can see on the browser screen.  In addition, STUN requests skip (the lowest packet in the picture) - this WebRTC ICE carefully checks the connection. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b93/975/7c4/b939757c46b144eb87469372ba304d0a.jpg" alt="image"><br><br>  It is also worth noting the relatively low latency (ping to the data center was about 250 ms) video playback.  WebRTC works on SRTP / UDP, and this is the fastest way to deliver packets, unlike HTTP, RTMP and other TCP-like streaming methods.  Those.  the delay seen by the eye should be RTT + browser buffering, decoding and playback time.  Visually, in this case it is - the eye almost does not see the delay, it is less than 500 milliseconds. <br><br>  The next test is to connect other viewers.  I managed to open 10 Chrome windows, and each of them showed a picture.  At the same time, Chrome itself began to blunt a little.  When you open the 11th window on another computer, playback remained smooth. <br><br><h4>  About WebRTC on mobile devices </h4><br>  As you know, WebRTC supports Chrome and Firefox browsers on the Android platform. <br>  Check if our broadcast will be displayed there: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/149/cc2/1b9/149cc21b9a861c1975fc97bd317eb0f4.jpg" alt="image"><br><br>  On the HTC phone, in a Firefox browser, the video from the camera is displayed.  There are no differences in the smoothness of playback from the desktop. <br><br><h4>  Conclusion </h4><br>  As a result, we managed to launch WebRTC online broadcasting from an IP camera to several browsers with minimal effort.  Neither tambourine dances nor rocket-science were required - only basic knowledge of Linux and the SSH console. <br><br>  The broadcast quality was at an acceptable level, and the playback delay was invisible to the eye. <br><br>  Summarizing, we can say that browser WebRTC broadcasts have the right to exist, because  in our case, WebRTC is no longer a crutch or plugin, but a real platform for playing video in a browser. <br><br><h4>  Why don't we see the widespread adoption of WebRTC? </h4><br>  The main brake, perhaps, is the lack of codecs.  WebRTC community and vendors should make an effort and enter the H.264 codec into WebRTC.  There is nothing to say against VP8, but why abandon the millions of compatible devices and software that work with H.264?  Patents, such patents ... <br><br>  In second place, not full support in browsers.  C IE and Safari, for example, the question remains open and there you have to switch to another type of streaming or use a plugin such as webrtc4all. <br><br>  So in the future, we hope to see more interesting solutions, in which transcoding and stream conversion will not be needed and most browsers will be able to play the streams from various devices directly. </div><p>Source: <a href="https://habr.com/ru/post/229243/">https://habr.com/ru/post/229243/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../229229/index.html">A serious loss of Blizzard, adding to the team Oculus Rift and the new publisher of the game Boom Beach - the main mobile news of the week</a></li>
<li><a href="../229231/index.html">We write in C / C ++ in Windows under KolibriOS</a></li>
<li><a href="../229235/index.html">My web-interface management smart apartment</a></li>
<li><a href="../229237/index.html">How-to: How to buy shares of technology companies on the example of "Yandex"</a></li>
<li><a href="../229239/index.html">Samsung launches new SSD-drive based on 3D technology V-NAND</a></li>
<li><a href="../229245/index.html">The native has died. Long live the native!</a></li>
<li><a href="../229247/index.html">Easy and dynamic business logic in JavaScript using Mozilla Rhino</a></li>
<li><a href="../229249/index.html">Anonymous chat rooms. Why they do not have an increase in the audience?</a></li>
<li><a href="../229251/index.html">Sony publishes the source code of the operating system kernel</a></li>
<li><a href="../229253/index.html">Dnepropetrovsk Android Practice Leaders Community Meeting, dedicated to UX, July 10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>