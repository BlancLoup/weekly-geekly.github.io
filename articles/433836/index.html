<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Byte-machine for the fort (and not only) in Indian (Part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let's continue experiments with bytecode. This is a continuation of the article about the byte-machine in assembler, here is the first part . 

 In ge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Byte-machine for the fort (and not only) in Indian (Part 2)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="image"><br><br>  Let's continue experiments with bytecode.  This is a continuation of the article about the byte-machine in assembler, <a href="https://habr.com/post/431932/">here is the first part</a> . <br><br>  In general, I planned in the second part to make the fort interpreter, and in the third - the fort compiler for this byte-machine.  But the volume, which was obtained for the article, turned out to be very large.  To make an interpreter, you need to expand the kernel (a set of byte commands), and implement: variables, string parsing, string input, dictionaries, dictionary lookup ... Well, at least the output of numbers should work.  As a result, I decided to break the article about the interpreter into two.  Therefore, in this article we will expand the core, we will define the variables, we will deduce the numbers.  Further the approximate plan is as follows: the 3rd part is the interpreter, the 4th part is the compiler.  And, of course, performance tests.  They will be in the 4th or 5th article.  These articles will be after the new year. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And who has not been afraid of the terrible assembler and byte-code - welcome under the cat!  :) <br><a name="habracut"></a><br>  To begin with, we will correct the errors.  We assign the file extension .s, as is customary for GAS (thanks to <a href="https://habr.com/users/mistergrim/" class="user_link">mistergrim</a> ).  Then, replace int 0x80 with syscall and use 64-bit registers (thanks to <a href="https://habr.com/users/qw1/" class="user_link">qw1</a> ).  In the beginning, I did not carefully read the call description and corrected only the registers ... and received a Segmentation fault.  It turns out that everything changed for syscall, including the call numbers.  sys_write for syscall is number 1, and sys_exit is 60. As a result, the bad, type and bye commands have the following form: <br><br><pre><code class="cpp hljs">b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov rax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_write mov rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov rsi, offset msg_bad_byte #     mov rdx, msg_bad_byte_len #   syscall #   mov rax, <span class="hljs-number"><span class="hljs-number">60</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_exit mov rbx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> syscall #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov rax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_write mov rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov rsi, offset msg_bye #     mov rdx, msg_bye_len #   syscall #   mov rax, <span class="hljs-number"><span class="hljs-number">60</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">60</span></span> - sys_exit mov rdi, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> syscall #   b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov rax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_write mov rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rsi push r8 syscall #   pop r8 jmp _next</code> </pre> <br>  And one moment.  Quite rightly written in the comments to the last article of <a href="https://habr.com/users/berez/" class="user_link">berez</a> and <a href="https://habr.com/users/fpauk/" class="user_link">fpauk</a> , that if you use the processor address in the bytecode, the bytecode depends on the platform.  And in that example, the string address for ‚ÄúHello, world!‚Äù Was specified in bytecode by value (using the command lit64).  Of course, this is not necessary.  But it was the easiest way to test a byte machine.  I will not do this anymore, but I will receive the addresses of variables by other means: in particular, with the var command (more on this later). <br><br><h4>  Warm up </h4><br>  And now, as a warm-up, we will do all the basic integer arithmetic operations (+, -, *, /, mod, / mod, abs).  We need them. <br><br>  The code is so simple that I quote it in the spoiler without comment. <br><br><div class="spoiler">  <b class="spoiler_title">Arithmetic</b> <div class="spoiler_text"><pre> <code class="cpp hljs">b_add = <span class="hljs-number"><span class="hljs-number">0x21</span></span> bcmd_add: pop rax add [rsp], rax jmp _next b_sub = <span class="hljs-number"><span class="hljs-number">0x22</span></span> bcmd_sub: pop rax sub [rsp], rax jmp _next b_mul = <span class="hljs-number"><span class="hljs-number">0x23</span></span> bcmd_mul: pop rax pop rbx imul rbx push rax jmp _next b_div = <span class="hljs-number"><span class="hljs-number">0x24</span></span> bcmd_div: pop rbx pop rax cqo idiv rbx push rax jmp _next b_mod = <span class="hljs-number"><span class="hljs-number">0x25</span></span> bcmd_mod: pop rbx pop rax cqo idiv rbx push rdx jmp _next b_divmod = <span class="hljs-number"><span class="hljs-number">0x26</span></span> bcmd_divmod: pop rbx pop rax cqo idiv rbx push rdx push rax jmp _next b_abs = <span class="hljs-number"><span class="hljs-number">0x27</span></span> bcmd_abs: mov rax, [rsp] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jge _next neg rax mov [rsp], rax jmp _next</code> </pre></div></div><br>  Traditionally, in a fort, double precision operations are added to ordinary arithmetic and stack operations.  Words for such operations usually begin with the symbol ‚Äú2‚Äù: 2DUP, 2SWAP, etc.  But we have standard arithmetic already 64 digits, and we will not make 128 just today :) <br><br>  Next, add the basic stack operations (drop, swap, root, -root, over, pick, roll). <br><br><div class="spoiler">  <b class="spoiler_title">Stack operations</b> <div class="spoiler_text"><pre> <code class="cpp hljs">b_drop = <span class="hljs-number"><span class="hljs-number">0x31</span></span> bcmd_drop: add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next b_swap = <span class="hljs-number"><span class="hljs-number">0x32</span></span> bcmd_swap: pop rax pop rbx push rax push rbx jmp _next b_rot = <span class="hljs-number"><span class="hljs-number">0x33</span></span> bcmd_rot: pop rax pop rbx pop rcx push rbx push rax push rcx jmp _next b_mrot = <span class="hljs-number"><span class="hljs-number">0x34</span></span> bcmd_mrot: pop rcx pop rbx pop rax push rcx push rax push rbx jmp _next b_over = <span class="hljs-number"><span class="hljs-number">0x35</span></span> bcmd_over: push [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>] jmp _next b_pick = <span class="hljs-number"><span class="hljs-number">0x36</span></span> bcmd_pick: pop rcx push [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>*rcx] jmp _next b_roll = <span class="hljs-number"><span class="hljs-number">0x37</span></span> bcmd_roll: pop rcx mov rbx, [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>*rcx] roll1: mov rax, [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>*rcx - <span class="hljs-number"><span class="hljs-number">8</span></span>] mov [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>*rcx], rax dec rcx jnz roll1 push rbx jmp _next</code> </pre> </div></div><br>  And we will also make reading and writing commands in memory (fortov words @ and!).  As well as their counterparts for another bit. <br><br><div class="spoiler">  <b class="spoiler_title">Reading and writing to memory</b> <div class="spoiler_text"><pre> <code class="cpp hljs">b_get = <span class="hljs-number"><span class="hljs-number">0x40</span></span> bcmd_get: pop rcx push [rcx] jmp _next b_set = <span class="hljs-number"><span class="hljs-number">0x41</span></span> bcmd_set: pop rcx pop rax mov [rcx], rax jmp _next b_get8 = <span class="hljs-number"><span class="hljs-number">0x42</span></span> bcmd_get8: pop rcx movsx rax, byte ptr [rcx] push rax jmp _next b_set8 = <span class="hljs-number"><span class="hljs-number">0x43</span></span> bcmd_set8: pop rcx pop rax mov [rcx], al jmp _next b_get16 = <span class="hljs-number"><span class="hljs-number">0x44</span></span> bcmd_get16: pop rcx movsx rax, word ptr [rcx] push rax jmp _next b_set16 = <span class="hljs-number"><span class="hljs-number">0x45</span></span> bcmd_set16: pop rcx pop rax mov [rcx], ax jmp _next b_get32 = <span class="hljs-number"><span class="hljs-number">0x46</span></span> bcmd_get32: pop rcx movsx rax, dword ptr [rcx] push rax jmp _next b_set32 = <span class="hljs-number"><span class="hljs-number">0x47</span></span> bcmd_set32: pop rcx pop rax mov [rcx], eax jmp _next</code> </pre> </div></div><br>  We may still need comparison commands, and we will do them. <br><br><div class="spoiler">  <b class="spoiler_title">Comparison commands</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># <span class="hljs-number"><span class="hljs-number">0</span></span>= b_zeq = <span class="hljs-number"><span class="hljs-number">0x50</span></span> bcmd_zeq: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz rfalse rtrue: push <span class="hljs-number"><span class="hljs-number">-1</span></span> jmp _next rfalse: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next # <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; b_zlt = <span class="hljs-number"><span class="hljs-number">0x51</span></span> bcmd_zlt: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jl rtrue push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next # <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; b_zgt = <span class="hljs-number"><span class="hljs-number">0x52</span></span> bcmd_zgt: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jg rtrue push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next # = b_eq = <span class="hljs-number"><span class="hljs-number">0x53</span></span> bcmd_eq: pop rbx pop rax cmp rax, rbx jz rtrue push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next # &lt; b_lt = <span class="hljs-number"><span class="hljs-number">0x54</span></span> bcmd_lt: pop rbx pop rax cmp rax, rbx jl rtrue push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next # &gt; b_gt = <span class="hljs-number"><span class="hljs-number">0x55</span></span> bcmd_gt: pop rbx pop rax cmp rax, rbx jg rtrue push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next # &lt;= b_lteq = <span class="hljs-number"><span class="hljs-number">0x56</span></span> bcmd_lteq: pop rbx pop rax cmp rax, rbx jle rtrue push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next # &gt;= b_gteq = <span class="hljs-number"><span class="hljs-number">0x57</span></span> bcmd_gteq: pop rbx pop rax cmp rax, rbx jge rtrue push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next</code> </pre> </div></div><br>  We will not test the operation.  The main thing that the assembler would not give when compiling errors.  Debugging will be in the process of using them. <br><br>  Immediately make the word depth (stack depth).  To do this, at the start, save the initial values ‚Äã‚Äãof the data stack and the return stack.  These values ‚Äã‚Äãcan still be useful when restarting the system. <br><br><pre> <code class="cpp hljs">init_stack: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> init_rstack: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> _start: mov rbp, rsp sub rbp, stack_size lea r8, start mov init_stack, rsp mov init_rstack, rbp jmp _next b_depth = <span class="hljs-number"><span class="hljs-number">0x38</span></span> bcmd_depth: mov rax, init_stack sub rax, rsp shr rax, <span class="hljs-number"><span class="hljs-number">3</span></span> push rax jmp _next</code> </pre> <br><h4>  Output numbers </h4><br>  Well, the warm-up is over, and you have to sweat a little.  Let's teach our system to display numbers.  To output numbers in the fort, the word "."  (point).  We do it the way it is done in standard implementations of the fort, using the words &lt;#, hold, #, #s, #&gt;, base.  We'll have to realize all these words.  A buffer and a pointer to the character being formed are used to form the number; these will be the words holdbuf and holdpoint. <br><br>  So, we need these words: <br><br><ul><li>  <b>holdbuf</b> - a buffer for forming the representation of a number, the formation takes place from the end </li><li>  <b>holdpoint</b> - address to the last displayed character (in holdbuf) </li><li>  <b>&lt;#</b> - the beginning of the formation of a number;  sets holdpoint to byte, after last byte holdbuf </li><li>  <b>hold</b> - decreases holdpoint by 1 and saves the character from the stack to the buffer at the received address </li><li>  <b>#</b> - divides the word at the top of the stack into the base of the number system, the remainder of the division translates into a character and saves it to the buffer using hold </li><li>  <b>#s</b> - converts the entire word;  actually calls the word # in a loop until 0 is left on the stack </li><li>  <b>#&gt;</b> - completion of the conversion;  pushes the beginning of the formed string and its length onto the stack </li></ul><br>  We will do all the words on the byte-code, but first we will deal with variables. <br><br><h4>  Variables </h4><br>  And here there will be some Fort magic.  The fact is that in a fort a variable is a word.  When executing this word, the stack contains the address of the memory cell that stores the value of the variable.  At this address you can read or write.  For example, to write the value 12345 in variable A, you need to execute the following commands: ‚Äú12345 A!‚Äù.  In this example, 12345 is pushed onto the stack, then the variable A puts its address, and the word "!"  removes two values ‚Äã‚Äãfrom the stack and writes 12345 to variable A. In typical implementations of a fort (with direct-stitched code), the variables are a microprocessor command CALL with the _next address, after which a space is reserved for storing the variable value.  When executing such a word, the microprocessor transfers control to _next and pushes the return address (on the RSP) onto the stack.  But in the forte the microprocessor stack is arithmetic, and we will not return anywhere.  As a result, execution continues, and in the stack is the address of the variable.  And all this is one processor team!  On an assembler, it would look like this: <br><br><pre> <code class="cpp hljs"> call _next #   _next,      ,   <span class="hljs-number"><span class="hljs-number">12345</span></span> .quad <span class="hljs-number"><span class="hljs-number">12345</span></span></code> </pre> <br>  But we have a byte code, and we can not use this mechanism!  I did not immediately figure out how to make such a mechanism on bytecode.  But, if you think logically, nothing prevents you from implementing something very similar.  You just have to take into account that this will not be a processor command, but a bytecode, more precisely, a ‚Äúsubroutine‚Äù bytecode.  Here is the statement of the problem: <br><br><ul><li>  this is a byte code, when transferring control to which you should immediately return from it </li><li>  after return, in the arithmetic stack should remain the address where the value of the variable is stored </li></ul><br>  We have an exit byte command.  We make a word on the bytecode containing a single exit command.  Then this command will return from it.  It remains to make the same command, which additionally puts on the stack the address of the next byte (register R8).  Let's do this as an additional entry point to exit, which would save on the transition: <br><br><pre> <code class="cpp hljs">b_var0 = <span class="hljs-number"><span class="hljs-number">0x28</span></span> bcmd_var0: push r8 b_exit = <span class="hljs-number"><span class="hljs-number">0x17</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>]</code> </pre> <br>  Now the base variable will look like this: <br><pre> <code class="cpp hljs">base: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br>  By the way, why var0 and not just var?  The fact is that there will be other commands for defining more advanced words that contain data.  I will tell you more in the following articles. <br><br>  Now we are ready to conclude numbers.  Let's start! <br><br><h4>  Words base, holdbuf, holdpoint </h4><br>  How the variables will be arranged is already decided.  Therefore, the words base, holdbuf, holdpoint are such: <br><br><pre> <code class="cpp hljs">base: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">10</span></span> holdbuf_len = <span class="hljs-number"><span class="hljs-number">70</span></span> holdbuf: .byte b_var0 .space holdbuf_len holdpoint: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  The size of the holdbuf buffer is 70. The maximum number of digits in a number is 64 (this is if you select a binary system).  There is still a reserve of several characters to put, for example, a number sign and a space after it.  We will check for buffer overflow, but for now let's not put extra characters into the buffer.  Then you can make another diagnosis. <br><br><h4>  hold </h4><br>  Now you can make the word hold.  On the fort, its code looks like this: <br><br><pre> <code class="cpp hljs">: hold holdpoint @ <span class="hljs-number"><span class="hljs-number">1</span></span>- dup holdbuf &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop drop <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dup holdpoint ! c! then ;</code> </pre> <br>  For those who see the fort for the first time, I will analyze the code in detail.  For the following words I will not do this. <br><br>  At the beginning there is a word for defining new words and the name of a new word: ": hold".  After that comes the code, which ends with the word ";".  Let's sort the code of the word.  I will give the command and the state of the stack after the command is executed.  Before calling a word on the stack, there is a character code that is placed in the buffer (indicated by &lt;symbol&gt;).  Further it turns out so: <br><br><pre> <code class="cpp hljs">holdpoint &lt;&gt; &lt;  holdpoint&gt; @ &lt;&gt; &lt;  holdpoint&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>- &lt;&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; dup &lt;&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; holdbuf &lt;&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &lt;  holdbuf&gt; &gt; &lt;&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &lt;,    holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>    holdbuf&gt;</code> </pre> <br>  After this is the if command, which is compiled into a conditional transition to a sequence of commands between else and then.  A conditional transition removes the comparison result from the stack and performs the transition if there was a lie on the stack.  If there was no transition, then there is a branch between if and else, in which there are two drop commands that remove the symbol and address.  Otherwise, execution continues.  The word "!"  saves the new value to the holdpoint (the address and value are removed from the stack).  And the word ‚Äúc!‚Äù Writes the character to the buffer, this is the set8 byte-command (the address and the value of the character are removed from the stack). <br><br><pre> <code class="cpp hljs">dup &lt;&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; holdpoint &lt;&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &lt;  holdpoint&gt; ! &lt;&gt; &lt;  holdpoint  <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; c! ,  ,   ! :)</code> </pre> <br>  This is how much action this short sequence of commands does!  Yes, the fort is laconic.  And now we turn on the manual ‚Äúcompiler‚Äù in the head :) And compile it all into bytecode: <br><pre> <code class="cpp hljs">hold: .byte b_call8 .byte holdpoint - . - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-meta"><span class="hljs-meta"># holdpoint .byte b_get # @ .byte b_wm # 1- .byte b_dup # dup .byte b_call8 .byte holdbuf - . - 1 # holdbuf .byte b_gt # &gt; .byte b_qbranch8 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> .byte 0f - . .byte b_drop # drop .byte b_drop # drop .byte b_branch8 #     ( then) .byte 1f - . 0: .byte b_dup # dup .byte b_call8 .byte holdpoint - . - 1 # holdpoint .byte b_set # ! .byte b_set8 # c! 1: .byte b_exit # ;</span></span></code> </pre> <br>  Here I used local labels (0 and 1).  These labels can be accessed by special names.  For example, label 0 can be accessed by name 0f or 0b.  This means a link to the nearest tag 0 (forward or backward).  It is quite convenient for tags that are used locally, so as not to come up with different names. <br><br><h4>  Word # </h4><br>  Make the word #.  On the fort, its code will look like this: <br><br><pre> <code class="cpp hljs">: <span class="hljs-meta"><span class="hljs-meta"># base /mod swap dup 10 &lt; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> c‚Ä≥ 0 + </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> 10 - c‚Ä≥ A + then hold ;</span></span></code> </pre> <br>  The condition here is used to check: is the resulting figure less than ten?  If it is less, numbers 0‚Äì9 are used; otherwise, characters starting with ‚ÄúA‚Äù are used.  This will allow you to work with the hexadecimal number system.  The c ‚Ä≥ 0 sequence pushes the character 0 code onto the stack. We include the ‚Äúcompiler‚Äù: <br><br><pre> <code class="cpp hljs">conv: .byte b_call16 .word base - . - <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-meta"><span class="hljs-meta"># base .byte b_get # @ .byte b_divmod # /mod .byte b_swap # swap .byte b_dup # dup .byte b_lit8 .byte 10 # 10 .byte b_lt # &lt; .byte b_qnbranch8 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> .byte 0f - . .byte b_lit8 .byte </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'0'</span></span></span><span class="hljs-meta"> # c‚Ä≥ 0 .byte b_add # + .byte b_branch8 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> .byte 1f - . 0: .byte b_lit8 .byte </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'A'</span></span></span><span class="hljs-meta"> # c‚Ä≥ A .byte b_add # + 1: .byte b_call16 .word hold - . - 2 # hold .byte b_exit # ;</span></span></code> </pre> <br><h4>  Word &lt;# </h4><br>  The word &lt;# is quite simple: <br><br><pre> <code class="cpp hljs">: &lt;<span class="hljs-meta"><span class="hljs-meta"># holdbuf 70 + holdpoint ! ;</span></span></code> </pre> <br>  Bytecode: <br><br><pre> <code class="cpp hljs">conv_start: .byte b_call16 .word holdbuf - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_lit8 .byte holdbuf_len .byte b_add .byte b_call16 .word holdpoint - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_exit</code> </pre> <br><h4>  Word #&gt; </h4><br>  The word #&gt; to complete the conversion looks like this: <br><br><pre> <code class="cpp hljs">: #&gt; holdpoint @ holdbuf <span class="hljs-number"><span class="hljs-number">70</span></span> + over - ;</code> </pre> <br>  Bytecode: <br><br><pre> <code class="cpp hljs">conv_end: .byte b_call16 .word holdpoint - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_call16 .word holdbuf - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_lit8 .byte holdbuf_len .byte b_add .byte b_over .byte b_sub .byte b_exit</code> </pre> <br><h4>  Word #s </h4><br>  And finally, the word #s: <br><br><pre> <code class="cpp hljs">: <span class="hljs-meta"><span class="hljs-meta">#s do # dup 0= until ;</span></span></code> </pre> <br>  Bytecode: <br><br><pre> <code class="cpp hljs">conv_s: .byte b_call8 .byte conv - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_dup .byte b_qbranch8 .byte conv_s - . .byte b_exit</code> </pre> <br>  Who is attentive, will notice here a slight discrepancy between the byte code and the code of the fort :) <br><br><h4>  All is ready </h4><br>  Now nothing will prevent the word "." From making a number: <br><br><pre> <code class="cpp hljs">: . &lt;# <span class="hljs-meta"><span class="hljs-meta">#s drop #&gt; type ;</span></span></code> </pre> <br>  Bytecode: <br><br><pre> <code class="cpp hljs">dot: .byte b_call8 .byte conv_start - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_call8 .byte conv_s - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_drop .byte b_call8 .byte conv_end - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_type .byte b_exit</code> </pre> <br>  Let's make a test byte code that checks our point: <br><br><pre> <code class="cpp hljs">start: .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">1234</span></span> .byte b_call16 .word dot - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_bye</code> </pre> <br>  Of course, it did not work all at once.  But, after debugging, the following result was obtained: <br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth 1234bye!</code> </pre><br>  The jamb is visible immediately.  After the number, the fort should display a space.  Add after the call conv_start (&lt;#) command 32 hold. <br><br>  Still make a conclusion sign.  At the beginning, we add dup abs, and at the end we check the sign of the left copy and place a minus if the number is negative (0 &lt;if c ‚Ä≥ - hold then).  As a result, the word "."  takes the following form: <br><br><pre> <code class="cpp hljs">: . dup <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span> &lt;# <span class="hljs-number"><span class="hljs-number">32</span></span> hold <span class="hljs-meta"><span class="hljs-meta">#s drop #&gt; 0&lt; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> c‚Ä≥ - hold then type ;</span></span></code> </pre> <br>  Bytecode: <br><br><pre> <code class="cpp hljs">dot: .byte b_dup .byte b_abs .byte b_call8 .byte conv_start - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_lit8 .byte <span class="hljs-string"><span class="hljs-string">' '</span></span> .byte b_call16 .word hold - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call8 .byte conv_s - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_drop .byte b_zlt .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_lit8 .byte <span class="hljs-string"><span class="hljs-string">'-'</span></span> .byte b_call16 .word hold - . - <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_call8 .byte conv_end - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_type .byte b_exit</code> </pre> <br>  In the starting sequence of byte commands, we put a negative number and check: <br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth -1234 bye!</code> </pre><br>  Output numbers there! <br><br><div class="spoiler">  <b class="spoiler_title">Full source</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data init_stack: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> init_rstack: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_call8, bcmd_call16, bcmd_call32, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_qnbranch8, bcmd_qnbranch16,bcmd_bad, bcmd_exit # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_add, bcmd_sub, bcmd_mul, bcmd_div, bcmd_mod, bcmd_divmod, bcmd_abs # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_var0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_dup, bcmd_drop, bcmd_swap, bcmd_rot, bcmd_mrot, bcmd_over, bcmd_pick, bcmd_roll # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_depth, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_get, bcmd_set, bcmd_get8, bcmd_set8, bcmd_get16, bcmd_set16, bcmd_get32, bcmd_set32 # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_zeq, bcmd_zlt, bcmd_zgt, bcmd_eq, bcmd_lt, bcmd_gt, bcmd_lteq, bcmd_gteq #<span class="hljs-number"><span class="hljs-number">0x50</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">-1234</span></span> .byte b_call16 .word dot - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_bye base: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">10</span></span> holdbuf_len = <span class="hljs-number"><span class="hljs-number">70</span></span> holdbuf: .byte b_var0 .space holdbuf_len holdpoint: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> # : hold holdpoint @ <span class="hljs-number"><span class="hljs-number">1</span></span>- dup holdbuf &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop drop <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dup holdpoint ! c! then ; hold: .byte b_call8 .byte holdpoint - . - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-meta"><span class="hljs-meta"># holdpoint .byte b_get # @ .byte b_wm # 1- .byte b_dup # dup .byte b_call8 .byte holdbuf - . - 1 # holdbuf .byte b_gt # &gt; .byte b_qbranch8 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> .byte 0f - . .byte b_drop # drop .byte b_drop # drop .byte b_branch8 #     ( then) .byte 1f - . 0: .byte b_dup # dup .byte b_call8 .byte holdpoint - . - 1 # holdpoint .byte b_set # ! .byte b_set8 # c! 1: .byte b_exit # ; # : # base /mod swap dup 10 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; if c" 0 + else 10 - c" A + then hold ; conv: .byte b_call16 .word base - . - 2 # base .byte b_get # @ .byte b_divmod # /mod .byte b_swap # swap .byte b_dup # dup .byte b_lit8 .byte 10 # 10 .byte b_lt # &lt; .byte b_qnbranch8 # if .byte 0f - . .byte b_lit8 .byte '0' # c" 0 .byte b_add # + .byte b_branch8 # else .byte 1f - . 0: .byte b_lit8 .byte '?' # c" A .byte b_add # + 1: .byte b_call16 .word hold - . - 2 # hold .byte b_exit # ; # : &lt;# holdbuf 70 + holdpoint ! ; conv_start: .byte b_call16 .word holdbuf - . - 2 .byte b_lit8 .byte holdbuf_len .byte b_add .byte b_call16 .word holdpoint - . - 2 .byte b_set .byte b_exit # : #s do # dup 0=until ; conv_s: .byte b_call8 .byte conv - . - 1 .byte b_dup .byte b_qbranch8 .byte conv_s - . .byte b_exit # : #&gt; holdpoint @ holdbuf 70 + over - ; conv_end: .byte b_call16 .word holdpoint - . - 2 .byte b_get .byte b_call16 .word holdbuf - . - 2 .byte b_lit8 .byte holdbuf_len .byte b_add .byte b_over .byte b_sub .byte b_exit dot: .byte b_dup .byte b_abs .byte b_call8 .byte conv_start - . - 1 .byte b_lit8 .byte ' ' .byte b_call16 .word hold - . - 2 .byte b_call8 .byte conv_s - . - 1 .byte b_drop .byte b_zlt .byte b_qnbranch8 .byte 1f - . .byte b_lit8 .byte '-' .byte b_call16 .word hold - . - 2 1: .byte b_call8 .byte conv_end - . - 1 .byte b_type .byte b_exit .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start mov init_stack, rsp mov init_rstack, rbp jmp _next b_var0 = 0x28 bcmd_var0: push r8 b_exit = 0x17 bcmd_exit: mov r8, [rbp] add rbp, 8 _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*8] b_num0 = 0x02 bcmd_num0: push 0 jmp _next b_lit8 = 0x08 bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = 0x09 bcmd_lit16: movsx rax, word ptr [r8] add r8, 2 push rax jmp _next b_call8 = 0x0C bcmd_call8: movsx rax, byte ptr [r8] sub rbp, 8 inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = 0x0D bcmd_call16: movsx rax, word ptr [r8] sub rbp, 8 add r8, 2 mov [rbp], r8 add r8, rax jmp _next b_call32 = 0x0E bcmd_call32: movsx rax, dword ptr [r8] sub rbp, 8 add r8, 4 mov [rbp], r8 add r8, rax jmp _next b_lit32 = 0x0A bcmd_lit32: movsx rax, dword ptr [r8] add r8, 4 push rax jmp _next b_lit64 = 0x0B bcmd_lit64: mov rax, [r8] add r8, 8 push rax jmp _next b_dup = 0x30 bcmd_dup: push [rsp] jmp _next b_wm = 0x20 bcmd_wm: decq [rsp] jmp _next b_add = 0x21 bcmd_add: pop rax add [rsp], rax jmp _next b_sub = 0x22 bcmd_sub: pop rax sub [rsp], rax jmp _next b_mul = 0x23 bcmd_mul: pop rax pop rbx imul rbx push rax jmp _next b_div = 0x24 bcmd_div: pop rbx pop rax cqo idiv rbx push rax jmp _next b_mod = 0x25 bcmd_mod: pop rbx pop rax cqo idiv rbx push rdx jmp _next b_divmod = 0x26 bcmd_divmod: pop rbx pop rax cqo idiv rbx push rdx push rax jmp _next b_abs = 0x27 bcmd_abs: mov rax, [rsp] or rax, rax jge _next neg rax mov [rsp], rax jmp _next b_drop = 0x31 bcmd_drop: add rsp, 8 jmp _next b_swap = 0x32 bcmd_swap: pop rax pop rbx push rax push rbx jmp _next b_rot = 0x33 bcmd_rot: pop rax pop rbx pop rcx push rbx push rax push rcx jmp _next b_mrot = 0x34 bcmd_mrot: pop rcx pop rbx pop rax push rcx push rax push rbx jmp _next b_over = 0x35 bcmd_over: push [rsp + 8] jmp _next b_pick = 0x36 bcmd_pick: pop rcx push [rsp + 8*rcx] jmp _next b_roll = 0x37 bcmd_roll: pop rcx mov rbx, [rsp + 8*rcx] roll1: mov rax, [rsp + 8*rcx - 8] mov [rsp + 8*rcx], rax dec rcx jnz roll1 push rbx jmp _next b_depth = 0x38 bcmd_depth: mov rax, init_stack sub rax, rsp shr rax, 3 push rax jmp _next b_get = 0x40 bcmd_get: pop rcx push [rcx] jmp _next b_set = 0x41 bcmd_set: pop rcx pop rax mov [rcx], rax jmp _next b_get8 = 0x42 bcmd_get8: pop rcx movsx rax, byte ptr [rcx] push rax jmp _next b_set8 = 0x43 bcmd_set8: pop rcx pop rax mov [rcx], al jmp _next b_get16 = 0x44 bcmd_get16: pop rcx movsx rax, word ptr [rcx] push rax jmp _next b_set16 = 0x45 bcmd_set16: pop rcx pop rax mov [rcx], ax jmp _next b_get32 = 0x46 bcmd_get32: pop rcx movsx rax, dword ptr [rcx] push rax jmp _next b_set32 = 0x47 bcmd_set32: pop rcx pop rax mov [rcx], eax jmp _next # 0= b_zeq = 0x50 bcmd_zeq: pop rax or rax, rax jnz rfalse rtrue: push -1 jmp _next rfalse: push 0 jmp _next # 0&lt; b_zlt = 0x51 bcmd_zlt: pop rax or rax, rax jl rtrue push 0 jmp _next # 0&gt; b_zgt = 0x52 bcmd_zgt: pop rax or rax, rax jg rtrue push 0 jmp _next # = b_eq = 0x53 bcmd_eq: pop rbx pop rax cmp rax, rbx jz rtrue push 0 jmp _next # &lt; b_lt = 0x54 bcmd_lt: pop rbx pop rax cmp rax, rbx jl rtrue push 0 jmp _next # &gt; b_gt = 0x55 bcmd_gt: pop rbx pop rax cmp rax, rbx jg rtrue push 0 jmp _next # &lt;= b_lteq = 0x56 bcmd_lteq: pop rbx pop rax cmp rax, rbx jle rtrue push 0 jmp _next # &gt;= b_gteq = 0x57 bcmd_gteq: pop rbx pop rax cmp rax, rbx jge rtrue push 0 jmp _next b_branch8 = 0x10 bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = 0x11 bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = 0x12 bcmd_qbranch8: pop rax or rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = 0x13 bcmd_qbranch16: pop rax or rax, rax jnz bcmd_branch16 add r8, 2 jmp _next b_qnbranch8 = 0x14 bcmd_qnbranch8: pop rax or rax, rax jz bcmd_branch8 inc r8 jmp _next b_qnbranch16 = 0x15 bcmd_qnbranch16:pop rax or rax, rax jz bcmd_branch16 add r8, 2 jmp _next b_bad = 0x00 bcmd_bad: mov rax, 1 #   ‚Ññ 1 - sys_write mov rdi, 1 #  ‚Ññ 1 ‚Äî stdout mov rsi, offset msg_bad_byte #     mov rdx, msg_bad_byte_len #   syscall #   mov rax, 60 #   ‚Ññ 1 - sys_exit mov rbx, 1 #    1 syscall #   b_bye = 0x01 bcmd_bye: mov rax, 1 #   ‚Ññ 1 - sys_write mov rdi, 1 #  ‚Ññ 1 ‚Äî stdout mov rsi, offset msg_bye #     mov rdx, msg_bye_len #   syscall #   mov rax, 60 #   ‚Ññ 60 - sys_exit mov rdi, 0 #    0 syscall #   b_type = 0x80 bcmd_type: mov rax, 1 #   ‚Ññ 1 - sys_write mov rdi, 1 #  ‚Ññ 1 - stdout pop rdx pop rsi push r8 syscall #   pop r8 jmp _next</span></span></span></span></code> </pre></div></div><br><h4>  Total </h4><br>  Now we have a pretty decent core of byte commands: all basic arithmetic, stack operations, comparison operations, work with memory, variables.  Also, there is already an output of numbers, fully implemented in bytecode.  Everything is ready, what would the interpreter do, which we will do in the next article! <br><br>  Happy New Year, everyone! <br><br>  Criticism is welcome!  :) </div><p>Source: <a href="https://habr.com/ru/post/433836/">https://habr.com/ru/post/433836/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433826/index.html">Persimmon 2.0 Instructions for use</a></li>
<li><a href="../433828/index.html">Using QML Map to Build Airways - Part 1</a></li>
<li><a href="../433830/index.html">New LED Lamp Diall</a></li>
<li><a href="../433832/index.html">Formatting Linux source code with ClangFormat: problems and solution</a></li>
<li><a href="../433834/index.html">How Ivan metrics DevOps did. Start</a></li>
<li><a href="../433838/index.html">Biohacker Joshua Seiner Public Letter</a></li>
<li><a href="../433842/index.html">[Friday] ASCII graffiti on retro monitors and other surfaces</a></li>
<li><a href="../433844/index.html">About the three components necessary for the success of IT</a></li>
<li><a href="../433846/index.html">Nuclear power before the NPP</a></li>
<li><a href="../433848/index.html">Apple patent for electric cars</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>