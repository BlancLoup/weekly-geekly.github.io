<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 3 of 6</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Course content 


- Article 1: Bresenham algorithm 
- Article 2: rasterization of the triangle + clipping of the rear faces 
- Article 3: Removing inv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 3 of 6</h1><div class="post__text post__text-html js-mediator-article"><h1>  Course content </h1><br><ul><li>  <a href="http://habrahabr.ru/post/248153/">Article 1: Bresenham algorithm</a> </li><li>  <a href="http://habrahabr.ru/post/248159/">Article 2: rasterization of the triangle + clipping of the rear faces</a> </li><li>  <b>Article 3: Removing invisible surfaces: z-buffer</b> </li><li>  Article 4: Required Geometry: Matrix Festival <br><ul><li>  <a href="http://habrahabr.ru/post/248611/">4a: Construction of perspective distortion</a> </li><li>  <a href="http://habrahabr.ru/post/248723/">4b: we move the camera and what follows from this</a> </li><li>  <a href="http://habrahabr.ru/post/249467/">4c: a new rasterizer and perspective distortion correction</a> </li></ul></li><li>  <a href="http://habrahabr.ru/post/248963/">Article 5: We write shaders for our library</a> </li><li>  <a href="http://habrahabr.ru/post/249139/">Article 6: A little more than just a shader: shadow rendering</a> </li></ul><br><h3>  Code enhancement </h3><br><ul><li>  <a href="http://habrahabr.ru/post/248909/">Article 3.1: It‚Äôs time to refactor</a> </li><li>  <a href="http://habrahabr.ru/post/249101/">Article 3.14: Beautiful Matrix Class</a> </li></ul><br><br><br><hr><h3>  The official translation (with a bit of polishing) is available <a href="https://github.com/ssloy/tinyrenderer/wiki">here.</a> </h3><hr><br><br><h1>  And then what?  I disassembled all the material! </h1>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In articles 7 and 8 we will talk about programming directly under OpenGL.  There is a non-zero chance of getting a short OpenCL / CUDA course in articles 9+. <br><br><h1>  Removing invisible surfaces </h1><br>  Meet, this is my friend z-buffer abstract African head.  It will help us to remove the visual artifacts of discarding the back edges that we had in the previous article. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f0/57a/756/3f057a75601d8ac34555e72ea03ef711.png"><br><br>  By the way, I can not fail to mention that this model, which I use in the tail and in the mane, was kindly provided by the wonderful <a href="https://se.linkedin.com/in/vidarrapp">Vidar Rapp</a> . <br><br>  We can use it exclusively as part of the rendering training.  This is a very high-quality model, which I barbarously treated, but I promise to return her eyes! <br><a name="habracut"></a><br>  In theory, you can not discard the invisible edges, but simply draw everything, starting from the very rear, and ending with the front. <br><br>  This is called <a href="http://en.wikipedia.org/wiki/Painter%2527s_algorithm">an artist algorithm</a> .  Unfortunately, it is very expensive, for each change in the position of the camera you need to re-sort the scene.  And there are also dynamic scenes ... But even this is not the main problem.  The problem is that this is not always possible. <br><br><hr><br><h1>  Before drawing the head, draw what is simpler </h1><br>  Let's imagine the simplest scene of three triangles, the camera looks down on top, we project our triangles on a white screen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d49/3c5/2da/d493c52da4cabe9a057c26f696784956.png"><br><br>  This is how the render of this scene should look like: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/023/668/cb8/023668cb8ea97f59bf87d982c1e8b030.png"><br><br>  The blue side - is it red or in front?  Neither this nor that.  The artist's algorithm breaks down here.  Well, that is, you can split the blue side into two, one part in front of the red one, the other behind.  And the one that is in front of the red, another two - before the green and behind the green ... I think it is quite clear that in scenes with millions of triangles this quickly becomes a daunting task.  Yes, it has solutions, for example, to <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2580%25D0%25B0%25D0%25B7%25D0%25B1%25D0%25B8%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25B0">use binary partitions of space</a> , at the same time it helps to sort when changing the camera position, but let's not complicate our lives! <br><br><hr><br><h1>  Three dimensions are too much.  Y-buffer! </h1><br>  Let's lose one of the dimensions, consider a two-dimensional scene obtained by intersecting our scene and the yellow section plane: <br><img src="https://habrastorage.org/getpro/habr/post_images/d67/3f4/0bc/d673f40bcadbe53f4b3cb29bbbcfb461.png"><br>  That is, our scene consists of three segments (the intersection of the yellow plane and each of the triangles), and its render is a picture <br>  the same width as the normal render, but one pixel high: <br><img src="https://habrastorage.org/getpro/habr/post_images/3d4/c4a/171/3d4c4a1710b8e2558beb5c72ea52a61a.png"><br><br>  <a href="https://github.com/ssloy/tinyrenderer/tree/d9c4b14c0d8c385937bc87cee1178f1e42966b7c">A snapshot of the</a> code, as usual, on a github.  Since we have a two-dimensional scene, it is very easy to draw it, it's just three calls to the line () function, which we programmed for the very first time. <br><br><pre>     {// just dumping the 2d scene (yay we have enough dimensions!)
         TGAImage scene (width, height, TGAImage :: RGB);

         // scene "2d mesh"
         line (Vec2i (20, 34), Vec2i (744, 400), scene, red);
         line (Vec2i (120, 434), Vec2i (444, 400), scene, green);
         line (Vec2i (330, 463), Vec2i (594, 200), scene, blue);

         // screen line
         line (Vec2i (10, 10), Vec2i (790, 10), scene, white);

         scene.flip_vertically ();  // i want to have the bottom corner
         scene.write_tga_file ("scene.tga");
     }
</pre><br><br>  This is what our two-dimensional scene looks like; our task is to look at these segments from above. <br><img src="https://habrastorage.org/getpro/habr/post_images/20e/9d8/742/20e9d8742d17979ec70e45cafacd63a5.png"><br><br>  Let's render it now.  I remind you that the render is a picture that is one pixel wide for the whole scene and one pixel high.  In my code, I declared it at a height of 16, but this is not to break my eyes, considering one pixel on high-resolution screens.  The rasterize function only writes in the first line of the render image. <br><br><pre>         TGAImage render (width, 16, TGAImage :: RGB);
         int ybuffer [width];
         for (int i = 0; i &lt;width; i ++) {
             ybuffer [i] = std :: numeric_limits &lt;int&gt; :: min ();
         }
         rasterize (Vec2i (20, 34), Vec2i (744, 400), render, red, ybuffer);
         rasterize (Vec2i (120, 434), Vec2i (444, 400), render, green, ybuffer);
         rasterize (Vec2i (330, 463), Vec2i (594, 200), render, blue, ybuffer);
</pre><br><br>  So, I declared the mysterious ybuffer array exactly the size of our screen (width, 1).  This array is initialized minus infinity.  Then I pass to the rasterize function both the render image, and this mysterious array.  What does the function look like? <br><br><pre> void rasterize (Vec2i p0, Vec2i p1, TGAImage &amp; image, TGAColor color, int ybuffer []) {
     if (p0.x&gt; p1.x) {
         std :: swap (p0, p1);
     }
     for (int x = p0.x; x &lt;= p1.x; x ++) {
         float t = (x-p0.x) / (float) (p1.x-p0.x);
         int y = p0.y * (1.-t) + p1.y * t;
         if (ybuffer [x] &lt;y) {
             ybuffer [x] = y;
             image.set (x, 0, color);
         }
     }
 }
</pre><br><br>  Very, very simple: I go through all the x-coordinates between p0.x and p1.x and calculate the corresponding y-coordinate of our line. <br>  Then I check that we have in the ybuffer array on this x coordinate.  If the current pixel is closer to the camera than what is stored there, <br>  then I draw it in the picture, and put a new y-coordinate in the multi-buffer. <br><br>  Let's understand in stages: after calling the rasterizer for the first (red) line, this is what we have in mind: <br><br>  screen content: <br><img src="https://habrastorage.org/getpro/habr/post_images/016/94d/604/01694d604755b68c406998c03db374d9.png"><br><br>  y-buffer contents: <br><img src="https://habrastorage.org/getpro/habr/post_images/65d/daf/2b4/65ddaf2b4d87f9b80127ecc6b02d0f72.png"><br>  Here, in ugly purple, minus infinity is marked, these are the places where not a single pixel has been drawn yet. <br>  Everything else is grayscale, because  ybuffer is not a color, but the depth of a given pixel.  The whiter, the closer to the camera was the pixel drawn on the screen. <br><br>  Next we draw the green line, here is the memory after calling its rasterizer: <br><br>  screen content: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f0/81a/c5f/6f081ac5fc77e2ec4bc733c945b16615.png"><br><br>  y-buffer contents: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bae/971/32f/bae97132fc4ae67584b46b03d7350944.png"><br><br>  And finally, the blue: <br><br>  screen content: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d6f/db1/d49/d6fdb1d49161923ac91796967afa766e.png"><br><br>  y-buffer contents: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f4/30d/7de/8f430d7de76bdcbda73b8de2986fbe49.png"><br><br>  Congratulations, we drew our two-dimensional scene!  Once again we will admire the final render: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/249/35d/71a/24935d71a1b0023ee3cb48934fae175d.png"><br><br><hr><br><br><h1>  Three dimensions - this is just right.  Z-buffer! </h1><br>  <a href="https://github.com/ssloy/tinyrenderer/tree/5ff999c9bcb4c960c504058079403817a24b61ee">Snapshot of</a> github <a href="https://github.com/ssloy/tinyrenderer/tree/5ff999c9bcb4c960c504058079403817a24b61ee">code</a> . <br><hr>  Attention: in this article I use the same version of the triangle rasterizer as in the previous one.  An improved version of the rasterizer (the passage of all pixels of the describing rectangle) will soon be kindly provided and described in a separate article by a respected <a href="https://habrahabr.ru/users/gbg/" class="user_link">gbg</a> !  Stay tuned. <br><hr><br><br>  Since our screen is now two-dimensional, the z-buffer should also be two-dimensional: <br><pre> int * zbuffer = new int [width * height];
</pre><br>  I packed a two-dimensional array in one-dimensional, you can convert as usual: <br>  from two coordinates to one: <br><pre> int idx = x + y * width;
</pre><br><br>  Back: <br><pre> int x = idx% width;
 int y = idx / width;
</pre><br><br>  Then in the code I go through all the triangles and make a call to the rasterizer, passing it both a picture and a z-buffer. <br><br><pre> triangle (screen_coords [0], screen_coords [1], screen_coords [2], image, TGAColor (intensity * 255, intensity * 255, intensity * 255, 255), zbuffer);

 [...]

 void triangle (Vec3i t0, Vec3i t1, Vec3i t2, TGAImage &amp; image, TGAColor color, int * zbuffer) {
     if (t0.y == t1.y &amp;&amp; t0.y == t2.y) return;  // i dont care about degenerate triangles
     if (t0.y&gt; t1.y) std :: swap (t0, t1);
     if (t0.y&gt; t2.y) std :: swap (t0, t2);
     if (t1.y&gt; t2.y) std :: swap (t1, t2);
     int total_height = t2.y-t0.y;
     for (int i = 0; i &lt;total_height; i ++) {
         bool second_half = i&gt; t1.y-t0.y ||  t1.y == t0.y;
         int segment_height = second_half?  t2.y-t1.y: t1.y-t0.y;
         float alpha = (float) i / total_height;
         float beta = (float) (i- (second_half? t1.y-t0.y: 0)) / segment_height;  // be careful: here
         Vec3i A = t0 + Vec3f (t2-t0) * alpha;
         Vec3i B = second_half?  t1 + Vec3f (t2-t1) * beta: t0 + Vec3f (t1-t0) * beta;
         if (Ax&gt; Bx) std :: swap (A, B);
         for (int j = Ax; j &lt;= Bx; j ++) {
             float phi = Bx == Ax?  1.: (float) (jA.x) / (float) (Bx-Ax);
             Vec3i P = Vec3f (A) + Vec3f (BA) * phi;
             int idx = P.x + Py * width;
             if (zbuffer [idx] &lt;Pz) {
                 zbuffer [idx] = Pz;
                 image.set (Px, Py, color);
             }
         }
     }
 }
</pre><br>  It's just terrible how much the code looks like a rasterizer from the previous article.  What changed?  (Use vimdiff and see). <br>  Vec2 was replaced by Vec3 in the function call and a check was made if (zbuffer [idx] &lt;Pz); <br>  Everything!  Here is our real render without flaws cut off invisible surfaces: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f93/a1f/c1c/f93a1fc1cbaebb9c4670ae0003e62947.png"><br><br>  Please note that backface culling in my code is left: <br><pre> if (intensity&gt; 0) {
     triangle (screen_coords [0], screen_coords [1], screen_coords [2], image, TGAColor (intensity * 255, intensity * 255, intensity * 255, 255), zbuffer);
 }
</pre><br>  It is not necessary to obtain this picture, it only accelerates the calculations. <br><br><hr><br><br><h1>  Stop, we just interpolated the z-coordinate.  And you can add something else to the load? </h1><br>  Textures!  This will be homework. <br><br>  In the .obj file there are lines vt uv, they define an array of texture coordinates. <br>  The average number between slashes in fx / x / xx / x / xx / x / x is the texture coordinates of a given vertex in a given triangle.  Interpolate them inside the triangle, multiply by the width-height of the texture file and get the color of the pixel from the texture file. <br>  Diffuse texture take <a href="">here</a> . <br><br>  Here is an example of what should happen: <br><img src="https://habrastorage.org/files/737/149/66a/73714966ad4a4377b8c4df60bef03777.png"><br><br><h3>  Update: </h3><br>  Home solution is available <a href="https://github.com/ssloy/tinyrenderer/tree/d7f1bfb932f55711eef405c408c0aff7595c8aa7">here.</a> </div><p>Source: <a href="https://habr.com/ru/post/248179/">https://habr.com/ru/post/248179/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248163/index.html">.NET Developer Skills</a></li>
<li><a href="../248165/index.html">Review of the most interesting materials on data analysis and machine learning ‚Ññ31 (January 12 - 18, 2015)</a></li>
<li><a href="../248169/index.html">A large list of materials for studying Meteor.JS</a></li>
<li><a href="../248173/index.html">The legacy of Jacob Bernoulli in Wolfram Language (Mathematica)</a></li>
<li><a href="../248177/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ143 (January 12 - 18, 2015)</a></li>
<li><a href="../248181/index.html">Home Raspberry shooting gallery</a></li>
<li><a href="../248185/index.html">Car Tutorial Guide (Unity3d) part 2 of 3</a></li>
<li><a href="../248187/index.html">What's new in CSS 4th level selectors?</a></li>
<li><a href="../248189/index.html">Create an environment for PyQt5 in Linux MInt (Ubuntu)</a></li>
<li><a href="../248193/index.html">Deploying CUCM with VMware Workstation 10.0.3 and GNS3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>