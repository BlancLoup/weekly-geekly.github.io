<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LogLog - find the number of unique elements</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! You and I have already indulged in Bloom and MinHash filters . Today, the talk will be about another probabilistic-randomized algorithm t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>LogLog - find the number of unique elements</h1><div class="post__text post__text-html js-mediator-article">  Hello, Habr!  You and I have already indulged in <a href="http://habrahabr.ru/blogs/algorithm/112069/">Bloom</a> and <a href="http://habrahabr.ru/blogs/algorithm/115147/">MinHash filters</a> .  Today, the talk will be about another probabilistic-randomized algorithm that allows determining the approximate number of unique elements in large amounts of data with minimal memory costs. <br><br>  To begin with, we will set ourselves a task: suppose that we have a large amount of textual data - say, the fruits of the literary works of the notorious Shakespeare, and we need to count the number of different words found in this volume.  A typical solution is a counter with a truncated hash table, where the keys are words without associated values. <br><br>  The method is good for everyone, but it requires a relatively large amount of memory for its work, and, as you know, we are restless efficiency geniuses.  Why a lot, if you can little - the approximate size of the vocabulary of the above-mentioned Shakespeare, you can calculate using only 128 bytes of memory. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h4>  Idea </h4><br>  As usual, we will need some kind of hash function, so the algorithm itself will not receive the data itself, but their hashes.  The task of the hash function, as is usually the case in randomized algorithms, is to turn the ordered data into ‚Äúrandom‚Äù, that is, in a more or less uniform spreading of the domain over the range of values.  For the test implementation, I chose <a href="http://en.wikipedia.org/wiki/Fowler_Noll_Vo_hash">FNV-1a</a> as a good and simple hash function: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fnv1a</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash = <span class="hljs-number"><span class="hljs-number">2166136261</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; text.length; ++i) { hash ^= text.charCodeAt(i); hash += (hash &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) + (hash &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + (hash &lt;&lt; <span class="hljs-number"><span class="hljs-number">7</span></span>) + (hash &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + (hash &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Well, let's turn on the brain and look at the hashes that it gives out in binary representation: <br><br> <code>fnv1a('aardvark') = <font color="gray">1001100000000001110100100011001</font> 1 <br> fnv1a('abyssinian') = <font color="gray">00101111000100001010001000111</font> 100 <br> fnv1a('accelerator') = <font color="gray">10111011100010100010110001010</font> 100 <br> fnv1a('accordion') = <font color="gray">0111010111000100111010000001100</font> 1 <br> fnv1a('account') = <font color="gray">00101001010011111100011101011</font> 100 <br> fnv1a('accountant') = <font color="gray">0010101001101111110011110010110</font> 1 <br> fnv1a('acknowledgment') = <font color="gray">0000101000010011100000111110</font> 1000 <br> fnv1a('acoustic') = <font color="gray">111100111010111111100101011000</font> 10 <br> fnv1a('acrylic') = <font color="gray">1101001001110011011101011101</font> 1000 <br> fnv1a('act') = <font color="gray">0010110101001010010001011000101</font> 1</code> <br> <br>  Pay attention to the index of the first non-zero least significant bit for each hash, add a unit to this index and call it rank (rank (1) = 1, rank (10) = 2, ...): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rank</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hash</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((hash &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; r &lt;= <span class="hljs-number"><span class="hljs-number">32</span></span>) { ++r; hash &gt;&gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre> <br>  The probability that we will encounter a hash with rank 1 is 0.5, with rank 2 - 0.25, with rank <i>r</i> - 2 <sup>- <i>r</i></sup> .  In other words, among 2 <sup><i>r</i></sup> hashes, one hash of rank <i>r</i> must be met.  In a completely different way, if you memorize the highest detected rank <i>R</i> , then 2 <sup><i>R will</i></sup> fit as a rough estimate of the number of <i>unique</i> elements among those already viewed. <br><br>  Well, the theory of probability is such that we can find a large rank <i>R</i> in a small sample, or a small one in an enormous sample, and generally 2 <sup>31</sup> and 2 <sup>32</sup> are two big differences, say you are right, that is why such a single estimate very rude.  What to do? <br><br>  Instead of a single hash function, you can use a bundle of them, and then somehow ‚Äúaverage‚Äù the estimates obtained for each of them.  This approach is bad because we will need a lot of functions and we will have to consider them all.  Therefore, we will do the following trick: we will bite off the <i>k</i> high-order bits of each of the hashes, and using the value of these bits as an index, we will calculate not one estimate, but an array of 2 <sup><i>k</i></sup> estimates, and then we will get an integral one based on them. <br><br><h4>  HyperLogLog </h4><br>  In fact, there are several variations of the LogLog algorithm, we will look at a relatively recent version - HyperLogLog.  This version allows to reach the magnitude of the standard error: <br><img src="https://habrastorage.org/storage/habraeffect/84/26/84260deee40899e48198e027ab33cc77.png" alt="standard error"><br>  Therefore, when using 8 high bits as an index, we get a standard error of 6.5% ( <i>œÉ</i> = 0.065) of the true number of unique elements.  And most importantly, if you arm <a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">yourself with the</a> <a href="http://algo.inria.fr/flajolet/Publications/DuFl03.pdf">skill</a> of the theory of probability, you can come to the following final assessment: <br><img src="https://habrastorage.org/storage/habraeffect/14/1d/141da8ea50bda0f765445767f488f5b7.png" alt="assessment"><br>  , where <i>Œ± <sub>m</sub></i> is the correction coefficient, <i>m</i> is the total number of estimates (2 <sup><i>k</i></sup> ), <i>M</i> is an array of the estimates themselves.  Now we know almost everything, it's time to <a href="http://jsfiddle.net/mM6bY/4/">implement</a> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pow_2_32 = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HyperLogLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">std_error</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.log(x) / <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.LN2; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rank</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hash, max</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((hash &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; r &lt;= max) { ++r; hash &gt;&gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-number"><span class="hljs-number">1.04</span></span> / std_error; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.ceil(log2(m * m)), k_comp = <span class="hljs-number"><span class="hljs-number">32</span></span> - k; m = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, k); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> alpha_m = m == <span class="hljs-number"><span class="hljs-number">16</span></span> ? <span class="hljs-number"><span class="hljs-number">0.673</span></span> : m == <span class="hljs-number"><span class="hljs-number">32</span></span> ? <span class="hljs-number"><span class="hljs-number">0.697</span></span> : m == <span class="hljs-number"><span class="hljs-number">64</span></span> ? <span class="hljs-number"><span class="hljs-number">0.709</span></span> : <span class="hljs-number"><span class="hljs-number">0.7213</span></span> / (<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1.079</span></span> / m); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> M = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m; ++i) M[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hash</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = hash &gt;&gt;&gt; k_comp; M[j] = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(M[j], rank(hash, k_comp)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m; ++i) c += <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, M[i]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> E = alpha_m * m * m / c; <span class="hljs-comment"><span class="hljs-comment">// -- make corrections if (E &lt;= 5/2 * m) { var V = 0; for (var i = 0; i &lt; m; ++i) if (M[i] == 0) ++V; if (V &gt; 0) E = m * Math.log(m / V); } else if (E &gt; 1/30 * pow_2_32) E = -pow_2_32 * Math.log(1 - E / pow_2_32); // -- return E; } } return {count: count}; } function fnv1a(text) { var hash = 2166136261; for (var i = 0; i &lt; text.length; ++i) { hash ^= text.charCodeAt(i); hash += (hash &lt;&lt; 1) + (hash &lt;&lt; 4) + (hash &lt;&lt; 7) + (hash &lt;&lt; 8) + (hash &lt;&lt; 24); } return hash &gt;&gt;&gt; 0; } var words = ['aardvark', 'abyssinian', ..., 'zoology']; // 2 336 words var seed = Math.floor(Math.random() * pow_2_32); // make more fun var log_log = HyperLogLog(0.065); for (var i = 0; i &lt; words.length; ++i) log_log.count(fnv1a(words[i]) ^ seed); var count = log_log.count(); alert(count + ', error ' + (count - words.length) / (words.length / 100.0) + '%');</span></span></code> </pre> <br>  Let us estimate how many bytes of memory we use, <i>k</i> is equal to 8, therefore, the array <i>M</i> consists of 256 elements, each of them, conditionally, takes 4 bytes, which totals 1 KB.  Not bad, but I would like less.  If you think about it, you can reduce the size of a unit estimate from the array <i>M</i> - you need only ceil (log2 (32 + 1 - <i>k</i> )) bits, which, for <i>k</i> = 8, is 5 bits.  In total, we have 160 bytes, which is much better, but I promised even less. <br><br>  To be less, you need to know in advance the maximum possible number of unique elements in our data - <i>N.</i>  Indeed, if we know it, there is no need to use all possible bits from the hash to determine the rank, ceil (log2 ( <i>N</i> / <i>m</i> )) bits are sufficient.  Do not forget that from this number we once again need to take the logarithm to get the size of one element of the array <i>M.</i> <br><br>  Suppose that in the case of our small set of words, their maximum number is 3,000, then we need only 64 bytes.  In the case of Shakespeare, we set <i>N</i> equal to 100,000, and we will have the promised 128 bytes with an error of 6.5%, 192 bytes at 4.6%, 768 at 3.3%.  By the way, the actual size of Shakespeare‚Äôs vocabulary is about 30,000 words. <br><br><h4>  Other thoughts </h4><br>  Of course, using small ‚Äúbytes‚Äù, for example, 3 bits each is not very efficient in terms of performance.  In practice, it is better not to go crazy by building rather long chains of bit operations, but to use the usual native bytes for the architecture.  If you do decide to "shallow", do not forget to correct the corrective assessment code. <br><br>  A small spoon of tar, the error <i>œÉ</i> is not the maximum error, but the so-called standard error.  For us, this means that 65% of the results will have an error of no more than <i>œÉ</i> , 95% - no more than 2 <i>œÉ</i> and 99% - no more than 3 <i>œÉ</i> .  It is quite acceptable, but there is always the likelihood of receiving a response with an error greater than expected. <br><br>  <s>Judging by my experiments, one should not get too carried away with its decrease, especially if there is little data.</s>  <s>In this case, the correction procedure begins to work, which does not always cope with its duties.</s>  <s>It seems that the algorithm requires testing and tuning for a specific task, unless, of course, this is not some kind of stupid mistake in my implementation.</s>  <a href="http://habrahabr.ru/blogs/algorithm/119852/">This is not quite true</a> . <br><br>  When using a 32-bit hash function, the algorithm allows to calculate up to 10 <sup>9</sup> unique elements with a minimum achievable standard error of about 0.5%.  In memory, with such an error, you need about 32-64 KB.  In general, LogLog is ideal for on-line work with live data streams. <br><br>  That's all.  Until! </div><p>Source: <a href="https://habr.com/ru/post/119852/">https://habr.com/ru/post/119852/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../119845/index.html">iPhone 5 and new display</a></li>
<li><a href="../119846/index.html">ASUS Ukraine Dissociative Identity Disorder ...</a></li>
<li><a href="../119848/index.html">Linus discusses Linux Kernel 2.8 or 3.0</a></li>
<li><a href="../119850/index.html">Creating a programming language using LLVM. Part 1: Introduction and Lexical Analysis</a></li>
<li><a href="../119851/index.html">JavaScript FAQ: ask questions</a></li>
<li><a href="../119854/index.html">Should CRM and ERP systems be integrated</a></li>
<li><a href="../119856/index.html">How we talked about the return of the brand with VKontakte, Facebook, Twitter and Youtube</a></li>
<li><a href="../119857/index.html">Digest Wanted.VC # 3</a></li>
<li><a href="../119861/index.html">ICQ (MailRu) started testing a client under Linux</a></li>
<li><a href="../119862/index.html">Itanium-based HP Integrity users join forces to influence Oracle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>