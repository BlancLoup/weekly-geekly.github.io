<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java EE Concurrency API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 And here we are indulging with buns, launching the second stream of the Java Enterprise Developer course. The permanent creator and teacher ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java EE Concurrency API</h1><div class="post__text post__text-html js-mediator-article"> Hello! <br><br>  And here we are <s>indulging with buns,</s> launching the second stream of <a href="https://otus.pw/Foxx/">the Java Enterprise Developer</a> course.  The permanent creator and teacher of the course, <a href="https://otus.pw/8tiY/">Vitaly Ivanov</a> , wrote an article on this subject even which we hope will seem useful to you :) <br><br>  So let's go :) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This article explores the JavaEE Concurrency API ( <a href="https://www.jcp.org/en/jsr/detail%3Fid%3D236">JSR 236</a> ) API, which defines the standard for executing parallel tasks in a JavaEE container using the concept of managed resources.  The release of the seventh version of JavaEE made it possible to run parallel tasks in Enterprise containers, providing the developer with convenient tools and utilities for working with multitasking.  Until that very moment, all multitasking was left at the mercy of the specific implementation of the application server used, independently deciding on the optimization of task execution.  Violation of this principle was regarded as a bad practice of building an enterprise application architecture.  As a result, the developer was not recommended to create new threads, and sometimes similar behavior was prohibited at the container level. <br><br><img src="https://habrastorage.org/webt/k4/qq/by/k4qqbyksdbtsvyaceyok4sx3jgw.png"><a name="habracut"></a><br>  <i>Manage threads.</i>  <i>It is a priority or a name.</i>  <i>Enterprise bean</i> <br><br>  <i>(free translation of the author: EJBs should not try to control threads, namely, try to start, stop, suspend, or restore their execution, or change the priority or change the name of the stream. Also, EJBs should not try to manage groups of threads).</i> <br><br>  In fact, prohibiting the creation of your own threads in JavaEE containers is problematic, but with this approach, the ‚Äúbackground‚Äù container services cannot guarantee the correctness of their work.  For example, closing a transaction upon the completion of an EJB method could potentially work incorrectly in the case of running tasks in a new thread using Threads heirs (or Runnable implementations) from JavaSE.  Also, the use of basic interface types from the Executor API delivery, such as ExecutorService and ScheduledExecutorService, when created using Executors class static methods, would lead to potential errors and disrupting the order of execution of container services. <br><br>  From the JavaEE specification-recommended tools for asynchronous execution of tasks, the developer had at his disposal the use of asynchronous Stateless / Statefull EJB and / or Message Driven bins, which have enough capabilities for a certain range of tasks and most importantly that the management of which is entirely and entirely controlled by the application server, namely the EJB container. <br><br>  However, as noted earlier, thanks to <a href="https://www.jcp.org/en/jsr/detail%3Fid%3D236">JSR 236</a> , container-managed resources have emerged that implement support for multithreading and asynchronous task execution, extending the capabilities of the <code>java.util.concurrent</code> package from JavaSE.  For the JavaEE stack, the classes of managed resources are located in the <code>javax.enterprise.concurrent</code> package, while access to the objects of these classes is through resource embedding using the <code>@Resource</code> annotation, or through the JNDI context (in particular, InitialContext).  At the same time, the possibility of using the Future / ScheduledFuture / CompletableFuture objects, which are usual for a multithreaded environment, inside JavaEE applications was added. <br><br>  So, quite lyric and let's take a closer look at each of the managed resources provided by the specification from a practical point of view, namely in terms of use in the application code of the application, as well as in terms of configuring resources on the example of the Glassfish 5 application server. <br><br>  Well, the ManagedExecutorService class is selected first in the review queue, which (already understanding from the name) extends the capabilities of the usual JavaSE ExecutorService and is intended for asynchronous execution of tasks in the JavaEE environment. <br><br>  To configure within the Glassfish application server, not only this type of ExecutorService, refer to the domain.xml configuration file, whose location is defined by the $ {GLASSFISH_HOME} / domains / &lt;domain_name&gt; / config directory.  A fragment of this file is presented below: <br><br><pre> <code class="java hljs">&lt;domain application-root=<span class="hljs-string"><span class="hljs-string">"${com.sun.aas.instanceRoot}/applications"</span></span> version=<span class="hljs-string"><span class="hljs-string">"25"</span></span> log-root=<span class="hljs-string"><span class="hljs-string">"${com.sun.aas.instanceRoot}/logs"</span></span>&gt; &lt;resources&gt; &lt;context-service object-type=<span class="hljs-string"><span class="hljs-string">"system-all"</span></span> jndi-name=<span class="hljs-string"><span class="hljs-string">"concurrent/__defaultContextService"</span></span> /&gt; &lt;managed-executor-service object-type=<span class="hljs-string"><span class="hljs-string">"system-all"</span></span> jndi-name=<span class="hljs-string"><span class="hljs-string">"concurrent/__defaultManagedExecutorService"</span></span> /&gt; &lt;managed-scheduled-executor-service object-type=<span class="hljs-string"><span class="hljs-string">"system-all"</span></span> jndi-name=<span class="hljs-string"><span class="hljs-string">"concurrent/__defaultManagedScheduledExecutorService"</span></span> /&gt; &lt;managed-thread-factory object-type=<span class="hljs-string"><span class="hljs-string">"system-all"</span></span> jndi-name=<span class="hljs-string"><span class="hljs-string">"concurrent/__defaultManagedThreadFactory"</span></span> /&gt; &lt;/resources&gt; &lt;servers&gt; &lt;server config-ref=<span class="hljs-string"><span class="hljs-string">"server-config"</span></span> name=<span class="hljs-string"><span class="hljs-string">"server"</span></span>&gt; &lt;resource-ref ref=<span class="hljs-string"><span class="hljs-string">"concurrent/__defaultContextService"</span></span> /&gt; &lt;resource-ref ref=<span class="hljs-string"><span class="hljs-string">"concurrent/__defaultManagedExecutorService"</span></span> /&gt; &lt;resource-ref ref=<span class="hljs-string"><span class="hljs-string">"concurrent/__defaultManagedScheduledExecutorService"</span></span> /&gt; &lt;resource-ref ref=<span class="hljs-string"><span class="hljs-string">"concurrent/__defaultManagedThreadFactory"</span></span> /&gt; &lt;/server&gt; &lt;/servers&gt; &lt;/domain&gt;</code> </pre> <br>  By accessing the Glassfish 5 admin panel interface, configuring <br><br>  ManagedExecutorService looks like this: <br><br><img src="https://habrastorage.org/webt/ov/ik/wt/ovikwtidsmbgljlxmelboniomzy.png"><br><br>  In this section, it is allowed to create new resources of the same type, manage existing ones, delete, and also lock and unlock. <br><br>  For lovers of console administration, Glassfish provides a powerful utility asadmin, using which the <code>create-managed-executor-service</code> command allows you to create new ManagedExecutorService resources: <br><br><img src="https://habrastorage.org/webt/en/cp/nx/encpnxc2gn7fobfzuyhsgnw8jba.png"><br><br>  In the application code, to get a reference to the object created by the ManagedExecutorService, it is more convenient to use resource injection, but you can also use JNDI tools, as shown below: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Resource</span></span>(lookup = <span class="hljs-string"><span class="hljs-string">"concurrent/OtusExecutorService"</span></span>) ManagedExecutorService executor; InitialContext context = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InitialContext(); ManagedExecutorService managedExecutorServiceWithContext = (ManagedExecutorService) context.lookup( <span class="hljs-string"><span class="hljs-string">"concurrent/OtusExecutorService"</span></span>);</code> </pre><br>  I would like to draw the reader‚Äôs attention to the fact that, for the <code>@Resource</code> annotation <code>@Resource</code> the lookup parameter is optional and if it is not defined by the developer in the application code, then the container injects default resources with the prefix <code>__default</code> in the name.  In this case, for the developer, the code becomes even more concise: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService executor;</code> </pre> <br>  After getting the reference to this object, using the <code>execute()</code> and <code>submit()</code> methods, you can run tasks inside the container that implement the Runnable or Callable interface. <br><br>  Turning to the example, I would like to note that among all the variety of possible cases, the tasks of particular interest are those performed in a distributed JavaEE environment and in which it is important to ensure support for transactionality in a multi-threaded environment.  As you know, JavaEE has developed the JTA (Java Transaction API) specification, which allows you to define transaction boundaries, explicitly starting with the <code>begin()</code> method and completing with the <code>commit()</code> methods, committing changes, or <code>rollback()</code> , rolling back the actions taken. <br><br>  Consider an example of a task that returns a message from a certain list of one hundred elements, by index in a user transaction: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransactionSupportCallableTask</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> messageIndex; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TransactionSupportCallableTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> messageId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>. messageIndex = messageId; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ UserTransaction tx = lookupUserTransaction(); String message = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { tx.begin(); message = getMessage(messageIndex); tx.commit(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { e.printStackTrace(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { tx.rollback(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e1) { e1.printStackTrace(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> message; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> UserTransaction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookupUserTransaction</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } }</code> </pre> <br>  The code of the servlet that displays the message on the list at a randomly selected index: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@WebServlet</span></span>(<span class="hljs-string"><span class="hljs-string">"/task"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManagedExecutorServiceServlet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpServlet</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span>(lookup = <span class="hljs-string"><span class="hljs-string">"concurrent/OtusExecutorService"</span></span>) ManagedExecutorService executor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ServletException, IOException </span></span>{ Future&lt;String&gt; futureResult = executor.submit(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TransactionSupportCallableTask(Random.nextInt(<span class="hljs-number"><span class="hljs-number">100</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!futureResult.isDone()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Thread.sleep(<span class="hljs-number"><span class="hljs-number">50</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { e.printStackTrace(); } } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { response.getWriter().write(<span class="hljs-string"><span class="hljs-string">"Callable task has received message with following content '"</span></span> + futureResult.get() + <span class="hljs-string"><span class="hljs-string">"'"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Exception e) { e.printStackTrace(); } } }</code> </pre> <br>  The next resource to be selected is the ManagedScheduledExecutorService resource, the main purpose of which is to schedule tasks that are repeated with a certain periodicity or require deferred execution. <br><br><img src="https://habrastorage.org/webt/6t/85/k3/6t85k3th4xfxgvefxm9tahhxjus.png"><br><br>  From the point of view of configuring this resource through the GlassFish administration console, no special changes were detected in comparison with the previous type: <br><br><img src="https://habrastorage.org/webt/ks/jq/g6/ksjqg6dvumoskfqcclnkm2x6_lc.png"><br><br>  To quickly create a resource with the ManagedScheduledExecutorService type, the <code>asadmin</code> utility has the <code>create-managed-scheduled-executor-service</code> command <br><br><img src="https://habrastorage.org/webt/bd/zh/22/bdzh22mgi708cpcwtchliflffh4.png"><br><br>  In the application code, we still use resource injection: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Resource</span></span>(lookup = <span class="hljs-string"><span class="hljs-string">"concurrent/OtusScheduledExecutorService"</span></span>) ManagedScheduledExecutorService scheduledExecutor;</code> </pre> <br>  The main methods for performing tasks for this type of ExecutorService are <code>schedule()</code> , which accepts tasks like Runnable or Callable as input, and <code>scheduleAtFixedRate()</code> , which additionally determines the initial delay in task execution and specifies the interval of repetitions in TimeUnit (seconds, minutes, etc. .). <br><br>  The previous case can be rewritten as follows: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@WebServlet</span></span>(<span class="hljs-string"><span class="hljs-string">"/scheduledTask"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManagedScheduledExecutorServiceServlet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpServlet</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span>(lookup = <span class="hljs-string"><span class="hljs-string">"concurrent/OtusScheduledExecutorService"</span></span>) ManagedScheduledExecutorService scheduledExecutor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ServletException, IOException </span></span>{ ScheduledFuture&lt;String&gt; futureResult = scheduledExecutor.schedule( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TransactionSupportCallableTask(Random.nextInt(<span class="hljs-number"><span class="hljs-number">100</span></span>)), <span class="hljs-number"><span class="hljs-number">5</span></span>, TimeUnit.SECONDS); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!futureResult.isDone()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Thread.sleep(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Wait } catch (InterruptedException e) { e.printStackTrace(); } } try { response.getWriter().write("Callable task received message with following content '" + futureResult.get() + "'"); } catch ( Exception e) { e.printStackTrace(); } } }</span></span></code> </pre> <br>  Also, the Concurrency API for the Enterpise environment provides the ability to create managed threads.  For these tasks, you should use the capabilities of a managed thread factory that implements its functionality through the ManagedThreadFactory class of the same name and which is also accessed via the JNDI service: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedThreadFactory factory;</code> </pre> <br>  The administration window for the Glassfish console looks ‚Äúold fashioned‚Äù: <br><br><img src="https://habrastorage.org/webt/c5/7n/dr/c57ndr_iu3zewecd6f_zte8vjsi.png"><br><br>  Using a managed thread factory, it is possible not only to provide the container with thread control mechanisms, but also to initialize the properties of the threads generated: set names and prioritize, which can seriously simplify the search for problems when dumping threads later, easily finding the order of execution of previously named threads. <br><br>  In our case, we define the class of the stream that displays information about the friend with which the task is inseparably linked to the console: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleThreadTask</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String friend; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimpleThreadTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String friend)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.friend = friend; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> + friend); } }</code> </pre> <br>  Let the servlet start a thread and report it at the output: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@WebServlet</span></span>(<span class="hljs-string"><span class="hljs-string">"/thread"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManagedThreadFactoryServlet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpServlet</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedThreadFactory factory; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ServletException, IOException </span></span>{ Thread thread = factory.newThread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleThreadTask(<span class="hljs-string"><span class="hljs-string">"Otus"</span></span>)); thread.setName(<span class="hljs-string"><span class="hljs-string">"ManagedThreadFromPool"</span></span>); thread.setPriority(<span class="hljs-number"><span class="hljs-number">7</span></span>); thread.start(); response.getWriter().write(<span class="hljs-string"><span class="hljs-string">"Custom thread has been running."</span></span>); } }</code> </pre><br>  Turning to the final JavaEE multithreading capabilities of Context Services, it should be noted that these services create dynamic context proxies.  We all are well aware of the dynamic proxies from JavaSE ( <code>java.lang.reflect.Proxy</code> ), which allow generating dynamic implementations of the required interfaces, whose capabilities are actively used for the tasks of creating database connections and transaction management, are used for various AOP interceptors and so on.  Moreover, for proxies created via JavaEE contextual services, it is supposed to work within the framework of a common JNDI context, a security context and a container class wizard. <br><br>  To connect the service it is enough to use the code: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ContextService service;</code> </pre> <br>  From the point of view of administration and configuration of this resource, everything is extremely familiar and similar to the types already considered: <br><br><img src="https://habrastorage.org/webt/ql/n6/vw/qln6vwb5bbsk_e3sxner_vwjzsc.png"><br><br>  Below is an example of a thread that runs a proxy task in the context of a container: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleProxyTask</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Subject subject = Subject.getSubject(AccessController.getContext()); logInfo(subject.getPrincipals()); //    calculateSmth(); } private void calculateSmth() { ‚Ä¶ } private void logInfo(Set&lt;Principal&gt; subject) { ‚Ä¶ } }</span></span></code> </pre> <br>  Stateless EJB Bin for creating context proxies: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextServiceBean</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ContextService service; <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService executor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Runnable task)</span></span></span><span class="hljs-function"> </span></span>{ Runnable proxy = service.createContextualProxy(task, Runnable.class); executor.submit(proxy); } }</code> </pre> <br>  Finally, the code of the servlet performing the task: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@WebServlet</span></span>(<span class="hljs-string"><span class="hljs-string">"/context"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextServiceServlet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpServlet</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> ContextServiceBean contextServiceBean; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ServletException, IOException </span></span>{ contextServiceBean.perform(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SampleProxyTask()); } }</code> </pre> <br>  This actually ends the JavaEE developer‚Äôs ability to work in a multi-threaded environment.  Thanks to them, all processes and services occurring in the container will be under the strict control of the server, coordinating their work and not disturbing the usual order of execution.  For the target tasks of an Enterprise developer, these opportunities are often enough and in the eighth version this API has not changed. <br><br>  THE END <br><br>  As always, we are waiting for questions and comments, and be sure to check out <a href="https://otus.pw/8tiY/">Vitaly</a> for <a href="https://otus.pw/4KAF/">an open lesson</a> , where you can also ask questions and listen / participate in the topic ‚ÄúCDI in action @ </div><p>Source: <a href="https://habr.com/ru/post/421809/">https://habr.com/ru/post/421809/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../421799/index.html">How to get remotely in a company that does not take remote employees?</a></li>
<li><a href="../421801/index.html">The author of the BetterSlack extension withdraws it at the request of Slack lawyers</a></li>
<li><a href="../421803/index.html">UPS and battery array: where to put? Wait you</a></li>
<li><a href="../421805/index.html">Dive into Ethereum development. Part 0: blockchain is not needed</a></li>
<li><a href="../421807/index.html">Take part in the public testing of the service of Positive Technologies for finding vulnerabilities on websites</a></li>
<li><a href="../421811/index.html">IETF proposed a new standard for messaging - what you need to know</a></li>
<li><a href="../421815/index.html">Liquid metal in the laptop six months later</a></li>
<li><a href="../421817/index.html">Working with forms in React.js using basic tools</a></li>
<li><a href="../421819/index.html">ELK Stack for storing Django application logs</a></li>
<li><a href="../421821/index.html">We apply Voronoi mosaic, pixelation and geometric masks in shaders to decorate the site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>