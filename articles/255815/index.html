<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Centralized collection of Windows event logs, without installing an agent, followed by visualization using ELK</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The task of centralized processing of logs is quite simply formulated and arises when it is necessary to monitor the work of a large number of servers...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Centralized collection of Windows event logs, without installing an agent, followed by visualization using ELK</h1><div class="post__text post__text-html js-mediator-article">  The task of centralized processing of logs is quite simply formulated and arises when it is necessary to monitor the work of a large number of servers.  I think it is not worth mentioning that from logs you can get a lot of information about the vital activity and well-being of systems.  The fact that writing and reading logs is just as important as being able to write programs. <br><br>  Accordingly, for the implementation of such a system, the administrator is tasked with: firstly, how to collect these logs, secondly, how to work with them conveniently and centrally.  Thanks to a sufficiently developed bundle of ELK (Elasticsearch + Logstash + Kibana), more than once described on Habr√©, the administrator has the tools to easily search and display all the information present in the logs.  Therefore, the answer to the second problem exists initially, and it remains only to solve the problem of collecting logs. <br><br>  Since, in my case, the requirement for the system was the lack of a client on the servers, and the fact that the logs needed to be pulled from Windows servers, the powershell was chosen as the native Windows tool. <br>  Based on this, the following model for collecting and displaying information from logs was compiled: logs are remotely collected from the powershell script servers, and then stored as files in the storage, then using ELK (Elasticsearch + Logstash + Kibana) they are processed and displayed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      An example of the operation of the entire bundle is shown in the image: <br><br><img src="https://habrastorage.org/files/c9c/8d1/7b4/c9c8d17b4b674701b7d1c4a94e0cdb7c.png"><br><a name="habracut"></a><br>  Preventing criticism, I will describe that this system does not set the task of collecting logs in real-time, the goal is only statistics that are collected for a certain period of time, and then displayed on the dashboard.  It is used to come in the morning, see how the servers behaved themselves at night, and compare them with the results obtained, say, last week.  In the proposed system, logs are collected once per hour, respectively, the lag between the current logs and what is output (to be exact, displayed and displayed on request) on the dashboard can be about an hour. <br><br>  Currently, powershell has two ways to get logs from a remote computer: <br><br><ul><li>  native powershell command: Get-EventLog -ComputerName $ computer ‚ÄìLogName System </li><li>  getting logs via WMI query: Get-WmiObject -Class win32_NTLogEvent -filter "logfile = 'System'" -ComputerName $ computer </li></ul><br>  But in the first case, the file is completely pumped with the event-logs of the system and only then they are processed on the computer where the script is executed.  As a result, such requests are processed unnecessarily long.  The possibility of sampling the logs (for example, only in the last 24 hours) does not work very well here, since the entire file is initially pulled out and only then some work is done with it. <br><br>  In the second case, a WMI request is sent to the server, processing occurs on the server side and the key point here is that it is possible to limit the interval of the logs of interest to us already at the request stage (in the example below, the interval is set at 1 hour).  Since this command works much faster than the first one, and the execution time of the request directly depends on the requested log spacing, I chose Get-WmiObject. <br><br>  In the script below, there are several unobvious and difficult points: <br>  First, the logic for limiting the time interval is described for sampling logs, when logs are required for the last hour, but not in the hour since the request, but in the last full hour, i.e.  starting at 00 min.  and ending 59 min. <br>  The second point is that the time in the WMI format is different from the usual format, so it is always necessary to convert to WMI time format and back. <br><br><div class="spoiler">  <b class="spoiler_title">ServersEventLogs.ps1</b> <div class="spoiler_text"><pre><code class="bash hljs">Clear-Host <span class="hljs-comment"><span class="hljs-comment">#     Active Directory (   powershell       Active Directory) import-module activedirectory $computers = Get-ADComputer -SearchBase "OU=Servers,DC=domain,DC=ru" -Filter * | ForEach-Object {$_.Name} | Sort-Object #     $logdir = "\\storage\Logs\ServersLog\" + $(Get-Date -UFormat "%Y_%m") #   ,   if((Test-Path $logdir) -eq 0) { New-Item -ItemType directory $logdir -Force } #         $domain = "domain" $username = "username" $password = 'password' $account = "$domain"+"\"+$($username) $accountpwd = ConvertTo-SecureString $password -AsPlainText -Force $credential = New-Object System.Management.Automation.PsCredential($account, $accountpwd) #  ,      ,          :   -  ,   -   . #   : # BiginDate = 08/26/2014 12:00:00 # EndDate = 08/26/2014 13:00:00 #          BiginDate = 08/26/2014 12:00:00  EndDate = 08/26/2014 13:00:00 $date = Get-Date Write-Host "Date = $date" $m = $date.Minute $s = $date.Second $begindate = (($date.AddSeconds(-$s)).AddMinutes(-$m)).addHours(-1) Write-Host "BiginDate = $begindate" $enddate = ($date.AddSeconds(-$s)).AddMinutes(-$m) Write-Host "EndDate = $enddate" #     WMI $wmibegindate=[System.Management.ManagementDateTimeConverter]::ToDMTFDateTime($begindate) Write-Host "WMIBiginDate = $wmibegindate" $wmienddate=[System.Management.ManagementDateTimeConverter]::ToDMTFDateTime($enddate) Write-Host "WMIEndDate = $wmienddate" $logjournals = "System", "Application", "Security" foreach ($computer in $computers) { Write-Host "Processing computer: $computer" foreach ($logjournal in $logjournals) { Write-Host "Processing log: $logjournal" $systemlog = Get-WmiObject -Class win32_NTLogEvent -filter "logfile = '$logjournal' AND (TimeWritten&gt;='$wmibegindate') AND (TimeWritten&lt;'$wmienddate')" -computerName $computer -Credential $credential -ErrorAction SilentlyContinue foreach ($logstring in $systemlog) { $wmitime = $logstring.TimeGenerated $time = [System.Management.ManagementDateTimeconverter]::ToDateTime("$wmitime") #Write-Host $logtime $level = $logstring.Type #Write-Host "$level" $journal = $logstring.LogFile #Write-Host "$journal" $category = $logstring.CategoryString #Write-Host "$category" $source = $logstring.SourceName #Write-Host "$source" $message = $logstring.Message #Write-Host "$message" $code = $logstring.EventCode #Write-Host "$code" @{Server="$computer";Time="$time";Level="$level";Journal="$journal";Category="$category";Source="$source";Message="$message";Code="$code"} | ConvertTo-Json -depth 10 -Compress | Out-File "$logdir\$computer-$logjournal.json" -Encoding utf8 -Append } } }</span></span></code> </pre> <br></div></div><br>  Upon completion of the script, the output is the following files: ComputerName-JournalName.json. <br>  The json format somewhat does not conform to the standard (there are no opening and closing parentheses), but the Logstash parser normally digests and processes it.  Three files are generated for each server: ComputerName-System.json ComputerName-Application.json ComputerName-Security.json Since the files have the same format, their processing is identical. <br><br>  You can limit log collection to a specific log by simply editing the line: $ logjournals = ‚ÄúSystem‚Äù, ‚ÄúApplication‚Äù, ‚ÄúSecurity‚Äù <br><br>  Logstash comes next with the following configuration: <br><br><div class="spoiler">  <b class="spoiler_title">ServersEventLogs.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs">input { file { <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"ServersLogs"</span></span> discover_interval =&gt; 1800 path =&gt; [ <span class="hljs-string"><span class="hljs-string">"//storage/Logs/ServersLog/*/*.json"</span></span> ] codec =&gt; <span class="hljs-string"><span class="hljs-string">"json"</span></span> } } filter { date { <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"ServersLogs"</span></span> match =&gt; [ <span class="hljs-string"><span class="hljs-string">"Time"</span></span>, <span class="hljs-string"><span class="hljs-string">"MM/dd/YYYY HH:mm:ss"</span></span> ] locale =&gt; <span class="hljs-string"><span class="hljs-string">"en"</span></span> target =&gt; <span class="hljs-string"><span class="hljs-string">"Logtimestamp"</span></span> } mutate { gsub =&gt; [ <span class="hljs-string"><span class="hljs-string">"Level"</span></span>, <span class="hljs-string"><span class="hljs-string">"[ -]"</span></span>, <span class="hljs-string"><span class="hljs-string">"_"</span></span> ] gsub =&gt; [ <span class="hljs-string"><span class="hljs-string">"Source"</span></span>, <span class="hljs-string"><span class="hljs-string">"[ -]"</span></span>, <span class="hljs-string"><span class="hljs-string">"_"</span></span> ] gsub =&gt; [ <span class="hljs-string"><span class="hljs-string">"Server"</span></span>, <span class="hljs-string"><span class="hljs-string">"[ -]"</span></span>, <span class="hljs-string"><span class="hljs-string">"_"</span></span> ] remove_field =&gt; [<span class="hljs-string"><span class="hljs-string">"message"</span></span>] remove_field =&gt; [<span class="hljs-string"><span class="hljs-string">"host"</span></span>] } } output { elasticsearch { embedded =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> host =&gt; <span class="hljs-string"><span class="hljs-string">"logserver"</span></span> protocol =&gt; <span class="hljs-string"><span class="hljs-string">"http"</span></span> cluster =&gt; <span class="hljs-string"><span class="hljs-string">"windowseventlogs"</span></span> codec =&gt; <span class="hljs-string"><span class="hljs-string">"plain"</span></span> index =&gt; <span class="hljs-string"><span class="hljs-string">"windowseventlogs-%{+YYYY.MM.dd}"</span></span> } }</code> </pre><br></div></div><br>  The data is entered into Elasticsearch, from where it is subsequently displayed using Kibana. <br><br>  As a result, information is displayed on the screen (in my case for the last 2 days): about the most problematic servers, about the most problematic services;  a graph is drawn in which you can immediately see an increase in the number of logs or errors at a particular point in time.  You can always search by error text or user name, or sort by error level or id. </div><p>Source: <a href="https://habr.com/ru/post/255815/">https://habr.com/ru/post/255815/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255803/index.html">How I did an English simulator, which is used not only by my mother</a></li>
<li><a href="../255805/index.html">MS Lync: Personal Call Identification</a></li>
<li><a href="../255807/index.html">Inno Setup: creating an installer using the example of deploying a C # application</a></li>
<li><a href="../255809/index.html">Localization of WPF pages</a></li>
<li><a href="../255813/index.html">Factorial Calculation or the Power of the Stream API</a></li>
<li><a href="../255817/index.html">Unlock Open Source 2GIS</a></li>
<li><a href="../255819/index.html">How-to: Rules for the layout of email-letters</a></li>
<li><a href="../255821/index.html">How a hybrid cloud works using VMware vCloud Connector</a></li>
<li><a href="../255823/index.html">Laboratory penetration testing "Test lab v.7". Challenge thrown</a></li>
<li><a href="../255825/index.html">SQL Language Tutorial (DDL, DML) on the example of MS SQL Server dialect. Part three</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>