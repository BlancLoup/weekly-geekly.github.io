<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Do it yourself: MSc Computer Science at the level of top American universities from home</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 I have long wanted to write an article about education in Computer Science, but my hands did not reach. I finally decided to do it. So,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Do it yourself: MSc Computer Science at the level of top American universities from home</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  I have long wanted to write an article about education in Computer Science, but my hands did not reach.  I finally decided to do it.  So, what will be discussed?  It's about what MSc Computer Science diploma at top US universities (in full detail, including core courses, books and projects) and how to comply with it. <br><br>  Why MSc?  This is a kind of fork: on the one hand, after MSc, you are an engineer who is already ready for life (yes, we are talking about engineering training, I think this is the most painful place in our education system), on the other hand, you can safely follow the PhD path.  As you know, you can get into the PhD program and not really knowing how to program - this is especially true for theoretical Computer Science.  On the other hand, finding a programmer‚Äôs job is also not very difficult, and often does not require a powerful education.  But reaching the level of MSc - you get the opportunity to understand how all the new ideas in Computer Science, and the opportunity to put them into practice.  That is, on the one hand, it's cool to sort out some deep learning and do something new in it, as well as take and write your operating system (who did that?).  And you are not clamped into the framework of a narrow specialization (unless of course you continue to learn).  So you are now a universal soldier, ready for anything. <br><br>  I hope this article will be useful: <br>  1. Students who want to meet the high standards of top US universities, or are going there to graduate school in Computer Science <br>  2. Professionals who want to close the "holes" and gaps <br>  3. Maybe someone from the teachers will take a note for their courses. <br>  4. Students, graduate students of American universities - I would also like to receive feedback, especially with regard to the latest trends in education 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What will be written here?  Minimum philosophy and general thoughts: a specific program of undergraduate and graduate courses, of course from the disciplines closest to me.  All courses were personally felt in their own skin, so I am writing about it.  (I tried to enroll in all the interesting courses that were, but my main focus is system programming, databases and artificial intelligence. Of course, there is some bias, but I try to offer a more or less universal program). <br><a name="habracut"></a><br><h4>  Content </h4><br>  1. Basic training <br>  2. Undergraduate program <br>  3. Graduate program <br>  4. Ready to check yourself?  Computer Science Comps. <br><br><h4>  Basic training </h4><br>  The first step is to go through math.  The generally accepted theory in the Russian academic environment is that our mathematics is very, very cool, and we are ahead of the rest.  But the line between theoretical Computer Science and mathematics is thin, and further, we will not call everything that is included in Computer Science.  Well, in Computer Science, our successes in recent years, alas ... <br><br>  In a nutshell, the essence is this - even though there is not much mathematics, you should not go too far.  We need to get a hybrid education - a mixture of a scientist and an engineer, and do it in a finite time.  Therefore, mathematics should be minimized.  For a lot of interesting things are in Computer Science. <br><br>  - Analysis - a confident mastery of the basics will be fine, that is, multidimensional analysis must be understood, but it is not necessary to go deeply with all the evidence <br>  - Linear algebra - you need to understand well, a very necessary thing everywhere.  Moreover, it is desirable at a fairly advanced level (eigenvectors, singular decomposition, conjugate gradients) <br>  - Difury - you can safely neglect, very rarely where you need them <br>  - Optimization is very useful, especially in machine learning this is just an iron requirement <br>  - Algebras, topologies, etc. - on the one hand, it is terribly useful, but on the other - it seems to me to study it mathematically, abstractly, without direct application - you can learn when you need it (for example, relational algebra or category theory for type systems ) and the necessary properties and principles have already been studied in conjunction with practice <br>  - Logic, set theory - I think that it is necessary to understand the basics.  ZFC must be taken. <br>  - The theory of probability, statistics - at a minimum from classical mathematics, it is better to learn what is needed for Computer Science in the context of machine learning, and you risk digging into what is not particularly useful <br>  - Game theory is a useful thing, but superficial knowledge will last long <br>  - Functional analysis, variational methods - very cool, but to study only if pripret, for example in machine learning <br>  - Numerical methods - only if you want to do them later <br><br>  Everything else is either not math, but Computer Science, or not (until needed for a specific case) <br><br><h4>  Programming languages </h4><br>  A controversial topic, there is a lot of choice, I propose such a minimal gentlemanly set: <br><br>  - assembler - you need to own some assembler, because we have to make our own compiler.  There are several options: <br><ul><li>  RISC is a good thing, but where to get it, just emulate, is not very convenient.  But if you adjust the environment - then RISC </li><li>  LLVM is a useful thing, but it simplifies a lot of things, not 100% iron. </li><li>  x86 is terrible, but gcc -S is very nice to use right on your laptop. </li><li>  JVM bytecode - did not try to generate, probably there is a convenient way.  But, if you use JVM a lot later, it can be very useful. </li></ul><br><br>  - C ++ / Java - unfortunately in system programming you cannot get away from these.  But the maximum need to do without them. <br>  - Python - quickly build something, test a hypothesis, cool libraries, especially in machine learning and math + basic pieces from functional programming <br>  - Scala - a practical functional language, if desired, you can go down and close enough to the gland.  A lot of all the system already written on Scala.  It should be the main workhorse. <br><br>  (SQL, Prolog - naturally too, but these are small tongues) <br><br>  Let's start? <br><br><h4>  Undergraduate </h4><br>  The course will be considered as one quarter - 3 months.  Skip all intro programming courses. <br><br>  <b>1. Discrete mathematics (do not forget that this is no longer mathematics)</b> <br>  Combinatorics, graph theory, discrete ter.  ver., recurrence relations, function generators. <br><br>  In fact, this is usually the initial course, you can watch online, for example at MIT: <br>  <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/">ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010</a> <br><br>  All this can be missed and mastered in other courses (as time does not press).  But it can become boring, and this is bad. <br><br>  <b>2. Algorithms and data structures</b> <br>  Starting from any sorting, hash tables, different trees, then algorithms on graphs (Djikstra, min cut / max flow). <br>  On conceptual knowledge: assessment of complexity in O notation, greedy algorithms, dynamic programming. <br>  Additional topics: linear programming, algorithms for strings, random algorithms. <br>  The very first beginning of the theory of complexity. <br><br>  Book: <a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844">www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844</a> <br><br>  Dynamic programming is omnipresent, trees must be understood, the lower bound must be able to be derived for sorting.  Purely theoretical course, tasks in textbooks there.  In general, quite simply, it does not take too long. <br><br>  PS Algorithms go on in each subject area, and return to the general course only in the graduate program. <br>  But you can immediately recommend a book on random algorithms (recently a colleague advised, so far only flipped through, but it seems very competent), it is graduate level, but you should start diving early: <a href="http://www.designofapproxalgs.com/index.php">www.designofapproxalgs.com/index.php</a> <br><br>  <b>3. Theory of Computation</b> <br>  Here I am promoting Sipser, in general a great book - must read, and it is also suitable for the graduate program. <br>  <a href="http://www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/113318779X">www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/113318779X</a> <br><br>  This is a super-important course, it will lay the foundation for everything else.  Sipser is very intuitive, logical and connected.  (Recently I looked through Kolmogorov - they immediately understand that it‚Äôs better not to enter without a level in Mechmatovo. Sipster has, on the contrary, a minimum of requirements, a minimum of formalization, only the most necessary, and everything becomes very accessible). <br><br>  We start with the definition of a ‚Äútask‚Äù - in Sipser this is a language.  That is, many lines.  The algorithm is something that says on any line - yes / no.  This concept goes all the work.  Further, the hierarchy of languages: regular, context-independent, computable, enumerable, noncomputable.  Also very well presented is complexity - P, NP, NP-complete, NP-hard, co-NP + random classes. <br><br>  In addition to good theoretical training, we get excellent skills: <br>  We work with finite automata and regulars <br>  We work with grammars and with a machine with a stack. <br>  We program in the Turing machine - it really needs to be done, it is fun, it widens the mind. <br>  You can program by car here, even have breakpoints!  <a href="http://morphett.info/turing/turing.html">morphett.info/turing/turing.html</a> <br>  We learn to prove which tasks are unsolvable, with the most convenient and fastest ways. <br>  Playing with reductions - transferring one task to another - also greatly expands the mind <br><br>  The course is purely theoretical, excellent tasks, those with asterisks can break the brain <br>  For example: we will prove that the Turing machine becomes a finite state machine in power, if we forbid it to rewrite the input characters on the tape. <br><br>  <b>4. Mathematical logic and set theory</b> <br>  Usually not included in the program Computer Science, but I think you need to learn.  I studied this book, a very simple book, very pleasant: <br>  <a href="http://www.amazon.com/Elements-Set-Theory-Herbert-Enderton/dp/0122384407">www.amazon.com/Elements-Set-Theory-Herbert-Enderton/dp/0122384407</a> <br><br>  <b>Everything, on this purely theoretical training in undergraduate Computer Science is complete, now - applied courses</b> <br><br><h4>  5. Compilers (2 quarters) </h4><br>  Book: <a href="http://en.wikipedia.org/wiki/Compilers">en.wikipedia.org/wiki/Compilers</a> : _Principles, _Techniques, _and_Tools <br><br>  Much has already been mastered from the theory of computing, here the whole emphasis on practice.  Our task is to make a real compiler from a serious language to an assembler.  For example, we were given <a href="http://en.wikipedia.org/wiki/Object-Oriented_Turing">en.wikipedia.org/wiki/Object-Oriented_Turing</a> , but something more interesting is possible. <br><br>  - Parsing: you need to take something reasonable, like JavaCC or ANTLR. <br>  - Transfer to AST <br>  - Semantic analysis: light, although it can be confused with type systems <br>  - Code generation <br><br>  If there is time and energy, add Intermediate Language and a little bit of optimization, the simplest one. <br><br>  As a result, we perfectly understand how the compiler works, how the function call is implemented, how to make objects, methods, arrays and so on. <br><br>  Note: we had to write everything in C ++, but in the modern world it is absolutely not necessary for educational purposes.  On the other hand, if the compiler is written on Python or Scale (ANTLR can work with python, I don‚Äôt know what Scala is - if someone knows a good tool, please suggest. I tried to understand what Spark SQL uses, but didn‚Äôt dig it) much more interesting with the least loss. <br><br>  <b>6. Architecture</b> <br>  Book: <a href="http://www.amazon.com/Computer-Architecture-Fifth-Edition-Quantitative/dp/012383872X">www.amazon.com/Computer-Architecture-Fifth-Edition-Quantitative/dp/012383872X</a> <br><br>  Well here it is - read, do puzzles.  But if there is a possibility, it would be nice to design a mini-CPU. <br>  On something like: <a href="http://www.logiccircuit.org/">www.logiccircuit.org</a> <br><br>  <b>7. Advanced data structures</b> <br>  Not sure what good books are here, but it would be nice to make your own disk indexes: <br>  - B-tree <br>  - Linear hash <br>  - R-tree <br><br>  Everything is tough here, C ++.  But you can not bother, unless you want to build a database / search engines. <br><br>  <b>8. Operating systems (2 quarters)</b> <br>  Here I have this approach - read the book: <a href="http://www.amazon.com/Operating-System-Concepts-Abraham-Silberschatz/dp/0470128720">www.amazon.com/Operating-System-Concepts-Abraham-Silberschatz/dp/0470128720</a> , but only for the sake of general concepts.  But really learn the OS this way: <br><br>  Take Nachos: <a href="http://en.wikipedia.org/wiki/Not_Another_Completely_Heuristic_Operating_System">en.wikipedia.org/wiki/Not_Another_Completely_Heuristic_Operating_System</a> (or Nachos 5.0j) and write your own modules: <br>  - Synchronization primitives <br>  - Library of threads <br>  - Multi-processing <br>  - Mini Shell <br>  - Virtual Memory <br>  - file system <br><br>  Note: this is certainly pretty hardcore, but worth it.  Probably better to take Nachos 5.0j, debugging virtual memory, which is not very pleasant in the memory problem itself. <br><br>  After such an exercise, there will be no mystery about operating systems. <br><br>  <b>9. Databases (2 quarters)</b> <br>  We read the book: <a href="http://www.amazon.com/Database-Systems-Complete-Book-Edition/dp/0131873253">www.amazon.com/Database-Systems-Complete-Book-Edition/dp/0131873253</a> <br>  We do the next project: we write the SQL engine on top of a simple repository, if there is not enough time, we do it like MySQL - we run AST.  If there is more time, we translate it into relational algebra and add an optimization pair (some rule-based). <br><br>  Note: again, at one time I had to do everything in C ++ / lex / yacc.  Time has gone ahead, if done on Python or Scala, much more can be done with less losses.  Or take immediately more interesting query language, for example OQL or SQL ++. <br><br>  <b>10. Artificial Intelligence</b> <br>  AI - in my eyes has always been and will be the most interesting area in Computer Science, since there they always solve very complex problems.  At the same time, as soon as something starts to work out well, it stops being an AI and stands out as a separate discipline.  In general, we read a wonderful book, and we are doing 2-3 projects. <br>  <a href="http://www.amazon.com/Artificial-Intelligence-Modern-Approach-Edition/dp/0136042597">www.amazon.com/Artificial-Intelligence-Modern-Approach-Edition/dp/0136042597</a> <br><br>  Recommended projects: <br>  - A * search for the problem 8-queens or something else, tinker with heuristics <br>  - theorem proving (resolution theorem proving) <br>  - make an effective conclusion for the Baes network <br>  - implement the temporary logic of Alain <br>  - self-learn to play checkers or play mini-max games of chess (counting wood) <br><br>  Hardcore: you can do all the tasks in the Probabilistic Graphical Models course, but this is more for the postgraduate level. <br><br>  <b>11. Machine learning</b> <br>  Without this topic now in any way.  I don‚Äôt know which tutorial is better for undergrad, but ideally to master Bishop: <br>  <a href="http://www.amazon.com/Pattern-Recognition-Learning-Information-Statistics/dp/0387310738">www.amazon.com/Pattern-Recognition-Learning-Information-Statistics/dp/0387310738</a> <br><br>  Here is the class Andew Ng at Stanford for undergrad, not to be confused to the class on the Curser, completely different levels: <br>  <a href="http://cs229.stanford.edu/">cs229.stanford.edu</a> <br><br>  And I found just wonderful lectures on YouTube (mathematicalmonk): <a href="http://www.youtube.com/playlist%3Flist%3DPLD0F06AA0D2E8FFBA">www.youtube.com/playlist?list=PLD0F06AA0D2E8FFBA</a> <br><br>  <b>12. Computer graphics</b> <br>  Not really necessary, but each programmer once wanted to write his own game, so you have to take it for fun and talk for beer. <br>  Not sure what good books are now. <br>  We wrote a piece of OpenGL in C, very useful - it gives an idea how all 3D engines work. <br>  You can even write your own Ray-Tracer - also a cool thing. <br><br>  <b>13. Computer networks</b> <br>  Missed this course, but there is a very good course on the Cursor. <br>  <a href="https://www.coursera.org/course/comnetworks">www.coursera.org/course/comnetworks</a> <br><br>  <b>14. Distributed systems</b> <br>  Strongly intersect with operating systems, but a lot of their important pieces. <br>  I would just read a book, especially key concepts, and not specific systems: <br>  <a href="http://www.amazon.com/Distributed-Systems-Concepts-Design-Edition/dp/0132143011">www.amazon.com/Distributed-Systems-Concepts-Design-Edition/dp/0132143011</a> <br><br>  Synchronization, global system state, consensus, transactions, etc.  Now all sorts of MPP systems have become very popular, here are the basics on which they hold (or do not hold, I am preparing a popular article about all sorts of fashionable databases). <br><br>  <b>15. Programming languages</b> <br>  Such a course often comes across, but usually it is a waste of time imo.  At this point, a compiler has been written for Turing and SQL, everything is clear.  You can get stuck with something like Haskell or ML.  As an option, examine XQuery for a small expansion of consciousness. <br><br>  <b>Here I would finish the undergrad program, you have a diploma B.Sc., congratulations.</b> <br><br>  Or you can go in breadth: Security / Cryptography, Scientific Programming, bore in AI: Computational Lingustics for example.  What do we have after such a program?  You can safely go to work, but there are still gaps in the theoretical basis.  You can fill in everything yourself, but you can continue to study at M.Sc. <br><br>  <b>Graduate</b> <br><br>  Graduate school in Computer Science is not our graduate school.  Here you continue to study for a couple of years and pass a comprehensive exam, in the case of a PhD in 5 disciplines, that is, you need to keep a very serious basis in your head at this moment.  Very useful exercise (I passed on MSc on the 3rd, it is much easier). <br><br>  And specialization begins very quickly.  But let's get the basics: <br><br>  <b>1. Algorithms</b> <br>  The same as in undergrad, but already really, deeper, plus randomization. <br>  Here, as if there is no universally recognized book, I advise you to climb on the websites of universities.  That is, many are costing articles, slides, etc. <br>  Well, random algorithms are our everything.  So open the book: <a href="http://www.designofapproxalgs.com/index.php">www.designofapproxalgs.com/index.php</a> <br><br>  <b>2. Computation Theory, Essentially Pure Complexity Theory</b> <br>  You can cover Sipser, and try to read something else.  We had Papadimitrou, but this is certainly not for the faint of heart.  There are mostly some reductions, there used to be NP-complete, now there are many in random classes. <br><br>  Still, if you like logic, it makes sense to read Descriptive Complexity: <a href="http://people.cs.umass.edu/~immerman/book/descriptiveComplexity.html">people.cs.umass.edu/~immerman/book/descriptiveComplexity.html</a> <br><br>  <b>3. Architecture</b> <br>  The same book, but in an adult way.  You can build some advanced CPU. <br><br>  Next is specialization by and large.  I would advise such areas, but this is my bias: <br><br>  <b>4. Machine learning</b> <br>  At the level of graduate school, you can take Bishop (he himself has not passed all of it), and the theory of machine learning <br>  I like the good old: <a href="http://www.amazon.com/An-Introduction-Computational-Learning-Theory/dp/0262111934">www.amazon.com/An-Introduction-Computational-Learning-Theory/dp/0262111934</a> <br>  But probably already much more relevant are the books. <br><br>  And you can hang on the cursor: <br>  - Probabilistic Graphical Models <br>  - Another very good Natural Language Processing course from Columbia University <br>  - Modern neural networks: <a href="https://class.coursera.org/neuralnets-2012-001">class.coursera.org/neuralnets-2012-001</a> <br><br>  <b>5. Database Theory</b> <br>  <a href="http://www.e-booksdirectory.com/details.php%3Febook%3D7942">www.e-booksdirectory.com/details.php?ebook=7942</a> <br>  This is a very exciting field, everything is mixed here: Logic, Model theory, Complexity, Descriptive Complexity, even game theory have been exploited.  The book is quite heavy and formal, but worth it, at least selectively read and do the exercises. <br><br>  <b>What is missing?</b> <br>  There is absolutely nothing about formal methods, well, it's a complicated thing.  In theory, between set theory, artificial intelligence and database theory + descriptive complexity - there is all the tools for verification and evidence, so this course should already be purely applied.  If you have experience of such a course - it would be very interesting to learn. <br><br>  Internet math - well, this is also a slightly separate topic, but the whole base is laid. <br><br>  <b>Everything, if you get here, doing projects and solving problems, we can assume that you have reached the level of M.Sc.</b>  <b>in Computer Science at the top universities in the world.</b> <br><br>  <b>Let's pass the test?</b> <br><br>  You can search the network for ‚ÄúComputer Science Comprehensive Exam‚Äù or something like that, and you can find real M.Sc. exams.  and Ph.D. <br><br>  I decided not to post the links, so as not to scorch once again, as they are usually not very spread. <br><br>  PS That's all.  Probably something is outdated, but the basics always remain relevant. <br><br>  PPS Of course, sitting at home on the couch is difficult to master such a program.  Doing exercises and big projects is especially difficult.  It is also very difficult without a university environment (but it can also be difficult at the university ‚Äî nights in the laboratory are a private phenomenon).  But!  - everything is possible.  All the above books (well, almost all) are written as simply as possible, they require a minimum of preliminary knowledge, they immediately show how to apply this knowledge, in general they are very suitable for independent study.  Courses on a course or lecture notes from universities are also very useful, it takes much less effort to see a lecture than reading a book, solving problems, etc. <br><br>  PPPS Tips for professionals who have ‚Äúforgotten everything‚Äù are clamped in their niche, but they want to go out again to the bleeding edge: he went through it himself, there is a clouding of brains and it seems that everything is lost and there is no hope.  But in essence, this is how to start playing sports after several years of unhealthy food - we start small, set short goals, rejoice at the slightest progress, and quite satisfied all the formulas will become clear again, the general worldview will be built again, and you can feel yourself like a student / graduate student again. <br><br>  University sites: <br><br>  Stanford: <a href="https://cs.stanford.edu/">cs.stanford.edu</a> <br>  MIT: <a href="https://www.eecs.mit.edu/">www.eecs.mit.edu</a> <br>  UC Berkeley: <a href="http://www.cs.berkeley.edu/">www.cs.berkeley.edu</a> <br>  UC San Diego: <a href="http://cs.ucsd.edu/">cs.ucsd.edu</a> (my alma mater, well, not yet # 4, but crawling up every year!) </div><p>Source: <a href="https://habr.com/ru/post/251747/">https://habr.com/ru/post/251747/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../251717/index.html">What is SBC (Border Controller Sessions) and why is it needed?</a></li>
<li><a href="../251721/index.html">Install Drupal 7.x + modules + localization in a few minutes</a></li>
<li><a href="../251723/index.html">Create your first desktop application with HTML, JS and Node-WebKit</a></li>
<li><a href="../251729/index.html">Practice functional JavaScript programming using Ramda</a></li>
<li><a href="../251745/index.html">MongoDB 3 Announcement</a></li>
<li><a href="../251749/index.html">FindBugs 3.0.1 released</a></li>
<li><a href="../251751/index.html">Proof of the incorrect sorting algorithm Android, Java and Python</a></li>
<li><a href="../251755/index.html">Visualize it</a></li>
<li><a href="../251757/index.html">Work on the modernization of the explorer in ReactOS completed</a></li>
<li><a href="../251759/index.html">Some interesting and useful things for web developer # 40</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>