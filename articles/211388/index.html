<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Search for routes for 1 person-month</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One day, our project required routing functionality. We do not have a lot of programmers, but rather the opposite, so we wanted to find some kind of r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Search for routes for 1 person-month</h1><div class="post__text post__text-html js-mediator-article">  One day, our project required routing functionality.  We do not have a lot of programmers, but rather the opposite, so we wanted to find some kind of ready-made solution, we searched and did not find anything good. <br><br>  We had the road graph data, but in such a way that it is not so easy to submit them to any library or some middle-ware.  And, frankly, we did not find the middle-ware for navigation, so that it was simply integrated into our system (thanks, if someone tells you where to look).  Therefore, they decided to make their own, using the maximum existing libraries for everything. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0fa/a62/2d2/0faa622d2cbf2c0f4f4a6811423bd8c9.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      On the process of developing the service and tell. <a name="habracut"></a><br><br>  <b>About the graph.</b> <br><br>  A few words about the data.  We receive data from a third-party supplier; we cannot influence the format and composition of data.  Road data is in the form of a ArcView (Shapefile) file.  All streets are divided into segments from the intersection to the intersection, each segment attributes are associated: <br>  - unique segment identifier <br>  - geometric polyline depicting a road segment <br>  - data on the allowed maximum speed of traffic rules <br>  - data on the possibility of reversal at the beginning and end of the segment <br>  - a sign of one-way traffic on the segment <br>  - Z is the level of the beginning and end of the segment (for example, the entrance to the overpass has a level 0 at the beginning and a level 1 at the end) <br><br>  In addition, there is a separate file with motion restrictions imposed by logic and / or traffic regulations.  Each restriction is a vector of identifiers that refer to street segments (from the first file), the consecutive movement of which is prohibited. <br><br>  An example of how it all looks, hangs in the title of the post (red - bans, unfortunately, our software in this case does not allow to draw bans with the direction). <br><br>  For the algorithms to work on a graph, it is required that the graph be presented in some generally accepted form, for example, as a list of connectedness of vertices, or a connectedness matrix.  That is, data on vertices and the connections between them are actually required.  Since the vertex information in our data is very incomplete, there is only data about their geometric location, we had to process it so that all vertices get unique identifiers. <br><br>  We took the geometric location of the vertices as a basis, but there was one circumstance: the coordinates of the final vertices of the segments did not always coincide by 100%, for example, at intersections (perhaps the defects of the work of GIS system operators, I don‚Äôt know exactly).  Therefore, we decided to consider as one vertex of the graph all the end points of the segments having the same Z-level and separated from each other no further than 1 meter. <br><br>  There are approximately 140,000 total road segments in our data, which means approximately 280,000 end points. Accordingly, we needed some kind of non-legged algorithm for finding all neighbors at a distance of up to 1 meter of each point.  The frontal search of all pairs has a quadratic complexity and works excessively long.  Since we decided that our program will work directly with the original data view, that is, with Shape-files (reasons: easy to update, no need to maintain, document, version your own storage format), we needed an efficient vertex identification algorithm. <br><br>  They came up with this (hereinafter C ++ code): <br>  <b>1. Made a container for the edges of the graph:</b> <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> EdgeID; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> VertexID; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EdgeDesc</span></span></span><span class="hljs-class"> {</span></span> VertexID vtxSrc, vtxDest; EdgeInfo info; }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_multimap</span></span>&lt;EdgeID, EdgeDesc&gt; EdgeMap;</code> </pre> <br><br>  Multimap, because we decided not to introduce new identifiers of segments / edges of the graph, but to keep information about the forward and reverse edges, respectively, with the same identifiers.  It was probably not the right decision, because in my opinion it complicated the logic of some procedures, but in the beginning it seemed that it would be normal. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0af/d4b/454/0afd4b454d601dacbf777eb496512284.png"><br>  Figure 1. <br><br>  <b>2. The coordinate plane was divided into squares by a meter per meter (Figure 1).</b> <br>  Each vertex has a key mapped: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">"size_t type should be 64 bit or larger"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> keyPartX = [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(x - bound_.first.x) + <span class="hljs-number"><span class="hljs-number">1</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> keyPartY = [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(y - bound_.first.y) + <span class="hljs-number"><span class="hljs-number">1</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> getKey = [](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">8</span></span>) | y; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> getKeyXY = [&amp;keyPartX, &amp;keyPartY, &amp;getKey](<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getKey(keyPartX(x), keyPartY(y)); };</code> </pre><br><br>  <b>3. Made a hash container</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> CellKey; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;CellKey, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;VertexID&gt;&gt; SPHash;</code> </pre><br><br>  When viewing the list of segments of the street network, we build a list of elements containing the identifiers of the initial and final vertices, the edge identifier, and related information, that is, in fact, a graph as a list of adjacent vertices. <br><br>  We try to add the starting and ending point of the segment to SPHash according to the key calculated in paragraph 2.  If there are already points with such a key in the container, then we do not add a new point, but return the identifier already existing (provided that the existing point in the container is at the same Z level as the one being added). <br>  If there is nothing on the key in the container, then add a point to the container and return the identifier of the added point. <br><br>  True points, the distance between which is less than 1 meter, may have different keys, so we check the container not only by the calculated key, but also by the 8 neighboring ones: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt; near; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> xPart = keyPartX(px); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> yPart = keyPartY(py); near.clear(); merge(near, getKey(xPart, yPart)); merge(near, getKey(xPart + <span class="hljs-number"><span class="hljs-number">1</span></span>, yPart)); merge(near, getKey(xPart - <span class="hljs-number"><span class="hljs-number">1</span></span>, yPart)); merge(near, getKey(xPart, yPart + <span class="hljs-number"><span class="hljs-number">1</span></span>)); merge(near, getKey(xPart, yPart - <span class="hljs-number"><span class="hljs-number">1</span></span>)); merge(near, getKey(xPart + <span class="hljs-number"><span class="hljs-number">1</span></span>, yPart + <span class="hljs-number"><span class="hljs-number">1</span></span>)); merge(near, getKey(xPart + <span class="hljs-number"><span class="hljs-number">1</span></span>, yPart - <span class="hljs-number"><span class="hljs-number">1</span></span>)); merge(near, getKey(xPart - <span class="hljs-number"><span class="hljs-number">1</span></span>, yPart + <span class="hljs-number"><span class="hljs-number">1</span></span>)); merge(near, getKey(xPart - <span class="hljs-number"><span class="hljs-number">1</span></span>, yPart - <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><br>  merge () builds a list of identifiers of the nearest points in the near vector. <br>  Having received the list of identifiers of neighbors (in fact, candidates for merging into one vertex), we compare the points, calculating the exact Euclidean distance between them.  And if it is less than the specified, then we assume that the points are the same and merge into one vertex (painted in one color in the figure), returning the identifier of the suitable vertex already in the cell with the key getKey (xPart, yPart). <br>  At the start, this processing takes about 1 second, which suits us. <br><br>  <b>4. As a result, we obtain that neighboring points closer to a given threshold receive one identifier.</b> <br>  Now we have a list of adjacent vertices.  The time complexity of obtaining such a list linearly depends on the number of vertices, because we process each one exactly 1 time, and the search and insertion operations in the hash container have asymptotically constant complexity. <br><br>  As you should have already noticed, we do not process intermediate vertices of a broken street segment, since they do not affect the topology of the graph (in the middle of the segment, no maneuver can be made, in any case, we have no data about it). <br><br>  If we would break the polyline into its constituent segments and consider each segment as an edge, then in the graph, instead of about 140,000 edges, there would already be about 600,000. The time to search for a path would increase significantly, at the end I will show this difference in absolute values. <br><br>  Stayed the final touch.  Restrictions, or prohibited maneuvers. <br>  The restriction prohibits any maneuver, for example, turning left at an intersection.  Initially, the data is a list of segments, the consecutive movement of which is prohibited. <br><br>  I will give an example: <br><img src="//habrastorage.org/files/277/713/9d0/2777139d0394418db516fae3596c9f02.png"><br>  Fig.  2 <br><br>  Red arrows indicate a forbidden maneuver, numbers denote segment identifiers.  In fact, in the data, this prohibition looks like {e1, e4}. <br><br>  With such a view of the prohibitions, it is very difficult to work in the process of laying a route, so we decided to locally transform the graph so that the forbidden maneuver was impossible in the graph purely topologically, while all other allowed maneuvers remained possible. <br><br>  To do this, we have duplicated the vertices that are included in the forbidden maneuver.  And through these duplicated vertices, we fixed the ribs so as to create allowed maneuvers, and for the forbidden maneuver such a route simply does not create. <br><br>  When cloning a vertex, its geometric location remains the same (the vertices v6 and v5 shown in the figure are actually geometrically in the same place and spaced apart in the figure for convenience), for the new vertex, of course, a new identifier is allocated. <br><br>  I will illustrate with the example of the intersection with the forbidden left turn above: <br><img src="//habrastorage.org/files/807/c69/574/807c6957423f45a9b5e8de5eb276d063.png"><br>  Figure 3. <br><br>  It can be seen that on the graph with the changed topology, it is no longer possible to make a left turn along the forbidden path at the intersection, while all the allowed maneuvers remained possible. <br><br>  Restrictions from more than 2 edges are processed according to the same principle, but generate more new vertices and edges, these transformations affect the size of the graph, but not significantly (the growth of the number of edges by about 5%).  In our data there are about 5000 restrictions from two segments and about 400 from three). <br><br>  Here is an illustration of how a graph is transformed under the action of a 3-edge constraint: <br>  <b>It was:</b> <br><img src="//habrastorage.org/files/0c7/bf1/f33/0c7bf1f33ae64b79929e7a73b2729c51.png"><br>  Figure 4. <br><br>  <b>It became:</b> <br><img src="//habrastorage.org/files/2e5/f81/ade/2e5f81adedc842bbb29bd1b5ad4f4f4c.png"><br>  Figure 5. <br><br>  It must be said that the implementation of the graph transformation algorithm became the most difficult stage of the whole work (it took about 30% of the time) and that was where the greatest number of bugs were.  This is partly due to not very good development of the data storage structure.  So if something remains unclear - it is not scary, it was really not easy, ask questions, try to answer. <br><br>  <b>About the tools.</b> <br><br>  And so now we had a graph presented in a convenient form with all the restrictions on which it was possible to lay routes.  As an algorithm, we decided to try the classic Dijkstra algorithm, which is a good implementation in the boost library. <br>  There is nothing special to add, for boost :: graph there is good documentation and even books, we took the code of one of the examples and used it with minor changes. <br><br>  The next step was processing requests.  We decided that it was convenient if the service could make a route with only the start and end point given by the coordinates.  This means that we must quickly find the initial and final vertices in the graph, which are located as close as possible to the corresponding points of the query. <br>  To do this, it was necessary to quickly be able to find the point closest to the user-defined point on the street network (the user may want a route from a point outside the road network). <br><br>  It is appropriate to recall that the segments of the road-street network in our data are broken, so we had to find the closest point to the given point on the broken line (this could be the point lying on the broken line, or its initial or final vertex). <br>  There are quite a few broken lines (140,000), but you need to search quickly.  Search through all segments too slowly.  Here a fresh version of the library boost :: geometry, where spatial indices (boost :: geometry :: index) appeared already with the support of such an object as a broken line (linestring), came to the rescue. <br><br>  Using this index, we quickly find several closest candidates, of which then the exact segment that most closely passes near a given point is determined by an exact algorithm. <br><br>  For reading SHP files, we used the GDAL library, for converting between geographic coordinate systems (we work in the local system of the city, historically), and it‚Äôs more convenient for the user to use GPS (WGS84) coordinates) they took the proj4 library, and for iconv text conversion tasks. <br><br>  <b>About the details.</b> <br><br>  - route to the middle of the edge <br>  Let me remind you that our graph is a topological representation of the road network, the geometrical details for the operation of the Dijkstra algorithm are unimportant.  But the geometric aspect is important to the user.  Recall that the Dijkstra algorithm builds the shortest routes from a given vertex of the graph to all the others (including the desired final vertex). <br>  So we must determine the initial vertex, but we search the index among the broken lines, that is, in fact, among the edges.  How to understand from which vertex (in the graph) you need to make a route, because there are no intermediate segment peaks, which means that you need to select either the initial or the final vertex of the found segment. <br><br><img src="//habrastorage.org/files/c59/e83/985/c59e83985f374327ac2c541a504c5c60.png"><br>  Figure 6. <br><br>  However, this solution will not be convenient for the user; imagine a long highway without turns and turns (and this often happens).  The user will be very surprised to see how the route was built from the point located a kilometer from the one he set (because there was no closer to the next segment of the other peaks).  This is bad.  In addition, as shown in Figure 6 (red dotted lines), selecting the nearest vertex of the segment will sometimes mean a longer way to the goal, which is not good at all.  So we had to somehow create the appearance of the fact that there are more peaks in our graph and they are located more often, but in such a way that it does not affect the running time of the pathfinding algorithm. <br><br>  Several approaches were considered with their advantages and disadvantages: <br>  1) two searches from the initial and final vertices of the segment and the choice of the path that is shorter, taking into account the distance from the user's point from the corresponding end of the segment. <br>  <b>plus:</b> easy to implement <br>  <b>minus:</b> double search for the shortest path with the corresponding slowdown time. <br><br>  2) creating a redundant graph: all geometric vertices of the road network segments are transformed into graph vertices. <br>  <b>plus:</b> easy to implement <br>  <b>minuses: a</b> significant increase in the operating time of the Dijkstra algorithm, in some cases does not solve the problem (straight long stretch of road) <br><br>  3) complement the graph with temporary vertices and edges at the time of the request and return the graph to its initial state after the route has been found. <br>  <b>plus:</b> one search route, no need to inflate the graph, fast running. <br>  <b>minus:</b> harder to implement than other methods <br><br>  We have chosen the third way.  A graph is temporarily added to the graph corresponding to the closest to the user point lying on the broken segment and 2 edges (corresponding to the segments of the segment to the starting and ending vertices, or just one of them, if the one-way segment) are added to the graph, a search is performed, after which the temporary vertices and edges are removed from the graph. <br><br>  - output to the web <br>  In fact, our program does not work with the network at all, it reads the standard input and writes the answer to the standard output, and the entire interface with the network and dispatching are done by a separate program on node.js. <br><br>  - multithreading <br>  It's simple.  Our program works in 1 stream.  But if you really need to load all the server cores, then you can run 1 instance for each kernel, the benefit is 1 process requires to store the graph, about 300 MB (and this size can be reduced by 2-3 times, but we haven‚Äôt set ourselves this task yet as unnecessary).  How to distribute requests by processes?  Since we have an external dispatcher, it can do the distribution of requests to running processes, as well as monitor their performance, etc. <br>  Another way to load all cores: creating a multi-threaded program in C ++, seemed to us more difficult.  First of all, it would be necessary to write the network code in C ++ (we almost all server-side of the project was written on node.js and we knew that it was much easier to work with the network on it), or to make a more complex interface to the external controller compared to stdin / stdout.  Secondly, we don‚Äôt have a read-only graph because of temporary vertices and edges, which means we would have to very carefully synchronize the worker threads so that we don‚Äôt kill the performance on the one hand, and we don‚Äôt run into the corresponding problems of the multithreaded code on the other. found the advantages of this approach (at the moment) to do so. <br><br>  In conclusion, a small statistic: <br>  The whole program turned out to be only 1500 lines, plus a few dozen lines of the dispatcher on node.js, 1 person was coding in C ++, it took about 1 month + time and a couple of colleagues helped with the ideas and debugging.  It seems to us quite well for such a not very elementary task. <br><br>  The average time to search for a route (on Core i7 3.4 Ghz) is about 60-65 ms.  By the way, I promised to tell the time of work on the graph, where each segment of the broken road segment turns into a separate edge of the graph, this is about 250 ms, a noticeable difference, you will agree. <br><br>  Thank you for your attention to those who read to the end. </div><p>Source: <a href="https://habr.com/ru/post/211388/">https://habr.com/ru/post/211388/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../211376/index.html">Certainty with branding</a></li>
<li><a href="../211380/index.html">What network speed does the provider provide? Actually</a></li>
<li><a href="../211382/index.html">Announced service Steam Music (beta)</a></li>
<li><a href="../211384/index.html">Automating the addition of the server in Zabbix with the appointment of templates</a></li>
<li><a href="../211386/index.html">Pebble 2.0 and Pebble AppStore release</a></li>
<li><a href="../211394/index.html">Satya Nadella officially became the CEO of Microsoft. Bill Gates resigned as chairman of the board</a></li>
<li><a href="../211396/index.html">Firefox 27 release</a></li>
<li><a href="../211400/index.html">Motorola Moto G - for beginners and budget</a></li>
<li><a href="../211402/index.html">Determination of physical constants with the help of STM32 and LED</a></li>
<li><a href="../211404/index.html">Interesting moments in C # Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>