<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Regular expression searches can be quick and easy.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, we will look at two ways to search using regular expressions. One is widely distributed and used in standard interpreters of many lan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Regular expression searches can be quick and easy.</h1><div class="post__text post__text-html js-mediator-article">  In this article, we will look at two ways to search using regular expressions.  One is widely distributed and used in standard interpreters of many languages.  The second is used in few places, mainly in awk and grep implementations.  Both approaches vary greatly in their performance: <br><br><img src="https://habrastorage.org/files/6fe/449/288/6fe44928826a4306a4c11b441da9ac94.png"><img src="https://habrastorage.org/files/0f7/f0d/5d6/0f7f0d5d608e4dbbb602934d3b5c3b7e.png"><br><br>  In the first case, the search takes A?  <sup>n</sup> A <sup>n of</sup> time, in the second - A <sup>n</sup> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The degrees denote the repeatability of rows, that is, A?  <sup>3</sup> A <sup>3</sup> is the same as A? A? A? AAA.  Charts reflect the time required to search through regular expressions. <br><br>  Note that in Perl it takes more than 60 seconds to search for a string of 29 characters.  And with the second method - 20 <b>microseconds</b> .  It's not a mistake.  When searching for the 29-character string, Thompson NFA runs about a million times faster.  If you need to find a 100-character string, Thompson NFA can handle in less than 200 microseconds, and Perl will need more than 10 to <sup>15</sup> years.  Moreover, it is taken only as an example, in many other languages ‚Äã‚Äãthe same picture is observed - in Python, PHP, Ruby, etc. Below we consider this question in more detail. <br><br>  Surely you find it hard to believe the given data.  If you‚Äôve worked with Perl, you‚Äôd hardly notice its poor performance when working with regular expressions.  The fact is that in most cases, Perl handles them fairly quickly.  However, as follows from the graph, you can encounter the so-called pathological regular expressions, on which Perl begins to slip.  At the same time, Thompson NFA has no such problem. <br><br>  A logical question arises: why not use the Thompson NFA method in Perl?  This is possible and should be done, and this will be discussed further. <br><a name="habracut"></a><br>  Previously, regular expressions were a vivid illustration of how the use of the ‚Äúgood theory‚Äù can lead to the creation of good programs.  Originally, they were created as a simple theoretical computational model, and then Ken Thompson implemented them in one of the versions of the QED text editor for CTSS.  Dennis Ritchie did the same in his own version of QED for GE-TSS.  Later, Thompson and Ritchie had a hand in creating UNIX, moving regular expressions there as well.  In the late 1970s, they were one of the main features of this OS and were used in tools such as ed, sed, grep, egrep, awk and lex. <br><br>  Today, regular expressions provide a no less vivid illustration of how ignoring the ‚Äúgood theory‚Äù leads to the creation of bad programs.  Implementations of regular expressions in many modern tools work much slower than those used 30 years ago in UNIX tools. <br><br>  In this article, we will look at various aspects of the ‚Äúgood theory‚Äù, as well as its practical implementation of the Thompson algorithm.  It consists of less than 400 lines of C and is very close to that used in Perl, Python, PCRE and a number of other languages. <br><br><h1>  Regular expressions </h1><br>  This is the name used to describe string data patterns.  If a certain set of string data is similar to that described by a regular expression (RV), then we are talking about the coincidence of the RV with this string data. <br><br>  The simplest case of a regular expression is a single letter character.  With the exception of metacharacters - *, +,?, (,), And |, - all characters are equal to themselves.  To search for matches with metacharacters, you need to add a backslash: the combination of characters \ + is similar to +. <br><br>  Two regular expressions can be transformed or combined, creating a new regular expression: if E <sub>1</sub> matches S, and E <sub>2</sub> matches t, then E <sub>1</sub> | E <sub>2</sub> matches S or T, and E <sub>1</sub> E <sub>2</sub> corresponds to ST. <br><br>  Metacharacters *, + and?  are loop operators: <br><ul><li>  E <sub>1</sub> * says that E <sub>1</sub> can occur 0 or more times; </li><li>  E <sub>1</sub> + says that E <sub>1</sub> can occur 1 or more times; </li><li>  E <sub>1</sub> ?  says that E <sub>1</sub> can occur 0 or 1 times. </li></ul><br><br>  Operators are prioritized by increasing the degree of binding (binding): first, alternation, then concatenation, and, finally, repetition operators.  Parentheses can be used to distinguish subexpressions, like arithmetic ones: AB | cd corresponds to (AB) | (cd), AB * corresponds to A (B *). <br><br>  The syntax described is a subset of the syntax used in egrep.  This is enough to describe all regular languages ‚Äã‚Äã(regular languages).  Roughly speaking, a regular language is a set of lines that can be found in the text in one pass using a fixed amount of memory.  Modern implementations of regular expressions (in Perl and several other languages) use <a href="http://www.perl.com/doc/manual/html/pod/perlre.html">numerous new operators and control sequences</a> .  This makes PB more concise, and sometimes quite incomprehensible.  But efficiency is not added, since almost all of these new expressions can be expressed using the ‚Äútraditional‚Äù syntax, just in a longer form. <br><br>  Additional features provide so-called <b>feedbacks</b> (backreferences).  The back reference \ 1 or \ 2 corresponds to a line similar to the previous expression enclosed in parentheses.  (cat | dog) \ 1 matches catcat and dogdog, not catdog or dogcat. <br><br>  From the point of view of the theory, regular expressions with feedback are no longer regular expressions.  The use of backlinks has its considerable price: in different implementations it is necessary to use exponential search algorithms.  Of course, Perl (like other languages) cannot be relieved of feedback support.  But in their absence, you can use much faster algorithms. <br><br><h1>  Finite automata </h1><br>  State machines can be used to describe patterns.  They are also known as state machines.  In this article, the concepts of "automatic" and "machine" will be interchangeable. <br><br>  An example of recognition by the machine of a pattern corresponding to the regular expression A (BB) + A: <br><br><img src="https://habrastorage.org/files/27d/759/459/27d7594597a345d7b35cc02bafb057f4.png"><br><br>  The state machine is always in one of the states designated as S <sub>0</sub> ... S <sub>4</sub> .  When the machine reads the data, it enters the next state.  There are two special states: S <sub>0</sub> - initial, S <sub>4</sub> - matching state (matching state). <br><br>  The machine reads incoming data one character at a time, sequentially moving from one state to another, depending on the current character.  Take the ABBBBA set.  When the machine reads the first A, it is in the S0 state.  Then goes to S1.  Then the process is repeated as the rest of the characters are read: B - S <sub>2</sub> , B - S <sub>3</sub> , B - S <sub>2</sub> , B - S <sub>3</sub> and, finally, A - S <sub>4</sub> . <br><br><img src="https://habrastorage.org/files/8c2/40f/1e0/8c240f1e048340719e7c0af53172506b.png"><br><br>  If the car stops in state S <sub>4</sub> , then the symbol is found;  if in a different state - not found. <br><br>  This type of machine is called a deterministic finite automaton (DFA, deterministic finite automaton), because regardless of the current state, each new input symbol leads to a transition to the next state.  You can create a machine that will choose exactly what state to go to it. <br><br><img src="https://habrastorage.org/files/b3c/2c1/47c/b3c2c147c9ff4dd0833d12b692671b1f.png"><br><br>  This machine is similar to the previous one, but is not deterministic, because if B is read in the S <sub>2</sub> state, then the machine can go back to S <sub>1</sub> (hoping to get another BB) and S <sub>3</sub> (hoping to get the last A) .  Since the machine does not know what other characters are included in the pattern, it cannot evaluate which decision will be correct.  That is, she always <b>guesses</b> .  Such machines are called non-deterministic (NFA or NDFA, nondeterministic finite automata).  NFA finds a match if it can read a character and go into a matching state. <br><br>  It is sometimes more convenient to allow NFA to change state at any time without reading incoming data.  In the diagram, this is indicated by an unmarked transition (arrow without signatures).  For example, this option will be the most advantageous in the case of the template A (BB) + A: <br><br><img src="https://habrastorage.org/files/12e/cda/7a4/12ecda7a4c5f4c7998c13627ec266ae3.png"><br><br><h1>  Converting Regular Expressions to NFA </h1><br>  Functionally, they are absolutely equivalent.  Each regular expression can be matched with equivalent NFA (they will look for the same patterns), and vice versa.  There are different ways to convert regular expressions to NFA.  One of these, described below, was proposed by Thompson in 1968. <br><br>  Regular expression NFA is collected from partial NFA for each of the subexpressions, with a different construction for each operator.  Partial NFA does not have a matching state; instead, it contains one or more "hanging" transitions.  The build process is completed when these transitions result in a match state. <br><br>  NFA search for single characters look like this: <br><br><img src="https://habrastorage.org/files/f86/fcf/40e/f86fcf40ec3f4550ada00afb15a77244.png"><br><br>  The NFA for the concatenation of E <sub>1</sub> E <sub>2</sub> consists of the machine E <sub>1</sub> , whose final transition is connected to the beginning of the machine E <sub>2</sub> : <br><br><img src="https://habrastorage.org/files/5fe/6ec/5c8/5fe6ec5c898445d4b5b56a37ae8f1c72.png"><br><br>  In NFA, for alternation E <sub>1</sub> | E <sub>2</sub> , a new initial state is added with the choice of following through the machine E <sub>1</sub> or E <sub>2</sub> : <br><br><img src="https://habrastorage.org/files/f89/18b/2cd/f8918b2cd1cd4137bbaec018b94ea67c.png"><br><br>  In NFA for E?  Machine E alternates with a blank transition: <br><br><img src="https://habrastorage.org/files/043/d85/5a2/043d855a2d1f4841b232f163cc054d15.png"><br><br>  In NFA, for E *, the same rotation is used, but the E machine loops to the initial state: <br><br><img src="https://habrastorage.org/files/698/cdb/f00/698cdbf0082048aaa5e1f3479a132434.png"><br><br>  There is also a loop in NFA for E +, but in this case you need to go through E at least once: <br><br><img src="https://habrastorage.org/files/5bb/ebe/69a/5bbebe69a7954b4abfa7bfdd810ebfde.png"><br><br>  If you analyze the above schemes, you can see that for each character or metacharacter in a regular expression (except for parentheses) a separate state is created.  Thus, the number of states of the resulting NFA is at least equal to the length of the original regular expression. <br><br>  As in the case of the previously considered example of NFA, unmarked transitions can either not be used from the very beginning, or they can be removed after assembly.  But their presence makes it easier for us to read and understand NFA, so we will keep them further. <br><br><h1>  Regular expression search algorithms </h1><br>  Now we have a way to check if the PB contains a string: transform the regular expression into NFA and run it using the string as input.  Remember that NFAs can well guess what state they should go to.  To use NFA on a regular computer, you must select the appropriate algorithm. <br><br>  For example, you can go through the options until you find the right one.  Consider the NFA for ABAB | ABBB, performing a search on ABBB: <br><br><img src="https://habrastorage.org/files/ede/5f5/c08/ede5f5c0893348edb315605f05644931.png"><br><br><img src="https://habrastorage.org/files/364/32a/01a/36432a01a32e430787070258592cff54.png"><br><br>  During action 0, the NFA must decide whether it should look for ABAB or ABBB.  In our example, he chose the first option and failed during action 3.  Then he tries to search for the second combination and finds during action 4. This approach has a recursive implementation and allows you to repeatedly read the data for a successful search.  The machine should try all possible options before stopping the execution.  In this example, only two branches are shown, but in life their number can grow exponentially, which greatly reduces the search performance. <br><br>  Another approach is more complicated, but more effective.  We are talking about the simultaneous search for both templates.  In this case, the machine can be in several different states at once.  When processing each character, it goes through all the relevant states. <br><br><img src="https://habrastorage.org/files/b6d/ca4/be7/b6dca4be71744b109a128ea42191dc4b.png"><br><br>  The execution of the machine begins simultaneously with the initial state and all other states to which unmarked transitions lead.  During actions 1 and 2, the NFA is in two states at once.  With this approach, data is read only once, and the machine simultaneously tries to go along two branches.  In the most "neglected" cases, NFA can be <b>in all</b> states at the same time <b>during</b> each action.  As a result, the search duration is very long regardless of the length of the template and templates of any size can be processed during linear time.  This is a kind of compensation for the exponential operating time when using backtracking.  Efficiency depends on the set of simultaneously available states, and not on the paths to them.  If NFA consists of N nodes, then during each action a maximum of N states can be simultaneously, and the number of transitions can reach 2 <sup>N.</sup> <br><br><h1>  Implementation </h1><br>  This approach ‚Äî when the machine is simultaneously in several states ‚Äî was proposed by Thompson in 1968.  In his interpretation, each state was described by small pieces of machine code, and the list of possible states was a sequence of instructions for calling functions.  In essence, Thompson compiled regular expressions into literate machine code.  Today, 40 years later, computers are much more powerful, and it is not necessary to use machine code.  Therefore, below is an implementation variant on ANSI C. The full code (less than 400 lines) and benchmark scripts can be downloaded from here: <a href="http://swtch.com/~rsc/regexp/">http://swtch.com/~rsc/regexp/</a> .  If you are not friends with the C language, you can read the descriptions. <br><br><h1>  Implementation: Compiled in NFA </h1><br>  To begin with, compiling RVs to NFA equivalent.  In our C code, NFA is represented as a related collection of State structures: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c; State *out; State *out1; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastlist; };</code> </pre> <br>  Each of them corresponds to one of the three subsequent NFA fragments: <br><br><img src="https://habrastorage.org/files/a72/51f/538/a7251f5383e8481cb756a235d727f788.png"><br><br>  lastlist is used at run time, its role will be explained below. <br><br>  The compiler creates NFA from a regular expression in postfix notation with the addition of a dot (.), An explicit concatenation operator.  The separate function re2post rewrites regular infix expressions like A (BB) + A in the form of equivalent postfix ABB expressions. +. A ... <br><br>  In the "real" implementation, the dot should be used as a metacharacter "any character", and not as a concatenation operator.  It is also possible that in a real situation NFA will have to be compiled during parsing, rather than creating an explicit postfix expression.  But the postfix variant is more convenient and more in line with the approach proposed by Thompson. <br><br>  As the postfix expression is scanned, the compiler creates a stack of computed NFA fragments.  The presence of a literal constant leads to the addition of a new fragment, and each statement requires first removing the fragment from the stack, and then adding a new one.  For example, after compiling ABB to ABB. +. A.  NFA fragments for A, B and B appear on the stack. Compiling a point removes two fragments for B and adds a fragment for the BB ... concatenation. Each fragment is determined by the initial state and outgoing transitions: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Frag</span></span></span><span class="hljs-class"> {</span></span> State *start; Ptrlist *out; };</code> </pre><br>  Start denotes the initial state of the fragment, and out denotes a list of pointers to State * pointers, which do not yet lead anywhere.  In the NFA fragment, they look like hanging transitions. <br><br>  The list of pointers can be manipulated with the help of auxiliary instructions: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Ptrlist *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State **outp)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Ptrlist *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ptrlist *l1, Ptrlist *l2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">patch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ptrlist *l, State *s)</span></span></span></span>;</code> </pre><br>  List1 creates a new list containing a single outp pointer.  Append merges two lists and returns the result.  Patch connects the trailing transitions in the list l with the state s: for each outp pointer in the list l is set * outp = s. <br><br>  Based on these elements and the stack of fragments, a simple loop is created from the postfix expression.  Finally, it remains to add one fragment: the state change completes the NFA. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">State* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post2nfa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *postfix)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p; Frag <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>[<span class="hljs-number"><span class="hljs-number">1000</span></span>], *stackp, e1, e2, e; State *s; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> push(s) *stackp++ = s #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> pop() *--stackp stackp = stack; for(p=postfix; *p; p++){ switch(*p){ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* compilation cases, described below */</span></span></span><span class="hljs-meta"> } } e = pop(); patch(e.out, matchstate); return e.start; }</span></span></code> </pre><br>  Compilation steps corresponding to the conversion steps described earlier: <br>  Character literals: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: s = state(*p, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); push(frag(s, list1(&amp;s-&gt;out)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br>  Catenation: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'.'</span></span>: e2 = pop(); e1 = pop(); patch(e1.out, e2.start); push(frag(e1.start, e2.out)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br>  Alternation: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'|'</span></span>: e2 = pop(); e1 = pop(); s = state(Split, e1.start, e2.start); push(frag(s, append(e1.out, e2.out))); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br>  Zero or more: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'*'</span></span>: e = pop(); s = state(Split, e.start, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); patch(e.out, s); push(frag(s, list1(&amp;s-&gt;out1))); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br>  One or more: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'+'</span></span>: e = pop(); s = state(Split, e.start, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); patch(e.out, s); push(frag(e.start, list1(&amp;s-&gt;out1))); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br><h1>  Implementation: NFA simulation </h1><br>  After creating the NFA, we need to model it.  To do this, it is necessary to keep track of the sets of Sets, which are stored as a simple array list: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> {</span></span> State **s; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n; };</code> </pre><br>  In the simulation uses two lists: <br><ul><li>  clist - the current set of states in which the NFA is located; </li><li>  nlist is the next set of states that NFA will go to after processing the current symbol. </li></ul><br>  At the beginning of the run loop, only the initial state is entered into clist and the operation of the machine is initialized, one action at a time. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">match</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State *start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *s)</span></span></span><span class="hljs-function"> </span></span>{ List *clist, *nlist, *t; <span class="hljs-comment"><span class="hljs-comment">/* l1 and l2 are preallocated globals */</span></span> clist = startlist(start, &amp;l1); nlist = &amp;l2; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; *s; s++){ step(clist, *s, nlist); t = clist; clist = nlist; nlist = t; <span class="hljs-comment"><span class="hljs-comment">/* swap clist, nlist */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ismatch(clist); }</code> </pre><br>  In order not to distribute at each iteration, match uses two predistributed lists l1 and l2 as clist and nlist. <br><br>  If in the list of final states there is a coincidence state, then we have found the required set of characters: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ismatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List *l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;l-&gt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(l-&gt;s[i] == matchstate) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  A state is added to the list using addstate, but only if it is not yet in it.  Scanning the list with each addition would be inefficient; instead, the listid variable is used to control the version of the list.  When addstate adds the S state to the list, the listid value is written to s-&gt; lastlist.  If their values ‚Äã‚Äãare equal, then, therefore, S is already in the list.  If S is a Split state, from which unmarked transitions to new states are possible, then addstate adds these states to the list instead of S. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addstate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List *l, State *s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || s-&gt;lastlist == listid) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; s-&gt;lastlist = listid; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s-&gt;c == Split){ <span class="hljs-comment"><span class="hljs-comment">/* follow unlabeled arrows */</span></span> addstate(l, s-&gt;out); addstate(l, s-&gt;out1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } l-&gt;s[l-&gt;n++] = s; }</code> </pre><br>  The list of initial states is created using the startlist: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">List* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startlist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State *s, List *l)</span></span></span><span class="hljs-function"> </span></span>{ listid++; l-&gt;n = <span class="hljs-number"><span class="hljs-number">0</span></span>; addstate(l, s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l; }</code> </pre><br>  Finally, step tells NFA to begin processing the next character, using the current clist to create the nlist: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List *clist, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c, List *nlist)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; State *s; listid++; nlist-&gt;n = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;clist-&gt;n; i++){ s = clist-&gt;s[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s-&gt;c == c) addstate(nlist, s-&gt;out); } }</code> </pre><br><h1>  Performance </h1><br>  The implementation described above cannot boast of high performance.  But it happens that the slow implementation of the linear time algorithm easily circumvents the fast implementation of the exponential time algorithm if the exponent is large enough.  This is well demonstrated when testing various popular engines on so-called pathological regular expressions. <br><br>  Let's consider RV A?  <sup>N</sup> A <sup>N.</sup>  If a?  allows you not to look for matches for any characters, then this PB will correspond to A <sup>N.</sup>  In implementations of RV with backtracking when searching for 1-or-0?  first, 1 will be searched, and then 0. The number of such choices can reach N, and the number of possibilities - 2 <sup>N.</sup>  And only the most recent opportunity - the choice of 0 for all?  - will lead to a coincidence.  When using the backtracking method, execution takes O (2 <sup>N</sup> ) time, so that if N ‚â• 25, the degree of scaling becomes small. <br><br>  For comparison, with the length of the character set N, the Thompson algorithm also implies about N possible states, but performs a search in O (N <sup>2</sup> ) time.  Since the constant RV is not preserved when the input data is increased, the execution time is described by a superlinear function.  If the length of the PB is M, and the search is performed on the text of length N, then using the Thompson algorithm, the execution time is O (MN). <br><br>  Match search A?  <sup>N</sup> A <sup>N</sup> to A <sup>N</sup> (the size of the PB and the text is equal to N): <br><br><img src="https://habrastorage.org/files/155/edc/4a4/155edc4a482a4e49abeeb05d6cbc7efc.png"><br><br>  Note that the Y axis has a logarithmic scale.  This is done for the convenience of displaying various implementations. <br><br>  As you can see, recursive backtracking is used in Perl, Python, PCRE and Ruby.  In PCRE, the correct result cannot be obtained already at N = 23 due to the interruption of backtracking due to the achievement of the maximum number of actions.  In the Perl engine, the search <a href="http://perlmonks.org/index.pl%3Fnode_id%3D502408">is memorized</a> , which can significantly reduce the time cost due to a slight increase in memory usage, despite the use of backlinks.  But, as can be seen from the graph, the memoization here is incomplete: the execution time grows exponentially even in the absence of backlinks in expressions.  In Java, although it is not depicted in the graph, backtracking implementation is also used.  The java.util.regex interface requires backtracking, since arbitrary Java code can be inserted into the search path.  And PHP uses the PCRE library. <br><br>  The blue line on the graph shows the performance of the Thompson algorithm implemented in the C language. In awk, Tcl, GNU grep and GNU awk, the DFA is assembled and rendered on the fly, we will discuss this later. <br><br>  Some would argue that this test is unfair to the implementation with backtracking, since the comparison is made on the example of a non-standard deadlock situation.  But another thing is important: when there is a choice between a method that has a predictable execution time (and a short one) with all types of input data, and a method that usually has good performance, but in some cases may require thousands of machine hours, the solution should be obvious . <br><br>  Yes, in practice, situations rarely occur in which search performance is so depressing.  But there are still a lot of tasks in which the search speed is quite low.  For example, when to get the five fields separated by a space, use (. *) (. *) (. *) (. *) (. *) Or alternations, where frequently encountered options are not at the beginning.  As a result, programmers often have to learn which constructions are not too successful to avoid their use, or to use so-called <a href="">optimizers</a> .  But when using the Thompson NFA algorithm, this is not required, there are no ‚Äúexpensive‚Äù regular expressions. <br><br><h1>  NFA caching to build DFA </h1><br>  In terms of efficiency, DFA is superior to NFA, since they can only be in one state at a time.  Any NFA can be converted to an equivalent DFA, in which each state corresponds to a list of NFA states. <br><br>  Here is the above NFA for ABAB | ABBB: <br><br><img src="https://habrastorage.org/files/60b/fcb/dbe/60bfcbdbe5bd474ab8faef3f110ead13.png"><br><br>  Equivalent DFA looks like this: <br><br><img src="https://habrastorage.org/files/a69/bc7/4e5/a69bc74e5e15499591fb7604491d7c0a.png"><br><br>  In some ways, Thompson NFA is equivalent to DFA: each List corresponds to one of the DFA states, and the step function, based on the list of states and the next search character, calculates the next DFA state.  Thompson's algorithm models DFA, reconstructing each of the states as necessary.  But instead of doing this after every action, we can cache all lists in the backup memory.  This helps to further avoid redundant calculations, especially the calculations of the equivalent DFA.  Let's look at this approach. <br><br>  We need to add less than 100 lines to the above described NFA to make DFA.  Before you implement the caching mechanism, you must first declare a new data type to describe the state of the DFA: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DState</span></span></span><span class="hljs-class"> {</span></span> List l; DState *next[<span class="hljs-number"><span class="hljs-number">256</span></span>]; DState *left; DState *right; };</code> </pre><br>  DState is a cached copy of the list l.  The next array stores pointers to the next state for each possible input data character: if the current state is D and the next character is C, then the next state is d-&gt; next [c].  If d-&gt; next [c] is null, then the next state is not yet calculated.  Nextstate is responsible for calculating, writing, and returning the next state. <br><br>  When searching for a regular expression, d-&gt; next [c] is processed cyclically, calling nextstate to compute the new state as needed. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">match</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DState *start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c; DState *d, *next; d = start; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; *s; s++){ c = *s &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((next = d-&gt;next[c]) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) next = nextstate(d, c); d = next; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ismatch(&amp;d-&gt;l); }</code> </pre><br>  All calculated DState must be saved as a structure that will allow to find them by the List criterion.  For this, a binary tree is used, where sorted List is used as keys.  By key, the dstate function returns the desired value: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">DState* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dstate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List *l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; DState **dp, *d; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DState *alldstates; qsort(l-&gt;s, l-&gt;n, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> l-&gt;s[<span class="hljs-number"><span class="hljs-number">0</span></span>], ptrcmp); <span class="hljs-comment"><span class="hljs-comment">/* look in tree for existing DState */</span></span> dp = &amp;alldstates; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((d = *dp) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>){ i = listcmp(l, &amp;d-&gt;l); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) dp = &amp;d-&gt;left; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) dp = &amp;d-&gt;right; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d; } <span class="hljs-comment"><span class="hljs-comment">/* allocate, initialize new DState */</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> *d + l-&gt;n*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> l-&gt;s[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(d, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> *d); d-&gt;ls = (State**)(d+<span class="hljs-number"><span class="hljs-number">1</span></span>); memmove(d-&gt;ls, l-&gt;s, l-&gt;n*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> l-&gt;s[<span class="hljs-number"><span class="hljs-number">0</span></span>]); d-&gt;ln = l-&gt;n; <span class="hljs-comment"><span class="hljs-comment">/* insert in tree */</span></span> *dp = d; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d; }</code> </pre><br>  Nextstate initializes the step NFA and returns the corresponding DState: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">DState* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nextstate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DState *d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ step(&amp;d-&gt;l, c, &amp;l1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d-&gt;next[c] = dstate(&amp;l1); }    NFA,   DFA   DState:</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">DState* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startdstate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State *start)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dstate(startlist(start, &amp;l1)); }</code> </pre><br>  As with NFA, l1 is a predefined List. <br><br>  Although DState values ‚Äã‚Äãcorrespond to certain DFA states, DFA itself is built only when the need arises.  If during the search the DFA status is detected, it means that it is not yet in the cache.  As an alternative solution, the entire DFA can be calculated once.  This will speed up the work of match somewhat, since the conditional transition will be eliminated, but it will increase the launch time and the amount of memory used. <br><br>  When building a DFA on the fly, note the following point: memory allocation.  Since DState is the step function cache, as dstate grows, the cache can decide to destroy the entire DFA.  To implement such a cache replacement policy, only a few extra lines of code in dstate and nextstate are required, as well as another 50 lines for memory management.  Download an example here: <a href="http://swtch.com/~rsc/regexp/">http://swtch.com/~rsc/regexp/</a> .  By the way, <a href="http://cm.bell-labs.com/cm/cs/awkbook/">awk</a> uses a similar strategy, there are no more than 32 states stored in the cache.  This explains the drop in its performance since N = 28, as was shown in the graph. <br><br>  NFA obtained from regular expressions is distinguished by good locality: in most tests they take the same states and follow the same transitions over and over again.  This further increases the importance of caching, because after the first pass, it is no longer necessary to calculate the states, it is enough to take them from memory.  In DFA-based implementations, additional optimization can be applied, further increasing execution speed. <br><br><h1>  Real examples of regular expressions </h1><br>  In these applications, it is somewhat harder to use regular expressions than in the implementations described above.  Here we look at the characteristic difficulties encountered by developers. <br><br>  <b>Character classes</b>  They are a simplified representation of alternation - 0-9, \ w or.  (point).  At compile time, they can be converted to interlaces, although for their explicit representation it would be more efficient to add a new type of NFA node.  <a href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html">POSIX</a> defines special character classes like [[: upper:]], which change their meaning depending on the current node.  The difficulty of working with them lies in defining their values, and not in putting these values ‚Äã‚Äãinto NFA. <br><br>  <b>Control sequences</b>  Regular expression syntax should handle escape sequences so that you can search for metacharacters (\ (, \), \\, etc.), as well as specify special characters like \ n. <br><br>  <b>Repeat (Counted repetition)</b> .  In many implementations of regular expressions, the repetition operator {N} is used, where N is the exact number of matches of the pattern.  Writing {N, M} means that the pattern must be found from N to M times.  {N,} - N and more times.  In recursive backtracking implementations, repetitions can be performed using loops.  In implementations based on NFA and DFA, repetitions should be presented in expanded form: instead of E {3} - EEE, instead of E {3,5} - EEEE? E?, Instead of E {3,} - EEE +. <br><br>  <b>Subexpressions (Submatch extraction)</b> .  If RVs are used to split or parse strings, it can be helpful to find out if there are matches with subexpressions in the input data.  If in the text there is a coincidence with ([0-9] + - [0-9] + - [0-9] +) ([0-9] +: [0-9] +), then in many realizations of RT you can will find matches for each of the subexpressions enclosed in parentheses.  For example, in Perl: <br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-regexp"><span class="hljs-regexp">/([0-9]+-[0-9]+-[0-9]+) ([0-9]+:[0-9]+)/</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"date: $1, time: $2\n"</span></span>; }</code> </pre><br>  Extraction of subexpressions was largely ignored by theorists.  Perhaps this is one of the main reasons for using recursive backtracking.  However, variations of the Thompson algorithm can be adapted to work with subexpressions without losing performance.  This was implemented as early as 1985, in the regexp library in the eighth version of UNIX, but was not widely used. <br><br>  <b>Unanchored matches</b> .  The information in this article is based on the fact that the search for PB is performed on all input data.  But in life often there are situations when we need to find only part of the line that coincides with PB.  In UNIX, the longest substring of matches found traditionally returns, starting closest to the beginning of the input data.  Search without binding is a special case of subexpressions.  It‚Äôs like looking for. * (E). *, Where the first sequence. * Limits the search to the shortest match. <br><br>  <b>Nasty operators</b> .  In the traditional UNIX implementation, using the repetition operators?, * And +, the maximum possible number of matches of the RVs is searched for.  For example, if ABCD is searched with operators (. +) (. +), Then the first sequence (. +) Finds ABC and the second matches D. Such operators are called greedy. <br><br>  Perl uses non-greedy versions ??, *?  and + ... .  Operator's greed does not affect the compliance of the RV with the entire line.  It depends only on the choice of boundaries subexpressions.  The backtracking algorithm allows the use of a simple implementation of non-operator operators: first, a shorter match is sought, then a longer one.  For example, in the standard implementation, the algorithm with backtracking when searching for E?  first tries to find E, and after detection tries not to use it anymore;  with E ??  another procedure is applied.  Variants of the Thompson algorithm using subexpressions can be adapted for the use of non-greedy operators. <br><br>  <b>Assertions (Assertions)</b> .  The ^ and $ metacharacters can be used as statements with respect to the text to the right and to the left of them.  ^ says that the character in front of it is the beginning of a new line.  $ states that the next character is the end of a line.  Other statements have been added to Perl, for example, \ b - the previous character is alphanumeric, and the next is not, or vice versa.  Also, Perl summarizes the idea of ‚Äã‚Äãarbitrary conditions called preliminary statements (lookahead assertions): (? = Re) states that the text after the current position coincides with re, but does not change the position itself.  (?! re) states that the text does not coincide with re, otherwise it works the same way.  The statements (? &lt;= Re) and (? &lt;! Re) are equivalent and speak about the coincidence of the text before the current position. <br><br>  Simple statements like ^, $ and \ b can be easily applied to NFA by delaying the matching procedure for preliminary statements by one byte.  General statements are more difficult to apply in NFA, but still possible. <br><br>  <b>Backlinks (Backreferences).</b>  As mentioned above, no one has yet succeeded in effectively implementing RT with backlinks.  On the other hand, no one has yet proved that this is impossible to do.  This is an <a href="http://perl.plover.com/NPC/NPC-3SAT.html">NP-complete task</a> , and if someone finds a solution, he can get a <a href="http://www.claymath.org/millennium-problems/rules-millennium-prizes">prize of one million dollars</a> .  The easiest way is not to use backlinks at all, as did the awk and egrep developers.      :      ,     .       <a href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html"> POSIX   </a> .             Thompson NFA,      .          . <br><br> <b>  .</b>   Perl        .    ,        ,      ,       .       ,   .      ,          : <br><pre> <code class="bash hljs">$ perl -e <span class="hljs-string"><span class="hljs-string">'("a" x 100000) =~ /^(ab?)*$/;'</span></span> Segmentation fault (core dumped) $</code> </pre><br> <b> .</b>           ASCII-   Unicode.  <a href="http://swtch.com/plan9port/unix/"> Plan 9</a>      Unicode:    NFA         Unicode-.      NFA    ,             <a href="http://plan9.bell-labs.com/sys/doc/utf.html">UTF-8</a> ,   Unicode. <br><br><h1>  Conclusion </h1><br>              ,   .   Perl, PCRE, Python, Ruby, Java          ,    ,     .           (   ),       . <br><br><h1>   </h1><br> [ <a href="https://swtch.com/~rsc/regexp/regexp1.html">1</a> ] L. Peter Deutsch and Butler Lampson. An online editor // Communications of the ACM.  Vol. 10, Iss. 12 (December 1967). P. 793‚Äì799. <a href="http://doi.acm.org/10.1145/363848.363863">doi.acm.org/10.1145/363848.363863</a> <br> [ <a href="https://swtch.com/~rsc/regexp/regexp1.html">2</a> ] Ville Laurikari. NFAs with Tagged Transitions, their Conversion to Deterministic Automata and Application to Regular Expressions // Proceedings of the Symposium on String Processing and Information Retrieval. September 2000. <a href="http://laurikari.net/ville/spire2000-tnfa.pdf">laurikari.net/ville/spire2000-tnfa.pdf</a> <br> [ <a href="https://swtch.com/~rsc/regexp/regexp1.html">3</a> ] M. Douglas McIlroy. Enumerating the strings of regular languages // Journal of Functional Programming. 2004. ‚Ññ 14. P. 503‚Äì518. <a href="">www.cs.dartmouth.edu/~doug/nfa.ps.gz</a> (preprint) <br> [ <a href="https://swtch.com/~rsc/regexp/regexp1.html">4</a> ] R. McNaughton and H. Yamada. Regular expressions and state graphs for automata // IRE Transactions on Electronic Computers.  Vol. EC-9 (1) (March 1960). P. 39‚Äì47. <br> [ <a href="https://swtch.com/~rsc/regexp/regexp1.html">5</a> ] Paul Pierce. CTSS source listings. <a href="http://www.piercefuller.com/library/ctss.html">www.piercefuller.com/library/ctss.html</a> (Thompson's QED is in the file com5 in the source listings archive and is marked as 0QED) <br> [ <a href="https://swtch.com/~rsc/regexp/regexp1.html">6</a> ] Rob Pike/ The text editor sam // Software ‚Äî Practice &amp; Experience.  Vol. 17, ‚Ññ 11 (November 1987. P. 813‚Äì845. <a href="http://plan9.bell-labs.com/sys/doc/sam/sam.html">plan9.bell-labs.com/sys/doc/sam/sam.html</a> <br> [ <a href="https://swtch.com/~rsc/regexp/regexp1.html">7</a> ] Michael Rabin and Dana Scott. Finite automata and their decision problems // IBM Journal of Research and Development. 1959. ‚Ññ 3. P. 114‚Äì125. <a href="http://www.research.ibm.com/journal/rd/032/ibmrd0302C.pdf">www.research.ibm.com/journal/rd/032/ibmrd0302C.pdf</a> <br> [ <a href="https://swtch.com/~rsc/regexp/regexp1.html">8</a> ] Dennis Ritchie. An incomplete history of the QED text editor. <a href="https://www.bell-labs.com/usr/dmr/www/qed.html">www.bell-labs.com/usr/dmr/www/qed.html</a> <br> [ <a href="https://swtch.com/~rsc/regexp/regexp1.html">9</a> ] Ken Thompson. Programming Techniques: Regular expression search algorithm // Communications of the ACM.  Vol. 11, Iss. 6 (June 1968). P. 419‚Äì422. <a href="http://doi.acm.org/10.1145/363347.363387">doi.acm.org/10.1145/363347.363387</a> ( <a href="http://www.cs.chalmers.se/~coquand/AUTOMATA/thompson.pdf">PDF</a> ) <br> [ <a href="https://swtch.com/~rsc/regexp/regexp1.html">10</a> ] Tom Van Vleck. The IBM 7094 and CTSS. <a href="http://www.multicians.org/thvv/7094.html">www.multicians.org/thvv/7094.html</a> </div><p>Source: <a href="https://habr.com/ru/post/270507/">https://habr.com/ru/post/270507/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270497/index.html">Zabbix alerts via sms using GSM modem. Easy setup</a></li>
<li><a href="../270499/index.html">Condition Tool</a></li>
<li><a href="../270501/index.html">Very short intro</a></li>
<li><a href="../270503/index.html">Analysis of shopping carts in retail</a></li>
<li><a href="../270505/index.html">Time to materialize: 5 days left until the end of the competition</a></li>
<li><a href="../270509/index.html">GDG DevFest Voronezh 2015: photo and video report from the event</a></li>
<li><a href="../270513/index.html">OpenStreetMap as a geodata source</a></li>
<li><a href="../270515/index.html">‚ÄúBig data‚Äù - is it boring?</a></li>
<li><a href="../270517/index.html">Another virtual interface</a></li>
<li><a href="../270519/index.html">Symfony2 two-factor authentication with a certificate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>