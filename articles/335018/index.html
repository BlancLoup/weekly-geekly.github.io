<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CDC + MSC USB Composite Device on STM32 HAL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I would like to believe that at least half of the readers can decipher at least half of the title of the article :) Who does not know - I will explain...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CDC + MSC USB Composite Device on STM32 HAL</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/c0f/498/aaf/c0f498aaf3b547ebb6c4f4da6de20013.png" alt="image"><br><br>  I would like to believe that at least half of the readers can decipher at least half of the title of the article :) Who does not know - I will explain.  <a href="https://geektimes.ru/post/287666/">My device</a> should implement two USB functions at once: <br><br><ul><li>  <b>Mass Storage Device</b> (aka <b>Mass Storage Class - MSC</b> ).  I want my device to pretend to be a regular flash drive and give the files with the data that lie on the SD card. </li><li>  Another function is the <b>virtual COM port</b> (also known as USB <b>Communication Class - CDC</b> in USB terminology).  Through this channel, I have any debugging output that is convenient to watch with an ordinary terminal. </li></ul><br>  In most examples of working with USB, only one type of device is implemented - a USB flash drive, a mouse, a custom HID device or a virtual COM port.  But to find an imputed explanation of how to implement at least two functions at the same time was not so easy.  In my article, I would like to fill this gap. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will describe the creation of a composite USB device based on the STM32 microcontroller, but the approach itself will also be applicable to other microcontrollers.  In the article I will examine in detail each of the classes separately, as well as the principle of building composite devices.  But about everything in order. <br><br>  So let's go! <br><a name="habracut"></a><br><h2>  Some theory </h2><br>  The USB interface is very complex, layered and multi-faceted.  With a swoop it does not overpower.  In one of the articles (I forgot, however, in what) I saw the phrase in the style ‚Äúread this article 2 times, and then in the morning again‚Äù.  Yes, he is, from the first time you will not master it.  Personally, my interface more or less decayed on the shelves only after a couple of months of active digging and reading specifications. <br><br>  I am still not an expert in USB, and therefore I would recommend to refer to articles that would describe the essence of what is happening in more detail.  I will only point out the most important places and briefly explain how it works - for the most part I got into it myself.  First of all, I would recommend <a href="http://www.beyondlogic.org/usbnutshell/usb1.shtml">Usb in a nutshell</a> ( <a href="http://microsin.net/programming/arm-working-with-usb/usb-in-a-nutshell-part1.html">translation</a> ), as well as <a href="http://www.usbmadesimple.co.uk/">USB Made Simple</a> (I did not read it myself, but many recommend it).  We also need <a href="http://www.usb.org/developers/docs/devclass_docs/">specifications for specific classes of USB devices</a> . <br><br>  Probably the most important thing in the USB interface is the handle.  More precisely, even the package descriptors.  When a device connects to the bus, the host requests device descriptors that describe the device's capabilities, baud rates, polling frequency, which interfaces the device implements, and much more.  The handle is an important and very gentle thing - even a mistake in one byte will result in the device not working. <br><br>  The device describes itself with the help of several descriptors of different types: <br><br><ul><li>  <b>Device Descriptor</b> - describes the device as a whole, its name, manufacturer, serial number.  String data is described by separate string descriptors (String Descriptor) <br><br></li><li>  <b>Configuration Descriptor</b> ‚Äî A device may have one or more configurations.  Each configuration determines the speed of communication with the device, a set of interfaces and power settings.  For example, a laptop that runs on battery can ask the device (choose a configuration) to use a lower exchange rate and switch to its own power source (instead of a laptop battery).  Of course, this only works if the device provides this configuration. <br><br></li><li>  <b>Interface descriptor</b> - describes the interface for communicating with the device.  Interfaces can be several.  For example, different functions (MSC, CDC, HID) will implement their interfaces.  Some functions (for example, CDC or DFU) implement several interfaces for their work at once.  In our case, the composite device, we need to implement several interfaces from different functions at once and make them get along with each other. <br><br></li><li>  <b>Endpoint descriptor</b> - describes the communication channel within a specific interface, sets the packet size, describes the interrupt parameters.  Using endpoints, we will receive and receive data. <br><br></li><li>  There are a bunch of different descriptors that describe specific aspects of specific interfaces. </li></ul><br>  The host requests the descriptors in a single byte stream.  It is very important that within the same configuration descriptors go in a certain order, otherwise the host will get confused about which descriptor to what.  Each configuration consists of a configuration descriptor and a set of descriptors describing interfaces.  Each interface is described by an interface descriptor and a set of endpoint descriptors.  Each entity carries its handles alongside. <br><br>  You also need to understand that USB is a host oriented protocol.  Device setup, reception, transfer - everything in USB is controlled from the host.  For us, this means that there is no control flow from the microcontroller side - all USB work is based on interrupts and callbacks.  And this, in turn, means that we don‚Äôt want to start long-running operations and need to be very careful when interacting with other interrupts (take into account priority, and so on).  However, let's try not to go down to such a low level. <br><br>  Also, host-centricity is also manifested in the name of the functions.  In USB terminology, the direction from the host to the device is called OUT, although for the controller it is a trick.  Conversely, the direction from the device to the host is called IN, although for us this means sending data.  So in the microcontroller, the DataOut () function actually receives the data, and DataIn () sends the data.  But this is so, by the way - we will use the already prepared code. <br><br><h2>  CDC - virtual COM port </h2><br>  Probably, taking the composite device at once will not work out entirely - too many nuances and pitfalls.  I think it would be better to first debug each interface separately, and then go to the composite device.  I'll start with the CDC, because  It does not require any dependencies. <br><br>  I recently <a href="https://geektimes.ru/post/291037/">moved to the STM32 Cube</a> - a package of low-level drivers for the STM32.  It has a USB control code with the implementation of individual classes of USB devices.  Take the template implementation of USB Core and CDC and begin to cut for themselves.  Blanks are in the \ Middlewares \ ST \ STM32_USB_Device_Library directory.  I use <a href="http://www.st.com/en/embedded-software/stm32cubef1.html">Cube for STM32F1 series controllers</a> , Cube version is 1.6 (April 2017), USB library version from the kit is 2.4.2 (December 2015) <br><br>  Template implementation of the library involves writing your own code in files called template.  Without an understanding of the entire library and the principles of USB operation, this is quite difficult to do.  But we will go easier - we will generate these files using <a href="http://www.st.com/en/development-tools/stm32cubemx.html">the CubeMX graphical configurator</a> . <br><br>  The implementation provided by CubeMX is ready to work right out of the box.  Even a little offensive, that did not have to write any code.  We'll have to study the CDC on the example of a completely finished implementation.  Let's take a look at the most interesting places in the generated code. <br><br>  First, let's look at the descriptors that are in the usbd_desc.c files (device descriptor) and usbd_cdc.c (configuration descriptors, interfaces, endpoints).  The <a href="http://www.beyondlogic.org/usbnutshell/usb1.shtml">usb in a nutshell</a> article ( <a href="http://microsin.net/programming/arm-working-with-usb/usb-in-a-nutshell-part1.html">in Russian</a> ) has a very detailed description of all descriptors.  I will not describe each field separately, I will dwell only on the most important and interesting fields. <br><br><div class="spoiler"> <b class="spoiler_title">Device handle</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_VID 1155 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_LANGID_STRING 1033 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_MANUFACTURER_STRING </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"STMicroelectronics"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_PID_FS 22336 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_PRODUCT_STRING_FS </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"STM32 Virtual ComPort"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_SERIALNUMBER_STRING_FS </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"00000000001A"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_CONFIGURATION_STRING_FS </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CDC Config"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_INTERFACE_STRING_FS </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CDC Interface"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_MAX_NUM_CONFIGURATION 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USB Standard Device Descriptor */</span></span></span><span class="hljs-meta"> __ALIGN_BEGIN uint8_t USBD_FS_DeviceDesc[USB_LEN_DEV_DESC] __ALIGN_END = { 0x12, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*bLength */</span></span></span><span class="hljs-meta"> USB_DESC_TYPE_DEVICE, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*bDescriptorType*/</span></span></span><span class="hljs-meta"> 0x00, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* bcdUSB */</span></span></span><span class="hljs-meta"> 0x02, 0x02, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*bDeviceClass*/</span></span></span><span class="hljs-meta"> 0x02, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*bDeviceSubClass*/</span></span></span><span class="hljs-meta"> 0x00, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*bDeviceProtocol*/</span></span></span><span class="hljs-meta"> USB_MAX_EP0_SIZE, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*bMaxPacketSize*/</span></span></span><span class="hljs-meta"> LOBYTE(USBD_VID), </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*idVendor*/</span></span></span><span class="hljs-meta"> HIBYTE(USBD_VID), </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*idVendor*/</span></span></span><span class="hljs-meta"> LOBYTE(USBD_PID_FS), </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*idVendor*/</span></span></span><span class="hljs-meta"> HIBYTE(USBD_PID_FS), </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*idVendor*/</span></span></span><span class="hljs-meta"> 0x00, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*bcdDevice rel. 2.00*/</span></span></span><span class="hljs-meta"> 0x02, USBD_IDX_MFC_STR, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*Index of manufacturer string*/</span></span></span><span class="hljs-meta"> USBD_IDX_PRODUCT_STR, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*Index of product string*/</span></span></span><span class="hljs-meta"> USBD_IDX_SERIAL_STR, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*Index of serial number string*/</span></span></span><span class="hljs-meta"> USBD_MAX_NUM_CONFIGURATION </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*bNumConfigurations*/</span></span></span><span class="hljs-meta"> } ; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USB_DeviceDescriptor */</span></span></span></span></code> </pre> <br></div></div><br>  Here we are interested in the following fields: <br><br><ul><li>  bDeviceClass, bDeviceSubClass and bDeviceProtocol - describe to the host what kind of device it is, what it can do and which drivers to load.  In this case, it says here that the device implements a Communication Device Class, which means that the host needs to make a virtual COM port and associate it with this device. <br><br></li><li>  PID (Product ID) and VID (Vendor ID) - according to these fields the host distinguishes between different devices connected to the system.  The devices at the same time implement the same class.  They say for devices sold on the market is very important to have a unique VID / PID, but I did not know who and where gives these ID-Schnick.  For a home device in a single copy, the default values ‚Äã‚Äãare sufficient. </li></ul><br>  Please note that string constants (device name, serial number) are not spelled out in the descriptor itself.  Strings are described by separate descriptors, and all others only indicate the index of the string.  In the case of the library from ST, the string handle is generated on the fly (grrrrrr), so I will not give it. <br><br><div class="spoiler">  <b class="spoiler_title">Configuration descriptor</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__ALIGN_BEGIN <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> USBD_CDC_CfgHSDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END = { <span class="hljs-comment"><span class="hljs-comment">/*Configuration Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Configuration Descriptor size */</span></span> USB_DESC_TYPE_CONFIGURATION, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: Configuration */</span></span> USB_CDC_CONFIG_DESC_SIZ, <span class="hljs-comment"><span class="hljs-comment">/* wTotalLength:no of returned bytes */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bNumInterfaces: 2 interface */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bConfigurationValue: Configuration value */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* iConfiguration: Index of string descriptor describing the configuration */</span></span> <span class="hljs-number"><span class="hljs-number">0xC0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bmAttributes: self powered */</span></span> <span class="hljs-number"><span class="hljs-number">0x32</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* MaxPower 100 mA */</span></span></code> </pre> <br></div></div><br>  Here we are interested in the following: <br><br><ul><li>  wTotalLength - the size of the entire packet of descriptors for this configuration - so that the host knows where this configuration ends and the next one begins.  We will need to fix it when we make a composite device.  Let me remind you that all interfaces for this configuration must be located in a solid block, and the value of wTotalLength determines the length of this block. <br><br></li><li>  bNumInterfaces: the Communication Device class is implemented using two interfaces.  One for management, the other for the actual data to be sent. <br><br></li><li>  bmAttributes and MaxPower indicates that our device has its own power source, but wants to consume up to 100 mA from the USB port.  These parameters will obviously have to be played in the future. </li></ul><br>  Next comes the handle to the first of the CDC interfaces.  This class of devices can implement several different communication models (telephone, direct connection, multi-party connection), but in our case it will be the Abstract Control Model. <br><br><div class="spoiler">  <b class="spoiler_title">CDC Management Interface Descriptor</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*Interface Descriptor */</span></span> <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Interface Descriptor size */</span></span> USB_DESC_TYPE_INTERFACE, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: Interface */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Interface descriptor type */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceNumber: Number of Interface */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bAlternateSetting: Alternate setting */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bNumEndpoints: One endpoints used */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceClass: Communication Interface Class */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceSubClass: Abstract Control Model */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceProtocol: Common AT commands */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* iInterface: */</span></span></code> </pre> <br></div></div><br>  Only one endpoint lives in this interface (bNumEndpoints).  But first comes a series of functional descriptors - settings specific to this class of devices. <br><br><div class="spoiler">  <b class="spoiler_title">Functional descriptors</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/*Header Functional Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Endpoint Descriptor size */</span></span> <span class="hljs-number"><span class="hljs-number">0x24</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: CS_INTERFACE */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorSubtype: Header Func Desc */</span></span> <span class="hljs-number"><span class="hljs-number">0x10</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bcdCDC: spec release number */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*Call Management Functional Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bFunctionLength */</span></span> <span class="hljs-number"><span class="hljs-number">0x24</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: CS_INTERFACE */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorSubtype: Call Management Func Desc */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bmCapabilities: D0+D1 */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDataInterface: 1 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*ACM Functional Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x04</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bFunctionLength */</span></span> <span class="hljs-number"><span class="hljs-number">0x24</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: CS_INTERFACE */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorSubtype: Abstract Control Management desc */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bmCapabilities */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Union Functional Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bFunctionLength */</span></span> <span class="hljs-number"><span class="hljs-number">0x24</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: CS_INTERFACE */</span></span> <span class="hljs-number"><span class="hljs-number">0x06</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorSubtype: Union func desc */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bMasterInterface: Communication class interface */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bSlaveInterface0: Data Class Interface */</span></span></code> </pre> <br></div></div><br>  It says that our device does not know about the concept of "bell" (in the sense of a phone call), but it also understands the command line parameters (speed, stop bits, DTR / CTS bits).  The last descriptor describes which of the two CDC interfaces is the manager, and where the data runs.  In general, here we are not interested in anything and we will not change anything. <br><br><div class="spoiler">  <b class="spoiler_title">Finally, the endpoint handle for the control interface</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/*Endpoint 2 Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Endpoint Descriptor size */</span></span> USB_DESC_TYPE_ENDPOINT, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: Endpoint */</span></span> CDC_CMD_EP, <span class="hljs-comment"><span class="hljs-comment">/* bEndpointAddress */</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bmAttributes: Interrupt */</span></span> LOBYTE(CDC_CMD_PACKET_SIZE), <span class="hljs-comment"><span class="hljs-comment">/* wMaxPacketSize: */</span></span> HIBYTE(CDC_CMD_PACKET_SIZE), <span class="hljs-number"><span class="hljs-number">0x10</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterval: */</span></span></code> </pre> <br></div></div><br>  It says that this endpoint is used for interrupts.  The host will poll the device once every 0x10 (16) ms with the question whether the device requires attention.  Also, control commands will go through this end point. <br><br>  The description of the second interface (where the data runs) will be simpler <br><br><div class="spoiler">  <b class="spoiler_title">CDC data interface and its endpoints</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*Data class interface descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Endpoint Descriptor size */</span></span> USB_DESC_TYPE_INTERFACE, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceNumber: Number of Interface */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bAlternateSetting: Alternate setting */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bNumEndpoints: Two endpoints used */</span></span> <span class="hljs-number"><span class="hljs-number">0x0A</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceClass: CDC */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceSubClass: */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceProtocol: */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* iInterface: */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Endpoint OUT Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Endpoint Descriptor size */</span></span> USB_DESC_TYPE_ENDPOINT, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: Endpoint */</span></span> CDC_OUT_EP, <span class="hljs-comment"><span class="hljs-comment">/* bEndpointAddress */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bmAttributes: Bulk */</span></span> LOBYTE(CDC_DATA_HS_MAX_PACKET_SIZE), <span class="hljs-comment"><span class="hljs-comment">/* wMaxPacketSize: */</span></span> HIBYTE(CDC_DATA_HS_MAX_PACKET_SIZE), <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterval: ignore for Bulk transfer */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Endpoint IN Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Endpoint Descriptor size */</span></span> USB_DESC_TYPE_ENDPOINT, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: Endpoint */</span></span> CDC_IN_EP, <span class="hljs-comment"><span class="hljs-comment">/* bEndpointAddress */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bmAttributes: Bulk */</span></span> LOBYTE(CDC_DATA_HS_MAX_PACKET_SIZE), <span class="hljs-comment"><span class="hljs-comment">/* wMaxPacketSize: */</span></span> HIBYTE(CDC_DATA_HS_MAX_PACKET_SIZE), <span class="hljs-number"><span class="hljs-number">0x00</span></span> <span class="hljs-comment"><span class="hljs-comment">/* bInterval: ignore for Bulk transfer */</span></span></code> </pre> <br></div></div><br>  In the interface, there are 2 end points of the bulk type - one to receive, the second to transfer.  In fact, in USB terminology, this is one endpoint, just two-way. <br><br>  I won‚Äôt explain how it all works, if only because I don‚Äôt understand it completely (for example, how the host knows how much data needs to be collected from the device).  Most importantly, the library implements everything for us.  Let's take a look at the architecture. <br><br>  ST's USB library is quite layered.  I would highlight such architectural levels. <br><br><ul><li>  <b>Class Driver</b> (in the case of CDC, these are usbd_cdc and usbd_cdc_if files): implement the logic of a specific class of devices - CDC for virtual COM port, MSC for storage devices, HID for keyboards / mice and any specific devices with user interface. <br><br></li><li>  <b>USB Core</b> (usbd_core.c, usbd_ctlreq.c, usbd_ioreq.c): implements the general logic of all classes of USB devices, can give the requested handles to the host, processes requests from the host and configures the USB device as a whole.  It also redirects data streams from a class driver to lower layers and vice versa. <br><br></li><li>  <b>USB HW Driver</b> (usbd_conf.c): The overlying layers are platform independent and work in the same way for several series of microcontrollers.  The code does not have low-level function calls for a particular microcontroller.  The usbd_conf.c file implements a layer between USB Core and HAL - a library of low-level drivers for the selected microcontroller.  Basically, simple live wrappers live here, which redirect calls from top to bottom and callbacks from bottom to top. <br><br></li><li>  <b>HAL</b> (stm32f1xx_hal_pcd.c, stm32f1xx_ll_usb.c): communicate with the microcontroller's iron, handles registers and responds to interrupts. </li></ul><br>  At this stage, we will be interested only in the topmost layer and one function from usbd_conf.c.  Let's start with the last one: <br><br><div class="spoiler">  <b class="spoiler_title">USBD_LL_Init () function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief Initializes the Low Level portion of the Device driver. * @param pdev: Device handle * @retval USBD Status */</span></span> <span class="hljs-function"><span class="hljs-function">USBD_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USBD_LL_Init</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USBD_HandleTypeDef *pdev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Init USB_IP */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Link The driver to the stack */</span></span> hpcd_USB_FS.pData = pdev; pdev-&gt;pData = &amp;hpcd_USB_FS; hpcd_USB_FS.Instance = USB; hpcd_USB_FS.Init.dev_endpoints = <span class="hljs-number"><span class="hljs-number">8</span></span>; hpcd_USB_FS.Init.speed = PCD_SPEED_FULL; hpcd_USB_FS.Init.ep0_mps = DEP0CTL_MPS_8; hpcd_USB_FS.Init.low_power_enable = DISABLE; hpcd_USB_FS.Init.lpm_enable = DISABLE; hpcd_USB_FS.Init.battery_charging_enable = DISABLE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HAL_PCD_Init(&amp;hpcd_USB_FS) != HAL_OK) { Error_Handler(); } HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , <span class="hljs-number"><span class="hljs-number">0x00</span></span> , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x18</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , <span class="hljs-number"><span class="hljs-number">0x80</span></span> , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x58</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , <span class="hljs-number"><span class="hljs-number">0x81</span></span> , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0xC0</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , <span class="hljs-number"><span class="hljs-number">0x01</span></span> , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x110</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , <span class="hljs-number"><span class="hljs-number">0x82</span></span> , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> USBD_OK; }</code> </pre> <br></div></div><br>  This function initializes the microcontroller's USB peripherals.  The most interesting thing here is the series of HAL_PCDEx_PMAConfig () function calls.  The fact is that on board the microcontroller there is a whole 512 bytes of memory allocated specifically for USB buffers (this memory is called PMA - Packet Memory Area).  But since the device does not know in advance how many endpoints will be and what their parameters will be, this memory is not allocated.  Therefore, before working with USB memory must be distributed according to the selected parameters. <br><br>  But what is strange is that only 2 endpoints were announced, and 5 calls. Where did the extra ones come from?  In fact, there is no extra here.  The fact is that each USB device must have one two-way endpoint through which the device is initialized and then managed.  This end point is always number 0. This function is not initialized by the end points, but by the buffer.  For the zero end point, 2 buffers are created - 0x00 to receive and 0x80 to transmit (the high-order bit indicates the direction of transmission, the lower ones indicate the end-point number).  The remaining 3 calls describe the buffers for the end point 1 (receiving and transmitting data) and the end point 2 (receiving commands and sending status - this happens synchronously, so there is only one buffer) <br><br>  The last parameter in each call indicates the offset of the endpoint buffer in the common buffer.  On the forums I saw the questions ‚Äúwhat is this magic constant 0x18 (the starting address of the first buffer)?‚Äù.  I will discuss this issue in detail later.  Now I can only say that the first 0x18 bytes of PMA memory is occupied by the buffer allocation table. <br><br>  But these are all guts and other entrails.  And what's outside? <br><br>  The user code operates on the transmit and receive functions that are in the usbd_cdc_if.c file.  So that the device could send data to the virtual COM port in the direction of the host, we were provided with the function CDC_Transmit_FS () <br><br><div class="spoiler">  <b class="spoiler_title">CDC_Transmit_FS () function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief CDC_Transmit_FS * Data send over USB IN endpoint are sent over CDC interface * through this function. * @note * * * @param Buf: Buffer of data to be send * @param Len: Number of data to be send (in bytes) * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL or USBD_BUSY */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> CDC_Transmit_FS(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* Buf, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Len) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> result = USBD_OK; USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hcdc-&gt;TxState != <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> USBD_BUSY; } USBD_CDC_SetTxBuffer(&amp;hUsbDeviceFS, Buf, Len); result = USBD_CDC_TransmitPacket(&amp;hUsbDeviceFS); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br></div></div><br>  The reception is a bit more complicated: the USB core will pull the CDC_Receive_FS () function as it receives data.  In this function, you need to add your code that will process the received data.  Or call a callback that will handle the processing, like this: <br><br><div class="spoiler">  <b class="spoiler_title">CDC_Receive_FS () function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief CDC_Receive_FS * Data received over USB OUT endpoint are sent over CDC interface * through this function. * * @note * This function will block any OUT packet reception on USB endpoint * untill exiting this function. If you exit this function before transfer * is complete on CDC interface (ie. using DMA controller) it will result * in receiving more data while previous ones are still not sent. * * @param Buf: Buffer of data to be received * @param Len: Number of data received (in bytes) * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> int8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CDC_Receive_FS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* Buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> len = *Len; CDCDataReceivedCallback(Buf, len); <span class="hljs-comment"><span class="hljs-comment">// Prepare for next reception USBD_CDC_ReceivePacket(&amp;hUsbDeviceFS); return (USBD_OK); }</span></span></code> </pre> <br></div></div><br>  I pay attention that these functions work with arrays of bytes without any structure.  In my case, I needed to send strings.  To make it convenient, I wrote an analogue of the printf function, which formatted the string and sent it to the port.  To speed up, I was also puzzled by double buffering.  Read more <a href="https://geektimes.ru/post/291037/">here</a> in the ‚ÄúDouble Buffered USB‚Äù and ‚ÄúPrintf‚Äù sections. <br><br>  Also in the same file are the functions of initializing / deinitializing the virtual COM port, as well as the function of changing the port parameters (speed, parity, stop bits, etc.).  The default implementation does not limit itself to speed and that suits me.  Initialization is just as good.  Leave everything as it is. <br><br>  The final barcode - it all starts <br><br><div class="spoiler">  <b class="spoiler_title">the code that runs it all</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> USBD_Init(&amp;hUsbDeviceFS, &amp;FS_Desc, DEVICE_FS); USBD_RegisterClass(&amp;hUsbDeviceFS, &amp;USBD_CDC); USBD_CDC_RegisterInterface(&amp;hUsbDeviceFS, &amp;USBD_Interface_fops_FS); USBD_Start(&amp;hUsbDeviceFS);</code> </pre><br></div></div><br>  Here different levels of the driver are initialized.  The last command enables USB interrupts.  It is important to understand that all work with USB occurs on request from the host.  In this case, an interrupt is called inside the driver, which in turn either processes the request itself, or delegates this to another code via a callback. <br><br>  To make it all work you need a driver from the operating system.  As a rule, this is a standard driver and the system can pick up the device without a special installation procedure.  As far as I understand, my system already installed the <a href="http://www.st.com/en/development-tools/stsw-stm32102.html">Virtual COM Port driver from STM</a> (supplied with ST Flash Utility) and my device picked up on its own.  On Linux, it also started with a half-kick. <br><br><h2>  MSC - storage device </h2><br>  With the CDC driver everything was simple - the device, as a rule, is itself the final consumer of data (for example, receives commands from the host) or a generator (for example, sends sensor readings to the host). <br><br>  With Mass Storage Class will be a bit more complicated.  The MSC driver is just an interlayer between the host and the USB bus on the one hand, and the storage device on the other.  This could be an SDIO card connected via SDIO, SPI Flash, maybe a RAM Drive, a disk drive, and maybe even a network drive.  In general, in most cases, the storage device will be represented by a certain driver (usually non-trivial), which we will need to interface with the MSC implementation. <br><br>  My device uses an SD card connected via SPI.  To access the files on this map I use the <a href="https://github.com/greiman/SdFat">SdFat</a> library.  It is also divided into several levels of abstraction: <br><br><ul><li>  The user is provided with the File class, through which you can create / open files, read and write data.  The client code is not steamed by interaction with the storage medium and the subtleties of the file system. <br><br></li><li>  The Volume class deals with the entire kitchen in servicing the file system, directory, clusters, FAT and such.  Communication with the data carrier is delegated to the underlying levels. <br><br></li><li>  SD card driver - this component knows how to communicate with the card, which commands to send to it, and which ones to listen to answers.  The library provides several types of drivers for SPI and SDIO-connected cards.  Theoretically, you can substitute your driver, for example, for a RAM disk. <br><br></li><li>  Overlying layers of cross-platform, they do not know how exactly the data will be written to the card or read from it.  This allows you to build a library for different platforms (like Arduino, and others).  For a specific platform or microcontroller, you can write a driver that will implement data transfer through the necessary interface.  By default, the library provides several drivers, incl.  for Arduinov SPI, but I got confused and wrote my driver <s>with preference and poetess</s> transfer via DMA based on HAL. <br><br></li><li>  Finally, the HAL provides work with the registers of a particular microcontroller. </li></ul><br>  In the case of USB Mass Storage, we will not work with files on a flash drive - the host will do all the work of interpreting the file system.  The device will receive requests to read or write a specific data block.  So we will be interested in levels from the driver card and below. <br><br>  The implementation of the MSC requires a specific interface from the repository - to be able to read and write, give its size and status.  Approximately the same features are provided by the SdFat library SD card driver interface.  It remains only to write an adapter that will lead one interface to another. <br><br>  With the direction of movement determined.  Let's deal with the implementation.  I again used the CubeMX configurator and generated the necessary files for the USB component.  The study will begin, of course, with descriptors. <br><br><div class="spoiler">  <b class="spoiler_title">Device handle</b> <div class="spoiler_text"><pre> <code class="cpp hljs">* USB Standard Device Descriptor */ __ALIGN_BEGIN <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> USBD_FS_DeviceDesc[USB_LEN_DEV_DESC] __ALIGN_END = { <span class="hljs-number"><span class="hljs-number">0x12</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bLength */</span></span> USB_DESC_TYPE_DEVICE, <span class="hljs-comment"><span class="hljs-comment">/*bDescriptorType*/</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bcdUSB */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bDeviceClass*/</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bDeviceSubClass*/</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bDeviceProtocol*/</span></span> USB_MAX_EP0_SIZE, <span class="hljs-comment"><span class="hljs-comment">/*bMaxPacketSize*/</span></span> LOBYTE(USBD_VID), <span class="hljs-comment"><span class="hljs-comment">/*idVendor*/</span></span> HIBYTE(USBD_VID), <span class="hljs-comment"><span class="hljs-comment">/*idVendor*/</span></span> LOBYTE(USBD_PID_FS), <span class="hljs-comment"><span class="hljs-comment">/*idVendor*/</span></span> HIBYTE(USBD_PID_FS), <span class="hljs-comment"><span class="hljs-comment">/*idVendor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bcdDevice rel. 2.00*/</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, USBD_IDX_MFC_STR, <span class="hljs-comment"><span class="hljs-comment">/*Index of manufacturer string*/</span></span> USBD_IDX_PRODUCT_STR, <span class="hljs-comment"><span class="hljs-comment">/*Index of product string*/</span></span> USBD_IDX_SERIAL_STR, <span class="hljs-comment"><span class="hljs-comment">/*Index of serial number string*/</span></span> USBD_MAX_NUM_CONFIGURATION <span class="hljs-comment"><span class="hljs-comment">/*bNumConfigurations*/</span></span> } ; <span class="hljs-comment"><span class="hljs-comment">/* USB_DeviceDescriptor */</span></span></code> </pre> <br></div></div><br>  The device handle hasn't changed much.  The difference is only in the fields defining the device class - now the device class as a whole is not set (zeros in bDeviceClass), but will be set at the interface level (this is a <a href="http://www.usb.org/developers/docs/devclass_docs/usbmassbulk_10.pdf">specification</a> requirement). <br><br><div class="spoiler">  <b class="spoiler_title">Configuration descriptor</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Configuation Descriptor size */</span></span> USB_DESC_TYPE_CONFIGURATION, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: Configuration */</span></span> USB_MSC_CONFIG_DESC_SIZ, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bNumInterfaces: 1 interface */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bConfigurationValue: */</span></span> <span class="hljs-number"><span class="hljs-number">0x04</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* iConfiguration: */</span></span> <span class="hljs-number"><span class="hljs-number">0xC0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bmAttributes: */</span></span> <span class="hljs-number"><span class="hljs-number">0x32</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* MaxPower 100 mA */</span></span></code> </pre> <br></div></div><br>  Very similar to the similar descriptor from the CDC - the number of interfaces (1) and the bus power parameters (up to 100 mA) are determined <br><br><div class="spoiler">  <b class="spoiler_title">Interface descriptor</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Interface Descriptor size */</span></span> <span class="hljs-number"><span class="hljs-number">0x04</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceNumber: Number of Interface */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bAlternateSetting: Alternate setting */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bNumEndpoints*/</span></span> <span class="hljs-number"><span class="hljs-number">0x08</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceClass: MSC Class */</span></span> <span class="hljs-number"><span class="hljs-number">0x06</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceSubClass : SCSI transparent*/</span></span> <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* nInterfaceProtocol */</span></span> <span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* iInterface: */</span></span></code> </pre> <br></div></div><br>  The interface descriptor declares 2 endpoints (one for each side of the transfer).  The descriptor also defines which subclass Mass Storage is Bulk Only Transport.  I have not found an explanatory description of what this particular subclass is.  I assume that this is a device that communicates only through two-way data transfer through 2 endpoints (whereas other models can also use interrupts).  The protocol in this conversation is the SCSI commands. <br><br><div class="spoiler">  <b class="spoiler_title">Endpoint Descriptors</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*Endpoint descriptor length = 7*/</span></span> <span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*Endpoint descriptor type */</span></span> MSC_EPIN_ADDR, <span class="hljs-comment"><span class="hljs-comment">/*Endpoint address (IN, address 1) */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*Bulk endpoint type */</span></span> LOBYTE(MSC_MAX_FS_PACKET), HIBYTE(MSC_MAX_FS_PACKET), <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*Polling interval in milliseconds */</span></span> <span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*Endpoint descriptor length = 7 */</span></span> <span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*Endpoint descriptor type */</span></span> MSC_EPOUT_ADDR, <span class="hljs-comment"><span class="hljs-comment">/*Endpoint address (OUT, address 1) */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*Bulk endpoint type */</span></span> LOBYTE(MSC_MAX_FS_PACKET), HIBYTE(MSC_MAX_FS_PACKET), <span class="hljs-number"><span class="hljs-number">0x00</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Polling interval in milliseconds*/</span></span></code> </pre><br></div></div><br>  Here 2 end points of the Bulk type are defined - the USB interface does not guarantee speed over such end points, but it guarantees data delivery.  The packet size is set to 64 bytes. <br><br>  Since we are talking about endpoints, it is worth looking into the usbd_conf.c file where the corresponding PMA buffers are defined. <br><br><div class="spoiler">  <b class="spoiler_title">Configuring PMA Buffers</b> <div class="spoiler_text"><pre> <code class="cpp hljs">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , <span class="hljs-number"><span class="hljs-number">0x00</span></span> , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x18</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , <span class="hljs-number"><span class="hljs-number">0x80</span></span> , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x58</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , <span class="hljs-number"><span class="hljs-number">0x81</span></span> , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x98</span></span>); HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , <span class="hljs-number"><span class="hljs-number">0x01</span></span> , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0xD8</span></span>);</code> </pre> <br></div></div><br>  Now look at the MSC from the other side.  This USB class accepts read / write commands from the host and broadcasts their specialized interface, USBD_StorageTypeDef.  We can only substitute its implementation. <br><br><div class="spoiler">  <b class="spoiler_title">Device interface</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** @defgroup USB_CORE_Exported_Types * @{ */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">USBD_STORAGE</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> (* Init) (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun); <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> (* GetCapacity) (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *block_num, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> *block_size); <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> (* IsReady) (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun); <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> (* IsWriteProtected) (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun); <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> (* Read) (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> blk_addr, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> blk_len); <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> (* Write)(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> blk_addr, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> blk_len); <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> (* GetMaxLun)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> *pInquiry; }USBD_StorageTypeDef;</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since this is C, not C ++, each of these entries is a pointer to the corresponding function. </font><font style="vertical-align: inherit;">As I said, we need to write an adapter that will lead the MSC interface to the SD card interface. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start to implement the interface. </font><font style="vertical-align: inherit;">The first is the initialization function.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialization function</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> SD_MSC_Init (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)lun; <span class="hljs-comment"><span class="hljs-comment">// Not used // if(!initSD()) // return USBD_FAIL; return (USBD_OK); }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So the SD card could be initialized right from here, if it was a quick operation. </font><font style="vertical-align: inherit;">But in the case of an SD card, this may not always be the case. </font><font style="vertical-align: inherit;">In addition, do not forget that all these functions are callbacks and are called from a USB interrupt, and it is not worth blocking interrupts for a long time. </font><font style="vertical-align: inherit;">Therefore, I call the function initSD () directly from main () before initializing USB, and SD_MSC_Init () does nothing for me</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Card Initialization</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">SdFatSPIDriver spiDriver; SdSpiCard card; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initSD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> card.begin(&amp;spiDriver, PA4, SPI_FULL_SPEED); }</code> </pre> <br></div></div><br>  ,     ,     .  SdSpiCard   SdFat     SD   SPI,         .         SPI.       SdFatSPIDriver,       SPI     DMA. <br><br>  Go ahead. <br><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> SD_MSC_GetCapacity (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *block_num, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> *block_size) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)lun; <span class="hljs-comment"><span class="hljs-comment">// Not used *block_num = card.cardSize(); *block_size = 512; return (USBD_OK); }</span></span></code> </pre> <br></div></div><br>  SD_MSC_GetCapacity()  ‚Äî SdSpiCard        <br><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> SD_MSC_Read (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> blk_addr, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> blk_len) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)lun; <span class="hljs-comment"><span class="hljs-comment">// Not used if(!card.readBlocks(blk_addr, buf, blk_len)) return USBD_FAIL; return (USBD_OK); } int8_t SD_MSC_Write (uint8_t lun, uint8_t *buf, uint32_t blk_addr, uint16_t blk_len) { (void)lun; // Not used if(!card.writeBlocks(blk_addr, buf, blk_len)) return USBD_FAIL; return (USBD_OK); }</span></span></code> </pre> <br></div></div><br>       . <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> SD_MSC_IsReady (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)lun; <span class="hljs-comment"><span class="hljs-comment">// Not used return (USBD_OK); } int8_t SD_MSC_IsWriteProtected (uint8_t lun) { (void)lun; // Not used return (USBD_OK); // Never write protected }</span></span></code> </pre> <br></div></div><br>      (        )     . <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> SD_MSC_GetMaxLun (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// We have just 1 Logic unit number (LUN) which is zero }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LUN - Logic Unit Number. </font><font style="vertical-align: inherit;">Theoretically, our storage device may consist of several media (for example, hard drives in a raid). </font><font style="vertical-align: inherit;">All functions of the SCSI protocol indicate with what carrier it wants to work. </font><font style="vertical-align: inherit;">The GetMaxLun function returns the last device number (the number of devices minus 1). </font><font style="vertical-align: inherit;">We have one flash drive because we return 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the last thing.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Storage handle</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> SD_MSC_Inquirydata[] = {<span class="hljs-comment"><span class="hljs-comment">/* 36 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* LUN 0 */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, (STANDARD_INQUIRY_DATA_LEN - <span class="hljs-number"><span class="hljs-number">5</span></span>), <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-string"><span class="hljs-string">'S'</span></span>, <span class="hljs-string"><span class="hljs-string">'T'</span></span>, <span class="hljs-string"><span class="hljs-string">'M'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* Manufacturer : 8 bytes */</span></span> <span class="hljs-string"><span class="hljs-string">'P'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span>, <span class="hljs-string"><span class="hljs-string">'u'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'t'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* Product : 16 Bytes */</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>, <span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span> ,<span class="hljs-string"><span class="hljs-string">'1'</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Version : 4 Bytes */</span></span> };</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To be honest, I really did not understand why it is needed. Looking into the SCSI specification, I saw a lot of fields of meaning, which I did not understand. From what I have mastered - here is described the standard device with direct (not sequential) access, and which can be removed (removable). The benefit of all the examples that I saw this array is the same, so let it be. Debugged after all. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now all this needs to be correctly initialized.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Initialization</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> USBD_StatusTypeDef res = USBD_Init(&amp;hUsbDeviceFS, &amp;FS_Desc, DEVICE_FS); USBD_RegisterClass(&amp;hUsbDeviceFS, &amp;USBD_MSC); USBD_MSC_RegisterStorage(&amp;hUsbDeviceFS, &amp;SdMscDriver); USBD_Start(&amp;hUsbDeviceFS);</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connect, check. Everything works, though very slowly - the connected disk opens for about 50 seconds. This is partly due to the fact that the linear speed of reading the flash drive through this interface is about 200 kb / s. When the USB Mass Storage device is connected to a computer, the operating system reads the FAT table. I use a flash drive for 8 gig, and there FAT is already 7.5 megabytes. Plus reading the MBR, boot sector, file table - that‚Äôs almost 50 seconds.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I also had to disable DMA when working with an SD card - it‚Äôs not so easy to turn it on. </font><font style="vertical-align: inherit;">The fact is that my driver implementation (as it turned out) cannot work from an interrupt, and in USB everything works only through interrupts. </font><font style="vertical-align: inherit;">Even the banal HAL_Delay () does not work. </font><font style="vertical-align: inherit;">it is also tied to interrupts, not to mention synchronization using FreeRTOS. </font><font style="vertical-align: inherit;">It will need to be redone, but this is a separate story and it does not apply to the USB composite device. </font><font style="vertical-align: inherit;">If I redo it, I will definitely write an article about it and leave a link here. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPDATE: as promised </font></font><a href="https://habrahabr.ru/post/336968/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here is the link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Managed to pump speed up to 650kb / s</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CDC + MSC Composite Device </font></font></h2><br> <i>         () </i> <br><br> ,      USB ,     CDC  MSC.    ,     .     ,    USB  ,   ,    .  :    ,        . <br><br>       STM32 Cube (Middlewares\ST\STM32_USB_Device_Library\Class\Template).      <a href="http://forum.easyelectronics.ru/viewtopic.php%3Ff%3D35%26t%3D23349"></a> . <br><br>  USB   : <br><br><ul><li>      ,    3  </li><li>    MSC <ul><li>       ‚Äî     </li></ul></li><li> CDC   . <br><ul><li>   .          </li><li>   CDC  .      ‚Äî     </li></ul></li><li>           (  USB ) </li></ul><br><img src="https://habrastorage.org/web/e99/ce3/0be/e99ce30be8294a32ab821981f824d044.png" alt="image"><br> <i> ,      .   <a href="http://www.usb.org/developers/docs/whitepapers/iadclasscode_r10.pdf"> IAD</a></i> <br><br>           . <br><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MSC_INTERFACE_IDX 0x0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Index of MSC interface #define CDC_INTERFACE_IDX 0x1 // Index of CDC interface // endpoints numbers // endpoints numbers #define MSC_EP_IDX 0x01 #define CDC_CMD_EP_IDX 0x02 #define CDC_EP_IDX 0x03 #define IN_EP_DIR 0x80 // Adds a direction bit #define MSC_OUT_EP MSC_EP_IDX /* EP1 for BULK OUT */ #define MSC_IN_EP MSC_EP_IDX | IN_EP_DIR /* EP1 for BULK IN */ #define CDC_CMD_EP CDC_CMD_EP_IDX| IN_EP_DIR /* EP2 for CDC commands */ #define CDC_OUT_EP CDC_EP_IDX /* EP3 for data OUT */ #define CDC_IN_EP CDC_EP_IDX | IN_EP_DIR /* EP3 for data IN */</span></span></span></span></code> </pre> <br></div></div><br>      .   ‚Ññ1  MSC, ‚Ññ2   CDC, ‚Ññ3     CDC.         ,       USB      . <br><br>  USB   ST   .            ‚Äî      IN ‚Äî    (     IN_EP_DIR).         .                  .       EP_IDX     . <br><br><blockquote>  IMPORTANT!    USB       ,           ,      .       ,   USB            . </blockquote><br>     .          (usbd_msc_cdc.c),            USB   usbd_desc.c <br><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_VID 0x0483 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_PID 0x5741 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_LANGID_STRING 0x409 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_MANUFACTURER_STRING </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"STMicroelectronics"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_PRODUCT_FS_STRING </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Composite MSC CDC"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_SERIALNUMBER_FS_STRING </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"00000000055C"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_CONFIGURATION_FS_STRING </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Config Name"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_INTERFACE_FS_STRING </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Interface Name"</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Device handle</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__ALIGN_BEGIN <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> USBD_FS_DeviceDesc[USB_LEN_DEV_DESC] __ALIGN_END = { <span class="hljs-number"><span class="hljs-number">0x12</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bLength */</span></span> USB_DESC_TYPE_DEVICE, <span class="hljs-comment"><span class="hljs-comment">/*bDescriptorType*/</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bcdUSB */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0xEF</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bDeviceClass*/</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bDeviceSubClass*/</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bDeviceProtocol*/</span></span> USB_MAX_EP0_SIZE, <span class="hljs-comment"><span class="hljs-comment">/*bMaxPacketSize*/</span></span> LOBYTE(USBD_VID), <span class="hljs-comment"><span class="hljs-comment">/*idVendor*/</span></span> HIBYTE(USBD_VID), <span class="hljs-comment"><span class="hljs-comment">/*idVendor*/</span></span> LOBYTE(USBD_PID), <span class="hljs-comment"><span class="hljs-comment">/*idVendor*/</span></span> HIBYTE(USBD_PID), <span class="hljs-comment"><span class="hljs-comment">/*idVendor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*bcdDevice rel. 2.00*/</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, USBD_IDX_MFC_STR, <span class="hljs-comment"><span class="hljs-comment">/*Index of manufacturer string*/</span></span> USBD_IDX_PRODUCT_STR, <span class="hljs-comment"><span class="hljs-comment">/*Index of product string*/</span></span> USBD_IDX_SERIAL_STR, <span class="hljs-comment"><span class="hljs-comment">/*Index of serial number string*/</span></span> USBD_MAX_NUM_CONFIGURATION <span class="hljs-comment"><span class="hljs-comment">/*bNumConfigurations*/</span></span> };</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, everything is the same here, only the fields that define the device class (bDeviceClass) differ. </font><font style="vertical-align: inherit;">Now these fields indicate that this is a composite device. </font><font style="vertical-align: inherit;">The host will need to work hard to figure out all the other descriptors and load the correct drivers for each of the components. </font><font style="vertical-align: inherit;">The bDeviceProtocol field means that parts of the composite device will be described by a special descriptor ‚Äî the Interface Association Descriptor. </font><font style="vertical-align: inherit;">About him a little lower. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The configuration descriptor is about the same as before, the difference is only in the number of interfaces. </font><font style="vertical-align: inherit;">Now we have them 3</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration descriptor</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USB_MSC_CDC_CONFIG_DESC_SIZ 98 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USB MSC+CDC device Configuration Descriptor */</span></span></span><span class="hljs-meta"> static const uint8_t USBD_MSC_CDC_CfgDesc[USB_MSC_CDC_CONFIG_DESC_SIZ] = { 0x09, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* bLength: Configuation Descriptor size */</span></span></span><span class="hljs-meta"> USB_DESC_TYPE_CONFIGURATION, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* bDescriptorType: Configuration */</span></span></span><span class="hljs-meta"> USB_MSC_CDC_CONFIG_DESC_SIZ, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* wTotalLength: Bytes returned */</span></span></span><span class="hljs-meta"> 0x00, 0x03, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*bNumInterfaces: 3 interface*/</span></span></span><span class="hljs-meta"> 0x01, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*bConfigurationValue: Configuration value*/</span></span></span><span class="hljs-meta"> 0x02, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*iConfiguration: Index of string descriptor describing the configuration*/</span></span></span><span class="hljs-meta"> 0xC0, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*bmAttributes: bus powered and Supports Remote Wakeup */</span></span></span><span class="hljs-meta"> 0x32, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*MaxPower 100 mA: this current is used for detecting Vbus*/</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* 09 bytes */</span></span></span></span></code> </pre> <br></div></div><br>         MSC.        ( MSC  CDC).      ,   ,   .       . ,        .          . <br><br><div class="spoiler"> <b class="spoiler_title"> MSC</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/******************** Mass Storage interface ********************/</span></span> <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Interface Descriptor size */</span></span> <span class="hljs-number"><span class="hljs-number">0x04</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: */</span></span> MSC_INTERFACE_IDX, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceNumber: Number of Interface */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bAlternateSetting: Alternate setting */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bNumEndpoints*/</span></span> <span class="hljs-number"><span class="hljs-number">0x08</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceClass: MSC Class */</span></span> <span class="hljs-number"><span class="hljs-number">0x06</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceSubClass : SCSI transparent command set*/</span></span> <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* nInterfaceProtocol */</span></span> USBD_IDX_INTERFACE_STR, <span class="hljs-comment"><span class="hljs-comment">/* iInterface: */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 09 bytes */</span></span> <span class="hljs-comment"><span class="hljs-comment">/******************** Mass Storage Endpoints ********************/</span></span> <span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*Endpoint descriptor length = 7*/</span></span> <span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*Endpoint descriptor type */</span></span> MSC_IN_EP, <span class="hljs-comment"><span class="hljs-comment">/*Endpoint address (IN, address 1) */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*Bulk endpoint type */</span></span> LOBYTE(USB_MAX_PACKET_SIZE), HIBYTE(USB_MAX_PACKET_SIZE), <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*Polling interval in milliseconds */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 07 bytes */</span></span> <span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*Endpoint descriptor length = 7 */</span></span> <span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*Endpoint descriptor type */</span></span> MSC_OUT_EP, <span class="hljs-comment"><span class="hljs-comment">/*Endpoint address (OUT, address 1) */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*Bulk endpoint type */</span></span> LOBYTE(USB_MAX_PACKET_SIZE), HIBYTE(USB_MAX_PACKET_SIZE), <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*Polling interval in milliseconds*/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 07 bytes */</span></span></code> </pre> <br></div></div><br>  MSC     ,     . <br><br>        ‚Äî IAD (Interface Association Descriptor) ‚Äì   .      ,         . <br><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/******** IAD should be positioned just before the CDC interfaces ****** IAD to associate the two CDC interfaces */</span></span> <span class="hljs-number"><span class="hljs-number">0x08</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength */</span></span> <span class="hljs-number"><span class="hljs-number">0x0B</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType */</span></span> CDC_INTERFACE_IDX, <span class="hljs-comment"><span class="hljs-comment">/* bFirstInterface */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceCount */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bFunctionClass */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bFunctionSubClass */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bFunctionProtocol */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* iFunction (Index of string descriptor describing this function) */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 08 bytes */</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This tricky descriptor tells the host that the description of the previous function of the USB device (MSC) has ended and now there will be a completely different function. </font><font style="vertical-align: inherit;">And it is immediately indicated which one - CDC. </font><font style="vertical-align: inherit;">It also indicates the number of interfaces associated with it and the index of the first one. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAD descriptor is not needed for MSC, because </font><font style="vertical-align: inherit;">there is only one interface. </font><font style="vertical-align: inherit;">But IAD is needed for CDC to group 2 interfaces into one function. </font><font style="vertical-align: inherit;">This is stated in the </font></font><a href="http://www.usb.org/developers/docs/whitepapers/iadclasscode_r10.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">specification of this descriptor.</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finally, the CDC descriptors. </font><font style="vertical-align: inherit;">They fully correspond to the descriptors for a single CDC function with an accuracy of interface and endpoint numbers.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CDC Descriptors</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/******************** CDC interfaces ********************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Interface Descriptor */</span></span> <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Interface Descriptor size */</span></span> USB_DESC_TYPE_INTERFACE, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: Interface */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Interface descriptor type */</span></span> CDC_INTERFACE_IDX, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceNumber: Number of Interface */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bAlternateSetting: Alternate setting */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bNumEndpoints: One endpoints used */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceClass: Communication Interface Class */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceSubClass: Abstract Control Model */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceProtocol: Common AT commands */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* iInterface: */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 09 bytes */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Header Functional Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Endpoint Descriptor size */</span></span> <span class="hljs-number"><span class="hljs-number">0x24</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: CS_INTERFACE */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorSubtype: Header Func Desc */</span></span> <span class="hljs-number"><span class="hljs-number">0x10</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bcdCDC: spec release number */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* 05 bytes */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Call Management Functional Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bFunctionLength */</span></span> <span class="hljs-number"><span class="hljs-number">0x24</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: CS_INTERFACE */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorSubtype: Call Management Func Desc */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bmCapabilities: D0+D1 */</span></span> CDC_INTERFACE_IDX + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDataInterface: 2 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 05 bytes */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*ACM Functional Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x04</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bFunctionLength */</span></span> <span class="hljs-number"><span class="hljs-number">0x24</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: CS_INTERFACE */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorSubtype: Abstract Control Management desc */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bmCapabilities */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 04 bytes */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Union Functional Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bFunctionLength */</span></span> <span class="hljs-number"><span class="hljs-number">0x24</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: CS_INTERFACE */</span></span> <span class="hljs-number"><span class="hljs-number">0x06</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorSubtype: Union func desc */</span></span> CDC_INTERFACE_IDX, <span class="hljs-comment"><span class="hljs-comment">/* bMasterInterface: Communication class interface */</span></span> CDC_INTERFACE_IDX + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bSlaveInterface0: Data Class Interface */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 05 bytes */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Endpoint 2 Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Endpoint Descriptor size */</span></span> USB_DESC_TYPE_ENDPOINT, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: Endpoint */</span></span> CDC_CMD_EP, <span class="hljs-comment"><span class="hljs-comment">/* bEndpointAddress */</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bmAttributes: Interrupt */</span></span> LOBYTE(CDC_CMD_PACKET_SIZE), <span class="hljs-comment"><span class="hljs-comment">/* wMaxPacketSize: */</span></span> HIBYTE(CDC_CMD_PACKET_SIZE), <span class="hljs-number"><span class="hljs-number">0x10</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterval: */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 07 bytes */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Data class interface descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Endpoint Descriptor size */</span></span> USB_DESC_TYPE_INTERFACE, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: */</span></span> CDC_INTERFACE_IDX + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceNumber: Number of Interface */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bAlternateSetting: Alternate setting */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bNumEndpoints: Two endpoints used */</span></span> <span class="hljs-number"><span class="hljs-number">0x0A</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceClass: CDC */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceSubClass: */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceProtocol: */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* iInterface: */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 09 bytes */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Endpoint OUT Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Endpoint Descriptor size */</span></span> USB_DESC_TYPE_ENDPOINT, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: Endpoint */</span></span> CDC_OUT_EP, <span class="hljs-comment"><span class="hljs-comment">/* bEndpointAddress */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bmAttributes: Bulk */</span></span> LOBYTE(CDC_DATA_PACKET_SIZE), <span class="hljs-comment"><span class="hljs-comment">/* wMaxPacketSize: */</span></span> HIBYTE(CDC_DATA_PACKET_SIZE), <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterval: ignore for Bulk transfer */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 07 bytes */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Endpoint IN Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Endpoint Descriptor size */</span></span> USB_DESC_TYPE_ENDPOINT, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: Endpoint */</span></span> CDC_IN_EP, <span class="hljs-comment"><span class="hljs-comment">/* bEndpointAddress */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bmAttributes: Bulk */</span></span> LOBYTE(CDC_DATA_PACKET_SIZE), <span class="hljs-comment"><span class="hljs-comment">/* wMaxPacketSize: */</span></span> HIBYTE(CDC_DATA_PACKET_SIZE), <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterval */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 07 bytes */</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When all the descriptors are ready, you can calculate the total size of the configuration. </font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USB_CDC_CONFIG_DESC_SIZ 98</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's move on to writing code. </font><font style="vertical-align: inherit;">USB core communicates with class drivers using this interface</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class driver interface</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Device_cb</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> (*Init) (struct _USBD_HandleTypeDef *pdev , <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> cfgidx); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> (*DeInit) (struct _USBD_HandleTypeDef *pdev , <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> cfgidx); <span class="hljs-comment"><span class="hljs-comment">/* Control Endpoints*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> (*Setup) (struct _USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef *req); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> (*EP0_TxSent) (struct _USBD_HandleTypeDef *pdev ); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> (*EP0_RxReady) (struct _USBD_HandleTypeDef *pdev ); <span class="hljs-comment"><span class="hljs-comment">/* Class Specific Endpoints*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> (*DataIn) (struct _USBD_HandleTypeDef *pdev , <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> epnum); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> (*DataOut) (struct _USBD_HandleTypeDef *pdev , <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> epnum); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> (*SOF) (struct _USBD_HandleTypeDef *pdev); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> (*IsoINIncomplete) (struct _USBD_HandleTypeDef *pdev , <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> epnum); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> (*IsoOUTIncomplete) (struct _USBD_HandleTypeDef *pdev , <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> epnum); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *(*GetHSConfigDescriptor)(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> *length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *(*GetFSConfigDescriptor)(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> *length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *(*GetOtherSpeedConfigDescriptor)(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> *length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *(*GetDeviceQualifierDescriptor)(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> *length); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (USBD_SUPPORT_USER_STRING == 1) uint8_t *(*GetUsrStrDescriptor)(struct _USBD_HandleTypeDef *pdev ,uint8_t index, uint16_t *length); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } USBD_ClassTypeDef;</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depending on the status or event on the USB bus, the kernel calls the appropriate function. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Any architectural problem can be solved by introducing an additional abstract layer ... (C) another anecdote.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Of course, we will not implement all the functionality entirely - the existing code will be responsible for the implementation of the CDC and MSC classes. </font><font style="vertical-align: inherit;">We will only write an interlayer that will redirect calls to either one or another implementation.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialization and Deinitialization</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief USBD_MSC_CDC_Init * Initialize the MSC+CDC interface * @param pdev: device instance * @param cfgidx: Configuration index * @retval status */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USBD_MSC_CDC_Init</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USBD_HandleTypeDef *pdev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cfgidx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* MSC initialization */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ret = USBD_MSC_Init (pdev, cfgidx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ret != USBD_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; <span class="hljs-comment"><span class="hljs-comment">/* CDC initialization */</span></span> ret = USBD_CDC_Init (pdev, cfgidx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ret != USBD_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> USBD_OK; } <span class="hljs-comment"><span class="hljs-comment">/** * @brief USBD_MSC_CDC_Init * DeInitialize the MSC+CDC layer * @param pdev: device instance * @param cfgidx: Configuration index * @retval status */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USBD_MSC_CDC_DeInit</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USBD_HandleTypeDef *pdev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cfgidx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* MSC De-initialization */</span></span> USBD_MSC_DeInit(pdev, cfgidx); <span class="hljs-comment"><span class="hljs-comment">/* CDC De-initialization */</span></span> USBD_CDC_DeInit(pdev, cfgidx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> USBD_OK; }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything is simple: we initialize (deinitialize) both classes. </font><font style="vertical-align: inherit;">Called functions themselves will create / delete their endpoints. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps the most difficult function will be Setup.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setup Handler</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief USBD_MSC_CDC_Setup * Handle the MSC+CDC specific requests * @param pdev: instance * @param req: usb requests * @retval status */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USBD_MSC_CDC_Setup</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Route requests to MSC interface or its endpoints to MSC class implementaion if(((req-&gt;bmRequest &amp; USB_REQ_RECIPIENT_MASK) == USB_REQ_RECIPIENT_INTERFACE &amp;&amp; req-&gt;wIndex == MSC_INTERFACE_IDX) || ((req-&gt;bmRequest &amp; USB_REQ_RECIPIENT_MASK) == USB_REQ_RECIPIENT_ENDPOINT &amp;&amp; ((req-&gt;wIndex &amp; 0x7F) == MSC_EP_IDX))) { return USBD_MSC_Setup(pdev, req); } return USBD_CDC_Setup(pdev, req); }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a callback to one of the standard requests on the USB bus, but this request is very multifaceted. It can be both data acquisition (get), and installation (Set). This may be a request to the device as a whole, to one of its interfaces or endpoints. It can also come here as a standard request defined by the basic specification of USB, and specific to a particular device or class. Read more </font></font><a href="http://microsin.net/programming/arm-working-with-usb/usb-in-a-nutshell-part2.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Section ‚ÄúSetup Package‚Äù).</font></font><br><br> -       Setup  .      if  switch.    USB    3-4           (    ).   ,          . <br><br>         , ,    .     ‚Äî   wIndex   ,   ,   wIndex    .        . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> By the way, in order for this to work, you need not to forget to change the default, which determines the number of interfaces, otherwise the request will simply not reach and cut off inside the USB core </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_MAX_NUM_INTERFACES 3</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DataIn and DataOut are all easier. </font><font style="vertical-align: inherit;">There is the number of the end point - by it and we determine where the request is redirected</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DataIn () and DataOut ()</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief USBD_MSC_CDC_DataIn * handle data IN Stage * @param pdev: device instance * @param epnum: endpoint index * @retval status */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USBD_MSC_CDC_DataIn</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USBD_HandleTypeDef *pdev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> epnum)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(epnum == MSC_EP_IDX) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> USBD_MSC_DataIn(pdev, epnum); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> USBD_CDC_DataIn(pdev, epnum); } <span class="hljs-comment"><span class="hljs-comment">/** * @brief USBD_MSC_CDC_DataOut * handle data OUT Stage * @param pdev: device instance * @param epnum: endpoint index * @retval status */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USBD_MSC_CDC_DataOut</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USBD_HandleTypeDef *pdev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> epnum)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(epnum == MSC_EP_IDX) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> USBD_MSC_DataOut(pdev, epnum); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> USBD_CDC_DataOut(pdev, epnum); }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Please note that the transmission direction flag in the endpoint number is not used. </font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">even if some functions use MSC_IN_EP (0x81), then in this function you need to use MSC_EP_IDX (0x01). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sometimes the data comes to the zero end point and for this there is a special callback. </font><font style="vertical-align: inherit;">I don‚Äôt know what I would do if both classes (both CDC and MSC) had handlers for this case - the interface or endpoint number was not specified in such a request. </font><font style="vertical-align: inherit;">It would be impossible to understand to whom the request is addressed. </font><font style="vertical-align: inherit;">The benefit of such a request is able to handle only the CDC class - so we will send it</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EP0_RxReady Handler</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief USBD_MSC_CDC_EP0_RxReady * handle EP0 Rx Ready event * @param pdev: device instance * @retval status */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USBD_MSC_CDC_EP0_RxReady</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USBD_HandleTypeDef *pdev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> USBD_CDC_EP0_RxReady(pdev); }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No longer will we have non-trivial handlers. </font><font style="vertical-align: inherit;">There are a couple of getters for the descriptors, but their code is standard and not of interest. </font><font style="vertical-align: inherit;">Fill in the "virtual functions table"</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Function pointers table</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">USBD_ClassTypeDef USBD_MSC_CDC_ClassDriver = { USBD_MSC_CDC_Init, USBD_MSC_CDC_DeInit, USBD_MSC_CDC_Setup, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">//USBD_MSC_CDC_EP0_TxReady, USBD_MSC_CDC_EP0_RxReady, USBD_MSC_CDC_DataIn, USBD_MSC_CDC_DataOut, NULL, //USBD_MSC_CDC_SOF, NULL, //USBD_MSC_CDC_IsoINIncomplete, NULL, //USBD_MSC_CDC_IsoOutIncomplete, USBD_MSC_CDC_GetCfgDesc, USBD_MSC_CDC_GetCfgDesc, USBD_MSC_CDC_GetCfgDesc, USBD_MSC_CDC_GetDeviceQualifierDesc, };</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now the initialization code </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialization code</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">USBD_Init(&amp;hUsbDeviceFS, &amp;FS_Desc, <span class="hljs-number"><span class="hljs-number">0</span></span>); USBD_RegisterClass(&amp;hUsbDeviceFS, &amp;USBD_MSC_CDC_ClassDriver); USBD_CDC_RegisterInterface(&amp;hUsbDeviceFS, &amp;USBD_Interface_fops_FS); USBD_MSC_RegisterStorage(&amp;hUsbDeviceFS, &amp;SdMscDriver); USBD_Start(&amp;hUsbDeviceFS);</code> </pre> <br></div></div><br>  USB ,         .  Everything?   .      . <br><br>  The point is this.        ‚Äì  ,   ,        .         ‚Äì     USB  (        ,   ).    USB        <br><br><div class="spoiler"> <b class="spoiler_title">     USB</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USB Device handle structure */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">USBD_HandleTypeDef</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *pClassData; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *pUserData; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *pData; } USBD_HandleTypeDef;</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem is that each class considers these fields as its own and clings its structure there. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This can be solved in several ways. </font><font style="vertical-align: inherit;">Comrades </font></font><a href="https://community.st.com/thread/31455"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generally pushed all the code from both drivers (CDC and MSC) into their class implementation in order to figure out what was happening. </font><font style="vertical-align: inherit;">Another approach is to put structures in these fields in which there is room for both classes of data. </font></font><a href="http://forum.easyelectronics.ru/viewtopic.php%3Ff%3D35%26t%3D23349"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this approach is partially used, in addition another part of the data is transferred to global variables (which is ok, if we have only one USB port). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will probably take a simpler path. </font><font style="vertical-align: inherit;">If class drivers want exclusive fields, we‚Äôll give them these fields.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'Right' USB Handle Fields</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">USBD_HandleTypeDef</span></span></span><span class="hljs-class"> {</span></span> ... USBD_MSC_BOT_HandleTypeDef *pClassDataMSC; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> USBD_StorageTypeDef *pClassSpecificInterfaceMSC; USBD_CDC_HandleTypeDef *pClassDataCDC; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> USBD_CDC_ItfTypeDef *pClassSpecificInterfaceCDC; PCD_HandleTypeDef *pPCDHandle; } USBD_HandleTypeDef;</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, I gave each class its own fields - let them be tormented as they want. Secondly, I named these fields according to the fact that there really is in them - no UserData there, but a pointer to the interface. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, on the pros, it would be more beautiful and elegant (with the same memory consumption and memory). but also on C can be done humanly. Since I launched my little hands into the handle structure, I changed the incomprehensible void * to human types (by the way, the void * pData field is now humanly called pPCDHandle with the corresponding type). And const also placed where necessary. It was necessary, however, to tinker with forward declarations.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About the organization of the project. </font><font style="vertical-align: inherit;">In some IDE projects can be built as follows. </font><font style="vertical-align: inherit;">The USB library and source code for the class drivers come with the STM32 Cube, but some of the files are suggested to be written to the user. </font><font style="vertical-align: inherit;">It may happen that the library lies somewhere in a common location and is used by several projects. </font><font style="vertical-align: inherit;">It should be understood that I now we are changing the code of the USB library and therefore it is better to have our own copy so as not to disturb anyone.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, renaming fields should be reflected in the driver code. </font><font style="vertical-align: inherit;">But here everything is just simple - contextual replacement solves the problem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main thing is not to overdo it. </font><font style="vertical-align: inherit;">I changed hands, looking through each use. </font><font style="vertical-align: inherit;">There I found a "bug" in the code, I fixed it and then I debugged 3 days in an attempt to understand why it was not working.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Type 'bug'</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">USBD_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USBD_LL_Reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USBD_HandleTypeDef *pdev)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pdev-&gt;pClassData) pdev-&gt;pClass-&gt;DeInit(pdev, pdev-&gt;dev_config); ... }</code> </pre></div></div><br>      ‚Äì  pClassData,    pClass.  ¬´¬ª ( pClass),    .  Those. pClassData    ,   . <br><br>    .  Init()    pClassDataXXX,       . <br><br> UPDATE:  ,   <a href="https://habr.com/users/fronders/" class="user_link">fronders</a> . <br>     (CDC, HID, MSC,    )    ( USBD_CDC_Init() )    pClassDataXXX    USBD_malloc(),        malloc().     ‚Äî      . <br><br><div class="spoiler"> <b class="spoiler_title">  USBD_CDC_Init()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USBD_CDC_Init</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USBD_HandleTypeDef *pdev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cfgidx)</span></span></span><span class="hljs-function"> </span></span>{ ... pdev-&gt;pClassData = USBD_malloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (USBD_CDC_HandleTypeDef)); ... }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But, in some projects (including examples from STMicroelectronics itself) they decided to save on memory and wrote their implementation of the allocator </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not very correct allocator</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USBD_static_malloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mem[(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(USBD_CDC_HandleTypeDef)/<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>)];<span class="hljs-comment"><span class="hljs-comment">/* On 32-bit boundary */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mem; }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In principle, this approach will work, but only for the time being we have only one class of device. </font><font style="vertical-align: inherit;">As soon as several classes try to ‚Äúallocate‚Äù memory through such an allocator, everything will break, because </font><font style="vertical-align: inherit;">several classes will torment the same buffer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, it </font><font style="vertical-align: inherit;">will be necessary </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to allocate</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memory only if you build a device with several identical functions - for example, a device that implements two or more CDCs. </font><font style="vertical-align: inherit;">Well, maybe this is still needed in some exotic cases, when interfaces are created and deleted on the fly. </font><font style="vertical-align: inherit;">In all other cases (of which the vast majority) I would not bother with the allocation of memory and distributed the buffer statically. </font><font style="vertical-align: inherit;">In my project, I did this (at the same time, the types of data are whitened-colored):</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static allocation</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// A CDC object USBD_CDC_HandleTypeDef cdcInstance; ... uint8_t USBD_CDC_Init (USBD_HandleTypeDef *pdev, uint8_t cfgidx) { ... pdev-&gt;pClassDataCDC = &amp;cdcInstance; hcdc = pdev-&gt;pClassDataCDC; ... }</span></span></code> </pre><br></div></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Final Touch - PMA Buffer Distribution </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PMA distribution</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"> HAL_PCDEx_PMAConfig(pdev-&gt;pPCDHandle , <span class="hljs-number"><span class="hljs-number">0x00</span></span> , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x20</span></span>); HAL_PCDEx_PMAConfig(pdev-&gt;pPCDHandle , <span class="hljs-number"><span class="hljs-number">0x80</span></span> , PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x60</span></span>); HAL_PCDEx_PMAConfig(pdev-&gt;pPCDHandle , MSC_IN_EP, PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0xA0</span></span>); HAL_PCDEx_PMAConfig(pdev-&gt;pPCDHandle , MSC_OUT_EP, PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>); HAL_PCDEx_PMAConfig(pdev-&gt;pPCDHandle, CDC_CMD_EP, PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x100</span></span>); HAL_PCDEx_PMAConfig(pdev-&gt;pPCDHandle, CDC_IN_EP, PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x140</span></span>); HAL_PCDEx_PMAConfig(pdev-&gt;pPCDHandle, CDC_OUT_EP, PCD_SNG_BUF, <span class="hljs-number"><span class="hljs-number">0x180</span></span>);</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For our endpoints, we need 7 buffers - 2 to the zero end point (control point), 2 to the MSC and 3 to the CDC. </font><font style="vertical-align: inherit;">But the most interesting thing here is the starting addresses (the last parameter). </font><font style="vertical-align: inherit;">For some reason, this nuance is carefully managed with all tutorials. </font><font style="vertical-align: inherit;">The datasheet is written about the allocation of buffers in PMA and how it looks at the register level, but there is no information on how to use the corresponding functions from the HAL. </font><font style="vertical-align: inherit;">We fill this gap.</font></font><br><br>  So.      ‚Äî PMA (Packet Memory Area).        ,  USB    ( ).     , ..          .    BTABLE       .        PMA.         PMA,  HAL       . <br><br><img src="https://habrastorage.org/web/ec8/513/51e/ec851351e07a4d2c9a449bbcbb205192.png" alt="image"><br> <i>  Reference Manual   STM32F103</i> <br><br> ,     ?         .         4 16-  ( 2    2  ,       ).    4   ‚Äî , MSC    CDC (     ‚Äî    7 ‚Äî     ,    ,      ).     4  * 4  * 2  = 32 . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I said, HAL can only locate the PMA area at the beginning. So we can arrange the first buffer only at offset 0x20 (32 bytes is the size of the table). Endpoint buffers can be placed anywhere in PMA memory, as long as they do not fit each other. Each endpoint determines the maximum packet size that it is ready to process, the buffer must be equal to or larger than this size. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I allocated the buffer in 64-byte increments (the maximum buffer size recommended for USB Full Speed ‚Äã‚Äãdevices), but for some endpoints it could have been smaller. So, there is not a lot of data running on the control CDC endpoint (CDC_CMD_PACKET_SIZE is 8 bytes), so the buffer can be made only 8 bytes. However, I was not sorry, and 32 bytes - just to get round numbers.</font></font><br><br>    .      ,    2 .   .    .  Mass Storage   ,  CDC ‚Äî . <br><br><img src="https://habrastorage.org/web/183/37f/429/18337f4297bb48a0bfa9f8508a0cbabd.png" alt="image"><br><br>   ‚Äî      . -       .         (     usbser.sys) <br><br>          .     STMicroelectronics Virtual COM Port    ST.    C:\Program Files (x86)\STMicroelectronics\Software\Virtual comport driver,     stmcdc.inf ‚Äî      .          <br><br> <code>%DESCRIPTION%=DriverInstall,USB\VID_0483&amp;PID_5740</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here it connects our VID / PID with the device driver. Only this is not enough - you must also specify the interface number that manages the CDC. In my case, this is the first interface (zero is responsible for the MSC). For this line should look like </font></font><br><br> <code>%DESCRIPTION%=DriverInstall,USB\VID_0483&amp;PID_5741&amp;MI_01</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, the original string can not be changed, but simply </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add a line to the appropriate section. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After all the preparations, we find a non-working device in the list of devices, please update the driver, specify the directory where the inf file is located and voila - the driver is installed. Windows itself assigns the name COMxx to this device - you can take your favorite terminalka and open this COM port. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything is easier with Linux - everything starts there without dancing with </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambourine</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> drivers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPDATE from </font></font><a href="https://habr.com/users/fronders/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fronders</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: in Windows10 also everything starts up on its own. </font><font style="vertical-align: inherit;">Moreover, ST themselves do not recommend their vcp driver for 10s and suggest using the standard one.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On some forums, I saw messages like ‚Äúhow everything in this USB is difficult, some drivers ... I‚Äôm better on registers.‚Äù </font><font style="vertical-align: inherit;">Guys, not everything is so simple. </font><font style="vertical-align: inherit;">The register level is probably the easiest part. </font><font style="vertical-align: inherit;">But besides it there is a huge layer of logic that the device must implement. </font><font style="vertical-align: inherit;">And here already without knowledge of the protocols and many hundreds of pages of specifications in any way.</font></font><br><br>  But it is not all that bad.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">People have already taken care of and written all the logic. In most cases, it remains only to substitute the necessary values ‚Äã‚Äãand correct some parameters. Yes, the library from ST is one more monster. But after a thoughtful reading of USB In A Nutshell, a couple of specifications of a particular class of devices and work with a sniffer, many things fall into place. The library begins to look more or less slender. You can even make a custom class driver with relatively small efforts, which we did with success. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I did an implementation of a composite CDC + MSC device, but approximately the same approach can be applied to other combinations - CDC + HID, MSC + Audio, CDC + MSC + HID and others. My implementation is designed to work on microcontrollers of the STM32F103 series, but the principle itself can be adapted for other microcontrollers (including and not STM32).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article, I did not set myself the task of telling how USB works in all details - firstly, there are articles and books that tell it better (I touched only a small part), and secondly, it is better to draw a lot of things from the original sources (specifications) . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of retelling the specifications, I tried to describe how the ST stack's USB implementation works. I also tried to draw attention to special moments and to tell why it is done this way. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have long doubted whether to put a tick "Tutorial". On the one hand, I give recommendations and step-by-step instructions, draw attention to special moments and give references to the original sources. On the other hand, I cannot provide a ready-made library for downloading and embedding in my projects.</font></font><br><br>   ,           ,       .    ,      ,  ,   ,    .   USB     ,     ST.              . ,   <a href="https://github.com/grafalex82/GPSLogger/tree/master/Libs/USB">  </a> ‚Äî ,   ,  ,  . <br><br>      ,         . , ! </div><p>Source: <a href="https://habr.com/ru/post/335018/">https://habr.com/ru/post/335018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335006/index.html">[Archeology Live] Shameful talk about singletons</a></li>
<li><a href="../335008/index.html">We give the user of the application game currency using AdMob Rewarded Video</a></li>
<li><a href="../335010/index.html">[UPDATED + Comments] At first they steal, and when you win, they kill you</a></li>
<li><a href="../335012/index.html">SHA2017 CTF: Need More Traffic</a></li>
<li><a href="../335016/index.html">TSP problem. Mixed algorithm</a></li>
<li><a href="../335020/index.html">TDD React.js Applications</a></li>
<li><a href="../335022/index.html">MythBusters - Gentoo Linux</a></li>
<li><a href="../335026/index.html">Limitations of depth learning and the future</a></li>
<li><a href="../335028/index.html">Using Hotspot Helper Extension</a></li>
<li><a href="../335030/index.html">Setting up the main and two backup operators on a Linux-router with NetGWM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>