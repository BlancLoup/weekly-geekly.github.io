<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>5 + 1 case where the REST API specification plays a huge role</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article focuses on writing and maintaining a useful and relevant specification for the REST API project, which will save a lot of unnecessary cod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>5 + 1 case where the REST API specification plays a huge role</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/b1/dg/ob/b1dgobh5dxfw3q-firfz-77qu-0.png"></div><br><p>  This article focuses on writing and maintaining a useful and relevant specification for the REST API project, which will save a lot of unnecessary code, as well as seriously improve the integrity, reliability and transparency of the project as a whole. </p><br><h3 id="chto-takoe-restful-api">  What is the RESTful API? </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dde/ee8/857/ddeee88570832b82d7a7ff7231255c3f.png"></div><br><p>  It is a myth. </p><br><p>  Seriously, if you think that your project is a RESTful API, you are almost certainly mistaken.  The idea of ‚Äã‚ÄãRESTful is to build an API that would in all respects the architectural rules and restrictions described by the REST style, but in real conditions it turns out to be <em>almost impossible</em> . </p><a name="habracut"></a><br><p>  On the one hand, REST contains too many vague and ambiguous definitions.  For example, some terms from HTTP dictionaries of methods and status codes are used in practice for other than their intended purpose, and many of them are not used at all. </p><br><p>  On the other hand, REST creates too many restrictions.  For example, the atomic use of resources in the real world is not rational for APIs used by mobile applications.  A complete failure to store state between requests is essentially a ban on the mechanism of user sessions used in many APIs. </p><br><p>  <strong>But wait, not everything is so bad!</strong> </p><br><h3 id="zachem-nuzhna-specifikaciya-rest-api">  Why is the REST API specification necessary? </h3><br><p>  Despite these drawbacks, with a reasonable approach, REST still remains an excellent basis for designing really cool APIs.  Such an API should have internal consistency, clear structure, convenient documentation and good coverage with unit tests.  All this can be achieved by developing a high-quality <strong>specification</strong> for your API. </p><br><p>  Most often <em>the</em> REST API <em>specification is</em> associated with its <em>documentation</em> .  Unlike the first (which is the formal description of your API), the documentation is intended to be read by people: for example, developers of a mobile or web application using your API. </p><br><p>  However, besides the actual creation of the documentation, the correct description of the API can bring a lot more benefit.  In the article, I want to share examples of how using competent specification you can: </p><br><ul><li>  make unit testing more simple and reliable; </li><li>  set up preprocessing and validation of input data; </li><li>  automate serialization and ensure the integrity of responses; </li><li>  and even take advantage of static typing. </li></ul><br><h3 id="openapi">  Openapi </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/222/aae/af9/222aaeaf95adf9cb50af1ed7702d4c9b.png" width="500"></div><br><p>  The common format for describing the REST API today is <a href="https://openapis.org/"><strong>OpenAPI</strong></a> , which is also known as <em>Swagger</em> .  This specification is a single file in JSON or YAML format, consisting of three sections: </p><br><ul><li>  a header containing the name, description and version of the API, as well as additional information; </li><li>  a description of all resources, including their identifiers, HTTP methods, all input parameters, as well as codes and formats of the response body, with links to definitions; </li><li>  all object definitions in the <a href="https://json-schema.org/"><strong>JSON Schema</strong></a> format that can be used both in the input parameters and in the responses. </li></ul><br><p>  OpenAPI has a serious drawback - the <em>complexity of the structure and, often, redundancy</em> .  For a small project, the contents of a JSON file specification can quickly grow to several thousand lines.  In this form, it is impossible to maintain this file manually.  This is a serious threat to the very idea of ‚Äã‚Äãmaintaining the current specification as the API evolves. </p><br><p>  There are many visual editors that allow you to describe the API and form as a result the OpenAPI specification.  They, in turn, are based on additional services and cloud solutions, such as <em>Swagger</em> , <em>Apiary</em> , <em>Stoplight</em> , <em>Restlet</em> and others. </p><br><p>  However, for me, such services were not very convenient due to the complexity of quickly editing the specification and combining with the process of writing code.  Another disadvantage is the dependence on the feature set of each specific service.  For example, it is practically impossible to implement full-fledged unit-testing using only cloud service.  Code generation and even the creation of stubs for endpoints, although they seem to be very possible, are practically useless in practice. </p><br><h3 id="tinyspec">  Tinyspec </h3><br><p>  In this article I will use examples based on the <a href="https://www.npmjs.com/package/tinyspec"><strong>RYS</strong></a> API's own description format, <a href="https://www.npmjs.com/package/tinyspec"><strong>tinyspec</strong></a> .  The format is a small file that intuitively describes the endpoints and data models used in the project.  Files are stored next to the code, which allows you to check with them and edit them right in the process of writing it.  In this case, tinyspec is automatically compiled into a full OpenAPI, which can be immediately used in the project.  It's time to tell exactly how. </p><br><p>  In this article, I will provide examples from Node.js (koa, express) and Ruby on Rails, although these practices apply to most technologies, including Python, PHP, and Java. </p><br><h2 id="kogda-eschyo-specifikaciya-okazyvaetsya-neveroyatno-poleznoy">  When else is the specification incredibly useful? </h2><br><h3 id="1-unit-testy-endpointov">  1. Unit tests endpoint </h3><br><p>  <em>Behavior-driven development (BDD) is</em> ideal for developing a REST API.  The most convenient way is to write unit tests not for individual classes, models and controllers, but for specific endpoints.  In each test, you emulate a real HTTP request and check the server response.  In Node.js, there is a <a href="https://github.com/visionmedia/supertest">supertest</a> and <a href="http/">chai-http</a> for emulating test requests, and <a href="http/">airborne</a> in Ruby on Rails. </p><br><p> Suppose we have a <code>User</code> schema and a <code>GET /users</code> endpoint that returns all users.  Here is the tinyspec syntax that describes this: </p><br><ol><li>  <em>User.models.tinyspec</em> file: </li></ol><br><pre> <code class="python hljs">User {name, isAdmin: b, age?: i}</code> </pre> <br><ol><li>  File <em>users.endpoints.tinyspec</em> : </li></ol><br><pre> <code class="python hljs">GET /users =&gt; {users: User[]}</code> </pre> <br><p>  This is how our test will look like: </p><br><h4 id="nodejs">  Node.js </h4><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'List all users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { status, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { users } } = request.get(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>); expect(status).to.equal(<span class="hljs-number"><span class="hljs-number">200</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].name).to.be(<span class="hljs-string"><span class="hljs-string">'string'</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].isAdmin).to.be(<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].age).to.be.oneOf([<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>]); }); });</code> </pre> <br><h4 id="ruby-on-rails">  Ruby on rails </h4><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'GET /users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">'List all users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get <span class="hljs-string"><span class="hljs-string">'/users'</span></span> expect_status(<span class="hljs-number"><span class="hljs-number">200</span></span>) expect_json_types(<span class="hljs-string"><span class="hljs-string">'users.*'</span></span>, { <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:string</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">isAdmin:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:boolean</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">age:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:integer_or_null</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  When we have a specification that describes the response formats of the server, we can simplify the test and simply <em>check the answer for compliance with this specification</em> .  To do this, we use the fact that our tinyspec models are turned into OpenAPI definitions, which in turn correspond to the JSON Schema format. </p><br><p>  Any <em>literal object</em> in JS (or <code>Hash</code> in Ruby, <code>dict</code> in Python, <em>an associative array</em> in PHP, and even <code>Map</code> in Java) can be tested against the JSON schema.  And even there are corresponding plugins for testing frameworks, for example <a href="https://www.npmjs.com/package/jest-ajv">jest-ajv</a> (npm), <a href="https://www.npmjs.com/package/chai-ajv-json-schema">chai-ajv-json-schema</a> (npm) and <a href="https://rubygems.org/gems/json_matchers/">json_matchers</a> (rubygem) for RSpec. </p><br><p>  Before using schemes, you need to connect them to the project.  First, let's generate an openapi.json specification file based on tinyspec (this action can be automatically performed before each test run): </p><br><pre> <code class="bash hljs">tinyspec -j -o openapi.json</code> </pre> <br><h4 id="nodejs-1">  Node.js </h4><br><p>  Now we can use the resulting JSON in the project and take from it the key <code>definitions</code> , which contains all the JSON schemes.  Schemes may contain cross-references ( <code>$ref</code> ), therefore, if we have nested schemes (for example, <code>Blog {posts: Post[]}</code> ), then we need to ‚Äúdeploy‚Äù them in order to use them in validations.  For this we will use <a href="https://www.npmjs.com/package/json-schema-deref-sync">json-schema-deref-sync</a> (npm). </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deref <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'json-schema-deref-sync'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spec = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./openapi.json'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> schemas = deref(spec).definitions; describe(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'List all users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { status, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { users } } = request.get(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>); expect(status).to.equal(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Chai expect(users[0]).to.be.validWithSchema(schemas.User); // Jest expect(users[0]).toMatchSchema(schemas.User); }); });</span></span></code> </pre> <br><h4 id="ruby-on-rails-1">  Ruby on rails </h4><br><p>  <code>json_matchers</code> can handle <code>$ref</code> links, but requires separate files with schemas in the file system along a certain path, so you first have to "split" <code>swagger.json</code> into many small files (more on this <a href="https://github.com/thoughtbot/json_matchers/issues/80">here</a> ): </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># ./spec/support/json_schemas.rb require 'json' require 'json_matchers/rspec' JsonMatchers.schema_root = 'spec/schemas' # Fix for json_matchers single-file restriction file = File.read 'spec/schemas/openapi.json' swagger = JSON.parse(file, symbolize_names: true) swagger[:definitions].keys.each do |key| File.open("spec/schemas/#{key}.json", 'w') do |f| f.write(JSON.pretty_generate({ '$ref': "swagger.json#/definitions/#{key}" })) end end</span></span></code> </pre> <br><p>  After this, we can write our test like this: </p><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'GET /users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">'List all users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get <span class="hljs-string"><span class="hljs-string">'/users'</span></span> expect_status(<span class="hljs-number"><span class="hljs-number">200</span></span>) expect(result[<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]).to match_json_schema(<span class="hljs-string"><span class="hljs-string">'User'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Please note: writing tests in this way is incredibly convenient.  Especially if your IDE supports running tests and debugging (for example, WebStorm, RubyMine and Visual Studio).  Thus, you can not use any other software at all, and the whole API development cycle comes down to 3 successive steps: </p><br><ol><li>  specification design (for example, in tinyspec); </li><li>  writing a complete set of tests for added / modified endpoints; </li><li>  developing code that satisfies all tests. </li></ol><br><h3 id="2-validaciya-vhodnyh-dannyh">  2. Validation of input data </h3><br><p>  OpenAPI describes the format of not only responses, but also input data.  This allows us to <em>validate the data</em> that came from the user right at the time of the request. </p><br><p>  Suppose we have the following specification, which describes the update of user data, as well as all the fields that can be changed: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># user.models.tinyspec UserUpdate !{name?, age?: i} # users.endpoints.tinyspec PATCH /users/:id {user: UserUpdate} =&gt; {success: b}</span></span></code> </pre> <br><p>  Earlier we considered plug-ins for validation inside tests, however for more general cases there are validation modules <a href="https://www.npmjs.com/package/ajv">ajv</a> (npm) and <a href="https://rubygems.org/gems/json-schema/">json-schema</a> (rubygem), let's use them and write a controller with validation. </p><br><h4 id="nodejs-koa">  Node.js (Koa) </h4><br><p>  This is an example for <strong>Koa</strong> , the successor to Express, but for Express, the code will look similar. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'koa-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ajv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ajv'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schemas } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schemas'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); <span class="hljs-comment"><span class="hljs-comment">// Standard resource update action in Koa. router.patch('/:id', async (ctx) =&gt; { const updateData = ctx.body.user; // Validation using JSON schema from API specification. await validate(schemas.UserUpdate, updateData); const user = await User.findById(ctx.params.id); await user.update(updateData); ctx.body = { success: true }; }); async function validate(schema, data) { const ajv = new Ajv(); if (!ajv.validate(schema, data)) { const err = new Error(); err.errors = ajv.errors; throw err; } }</span></span></code> </pre> <br><p>  In this example, if the input data does not match the specification, the server will return <code>500 Internal Server Error</code> to the client.  To avoid this, we can intercept the validator error and form our own response, which will contain more detailed information about specific fields that have not passed the test, and also <em>comply with the specification</em> . </p><br><p>  Add a description of the <code>FieldsValidationError</code> model in the <code>FieldsValidationError</code> file: </p><br><pre> <code class="python hljs">Error {error: b, message} InvalidField {name, message} FieldsValidationError &lt; Error {fields: InvalidField[]}</code> </pre> <br><p>  And now we indicate it as one of the possible answers of our endpoint: </p><br><pre> <code class="python hljs">PATCH /users/:id {user: UserUpdate} =&gt; <span class="hljs-number"><span class="hljs-number">200</span></span> {success: b} =&gt; <span class="hljs-number"><span class="hljs-number">422</span></span> FieldsValidationError</code> </pre> <br><p>  This approach will allow you to write unit-tests that verify the correctness of the formation of an error when incorrect data came from the client. </p><br><h3 id="3-serializaciya-modeley">  3. Serialization of models </h3><br><p>  Almost all modern server frameworks somehow use <a href="https://en.wikipedia.org/wiki/Object-relational_mapping">ORM</a> .  This means that most of the resources used in the API within the system are represented as models, their instances and collections. </p><br><p>  The process of generating JSON representations of these entities for transmission in an API response is called <em>serialization</em> .  There are a number of plugins for different frameworks that perform the functions of a serializer, for example: <a href="https://www.npmjs.com/package/sequelize-to-json">sequelize-to-json</a> (npm), <a href="https://rubygems.org/gems/acts_as_api">acts_as_api</a> (rubygem), <a href="https://rubygems.org/gems/jsonapi-rails">jsonapi-rails</a> (rubygem).  In fact, these plugins allow for a specific model to specify a list of fields that need to be included in the JSON object, as well as additional rules, for example, to rename them or dynamically calculate values. </p><br><p>  Difficulties begin when we need to have several different JSON representations of the same model, or when an object contains nested entities ‚Äî associations.  There is a need to <em>inherit, reuse and bind serializers</em> . </p><br><p>  Different modules solve these problems in different ways, but let's think about whether the specification can help us again?  After all, in fact, all the information about the requirements for JSON representations, all possible combinations of fields, including nested entities, are already in it.  So we can write an automatic serializer. </p><br><p>  I bring to your attention a small module <a href="https://www.npmjs.com/package/sequelize-serialize">sequelize-serialize</a> (npm), which allows to do this for Sequelize models.  It takes as input a model instance or an array, as well as the required schema, and iteratively builds a serialized object, taking into account all the required fields and using nested schemas for the associated entities. </p><br><p>  So, suppose we have a need to return from the API all users who have blog posts, including comments on these posts.  We describe this with the following specification: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># models.tinyspec Comment {authorId: i, message} Post {topic, message, comments?: Comment[]} User {name, isAdmin: b, age?: i} UserWithPosts &lt; User {posts: Post[]} # blogUsers.endpoints.tinyspec GET /blog/users =&gt; {users: UserWithPosts[]}</span></span></code> </pre> <br><p>  Now we can build a query using Sequelize and return a serialized object that exactly matches the specification just described above: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'koa-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> serialize <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'sequelize-serialize'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schemas } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schemas'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); router.get(<span class="hljs-string"><span class="hljs-string">'/blog/users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ctx) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> User.findAll({ <span class="hljs-attr"><span class="hljs-attr">include</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">association</span></span>: User.posts, <span class="hljs-attr"><span class="hljs-attr">required</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">include</span></span>: [Post.comments] }] }); ctx.body = serialize(users, schemas.UserWithPosts); });</code> </pre> <br><p>  It's almost magic, right? </p><br><h3 id="4-staticheskaya-tipizaciya">  4. Static typing </h3><br><p>  If you are so cool that you are using TypeScript or Flow, you may have already wondered <em>"What about my dear static types ?!"</em>  .  Using the modules <a href="https://www.npmjs.com/package/sw2dts">sw2dts</a> or <a href="https://www.npmjs.com/package/swagger-to-flowtype">swagger-to-flowtype,</a> you can generate all the necessary definitions based on JSON schemes and use them for static typing of tests, input data and serializers. </p><br><pre> <code class="bash hljs">tinyspec -j sw2dts ./swagger.json -o Api.d.ts --namespace Api</code> </pre> <br><p>  Now we can use types in controllers: </p><br><pre> <code class="hljs pgsql">router.patch(<span class="hljs-string"><span class="hljs-string">'/users/:id'</span></span>, async (ctx) =&gt; { // Specify <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> request data <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> const userData: Api.UserUpdate = ctx.request.body.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>; // Run spec validation await <span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.UserUpdate, userData); // Query the <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = await <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.findById(ctx.params.id); await <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(userData); // <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span> serialized result const serialized: Api.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> = serialize(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>); ctx.body = { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: serialized }; });</code> </pre> <br><p>  And in the tests: </p><br><pre> <code class="hljs pgsql">it(<span class="hljs-string"><span class="hljs-string">'Update user'</span></span>, async () =&gt; { // Static <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> data. const updateData: Api.UserUpdate = { <span class="hljs-type"><span class="hljs-type">name</span></span>: MODIFIED }; const res = await request.patch(<span class="hljs-string"><span class="hljs-string">'/users/1'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: updateData }); // <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> helper <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> request response: const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: Api.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> = res.body.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>; expect(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.be.validWithSchema(<span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>); expect(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.containSubset(updateData); });</code> </pre> <br><p>  Please note that the generated type definitions can be used not only in the API project itself, but also in client application projects to describe the types of functions in which the work with the API takes place.  Developers of clients on Angular will be especially glad to such gift. </p><br><h3 id="5-privedenie-tipov-query-string">  5. Type casting query string </h3><br><p>  If for some reason your API accepts requests with the MIME type <code>application/x-www-form-urlencoded</code> , and not <code>application/json</code> , the request body will look like this: </p><br><pre> <code class="python hljs">param1=value&amp;param2=<span class="hljs-number"><span class="hljs-number">777</span></span>&amp;param3=false</code> </pre> <br><p>  The same applies to query parameters (for example, in GET requests).  In this case, the web server will not be able to automatically recognize the types - all data will be in the form of strings ( <a href="https://github.com/ljharb/qs/issues/91">here is a discussion</a> in the qs npm module repository), so after parsing you will receive the following object: </p><br><pre> <code class="python hljs">{ param1: <span class="hljs-string"><span class="hljs-string">'value'</span></span>, param2: <span class="hljs-string"><span class="hljs-string">'777'</span></span>, param3: <span class="hljs-string"><span class="hljs-string">'false'</span></span> }</code> </pre> <br><p>  In this case, the request will not be validated according to the scheme, which means it will be necessary to manually ensure that each parameter has the correct format and bring it to the required type. </p><br><p>  As you might guess, this can be done using all the same schemes from our specification.  Imagine that we have such an endpoint and scheme: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># posts.endpoints.tinyspec GET /posts?PostsQuery # post.models.tinyspec PostsQuery { search, limit: i, offset: i, filter: { isRead: b } }</span></span></code> </pre> <br><p>  Here is an example request for such an endpoint. </p><br><pre> <code class="python hljs">GET /posts?search=needle&amp;offset=<span class="hljs-number"><span class="hljs-number">10</span></span>&amp;limit=<span class="hljs-number"><span class="hljs-number">1</span></span>&amp;filter[isRead]=true</code> </pre> <br><p>  Let's write the <code>castQuery</code> function, which for us will lead all the parameters to the desired types.  It will look something like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">castQuery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">query, schema</span></span></span><span class="hljs-function">) </span></span>{ _.mapValues(query, (value, key) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { type } = schema.properties[key] || {}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value || !type) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'integer'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(value, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'number'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">parseFloat</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'boolean'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value !== <span class="hljs-string"><span class="hljs-string">'false'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } }); }</code> </pre> <br><p>  Its more complete implementation with support for nested schemes, arrays, and <code>null</code> types is available in <a href="https://www.npmjs.com/package/cast-with-schema">cast-with-schema</a> (npm).  Now we can use it in our code: </p><br><pre> <code class="javascript hljs">router.get(<span class="hljs-string"><span class="hljs-string">'/posts'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ctx) =&gt; { <span class="hljs-comment"><span class="hljs-comment">// Cast parameters to expected types const query = castQuery(ctx.query, schemas.PostsQuery); // Run spec validation await validate(schemas.PostsQuery, query); // Query the database const posts = await Post.search(query); // Return serialized result ctx.body = { posts: serialize(posts, schemas.Post) }; });</span></span></code> </pre> <br><p>  Notice how, of the four lines of endpoint code, three use schemas from the specification. </p><br><h2 id="luchshie-praktiki">  Best practics </h2><br><h3 id="otdelnye-shemy-dlya-sozdaniya-i-izmeneniya">  Separate schemes for creating and modifying </h3><br><p>  Typically, the schemes that describe the response of the server are different from those that describe the input data used to create and modify models.  For example, the list of available fields for <code>POST</code> and <code>PATCH</code> queries should be strictly limited, while in <code>PATCH</code> queries, usually all fields of the scheme are made optional.  Schemes that determine the answer may be more free. </p><br><p>  In the automatic <a href="https://github.com/Ajaxy/tinyspec">generation of tinyspec CRUDL</a> endpoints, the postfixes <code>New</code> and <code>Update</code> .  <code>User*</code> can be defined as follows: </p><br><pre> <code class="python hljs">User {id, email, name, isAdmin: b} UserNew !{email, name} UserUpdate !{email?, name?}</code> </pre> <br><p>  Try not to use the same schemes for different types of actions to avoid accidental security problems due to the reuse or inheritance of old schemes. </p><br><h3 id="semantika-v-nazvaniyah-shem">  Semantics in scheme names </h3><br><p>  The content of the same models may differ in different endpoints.  Use the <code>With*</code> and <code>For*</code> postfixes in schema names to show how they differ and what they are intended for.  The tinyspec models can also be inherited from each other.  For example: </p><br><pre> <code class="python hljs">User {name, surname} UserWithPhotos &lt; User {photos: Photo[]} UserForAdmin &lt; User {id, email, lastLoginAt: d}</code> </pre> <br><p>  Postfixes can be varied and combined.  The main thing is that their name reflects the essence and simplifies familiarity with the documentation. </p><br><h3 id="razdelenie-endpointov-po-tipu-klienta">  Endpoint separation by client type </h3><br><p>  Often the same endpoints return different data depending on the type of client or the role of the user accessing the endpoint.  For example, endpoints <code>GET /users</code> and <code>GET /messages</code> can be very different for users of your mobile application and for back office managers.  In this case, changing the very name of the endpoint may be too great a complication. </p><br><p>  To describe the same endpoint several times, you can add its type in brackets after the path.  In addition, it is useful to use tags: this will help to divide the documentation of your endpoints into groups, each of which will be intended for a specific group of clients of your API.  For example: </p><br><pre> <code class="python hljs">Mobile app: GET /users (mobile) =&gt; UserForMobile[] CRM admin panel: GET /users (admin) =&gt; UserForAdmin[]</code> </pre> <br><h2 id="dokumentaciya-rest-api">  REST API documentation </h2><br><p>  Once you have the tinyspec or OpenAPI specification, you can generate nice HTML documentation and publish it to the delight of developers using your API. </p><br><p>  In addition to the cloud services mentioned earlier, there are CLI-tools that convert OpenAPI 2.0 to HTML and PDF, after which you can upload it to any static hosting.  Examples: </p><br><ul><li>  <a href="https://www.npmjs.com/package/bootprint-openapi">bootprint-openapi</a> (npm, used by default in tinyspec) </li><li>  <a href="https://github.com/Swagger2Markup/swagger2markup-cli">swagger2markup-cli</a> (jar, there is <a href="https://github.com/Ajaxy/openapi-asciidoctor">an example of use</a> , will be used in the <a href="https://tinyspec.cloud/">tinyspec Cloud</a> ) </li><li>  <a href="https://www.npmjs.com/package/redoc-cli">redoc-cli</a> (npm) </li><li>  <a href="https://www.npmjs.com/package/widdershins">widdershins</a> (npm) </li></ul><br><p>  <em>Do you know more examples?</em>  <em>Share them in the comments.</em> </p><br><p>  Unfortunately, OpenAPI 3.0 released a year ago is still poorly supported and I could not find decent examples of documentation based on it: neither among cloud solutions nor among CLI tools.  For the same reason, OpenAPI 3.0 is not yet supported in tinyspec. </p><br><h3 id="publikaciya-v-github">  Posting to GitHub </h3><br><p>  One of the easiest ways to publish documentation is <a href="https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/">GitHub Pages</a> .  Simply enable static page support for the <code>/docs</code> directory in your repository settings and store the HTML documentation in this folder. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/09b/5ad/775/09b5ad7757239f4405cb370cb59c6a7b.png"></p><br><p>  You can add a command to generate documentation via tinyspec or another CLI tool in <code>scripts</code> in <code>package.json</code> and update the documentation with each commit: </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"docs"</span></span>: <span class="hljs-string"><span class="hljs-string">"tinyspec -h -o docs/"</span></span>, <span class="hljs-string"><span class="hljs-string">"precommit"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run docs"</span></span> }</code> </pre> <br><h3 id="continuous-integration">  Continuous integration </h3><br><p>  You can enable documentation generation in the CI cycle and publish it, for example, in Amazon S3 under different addresses depending on the environment or version of your API, for example: <code>/docs/2.0</code> , <code>/docs/stable</code> , <code>/docs/staging</code> . </p><br><h3 id="tinyspec-cloud">  Tinyspec cloud </h3><br><p>  If you like the tinyspec syntax, you can register as an early adopter on <a href="https://tinyspec.cloud/">tinyspec.cloud</a> .  We are going to build on its basis a cloud service and a CLI for the automatic publication of documentation with a wide choice of templates and the ability to develop our own templates. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Development of the REST API is perhaps the most enjoyable thing that exists in the process of working on modern web and mobile services.  There is no browser zoo, operating systems and screen sizes, everything is completely under our control - "at your fingertips." </p><br><p>  Maintaining the current specifications and bonuses in the form of various automations, which are provided at the same time, make this process even more pleasant.  Such an API becomes structured, transparent and reliable. </p><br><p>  <em>After all, in fact, if we are doing what we create a myth, then why don't we make it beautiful?</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/427601/">https://habr.com/ru/post/427601/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427587/index.html">Java concentrated on one and a half thousand people. How was Joker 2018</a></li>
<li><a href="../427589/index.html">Asynchronous WEB in 2018. We write chat on Websocket using Swoole</a></li>
<li><a href="../427591/index.html">Architecture as a burden</a></li>
<li><a href="../427593/index.html">The magic of fast teams in Vivaldi 2.1</a></li>
<li><a href="../427595/index.html">Try Micronaut or Honey, I have reduced the framework</a></li>
<li><a href="../427603/index.html">How to finally start writing tests and not regret it</a></li>
<li><a href="../427605/index.html">How the crowdsourcing platform of Yandex helps train drones and evaluate the quality of services</a></li>
<li><a href="../427607/index.html">Data Center in Switzerland: to work like a clock</a></li>
<li><a href="../427609/index.html">Solving an equation with integer division without enumeration</a></li>
<li><a href="../427611/index.html">A tale about how I updated Yandex MapKit on iOS or maps, money, 2 mapkits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>