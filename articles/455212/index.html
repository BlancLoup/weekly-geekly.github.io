<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Linux network application performance. Introduction</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Web applications are now used everywhere, and among all transport protocols the lion's share is taken by HTTP. Studying the nuances of developing web ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Linux network application performance. Introduction</h1><div class="post__text post__text-html js-mediator-article">  Web applications are now used everywhere, and among all transport protocols the lion's share is taken by HTTP.  Studying the nuances of developing web applications, the majority devotes very little attention to the operating system, where these applications actually run.  Separation of development (Dev) and operation (Ops) only worsened the situation.  But with the spread of DevOps culture, developers are beginning to take responsibility for running their applications in the cloud, so it‚Äôs very useful for them to thoroughly get acquainted with the operating system backend.  This is especially useful if you are trying to deploy a system for thousands or tens of thousands of simultaneous connections. <br><br>  The limitations in web services are very similar to those in other applications.  Whether they are load balancers or database servers, all of these applications have similar problems in a high-performance environment.  Understanding these fundamental limitations and ways to overcome them in general will allow you to evaluate the performance and scalability of your web applications. <br><br>  I am writing this series of articles in response to questions from young developers who want to become well-informed system architects.  It is impossible to clearly understand the methods of optimizing Linux applications, not immersed in the basics, how they work at the operating system level.  Although there are many types of applications, in this cycle I want to explore network applications, rather than desktop ones, such as a browser or text editor.  This material is intended for developers and architects who want to understand how Linux or Unix programs work and how to structure them for high performance. <br><a name="habracut"></a><br>  Linux is a <i>server</i> operating system, and most often your applications run on this OS.  Although I say ‚ÄúLinux‚Äù, most of the time you can safely assume that all Unix-like operating systems are meant as a whole.  However, I have not tested the accompanying code on other systems.  So, if you are interested in FreeBSD or OpenBSD, the result may differ.  When I try something Linux-specific, I point it out. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Although you can use this knowledge to create an application from scratch, and it will be perfectly optimized, but it is better not to do so.  If you write a new C or C ++ web server for your organization‚Äôs business application, it may be your last day at work.  However, knowledge of the structure of these applications will help in the selection of existing programs.  You will be able to compare systems based on processes with systems based on threads as well as based on events.  You will understand and appreciate why Nginx works better than Apache httpd, why a Tornado-based Python application can serve more users than a Django-based Python application. <br><br><h1>  ZeroHTTPd: a learning tool </h1><br>  <a href="httpd">ZeroHTTPd</a> is a web server that I wrote from scratch in C as an educational tool.  He has no external dependencies, including access to Redis.  We run our own Redis routines.  See below for details. <br><br>  Although we could discuss the theory for a long time, there is nothing better than writing code, running it and comparing all the server architectures with each other.  This is the most visual method.  Therefore, we will write a simple ZeroHTTPd web server, applying each model: based on processes, threads and events.  Let's check each of these servers and see how they work compared to each other.  ZeroHTTPd is implemented in a single C file. The event-based server includes <a href="https://troydhanson.github.io/uthash/">uthash</a> , an excellent implementation of a hash table that is supplied in a single header file.  In other cases, there are no dependencies, so as not to complicate the project. <br><br>  The code has a lot of comments to help you figure it out.  Being a simple web server in a few lines of code, ZeroHTTPd is also a minimal framework for web development.  It has limited functionality, but it is capable of generating static files and very simple ‚Äúdynamic‚Äù pages.  I must say that ZeroHTTPd is well suited for learning how to create high-performance Linux applications.  By and large, most web services are waiting for requests, check them and process them.  This is exactly what ZeroHTTPd will do.  This is a tool for learning, not for production.  He is not good at handling errors and hardly boasts the best security practices (oh yeah, I used <code>strcpy</code> ) or abstruse stunts of the C language. But I hope he will cope well with his task. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd0/fd7/c03/cd0fd7c03567dcb48c1e615a63a19c48.png"><br>  <i><font color="gray">The main page ZeroHTTPd.</font></i>  <i><font color="gray">It can produce different types of files, including images.</font></i> <br><br><h1>  Guestbook application </h1><br>  Modern web applications are usually not limited to static files.  They have complex interactions with various databases, caches, etc. Therefore, we will create a simple web application called Guestbook, where visitors leave entries under their own names.  In the guest book saved entries left earlier.  There is also a visitor counter at the bottom of the page. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/997/b6b/39e/997b6b39e116c216a13422e1a3fcd7b6.png"><br>  <i><font color="gray">Guest book web application ZeroHTTPd</font></i> <br><br>  Visitor counters and guestbook entries are stored in Redis.  Own procedures are implemented for communications with Redis, they do not depend on an external library.  I'm not a big fan of rolling out homebrew code when there are generally available and well-tested solutions.  But the goal of ZeroHTTPd is to study Linux performance and access to external services, while serving HTTP requests has a serious impact on performance.  We must fully control the communication with Redis in each of our server architectures.  In one architecture, we use blocking calls, in others, event-based procedures.  Using the Redis external client library will not give such control.  In addition, our little Redis client performs only a few functions (getting, setting and increasing the key; getting and adding to the array).  In addition, the Redis protocol is extremely elegant and simple.  He doesn‚Äôt even need to teach him.  The fact that the protocol does all the work in about a hundred lines of code indicates how well-thought it is. <br><br>  The following figure shows the actions of the application when the client (browser) requests <code>/guestbookURL</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9f4/6cc/bb0/9f46ccbb030a53a1822678afac4e518f.png"><br>  <i><font color="gray">The mechanism of the guestbook application</font></i> <br><br>  When you need to issue a guestbook page, there is one call to the file system to read the template into memory and three network calls to Redis.  The template file contains most of the HTML content for the page in the screenshot above.  There are also special placeholders for the dynamic part of the content: records and visitor counters.  We get them from Redis, paste them into the page and give the client the fully formed content.  The third Redis call can be avoided because Redis returns the new key value when incremented.  However, for our server with an asynchronous, event-based architecture, numerous network calls are a good test for training purposes.  Thus, we discard the return value of Redis about the number of visitors and request it with a separate call. <br><br><h1>  ZeroHTTPd Server Architectures </h1><br>  We build seven versions of ZeroHTTPd with the same functionality, but different architectures: <br><br><ul><li>  Iterative <br></li><li>  Fork server (one child process per request) <br></li><li>  Pre-fork server (pre-forking processes) <br></li><li>  Server with threads of execution (one thread per request) <br></li><li>  Server with pre-threading <br></li><li>  <code>poll()</code> based architecture <br></li><li>  Epoll-based architecture </li></ul><br>  We measure the performance of each architecture by loading the server with HTTP requests.  But when comparing architectures with a high degree of parallelism, the number of queries increases.  We test three times and consider the average. <br><br><h1>  Testing Methodology </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/d37/97d/a33/d3797da3301e7b3d8b9e93fbfb3aeafa.png"><br>  <i><font color="gray">Installation for load testing ZeroHTTPd</font></i> <br><br>  It is important that when performing tests all components do not work on the same machine.  In this case, the OS incurs additional planning overhead, as the components compete for the CPU.  Measuring the operating system overhead for each of the selected server architectures is one of the most important goals of this exercise.  Adding more variables will be detrimental to the process.  Therefore, the setting in the figure above works best. <br><br><h3>  What each of these servers does </h3><br><ul><li>  load.unixism.net: here we run <code>ab</code> , the Apache Benchmark utility.  It generates the workload required to test our server architectures. <br></li><li>  nginx.unixism.net: sometimes we want to run more than one instance of the server program.  To do this, the Nginx server with the appropriate settings works as a load balancer from <i>ab</i> to our server processes. <br></li><li>  zerohttpd.unixism.net: here we run our server programs on seven different architectures, one at a time. <br></li><li>  redis.unixism.net: the Redis daemon is running on this server, where guestbook entries and the visitors counter are stored. </li></ul><br>  All servers run on the same processor core.  The idea is to evaluate the maximum performance of each of the architectures.  Since all server programs are tested on the same hardware, this is the basic level for comparing them.  My test setup consists of virtual servers rented from Digital Ocean. <br><br><h3>  What do we measure? </h3><br>  You can measure different indicators.  We estimate the performance of each architecture in this configuration by loading servers with requests at different levels of parallelism: the load grows from 20 to 15,000 simultaneous users. <br><br><h1>  Test results </h1><br>  The following diagram shows the performance of servers on different architectures with different levels of parallelism.  On the y axis - the number of requests per second, on the x axis - parallel connections. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f5/01a/a17/4f501aa1794e1d9eddc4f57fad5e96d3.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff7/9bc/306/ff79bc306edde1b6f1bc39b4d2aeaa38.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b30/b9b/322/b30b9b322ec0d8fa20bfc5e7010a7a5d.png"><br><br>  Below is a table with the results. <br><br><div class="scrollable-table"><table><tbody><tr><td></td><td colspan="7">  requests per second </td></tr><tr><td>  <strong>parallelism</strong> </td><td>  <strong>iterative</strong> </td><td>  <strong>fork</strong> </td><td>  <strong>pre-fork</strong> </td><td>  <strong>streaming</strong> </td><td>  <strong>pre-streaming</strong> </td><td>  <strong>poll</strong> </td><td>  <strong>epoll</strong> </td></tr><tr><td>  20 </td><td>  7 </td><td>  112 </td><td>  2100 </td><td>  1800 </td><td>  2250 </td><td>  1900 </td><td>  2050 </td></tr><tr><td>  50 </td><td>  7 </td><td>  190 </td><td>  2200 </td><td>  1700 </td><td>  2200 </td><td>  2000 </td><td>  2000 </td></tr><tr><td>  100 </td><td>  7 </td><td>  245 </td><td>  2200 </td><td>  1700 </td><td>  2200 </td><td>  2150 </td><td>  2100 </td></tr><tr><td>  200 </td><td>  7 </td><td>  330 </td><td>  2300 </td><td>  1750 </td><td>  2300 </td><td>  2200 </td><td>  2100 </td></tr><tr><td>  300 </td><td>  - </td><td>  380 </td><td>  2200 </td><td>  1800 </td><td>  2400 </td><td>  2250 </td><td>  2150 </td></tr><tr><td>  400 </td><td>  - </td><td>  410 </td><td>  2200 </td><td>  1750 </td><td>  2600 </td><td>  2000 </td><td>  2000 </td></tr><tr><td>  500 </td><td>  - </td><td>  440 </td><td>  2300 </td><td>  1850 </td><td>  2700 </td><td>  1900 </td><td>  2212 </td></tr><tr><td>  600 </td><td>  - </td><td>  460 </td><td>  2400 </td><td>  1800 </td><td>  2500 </td><td>  1700 </td><td>  2519 </td></tr><tr><td>  700 </td><td>  - </td><td>  460 </td><td>  2400 </td><td>  1600 </td><td>  2490 </td><td>  1550 </td><td>  2607 </td></tr><tr><td>  800 </td><td>  - </td><td>  460 </td><td>  2400 </td><td>  1600 </td><td>  2540 </td><td>  1400 </td><td>  2553 </td></tr><tr><td>  900 </td><td>  - </td><td>  460 </td><td>  2300 </td><td>  1600 </td><td>  2472 </td><td>  1200 </td><td>  2567 </td></tr><tr><td>  1000 </td><td>  - </td><td>  475 </td><td>  2300 </td><td>  1700 </td><td>  2485 </td><td>  1150 </td><td>  2439 </td></tr><tr><td>  1500 </td><td>  - </td><td>  490 </td><td>  2400 </td><td>  1550 </td><td>  2620 </td><td>  900 </td><td>  2479 </td></tr><tr><td>  2000 </td><td>  - </td><td>  350 </td><td>  2400 </td><td>  1400 </td><td>  2396 </td><td>  550 </td><td>  2200 </td></tr><tr><td>  2500 </td><td>  - </td><td>  280 </td><td>  2100 </td><td>  1300 </td><td>  2453 </td><td>  490 </td><td>  2262 </td></tr><tr><td>  3000 </td><td>  - </td><td>  280 </td><td>  1900 </td><td>  1250 </td><td>  2502 </td><td>  large scatter </td><td>  2138 </td></tr><tr><td>  5000 </td><td>  - </td><td>  large scatter </td><td>  1600 </td><td>  1100 </td><td>  2519 </td><td>  - </td><td>  2235 </td></tr><tr><td>  8,000 </td><td>  - </td><td>  - </td><td>  1200 </td><td>  large scatter </td><td>  2451 </td><td>  - </td><td>  2100 </td></tr><tr><td>  10,000 </td><td>  - </td><td>  - </td><td>  large scatter </td><td>  - </td><td>  2200 </td><td>  - </td><td>  2200 </td></tr><tr><td>  11,000 </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  2200 </td><td>  - </td><td>  2122 </td></tr><tr><td>  12,000 </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  970 </td><td>  - </td><td>  1958 </td></tr><tr><td>  13,000 </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  730 </td><td>  - </td><td>  1897 </td></tr><tr><td>  14,000 </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  590 </td><td>  - </td><td>  1466 </td></tr><tr><td>  15,000 </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  532 </td><td>  - </td><td>  1281 </td></tr></tbody></table></div><br>  From the graph and the table it is clear that above 8000 simultaneous requests, we have only two players left: pre-fork and epoll.  As the load grows, a server based on poll works worse than a streaming one.  The pre-threading architecture makes epoll worthy of competition: this is evidence of how well the Linux kernel plans a large number of threads. <br><br><h1>  ZeroHTTPd source code </h1><br>  ZeroHTTPd source code <a href="httpd">here</a> .  For each architecture, a separate directory. <br><br><pre>  ZeroHTTPd
 ‚îÇ
 01‚îÄ‚îÄ 01_iterative
 ‚îÇ ‚îú‚îÄ‚îÄ main.c
 02‚îÄ‚îÄ 02_forking
 ‚îÇ ‚îú‚îÄ‚îÄ main.c
 03‚îÄ‚îÄ 03_preforking
 ‚îÇ ‚îú‚îÄ‚îÄ main.c
 04‚îÄ‚îÄ 04_threading
 ‚îÇ ‚îú‚îÄ‚îÄ main.c
 05‚îÄ‚îÄ 05_prethreading
 ‚îÇ ‚îú‚îÄ‚îÄ main.c
 06‚îÄ‚îÄ 06_poll
 ‚îÇ ‚îú‚îÄ‚îÄ main.c
 07‚îÄ‚îÄ 07_epoll
 ‚îÇ ‚îî‚îÄ‚îÄ main.c
 Make‚îÄ‚îÄ Makefile
 Public‚îÄ‚îÄpublic
 ‚îÇ ‚îú‚îÄ‚îÄ index.html
 ‚îÇ ‚îî‚îÄ‚îÄ tux.png
 Templates‚îÄ‚îÄ templates
     Guest‚îÄ‚îÄ guestbook
         Index‚îÄ‚îÄ index.html </pre><br>  In addition to the seven directories for all architectures, there are two more in the top-level directory: public and templates.  The first one contains the index.html file and the image from the first screenshot.  You can put other files and folders there, and ZeroHTTPd should easily issue these static files.  If the path in the browser corresponds to the path in the public folder, then ZeroHTTPd searches the index.html file in this directory.  Content for the guest book is generated dynamically.  It has only the main page, and its content is based on the 'templates / guestbook / index.html' file.  Dynamic pages for extensions are easily added to ZeroHTTPd.  The idea is that users can add templates to this directory and extend ZeroHTTPd as needed. <br><br>  To build all seven servers, run <code>make all</code> from the top-level directory - and all builds will appear in this directory.  Executable files look for public and templates directories in the directory from which they are launched. <br><br><h1>  Linux API </h1><br>  To understand the information in this series of articles, it is not necessary to understand the Linux API well.  However, I recommend reading more on this topic, there are many reference resources on the Web.  Although we will cover several categories of the Linux API, our focus will be mainly on processes, threads, events, and the network stack.  In addition to books and articles about the Linux API, I also recommend reading mana for system calls and library functions used. <br><br><h1>  Performance and Scalability </h1><br>  One note about performance and scalability.  Theoretically, there is no connection between them.  You may have a web service that works very well, with a response time of a few milliseconds, but it does not scale at all.  Similarly, there may be a poorly functioning web application that takes a few seconds to respond, but it scales to tens to handle tens of thousands of simultaneous users.  However, the combination of high performance and scalability is a very powerful combination.  High-performance applications generally save resources and, therefore, effectively serve more concurrent users on the server, reducing costs. <br><br><h1>  CPU and I / O tasks </h1><br>  Finally, in calculations there are always two possible types of tasks: for I / O and CPU.  Getting requests via the Internet (network I / O), file serving (network and disk I / O), communication with the database (network and disk I / O) are all I / O actions.  Some queries to the database may slightly load the CPU (sorting, calculating the average value of a million results, etc.).  Most web applications are limited to the maximum possible I / O, and the processor is rarely used at full capacity.  When you see that a lot of CPUs are used in some I / O task, this is most likely a sign of a poor application architecture.  This may mean that CPU resources are spent on managing processes and context switching - and this is not entirely useful.  If you do something like image processing, audio file conversion or machine learning, then the application requires powerful CPU resources.  But for most applications this is not the case. <br><br><h1>  Learn more about server architectures. </h1><br><ol><li>  <a href="http://unixism.net/2019/04/28/linux-applications-performance-part-i-iterative-servers/">Part I. Iterative Architecture</a> </li><li>  <a href="http://unixism.net/2019/04/28/linux-applications-performance-part-ii-forking-servers/">Part II.</a>  <a href="http://unixism.net/2019/04/28/linux-applications-performance-part-ii-forking-servers/">Fork servers</a> </li><li>  <a href="http://unixism.net/2019/04/28/linux-applications-performance-part-iii-preforked-servers/">Part III.</a>  <a href="http://unixism.net/2019/04/28/linux-applications-performance-part-iii-preforked-servers/">Pre-fork servers</a> </li><li>  <a href="http://unixism.net/2019/04/28/linux-applications-performance-part-iv-threaded-servers/">Part IV.</a>  <a href="http://unixism.net/2019/04/28/linux-applications-performance-part-iv-threaded-servers/">Run Threads Servers</a> </li><li>  <a href="http://unixism.net/2019/04/28/linux-applications-performance-part-v-pre-threaded-servers/">Part V. Servers with preliminary thread creation</a> </li><li>  <a href="http://unixism.net/2019/04/28/linux-applications-performance-part-vi-polling-servers/">Part VI.</a>  <a href="http://unixism.net/2019/04/28/linux-applications-performance-part-vi-polling-servers/">Poll based architecture</a> </li><li>  <a href="http://unixism.net/2019/04/28/linux-applications-performance-part-vii-epoll-servers/">Part VII.</a>  <a href="http://unixism.net/2019/04/28/linux-applications-performance-part-vii-epoll-servers/">Epoll-based architecture</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/455212/">https://habr.com/ru/post/455212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455202/index.html">Big data in hotel management: use cannot be ignored</a></li>
<li><a href="../455204/index.html">The hatch of the Soyuz MS-14 spaceship turned out to be narrow for the FEDOR robot</a></li>
<li><a href="../455206/index.html">5 test questions for a quick job search in Germany</a></li>
<li><a href="../45521/index.html">Blizzard gives out StarCraft for free</a></li>
<li><a href="../455210/index.html">Carding and ‚Äúblack boxes‚Äù: how to hack ATM today</a></li>
<li><a href="../455214/index.html">Stanford, it seems we have a problem ...</a></li>
<li><a href="../455216/index.html">Doppler speed meter</a></li>
<li><a href="../455218/index.html">Ecosystem Approach to Business Technologies</a></li>
<li><a href="../455224/index.html">Finger Music: Play Anything With Sphero SpecDrums</a></li>
<li><a href="../455226/index.html">Why attach an applied linguist?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>