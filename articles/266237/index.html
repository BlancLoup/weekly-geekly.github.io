<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Guide to the implementation of 2D platformer (the end)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The end of the translation of the article "guide to the implementation of 2D platformers." 
 Start 

 Type 3: Bitmasks 
 It is similar to the tile (sm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Guide to the implementation of 2D platformer (the end)</h1><div class="post__text post__text-html js-mediator-article">  The end of the translation of the article "guide to the implementation of 2D platformers." <br>  <a href="http://habrahabr.ru/post/265911/">Start</a> <br><br><h2>  Type 3: Bitmasks </h2><br>  It is similar to the tile (smooth) method, but instead of using large tiles, a picture is used to check collisions for each pixel.  This allows you to work out the game better, but it also significantly increases the complexity, uses more memory and requires something similar to the graphic editor to create levels.  Such a mask is usually not used directly for visualization, so additional tools are needed - for example, a large graphic image (substrate), individually for each level.  Due to these problems, this technique is quite rare to use, but it allows for better results than tile-based options.  This method is convenient for creating a dynamic environment - the destruction can simply be ‚Äúdrawn‚Äù into a bit mask for changing the level.  A good example is the Worms series. <br><img src="https://habrastorage.org/files/c8d/ecf/509/c8decf5098ca41d0ab29bd3c988bc948.png"><br>  <i>Worms World Party with destructible topography</i> <br>  Examples: Worms, Talbot's Odyssey <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>How it works</b> <br>  The main idea is very close to the tile (smooth) algorithm - we just decide that each pixel is a tile, and we implement the exact same algorithm.  Everything will work with one small exception - biases.  Since the slopes are now completely determined by the relative position of the two nearest tiles, the previous technique will not work and will have to use a much more complex algorithm instead.  Other elements, like stairs, are also becoming smarter. <br><br><h2>  Slopes </h2><br><img src="https://habrastorage.org/files/da3/1e9/9fc/da31e99fc6d94cc893919959b9947ae9.png"><br>  <i>Talbot's Odyssey, with a collision mask overlaid on top of the game.</i> <br><br>  Biases are the main reason why this implementation is extremely difficult to do right.  Unfortunately, they are usually mandatory, since there is no point in using this implementation without biases.  Smooth change of level geometry is the main reason why you are forced to use this system. <br>  Here is a rough algorithm used in Talbot's Odyssey: <br><ul><li>  Combining the acceleration and the direction of motion to calculate the vector of the position change (how far to move along each axis) </li><li>  We process each axis separately, starting with the one with the larger difference. </li><li>  For horizontal movement, move the player's AABB rectangle 3 pixels up, so that he can climb slopes. </li><li>  Scan further, checking all obstacles and the bit mask itself to determine how many pixels you can move before colliding with an obstacle.  We dig to a new position. </li><li>  If it was a horizontal movement, we move up as many pixels as necessary (generally it should be no more than three) to climb the slope. </li><li>  If at the end of the movement any pixel of the character intersects with any obstacle, remove the movement along this axis. </li><li>  According to the result of the last condition, we do the same for the other axis. </li></ul><br><br>  Since this system has no differences in movement - the character moves down or falls, you will most likely have to count the number of frames that the character does not touch the floor to determine whether he can jump and change the animation.  In Talbot, this value is 10 frames. <br>  Another trick here is an effective calculation of how many pixels you can move before colliding with something.  There are other possible complicating factors, such as one-sided platforms (working in exactly the same way as in the tile approach) and steep inclines along which the player slides down, but cannot climb them (which are rather complicated and beyond the scope of this article) .  In general, this technique requires a large amount of fine adjustment of values ‚Äã‚Äãand is actually less stable than tile approaches with a grid.  I would recommend it only if you need to have very detailed terrain. <br><br><h2>  Type 4: Vector </h2><br><br>  This technique uses vector data (lines or polygons) to define the edges of the collision zone.  Despite the very great complexity in the correct development, it is becoming more common due to the abundance of physics engines, such as Box2D, which are suitable for the implementation of this technique.  It gives all the charm of the technique of bitmasks, but without a huge memory overload and uses a completely different level editing method. <br><br><img src="https://habrastorage.org/files/0db/b72/b7f/0dbb72b7fe9348a99f976c24ade15b73.jpg"><br><img src="https://habrastorage.org/files/ef7/224/005/ef722400575f4269b3c57e6587a46f09.png"><br>  <i>Braid (level editor), with visible layers (top) and collision polygons (bottom)</i> <br>  Examples: Braid, Limbo <br><br>  <b>How it works</b> <br>  Here are two basic approaches to implementation: <br><ul><li>  To process motion and collisions independently, similar to bitmasks, but using polygons for rendering object intersections and motion. </li><li>  Use a physics engine (for example Box2D) </li></ul><br>  Obviously, the second option is much more popular (although I suspect that the creator of Braid went the first way) - it is much easier and allows you to do many other interesting things with physics in the game.  But in my opinion, you need to be very careful, going this way, because you can make the game too ordinary, uninteresting physical-platformer (meaning the similarity of games on the behavior on this engine. Comment. Per.). <br><br><h2>  Complex objects </h2><br><br>  This approach also has its own unique problems.  For example, it can sometimes be difficult to say whether a player is standing on the floor (due to rounding errors), has rested against a wall or slides down a slope.  When using the physics engine, friction can be a big problem, because you want the friction to be large on the floor, but small on the sides of the tile. <br>  They solve this in different ways, but the most popular solution is to divide the character into several different polygons, each with a different role: this is how the main body (optional) is obtained, then a thin rectangle for the legs and two thin rectangles for the sides, as well as another for the head.  Sometimes they are narrowed so as not to get stuck in obstacles.  They can be with different physics settings, and the response (callbacks) to the collision can serve to determine the state of the character.  For more information, use sensors (non-colliding objects that use to check the intersection).  Basic cases include determining whether a character is close enough to the floor to make a jump, or does he push a wall, etc. <br><br><h2>  Key Considerations </h2><br><br>  Depending on the type of movement that you have chosen (except, perhaps, type number 1), there are several considerations. <br><br><h2>  Acceleration </h2><br><img src="https://habrastorage.org/files/b06/a8c/e76/b06a8ce76a394ddbbca2a19aa50fcc1f.png"><br>  <i>Super Mario World (low acceleration), Super Metroid (medium acceleration), Mega Man 7 (high acceleration)</i> <br><br>  One of the factors that affects the feel of the platformer is the acceleration of the character.  Acceleration is a measure of speed change.  When it is low, the character takes a long time to reach maximum speed, or stop if the player releases the controller.  If implemented incorrectly, this causes the feeling that the character is ‚Äúslippery‚Äù and does not give good control.  Such a movement is often associated with the games of the Super Mario series.  When the acceleration is high, the character needs very little (or no need at all) time to accelerate from zero to maximum speed, or vice versa, which causes a very fast response, ‚Äújerky‚Äù control, as can be seen in the Mega Man series (I believe Mega Man actually uses infinite acceleration, as it even stops at full speed). <br>  Even if the game has no concept of acceleration in the horizontal plane, it most likely uses it to jump in an arc.  Otherwise the jump shape would be triangular. <br><br>  <b>How it works</b> <br>  Implementing acceleration is actually very simple, but there are a few pitfalls. <br><ul><li>  Determine xTargetSpeed.  It must be 0 if the player does not touch the control, -maxSpeed ‚Äã‚Äãif he presses to the left or + maxSpeed ‚Äã‚Äãif he presses to the right. </li><li>  Define yTargetSpeed.  It must be 0 if the player is on the platform or + terminalSpeed ‚Äã‚Äãotherwise. </li><li>  For each axis, increase the current speed in the direction of the target speed using weighted average or incremental acceleration. </li></ul><br>  Two methods of acceleration: <br><ul><li>  Weighted average: acceleration is a number (‚Äúa‚Äù) from 0 (no change) to 1 (instantaneous acceleration).  Use this value to linearly interpolate between the target and the current speed and set the result as the current speed. <br><pre><code class="hljs cpp">vector2f curSpeed = a * targetSpeed + (<span class="hljs-number"><span class="hljs-number">1</span></span>-a) * curSpeed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(curSpeed.x) &lt; threshold) curSpeed.x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(curSpeed.y) &lt; threshold) curSpeed.y = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> </li><li>  Incremental acceleration: we determine the direction for adding acceleration (using a function that returns 1 for numbers greater than 0 and -1 for numbers less than zero), then we check to see if it‚Äôs missing. <br><pre> <code class="hljs pgsql">vector2f direction = vector2f(sign(targetSpeed.x - curSpeed.x), sign(targetSpeed.y - curSpeed.y)); curSpeed += acceleration * direction; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sign(targetSpeed.x - curSpeed.x) != direction.x) curSpeed.x = targetSpeed.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sign(targetSpeed.y - curSpeed.y) != direction.y) curSpeed.y = targetSpeed.y;</code> </pre></li></ul><br><br>  It is important to add acceleration to the speed before moving the character, otherwise you will create a delay of one frame in the control (lag). <br><br>  When a character crashes into an obstacle, it‚Äôs a good idea to zero its speed along this axis, but this may not be enough.  The speed may be greater than the distance to the object.  In some implementations, as a result of a collision at high speed, a character can penetrate an obstacle.  In this case, you need to find the correction value (the depth of the intersection) and move the character back to this value, or find a different speed one frame before the intersection.  (approx. lane) <br><br><h2>  Jump Control </h2><br><img src="https://habrastorage.org/files/7ec/6b0/cd2/7ec6b0cd26dd46bfaaaecfbc6a54363c.png"><br>  <i>Super Metroid, Samus performs Space Jump (with a Screw Attack bonus)</i> <br><br>  Jumping in the game is as simple as checking whether the player is on the ground (or if he has been on the ground in the last n frames more often) and, if so, give him a starting negative speed along the y axis (in physical terms, an impulse).  And let gravity do the rest. <br>  Here are four options that allow the player to control the jump: <br><ul><li>  Impulse: can be seen in games like Super Mario World and Sonic the Hedgehog.  The jump retains inertia (in terms of speed), which the character had before the jump.  In some games this is the only option to influence the arc of a jump, as in real life.  There is nothing to do here, it will be so until you do something to stop it. </li><li>  Acceleration in the air: just like that, getting control of horizontal movement when you are in the air.  Despite the physical impossibility, this is a very popular feature, as it makes the character more manageable.  Almost every platformer has this feature, except for games similar to Prince of Persia.  Basically, the acceleration received in the air is greatly reduced, so the pulse is still important.  However, some games (like Mega Man) give full control in the air. </li><li>  Lifting control: another physically impossible action, but also popular, as it gives even greater control over the character.  The longer you press the jump button, the higher the character flies.  This is usually done by suppressing gravity or continuing to add momentum to the character (but at the same time reducing the added impulse) while the button is pressed.  There is a time limit on the action if you don‚Äôt want the character to jump endlessly.  You can imagine this implementation as a very short work of the jet pack - it was delayed longer, it flew higher (approx. Lane). </li><li>  Multiple jumps: already being in the air, some games allow the player to jump again, sometimes an infinite number of times (like Space Jump in Super Metroid or flying to Talbot's Odyssey), or a limited number of jumps to the touch of the earth (‚Äúdouble jump‚Äù is the most frequent choice).  This can be achieved by keeping the counter, which increases with each jump and decreases when on the ground (more carefully update this value, otherwise you can reset it immediately after the first jump) and allow further jumps if the counter scored a small value.  Sometimes the second jump is shorter than the first, or it works only when lifting - if you start to fall, the second jerk cannot be done.  You can include other restrictions - Space Jump only works if you are already doing a spinning jump and just started to fall. </li></ul><br><br><h2>  Animations </h2><br><img src="https://habrastorage.org/files/3d7/b90/20d/3d7b9020d1d94b04ac9d0890fd75a952.png"><br>  <i>Black Thorne, the character performs a long animation before shooting back</i> <br><br>  In many games, your character will play the animation before it actually performs the action.  However, in action games, it will upset the player - ‚ÄúDO NOT DO IT!‚Äù For smoothness, you still need to have proactive animations for jumping and running, but you need to take care of how the game responds.  You can make such animations purely cosmetic, and the action itself to work out immediately. </div><p>Source: <a href="https://habr.com/ru/post/266237/">https://habr.com/ru/post/266237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266169/index.html">PBX-Sphere Online - How We Did It</a></li>
<li><a href="../266171/index.html">Wkhtmltopdf + Node.JS</a></li>
<li><a href="../266173/index.html">ReCaptcha in phpMyAdmin - activation, traversal and fix</a></li>
<li><a href="../266175/index.html">A monkey with a violin, or how I unexpectedly saved 790 rubles with the help of Fiddler</a></li>
<li><a href="../266199/index.html">Visualization of static and dynamic networks on R, part 4</a></li>
<li><a href="../266285/index.html">Visualization of static and dynamic networks on R, part 5</a></li>
<li><a href="../266287/index.html">Adding kernel modules to Fedora distributions</a></li>
<li><a href="../266291/index.html">Improved plugin for Smarty - Combine</a></li>
<li><a href="../266293/index.html">Linux and free cloud storage</a></li>
<li><a href="../266297/index.html">The digest of interesting materials for the mobile developer # 119 (August 31 - September 6)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>