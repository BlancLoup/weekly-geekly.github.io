<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Assembler for simulation tasks. Part 2: core simulation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="HCF, n. Mnemonic for 'Halt and Catch Fire', any of several undocumented and semi-mythical machine instructions with destructive side-effects <...> 
 J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Assembler for simulation tasks. Part 2: core simulation</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <sup>HCF, n.</sup>  <sup>Mnemonic for 'Halt and Catch Fire', any of several undocumented and semi-mythical machine instructions with destructive side-effects &lt;...&gt;</sup> <sup><br></sup>  <sup><a href="http://www.catb.org/jargon/html/H/HCF.html">Jargon file</a></sup> </blockquote>  In a <a href="http://habrahabr.ru/company/intel/blog/254419/">previous post,</a> I began to talk about the areas of assembly application in the development of software models of computer simulators.  I described the operation of the software decoder, and also speculated on the method of testing the simulator using unit tests. <br>  This article will explain why the programmer needs knowledge about the structure of the machine code when creating an equally important component of the simulator - the kernel responsible for simulating individual instructions. <br>  Until now, the discussion mainly concerned the assembler of the guest system.  The time has come to talk about the assembler master. <br><a name="habracut"></a><br><h2>  With the assembler in the heart - the core of the simulator </h2><br>  A serious simulator product should have a <a href="http://habrahabr.ru/company/intel/blog/202926/">multi-chamber</a> ‚Äúheart‚Äù: several ways to execute guest code.  The most efficient of them is used at any given time. <br>  In general, there are three technologies: interpretation, binary translation and direct execution.  And in each of them there is a place for machine code and assembler. <br><img src="https://habrastorage.org/files/dc4/4d9/f8a/dc44d9f8a89844c09812694c8d723d98.png"><br><br><h2>  Interpreter and intrinsic </h2><br>  The simplest interpreter-based simulator is written in a portable high-level language.  This means that each procedure describing a statement simply implements its logic in C. <br>  A large proportion of machine instructions have fairly simple semantics, which is easily expressed in C: add two numbers, compare them with the third, shift left and right, and so on. <br>  Privileged instructions are usually more difficult due to the need to perform various access checks and throwing exceptions.  However, they are relatively few. <br>  Difficulties appear further.  There are instructions that work with numbers according to the <a href="https://ru.wikipedia.org/wiki/IEEE_754-2008">IEEE 754</a> standard, i.e.  floating point, "buoy".  It will be necessary to correctly handle several formats of these numbers, from float16 through float32, float64, sometimes semi-standard float80 and even float82;  no architecture seems to support float128 directly, although the standard describes them.  Maintain non-NaN numbers, denormalized numbers, consider rounding modes and exception signaling.  And also to realize all sorts of arithmetic, like sines, roots, inverse values. <br>  Some help is the open-source <a href="http://www.jhauser.us/arithmetic/SoftFloat.html">Softfloat</a> library, which implements quite a lot of the standard. <br>  Another example of a class of instructions that are difficult to simulate is vector, SIMD.  They perform one operation immediately on the vector of similar arguments.  Firstly, they also often work with buoyers, although with integer operands too.  Secondly, there are many such instructions due to the combinatorial effect: for each operation there are several vector lengths and element formats, mask formats, the optional use of ‚Äúmixing‚Äù operations of broadcast, gather / scatter, etc. <br>  Having successfully implemented the emulation procedures for all the required guest instructions, the creator of the model will most likely encounter an extremely low interpreter speed.  And this is not surprising: what is done on a real machine in one instruction will be represented in the model as a procedure with a loop inside and nontrivial logic that calculates all the edge scenarios!  Now, if something for us implemented the semantics of instructions, and did it quickly! .. <br>  Wait a minute, but there must be exactly the same or at least very similar instructions in the host processor!  Let not for everyone, but at least for the part.  Moreover, popular compilers provide an interface for including machine instructions in the code - <i>intrinsic</i> (eng. Intrinsic - internal) - descriptions of functions that wrap machine instructions.  Example description of intrinsics for LZCNT instruction from <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel SDM</a> : <br><blockquote>  Intel C / C ++ Compiler Intrinsic Equivalent <br>  LZCNT: <br>  unsigned __int32 _lzcnt_u32 (unsigned __int32 src); <br>  LZCNT: <br>  unsigned __int64 _lzcnt_u64 (unsigned __int64 src); <br></blockquote><br><br>  These intrinsics also work in GCC.  Below I did a little experiment: <br><pre><code class="hljs mel">$ cat lzcnt1.c #include &lt;stdint.h&gt; #include &lt;immintrin.h&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, char **argv) { int64_t src = argc; int64_t dst = _lzcnt_u64(src); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)dst; } $ gcc -O3 -mlzcnt lzcnt1.c #   , ..     LZCNT $ objdump -d a.out &lt;......&gt; Disassembly of section .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>: <span class="hljs-number"><span class="hljs-number">00000000004003</span></span>c0 &lt;main&gt;: <span class="hljs-number"><span class="hljs-number">4003</span></span>c0: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">63</span></span> c7 movslq %edi,%rax <span class="hljs-number"><span class="hljs-number">4003</span></span>c3: f3 <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>f bd c0 lzcnt %rax,%rax <span class="hljs-number"><span class="hljs-number">4003</span></span>c8: c3 retq <span class="hljs-number"><span class="hljs-number">4003</span></span>c9: <span class="hljs-number"><span class="hljs-number">90</span></span> nop <span class="hljs-number"><span class="hljs-number">4003</span></span>ca: <span class="hljs-number"><span class="hljs-number">90</span></span> nop <span class="hljs-number"><span class="hljs-number">4003</span></span>cb: <span class="hljs-number"><span class="hljs-number">90</span></span> nop &lt;......&gt;</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      With the optimization flag <code>-O3</code> compiler did everything <code>_lzcnt_u64()</code> : from the ‚Äúfunction‚Äù <code>_lzcnt_u64()</code> there is neither a prologue nor an epilogue, only one machine instruction, which we need. <br>  Like machine instructions, intrinsics are usually many (but still less than instructions).  Each compiler provides its own set, something similar, somewhat different from the rest. <br><ul><li>  Intrinsics present in Microsoft compilers are described in MSDN separately for <a href="https://msdn.microsoft.com/en-us/library/hh977023.aspx">x86</a> and <a href="https://msdn.microsoft.com/en-us/library/hh977022.aspx">x64</a> . </li><li>  Intel C / C ++ compiler intrusion documentation has been available for several years in a convenient, interactive format on a <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/">web page</a> .  It‚Äôs quite convenient to filter them by extension class (SSE2, SSE3, AVX, etc.) and by functionality (bit operations, logical, cryptographic, etc.), and also get help on semantics and speed of operation (in cycles). </li><li>  Intrinsics of the GCC compiler for IA-32 mostly coincide with those described for ICC. </li><li>  For Clang, I did not find any clear documentation on the available intrinsics for any architecture.  If the reader has relevant information on this issue, then please share it in the comments. </li></ul><br><br>  Compared to handwritten sections of inline-assembler, intrinsics have the following advantages. <br><ol><li>  Calling a function is much more familiar, it is easier to understand and less likely to bungle on it when writing.  Intrinsics transfer work on the allocation of input and output registers to the compiler, and also allow it to carry out syntax checking, type consistency and other useful things and, if necessary, report problems.  In the case of inline-code, assembler diagnostics will be much more mysterious.  Those who often have to write out the clobber specifications for GNU as (and err in them) will agree with me. </li><li>  Intrinsics are not for the compiler "black boxes" of inline-assembler, in which unknown register and memory updates occur.  Accordingly, its register allocation algorithms can take this into account when processing the procedure code.  As a result, it is easier to get faster code. </li><li>  Intrinsics have, though weak, portability between compilers (but not master architectures).  In the extreme case, you can write a prototype of your own implementation if the host architecture does not directly support the instruction.  Example from practice: SSE2 instruction <code>CVTSI2SD xmm, r/m64</code> does not have valid coding in 32-bit processor mode.  Accordingly, there is no intrinsica, whereas in the 64-bit mode, for which a certain tool was originally developed, it was, and the code used it.  When compiling code on a 32-bit host, an error was generated.  Since the procedure tied to this intrinsic was not ‚Äúhot‚Äù (the speed of the application depended weakly on it), its own implementation of <code>_mm_cvtsi64_sd()</code> on C was written, which was substituted for the 32-bit build. </li></ol><br>  For these or other reasons, Microsoft has <a href="http://msdn.microsoft.com/en-us/library/4ks26t93%2528VS.100%2529.aspx">discontinued</a> support for inline assembly in MS Visual Studio 2010 and later for x64 architecture.  In this case, only intrinsics are available for inserting machine code into C / C ++ files. <br>  However, I would go against the truth, saying that using intrinsics is a panacea.  Nevertheless, it is necessary to look after the code generated by the compiler, especially when you need to squeeze the <a href="http://danluu.com/assembly-intrinsics/">maximum</a> performance out of it. <br><br><br><h2>  Binary translator and code generation </h2><br>  The binary translator (hereinafter DT) usually works faster than the interpreter, because it converts entire blocks of the guest machine code into their equivalent blocks of the host machine code, which then, in the case of a hot code, are repeatedly launched.  The interpreter (if it does not implement caching) is forced to process each encountered guest instruction from scratch, even if it has recently worked with it. <br>  And, unlike the interpreter, which can be written from beginning to end, without delving into the particular architecture of the host, DT will require knowledge of both the assembler and encodings of machine instructions.  When transferring your simulator to a new master system, a significant part of it, which is responsible for code generation, will have to be rewritten.  This is the price of speed work. <br>  In this article I will describe one of the easiest ways to build a so-called <i>template translator</i> .  If there is interest, then some other time I will try to talk about a more advanced binary translation method. <br>  Having received from the decoder information about the guest instructions, DT generates for it a piece of machine code - a <i>capsule</i> .  For several instructions executed sequentially, a <i>translation block</i> is created, consisting of their capsules recorded sequentially.  As a result, when in the guest system control is transferred to the first translated instruction, to simulate this and subsequent commands, it is enough to execute the code from the translation block. <br>  How to generate code for guest instructions, knowing its opcode and operand values?  According to the opcode, the simulator selects a <i>template</i> ‚Äî a master machine code preset that implements the desired semantics.  From the procedures usually created by the compiler, it is distinguished by the lack of a prologue and an epilogue, since we directly ‚Äúglue‚Äù such templates into a single translation block.  However, this is still not enough to mark the broadcast unit as ready. <br>  One more task remained unfulfilled - transfer the operand values ‚Äã‚Äãas arguments to the pattern, thus specializing it and turning it into a capsule.  Moreover, operands are most often transmitted at the broadcast stage: they are already known.  That is, it is necessary to ‚Äúsew‚Äù them directly into the master code of the capsule.  With implicit operands (for example, values ‚Äã‚Äãlying on the stack) this will not work, and they, of course, will have to be processed at the simulation stage, while wasting time. <br>  If the dimension of the set (= number of combinations) of explicit operands is small, then they can be ‚Äúsewn‚Äù into the group of patterns for this instruction ‚Äî one for each combination.  As a result, for each guest opcode, you will have to choose from N patterns according to what values ‚Äã‚Äãthe operands took in each specific case. <br>  Unfortunately, not everything is so simple.  In practice, it is often impossible to generate patterns for all possible values ‚Äã‚Äãof operands due to a combinatorial explosion of their number.  Thus, a three-operand instruction on an architecture with 32 registers will require 32 √ó 32 √ó 32 = 2¬π‚Åµ blocks of code.  And if the guest architecture has operands-literals (and all important ones have) 32 bits wide, then you have to store 2¬≥¬≤ capsule options.  Need to come up with something. <br>  In fact, there is no need to keep a bunch of almost identical templates - they all contain the same host instructions.  When variations of guest operands, they only change some host operands (but sometimes the length of the instruction, see my previous <a href="http://habrahabr.ru/company/intel/blog/254419">post</a> ), describing where the simulated state is stored or which literal is passed.  When forming a capsule from a template, it is necessary to ‚Äújust‚Äù patch the bits or bytes at the corresponding offsets: <br><img src="https://habrastorage.org/files/3d1/dd2/8de/3d1dd28debe34bc88cd9e3c25eba1313.png"><br>  A question for connoisseurs: which architectures in the example above are used as guest and master? <br><br>  Thus, for each guest instruction as part of a simulator with DT, one master machine code template and one procedure correcting the source operands for the correct ones are sufficient.  Naturally, for the pattern to be patched correctly, it is necessary to know the displacements of all operands relative to its beginning, that is, to understand the coding of the commands of the host system.  In fact, you must either implement your own encoder, or somehow learn to isolate the necessary information from the work of a third-party tool. <br>  In general, the template translation process is presented in the following figure. <br><img src="https://habrastorage.org/files/b77/c0c/322/b77c0c32289341dcac96ef677c936ce9.png"><br><br><h2>  Direct execution and virtualization </h2><br>  The third simulation mechanism I consider is direct execution.  The principle of its operation directly follows from the name - to simulate a guest code, launching it on the host without changes.  Obviously, this method potentially gives the highest simulation speed;  however, he is the most "capricious."  The following requirements must be met. <br><ol><li>  The architecture of the guest and the host must be the same.  In other words, it will not be possible to directly model the code for ARM on MIPS and vice versa;  In any case, it will not be a direct performance. </li><li>  The host architecture must meet the conditions for <a href="http://habrahabr.ru/company/intel/blog/196444/">efficient virtualization</a> . </li></ol><br><br>  Assume that the guest architecture meets the specified conditions, for example, this is Intel IA-32 / Intel 64 with Intel¬Æ VT-x extensions.  The next task that arises when adding support for direct execution to the simulator is writing the kernel module (driver) of the operating system.  You can't do without it: the simulator will need to execute privileged instructions and manipulate system resources, such as page tables, physical memory, interrupts, and so on.  From the user space to them do not reach.  On the other hand, completely ‚Äúdigging in‚Äù in the kernel is harmful: programming and debugging drivers is much more time-consuming and nerve-consuming than writing application programs.  Therefore, only the very minimum of the functionality of a simulator, which is accessed through the interfaces of system calls, is usually carried into the kernel.  All the virtual machines and simulators I know that use direct execution are arranged like this: a kernel module + a custom application that uses it. <br>  Since the kernel module is written to a specific OS, you need to understand that when transferring an application to another OS, you will have to rewrite it, perhaps quite strongly.  This is another reason to minimize its size. <br>  In principle, the use of the assembler in the core is justified in about the same conditions as in the userland - that is, when not to do without it.  Virtual machines work with system structures, such as VMCS (virtual machine control structure), control, debug, and model-specific registers, which are available only through specialized instructions.  The most sensible thing would be to use intrinsics for them, but ... <br>  Not all machine instructions have ready intrinsics.  In compilers designed to build primarily user-defined code, drivers somehow forget about the needs of driver writers.  For the appeal to them it is necessary to use the built-in (inline) assembler.  In the source code of the KVM virtual machine, for example, there is such a <a href="">definition</a> for the function of reading VMCS fields: <br><pre> <code class="hljs kotlin">#define ASM_VMX_VMREAD_RDX_RAX <span class="hljs-string"><span class="hljs-string">".byte 0x0f, 0x78, 0xd0"</span></span> static __always_inline unsigned long vmcs_readl(unsigned long field) { unsigned long value; asm <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> (__ex_clear(ASM_VMX_VMREAD_RDX_RAX, <span class="hljs-string"><span class="hljs-string">"%0"</span></span>) : <span class="hljs-string"><span class="hljs-string">"=a"</span></span>(value) : <span class="hljs-string"><span class="hljs-string">"d"</span></span>(field) : <span class="hljs-string"><span class="hljs-string">"cc"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; }</code> </pre><br>  To be honest, I expected to see here a VMREAD call on the vmread mnemonic, but for some reason its ‚Äúraw‚Äù representation in the form of bytes is used.  Perhaps, in this way, the authors wanted to support the build with compilers that are not aware of such an instruction. <br>  By the way, an example with an intrinsic for LZCNT from the example above can be rewritten using the inline-assembler format in the following form.  The machine code in this simple case is generated the same. <br><pre> <code class="hljs mel">#include &lt;stdint.h&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, char **argv) { int64_t src = argc; int64_t dst; __asm__ volatile( <span class="hljs-string"><span class="hljs-string">"lzcnt %1, %0\n"</span></span> :<span class="hljs-string"><span class="hljs-string">"=r"</span></span>(dst) :<span class="hljs-string"><span class="hljs-string">"r"</span></span>(src) :<span class="hljs-string"><span class="hljs-string">"cc"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)dst; }</code> </pre><br>  Although initially I planned to describe in this article in detail the features of the GNU-inline format of the assembler, I decided not to do this, because  There is a lot of information on this topic on the Internet.  If there is a need, I can do it in my next article. <br>  It happens that it is more profitable to assemble the entire assembler in one file than to try to fit it among the C code.  I did not find examples for KVM, but they were for <a href="">Xen</a> .  I note that in this file the assembler itself is no more than a quarter in volume, the rest is preprocessor directives and comments documenting what this code does and what its interface is. <br><br><h3>  Results </h3><br>  Assembly language plays a key role in the development of simulation solutions.  It is used in various components of models, as well as in the process of their testing. <br>  The assembler code itself in a complex project that also uses high-level languages ‚Äã‚Äãcan be represented in three ways. <br><ol><li>  Intrinsiki - wrappers for individual machine instructions with the interface of ordinary functions C / C ++. </li><li>  Assembler inserts ‚Äî fragments of assembler code specific to the selected compiler / assembler, consistent with the high-level code surrounding them. </li><li>  Files written entirely in assembly language are used in those (rare) cases where it is more convenient to express a certain sequence of actions entirely in assembly language.  They interact with the outside world either through the interface of functions (independently implementing the ABI of the platform for which they are intended) or without any interaction (in the case of independent unit tests). </li></ol><br><br></div><p>Source: <a href="https://habr.com/ru/post/254027/">https://habr.com/ru/post/254027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254015/index.html">Experience roentgenoscopy at home</a></li>
<li><a href="../254017/index.html">A hundred times the same thing</a></li>
<li><a href="../254021/index.html">Turn your Android phone into a network SQL database (MyMobileSQLServer - Utesov)</a></li>
<li><a href="../254023/index.html">Planets and the fourth dimension</a></li>
<li><a href="../254025/index.html">Microsoft is going to strike! Details about our participation in the conference</a></li>
<li><a href="../254029/index.html">Perl 6 and smart match</a></li>
<li><a href="../254031/index.html">Three user states (web development)</a></li>
<li><a href="../254035/index.html">Protection of devices against incorrect polarity supply</a></li>
<li><a href="../254037/index.html">Antifraud. Service Architecture (Part 3)</a></li>
<li><a href="../254041/index.html">Project Spartan is almost here.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>