<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Find the system call code mkdir</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Even in the first year of my acquaintance with Ubuntu, I wondered how the core of this OS works. I decided with all seriousness to figure it out, down...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Find the system call code mkdir</h1><div class="post__text post__text-html js-mediator-article"> <i>Even in the first year of my acquaintance with Ubuntu, I wondered how the core of this OS works.</i>  <i>I decided with all seriousness to figure it out, downloaded the 80-megabyte source archive, and ... everything!</i>  <i>I did not know where to start, nothing to finish.</i>  <i>He opened random files one by one and was immediately lost.</i>  <i>I think this happened to every experienced Linux user.</i>  <i>Now I have gained experience and would like to share it.</i> <br><br>  In this article I will explain how I searched for the mkdir system call code. <br><br>  To begin with, the mkdir function is defined in <code>sys/stat.h</code>  The prototype is as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Create a new directory named PATH, with permission bits MODE. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mkdir</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__const </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *__path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">__mode_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __mode)</span></span></span><span class="hljs-function"> __THROW __</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nonnull</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>;</code> </pre><br><br>  This header file is part of the POSIX standard.  Linux is almost completely POSIX-compatible, which means it must implement mkdir with exactly this signature. <br><br>  But even knowing the signature, it‚Äôs not easy to find the actual system call code ... <br><a name="habracut"></a><br>  And in truth, <code>ack "int mkdir"</code> will return: <br><br><blockquote>  security / inode.c <br>  103: static int mkdir (struct inode * dir, struct dentry * dentry, int mode) <br><br>  tools / perf / util / util.c <br>  4: int mkdir_p (char * path, mode_t mode) <br><br>  tools / perf / util / util.h <br>  259: int mkdir_p (char * path, mode_t mode); <br></blockquote><br><br>  It is clear that no signature completely matches.  Where is the implementation of the mkdir function?  What is the algorithm for finding implementations of system calls in the Linux kernel? <br><br>  System calls do not work like normal functions.  They are not functions at all.  To perform a system call, you need some assembly code.  By and large, the system call number is put in the EAX register (by the way, system calls are addressed by number, not by address), arguments are put in the other registers: the first in EBX, the second in ECX, the third in EDX, the fourth in ESX, fifth in edi.  By the way, this is why a system call cannot have more than 5 arguments.  After locating all the necessary values, the program that wants to make a system call performs the 128th interrupt (on the assembler: int 0x80).  Interruption, transfers the processor to the kernel mode and transfers control to the address specified in advance with the kernel.  As you can see, the system calls operate at a lower level than the C functions. <br><br>  The number of any system call can be found in <code>usr/include/asm*/unistd.h</code> : <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __NR_mkdir 83 __SYSCALL(__NR_mkdir, sys_mkdir)</span></span></code> </pre><br><br>  That is the mkdir system call has number 83. <br><br>  If you programmed in user space under Linux, you most likely know that, as a rule, C functions are used to make system calls.  Where do they come from?  Those functions are just wrappers from the GNU libc library.  Each system call has a corresponding wrapper function.  The functions themselves do all the same interrupts. <br><br>  So where do you look for mkdir now?  In theory, a system call could be implemented simply in assembly language, then the corresponding C function simply would not exist, but this is not so.  On Linux, each system call is defined in <code>include/linux/syscalls.h</code> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sys_mkdir</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *pathname, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode)</span></span></span></span>;</code> </pre><br><br>  The implementation is in the appropriate part of the kernel.  Here you just need to know that mkdir is part of the VFS file subsystem and is defined in <code>fs/namei.c</code> : <br><pre> <code class="cpp hljs">SYSCALL_DEFINE2(mkdir, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *, pathname, <span class="hljs-keyword"><span class="hljs-keyword">umode_t</span></span>, mode) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sys_mkdirat(AT_FDCWD, pathname, mode); }</code> </pre><br><br>  SYSCALL_DEFINE2 is one of the SYSCALL_DEFINEx series macros, where x is the number of arguments to the system call.  In the above code, another system call is called - sys_mkdirat, which is also located in <code>fs/namei.c</code> .  Note that here the system call is executed by a function call, because the calling code is already executed in kernel mode. <br><br><pre> <code class="cpp hljs">SYSCALL_DEFINE3(mkdirat, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, dfd, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *, pathname, <span class="hljs-keyword"><span class="hljs-keyword">umode_t</span></span>, mode) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dentry</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dentry</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> error; dentry = user_path_create(dfd, pathname, &amp;path, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(dentry)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(dentry); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IS_POSIXACL(path.dentry-&gt;d_inode)) mode &amp;= ~current_umask(); error = security_path_mkdir(&amp;path, dentry, mode); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!error) error = vfs_mkdir(path.dentry-&gt;d_inode, dentry, mode); done_path_create(&amp;path, dentry); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error; }</code> </pre><br><br>  And here is already interesting!  We meet the first checks and, again, the transfer of control to another function, vfs_mkdir, which is defined in the same <code>fs/namei.h</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vfs_mkdir</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct inode *dir, struct dentry *dentry, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">umode_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> error = may_create(dir, dentry); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> max_links = dir-&gt;i_sb-&gt;s_max_links; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dir-&gt;i_op-&gt;mkdir) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EPERM; mode &amp;= (S_IRWXUGO|S_ISVTX); error = security_inode_mkdir(dir, dentry, mode); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (max_links &amp;&amp; dir-&gt;i_nlink &gt;= max_links) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EMLINK; error = dir-&gt;i_op-&gt;mkdir(dir, dentry, mode); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!error) fsnotify_mkdir(dir, dentry); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error; }</code> </pre><br><br>  More checks, more control transfers.  It is worth saying that Linux is a very multi-level system, where duties are distributed across different parts of the system.  Therefore, it is not strange that in the code above the logic is constantly delegated.  In the last piece of code dir-&gt; i_op-&gt; mkdir (dir, dentry, mode) is called.  Follow the trail!  dir is of type inode *.  From the definition of the inode structure, we learn that the i_op pointer is of the type inode_operations *.  The latter structure contains pointers to functions of operations that can be performed on this node, and the implementations are different for different file systems.  That is, depending on what file system our dir belongs to, the inode_operations structure will contain pointers to certain implementations. <br><br>  For example for ext4, we find the mkdir implementation in fs / ext4 / namei.c <br><br><div class="spoiler">  <b class="spoiler_title">Actually so the desired code!</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ext4_mkdir</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct inode *dir, struct dentry *dentry, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">umode_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">handle_t</span></span> *handle; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inode</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inode</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">buffer_head</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dir_block</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ext4_dir_entry_2</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">de</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ext4_dir_entry_tail</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = dir-&gt;i_sb-&gt;s_blocksize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> csum_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err, retries = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EXT4_HAS_RO_COMPAT_FEATURE(dir-&gt;i_sb, EXT4_FEATURE_RO_COMPAT_METADATA_CSUM)) csum_size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct ext4_dir_entry_tail); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EXT4_DIR_LINK_MAX(dir)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EMLINK; dquot_initialize(dir); retry: handle = ext4_journal_start(dir, EXT4_DATA_TRANS_BLOCKS(dir-&gt;i_sb) + EXT4_INDEX_EXTRA_TRANS_BLOCKS + <span class="hljs-number"><span class="hljs-number">3</span></span> + EXT4_MAXQUOTAS_INIT_BLOCKS(dir-&gt;i_sb)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(handle)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(handle); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_DIRSYNC(dir)) ext4_handle_sync(handle); inode = ext4_new_inode(handle, dir, S_IFDIR | mode, &amp;dentry-&gt;d_name, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); err = PTR_ERR(inode); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(inode)) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out_stop; inode-&gt;i_op = &amp;ext4_dir_inode_operations; inode-&gt;i_fop = &amp;ext4_dir_operations; inode-&gt;i_size = EXT4_I(inode)-&gt;i_disksize = inode-&gt;i_sb-&gt;s_blocksize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(dir_block = ext4_bread(handle, inode, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;err))) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!err) { err = -EIO; ext4_error(inode-&gt;i_sb, <span class="hljs-string"><span class="hljs-string">"Directory hole detected on inode %lu\n"</span></span>, inode-&gt;i_ino); } <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out_clear_inode; } BUFFER_TRACE(dir_block, <span class="hljs-string"><span class="hljs-string">"get_write_access"</span></span>); err = ext4_journal_get_write_access(handle, dir_block); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out_clear_inode; de = (struct ext4_dir_entry_2 *) dir_block-&gt;b_data; de-&gt;inode = cpu_to_le32(inode-&gt;i_ino); de-&gt;name_len = <span class="hljs-number"><span class="hljs-number">1</span></span>; de-&gt;rec_len = ext4_rec_len_to_disk(EXT4_DIR_REC_LEN(de-&gt;name_len), blocksize); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(de-&gt;name, <span class="hljs-string"><span class="hljs-string">"."</span></span>); ext4_set_de_type(dir-&gt;i_sb, de, S_IFDIR); de = ext4_next_entry(de, blocksize); de-&gt;inode = cpu_to_le32(dir-&gt;i_ino); de-&gt;rec_len = ext4_rec_len_to_disk(blocksize - (csum_size + EXT4_DIR_REC_LEN(<span class="hljs-number"><span class="hljs-number">1</span></span>)), blocksize); de-&gt;name_len = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(de-&gt;name, <span class="hljs-string"><span class="hljs-string">".."</span></span>); ext4_set_de_type(dir-&gt;i_sb, de, S_IFDIR); set_nlink(inode, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (csum_size) { t = EXT4_DIRENT_TAIL(dir_block-&gt;b_data, blocksize); initialize_dirent_tail(t, blocksize); } BUFFER_TRACE(dir_block, <span class="hljs-string"><span class="hljs-string">"call ext4_handle_dirty_metadata"</span></span>); err = ext4_handle_dirty_dirent_node(handle, inode, dir_block); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out_clear_inode; set_buffer_verified(dir_block); err = ext4_mark_inode_dirty(handle, inode); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!err) err = ext4_add_entry(handle, dentry, inode); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { out_clear_inode: clear_nlink(inode); unlock_new_inode(inode); ext4_mark_inode_dirty(handle, inode); iput(inode); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out_stop; } ext4_inc_count(handle, dir); ext4_update_dx_flag(dir); err = ext4_mark_inode_dirty(handle, dir); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out_clear_inode; unlock_new_inode(inode); d_instantiate(dentry, inode); out_stop: brelse(dir_block); ext4_journal_stop(handle); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err == -ENOSPC &amp;&amp; ext4_should_retry_alloc(dir-&gt;i_sb, &amp;retries)) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> retry; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; }</code> </pre></div></div><br><br>  Understanding the work of the kernel is a useful skill in the arsenal of any Linux user.  I hope this article was also helpful! <br><br>  Resources: <br>  <a href="http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html">Linux system call table</a> <br>  <a href="http://git.kernel.org/%3Fp%3Dlinux/kernel/git/torvalds/linux.git%3Ba%3Dtree">Linux sources 3.6</a> <br>  <a href="http://unix.stackexchange.com/questions/797/understanding-the-linux-kernel-source">Discussion on unix.stackexchange.com</a> </div><p>Source: <a href="https://habr.com/ru/post/155645/">https://habr.com/ru/post/155645/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../155633/index.html">Do you have Unity Web Apps?</a></li>
<li><a href="../155637/index.html">Brazilian newspapers no longer work with Google News.</a></li>
<li><a href="../155639/index.html">SMM 2.0</a></li>
<li><a href="../155641/index.html">Air Fuel Synthesis has created a prototype system for producing gasoline from humid air.</a></li>
<li><a href="../155643/index.html">Amazon can delete all Kindle books without warning.</a></li>
<li><a href="../155647/index.html">ABBYY Labs: Project FromWord - we play with words on Android</a></li>
<li><a href="../155649/index.html">Preparing an educational resource for Android from XDA-developers</a></li>
<li><a href="../155651/index.html">OpenCV 2.4 Flat Object Recognition</a></li>
<li><a href="../155653/index.html">Bukhsoft-Online became the winner of the "Clouds 2012" award</a></li>
<li><a href="../155655/index.html">Autoconfiguration in the Amazon cloud using Chef-Solo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>