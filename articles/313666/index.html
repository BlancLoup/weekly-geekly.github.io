<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Scalable nginx configuration</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Igor Sysoev ( isysoev ) 
 My name is Igor Sysoev, I am the author of nginx and the co-founder of the same name company. 

 We continue to develop open...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Scalable nginx configuration</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/b33/50d/976/b3350d976d950efafc65d409546e2138.jpg" alt="Igor Sysoev"><br><br><h2>  Igor Sysoev ( <a href="https://habrahabr.ru/users/isysoev/" class="user_link">isysoev</a> ) </h2><br>  My name is Igor Sysoev, I am the author of nginx and the co-founder of the same name company. <br><br>  We continue to develop open source.  Since the founding of the company, the pace of development has increased significantly since a lot of people work on the product.  As part of open source, we provide <a href="https://www.nginx.com/">paid support</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I‚Äôll talk about the scalable nginx configuration, but it‚Äôs not about how to service hundreds of thousands of simultaneous connections with nginx, because you don‚Äôt need to configure nginx for this.  You need to set an adequate number of workflows or put it in the ‚Äúauto‚Äù mode, set worker_connections to 100,000 connections, then configuring the kernel is a much more global task than simply setting up nginx.  Therefore, I will talk about other scalability - about the scalability of the nginx configuration, i.e.  how to ensure the growth of the configuration from hundreds of lines to several thousand and at the same time spend the minimum (preferably constant) time to maintain this configuration. <a name="habracut"></a><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/117154512" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Why, in fact, there was such a topic?  About 15 years ago I started working at the Rambler and administered servers, in particular, apache.  And apache has such an unpleasant feature, which is well illustrated by the following two configurations: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d5a/cf4/353/d5acf4353409e449971ed9f8af5e94e1.png"><br><br>  There are two locations here and they go in a different order.  The same request, depending on which configuration is used, will be processed by different files - either a php file or an html file.  That is, when working with the apache configuration, the order matters.  And you can not cancel it - when processing requests, apache goes through all the locations, tries to find those that somehow coincide with this request, and collects the configuration from all these locations.  It merges it and, in the end, uses the resultant. <br><br>  This is convenient if you have a small configuration - so you can make it even smaller.  But as you grow, you encounter the following problems.  For example, if you add a new location at the end, everything works, but after that you need to change the configuration in the middle or throw out the irrelevant location from the middle.  You need to review the entire configuration after these locations to make sure that everything continues to work as before.  Thus, the configuration turns into a house of cards - by pulling out one card, we can tear down the whole structure. <br><br>  In apache, to add hell to the configuration there are several more sections that work in exactly the same way, they are processed in a different order, but one of the resulting configuration is assembled from all of them.  All this is done in runtime, i.e.  if you have many modules, then each module will merge configurations (this partially explains why nginx in some tests is faster than apache - because nginx does not merge configuration in the runtime).  Some of these sections and most of the directives can be placed in .htaccess files that are scattered throughout the site, and in order to make your life and your colleagues even more ‚Äúinteresting‚Äù, these files can be renamed, and look for this configuration ... <br><br>  And the ‚Äúcherry on the cake‚Äù are RewriteRules, which allow you to make the configuration similar to sendmail.  Few appreciated the humor, because, fortunately, most no longer know what it is. <br><br>  RewriteRules are a nightmare.  A lot of administrators come not so much with the apache background, as with the apache administration background on shared hosting, i.e.  when the only administration tool was .htaccess.  And in it, they make very intricate rewriteRules, which are very hard to understand both by virtue of syntax and logic. <br><br>  This was one of the drawbacks of apache, which really annoyed me; it did not allow me to create large enough configurations.  During the development of nginx I wanted to change this, I fixed a lot of annoying apache features, added my own.  Here is the previous example in nginx: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6bb/215/2c3/6bb2152c3aa2b88d8860ca4ce0f7fa6f.png"><br><br>  Unlike apache, regardless of the order of locations, the request will be processed in the same way, because  nginx searches for the maximum possible match with the prefix location, not specified by a regular expression, and then selects this location.  The configuration of the selected location is used, and all other locations are ignored.  This approach allows you to write configurations with hundreds of locations and not think about how it will affect everything else, i.e.  we get some kind of containers.  You isolate processing in one small place. <br><br>  Consider how nginx selects the configuration that it will use when processing the request.  First of all, a suitable server subquery is searched.  The selection is made based on the address and port first, and then all the server-name names associated with the data address and port. <br><br>  If you want to, say, place the server at several addresses, write there many server names, and you want all these server names to work at all addresses, then you need to duplicate addresses on all names.  After the server is selected, a suitable location is searched for inside the server.  First, all prefix locations are checked, the maximum match is searched, then it is checked if there are locations defined by regular expressions.  Since we cannot determine the maximum match for regular expressions, the location is chosen, for which the regular expression matches the first one.  After that, the configuration names of this location are used.  If no regular expression matches, the configuration that was found before is used with the maximum matching prefix. <br><br>  Regular expressions add dependency on order, thus creating poorly maintained configurations, because life is more complicated than theory, and very often the site structure is such a dump from a heap of static files, scripts, etc., and in this case the only way to handle everything queries are regular expressions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0da/a74/cb0/0daa74cb04b2b72c64fe27d86c1472f1.png"><br><br>  On this slide, an illustration of how to do is not necessary.  If you already have such sites, they need to be redone. <br><br>  When I talked about how to handle the configuration, it was the original design.  Then it became possible to describe locations within a location, i.e.  inclusive locations, and the order has adapted a bit.  Those.  First, the maximum matching prefix location is searched, then inside it the maximum matching prefix location is searched.  Such a recursive search continues until we reach the location, in which there is nothing left. <br><br>  After that, we start checking locations with regular expressions in the reverse order, i.e.  we entered the most nested location, see if there is a regular expression.  If not, then go down to the level below, etc.  Again, the first matching location with the regular expression "wins."  This approach allows you to do this processing: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd9/995/0bc/bd99950bcb52e41a5e27fada79ffb99c.png"><br><br>  We have two locations here with regular expressions, but for the request /admin/index.php the nested first location will be selected, not the second. <br><br>  In addition, the second part of the search for regular expressions can be disabled by marking the location with the symbol ^ ~: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/173/b66/10e/173b6610e857c8e4c2f4d23a96acf0c5.png"><br><br>  Such a ban means that if this location showed the maximum match, then regular expressions will not be searched for after it. <br><br>  Very often, people try to make the configuration smaller, i.e.  they take out some common part of the configuration and simply redirect requests there.  Here, for example, is a very bad way to throw everything into php processing: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/010/f7e/c9a/010f7ec9ac20ee1e24ed62bc2783bf15.png"><br><br>  In nginx there are other methods for extracting common parts of the configuration.  First of all, this is the inheritance of the configuration from the previous level.  For example, here we can write at the http level to enable sendfile for all servers and all locations: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d6c/7ec/898/d6c7ec898c970688dfbbfbbeb1c8240f.png"><br><br>  This configuration is inherited in all nested servers and locations.  If we need to cancel sendfile somewhere, because, let's say, the file system does not support it, or for some other reason, then we can turn it off in a specific location or in a specific server. <br><br>  Or, for example, for the server, we can write a common root, where we need to override it. <br><br>  This approach differs from apache in that we know specific places where we need to look for common parts that may affect our location. <br><br>  The only thing that cannot be done is shared - for example, at the level of http you cannot describe location.  This was done deliberately.  In apache, you can do this, but it causes a lot of problems when used. <br><br>  Personally, I prefer to describe the locations explicitly directly in the configuration.  If you do not want to do this, then you can enable it through an external file. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72f/d0c/71e/72fd0c71eabd06234c72f099b250c6b9.png"><br><br>  Now I would like to talk about why people want to write less, i.e.  why they fumble shared configurations.  They believe they will spend less energy.  In fact, people do not want to write as much as spend less time.  But they don‚Äôt think about the future, but they think that if they write less now, it will be the same in the future ... <br><br>  The correct approach is to use copy-paste.  That is, inside a location should be all the necessary directives for its processing. <br><br>  The usual argument for DRY lovers (Don't Repeat Youself) is that if you need to fix something, you can fix it in one place and everything will be fine. <br><br>  In fact, modern editors have the find-replace functionality.  If you need, for example, to fix the name / port of the backend or change the root, the header, transferred to the backend, etc., you can easily do this using find. <br><br>  In order to understand whether you need to change some parameter in a given place, a couple of seconds is enough.  For example, you have 100 locations, you will spend 2 seconds for each location, for a total of 200 seconds.  ~ 3 min  That's not a lot.  But when in the future you have to untie some kind of location from the general part, then it will be much more difficult.  You will need to understand what to change, how it will affect other locations, etc.  Therefore, as for the nginx configuration, you need to use copy-paste. <br><br>  Generally speaking, administrators do not like to spend a lot of time on their configurations.  I myself am so.  The administrator can have 2-3 favorite products, he can mess around with them a lot, while there are a dozen other products that you don‚Äôt want to spend time on.  For example, I have mail on my personal site, this is Exim, Dovecot.  I do not like to administer them.  I just want them to work, and if you need to add something so that it takes no more than a couple of minutes.  I'm just too lazy to learn the configuration, and I think most nginx administrators - they are the same, they want to administer ngnix as little as possible, it is important for them to work.  If you are such an administrator, use copy-paste. <br><br>  Examples of how short non-scalable configurations can be turned into what is needed: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/416/679/342/416679342faa4a442f255ac53ebe17ec.png"><br><br>  Then a person thinks that he wrote a regular expression, just a little, everything is fine.  In fact, because  there is a regular expression, this is bad - it can affect everything else.  Therefore, I personally do this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c28/c67/70d/c28c6770da7564ca887ee04f4c163125.png"><br><br>  If you have this root common to all locations, or at least used in most of them, then this can be done even this way: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/601/23e/9fe/60123e9feaaf6e0802a302de6f81137e.png"><br><br>  This is, in general, a legal configuration, i.e.  completely empty location configuration. <br><br>  The second way to avoid copy-paste is an example: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ec/835/e98/0ec835e98b32a56c50d9619188c0e7db.png"><br><br>  Administrators who used to work with apache think that admin / index.php should request authorization.  In nginx this does not work, because  Index.php is processed in one location, and location / admin is completely different.  But you can make a nested configuration and then index.php will naturally request authorization. <br><br>  Often you need to use regular expressions in order to "bite" some parts of the URL and use them in processing.  This is a bad way: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/773/31a/510/77331a510cfce5f1ac29fdb923c628e9.png"><br><br>  Right is to use nested locations, so we isolate regular expressions from the configuration of the rest of the site, i.e.  beyond this location / img /, which is placed on the screen, the control will not go away: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ff/d1e/974/6ffd1e974befe5764f8c9dac8026eb35.png"><br><br>  Another place where it is safe to use regular expressions in nginx is the map, i.e.  form variables based on some other variables using regular expressions, etc .: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ef/ca1/9cc/6efca19cc5265d64800898a053d39739.png"><br><br>  I did not say anything about using Rewrites, because they should <b>not</b> be used at all.  If you can not not use them, then use them on the side of the backend. <br><br>  Evil is also not a recommended design in nginx, because, as Evil works inside, 10 people in the world know it, and you are unlikely to be one of them. <br><br>  Here is the configuration when we have two if (true): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/710/b9a/5f3/710b9a5f33246fd23269f073092a19af.png"><br><br>  It is expected that we will have gzip and etag turned off.  Actually, only the last if will work. <br><br>  There is one safe use for if is when you use it to return a response to a client.  You can use rewrite in this place, but I do not like it, I use return (it allows you to add code, etc.): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/242/2e9/4e3/2422e94e34f7b4d12a52151c0d7bfb29.png"><br><br>  We summarize: <br><br><ul><li>  it is desirable to use only prefix locations; </li><li>  Avoid regular expressions, but if regular expressions are still needed in the configuration, then they are better isolated; </li><li>  use maps; </li><li>  Do not listen to people who say that DRY is a universal paradigm.  It's good when you like the product, or you program the product.  If you just need to facilitate your administrative life, then copy-paste is for you.  Your friend is an editor with a good find-replace; </li><li>  do not use rewrites; </li><li>  use if only to return some answer to the client. </li></ul><br>  <b>Question from the audience:</b> If I use http rewrites on https, where is it better to use it - in nginx or on the backend? <br><br>  <b>Answer:</b> Use it in nginx.  Ideally, this is how you make two servers.  One server you have plain text and it only does rewrites.  In this place there will be literally several directives - server listen on the port, server name, if needed, and return in 301 or 302 to https with duplication of the request URI.  There even rewrite is not needed, use return. <br><br>  If you want to do something more complicated, then somewhere you can insert an if.  Suppose some of your locations are processed in plain text, describe them using regular expressions in the map, for example, and everything else can be redirected to https.  Or, on the contrary, insert one if if inside each location, which will redirect to https. <br><br>  <b>Question from the audience:</b> Thank you for nginx.  I have a somewhat joking question.  You do not plan to add a startup key or a compilation key that will not allow using the include directive, will it prevent using if regular expressions in locations? <br><br>  <b>Answer:</b> No, it is unlikely.  We usually add some directives, improve them and then make them deprecated.  They print warning messages in the log for a while before they disappear completely, but they work in some mode.  We are unlikely to do what you said, we will better write a good User Guide, perhaps based on the materials of this speech. <br><br>  <b>Question from the audience: The</b> usual desire that arises when using if is because it can be used in the server and in the location, and the map cannot be used.  Why did this happen? <br><br>  <b>Answer:</b> All variables in nginx are calculated on demand, i.e.  if map is described at the http level, this does not mean that this variable will be computed when processing the request.  Map is needed in order to otmappit something into one, and then something one - into another, and you can use the resulting variable in if or within some expression, proxy somewhere, etc.  A map is just like a declaration ... Maybe it makes sense to move them to the server in order to make them local to the server if you have the same variable.  It was just harder to program there, so they were moved to a global server.  In nginx there are no variables that are local to the server. <br><br>  From the point of view of performance, there are no problems, it is just an inconvenience.  It will be necessary to do, say, three servers and three maps, and the variable will have the prefix ‚Äúserver such and such‚Äù ... You can, in principle, describe them in front of the server, i.e.  These maps are one before the first server, then before the second ... In the configuration, you will not have to go up and down, they will be closer to the server. <br><br>  <b>Question from the audience:</b> I am new to the logic of the work of returns.  Please tell us where it is worth using returns instead of rewritees, some use specific ones? <br><br>  <b>Answer:</b> In general, rewrite is replaced with the following construction: location with a regular expression, in which you can make some captures - captures, selections, and return directive.  Those.  one rewrite is its left side in the location, and the right side is what will be in the return after the response code.  Return offers the possibility of returning a different response code, and there are only 301, 302 in the rewrite to return to the client. Return can return 404 with some body, can - 200, 500, can return redirect.  And in his body, you can use a variable, write something.  If it is 301, 302, then it is not the body, it is already the URL to which you need to redirect.  In general, return has richer functionality. <br><br>  <b>Question from the audience:</b> I have an applied question.  Nginx can be used as a mail proxy.  Is it possible to give SMTP access to the email client, send an email through this email client, and nginx intercept the data and send it to the script, bypassing the webmail server?  Now we will implement this task using postfix - it intercepts the letter and then throws it at the script where the processing takes place. <br><br>  <b>Answer:</b> I doubt that this can be done through nginx.  I can describe briefly the functionality that is in the SMTP Proxy in nginx.  He knows how to do the following - an SMTP client connects to it, shows some kind of authentication, nginx goes to an external script, checks the username and password, and then says, let the client go to some servers (and passes on which ones), or do not let  That's all he can do.  If it is decided to start somewhere, then nginx via SMTP connects to this server and sends it to it.  Whether it falls into your script, I can not say.  Hardly. <br><br>  SMTP Proxy with authorization appeared, because in the Rambler for mail clients there is a special server through which these clients send mail.  And it turned out that about 90% of connections are not Rambler clients, but spam and viruses.  In order not to load postfixes, not to raise unnecessary processes, nginx was put in front of this, which checks whether this client provides its authentication data.  Actually, for this it was done - just to repel "junk" customers. <br><br>  <b>Question from the audience:</b> You mentioned containers today, this is, of course, a promising approach, but it implies a changing topology and dynamic configuration.  Now it still leads to the fact that people build some external ‚Äúcrutches‚Äù, which periodically react to events of topology changes, generate the actual nginx config through some template, slip it and kick it in order to recalculate the config.  Interestingly, the company has some plans for development towards containerization, i.e.  towards providing more convenient and natural means for this trend? <br><br>  <b>Answer: It</b> depends on what you mean by containers in this case.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When I talked about containers, compared, I said that these locations look different from each other. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Question:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We returned back to docker, to the possibility of running backends somewhere in containers, which is dynamically executed on different hosts, and we need, roughly speaking, to add a new host to balancing ... </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Answer:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We have one of the Advanced Load parts in NGINX + Balancing just means that you can dynamically add servers to the upstream. It turns out that you do not need to reload the nginx config, and all this is done on the fly - for this there is an API.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More active chelschiki included there. </font><font style="vertical-align: inherit;">When the usual open source nginx connects to the backend, if the backend does not respond, then nginx does not access it for some time, i.e. </font><font style="vertical-align: inherit;">There is also a kind of helcheck here, but customers are suffering. </font><font style="vertical-align: inherit;">If you have 50 clients at the same time went to one backend, and it lies or will time out after 5-10 seconds, then the clients will see it, and only after that they will be transferred to another upstream. </font><font style="vertical-align: inherit;">In NGINX + we have proactive backend testing, i.e. </font><font style="vertical-align: inherit;">the backends themselves are tested, and clients simply don‚Äôt go to fallen backends. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Question:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And, since there is an active helcheck, then maybe they have already written down a beautiful JSON-like status page, which can be parted? </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Answer:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yes, we have monitoring, it is available, including through JSON, and also it is in the form of a beautiful html. </font></font><br><br><h3>  Contacts </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ª </font></font><a href="https://habrahabr.ru/users/isysoev/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isysoev</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font><a href="https://habrahabr.ru/hub/nginx/"><font style="vertical-align: inherit;">Nginx</font></a><font style="vertical-align: inherit;"> company blog</font></font><a href="https://habrahabr.ru/hub/nginx/"><font style="vertical-align: inherit;"></font></a> <br><br><blockquote> <font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This report is a transcript of one of the best speeches at the conference of developers of high-loaded systems </font></font><a href="http://highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HighLoad ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Now we are actively preparing for the conference in 2016 - this year HighLoad ++ will be held in Skolkovo on November 7 and 8. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The DevOps section this year was prepared by a separate Program Committee, which was overseen by </font></font><a href="http://express42.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Express42</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A </font></font><a href="http://www.highload.ru/2016/abstracts"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dozen reports</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , including a report by Maxim Dunin on </font></font><a href="http://www.highload.ru/2016/abstracts/2333.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">news from the world of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nginx.</font></font><br><br></font>  <font color="gray">Also, some of these materials are used by us in an online training course on the development of high-load systems <a href="http://highload.guide/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad.Guide</a> is a chain of specially selected letters, articles, materials, videos.</font>  <font color="gray">Already, in our textbook more than 30 unique materials.</font>  <font color="gray">Get connected!</font> <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/313666/">https://habr.com/ru/post/313666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313654/index.html">Implementing the undo / redo model for a complex document</a></li>
<li><a href="../313656/index.html">UX / UI track program at MBLTdev 16 conference</a></li>
<li><a href="../313658/index.html">Node.js 7.0.0 is released. Meet async / await without babel</a></li>
<li><a href="../313660/index.html">Experience of installing Apple iBeacon & Google Physical Web beacons in the Semenovsky shopping mall in Moscow</a></li>
<li><a href="../313664/index.html">Mobile traffic arbitration: methods and approaches</a></li>
<li><a href="../313668/index.html">How to write in English scientific articles in journals and applications for grants</a></li>
<li><a href="../313670/index.html">Go for the record: Chromium fifth check</a></li>
<li><a href="../313672/index.html">Lord of storage</a></li>
<li><a href="../313674/index.html">Secrets of Progressive Web Apps: Part 2</a></li>
<li><a href="../313676/index.html">Determine the user's location by IP and create a hit counter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>