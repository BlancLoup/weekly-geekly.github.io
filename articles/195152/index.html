<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Linux pipes tips & tricks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pipe - what is it? 
 Pipe is a unidirectional interprocess communication channel. The term was coined by Douglas McIlroy for the Unix command shell an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Linux pipes tips & tricks</h1><div class="post__text post__text-html js-mediator-article"><h4>  Pipe - what is it? </h4><br>  Pipe is a unidirectional interprocess communication channel.  The term was coined by <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D0%25BA%25D0%25B8%25D0%25BB%25D1%2580%25D0%25BE%25D0%25B9,_%25D0%2594%25D1%2583%25D0%25B3%25D0%25BB%25D0%25B0%25D1%2581">Douglas McIlroy</a> for the Unix command shell and is named after the pipeline.  Conveyors are most often used in shell scripts to connect several commands by redirecting the output of one command (stdout) to the input (stdin) of a subsequent command, using the conveyor symbol '|': <br><pre><code class="bash hljs">cmd1 | cmd2 | .... | cmdN</code> </pre> <br>  For example: <br><pre> <code class="bash hljs">$ grep -i ‚Äúerror‚Äù ./<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> | wc -l 43</code> </pre><br>  grep performs a case-insensitive search for the string ‚Äúerror‚Äù in the log file, but the search result is not displayed on the screen, but redirected to the input (stdin) of the wc command, which in turn calculates the number of lines. <br><br><h4>  Logics </h4><br>  Conveyor provides asynchronous command execution using I / O buffering.  Thus, all the commands in the pipeline are working in parallel, each in its own process. <br><br>  The buffer size starting with kernel 2.6.11 is 65536 bytes (64Kb) and is equal to the memory page in older kernels.  When trying to read from an empty buffer, the reading process is blocked until data is displayed.  Similarly, if you attempt to write to the filled buffer, the recording process will be blocked until the required space is freed. <br>  It is important that despite the fact that the pipeline operates with file descriptors for I / O streams, all operations are performed in memory, without any load on the disk. <br>  All the information below relates to the bash-4.2 shell and the kernel 3.10.10. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Simple debag </h4><br>  The strace utility allows you to track system calls during program execution: <br><pre> <code class="bash hljs">$ strace -f bash -c <span class="hljs-string"><span class="hljs-string">'/bin/echo foo | grep bar'</span></span> .... getpid() = 13726 &lt;‚Äì PID   ... pipe([3, 4]) &lt;‚Äì      .... <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span>(....) = 13727 &lt;‚Äì      (<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span>) ... [pid 13727] execve(<span class="hljs-string"><span class="hljs-string">"/bin/echo"</span></span>, [<span class="hljs-string"><span class="hljs-string">"/bin/echo"</span></span>, <span class="hljs-string"><span class="hljs-string">"foo"</span></span>], [/* 61 vars */] ..... [pid 13726] <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span>(....) = 13728 &lt;‚Äì     (grep)      ... [pid 13728] <span class="hljs-built_in"><span class="hljs-built_in">stat</span></span>(<span class="hljs-string"><span class="hljs-string">"/home/aikikode/bin/grep"</span></span>, ...</code> </pre>  It can be seen that the pipe () system call is used to create the pipeline, and also that both processes are executed in parallel in different threads. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Lots of bash source code and kernels</b> <div class="spoiler_text"><h4>  Source code, level 1, shell </h4><br>  Since the best documentation is source code, let's turn to it.  Bash uses Yacc to parse the input commands and returns 'command_connect ()' when it encounters the '|' character. <br>  <a href="">parse.y</a> : <br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1242</span></span> pipeline: pipeline <span class="hljs-string"><span class="hljs-string">'|'</span></span> newline_list pipeline <span class="hljs-number"><span class="hljs-number">1243</span></span> { $$ = command_connect ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'|'</span></span>); } <span class="hljs-number"><span class="hljs-number">1244</span></span> | pipeline BAR_AND newline_list pipeline <span class="hljs-number"><span class="hljs-number">1245</span></span> { <span class="hljs-number"><span class="hljs-number">1246</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Make cmd1 |&amp; cmd2 equivalent to cmd1 2&gt;&amp;1 | cmd2 */</span></span> <span class="hljs-number"><span class="hljs-number">1247</span></span> COMMAND *tc; <span class="hljs-number"><span class="hljs-number">1248</span></span> REDIRECTEE rd, sd; <span class="hljs-number"><span class="hljs-number">1249</span></span> REDIRECT *r; <span class="hljs-number"><span class="hljs-number">1250</span></span> <span class="hljs-number"><span class="hljs-number">1251</span></span> tc = $<span class="hljs-number"><span class="hljs-number">1</span></span>-&gt;type == cm_simple ? (COMMAND *)$<span class="hljs-number"><span class="hljs-number">1</span></span>-&gt;value.Simple : $<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">1252</span></span> sd.dest = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-number"><span class="hljs-number">1253</span></span> rd.dest = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">1254</span></span> r = make_redirection (sd, r_duplicating_output, rd, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-number"><span class="hljs-number">1255</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tc-&gt;redirects) <span class="hljs-number"><span class="hljs-number">1256</span></span> { <span class="hljs-number"><span class="hljs-number">1257</span></span> <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> REDIRECT *t; <span class="hljs-number"><span class="hljs-number">1258</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (t = tc-&gt;redirects; t-&gt;next; t = t-&gt;next) <span class="hljs-number"><span class="hljs-number">1259</span></span> ; <span class="hljs-number"><span class="hljs-number">1260</span></span> t-&gt;next = r; <span class="hljs-number"><span class="hljs-number">1261</span></span> } <span class="hljs-number"><span class="hljs-number">1262</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">1263</span></span> tc-&gt;redirects = r; <span class="hljs-number"><span class="hljs-number">1264</span></span> <span class="hljs-number"><span class="hljs-number">1265</span></span> $$ = command_connect ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'|'</span></span>); <span class="hljs-number"><span class="hljs-number">1266</span></span> } <span class="hljs-number"><span class="hljs-number">1267</span></span> | command <span class="hljs-number"><span class="hljs-number">1268</span></span> { $$ = $<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-number"><span class="hljs-number">1269</span></span> ;</code> </pre>  Also here we see the processing of the pair of characters '| &amp;', which is equivalent to redirection of both stdout and stderr to the pipeline.  Next we turn to command_connect (): <a href="">make_cmd.c</a> : <br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">194</span></span> COMMAND * <span class="hljs-number"><span class="hljs-number">195</span></span> command_connect (com1, com2, connector) <span class="hljs-number"><span class="hljs-number">196</span></span> COMMAND *com1, *com2; <span class="hljs-number"><span class="hljs-number">197</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> connector; <span class="hljs-number"><span class="hljs-number">198</span></span> { <span class="hljs-number"><span class="hljs-number">199</span></span> CONNECTION *temp; <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">201</span></span> temp = (CONNECTION *)xmalloc (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (CONNECTION)); <span class="hljs-number"><span class="hljs-number">202</span></span> temp-&gt;connector = connector; <span class="hljs-number"><span class="hljs-number">203</span></span> temp-&gt;first = com1; <span class="hljs-number"><span class="hljs-number">204</span></span> temp-&gt;second = com2; <span class="hljs-number"><span class="hljs-number">205</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (make_command (cm_connection, (SIMPLE_COM *)temp)); <span class="hljs-number"><span class="hljs-number">206</span></span> }</code> </pre>  where connector is the character '|'  as int.  When executing a sequence of commands (linked by '&amp;', '|', ';', etc.), execute_connection () is called: <a href="">execute_cmd.c</a> : <br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">2325</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'|'</span></span>: ... <span class="hljs-number"><span class="hljs-number">2331</span></span> exec_result = execute_pipeline (command, asynchronous, pipe_in, pipe_out, fds_to_close);</code> </pre><br>  PIPE_IN and PIPE_OUT are file descriptors containing information on the input and output streams.  They can take the value NO_PIPE, which means that the I / O is stdin / stdout. <br>  execute_pipeline () is a rather voluminous function whose implementation is contained in <a href="">execute_cmd.c</a> .  We will consider the most interesting parts for us. <br>  <a href="">execute_cmd.c</a> : <br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">2112</span></span> prev = pipe_in; <span class="hljs-number"><span class="hljs-number">2113</span></span> cmd = command; <span class="hljs-number"><span class="hljs-number">2114</span></span> <span class="hljs-number"><span class="hljs-number">2115</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cmd &amp;&amp; cmd-&gt;type == cm_connection &amp;&amp; <span class="hljs-number"><span class="hljs-number">2116</span></span> cmd-&gt;value.Connection &amp;&amp; cmd-&gt;value.Connection-&gt;connector == <span class="hljs-string"><span class="hljs-string">'|'</span></span>) <span class="hljs-number"><span class="hljs-number">2117</span></span> { <span class="hljs-number"><span class="hljs-number">2118</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-number"><span class="hljs-number">2119</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pipe (fildes) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-number"><span class="hljs-number">2120</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> } ....... <span class="hljs-comment"><span class="hljs-comment">/*     ,      prev ‚Äî   ,     fildes[1] ‚Äî   ,     pipe() */</span></span> <span class="hljs-number"><span class="hljs-number">2178</span></span> execute_command_internal (cmd-&gt;value.Connection-&gt;first, asynchronous, <span class="hljs-number"><span class="hljs-number">2179</span></span> prev, fildes[<span class="hljs-number"><span class="hljs-number">1</span></span>], fd_bitmap); <span class="hljs-number"><span class="hljs-number">2180</span></span> <span class="hljs-number"><span class="hljs-number">2181</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prev &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-number"><span class="hljs-number">2182</span></span> close (prev); <span class="hljs-number"><span class="hljs-number">2183</span></span> <span class="hljs-number"><span class="hljs-number">2184</span></span> prev = fildes[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> <span class="hljs-number"><span class="hljs-number">2185</span></span> close (fildes[<span class="hljs-number"><span class="hljs-number">1</span></span>]); ....... <span class="hljs-number"><span class="hljs-number">2190</span></span> cmd = cmd-&gt;value.Connection-&gt;second; <span class="hljs-comment"><span class="hljs-comment">/* ‚Äú‚Äù      */</span></span> <span class="hljs-number"><span class="hljs-number">2191</span></span> }</code> </pre>  Thus, bash processes the pipeline symbol by system pipe () call for each encountered '|'  and executes each command in a separate process using the appropriate file descriptors as input and output streams. <br><br><h4>  Source Code Level 2 Core </h4><br>  Referring to the kernel code and look at the implementation of the function pipe ().  The article discusses the kernel version 3.10.10 stable. <br>  <a href="">fs / pipe.c</a> (missing code sections for this article): <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*       .       /proc/sys/fs/pipe-max-size */</span></span> <span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pipe_max_size = <span class="hljs-number"><span class="hljs-number">1048576</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    ,   POSIX     , .. 4 */</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pipe_min_size = PAGE_SIZE; <span class="hljs-number"><span class="hljs-number">869</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_pipe_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct file **res, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags)</span></span></span><span class="hljs-function"> 870 </span></span>{ <span class="hljs-number"><span class="hljs-number">871</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err; <span class="hljs-number"><span class="hljs-number">872</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inode</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inode</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_pipe_inode</span></span></span><span class="hljs-class">();</span></span> <span class="hljs-number"><span class="hljs-number">873</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-number"><span class="hljs-number">874</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-number"><span class="hljs-number">875</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">qstr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class"> = {</span></span>. name = ‚Äú‚Äù }; <span class="hljs-comment"><span class="hljs-comment">/*  dentry  dcache */</span></span> <span class="hljs-number"><span class="hljs-number">881</span></span> path.dentry = d_alloc_pseudo(pipe_mnt-&gt;mnt_sb, &amp;name); <span class="hljs-comment"><span class="hljs-comment">/*     file.    FMODE_WRITE,     O_WRONLY, ..             .   O_NONBLOCK   . */</span></span> <span class="hljs-number"><span class="hljs-number">889</span></span> f = alloc_file(&amp;path, FMODE_WRITE, &amp;pipefifo_fops); <span class="hljs-number"><span class="hljs-number">893</span></span> f-&gt;f_flags = O_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT)); <span class="hljs-comment"><span class="hljs-comment">/*      file   (. FMODE_READ   O_RDONLY) */</span></span> <span class="hljs-number"><span class="hljs-number">896</span></span> res[<span class="hljs-number"><span class="hljs-number">0</span></span>] = alloc_file(&amp;path, FMODE_READ, &amp;pipefifo_fops); <span class="hljs-number"><span class="hljs-number">902</span></span> res[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;f_flags = O_RDONLY | (flags &amp; O_NONBLOCK); <span class="hljs-number"><span class="hljs-number">903</span></span> res[<span class="hljs-number"><span class="hljs-number">1</span></span>] = f; <span class="hljs-number"><span class="hljs-number">904</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">917</span></span> } <span class="hljs-number"><span class="hljs-number">918</span></span> <span class="hljs-number"><span class="hljs-number">919</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __do_pipe_flags(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *fd, struct file **files, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> flags) <span class="hljs-number"><span class="hljs-number">920</span></span> { <span class="hljs-number"><span class="hljs-number">921</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> error; <span class="hljs-number"><span class="hljs-number">922</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fdw, fdr; <span class="hljs-comment"><span class="hljs-comment">/*   file     (.  ) */</span></span> <span class="hljs-number"><span class="hljs-number">927</span></span> error = create_pipe_files(files, flags); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-number"><span class="hljs-number">931</span></span> fdr = get_unused_fd_flags(flags); <span class="hljs-number"><span class="hljs-number">936</span></span> fdw = get_unused_fd_flags(flags); <span class="hljs-number"><span class="hljs-number">941</span></span> audit_fd_pair(fdr, fdw); <span class="hljs-number"><span class="hljs-number">942</span></span> fd[<span class="hljs-number"><span class="hljs-number">0</span></span>] = fdr; <span class="hljs-number"><span class="hljs-number">943</span></span> fd[<span class="hljs-number"><span class="hljs-number">1</span></span>] = fdw; <span class="hljs-number"><span class="hljs-number">944</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">952</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*    int pipe2(int pipefd[2], int flags)... */</span></span> <span class="hljs-number"><span class="hljs-number">969</span></span> SYSCALL_DEFINE2(pipe2, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __user *, fildes, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, flags) <span class="hljs-number"><span class="hljs-number">970</span></span> { <span class="hljs-number"><span class="hljs-number">971</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">files</span></span></span><span class="hljs-class">[2];</span></span> <span class="hljs-number"><span class="hljs-number">972</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*    /     */</span></span> <span class="hljs-number"><span class="hljs-number">975</span></span> __do_pipe_flags(fd, files, flags); <span class="hljs-comment"><span class="hljs-comment">/*     kernel space  user space */</span></span> <span class="hljs-number"><span class="hljs-number">977</span></span> copy_to_user(fildes, fd, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fd)); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-number"><span class="hljs-number">984</span></span> fd_install(fd[<span class="hljs-number"><span class="hljs-number">0</span></span>], files[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-number"><span class="hljs-number">985</span></span> fd_install(fd[<span class="hljs-number"><span class="hljs-number">1</span></span>], files[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-number"><span class="hljs-number">989</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* ... int pipe(int pipefd[2]),        pipe2   ; */</span></span> <span class="hljs-number"><span class="hljs-number">991</span></span> SYSCALL_DEFINE1(pipe, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __user *, fildes) <span class="hljs-number"><span class="hljs-number">992</span></span> { <span class="hljs-number"><span class="hljs-number">993</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sys_pipe2(fildes, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-number"><span class="hljs-number">994</span></span> }</code> </pre>  If you noticed, the code checks for the O_NONBLOCK flag.  It can be set using the F_SETFL operation in fcntl.  He is responsible for the transition to the mode without blocking I / O flows in the pipeline.  In this mode, instead of blocking, the read / write process to the stream will end with errno code EAGAIN. <br><br>  The maximum size of the data block that will be written into the pipeline is equal to one memory page (4Kb) for the arm architecture: <br>  <a href="">arch / arm / include / asm / limits.h</a> : <br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIPE_BUF PAGE_SIZE</span></span></code> </pre>  For kernels&gt; = 2.6.35, you can change the size of the pipeline buffer: <br><pre> <code class="bash hljs">fcntl(fd, F_SETPIPE_SZ, &lt;size&gt;)</code> </pre>  The maximum allowed buffer size, as we saw above, is specified in the / proc / sys / fs / pipe-max-size file. <br></div></div><br><h4>  Tips &amp; trics </h4><br>  In the examples below, we will execute ls on the existing Documents directory and two non-existing files: ./non-existent_file and.  / other_non-existent_file. <br><br><ol><li><h5>  Redirecting both stdout and stderr to pipe </h5><br><pre> <code class="bash hljs">ls -d ./Documents ./non-existent_file ./other_non-existent_file 2&gt;&amp;1 | egrep ‚ÄúDoc|other‚Äù ls: cannot access ./other_non-existent_file: No such file or directory ./Documents</code> </pre>  or you can use the combination of characters '| &amp;' (you can learn about it from the shell documentation (man bash) or from the sources above, where we parsed the Yashc bash parser): <br><pre> <code class="bash hljs">ls -d ./Documents ./non-existent_file ./other_non-existent_file |&amp; egrep ‚ÄúDoc|other‚Äù ls: cannot access ./other_non-existent_file: No such file or directory ./Documents</code> </pre><br></li><li><h5>  Redirect _only_ stderr to pipe </h5><br><pre> <code class="bash hljs">$ ls -d ./Documents ./non-existent_file ./other_non-existent_file 2&gt;&amp;1 &gt;/dev/null | egrep ‚ÄúDoc|other‚Äù ls: cannot access ./other_non-existent_file: No such file or directory</code> </pre>  <i><b>Shoot yourself in the foot</b></i> <i><br></i>  <i>It is important to follow the order of redirection stdout and stderr.</i>  <i>For example, the combination '&gt; / dev / null 2&gt; &amp; 1 ‚Ä≤ will redirect both stdout and stderr to / dev / null.</i> <br><br></li><li><h5>  Getting the correct pipeline completion code </h5><br>  By default, the pipeline completion code is the code for the completion of the last command in the pipeline.  For example, take the original command, which ends with a non-zero code: <br><pre> <code class="bash hljs">$ ls -d ./non-existent_file 2&gt;/dev/null; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $? 2</code> </pre>  And put it in the pipe: <br><pre> <code class="bash hljs">$ ls -d ./non-existent_file 2&gt;/dev/null | wc; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $? 0 0 0 0</code> </pre>  Now the pipeline completion code is the wc command completion code, i.e.  0 <br><br>  Usually we need to know if an error occurred during the execution of the pipeline.  To do this, set the pipefail option, which indicates to the shell that the pipeline completion code will match the first nonzero code for the completion of one of the pipeline commands, or zero if all the commands completed correctly: <br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -o pipefail $ ls -d ./non-existent_file 2&gt;/dev/null | wc; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $? 0 0 0 2</code> </pre>  <i><b>Shoot yourself in the foot</b></i> <i><br></i>  <i>Keep in mind the ‚Äúharmless‚Äù commands that can return non-zero.</i>  <i>This applies not only to work with conveyors.</i>  <i>For example, consider an example with grep:</i> <i><br></i> <pre> <code class="bash hljs">$ egrep ‚Äú^foo=[0-9]+‚Äù ./config | awk <span class="hljs-string"><span class="hljs-string">'{print ‚Äúnew_‚Äù$0;}'</span></span></code> </pre>  Here we print all the found lines, assigning 'new_' at the beginning of each line, or we do not print anything if there is not a single line of the required format.  The problem is that grep completes with code 1, if no matches were found, so if the pipefail option is set in our script, this example will end with code 1: <br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -o pipefail $ egrep ‚Äú^foo=[0-9]+‚Äù ./config | awk <span class="hljs-string"><span class="hljs-string">'{print ‚Äúnew_‚Äù$0;}'</span></span> &gt;/dev/null; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $? 1</code> </pre>  In large scripts with complex constructions and long conveyors, this moment can be overlooked, which can lead to incorrect results. <br><br></li><li><h5>  Assigning values ‚Äã‚Äãto variables in the pipeline </h5><br>  To begin with, remember that all the commands in the pipeline are executed in separate processes received by the clone () call.  As a rule, this does not create problems, except in cases of changing the values ‚Äã‚Äãof variables. <br>  Consider the following example: <br><pre> <code class="bash hljs">$ a=aaa $ b=bbb $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> ‚Äúone two‚Äù | <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> ab</code> </pre>  We now expect that the values ‚Äã‚Äãof the variables a and b will be ‚Äúone‚Äù and ‚Äútwo‚Äù, respectively.  In fact, they will remain ‚Äúaaa‚Äù and ‚Äúbbb‚Äù.  In general, any change in the values ‚Äã‚Äãof variables in the pipeline outside of it will leave the variables unchanged: <br><pre> <code class="bash hljs">$ filefound=0 $ find . -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> f -size +100k | <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> f <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> ‚Äú<span class="hljs-variable"><span class="hljs-variable">$f</span></span> is over 100KB‚Äù filefound=1 <span class="hljs-built_in"><span class="hljs-built_in">break</span></span> <span class="hljs-comment"><span class="hljs-comment">#      done $ echo $filefound;</span></span></code> </pre>  Even if find finds a file larger than 100Kb, the filefound flag will still have the value 0. <br>  There are several solutions to this problem: <br><ul><li>  use <pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -- <span class="hljs-variable"><span class="hljs-variable">$var</span></span></code> </pre><br>  This construct will set the positional variables according to the contents of the var variable.  For example, as in the first example above: <br><pre> <code class="bash hljs">$ var=‚Äùone two‚Äù $ <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -- <span class="hljs-variable"><span class="hljs-variable">$var</span></span> $ a=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-comment"><span class="hljs-comment"># ‚Äúone‚Äù $ b=$2 # ‚Äútwo‚Äù</span></span></code> </pre>  It should be borne in mind that the script will lose the original positional parameters with which it was called. </li><li>  transfer all the logic of processing the value of a variable to the same subprocess in the pipeline: <br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> ‚Äúone‚Äù | (<span class="hljs-built_in"><span class="hljs-built_in">read</span></span> a; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$a</span></span>;) one</code> </pre></li><li>  change the logic to avoid assigning variables inside the pipeline. <br>  For example, change our example with find: <br><pre> <code class="bash hljs">$ filefound=0 $ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $(find . -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> f -size +100k) <span class="hljs-comment"><span class="hljs-comment">#   ,     do read f echo ‚Äú$f is over 100KB‚Äù filefound=1 break done $ echo $filefound;</span></span></code> </pre></li><li>  (only for bash-4.2 and newer) use the lastpipe option <br>  The lastpipe option instructs the shell to execute the last pipeline command in the main process. <br><pre> <code class="bash hljs">$ (<span class="hljs-built_in"><span class="hljs-built_in">shopt</span></span> -s lastpipe; a=‚Äùaaa‚Äù; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> ‚Äúone‚Äù | <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> a; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$a</span></span>) one</code> </pre>  It is important that in the command line it is necessary to set the lastpipe option in the same process where the corresponding pipeline will be called, therefore the brackets in the example above are required.  Brackets are optional in scripts. </li></ul></li></ol><br><h4>  Additional Information </h4><br><ul><li>  A detailed description of the syntax of the <a href="http://linux.die.net/man/1/bash">pipeline</a> : <a href="http://linux.die.net/man/1/bash">linux.die.net/man/1/bash</a> (Pipelines section), or 'man bash' in the terminal. </li><li>  logic of the <a href="http://linux.die.net/man/7/pipe">conveyor</a> : <a href="http://linux.die.net/man/7/pipe">linux.die.net/man/7/pipe</a> or 'man 7 pipe' </li><li>  bash shell source code: <a href="http://ftp.gnu.org/gnu/bash/">ftp.gnu.org/gnu/bash</a> , repository: <a href="">git.savannah.gnu.org/cgit/bash.git</a> </li><li>  Linux kernel: <a href="https://www.kernel.org/">www.kernel.org</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/195152/">https://habr.com/ru/post/195152/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../195140/index.html">Adding Admob to Unity3d and withdrawing money from PayPal to a bank account in Russia</a></li>
<li><a href="../195142/index.html">Random Cat Generator in 8 Steps</a></li>
<li><a href="../195146/index.html">Evaluation of linear regression results</a></li>
<li><a href="../195148/index.html">GCC and Variable-Length Arrays</a></li>
<li><a href="../195150/index.html">Debian: create packages for a narrow range of systems</a></li>
<li><a href="../195154/index.html">Primitive game design. Turn-based card game development</a></li>
<li><a href="../195158/index.html">Pirates vs. copyright holders: insider view</a></li>
<li><a href="../195160/index.html">Document generation based on ODT templates. ODT to PDF</a></li>
<li><a href="../195164/index.html">Russian Code Cup 2013: parse the tasks of the final</a></li>
<li><a href="../195168/index.html">AlterWiki - quick search on Russian wiki projects</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>