<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Monadic Parser Combinator in Nemerle</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently discovered a wonderful article Monadic Parser Combinator about creating parsers. The basic idea is to describe the parser as an object of the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Monadic Parser Combinator in Nemerle</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/818/556/1a5/8185561a578af6e66387c600b3f27904.jpg" align="left">  Recently discovered a wonderful article <a href="http://citeseerx.ist.psu.edu/viewdoc/summary%3Fdoi%3D10.1.1.2.4159">Monadic Parser Combinator</a> about creating parsers.  The basic idea is to describe the parser as an object of the first class, so that you can decompose the original problem and present the desired parser as a synthesis of simpler parsers.  To facilitate the combination of parsers, the replace error with list of success approach is used.  In the haskell language it is very convenient to work with the creation of parsers, since this task naturally falls on the concept of monads, unfortunately in nemerle monads are not supported, but the language is still powerful enough to cope with this task. <br><br><a name="habracut"></a>  A parser can be presented in more detail as a mapping from a string to a list of tuples, where the first element of the tuple is the disassembled part of the line, and the second element is the rest of the line.  In case of unsuccessful parsing, an empty list is returned.  In different cases, what I called the parsed part of the string can have a different type, so it is natural to consider the type of the parser as polymorphic, for example, <font color="#0000ff">string</font> -&gt; <font color="#0000ff">list</font> ['a * <font color="#0000ff">string</font> ].  Below this structure will be denoted as a parser ['a]. <br><br>  Next you need to consider a combination of parsers.  Suppose you need to parse and calculate ‚Äúsin42‚Äù, and we already have a parser that can parse mathematical functions ‚Äî math: parser [ <font color="#0000ff">double</font> -&gt; <font color="#0000ff">double</font> ], and a parser that can parse numbers ‚Äî number: parser [ <font color="#0000ff">double</font> ] (through: the type of parsers is described ). <br>  The desired parser can be written as follows: <br><blockquote>  <font color="#0000ff">def</font> eval = text =&gt; math (text) .Map ((f, rest) =&gt; number (rest) .Map ((a, b) =&gt; (f (a), b))). Fold ([], (e, acc) =&gt; e + acc) </blockquote><br>  It turned out quite capacious, but only a red-eyed fan of FP can agree that this is a beautiful code.  Below I will define an operator on parsers and this code can be rewritten as follows: <br><blockquote>  <font color="#0000ff">def</font> eval = math * (f =&gt; number * (x =&gt; <font color="#2B91AF">result</font> (f (x)))) </blockquote><br>  In simple terms, the action of the '*' operator can be described as the creation of a new parser, which acts as follows: the first parser is applied, then the second parser parametrizes the disassembled result of the first and continues parsing.  At the input, the '*' operator has a parser ['a] and a function that performs parameterization, such as the' a-&gt; parser ['b]. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Below, for an example of the simplicity and power of this approach, I have written a parser that checks the correctness of arithmetic expressions consisting of positive numbers, parentheses and the "+" operation.  The code is written in nemerle, but I will try to comment on the syntax, try to understand the semantics themselves, but be careful - do not break the brain!  And do not be afraid of the size of the code, since half of it can be moved to a separate library to create parsers, in the case of haskell the library based on this approach is parsec.  Go! <br><blockquote><code><font color="#0000ff">using</font> System; <br> <font color="#0000ff">using</font> System. <font color="#2B91AF">Console</font> ;</code> </blockquote>  I connect the necessary namespaces and open the System.Console class - from now on all its static methods become global functions / procedures.  About the module, functional types instead of delegates, the lack of new before calling the constructor and the description of the constructor through the word this, I probably wrote before.  I note now only that generic parameters in nemerle are set through square brackets, and not through angular ones, that the type name may contain apostrophes and that in the nonmert it is considered good form to give names to generic parameters starting with an apostrophe. <br><blockquote> <code><font color="#0000ff">module</font> <font color="#2B91AF">Program</font> <br> { <br> <font color="#0000ff">class</font> <font color="#2B91AF">Parser</font> ['a] <br> { <br> <font color="#0000ff">public this</font> (core : string -&gt; <font color="#0000ff">list</font> ['a* <font color="#0000ff">string</font> ]) { <font color="#0000ff">this</font> .core = core } <br> core : <font color="#0000ff">string</font> -&gt; <font color="#0000ff">list</font> ['a* <font color="#0000ff">string</font> ];</code> </blockquote> <br>  The type of the tuple, in which the first element is of type int, and the second string, is written in nemerle as int * string, the tuple itself, if it has not written about it yet, is written, for example: <font color="#0000ff">def</font> tuple = (45, ‚Äúqwerty‚Äù).  Now, I hope, the entry list ['a * string] is clear. <br><blockquote> <code><font color="#0000ff">public</font> Parse(text : <font color="#0000ff">string</font> ) : <font color="#0000ff">list</font> ['a* <font color="#0000ff">string</font> ] { core(text) } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> @*['b](self : <font color="#2B91AF">Parser</font> ['a], parser : 'a-&gt; <font color="#2B91AF">Parser</font> ['b]) : <font color="#2B91AF">Parser</font> ['b] <br> { <br> <font color="#2B91AF">Parser</font> ( <font color="#0000ff">fun</font> (text : <font color="#0000ff">string</font> ) : list['b* <font color="#0000ff">string</font> ] <br> { <br> <font color="#0000ff">def</font> data = self.Parse(text); <br> data.Map((ast,rest) =&gt; parser(ast).Parse(rest)).FoldRight([], (e,acc) =&gt; e+acc) <br> }) <br> } <br></code> </blockquote><br>  @ * is not a mate, as my friend thought, but a synonym for operator * in C #.  Another syntactic feature that you have not yet met on this blog is fun.  This is nothing more than a lambda expression, another possible syntax for lambda is the same as the C # syntax, for example, the following code examples are equivalent: fun (x) {x + 1} and x =&gt; x + 1;  Optionally, you can specify the type, for example, fun (x: int): int {x + 1} or x: int =&gt; x + 1. In the case where the lambda can be written in one line, I use the second option, otherwise the first one. <br><blockquote> <code><font color="#0000ff">public</font> <font color="#0000ff">static</font> @+(a : <font color="#2B91AF">Parser</font> ['a], b : <font color="#2B91AF">Parser</font> ['a]) : <font color="#2B91AF">Parser</font> ['a] <br> { <br> <font color="#2B91AF">Parser</font> (text =&gt; a.Parse(text) + b.Parse(text) ) <br> } <br> } <br></code> </blockquote><br>  In nemerle, operation + for lists is defined, in the code above it was used inside the lambda body. <br><blockquote> <code><font color="#0000ff">class</font> <font color="#2B91AF">zero</font> ['a] : <font color="#2B91AF">Parser</font> ['a] { <font color="#0000ff">public</font> <font color="#0000ff">this</font> () { <font color="#0000ff">base</font> (x=&gt;[]) } } <br> <br> <font color="#0000ff">class</font> <font color="#2B91AF">result</font> ['a] : <font color="#2B91AF">Parser</font> ['a] <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">this</font> (value : 'a) { <font color="#0000ff">base</font> (text =&gt; [(value,text)]) } <br> } <br></code> </blockquote><br>  In Nemer, as in the Java language, the call to the base class constructor occurs inside the subclass constructor.  The two classes that I defined are fundamental parsers, and many other parsers and parser generators are built on their basis.  The result class can be compared with the monad constructor in haskell.  I called the parser generator a function that returns a parser, for example, the symbol (x: char) generator is defined below: Parser [char], which creates a parser waiting for the specified symbol at the beginning of the parse line. <br><br>  Below I define three parser combinators.  Since all this code is written inside a module, which is a static class, I can easily declare static methods of this class (the static keyword is not needed in this case, since it is a module) and use them as global functions.  I called the parser combinator a function that accepts a parser or parsers at the input, and returns a parser at the output.  The trivial combinator is the identical function, but it is not interesting, so I defined the combinators many, many1 and oneOf.  The first repeats a parser that has an input, as long as the line it parses it allows (analog * in regular expressions), the second is an analog of + in a regular expression, and the third tries to apply successively the parsers passed to it until one of them won't parse part of the string successfully. <br><blockquote> <code>many['a] (parser : <font color="#2B91AF">Parser</font> ['a]) : <font color="#2B91AF">Parser</font> [ <font color="#0000ff">list</font> ['a]] <br> { <br> parser * (x =&gt; many(parser) * (xs =&gt; <font color="#2B91AF">result</font> (x::xs))) + <font color="#2B91AF">result</font> ([]) <br> } <br> <br> many1['a] (parser : <font color="#2B91AF">Parser</font> ['a]) : <font color="#2B91AF">Parser</font> [ <font color="#0000ff">list</font> ['a]] <br> { <br> parser * (x =&gt; many(parser) * (xs =&gt; <font color="#2B91AF">result</font> (x::xs))) <br> } <br> <br> oneOf['a] ( <font color="#0000ff">params</font> parsers : <font color="#0000ff">array</font> [ <font color="#2B91AF">Parser</font> ['a]]) : <font color="#2B91AF">Parser</font> ['a] <br> { <br> <font color="#2B91AF">Parser</font> ( <font color="#0000ff">fun</font> (text){ <br> parsers.FoldLeft([], <font color="#0000ff">fun</font> (e,acc) <br> { <br> | (_, []) =&gt; e.Parse(text) <br> | (_, _) =&gt; acc <br> }) <br> }) <br> } <br></code> </blockquote><br>  In the last generator, the abbreviated syntax for pattern matching is used in the body of the lambda expression.  It can be used in the case when the function arguments are involved in pattern matching and the function body consists of a single pattern matching expression.  I will give the equivalent code examples: <font color="#0000ff">def</font> foo (x) { <font color="#0000ff">match</font> (x) {|  [] =&gt; ‚ÄúEmpty‚Äù |  _ =&gt; "! empty"}} and <font color="#0000ff">def</font> foo (x) {|  [] =&gt; ‚ÄúEmpty‚Äù |  _ =&gt; "! empty"}. <br><br><h5>  Attention! </h5><br>  Below is the already significant code that creates the checking parser.  All the code before this can be transferred to the library, since it is the most generalized and not tied to a specific parser. <br><blockquote> <code>Main() : <font color="#0000ff">void</font> <br> { <br> <font color="#0000ff">def</font> item = Parser(x =&gt; <font color="#0000ff">if</font> (x.Length==0) [] <font color="#0000ff">else</font> [(x[0],x.Substring(1))] ); <br> <font color="#0000ff">def</font> sat(predicate) { item * (x =&gt; <font color="#0000ff">if</font> (predicate(x)) <font color="#2B91AF">result</font> (x) <font color="#0000ff">else</font> <font color="#2B91AF">zero</font> ()) } <br> <font color="#0000ff">def</font> symbol(x : char) { sat(y =&gt; x==y) } <br> <font color="#0000ff">def</font> digit = sat(x =&gt; <font color="#A31515">'0'</font> &lt;= x &amp;&amp; x &lt;= <font color="#A31515">'9'</font> ); <br> <font color="#0000ff">def</font> number = many1(digit); <br> <br> <font color="#0000ff">def</font> expr() <br> { <br> <font color="#0000ff">def</font> parentheses = <br> symbol( <font color="#A31515">'('</font> ) * (_ =&gt; <br> expr() * ( _=&gt; <br> symbol( <font color="#A31515">')'</font> ) * (_ =&gt; <font color="#2B91AF">result</font> ([])) <br> ) <br> ); <br> <br> <font color="#0000ff">def</font> trivial = oneOf(number, parentheses); <br> <br> <font color="#0000ff">def</font> mul = <br> trivial * ( _ =&gt; <br> many1(symbol( <font color="#A31515">'*'</font> ) * ( _ =&gt; trivial)) * (_ =&gt; <font color="#2B91AF">result</font> ([])) <br> ); <br> <br> <font color="#0000ff">def</font> sarg = oneOf(mul, trivial); <br> <br> <font color="#0000ff">def</font> sum = <br> sarg * ( _ =&gt; <br> many1(symbol( <font color="#A31515">'+'</font> ) * ( _ =&gt; sarg)) * (_ =&gt; result([])) <br> ); <br> <br> oneOf(sum,mul,trivial) <br> } <br> <br> WriteLine(expr().Parse( <font color="#A31515">"5+42*(8+1)"</font> )); <br> _ = ReadLine(); <br> } <br> }</code> </blockquote> <br>  This code should be clear (syntactically), the only thing I missed, it did not explain what the word def does.  This word comes from the English define what it means to declare.  This is exactly what it does: it allows you to give a name to a value and declare local functions (relative to the class method and other local functions).  The first is similar to the behavior of the word var in the C # language, only in the German it is impossible to change the meaning of the name, it is easier to understand it by example: <br><blockquote>  <font color="#0000ff">def</font> x = 1;  // right <br>  x = x + 1;  // compile error <br>  <font color="#0000ff">def</font> x = x + 1;  // compilation was successful <br>  <font color="#0000ff">mutable</font> y = 1;  // mutable - full analogue of var in the C # language <br>  y = y +1;  // all is well. <br></blockquote><br>  Another note to the parser code: expr is declared as a local function, since its description refers to itself. <br><br>  PS I hope I was able to adequately retell the ideas of the article and better acquaint the readers with the nemerle language. <br><br> <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img src="https://habrastorage.org/getpro/habr/post_images/b19/f14/bf8/b19f14bf830a4eecadc0e9ecab09618b.png" alt="cc-by-nc-sa"></a> </div><p>Source: <a href="https://habr.com/ru/post/50859/">https://habr.com/ru/post/50859/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../50854/index.html">Sync Firefox with Dropbox.</a></li>
<li><a href="../50855/index.html">The Beginning of a Scientific Career (Part 4)</a></li>
<li><a href="../50856/index.html">Masquerade Ball "Karnavaliya" 2009</a></li>
<li><a href="../50857/index.html">Stimulus to study well - Medvedev proposed to transfer the best students to free places</a></li>
<li><a href="../50858/index.html">Security</a></li>
<li><a href="../50860/index.html">Battle for the project</a></li>
<li><a href="../50862/index.html">TV "cinema" format</a></li>
<li><a href="../50866/index.html">The second beta of Windows 7 will not. Will RC</a></li>
<li><a href="../50867/index.html">The first laptop on the Intel Core i7</a></li>
<li><a href="../50868/index.html">Top Startup Augusta. Six months later.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>