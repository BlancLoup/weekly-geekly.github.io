<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>From API first on Swagger to Single contract on RAML</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi% username%! 

 You probably know what API interfaces are and how much depends on them in your project. Moreover, I also believe that you are alread...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>From API first on Swagger to Single contract on RAML</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/cj/pv/it/cjpvit3gxuwcyybj7ifn7xzv8gw.png" alt="image"><br><br>  Hi% username%! <br><br>  You probably know what API interfaces are and how much depends on them in your project.  Moreover, I also believe that you are already familiar with the fact that <a href="https://medium.com/adobetech/three-principles-of-api-first-design-fa6666d9f694">API is the first</a> approach and you know that <a href="https://swagger.io/">Swagger</a> and its <a href="https://swagger.io/docs/specification/about/">Open API</a> are among the most popular tools to help it follow. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But in this article I want to tell you about the approach to the implementation of the API first, which is conceptually different from what Swagger and Apiary offers.  At the head of the idea is the concept of <i>Single contract</i> and the possibility of its implementation based on RAML 1.0. <br><br>  Under the cut: <br><br><ul><li>  A brief description of the principles of the API first; </li><li>  <i>Single contract</i> - input of the concept, prerequisites for appearance, consideration of the possibility of its implementation on the basis of OAS (Swagger); </li><li>  RAML + annotations + overlays as a base for <i>Single contract</i> , examples; </li><li>  RAML problems, conceptual differences of developers; </li><li>  The idea of ‚Äã‚Äãa SaaS service based on the above idea (picture of the prototype above). </li></ul><br><br><a name="habracut"></a><br><h2>  From API first on Swagger to Single contract on RAML </h2><br>  When designing modern software systems, it often becomes necessary to coordinate and develop interfaces for the interaction of their components with each other.  In the last decade, SPA and thick mobile applications interacting with the server through API interfaces have gained immense popularity and development.  If earlier the development of an interactive web site was done by phasing the server side code to generate HTML markup and then passing it to the client‚Äôs browser, now the development of dynamic web applications has shifted towards the creation of a single service API and parallel development of many applications (including SPA) running with this API as with the main data source.  This approach allows you to more conveniently separate tasks, organize teams that specialize only in specific technologies (attract more specialized specialists), organize parallel development at the very first stages, and also allows you to create a single point of communication - API interface. <br><br>  Such a single point of communication requires a formal and unambiguous definition, this document is the API specification.  Various technologies and languages ‚Äã‚Äãare used to develop and document API specifications today, for example: OAS (Swagger), Apiary and RAML. <br><br>  The following three items define the nature of the API first approach: <br><br><ol><li>  The API interface must be the very first client interface of the application being developed; </li><li>  First of all, the API specification is developed, and then the software part of its clients; </li><li>  The life stages of an API interface must match the life stages of its documentation. </li></ol><br>  If we consider the process based on the foregoing, then the API specification lies at the center of the development process, and all nodes that make up the system and use this API as an interaction gateway are clients of the API specification.  Thus, the server part of the system can be considered the same API client of the specification, like any other node that uses the API to communicate with it.  Domain domain application models do not have to match the models described in the API specification.  Their possible intentional coincidences with class structures in the code of client applications or database schema structures are introduced rather to simplify the development process, for example, when using a code generator according to the OAS specification.  Logically, the above can be brought under the definition of <i>Single contract</i> .  <i>Single contract</i> - many clients. <br><br><h3>  Single Contract.  Contract Tools and Libraries </h3><br><blockquote>  The term <i>Single contract</i> does not claim any participation in criticism for its use in the text of the article.  Its use, in this context, is my personal idea. </blockquote>  Expanding the notion of <i>API first</i> , to the more general <i>Single contract,</i> allows us to consider the API specification not only as a formal description of the interaction interface between system components, but also as a <i>single contract</i> used by any number of external libraries and tools as a configuration source.  In this case, these tools and libraries can be perceived as clients of the contract along with SPA or mobile applications.  Examples of such clients include: <br><br><ul><li>  Documentation Generator </li><li>  Mock-server API </li><li>  Load Testing Service </li><li>  Request / Response Validation Library </li><li>  Code generator </li><li>  UI interface generator </li><li>  etc. </li></ul><br>  <i>Single contract</i> for such clients is a single configuration file and data source.  Contract tools work only on the basis of information obtained from a particular contract.  Obviously, for a full-fledged functional of such heterogeneous clients as a mock server API, a single API description is not enough, additional meta information is needed, for example, a description of the links between GET request parameters (resource id) and data that the server should return, prompts indicating the response fields and query parameters used to organize pagination.  Further, this example will be discussed in more detail.  Specific information for specific instruments, at the same time, must exist and be maintained inextricably from the main document, otherwise it will lead to a violation of the concept of a single contract. <br><br><h3>  Swagger (OAS) as a Single contract description tool </h3><br>  Swagger (OAS) and Apiary (Blueprint), the most popular on the market, allow you to describe HTTP API interfaces using special languages: Open API based on YAML or JSON, Blueprint based on Markdown, which makes the specifications easy to read.  There are also many tools and libraries created by the large open-source community.  Swagger is currently widely distributed and can be said to have become the de facto API standard first.  Many external systems support importing Swagger specifications, such as <a href="https://www.soapui.org/">SoapUI</a> , <a href="https://readme.io/">Readme.io</a> , <a href="https://apigee.com/">Apigee</a> , etc.  In addition, the existing SaaS <a href="https://app.swaggerhub.com/">Swagger Hub</a> and <a href="https://apiary.io/">Apiary</a> allow users to create projects, upload or create their own specifications, use the built-in documentation generators and mock-servers, as well as publish links to access them from outside. <br><br>  Swagger along with its OAS 3.0 look pretty confident and its functionality to describe the API (especially simple) is enough in most cases.  The following is a list of pros and cons of Swagger: <br><br>  Pros: <br><br><ul><li>  Clear and easy to read description language; </li><li>  Large open-source community; </li><li>  Many official and open-source editors, generators, libraries; </li><li>  Having a core development team constantly working on developing and improving the format; </li><li>  Conditionally free hub for specifications; </li><li>  Detailed official documentation; </li><li>  Low threshold of entry. </li></ul><br>  Minuses: <br><br><ul><li>  Weak modularity support; </li><li>  Absence of autogeneration of sample response requests based on the description of their structures; </li><li>  There are often problems with the poor stability of SmartBear products (the authors of the swagger) and the late reaction of the developer to this (the opinion is based purely on personal experience of use, and on the experience of our team). </li></ul><br>  But the main limitation of not allowing to use OAS as a <i>Single contract</i> description tool is the inability to attach custom meta information for describing additional parameters of target tools / libraries. <br>  Therefore, all tools that work on the basis of Swagger-specifications must be content with the set of information that can accommodate the basic format. <br><br>  For example, the implementation of a smart mock api server requires more information than a specification document is capable of, which is why the built-in Swagger Hub mock API is only capable of generating fake data based on data types / structures obtained from the specification document.  Undoubtedly, this is not enough and such functionality of the mock server can be satisfied only by a simple API client. <br><br>  In our company, during the development of one of the projects (React SPA + API server), the following mock-server functionality was required: <br><br><ul><li>  imitation of pagination.  The server should not return completely random values ‚Äã‚Äãof the currentPage, nextPage, pagesTotal fields in response to list requests, but be able to simulate the actual behavior of the pagination mechanism with generating values ‚Äã‚Äãof these metafields depending on the received page value from the client; </li><li>  generation of response bodies containing different data sets depending on the specific parameter of the incoming request; </li><li>  ability to build real connections between fake objects: the <i>foo_id</i> field of the <i>Bar</i> entity must refer to the previously generated <i>Foo</i> entity.  This can be achieved by adding support for idempotency mock-server; </li><li>  imitation of work of various authorization methods: OAuth2, JWT and so on. </li></ul><br>  Without all this, it is very difficult to develop a SPA in parallel with the development of the server part of the system.  And, at the same time, such a mock server, due to what was described earlier, is almost impossible to implement without additional specific meta information that could be stored directly in the API specification and inform it of the required behavior when simulating the next endpoint.  This problem can be solved by adding the required parameters as a separate file with configurations parallel to the base OAS specification, but in this case, you will need to support these two different sources separately. <br><br>  If there are more than one mock server operating in the environment of the development process according to this principle, we will get a ‚Äúzoo‚Äù of tools, each of which, if it has its own unique functionality, is forced to have its own unique configuration file, logically linked to the base API -specifications, but actually located separately and living ‚Äúits own life‚Äù. <br><br><img src="https://habrastorage.org/webt/-1/2j/nx/-12jnxo_wzra4vl923py0d4hgnk.png" alt="image"><br><br>  Problem: the developer will be forced to keep all configurations up-to-date after changing versions of the base specification, often in completely different places and formats. <br><br>  Some examples of services that work on a similar principle: <br><br><ul><li>  <i><a href="https://www.soapui.org/">SoapUI</a></i> is a system for testing REST &amp; SOAP interfaces.  Supports project import from Swagger-spec.  When the Swagger base specification is changed, the configuration of the draft based on the API call list continues to exist in parallel and requires manual synchronization; </li><li>  Other <a href="https://smartbear.com/product/">SmartBear</a> Products; </li><li>  <i><a href="https://apigee.com/">Apigee</a></i> is an API lifecycle management service.  Uses Swagger-specifications as templates, based on which, allows you to initialize your configuration of internal services.  Automatic synchronization is also missing; </li><li>  <i><a href="https://readme.io/">Readme.io</a></i> is a service that allows you to create beautiful documentation based on the Swagger-specification, and also has a mechanism for tracking changes in the basic specification and resolving conflicts by updating the project configuration on the service side.  Surely, this required the excessive complexity of the development of this service. </li></ul><br>  Many other services can be added to this list that provide the integration function with the Swagger specification.  Integration means for most of them the usual copying of the basic structure of the Swagger-specification and the subsequent auto-completion of the local configuration fields without synchronization with changes in the basic specification. <br><br><h3>  RAML, annotations, overlays </h3><br>  The desire to find a tool that eliminates the previously mentioned OAS restriction, which makes it possible to view the specification as a single contract for all client tools, led us to become familiar with the RAML language.  About RAML is written enough, you can read, for example, <a href="https://www.infoq.com/articles/power-of-raml">https://www.infoq.com/articles/power-of-raml</a> .  RAML developers have tried to lay in the language support for modularity at the level of its concept.  Now each company or individual developer can create their own or use ready-made public dictionaries when designing an API, redefine and inherit ready-made data models.  Starting from version 1.0, RAML supports 5 different types of external modules: <i>include, library, extension, trait, overlay</i> , which allows each of them to be used depending on the task as flexibly as possible. <br><br>  The time has come to discuss the main possibility of RAML, which, for reasons not entirely clear, has no analogues in OAS and Blueprint - Annotations. <br><blockquote>  RAML Annotations is the ability to attach custom metadata to basic language structures. </blockquote>  It is this function RAML and became the reason for writing this article. <br><br>  Example: <br><br><pre><code class="hljs pgsql">#%RAML <span class="hljs-number"><span class="hljs-number">1.0</span></span> title: Example API mediaType: application/<span class="hljs-type"><span class="hljs-type">json</span></span> # Annotation <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> block may be placed <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> file annotationTypes: validation-rules: description: | Describes <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span> validation rules <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the model properties. Can be used <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> validation library allowedTargets: [ TypeDeclaration ] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string[] <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>-tip: description: | Can be used <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> Documentation generator <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> showing tips allowedTargets: [ <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span>, DocumentationItem, TypeDeclaration ] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string condition: description: | Named example can be returned <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> evaluated <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>. Can be used <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> Intelligent mock <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> allowedTargets: [ Example ] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>: Article: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> properties: id: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-type"><span class="hljs-type">integer</span></span> title: string paragraphs: Paragraph[] createdAt: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string (validation-rules): ["regex:/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?Z?/"] Paragraph: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> properties: <span class="hljs-keyword"><span class="hljs-keyword">order</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-type"><span class="hljs-type">integer</span></span> (validation-rules): ["min:0"] content: string (validation-rules): ["max-length:1024"] /articles/{articleId}: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>: (<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>-tip): This endpoint <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> deprecated description: <span class="hljs-keyword"><span class="hljs-keyword">Returns</span></span> Article <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ID responses: <span class="hljs-number"><span class="hljs-number">200</span></span>: body: application/<span class="hljs-type"><span class="hljs-type">json</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Article</code> </pre> <br>  User annotation structures themselves must have clear RAML descriptions.  For this, a special section <i>annotationTypes is used</i> , the definitions from which can also be transferred to an external module.  Thus, it becomes possible to determine the special parameters of an external tool in the form of annotations associated with the basic definition of the RAML API.  In order to avoid cluttering up the base specification with a huge number of annotations for various external tools, there is support for the possibility of their removal into separate files - <i>overlays</i> (as well as possible in <i>extensions</i> ), with a classification by application.  This is what is said about overlays in the documentation for RAML ( <a href="">https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md#overlays</a> ): <br><blockquote>  An overlay adds or overrides the nodes of a RAML API definition while preserving its behavioral, functional aspects.  Definition of the APIs: its resources, methods, parameters, bodies, responses, and so on.  Cannot be changed by applying an overlay.  In contrast, other nodes, such as those that address the functional interface, or  These nodes can be changed by applying an overlay. <br><br>  Overlays are particularly important for separating interface from implementation.  Overlays enable you to be controlled tightly, such as a contracting different paces.  For example, it can be defined as an API.  These things can be controlled through a rigorous version and change management process. </blockquote>  In other words, this functionality allows to ‚Äúseparate the wheat from the chaff,‚Äù for example, the basic description of the API specification, from additional meta-information specific to the specific tool using it for work.  Meta-information in each individual overlay is ‚Äúhung‚Äù on various specification blocks in the form of annotations. <br><br>  An example of a basic structure: <br><br><pre> <code class="hljs pgsql">#%RAML <span class="hljs-number"><span class="hljs-number">1.0</span></span> title: Phrases API mediaType: application/<span class="hljs-type"><span class="hljs-type">json</span></span> <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>: Phrase: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> properties: content: string /phrases: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>: queryParameters: whoSaid: string responses: <span class="hljs-number"><span class="hljs-number">200</span></span>: body: application/<span class="hljs-type"><span class="hljs-type">json</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Phrase</code> </pre><br>  Overlay: <br><pre> <code class="hljs vbscript">#%RAML <span class="hljs-number"><span class="hljs-number">1.0</span></span> Overlay usage: Applies annotations <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Intelligent mock <span class="hljs-built_in"><span class="hljs-built_in">server</span></span> extends: example_for_article_2_1.raml annotationTypes: condition: description: | Named example can be returned <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> evaluated <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> type: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> allowedTargets: Example /phrases: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>: responses: <span class="hljs-number"><span class="hljs-number">200</span></span>: body: application/json: examples: firstExample: (condition): $whoSaid <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Hamlet content: <span class="hljs-string"><span class="hljs-string">"To be, or not to be?"</span></span> secondExample: (condition): $whoSaid <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Homer Simpson content: <span class="hljs-string"><span class="hljs-string">"D'oh!"</span></span></code> </pre><br>  As a result, it becomes possible to implement a single contract: all functional, behavioral and meta information is stored and versioned in one single place, and the contractual tools - the contract clients must have the support of the annotations used in this specification.  On the other hand, it is the tools themselves that can make their own requirements for annotations that need to be ‚Äúhung‚Äù on the specification - this will provide a wider range of possibilities in developing contractual tools. <br><br>  The above concept is shown in the figure below: <br><br><img src="https://habrastorage.org/webt/w1/0i/aj/w10iajxxllknypbvu6gwcvwrtkc.png" alt="image"><br><br>  Among the drawbacks of this approach, one can single out the high complexity of manual synchronization of the base specification file and each of the overlays: when updating the structure of the base specification, it is necessary to apply the required changes in the structures of overlays.  This problem becomes more serious with the appearance of more than one overlay. <br><br>  A possible and most obvious solution would be to develop a special editor or add-on for the existing RAML online editor <a href="https://github.com/mulesoft/api-designer">https://github.com/mulesoft/api-designer</a> .  The editing area remains unchanged, but it becomes possible to create tabs: each new tab is a window for editing the overlay assigned to it.  When editing the base structure of the specification in the main window, the structures in all the created tabs also change, and if an incompatibility of the new structure with already existing annotations found in the tabs overlays is detected, a warning appears.  A more detailed consideration of such an editor is a separate topic and deserves serious consideration. <br><br><h3>  Existing groundwork </h3><br>  In the search for existing solutions that are close to the implementation of the idea of ‚Äã‚Äãusing annotations as a means of describing meta-information, the following solutions were found: <br><br><ul><li>  <a href="https://github.com/raml-org/raml-annotations">https://github.com/raml-org/raml-annotations</a> repository containing official annotations approved by the developer community RAML.  In the current version, only OAuth2 annotations are available.  Can be used by external tools to obtain meta-information describing aspects of the implementation of OAuth2 for the specification being developed by the API; </li><li>  <a href="https://github.com/petrochenko-pavel-a/raml-annotations">https://github.com/petrochenko-pavel-a/raml-annotations</a> <a href="https://github.com/petrochenko-pavel-a">@ petrochenko-pavel-a</a> library of annotations with logical grouping by scopes.  The project is rather experimental, but it perfectly illustrates the idea of ‚Äã‚Äãusing annotations.  The most interesting annotation groups are: <br><ul><li>  <i>additionalValidation.raml</i> - annotations for describing additional rules for the validation of specification models.  For example, they can be used by the server library to validate requests for the RAML specification; </li><li>  <i>mock.raml</i> - annotations for describing the details of how a mock server is based on the RAML specification; </li><li>  <i>semanticContexts.raml</i> ‚Äî annotations indicating the semantic context of individual declared structural blocks of the RAML specification; </li><li>  <i>structural.raml</i> - annotations, clarifying the role of a separate RAML entity in the overall structure of the described domain model; </li><li>  <i>uiCore.raml</i> is an example of annotations that are possible for use by UI generation tools based on the RAML specification; </li></ul></li></ul><br>  The repository also contains libraries of service types suitable for use as primitives when describing data structures of the RAML specification. <br><br><h3>  RAML problems </h3><br>  Despite the functionality, progressiveness of the basic idea, attention from major software vendors (cisco, spotify, vmware, etc.), today RAML has serious problems that can be fatal regarding its successful fate: <br><br><ul><li>  Small and isolated open-source community; </li><li>  The incomprehensible strategy of the main RAML developer is <a href="https://www.mulesoft.com/">mulesoft</a> .  The company develops products that are only a copy of existing OAS-based solutions (included in the <a href="https://anypoint.mulesoft.com/">Anypoint Platform</a> ), instead of creating services that emphasize the advantages of RAML over Swagger; </li><li>  The consequence of the first paragraph: a small number of open-source libraries / tools; </li><li>  A higher threshold of entry than the OAS (this is strange, but many people think so); </li><li>  Due to the large number of bugs and problems with UX / UI, the main service is completely unusable and repulsive to users. The RAML entry point is <a href="https://anypoint.mulesoft.com/">https://anypoint.mulesoft.com/</a> . </li></ul><br><h3>  Conceptual differences.  First conclusion </h3><br>  There are contradictions within the community regarding the basic concept.  Someone thinks that RAML is a <i>model definition language</i> , and someone that this is an <i>API definition language</i> as OAS or Blueprint (guys who call themselves RAML developers often mention this in various comments).  The concept of a <i>model definition language</i> would allow within the RAML specification to describe the domain model of the domain without being strictly tied to the context of the resource API description, thereby expanding the horizons of options for using the specification with external tools (actually creating a foundation for the existence of a real <i>Single Contract</i> !).  This definition of the resource concept can be seen on the readhat docs site ( <a href="http://restful-api-design.readthedocs.io/en/latest/resources.html">http://restful-api-design.readthedocs.io/en/latest/resources.html</a> , by the way, I recommend everyone to read this wonderful API design guide): <br><blockquote>  This is a list of available <b><i>APIs</i></b> .  <i><b>The</b></i> Restored mapping of <b><i>the application data model</i></b> . </blockquote>  In the RAML, the <i><b>application data model</b></i> is the types declared in the <i>types</i> block, and the <b><i>resource model of an API</i></b> is what is described in the <i>resources</i> RAML block.  Therefore, it is necessary to have the possibility of describing this <i><b>mapping</b></i> .  But the current implementation of RAML allows you to make such a <b><i>mapping</i></b> only 1 to 1, that is, use types ‚Äúas is‚Äù inside the declaration of the resource API. <br><br>  I think this is the most important problem of the language, the solution of which will allow RAML to go beyond the <i>API definition language</i> and become a full-fledged <i>model definition language</i> : a more common language (rather than OAS or Blueprint) used to describe single system contracts, which are essentially the formal core sets of their components. <br><br>  The above makes RAML a weak player who is currently unable to win a Swagger competition.  Perhaps that is why, as a result, the main developer of RAML went to cardinal measures <a href="https://blogs.mulesoft.com/dev/api-dev/open-api-raml-better-together/">https://blogs.mulesoft.com/dev/api-dev/open-api-raml-better-together/</a> <br><br><h3>  Idea Single contract RAML SaaS </h3><br>  Based on the concept of <i>Single Contract</i> , building on the hosting idea of ‚Äã‚Äãthe Swagger hub OAS-based API specifications, and also relying on the capabilities of RAML to declare meta-information and to split the base specification using overlays, the idea of ‚Äã‚Äãan alternative SaaS solution for hosting and managing specifications based on the RAML language that is capable of surpass Swagger Hub and Apiary with the volume and quality of possible functionality. <br><br>  The new service, by analogy with Swagger hub, will be hosting user contracts with the provision of an online editor and the possibility of viewing documentation-previews with real-time updates.  The main difference should be the presence of a catalog of contract plug-ins built into the service, any of which the user can install in his current project an API specification.  For installation, you will need to implement the required RAML annotations specified in the plugin documentation.  After adding a new plug-in to the project, a new tab will be added to the code editor window. When you switch to this tab, editing annotations of the installed plug-in will become available.  The structure of the base specification should be automatically duplicated in all tabs corresponding to the plugins.  In the event of conflicts between the basic structure and already existing annotations, a special mechanism should offer options for its solution, or resolve it automatically. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/le/5g/go/le5ggomtfukodgechbdyhugpafq.png" alt="image"></div><br>  Technically, each tab will be an abstraction over RAML overlay containing annotations of each specific plug-in.  This guarantees the compatibility of the specification with any tool that supports RAML 1.0. <br><br>  The plug-in directory must be open to the open source community.  It is also possible to implement paid plug-ins, which can serve as an incentive for developing new ones. <br><br>  Possible plugins: API documentation with support for a large number of annotations for flexible parameterization of its rendering, a smart mock server (from the example above), downloadable libraries for validating requests or code generation, debugging tools for outgoing API requests for mobile applications (caching proxy), load tests with test flow setting through annotations, various plugins for integration with external services. <br><br>  This idea of ‚Äã‚Äãthe service contains clear advantages over existing services for managing API specifications and its implementation lays the beginning of a possible change in the approach to the implementation of any external systems one way or another connected with the API. <br><br><h3>  Second conclusion </h3><br>  The purpose of this article is not to criticize Swagger, Apiary, or other de facto standard API development tools, but rather to consider the conceptual difference c by the design approach of specifications promoted by RAML, an attempt to introduce the concept <i>Contract first</i> and consider the possibility of its implementation on the basis of RAML.  Another goal was the desire to attract to RAML well-deserved attention of developers for the further possible development of its community. <br><br>  <a href="https://raml.org/">RAML official website</a> <br>  <a href="https://raml-api.slack.com/">Slack channel</a> <br>  <a href="">Specification</a> <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/419525/">https://habr.com/ru/post/419525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419509/index.html">Photon Artificial Neural Network</a></li>
<li><a href="../419511/index.html">typeof (T) vs. TypeOf‚ü®T‚ü©</a></li>
<li><a href="../419513/index.html">Setting a password security policy in Zimbra</a></li>
<li><a href="../419519/index.html">Tips for launching a mobile game: Part 1, Soft launch</a></li>
<li><a href="../419523/index.html">PVS-Studio team is open-minded when writing articles</a></li>
<li><a href="../419527/index.html">How the heartbeat sounds: the transfer of a paper cardiogram to WAV-format</a></li>
<li><a href="../419531/index.html">We select the perfect match for your ears: ten practical tips</a></li>
<li><a href="../419535/index.html">Toaster Update</a></li>
<li><a href="../419537/index.html">Cyberdemona: artificial intelligence DOOM 2016</a></li>
<li><a href="../419545/index.html">Material 2.0 for developers. Overview of new components</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>