<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write parsers on javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... namely, how to write LL parsers for not very complex structures by constructing a complex parser from simpler ones. Occasionally there is a need t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write parsers on javascript</h1><div class="post__text post__text-html js-mediator-article">  ... namely, how to write LL parsers for not very complex structures by constructing a complex parser from simpler ones.  Occasionally there is a need to parse something simple, say some XML-like structure or some kind of data URL, and then usually there is either a sheet of tricky difficult-to-read code or dependence on some more complex and tricky parsing library.  Here I am going to combine several well-known ideas (some of them came across on Habr√©) and show how you can simply and concisely write quite complex parsers while doing very few lines of code.  For example, I will write a parser for an XML-like structure.  And yes, I will not insert a picture here to attract attention.  There are no pictures in the article at all, so it will be difficult to read. <br><br><a name="habracut"></a><br><br><h4>  main idea </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It lies in the fact that each piece of input text is parsed by a separate function (let's call it a ‚Äúpattern‚Äù) and by combining these functions you can get more complex functions that can parse more complex texts.  So, a pattern is such an object that has an <i>exec</i> method that performs parsing.  This function is indicated as where from where to parse and it returns parse and the place where the parsing ended: <br><br><pre><code class="hljs perl">var digit = { <span class="hljs-keyword"><span class="hljs-keyword">exec</span></span>: function (str, <span class="hljs-keyword"><span class="hljs-keyword">pos</span></span>) { var <span class="hljs-keyword"><span class="hljs-keyword">chr</span></span> = str.charAt(<span class="hljs-keyword"><span class="hljs-keyword">pos</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">chr</span></span> &gt;= <span class="hljs-string"><span class="hljs-string">"0"</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">chr</span></span> &lt;= <span class="hljs-string"><span class="hljs-string">"9"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { res: +<span class="hljs-keyword"><span class="hljs-keyword">chr</span></span>, end: <span class="hljs-keyword"><span class="hljs-keyword">pos</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>}; } };</code> </pre> <br><br>  Now the digit is a pattern of the digit digit and can be used as follows: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">assert</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.deepEqual</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">digit</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.exec</span></span>("5", 0), { <span class="hljs-attribute"><span class="hljs-attribute">res</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, end: <span class="hljs-number"><span class="hljs-number">1</span></span> }); <span class="hljs-selector-tag"><span class="hljs-selector-tag">assert</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.deepEqual</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">digit</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.exec</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">Q</span></span>", 0), <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> 0);</code> </pre><br><br>  Why such an interface?  Because in JS there is a built-in class RegExp with a very similar interface.  For convenience, we introduce the Pattern class (look at it as an analogue of RegExp) whose instances will be these patterns: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pattern</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(exec)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.exec = exec; }</code> </pre><br><br>  Then we will introduce some simple patterns that will be useful practically in a more or less complex parser. <br><br><h4>  Simple patterns </h4><br><br>  The simplest pattern is txt - it parses a fixed, predetermined string of text: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">txt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str, pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str.substr(pos, text.length) == text) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: text, <span class="hljs-attr"><span class="hljs-attr">end</span></span>: pos + text.length }; }); }</code> </pre><br><br>  It is applied like this: <br><br><pre> <code class="javascript hljs">assert.deepEqual(txt(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>).exec(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: <span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }); assert.deepEqual(txt(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>).exec(<span class="hljs-string"><span class="hljs-string">"def"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><br>  If there were default constructors in JS (as in C ++), then the txt (‚Äúabc‚Äù) record could be reduced to ‚Äúabc‚Äù in the context of constructing a more complex pattern. <br><br>  Then we introduce its analogue for regular expressions and call it rgx: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rgx</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">regexp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str, pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = regexp.exec(str.slice(pos)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &amp;&amp; m.index === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: m[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-attr"><span class="hljs-attr">end</span></span>: pos + m[<span class="hljs-number"><span class="hljs-number">0</span></span>].length }; }); }</code> </pre><br><br>  Apply it like this: <br><br><pre> <code class="javascript hljs">assert.deepEqual(rgx(<span class="hljs-regexp"><span class="hljs-regexp">/\d+/</span></span>).exec(<span class="hljs-string"><span class="hljs-string">"123"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: <span class="hljs-string"><span class="hljs-string">"123"</span></span>, <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }); assert.deepEqual(rgx(<span class="hljs-regexp"><span class="hljs-regexp">/\d+/</span></span>).exec(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><br>  Again, if the default constructors were in JS, then the rgx (/ abc /) entry could be reduced to / abc /. <br><br><h4>  Combinators Patterns </h4><br><br>  Now you need to enter a few patterns that combine existing patterns.  The simplest of such ‚Äúcombinators‚Äù is opt - it makes any pattern optional, i.e.  if the source pattern p cannot parse the text, then opt (p) on the same text will say that everything has parsed, only the result of parsing is empty: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pattern</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str, pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pattern.exec(str, pos) || { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">end</span></span>: pos }; }); }</code> </pre><br><br>  Usage example: <br><br><pre> <code class="javascript hljs">assert.deepEqual(opt(txt(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>)).exec(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>), { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: <span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }); assert.deepEqual(opt(txt(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>)).exec(<span class="hljs-string"><span class="hljs-string">"123"</span></span>), { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> });</code> </pre><br><br>  If operator overload and default constructors were possible in JS, then the opt (p) record could be reduced to p ||  void 0 (this is clearly seen from how opt is implemented). <br><br>  The next most complex combinator is exc - it only parses what the first pattern can parse and cannot parse the second one: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pattern, except</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str, pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !except.exec(str, pos) &amp;&amp; pattern.exec(str, pos); }); }</code> </pre><br><br>  If W (p) is a set of texts that parses the pattern p, then W (exc (p, q)) = W (p) \ W (q).  This is useful for example when you need to parse all large letters except the letter H: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = exc(rgx(<span class="hljs-regexp"><span class="hljs-regexp">/[AZ]/</span></span>), txt(<span class="hljs-string"><span class="hljs-string">"H"</span></span>)); assert.deepEqual(p.exec(<span class="hljs-string"><span class="hljs-string">"R"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: <span class="hljs-string"><span class="hljs-string">"R"</span></span>, <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }); assert.deepEqual(p.exec(<span class="hljs-string"><span class="hljs-string">"H"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><br>  If JS had operator overloading, then exc (p1, p2) could be reduced to p1 - p2 or! P2 &amp;&amp; p1 (for this, however, you need to enter the pattern combinator all / and which will work as an &amp;&amp; operator) . <br><br>  Then there is a pattern-combinator any - it takes several patterns and constructs a new one, which parses what the first of these patterns parses.  We can say that W (any (p1, p2, p3, ...)) = W (p1) v W (p2) v W (p3) v ... <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...patterns</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str, pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; patterns.length; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r = patterns[i].exec(str, pos)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }); }</code> </pre><br><br>  I used the ... patterns (harmony: rest_parameters) construct to avoid a clumsy code like [] .slice.call (arguments, 0).  Example of using any: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = any(txt(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>), txt(<span class="hljs-string"><span class="hljs-string">"def"</span></span>)); assert.deepEqual(p.exec(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: <span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }); assert.deepEqual(p.exec(<span class="hljs-string"><span class="hljs-string">"def"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: <span class="hljs-string"><span class="hljs-string">"def"</span></span>, <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }); assert.deepEqual(p.exec(<span class="hljs-string"><span class="hljs-string">"ABC"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><br>  If in JS there was an operator overload, then any (p1, p2) could be reduced to p1 ||  p2. <br><br>  The following pattern combinator is seq - it sequentially parses the text of the sequence of patterns given to it and produces an array of results: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seq</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...patterns</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str, pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, r, end = pos, res = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; patterns.length; i++) { r = patterns[i].exec(str, end); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!r) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; res.push(r.res); end = r.end; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: res, <span class="hljs-attr"><span class="hljs-attr">end</span></span>: end }; }); }</code> </pre><br><br>  It is applied like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = seq(txt(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>), txt(<span class="hljs-string"><span class="hljs-string">"def"</span></span>)); assert.deepEqual(p.exec(<span class="hljs-string"><span class="hljs-string">"abcdef"</span></span>), { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: [<span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-string"><span class="hljs-string">"def"</span></span>], <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }); assert.deepEqual(p.exec(<span class="hljs-string"><span class="hljs-string">"abcde7"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><br>  If JS had operator overloading, then seq (p1, p2) could be reduced to p1, p2 (the comma operator is overloaded). <br><br>  Finally, the pattern combinator rep - it repeatedly applies the known pattern to the text and produces an array of results.  As a rule, this is used to parse some of the same type of structures separated by, say, commas, so the rep takes two arguments: the main pattern whose results we are interested in and the dividing pattern whose results are discarded: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pattern, separator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> separated = !separator ? pattern : seq(separator, pattern).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> r[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str, pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = [], end = pos, r = pattern.exec(str, end); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (r &amp;&amp; r.end &gt; end) { res.push(r.res); end = r.end; r = separated.exec(str, end); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: res, <span class="hljs-attr"><span class="hljs-attr">end</span></span>: end }; }); }</code> </pre><br><br>  You can add a couple more parameters min and max which will control how many repetitions are valid.  Here I used the arrow function r =&gt; r [1] (harmony: arrow_functions) in order not to write function (z) {return z [1]}.  Notice how rep is reduced to seq with Pattern # then (the idea is taken from Promise # then): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pattern</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exec</span></span></span><span class="hljs-function">) </span></span>{ ... this.then = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">transform</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str, pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = exec(str, pos); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r &amp;&amp; { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: transform(r.res), <span class="hljs-attr"><span class="hljs-attr">end</span></span>: r.end }; }); }; }</code> </pre><br><br>  This method allows you to derive another from one pattern by applying an arbitrary transformation to the results of the first.  By the way, experts of Haskel, can we say that this Pattern # then makes a pattern of monad? <br><br>  Well, rep is used this way: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = rep(rgx(<span class="hljs-regexp"><span class="hljs-regexp">/\d+/</span></span>), txt(<span class="hljs-string"><span class="hljs-string">","</span></span>)); assert.deepEqual(p.exec(<span class="hljs-string"><span class="hljs-string">"1,23,456"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: [<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"23"</span></span>, <span class="hljs-string"><span class="hljs-string">"456"</span></span>], <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> }); assert.deepEqual(p.exec(<span class="hljs-string"><span class="hljs-string">"123ABC"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: [<span class="hljs-string"><span class="hljs-string">"123"</span></span>], <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }); assert.deepEqual(p.exec(<span class="hljs-string"><span class="hljs-string">"ABC"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><br>  Any distinct analogy with operator overload for rep does not occur to me. <br><br>  The result is about 70 lines for all these rep / seq / any.  This completes the list of combinator patterns and you can proceed to the actual construction of a pattern that recognizes XML-like text. <br><br><h4>  Parser XML-like texts </h4><br><br>  We confine ourselves to such XML-like texts: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">book</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">title</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Book 1"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">chapter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">title</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Chapter 1"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">paragraph</span></span></span><span class="hljs-tag">&gt;</span></span>123<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">paragraph</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">paragraph</span></span></span><span class="hljs-tag">&gt;</span></span>456<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">paragraph</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">chapter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">chapter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">title</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Chapter 2"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">paragraph</span></span></span><span class="hljs-tag">&gt;</span></span>123<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">paragraph</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">paragraph</span></span></span><span class="hljs-tag">&gt;</span></span>456<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">paragraph</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">paragraph</span></span></span><span class="hljs-tag">&gt;</span></span>789<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">paragraph</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">chapter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">chapter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">title</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Chapter 3"</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">chapter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">book</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  To begin with, we will write a pattern recognizing a named attribute of the form name = "value" - it is obviously often found in XML: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = rgx(<span class="hljs-regexp"><span class="hljs-regexp">/[az]+/i</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.toLowerCase()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> char = rgx(<span class="hljs-regexp"><span class="hljs-regexp">/[^"&amp;]/i</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> quoted = seq(txt(<span class="hljs-string"><span class="hljs-string">'"'</span></span>), rep(char), txt(<span class="hljs-string"><span class="hljs-string">'"'</span></span>)).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> r[<span class="hljs-number"><span class="hljs-number">1</span></span>].join(<span class="hljs-string"><span class="hljs-string">''</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attr = seq(name, txt(<span class="hljs-string"><span class="hljs-string">'='</span></span>), quoted).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: r[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-attr"><span class="hljs-attr">value</span></span>: r[<span class="hljs-number"><span class="hljs-number">2</span></span>] }));</code> </pre><br><br>  Here, attr parsits a named attribute with a value as a string, quoted - parses the string in quotes, char - parses one letter in the string (why write it as a separate pattern? Then, what then to ‚Äúteach‚Äù this char to parse the so-called xml entities ), well, the name parses the name of the attribute (note that it parses both large and small letters, but returns the parse name where all the letters are small).  Using attr looks like this: <br><br><pre> <code class="javascript hljs">assert.deepEqual( attr.exec(<span class="hljs-string"><span class="hljs-string">'title="Chapter 1"'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"title"</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">"Chapter 1"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-number"><span class="hljs-number">17</span></span> });</code> </pre><br><br>  Next, we construct a pattern that can parse a header like &lt;? Xml ...?&gt;: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wsp = rgx(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attrs = rep(attr, wsp).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = {}; r.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> (m[a.name] = a.value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m; }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> header = seq(txt(<span class="hljs-string"><span class="hljs-string">'&lt;?xml'</span></span>), wsp, attrs, txt(<span class="hljs-string"><span class="hljs-string">'?&gt;'</span></span>)).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> r[<span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre><br><br>  Here wsp parsit one or more spaces, attrs parses one or more named attributes and returns parsed as a dictionary (rep would return an array of name-value pairs, but the dictionary is more convenient, so the array is converted to a dictionary inside then), and the header parses the header itself and returns only header attributes in the form of the dictionary itself: <br><br><pre> <code class="javascript hljs">assert.deepEqual( header.exec(<span class="hljs-string"><span class="hljs-string">'&lt;?xml version="1.0" encoding="utf-8"?&gt;'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), { <span class="hljs-attr"><span class="hljs-attr">res</span></span>: { <span class="hljs-attr"><span class="hljs-attr">version</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">encoding</span></span>: <span class="hljs-string"><span class="hljs-string">"utf-8"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">end</span></span>: ... });</code> </pre><br><br>  We now turn to parsing the constructions of the form &lt;node ...&gt; ...: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text = rep(char).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> r.join(<span class="hljs-string"><span class="hljs-string">''</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subnode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str, pos</span></span></span><span class="hljs-function">) =&gt;</span></span> node.exec(str, pos)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = seq( txt(<span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>), name, wsp, attrs, txt(<span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>), rep(any(text, subnode), opt(wsp)), txt(<span class="hljs-string"><span class="hljs-string">'&lt;/'</span></span>), name, txt(<span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: r[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: r[<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-attr"><span class="hljs-attr">nodes</span></span>: r[<span class="hljs-number"><span class="hljs-number">5</span></span>] }));</code> </pre><br><br>  Here text parsits the text inside the node (node) and uses the char pattern which can be taught to recognize xml entities, the internal node has its subnode and its node has attributes and internal nodes.  Why such a clever definition of subnode?  If in the definition of node we refer directly to node (something like this: node = seq (..., node, ...)) then it turns out that at the time of determining node this variable is still empty.  The subnode trick allows you to remove this circular dependency. <br><br>  It remains to determine the pattern recognizing the entire file with the header: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xml = seq(header, node).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">root</span></span>: r[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: r[<span class="hljs-number"><span class="hljs-number">0</span></span>] }));</code> </pre><br><br>  The application is accordingly: <br><br><pre> <code class="javascript hljs">assert.deepEqual( xml.exec(src), { <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: { <span class="hljs-attr"><span class="hljs-attr">version</span></span>: <span class="hljs-string"><span class="hljs-string">'1.0'</span></span>, <span class="hljs-attr"><span class="hljs-attr">encoding</span></span>: <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">root</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'book'</span></span>, <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Book 1'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">nodes</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'chapter'</span></span>, <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Chapter 1'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">nodes</span></span>: [...] }, ... ] } });</code> </pre><br><br>  Here I call Pattern # exec with one argument and the meaning of this is that I want to parse the line from the very beginning and make sure that it has been parted to the end, and since it has been parted to the end, it is enough to return only parser without a pointer to that place. where the parser stopped (I already know that this is the end of the line): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pattern</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, exec</span></span></span><span class="hljs-function">) </span></span>{ ... this.exec = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str, pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = exec(str, pos || <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pos &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ? r : !r ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : r.end != str.length ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : r.res; }; }</code> </pre><br><br>  Actually the entire parser is 20 lines (do not forget about those 70 that implement rep, seq, any, etc.): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = rgx(<span class="hljs-regexp"><span class="hljs-regexp">/[az]+/i</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.toLowerCase()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> char = rgx(<span class="hljs-regexp"><span class="hljs-regexp">/[^"&amp;]/i</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> quoted = seq(txt(<span class="hljs-string"><span class="hljs-string">'"'</span></span>), rep(char), txt(<span class="hljs-string"><span class="hljs-string">'"'</span></span>)).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> r[<span class="hljs-number"><span class="hljs-number">1</span></span>].join(<span class="hljs-string"><span class="hljs-string">''</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attr = seq(name, txt(<span class="hljs-string"><span class="hljs-string">'='</span></span>), quoted).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: r[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-attr"><span class="hljs-attr">value</span></span>: r[<span class="hljs-number"><span class="hljs-number">2</span></span>] })); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wsp = rgx(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attrs = rep(attr, wsp).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = {}; r.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> (m[a.name] = a.value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m; }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> header = seq(txt(<span class="hljs-string"><span class="hljs-string">'&lt;?xml'</span></span>), wsp, attrs, txt(<span class="hljs-string"><span class="hljs-string">'?&gt;'</span></span>)).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> r[<span class="hljs-number"><span class="hljs-number">2</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text = rep(char).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> r.join(<span class="hljs-string"><span class="hljs-string">''</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subnode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str, pos</span></span></span><span class="hljs-function">) =&gt;</span></span> node.exec(str, pos)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = seq( txt(<span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>), name, wsp, attrs, txt(<span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>), rep(any(text, subnode), opt(wsp)), txt(<span class="hljs-string"><span class="hljs-string">'&lt;/'</span></span>), name, txt(<span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: r[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: r[<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-attr"><span class="hljs-attr">nodes</span></span>: r[<span class="hljs-number"><span class="hljs-number">5</span></span>] })); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xml = seq(header, node).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">root</span></span>: r[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: r[<span class="hljs-number"><span class="hljs-number">0</span></span>] }));</code> </pre><br><br>  With operator overloading in JS (or in C ++), it would look something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = rgx(<span class="hljs-regexp"><span class="hljs-regexp">/[az]+/i</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.toLowerCase()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> char = rgx(<span class="hljs-regexp"><span class="hljs-regexp">/[^"&amp;]/i</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> quoted = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'"'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> + rep(char</span></span></span><span class="hljs-function">) + '"').</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">then</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r =&gt; r[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].join(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span></span><span class="hljs-function">)); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">var</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">attr</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name + </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'='</span></span></span></span><span class="hljs-function"><span class="hljs-params"> + quoted</span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">then</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r =&gt; ({ name: r[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">], value: r[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">] }</span></span></span><span class="hljs-function">)); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">var</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">wsp</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rgx</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/\s+/</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">var</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">attrs</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">attr, wsp</span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">then</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r =&gt; { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m = {}; r.forEach(a =&gt; (m[a.name] = a.value</span></span></span><span class="hljs-function">)); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m</span></span></span><span class="hljs-function">; }); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">var</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">header</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'&lt;?xml'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> + wsp + attrs + </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'?&gt;'</span></span></span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">then</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r =&gt; r[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">var</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">char</span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">then</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r =&gt; r.join(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span></span><span class="hljs-function">)); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">var</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subnode</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Pattern</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(str, pos</span></span></span><span class="hljs-function">) =&gt;</span></span> node.exec(str, pos)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = (<span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> + name + wsp + attrs + <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span> + rep(text | subnode) + (wsp | <span class="hljs-literal"><span class="hljs-literal">null</span></span>) + <span class="hljs-string"><span class="hljs-string">'&lt;/'</span></span> + name + <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: r[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: r[<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-attr"><span class="hljs-attr">nodes</span></span>: r[<span class="hljs-number"><span class="hljs-number">5</span></span>] })); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xml = (header + node).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">root</span></span>: r[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: r[<span class="hljs-number"><span class="hljs-number">0</span></span>] }));</code> </pre><br><br>  It should be noted that each var here strictly corresponds to one ABNF rule and therefore if it is necessary to parse something according to the description in the RFC (and ABNF is loved there), then the transfer of those rules is a mechanical matter.  Moreover, since the ABNF rules themselves (as well as EBNF and PEG) are strictly formal, we can write a parser of these rules and then, instead of calls to rep, seq, etc., write something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataurl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ABNF(<span class="hljs-string"><span class="hljs-string">'"data:" mime ";" attrs, "," data'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">mime</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/[az]+\/[az]+/i</span></span>, <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: ..., <span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/.*/</span></span> }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">mime</span></span>: r[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: r[<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-attr"><span class="hljs-attr">data</span></span>: r[<span class="hljs-number"><span class="hljs-number">5</span></span>] }));</code> </pre><br><br>  And apply as usual: <br><br><pre> <code class="javascript hljs">assert.deepEqual( dataurl.exec(<span class="hljs-string"><span class="hljs-string">'data:text/plain;charset="utf-8",how+are+you%3f'</span></span>), { <span class="hljs-attr"><span class="hljs-attr">mime</span></span>: <span class="hljs-string"><span class="hljs-string">"text/plain"</span></span>, <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: { <span class="hljs-attr"><span class="hljs-attr">charset</span></span>: <span class="hljs-string"><span class="hljs-string">"utf-8"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-string"><span class="hljs-string">"how are you?"</span></span> });</code> </pre><br><br><h4>  Some more beeches </h4><br><br>  Why does Pattern # exec return null / undefined if parsing failed?  Why not throw an exception?  If you use exceptions in this way, the parser will become slower every twenty.  Exceptions are good for exceptional cases. <br><br>  The described method allows you to write LL parsers that are not suitable for all purposes.  For example, if you need to parse an XML like <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">book</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">attr1</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"..."</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">attr2</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"..."</span></span></span><span class="hljs-tag">    ???</span></span></code> </pre><br><br>  So in the place where it is ???  may be either /&gt; or just&gt;.  Now, if LL parser tried to parse it all as &lt;book ...&gt; and in place ???  turned out to be /&gt;, then the parser will drop everything that it took so long for parsil and start anew, assuming that it is &lt;book ... /&gt;.  LR parsers do not have this drawback, but it is difficult to write them. <br><br>  Also LL parsers are poorly suited for parsing various syntactic / mathematical expressions where there are operators with different priorities, etc.  LL parser can of course be written, but it will be somewhat confused and will work slowly.  The LR parser will be messed up by itself, but it will be fast.  Therefore, such expressions are convenient to parse so-called.  Pratt's algorithm that <a href="http://javascript.crockford.com/tdop/tdop.html">explained</a> Crockford quite well (if you have a purple link, then you probably understand the parsers better than me and you must have been very bored reading all this). <br><br>  I hope someone this is useful.  At one time I wrote parsers of varying degrees of clumsiness and the method described above was a discovery for me. </div><p>Source: <a href="https://habr.com/ru/post/224081/">https://habr.com/ru/post/224081/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224071/index.html">Popularizing 3D printing in an adult way ... in schools</a></li>
<li><a href="../224073/index.html">Node.js: Overview of General Library Development Technologies</a></li>
<li><a href="../224075/index.html">Haskell. We test the multithreaded application</a></li>
<li><a href="../224077/index.html">Testing through abstract classes in TestNG</a></li>
<li><a href="../224079/index.html">Amazon hides books from Hachette</a></li>
<li><a href="../224083/index.html">Lenovo ThinkServer RD540 Server New Corporate Standard</a></li>
<li><a href="../224089/index.html">DevConf 2014: Piracy and other threats for Android applications. How to defend?</a></li>
<li><a href="../224093/index.html">Happy businessman, Habr!</a></li>
<li><a href="../224095/index.html">Robot Vacuum Cleaner: Human Tested</a></li>
<li><a href="../224097/index.html">Getting a job as a phone repairman in Buenos Aires</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>