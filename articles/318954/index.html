<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Processing preprocessor directives in Objective-C</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A programming language with preprocessor directives is difficult to process, since in this case it is necessary to calculate the values ‚Äã‚Äãof the direc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Processing preprocessor directives in Objective-C</h1><div class="post__text post__text-html js-mediator-article"><p>  A programming language with <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D1%2580%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D0%25B2%25D0%25B0_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">preprocessor directives</a> is difficult to process, since in this case it is necessary to calculate the values ‚Äã‚Äãof the directives, cut out the non-compiled code fragments, and then parse the cleaned code.  Processing directives can be done while parsing the regular code.  This article describes in detail both approaches in relation to the Objective-C language, and also reveals their advantages and disadvantages.  These approaches exist not only in theory, but have already been implemented and are being used in practice in such web services as Swiftify and Codebeat. </p><br><p> <a href="https://habrahabr.ru/post/318954/"><img align="left" src="https://habrastorage.org/files/d3c/d53/8db/d3cd538db7604fe3ad10f759a9042d76.jpg"></a> <br>  <strong>Swiftify</strong> is a web service for converting source codes on Objective-C to Swift.  At the moment, the service supports the processing of both single files and entire projects.  Thus, it can save time for developers who want to learn a new language from Apple. </p><br><p> <a href="https://habrahabr.ru/post/318954/"><img align="left" src="https://habrastorage.org/files/f81/032/e83/f81032e83f4d45cba5a529fad9df9834.png"></a> <br>  <strong>Codebeat</strong> is an automated system for calculating code metrics and analyzing various programming languages, including Objective-C. </p><br><a name="habracut"></a><br><br><a name="content"></a><br><h2 id="soderzhanie">  Content </h2><br><ul><li>  <a href="https://habr.com/ru/post/318954/">Introduction</a> </li><li>  <a href="https://habr.com/ru/post/318954/">Single stage processing</a> <br><ul><li>  <a href="https://habr.com/ru/post/318954/">Linking hidden tokens with non-terminal nodes</a> </li><li>  <a href="https://habr.com/ru/post/318954/">Linking hidden tokens to terminal nodes</a> </li><li>  <a href="https://habr.com/ru/post/318954/">Ignored macros</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/318954/">Two-stage processing</a> <br><ul><li>  <a href="https://habr.com/ru/post/318954/">Preprocessor lexer</a> </li><li>  <a href="https://habr.com/ru/post/318954/">Preprocessor Parser</a> </li><li>  <a href="https://habr.com/ru/post/318954/">Preprocessor</a> </li><li>  <a href="https://habr.com/ru/post/318954/">Lexer</a> </li><li>  <a href="https://habr.com/ru/post/318954/">Parser</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/318954/">Other processing methods</a> </li><li>  <a href="https://habr.com/ru/post/318954/">Conclusion</a> </li></ul><br><a name="intro"></a><br><h2 id="vvedenie">  Introduction </h2><br><p>  Processing of preprocessor directives is carried out while parsing the code.  We will not describe the basic concepts of parsing, but here we will use the <a href="https://habrahabr.ru/company/pt/blog/210772/">terms</a> from the article on the theory and parsing of the source code using ANTLR and Roslyn.  ANTLR is used as a parser generator in both services, and the Objective-C grammars themselves are laid out in the official ANTLR grammar repository ( <a href="https://github.com/antlr/grammars-v4/tree/master/objc">Objective-C grammar</a> ). </p><br><p>  We have identified two ways of processing preprocessor directives: </p><br><ul><li>  single stage processing; </li><li>  two-stage processing. </li></ul><br><a name="one-step-processing"></a><br><h2 id="odnoetapnaya-obrabotka">  Single stage processing </h2><br><p>  One-step processing involves the simultaneous parsing of directives and tokens of the main language.  In ANTLR, there is a channel mechanism that allows you to isolate tokens of various types: for example, tokens of the main language and hidden tokens (comments and spaces).  Directive tokens can also be placed in a separate named pipe. </p><br><p> Usually directive tokens begin with a pound sign ( <code>#</code> or sharp) and end with a line break ( <code>\r\n</code> ).  Thus, to capture such tokens, it is advisable to have a different mode of recognition of tokens.  ANTLR supports such modes, they are described like this: <code>mode DIRECTIVE_MODE;</code>  .  A fragment of the lexer with the mode section for preprocessor directives is as follows: </p><br><pre> <code class="hljs pgsql">SHARP: <span class="hljs-string"><span class="hljs-string">'#'</span></span> -&gt; channel(DIRECTIVE_CHANNEL), mode(DIRECTIVE_MODE); mode DIRECTIVE_MODE; DIRECTIVE_IMPORT: <span class="hljs-string"><span class="hljs-string">'import'</span></span> [ \t]+ -&gt; channel(DIRECTIVE_CHANNEL), mode(DIRECTIVE_TEXT_MODE); DIRECTIVE_INCLUDE: <span class="hljs-string"><span class="hljs-string">'include'</span></span> [ \t]+ -&gt; channel(DIRECTIVE_CHANNEL), mode(DIRECTIVE_TEXT_MODE); DIRECTIVE_PRAGMA: <span class="hljs-string"><span class="hljs-string">'pragma'</span></span> -&gt; channel(DIRECTIVE_CHANNEL), mode(DIRECTIVE_TEXT_MODE);</code> </pre> <br><p>  Some of the preprocessor Objective-C directives are converted into specific Swift code (for example, using the <strong>let</strong> syntax): some remain unchanged, and the rest are converted into comments.  The table below contains examples: </p><br><table><thead><tr><th>  Objective c </th><th>  Swift </th></tr></thead><tbody><tr><td> <code>#define SERVICE_UUID @ "c381de0d-32bb-8224-c540-e8ba9a620152"</code> </td> <td> <code>let SERVICE_UUID = "c381de0d-32bb-8224-c540-e8ba9a620152"</code> </td> </tr><tr><td> <code>#define ApplicationDelegate ((AppDelegate *)[UIApplication sharedApplication].delegate)</code> </td> <td> <code>let ApplicationDelegate = (UIApplication.shared.delegate as? AppDelegate)</code> </td> </tr><tr><td> <code>#define DEGREES_TO_RADIANS(degrees) (M_PI * (degrees) / 180)</code> </td> <td> <code>func DEGREES_TO_RADIANS(degrees: Double) -&gt; Double { return (.pi * degrees)/180; }</code> </td> </tr><tr><td> <code>#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)</code> </td> <td> <code>#if __IPHONE_OS_VERSION_MIN_REQUIRED</code> </td> </tr><tr><td> <code>#pragma mark - Directive between comments.</code> </td> <td> <code>// MARK: - Directive between comments.</code> </td> </tr></tbody></table><br><p>  Comments also need to be placed in the correct position in the resulting Swift code.  However, as already mentioned, there are no hidden tokens in the parse tree. </p><br><div class="spoiler">  <b class="spoiler_title">What if you include hidden tokens in the parse tree?</b> <div class="spoiler_text"><p>  Indeed, hidden tokens can be included in the grammar, but because of this it will become too complicated and redundant, since  <code>COMMENT</code> and <code>DIRECTIVE</code> tokens will be contained in each rule between significant tokens: </p><br><pre> <code class="hljs sql">declaration: property <span class="hljs-keyword"><span class="hljs-keyword">COMMENT</span></span>* COLON <span class="hljs-keyword"><span class="hljs-keyword">COMMENT</span></span>* expr <span class="hljs-keyword"><span class="hljs-keyword">COMMENT</span></span>* prio?;</code> </pre> <br><p>  Therefore, this approach can be immediately forgotten. </p></div></div><br><p>  The question arises: how can one still extract such tokens when traversing the parse tree? </p><br><p>  As it turned out, there are several solutions to this problem, in which hidden tokens are associated with non-terminal or terminal (end) nodes of the parse tree. </p><br><a name="directives-with-non-terminal-nodes"></a><br><h3 id="svyazyvanie-skrytyh-tokenov-s-neterminalnymi-uzlami">  Linking hidden tokens with non-terminal nodes </h3><br><p>  This method is borrowed from the relatively old <a href="http://meri-stuff.blogspot.ru/2012/09/tackling-comments-in-antlr-compiler.html">2012</a> article <a href="http://meri-stuff.blogspot.ru/2012/09/tackling-comments-in-antlr-compiler.html">on ANTLR 3</a> . </p><br><p>  In this case, all hidden tokens are divided into sets of the following types: </p><br><ul><li>  preceding tokens; </li><li>  subsequent tokens ( <strong>following</strong> ); </li><li>  orphans tokens. </li></ul><br><p>  To better understand what these types mean, consider a simple rule in which curly brackets are terminal characters, and as a <code>statement</code> can be any expression containing a semicolon at the end, for example, assignment <code>a = b;</code>  . </p><br><pre> <code class="hljs pgsql">root : <span class="hljs-string"><span class="hljs-string">'{'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span>* <span class="hljs-string"><span class="hljs-string">'}'</span></span> ;</code> </pre> <br><p>  In this case, all comments from the following code fragment will be listed in the precending list, i.e.  first token in the file or tokens in front of non-terminal nodes of the parse tree. </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*First comment*/</span></span> <span class="hljs-string"><span class="hljs-string">'{'</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Precending1*/</span></span> a = b; <span class="hljs-comment"><span class="hljs-comment">/*Precending2*/</span></span> b = c; <span class="hljs-string"><span class="hljs-string">'}'</span></span></code> </pre> <br><p>  If the comment is the last one in the file, or the comment is inserted after all the <code>statement</code> (followed by the terminal bracket), then it is in the list following. </p><br><pre> <code class="java hljs"><span class="hljs-string"><span class="hljs-string">'{'</span></span> a = b; b = c; <span class="hljs-comment"><span class="hljs-comment">/*Following*/</span></span> <span class="hljs-string"><span class="hljs-string">'}'</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Last comment*/</span></span></code> </pre> <br><p>  All other comments fall into the list of orphans (they are all essentially separated by tokens, in this case with curly braces): </p><br><pre> <code class="java hljs"><span class="hljs-string"><span class="hljs-string">'{'</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Orphan*/</span></span> <span class="hljs-string"><span class="hljs-string">'}'</span></span></code> </pre> <br><p>  Due to this splitting, all hidden tokens can be processed in the general method of <code>Visit</code> .  This method is still used in Swiftify, but it is rather complicated and it is problematic to build a <strong>valid</strong> (fidelity) parse tree using it.  The validity of the tree is that it can be converted back into character code into a character, including spaces, comments, and preprocessor directives.  In the future, we plan to switch to using the method for processing preprocessor directives and other hidden tokens, which will be described below. </p><br><a name="directives-with-terminal-nodes"></a><br><h3 id="svyazyvanie-skrytyh-tokenov-s-terminalnymi-uzlami">  Linking hidden tokens to terminal nodes </h3><br><p>  In this case, hidden tokens are associated with certain significant tokens.  In this case, hidden tokens can be <strong>leading</strong> (LeadingTrivia) and <strong>closing</strong> (TrailingTrivia).  This method is now used in the Roslyn parser (for C # and Visual Basic), and the hidden tokens in it are called Trivia (Trivia). </p><br><p>  All trivia on the same line from the significant token to the next significant token fall into the set of closing tokens.  All other hidden tokens fall into the set of leading ones and are associated with the next significant token.  The first significant token contains the initial trivii of the file.  Hidden tokens closing the file are associated with the latest special end-of-file token of zero length.  For more information on the types of parse tree and trivia written in the official documentation <a href="https://github.com/dotnet/roslyn/wiki/Roslyn%2520Overview">Roslyn</a> . </p><br><p>  In ANTLR, for a token with index i, there is a method that returns all tokens from a specific channel to the left or to the right: <code>getHiddenTokensToLeft(int tokenIndex, int channel)</code> , <code>getHiddenTokensToRight(int tokenIndex, int channel)</code> .  Thus, it is possible to make the ANTLR based parser form a reliable parse tree, similar to the Roslyn parse tree. </p><br><a name="ignored-macros"></a><br><h3 id="ignoriruemye-makrosy">  Ignored macros </h3><br><p>  Since during one-step processing, macros are not replaced with Objective-C code fragments, they can be ignored or placed in a separate, isolated channel.  This avoids problems when parsing ordinary Objective-C code and the need to include macros in grammar nodes (by analogy with comments).  This also applies to default macros, such as <code>NS_ASSUME_NONNULL_BEGIN</code> , <code>NS_AVAILABLE_IOS(3_0)</code> and others: </p><br><pre> <code class="hljs erlang-repl">NS_ASSUME_NONNULL_BEGIN : <span class="hljs-string"><span class="hljs-string">'NS_ASSUME_NONNULL_BEGIN'</span></span> ~[\r\n]* -&gt; channel(IGNORED_MACROS); IOS_SUFFIX : [_A-Z]+ <span class="hljs-string"><span class="hljs-string">'_IOS('</span></span> ~<span class="hljs-string"><span class="hljs-string">')'</span></span>+ <span class="hljs-string"><span class="hljs-string">')'</span></span> -&gt; channel(IGNORED_MACROS);</code> </pre> <br><a name="two-step-processing"></a><br><h2 id="dvuhetapnaya-obrabotka">  Two-stage processing </h2><br><p>  The two-step processing algorithm can be represented as the following sequence of steps: </p><br><ol><li>  Tokenization and parsing code preprocessor directives.  Normal code snippets in this step are recognized as plain text. </li><li>  Calculation of conditional directives ( <code>#if</code> , <code>#elif</code> , <code>#else</code> ) and the definition of compiled code blocks. </li><li>  Calculation and substitution of the values ‚Äã‚Äãof the <code>#define</code> directives to the appropriate places in the compiled code blocks. </li><li>  Replacing directives from the source with space characters (to preserve the correct positions of the tokens in the source code). </li><li>  Tokenization and parsing of the resulting text with directives removed. </li></ol><br><p>  The third step can be skipped, and macros can be included directly in the grammar, at least partially.  However, this method is still more difficult to implement than one-step processing: in this case, after the first step, it is necessary to replace the code of the preprocessor directives with spaces if there is a need to maintain the correct positions of the tokens of the usual source code.  Nevertheless, this algorithm for processing preprocessor directives was also implemented in its time and is now used in Codebeat.  The grammar is laid out on <a href="https://github.com/antlr/grammars-v4/tree/master/objc/two-step-processing">GitHub</a> along with a visitor processing preprocessor directives.  An additional advantage of this method is the presentation of grammars in a more structured form. </p><br><p>  For two-stage processing, the following components are used: </p><br><ol><li>  preprocessor lexer; </li><li>  preprocessing parser; </li><li>  preprocessor; </li><li>  lexer; </li><li>  parser </li></ol><br><p>  Recall that the <strong>lexer</strong> groups source code symbols into meaningful sequences, called lexemes or tokens.  And the <strong>parser</strong> builds from a stream of tokens a connected tree structure, which is called a parse tree.  <strong>Visitor</strong> (Visitor) - design pattern that allows you to make the processing logic of each tree node in a separate method. </p><br><a name="ObjectiveCPreprocessorLexer"></a><br><h3 id="preprocessornyy-lekser">  Preprocessor lexer </h3><br><p>  A lexer separating tokens of preprocessor directives and ordinary Objective-C code.  For regular code tokens, <code>DEFAULT_MODE</code> used, and for directive code it is <code>DIRECTIVE_MODE</code> .  Below are the tokens from <code>DEFAULT_MODE</code> . </p><br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">SHARP</span></span>: '#' -&gt; mode(<span class="hljs-type"><span class="hljs-type">DIRECTIVE_MODE</span></span>); <span class="hljs-type"><span class="hljs-type">COMMENT</span></span>: '/*' .*? '*/' -&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CODE</span></span></span><span class="hljs-class">); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LINE_COMMENT</span></span></span><span class="hljs-class">: '//' ~[\r\n]* -&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CODE</span></span></span><span class="hljs-class">); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SLASH</span></span></span><span class="hljs-class">: '/' -&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CODE</span></span></span><span class="hljs-class">); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CHARACTER_LITERAL</span></span></span><span class="hljs-class">: '\'' (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EscapeSequence</span></span></span><span class="hljs-class"> | ~('\''|'\\')) '\'' -&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CODE</span></span></span><span class="hljs-class">); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QUOTE_STRING</span></span></span><span class="hljs-class">: '\'' (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EscapeSequence</span></span></span><span class="hljs-class"> | ~('\''|'\\'))* '\'' -&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CODE</span></span></span><span class="hljs-class">); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STRING</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StringFragment</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CODE</span></span></span><span class="hljs-class">); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CODE</span></span></span><span class="hljs-class">: ~[#'"/]+;</span></span></code> </pre> <br><p>  When looking at this code fragment, the question may arise about the need for additional tokens ( <code>COMMENT</code> , <code>QUOTE_STRING</code> and others), while for the Objective-C code only one token is used - <code>CODE</code> .  The fact is that the <code>#</code> character can be hidden inside ordinary lines and comments.  Therefore, these tokens must be allocated separately.  But this is not a problem, since their type still changes to <code>CODE</code> , and the following rules exist in the preprocessing parser for separating tokens: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">text</span></span> : code | SHARP directive (NEW_LINE | EOF) ; <span class="hljs-attribute"><span class="hljs-attribute">code</span></span> : CODE+ ;</code> </pre> <br><a name="ObjectiveCPreprocessorParser"></a><br><h3 id="preprocessornyy-parser">  Preprocessor Parser </h3><br><p>  A parser that separates Objective-C code tokens and processes preprocessor directive tokens.  The resulting parse tree is then passed to the preprocessor. </p><br><a name="ObjectiveCPreprocessor"></a><br><h3 id="preprocessor">  Preprocessor </h3><br><p>  A visitor that calculates the values ‚Äã‚Äãof preprocessor directives.  Each node traversal method returns a string.  If the calculated value of the directive is <code>true</code> , then the next Objective-C code fragment is returned.  Otherwise, the Objective-C code is replaced with spaces.  As mentioned earlier, this is necessary in order to maintain the correct positions of the tokens of the main code.  To make it easier to understand, let's take the following Objective-C code fragment as an example: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">BOOL</span></span> trueFlag = #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEBUG</span></span> YES #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> arc4random_uniform(<span class="hljs-number"><span class="hljs-number">100</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">95</span></span> ? YES : <span class="hljs-keyword"><span class="hljs-keyword">NO</span></span> #endif ;</code> </pre> <br><p>  This fragment will be converted to the following code in Objective-C for a given conditional symbol <code>DEBUG</code> when using two-stage processing. </p><br><pre> <code class="hljs objectivec"><span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> trueFlag = <span class="hljs-literal"><span class="hljs-literal">YES</span></span> ;</code> </pre> <br><p>  It should be noted that all directives and non-compiled code turned into spaces.  Directives can also be nested in each other: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 60000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MBLabelAlignmentCenter NSTextAlignmentCenter #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MBLabelAlignmentCenter UITextAlignmentCenter #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><a name="ObjectiveCLexer"></a><br><h3 id="lekser">  Lexer </h3><br><p>  Normal Objective-C lexer without tokens that recognize preprocessor directives.  If there are no directives in the source file, then the same original file arrives. </p><br><a name="ObjectiveCParser"></a><br><h3 id="parser">  Parser </h3><br><p>  Parser ordinary Objective-C code.  The grammar of this parser coincides with the grammar of the parser from one-step processing. </p><br><a name="other-processing-methods"></a><br><h2 id="drugie-sposoby-obrabotki">  Other processing methods </h2><br><p>  There are other ways to handle preprocessor directives, for example, you can use a <a href="https://en.wikipedia.org/wiki/Scannerless_parsing">lexeless parser</a> .  Theoretically, in such a parser it will be possible to combine the advantages of both one-stage and two-stage processing, namely: the parser will calculate the values ‚Äã‚Äãof the directives and determine the non-compiled code blocks, and in one pass.  However, such parsers also have disadvantages: they are more difficult to understand and debug. </p><br><p>  Since ANTLR is very strongly tied to the tokenization process, such solutions were not considered.  Although the possibility of creating lexeless grammars now exists and will be refined in the future (see <a href="https://github.com/antlr/antlr4/issues/814">discussion</a> ). </p><br><a name="conclusion"></a><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  This article has examined approaches for processing preprocessor directives that can be used when parsing C-like languages.  These approaches are already implemented for processing Objective-C code and are used in commercial services such as Swiftify and Codebeat.  The parser with two-stage processing was tested on 20 projects, in which the number of correctly processed files is more than 95% of the total.  In addition, one-step processing is also implemented for parsing C # and is laid out in Open Source: <a href="https://github.com/antlr/grammars-v4/tree/master/csharp">C # grammar</a> . </p><br><p>  Swiftify uses one-step processing of preprocessor directives, since our task is not to do the work of the preprocessor, but to translate the preprocessor directives into the appropriate Swift language constructs, despite the potential for parsing errors.  For example, Objective-C <code>#define</code> directives are commonly used to declare global constants and macros.  In Swift, constants ( <strong>let</strong> ) and functions ( <strong>func</strong> ) are used for the same purpose. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/318954/">https://habr.com/ru/post/318954/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318944/index.html">In search of free tickets, the study of the game Aeroflot: Mission 2017</a></li>
<li><a href="../318946/index.html">How to find a way to win the Russian AI Cup 2016, but in the wrong direction</a></li>
<li><a href="../318948/index.html">Finding GDI Object Leaks: How to Drive a Mastodon</a></li>
<li><a href="../318950/index.html">NativeScript, what kind of beast and what is it for?</a></li>
<li><a href="../318952/index.html">Let's Encrypt and nginx: configuration in Debian and Ubuntu</a></li>
<li><a href="../318958/index.html">json-api-normalizer: an easy way to make friends with Redux and the JSON API</a></li>
<li><a href="../318960/index.html">Scala type classes (with a little overview of the cats library)</a></li>
<li><a href="../318962/index.html">About string formatting in modern C ++</a></li>
<li><a href="../318964/index.html">Towers of Hanoi - a theoretical solution without recursion</a></li>
<li><a href="../318966/index.html">Features of the development of mobile MMO RTS. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>