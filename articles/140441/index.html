<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing features and possible features of LR-generators</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Good day. 
 In the final part about writing your own LALR parser generator, I would like to describe the possible features and features...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing features and possible features of LR-generators</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Good day. <br>  In the final part about writing your own LALR parser generator, I would like to describe the possible features and features.  In addition, I will describe what I lacked in existing solutions and for what I started writing my bicycle. <br><br>  In order to set the context, let me tell you that the grammar for analysis is ECMAScript, also known as JavaScript.  The specific specification is ECMA-262, version 5.1 dated June 2011. <br><a name="habracut"></a><br><br>  When I first encountered the difficulties of writing, I did not immediately rush to write compiler code.  At first, I learned how large companies solved these problems: Mozilla and Google (Opera and IE source codes are not publicly available).  As it turned out, they were not particularly steamed with the formalization of grammar and wrote the code as is, that is, as I warned to do in the first part.  Example of if'a processing in v8 (Chrome JS engine): <br><pre><code class="cpp hljs">IfStatement* Parser::ParseIfStatement(ZoneStringList* labels, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>* ok) { <span class="hljs-comment"><span class="hljs-comment">// IfStatement :: // 'if' '(' Expression ')' Statement ('else' Statement)? Expect(Token::IF, CHECK_OK); Expect(Token::LPAREN, CHECK_OK); Expression* condition = ParseExpression(true, CHECK_OK); Expect(Token::RPAREN, CHECK_OK); Statement* then_statement = ParseStatement(labels, CHECK_OK); Statement* else_statement = NULL; if (peek() == Token::ELSE) { Next(); else_statement = ParseStatement(labels, CHECK_OK); } else { else_statement = factory()-&gt;NewEmptyStatement(); } return factory()-&gt;NewIfStatement(condition, then_statement, else_statement); }</span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Why did they do that?  There are several reasons: <br><ol><li>  Speed ‚Äã‚Äãof work  Although the FSM is very fast, the ‚Äúlinear‚Äù performance is still faster. </li><li>  Flexibility.  The fact that bison / ANTLR / boost :: spirit / proprietary development was not used indirectly made me think that everything is not so simple with this grammar and it‚Äôs not me who ran into restrictions. </li><li>  They are not language developers from scratch (as with Dart, for example), so it‚Äôs enough to write once and forget for a couple of years before new changes in the standard.  It follows from this that changes in grammar are not carried out every day. </li></ol><br>  Of course, there are a number of disadvantages: <br><ol><li>  5-10 thousand lines of code just for parsing is a bit too much. </li><li>  Without specifications do not live.  Since the code is very fragmented, it is very difficult to assemble the language scheme into the system from scratch only by source code. </li><li>  Error handling inflates the code, despite the tricky macros: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHECK_OK ok); \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!*ok) return NULL; \ ((void)0</span></span></code> </pre><br></li></ol><br><br><h4>  Parser / Generator Parser Requirements </h4><br>  Now you can go to those grammar pitfalls and my expectations.  At once I will say that some of the items are fully implemented by third-party software.  But in the sum there is no complete program, and there are points for which I have not found a solution. <br><br><h5>  Comments are helpful! </h5><br>  In my task I needed to save the text and position of the comments, rather than discard them.  ANTLR and bison / flex can do it.  The first is due to the multiplexing of the lexer, the second is due to the power of the flex.  Since I have not started writing my lexer yet, I use flex.  And solved this problem as follows: <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* [Comment] = [MultiLineComment] | [SingleLineComment] */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* [MultiLineComment] */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* start of multiline, grab whole comment, that's why i use yymore() */</span></span> <span class="hljs-string"><span class="hljs-string">"/*"</span></span> { BEGIN(multilinecomment); yymore(); m_loc.setMore(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* skip all comments chars except "*" */</span></span> &lt;multilinecomment&gt;[^*\n\r]* { yymore(); } <span class="hljs-comment"><span class="hljs-comment">/* skip all "*", that not followed by "/" */</span></span> &lt;multilinecomment&gt;<span class="hljs-string"><span class="hljs-string">"*"</span></span>+[^*/\n\r]* { yymore(); } <span class="hljs-comment"><span class="hljs-comment">/* end of comment */</span></span> &lt;multilinecomment&gt;<span class="hljs-string"><span class="hljs-string">"*"</span></span>+<span class="hljs-string"><span class="hljs-string">"/"</span></span> { m_comments.push_back(CParser::Comment(yytext, m_loc.tokenLine(), m_loc.tokenCol())); m_loc.setMore(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); BEGIN(INITIAL); } <span class="hljs-comment"><span class="hljs-comment">/* [SingleLineComment] increment lineNo */</span></span> (<span class="hljs-string"><span class="hljs-string">"//"</span></span>([^\r\n])*{LineTerminator})|(<span class="hljs-string"><span class="hljs-string">"//"</span></span>([^\r\n])*) { m_comments.push_back(CParser::Comment(yytext, m_loc.tokenLine(), m_loc.tokenCol())); m_loc.linc(); }</code> </pre><br>  There is nothing special here.  We use the internal states of the lexer and yymore () which allows you to create a holistic lexeme of several rules. <br><br><h5>  Parser-controlled lexer modes </h5><br>  JS has a special form for specifying reg-exps.  They can be written just like that in the source code, and the signal is "/".  But at the same time it is also a sign of division.  Accordingly, the stream of tokens is very different in these cases.  Slash is interpreted as a division mark if the parser in this position allows you to see it.  And as a sign of the beginning reg-exp - in all other cases: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     regexp'a /asd[^c]/i.match(s); //    -   a = b / c;</span></span></code> </pre><br>  That is, the parser should be able to check the box if the division operator can come at the moment.  At the flex level, it is simply solved: <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* [RegularExpressionLiteral] it has more length then [DivPunctor] (at least 3 == "/X/" versus 2 == "/="), that's why it would be proceeded first, before [DivPunctor] */</span></span> <span class="hljs-string"><span class="hljs-string">"/"</span></span>{RegularExpressionFirstChar}({RegularExpressionFirstChar}|<span class="hljs-string"><span class="hljs-string">"*"</span></span>)*<span class="hljs-string"><span class="hljs-string">"/"</span></span>({IdentifierStart}|[<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-9</span></span>])* { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_mode != Mode::M_REGEXP) REJECT; yylval-&gt;assign(yytext, yyleng); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> token::T_REGEXP; } <span class="hljs-comment"><span class="hljs-comment">/* [DivPunctuator]: "/" or "/=" */</span></span> <span class="hljs-string"><span class="hljs-string">"/"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> token::T_DIV; <span class="hljs-string"><span class="hljs-string">"/="</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> token::T_DIVAS;</code> </pre><br>  Since flex is a greedy lexer and tries to process as long as possible lexemes, first it will fall into the rule for regexps, and there, if the mode for division is set, it will go to the next rule. <br><br><h5>  Parser tree output </h5><br>  I would love to get exactly the parser tree as a result of the analysis.  It is very convenient to work with him as part of my task.  AST is also suitable, but alas, the only supporting this format ANTLR requires you to specify explicit rules for its construction on top of the grammar.  No special action was required.  Is that a small addition to the analyzer algorithm: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!accepted &amp;&amp; !error) { ... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (act.type) { ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Action::ACTION_SHIFT: ... node.col = m_loc.tokenCol(); node.line = m_loc.tokenLine(); node.type = ParseNode::NODE_TERM; node.termVal = s; node.symb.term = tok; nodes.push(tree.create(node)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Action::ACTION_REDUCE: ... node.type = ParseNode::NODE_NONTERM; node.symb.nonTerm = (Symbols::SymbolsType)act.reduce.nonTerm; CTree&lt;ParseNode&gt;::TreeNode * parent = tree.create(node); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ruleLen = act.reduce.ruleLength; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ruleLen) { tree.add(parent, nodes.top(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); nodes.pop(); ruleLen--; } nodes.push(parent); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nodes.top()) tree.SetRoot(nodes.top());</code> </pre><br><br><h5>  Custom lookahead </h5><br>  In grammar you can find just such a thing. <br><pre> <code class="hljs matlab">ExpressionStatement = [lookahead ‚àâ {{, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">}] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Expression</span></span></span><span class="hljs-function"> ;</span></span></code> </pre> <br><br>  No, this is not a standard expect-a convolution symbol, which I mentioned in the previous part.  This is the opposite of trying to filter the first character of the expression.  That is, according to this rule, we should throw out unnecessary subsidiary products from Expression, which begin with the terminal "{".  In this case, this is done in order to avoid a conflict between Block, which may look like "{}" and one of the generations just Expression: "{}" as setting an empty javascript Object.  Similarly for ‚Äúfunction‚Äù. <br><br>  The solution can be made without parser magic, but only by correcting the grammar: <br><pre> <code class="cpp hljs">ExpressionStatement = ExpressionWithoutBracket ExpressionWithoutBracket = ... | AssignmentExpressionWithoutBracket | ... ...</code> </pre>  And so until we reach the rule that begins with the terminal "{", and we exclude these rules from the penultimate grammar.  The problem is that there are about 20 intermediate steps. In addition, we multiply this by 2 (also ‚Äúfunction‚Äù!) And then by 2 because this technique is used for the same rule but in a different situation (2 lines - Expression and ExpressionNoIn).  No, it does not please me at all. <br><br>  Technically, in my parser this is solved quite simply: <br><pre> <code class="hljs mel">ExpressionStatement = Expression {<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>: [objectLiteral, functionDeclaration]} ... ObjectLiteral = {commonId: objectLiteral} <span class="hljs-string"><span class="hljs-string">'{'</span></span> <span class="hljs-string"><span class="hljs-string">'}'</span></span> | <span class="hljs-string"><span class="hljs-string">'{ '</span></span>PropertyNameAndValueList <span class="hljs-string"><span class="hljs-string">'}'</span></span> | <span class="hljs-string"><span class="hljs-string">'{'</span></span> <span class="hljs-string"><span class="hljs-string">','</span></span> <span class="hljs-string"><span class="hljs-string">'}'</span></span></code> </pre>  When closing, we set the filtering label from the parent to the child if necessary.  And when we meet the rule that falls under the filtering, we simply do not include it in the closure. <br><br><h5>  Turn off some child rules </h5><br>  This is almost a subtype of the previous item, but here you need to look not only at the first character, but also at an arbitrary one.  The illustration is the aforementioned ExpressionNoIn and a VariableDeclarationListNoIn similar to it.  If you look in more detail, the roots of the problem go to 2 types of for'a for example: <br>  // first syntax <br>  for (var id in obj) alret (id); <br>  // second syntax <br>  for (var id = 1; id &lt;10; id) alert (id); <br><br>  Under normal conditions, when initializing variables, we can use in, a la a = 'eval' in window;  This operator checks the existence of a member in a given object (hussars, be silent!).  However, in the loop it is used to iterate through all members of the object.  And, actually, confusion may very easily arise, therefore inside the second syntax it is forbidden to use in.  In fact, the LALR parser easily resolves all of this thanks to a convolution checking the next character (';' or ')'), but the creators of the grammar apparently focused on a wider class of parsers and therefore introduce duplicate 20 rules for the case without the ‚Äúin‚Äù operator.  However, you need to follow the grammar, so you also need a mechanism to turn off unwanted children (great-great -...) rules. <br><br>  I have it completely similar to the previous paragraph, except that the differences in the details: <br><pre> <code class="hljs mel">ExpressionNoIn = Expression {<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>: [RelationalExpression_6]} ... RelationalExpression = ShiftExpression | RelationalExpression <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> ShiftExpression | RelationalExpression <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span> ShiftExpression | RelationalExpression <span class="hljs-string"><span class="hljs-string">'&lt;='</span></span> ShiftExpression | RelationalExpression <span class="hljs-string"><span class="hljs-string">'&gt;='</span></span> ShiftExpression | RelationalExpression <span class="hljs-string"><span class="hljs-string">'instanceof'</span></span> ShiftExpression | {id: RelationalExpression_6} RelationalExpression <span class="hljs-string"><span class="hljs-string">'in'</span></span> ShiftExpression</code> </pre><br>  This is an optional feature that just makes life easier.  And how exactly show examples of errors.  In the grammar itself, they forgot to add NoIn in one of the rules: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">ConditionalExpressionNoIn</span></span> = LogicalORExpressionNoIn ? AssignmentExpression : AssignmentExpressionNoIn</code> </pre>  The second AssignmentExpression must be obvious with a postfix. <br><br><h5>  Automatic insertion ';' </h5><br>  Another interesting feature of JavaScript is that the Statement does not have to be completed with a semicolon.  Even in places where grammar requires it.  Insertion rules are both simple to describe and difficult to implement: <br><ol><li>  If the parser returned an error on the next token and this token '{' or it is separated from the previous one by at least one newline. </li><li>  We met EOF and it was unexpected. </li><li>  For fora, the rules do not apply.  Semicolons between brackets in the header for'a. </li></ol><br>  The insertion is quite simple - if you determine the need for this action, then just go to the new FSM circle, replacing the last token read with a semicolon.  Well, in the next shift, we don‚Äôt read the new token, but use the one that caused the error. <br><br><h5>  Unicode support </h5><br>  JS is a very competent language in this regard.  Support for utf16 is written hard in the standard.  Up to the point that before parsing the entire source must be converted to utf16.  However, unfortunately, flex does not know how to do this (no, \ xXX is not suitable. Offhand, about a thousand characters will need to be encoded).  Therefore, while this condition is not met. <br><br><h5>  Quantifier support </h5><br>  Another fairly large topic that makes it easier to work with grammar.  I first needed the following quantifiers: "|"  - variants of the rules, where the left part is common and the right part is different;  "?"  - optional character in the rule;  "*" - the symbol is repeated 1 or more times.  Yes, they are completely resolved at the level of BNF grammars: <br><pre> <code class="cpp hljs">A = B | C <span class="hljs-comment"><span class="hljs-comment">//   A = B A = C A = B? C //   A = BC A = C A = B* //   A = AB A = B</span></span></code> </pre><br>  Here everything is fine except for the last example.  In this case, we get the steps in the tree.  That is, if B is repeated 5 times, then we get node A with a depth of 5. This is very inconvenient.  Therefore, again, I decided to introduce modifications to the parser that provide a convenient linear representation - BBBBB form one node A with 5 leaves B. In practice, this looks like the introduction of a new type of operation - ReduceRepeated.  And modifications of closure functions and definitions of convolutions.  In closeItem () we loop the element. <br><br>  But what will happen if done as usual: <br><img src="https://habrastorage.org/storage2/ea7/7fc/e35/ea77fce35afaa6531a89d6b1f975e12f.png"><br><br>  That's all.  Thank you for reading this article. <br><br><h4>  Parts of the article </h4><br><ol><li>  <a href="http://habrahabr.ru/post/140058/">Part 1. Basic theory</a> </li><li>  <a href="http://habrahabr.ru/topic/edit/140339/">Part 2. Description of LR-generators</a> </li><li>  Part 3. Features of writing and possible features of LR-generators </li></ol></div><p>Source: <a href="https://habr.com/ru/post/140441/">https://habr.com/ru/post/140441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../140436/index.html">Saving flash drive based on Linux Debian / Ubuntu distribution</a></li>
<li><a href="../140437/index.html">OS templates with pre-configured applications have been updated in our cloud.</a></li>
<li><a href="../140438/index.html">Payment from mobile phones</a></li>
<li><a href="../140439/index.html">What is wrong with for loops?</a></li>
<li><a href="../140440/index.html">Sandbox wars - Part 3: ARP-Spoofing, the uselessness of filtering by MAC address and the danger of installing unsigned software</a></li>
<li><a href="../140442/index.html">Ready to break into the top travel apps - insights of startups iOS apps</a></li>
<li><a href="../140443/index.html">Release mc-4.8.2</a></li>
<li><a href="../140445/index.html">PHPDocumentor teamed up with Docblox</a></li>
<li><a href="../140446/index.html">How Agile and Google Calendar changed my life</a></li>
<li><a href="../140447/index.html">PHP and git support for AWS Elastic Beanstalk announced</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>