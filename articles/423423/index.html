<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MIT course "Computer Systems Security". Lecture 8: "Model of network security", part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Lecture course # 6.858. "Security of computer systems". Nikolai Zeldovich, James Mykens. year 2014 
 Computer S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MIT course "Computer Systems Security". Lecture 8: "Model of network security", part 3</h1><div class="post__text post__text-html js-mediator-article"><h3>  Massachusetts Institute of Technology.  Lecture course # 6.858.  "Security of computer systems".  Nikolai Zeldovich, James Mykens.  year 2014 </h3><br>  Computer Systems Security is a course on the development and implementation of secure computer systems.  Lectures cover threat models, attacks that compromise security, and security methods based on the latest scientific work.  Topics include operating system (OS) security, capabilities, information flow control, language security, network protocols, hardware protection and security in web applications. <br><br>  Lecture 1: "Introduction: threat models" <a href="https://habr.com/company/ua-hosting/blog/354874/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/354894/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/354896/">Part 3</a> <br>  Lecture 2: "Control of hacker attacks" <a href="https://habr.com/company/ua-hosting/blog/414505/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/416047/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/416727/">Part 3</a> <br>  Lecture 3: "Buffer overflow: exploits and protection" <a href="https://habr.com/company/ua-hosting/blog/416839/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418093/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418099/">Part 3</a> <br>  Lecture 4: "Separation of privileges" <a href="https://habr.com/company/ua-hosting/blog/418195/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418197/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418211/">Part 3</a> <br>  Lecture 5: "Where Security Errors Come From" <a href="https://habr.com/company/ua-hosting/blog/418213/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418215/">Part 2</a> <br>  Lecture 6: "Opportunities" <a href="https://habr.com/company/ua-hosting/blog/418217/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418219/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418221/">Part 3</a> <br>  Lecture 7: "Sandbox Native Client" <a href="https://habr.com/company/ua-hosting/blog/418223/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418225/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418227/">Part 3</a> <br>  Lecture 8: "Model of network security" <a href="https://habr.com/company/ua-hosting/blog/418229/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/423155/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/423423/">Part 3</a> <a name="habracut"></a><br><br>  <b>Audience:</b> Why does a random token always be included in the URL, not in the request body? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Professor:</b> HTTPS is involved in this way, but there are no compelling reasons for not including random variables in the request body.  There are just some forms of inheritance that work in this way through a URL.  But in practice, you can put this information anywhere else in an HTTPS request, other than the header. <br><br>  However, note that simply moving this information to the request body is potentially unsafe if there is something there that an attacker can guess.  Then the attacker will still somehow be able to call the URLs he needs.  For example, when I make an XML HTTP request, and then explicitly put in the body some content that the attacker can guess. <br><br><img src="https://habrastorage.org/webt/k8/00/rl/k800rljxqskwap85v7jdymt3sb8.jpeg"><br><br>  If you simply set the frame in the URL, then the attacker can control it.  But if you use an XML HTTP request and the attacker can generate one of them, then the XML HTTP interface allows you to set the request body.  XML HTTP request is limited to the same origin.  However, if an attacker can do something like: <br><br><pre><code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> x = ‚Äúntrusted‚Äù; </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  It will then be able to inject an HTTP HTTP request that will be executed with inline page authority. <br><br>  It all depends on what the attacker has access to.  If it can force the page to execute an untested script, as shown above, then it can use a JavaScript property called internal HTML to get all the HTML content of the page.  If an attacker can or cannot generate an AJAX request, this one, if he can or cannot see the correct HTML code, this is another, and so on.  In short, this randomly generated token can prevent CSRF attacks. <br><br>  There is one more thing that needs attention: network addresses.  They relate to the part of our conversation that said who the attacker could not communicate with via an XML HTTP request. <br><br>  Regarding network addresses, the frame can send HTTP and HTTPS requests to (host + port) corresponding to its origin.  Please note that the security of the same policy of the same source is very closely related to the security of the DNS infrastructure, because all such policies are based on what you are called. <br><br>  So if you can control how they call me, you can make some rather vicious attacks, like a DNS re-bind attack.  The purpose of such an attack is to launch a JavaScript-controlled JavaScript attacker with the authority (or on behalf of) of the victim‚Äôs website, called victim.com.  In this case, the attacker uses the rules of the policy of the same source and is going to somehow run the code written by him with the permission of another site. <br><br>  This is done as follows.  First, the attacker registers the domain name, say, attacker.com.  It's very simple, just pay a couple of bucks - and on the way, you have your own domain name.  The attacker must also configure the DNS server to respond to requests coming in the name of objects located on attacker.com. <br><br><img src="https://habrastorage.org/webt/wt/pf/jh/wtpfjh-yok0lfy5vp63pmv3t-ww.jpeg"><br><br>  The second thing that should happen is that the user must visit the site attacker.com.  In particular, he should visit some site that depends on this domain name.  In this part of the attack, too, there is nothing tricky. <br><br>  See if you can create an ad campaign, for example, to offer a free iPad.  Everyone wants a free iPad, although I don't know anyone who ever won a free iPad.  So, click on such a message in a phishing mail, and you are already on the site of the attacker.  Nothing special, this part is not complicated. <br><br>  So what happens next?  The browser will start generating DNS queries for the attacker.com site, since the page you visited contains objects that refer to objects located on attacker.com.  But the browser is going to say: ‚ÄúI have never seen this domain before, so let me send a DNS request for permission to contact attacker.com‚Äù! <br><br><img src="https://habrastorage.org/webt/cz/qf/mw/czqfmwdiinh1lxrjntllnrkrktw.jpeg"><br><br>  And the attacker's DNS server responds to this request, but its response contains a very short TTL lifetime, which prevents the response from being cached.  Therefore, the browser will think that it is valid only for a very short period of time before it has to go out and confirm this, which in effect means disabling caching. <br><br>  It turns out that as soon as the user goes to the hacker domain, the attacker's DNS server first returns the real IP address of the web server, which provided the user with a malicious code.  This client-side code refers to attacker.com because the origin policy allows such requests.  The user receives a response, and now the malicious website is running on the client side. <br><br>  Meanwhile, the attacker is going to configure a DNS server, which he controls, to bind the name attacker.com and the IP address victim.com.  This means that if a user's browser requests the resolution of a domain name for something inside attacker.com, it is actually going to get some internal address victim.com. <br><br><img src="https://habrastorage.org/webt/df/tt/jd/dfttjdzqo2hzt6dsttw7ch-mz5o.jpeg"><br><br>  Why can the attacker's DNS do this?  Because the hacker configures it for this, and the attacker's DNS server should not be consulted to re-bind to victim.com. <br><br>  Moreover, if our site wants to get a new object through, say, AJAX, it will assume that this AJAX request goes to attacker.com somewhere outside, but in fact this AJAX request goes inside, to victim.com.  This is bad, because now we have this code on the side where the attacker.com web page is located, which actually accesses data from victim.com from a different source of origin. <br><br><img src="https://habrastorage.org/webt/eo/tn/hr/eotnhr2eggyam1aggoimj-shebs.jpeg"><br><br>  Simply put, when the script is executed in the victim‚Äôs browser due to the outdated previous DNS response, a new DNS query is made for this domain, which, due to the caching ban, goes to the attacker's DNS server.  He replies that now attacker.com seems to have a new IP address of some other website, and the request goes to another server.  And then to return the information collected by the attacker, the attacker will provide his or her correct IP address in one of the following DNS requests. <br><br>  <b>Audience:</b> would it not be wiser to make an attack on the contrary, from victim.com to get all the attacker's cookies and the like? <br><br>  <b>Professor:</b> yes, this option will also work.  This will allow you to do such good things as port scanning.  I mean, your approach will work correctly.  Because you can step by step constantly rebind attacker.com to various computer names and various ports on victim.com's network.  In other words, the attacker.com webpage will always think that it is going to attacker.com and receive an AJAX request from there. <br><br>  In fact, every time the DNS server re-connects to attacker.com, it sends requests to some other IP address within victim.com.  Thus, he can simply step through the IP addresses one by one and see if someone answers these requests. <br><br>  <b>Audience:</b> but the user you are attacking does not necessarily have internal access to the victim.com network. <br><br>  <b>Professor:</b> As a rule, this attack is that there are certain firewall rules that could prevent the external site attacker.com from viewing the IP addresses inside the victim.com network.  However, if you are inside a corporate network such as corp.net behind a corporate firewall, then computers often have the ability to connect to machines outside their network. <br><br>  <b>Audience:</b> Does this method of attack via HTTPS work? <br><br>  <b>Professor:</b> this is an interesting question!  The fact is that HTTPS uses keys.  If you use HTTPS, then when sending an AJAX request, the victim‚Äôs machine will not have the attacker's HTTPS keys, and the encryption check on the victim.com computer will show the key mismatch.  Therefore, I think that HTTPS rules out this type of attack. <br><br>  <b>Audience:</b> what if the victim uses only HTTPS? <br><br>  <b>Professor:</b> I think it will stop the attacker. <br><br>  <b>Audience:</b> why does an attacker first of all respond to the victim's computer with his IP address? <br><br>  <b>Professor:</b> because the attacker must somehow run his own code on the victim's machine before he can take further steps to search for something within the victim's network.  But let's not waste time, so if you have questions about DNS reassignment, come to me after the lecture. <br><br>  So how can you fix this?  One way to fix this vulnerability is to modify the client DNS permissions module so that external host names are never allowed to access internal IP addresses. <br><br>  It‚Äôs kind of stupid that someone outside your network should be able to create a DNS linked to something inside your network.  This is the easiest solution. <br><br><img src="https://habrastorage.org/webt/9_/2g/3x/9_2g3xpmlwnrztz5386gzndondi.jpeg"><br><br>  One can imagine that the browser can do something called ‚ÄúDNS pinning‚Äù, or DNS pinning.  As a result, if the browser receives a record of resolved DNS, it will always consider this record valid, for example, to interact for 30 minutes, regardless of what TTL the attacker assigns, and will be able to withstand the attack in this way. <br>  This solution is a bit tricky, because there are sites that intentionally use dynamic DNS for things like load balancing on a server and the like.  Thus, the first solution with DNS binding is the best option. <br><br>  And now we consider what the policy of the same source protects.  What about pixels?  How does the origin policy protect the pixels? <br><br>  As it turned out, the pixels actually have no origin.  Thus, each frame gets its own little bounding box, basically just a square, and the frame can draw anywhere within this area. <br><br>  This is actually a problem, because it means that the parent frame can draw on top of the child frame.  And this, in turn, can lead to very insidious attacks. <br><br>  Say, an attacker creates a page that says: ‚Äúclick here to win an iPad‚Äù.  The same standard technique.  This is the parent frame. <br><br><img src="https://habrastorage.org/webt/ow/ul/sd/owulsdkyx1yy_wz5uyaskopock0.jpeg"><br><br>  And this parent frame can create a child frame, which is actually a Facebook button‚Äôs Like frame.  Thus, Facebook allows you to run this little piece of Facebook code that you can put on your page. <br><br>  You know that if a user clicks ‚Äúlike‚Äù, it means that he will go to Facebook and say: ‚ÄúHey, I like this particular page‚Äù!  So, we now have this child frame Like button. <br><br><img src="https://habrastorage.org/webt/sp/dm/xk/spdmxk6xeyd9f6vvpes71las3aq.jpeg"><br><br>  Now an attacker can impose this frame on the area of ‚Äã‚Äãthe screen on which the user should click to get a free iPad, and also make this frame invisible, CSS allows it. <br><br>  So what happens when this happens?  As we have already installed, everyone wants to get a free iPad.  The user is going to go to this site by clicking on this area of ‚Äã‚Äãthe screen, being sure that he clicks on exactly what the free iPad will give him.  But in fact, he presses the invisible Like button.  It's like layering on top of C. <br><br>  This means that now, perhaps, the user enters the profile of Facebook, where he notes that he liked the site attacker.com.  You know, he won't even remember how it happened.  So this is actually what is called a click jacking attack - support for a click attack.  In the same way, you can do a lot of bad things - steal passwords, get personal data, in short, this is crazy.  I emphasize that this is possible due to the fact that the parent frame is able to draw anything within this rectangle bounding it. <br><br>  So, the parent frame is what you see on the page, the call to get a free tablet, and the child frame is the ‚Äúlike‚Äù button, which is transparently superimposed on the parent frame. <br><br>  There are different solutions to this problem.  The first is the use of the frame lock code frame busting code.  That way, you can use JavaScript expressions to find out if someone has put their own frame into your frame.  For example, one of these tests is a comparison of the following form: if (self! = Top). <br><br>  Here, the self operator refers to the top of the top frame, which is compared to the hierarchy of the entire frame.  Therefore, if you do this test and find that self is not equal to the top of the parent frame, you will understand that you have a child frame.  In this case, you can refuse to download it. <br><br>  This happens if you try to create a frame, for example, for CNN.com.  If you look at the source code of JavaScript, you can see that it performs this test, because CNN.com does not want other people to use its content.  Therefore, this frame always occupies the highest position.  So this is one solution that can be used here. <br><br>  The second solution is for your web server to respond with an HTTP header called x-Frame options.  Therefore, when the web server returns a response, it can set this header, which says: ‚Äúhey, browser, don't let anyone put my content inside the frame!‚Äù.  This solution allows the browser to perform enforcement actions. <br><br>  So it's pretty simple.  But there are still a bunch of other crazy attacks you can organize. <br><br>  As I mentioned earlier, the fact that we now live in an international Internet creates problems with the use of a domain name or host. <br><br>  Suppose we have the letter C. But in what language?  From which alphabet is this letter from Latin ASCII or is it C in Cyrillic?  This allows you to organize attacks that use different interpretations and the use of different, but externally similar letters.  For example, an attacker registers the domain name cats.com.  And users will go to this domain, thinking that they will visit the site ‚Äúcats.com‚Äù, but in reality they will get on the site of the attacker ‚Äúsatss.kom‚Äù, because the first letter here is not Latin, but Cyrillic. <br><br>  An attacker can register a domain fcebook.com, but people are inattentive, they will perceive it as facebook.com and go there.  So if you control Facebook, you‚Äôll get a bunch of traffic from people who think they‚Äôve logged in to Facebook. <br><br><img src="https://habrastorage.org/webt/1w/0f/z-/1w0fz-myyja-qcjtcfwzn5yebl4.jpeg"><br><br>  There are a lot of different, kind of, stupid attacks that you can launch through the domain name registration system, from which it is difficult to defend yourself, because how can you prevent users from making typos?  Or, as the browser tells the user: ‚ÄúHey, is it Cyrillic, not Latin?‚Äù? <br><br>  If the browser warns the user every time Cyrillic fonts are turned on, it will piss off people who actually use Cyrillic as their native font.  So it is not entirely clear how such issues can be solved from a technical point of view, therefore very sensitive security problems arise here. <br><br>  Another interesting thing is plugins.  How do plugins interact with the origin policy?  Plugins often have incompatibility with the rest of the browser in relation to the same source of origin.  For example, if you look at a Java plugin, it assumes that different host names that have the same IP address also have the same origin. <br><br>  In fact, this is a rather large deviation from the standard interpretation of a policy of the same origin.  This approach means that if you have something like xycom and zycom and they are projected onto the same IP address, then Java will assume that they have the same origin.  This can be a problem, since in reality one site has a trusted source of origin, and the other does not.  There are many other difficulties associated with plug-ins, which you can find from publicly available sources on the Internet or from the outline of this lecture. <br><br>  The last thing I want to discuss is a screen sharing attack, or a screen sharing attack. <br><br>  HTML5 actually defines a new API, through which a web page can share all of its bits for sharing with another browser or server.  This seems like a really cool idea, because there is a possibility of simultaneous work of several users on one document.  This is great because we live in the future. <br><br>  But the funny thing is that when they developed this new API, they did not even think about a common source policy! <br><br>  Suppose you have a page on which several frames are located, and each of them has the right to take a screenshot of your entire monitor.  It can take a screenshot of all the frames located on the screen and all the content regardless of the sources from which they originate. <br><br><img src="https://habrastorage.org/webt/wz/ok/io/wzokioeio3vzffhinxhsdgau-ae.jpeg"><br><br>  So in fact, this is a rather destructive flaw in the policy of the same source of origin, so you should think about correcting it.  For example, if a person from the right frame has the ability to take screenshots, then he will be able to take a screenshot of only the right frame, and not the entire screen. <br><br>  Why didn't the browser developers implement it this way?  Because they are experiencing competitive pressure and are forced to focus their efforts on the development of new and new features, new features, rather than focusing on improving things already developed. <br><br>  Many questions that students asked on the Internet regarding this lecture, sounded like this: ‚Äúwhy didn't the developers do what they could do?  Is this not clear? ‚ÄùOr:‚Äú It seems that this particular scheme is dead.  Wouldn't the other be better? ‚ÄùAnd so on. <br><br>  I'll tell you honestly - yes, that‚Äôs for sure, almost everything would have been better if the developers reacted to this responsibly.  So I feel ashamed that I am connected with this. <br><br>  But the fact is that this is what we had before.  If you look at all the elements that existed before, you will see that web browsers are evolving, and people have begun to take a little more care about security.  But not in the case of screen sharing, where developers were so concerned about the innovative features of the browser that they completely forgot about the possibility of bits leaking. <br><br><img src="https://habrastorage.org/webt/0w/pr/lj/0wprljlz8_-bdy5l852zllntduu.jpeg"><br><br>  Therefore, I ask you to always pay attention to the things we discussed today.  Imagine if we were going to start from scratch, destroy everything that was before us, and try to come up with a better security policy, how do you think, how many sites would work for us?  I think no more than 2%.  So users would surely complain about us. <br><br>  There is another interesting property related to security.      - ,     ,     .       ,    origin,        . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_1C62Twf0vs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-858-computer-systems-security-fall-2014/"></a> . <br><br>  Thank you for staying with us.  Do you like our articles?  Want to see more interesting materials?  Support us by placing an order or recommending to friends, <b>30% discount for Habr users on a unique analogue of the entry-level servers that we invented for you:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">The whole truth about VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps from $ 20 or how to share the server?</a>  (Options are available with RAID1 and RAID10, up to 24 cores and up to 40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps until December for free</b> if you pay for a period of six months, you can order <a href="https://ua-hosting.company/vpsnl">here</a> . <br><br>  <b>Dell R730xd 2 times cheaper?</b>  Only we have <b><a href="https://ua-hosting.company/serversnl">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV from $ 249</a> in the Netherlands and the USA!</b>  Read about <a href="https://habr.com/company/ua-hosting/blog/329618/">How to build an infrastructure building.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">class c using servers Dell R730xd E5-2650 v4 worth 9000 euros for a penny?</a> </div><p>Source: <a href="https://habr.com/ru/post/423423/">https://habr.com/ru/post/423423/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423411/index.html">iOS CSS of death</a></li>
<li><a href="../423415/index.html">Multikopter on the principle of the doll or snitch catcher?</a></li>
<li><a href="../423417/index.html">We write the first application for Samsung Smart Watch and OS Tizen</a></li>
<li><a href="../423419/index.html">HTML5 client for VMware vSphere coming out this fall - what you need to know</a></li>
<li><a href="../423421/index.html">Why for indie before the grass was greener</a></li>
<li><a href="../423425/index.html">Old school: what were the games on - we are discussing unusual carriers</a></li>
<li><a href="../423427/index.html">IndieVisible - an online community of indie developers built on an open source platform.</a></li>
<li><a href="../423429/index.html">Database update and zero-downtime deployment</a></li>
<li><a href="../423431/index.html">SIEM depths: out-of-box correlations. Part 1: Pure marketing or unsolvable problem?</a></li>
<li><a href="../423437/index.html">The digest of interesting materials for mobile developer # 270 (September 10 - 16)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>