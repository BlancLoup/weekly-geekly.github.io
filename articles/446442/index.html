<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Happy Party or a couple of memory lines about your introduction to PostgreSQL10 partitioning</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Preface or how the partitioning idea came about 
 The beginning of the story is here: Do you remember how it all began. It was the first time and agai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Happy Party or a couple of memory lines about your introduction to PostgreSQL10 partitioning</h1><div class="post__text post__text-html js-mediator-article"><h4>  Preface or how the partitioning idea came about </h4><br>  The beginning of the story is here: <a href="https://habr.com/ru/company/icl_services/blog/446314/">Do you remember how it all began.</a>  <a href="https://habr.com/ru/company/icl_services/blog/446314/">It was the first time and again.</a>  After almost all the resources to optimize the query, at that time, were exhausted, the question arose - what next?  So the idea of ‚Äã‚Äãpartitioning arose. <br><br><img src="https://habrastorage.org/webt/nm/xq/n_/nmxqn_3ph5nuny67ibx2bs82_gy.jpeg"><br><br>  <b>Lyrical digression:</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>It was "at that time", because <a href="https://habr.com/ru/company/icl_services/blog/446314/">as it turned out, there were unused reserves of optimization</a> .</i>  <i>Thanks <a href="https://habr.com/ru/users/asmm/" class="user_link">asmm</a> and Habra!</i> <br><br>  So, how else can you make the customer seem to be happy, at the same time and pump your own skills? <br><br>  <b>If to simplify everything to the utmost</b> , then, there are drastic ways to improve something in the speed of the database, only two: <br><br><ol><li>  Extensive way - we increase resources, change the configuration; </li><li>  The intensive way is query optimization. </li></ol><br>  Since, I repeat, at that time it was not clear what else to change in the query for acceleration, the path was chosen - <b>changes to the design of the tables.</b> <br><br>  <b>So - the main question arises - what and how will we change?</b> <br><a name="habracut"></a><br><h2>  Initial conditions </h2><br>  First, there is such an ERD (shown conditionally simplified): <br><br><img src="https://habrastorage.org/webt/l_/yk/tx/l_yktxpeyudnjegmli4rdr9aw-c.jpeg"><br><br>  Key Features: <br><br><ol><li>  many-to-many relationship </li><li>  the table already has a potential partitioning key </li></ol><br>  Original request: <br><br><pre><code class="plaintext hljs">SELECT p."PARAMETER_ID" as parameter_id, pc."PC_NAME" AS pc_name, pc."CUSTOMER_PARTNUMBER" AS customer_partnumber, w."LASERMARK" AS lasermark, w."LOTID" AS lotid, w."REPORTED_VALUE" AS reported_value, w."LOWER_SPEC_LIMIT" AS lower_spec_limit, w."UPPER_SPEC_LIMIT" AS upper_spec_limit, p."TYPE_CALCUL" AS type_calcul, s."SHIPMENT_NAME" AS shipment_name, s."SHIPMENT_DATE" AS shipment_date, extract(year from s."SHIPMENT_DATE") AS year, extract(month from s."SHIPMENT_DATE") as month, s."REPORT_NAME" AS report_name, p."SPARAM_NAME" AS SPARAM_name, p."CUSTOMERPARAM_NAME" AS customerparam_name FROM data w INNER JOIN shipment s ON s."SHIPMENT_ID" = w."SHIPMENT_ID" INNER JOIN parameters p ON p."PARAMETER_ID" = w."PARAMETER_ID" INNER JOIN shipment_pc sp ON s."SHIPMENT_ID" = sp."SHIPMENT_ID" INNER JOIN pc pc ON pc."PC_ID" = sp."PC_ID" INNER JOIN ( SELECT w2."LASERMARK" , MAX(s2."SHIPMENT_DATE") AS "SHIPMENT_DATE" FROM shipment s2 INNER JOIN data w2 ON s2."SHIPMENT_ID" = w2."SHIPMENT_ID" GROUP BY w2."LASERMARK" ) md ON md."SHIPMENT_DATE" = s."SHIPMENT_DATE" AND md."LASERMARK" = w."LASERMARK" WHERE s."SHIPMENT_DATE" &gt;= '2018-07-01' AND s."SHIPMENT_DATE" &lt;= '2018-09-30' ;</code> </pre> <br>  <b>Execution results on the test database:</b> <br>  <b>Cost</b> : 502 997.55 <br>  <b>Execution time</b> : 505 seconds. <br><br>  What do we see?  Normal request, by time slice. <br><br>  We make the simplest logical assumption: if there is a sample of the time slice, will it help us?  Correct - sectioning. <br><br><h2>  What to partition? </h2><br>  At first glance, the choice is obvious - the declarative sectioning of the ‚Äúshipment‚Äù table with the key ‚ÄúSHIPMENT_DATE‚Äù ( <i>running a lot ahead - in the end, the production turned out a bit wrong</i> ). <br><br><h2>  How to partition? </h2><br>  This question is also not too complicated.  Fortunately, in PostgreSQL 10, now the human partitioning mechanism. <br><br>  So: <br><br><ol><li>  Save dump of source table - <i>pg_dump source_table</i> </li><li>  Remove source table - <i>drop table source_table</i> </li><li>  Create parent table with range partitioning - <i>create table source_table</i> </li><li>  Create sections - <i>create table source_table, create index</i> </li><li>  Import the dump created in step 1 - <i>pg_restore</i> </li></ol><br><h2>  Sectioning scripts </h2><br>  For simplicity and convenience, steps 2,3,4 were combined in one script. <br><br>  So: <br><br><div class="spoiler">  <b class="spoiler_title">Save the source table dump</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pg_dump postgres --file=/dump/shipment.dmp --format=c --table=shipment --verbose &gt; /dump/shipment.log 2&gt;&amp;1</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Delete the source table + Create a parent table with range partitioning + Create sections</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">--create_partition_shipment.sql do language plpgsql $$ declare rec_shipment_date RECORD ; partition_name varchar; index_name varchar; current_year varchar ; current_month varchar ; begin_year varchar ; begin_month varchar ; next_year varchar ; next_month varchar ; first_flag boolean ; i integer ; begin RAISE NOTICE 'CREATE TEMPORARY TABLE FOR SHIPMENT_DATE'; CREATE TEMP TABLE tmp_shipment_date as select distinct "SHIPMENT_DATE" from shipment order by "SHIPMENT_DATE" ; RAISE NOTICE 'DROP TABLE shipment'; drop table shipment cascade ; CREATE TABLE public.shipment ( "SHIPMENT_ID" integer NOT NULL DEFAULT nextval('shipment_shipment_id_seq'::regclass), "SHIPMENT_NAME" character varying(30) COLLATE pg_catalog."default", "SHIPMENT_DATE" timestamp without time zone, "REPORT_NAME" character varying(40) COLLATE pg_catalog."default" ) PARTITION BY RANGE ("SHIPMENT_DATE") WITH ( OIDS = FALSE ) TABLESPACE pg_default; RAISE NOTICE 'CREATE PARTITIONS FOR TABLE shipment'; current_year:='0'; current_month:='0'; begin_year := '0' ; begin_month := '0' ; next_year := '0' ; next_month := '0' ; FOR rec_shipment_date IN SELECT * FROM tmp_shipment_date LOOP RAISE NOTICE 'SHIPMENT_DATE=%',rec_shipment_date."SHIPMENT_DATE"; current_year := date_part('year' ,rec_shipment_date."SHIPMENT_DATE"); current_month := date_part('month' ,rec_shipment_date."SHIPMENT_DATE") ; IF to_number(current_month,'99') &lt; 10 THEN current_month := '0'||current_month ; END IF ; --Init borders IF begin_year = '0' THEN first_flag := true ; --first time flag begin_year := current_year ; begin_month := current_month ; IF current_month = '12' THEN next_year := date_part('year' ,rec_shipment_date."SHIPMENT_DATE" + interval '1 year') ; ELSE next_year := current_year ; END IF; next_month := date_part('month' ,rec_shipment_date."SHIPMENT_DATE" + interval '1 month') ; END IF; -- Check current date into borders NOT for First time IF to_date( current_year||'.'||current_month, 'YYYY.MM') &gt;= to_date( begin_year||'.'||begin_month, 'YYYY.MM') AND to_date( current_year||'.'||current_month, 'YYYY.MM') &lt; to_date( next_year||'.'||next_month, 'YYYY.MM') AND NOT first_flag THEN CONTINUE ; ELSE --NEW borders only for second and after time begin_year := current_year ; begin_month := current_month ; IF current_month = '12' THEN next_year := date_part('year' ,rec_shipment_date."SHIPMENT_DATE" + interval '1 year') ; ELSE next_year := current_year ; END IF; next_month := date_part('month' ,rec_shipment_date."SHIPMENT_DATE" + interval '1 month') ; END IF; partition_name := 'shipment_shipment_date_'||begin_year||'-'||begin_month||'-01-'|| next_year||'-'||next_month||'-01' ; EXECUTE format('CREATE TABLE ' || quote_ident(partition_name) || ' PARTITION OF shipment FOR VALUES FROM ( %L ) TO ( %L ) ' , current_year||'-'||current_month||'-01' , next_year||'-'||next_month||'-01' ) ; index_name := partition_name||'_shipment_id_idx'; RAISE NOTICE 'INDEX NAME =%',index_name; EXECUTE format('CREATE INDEX ' || quote_ident(index_name) || ' ON '|| quote_ident(partition_name) ||' USING btree ("SHIPMENT_ID") TABLESPACE pg_default ' ) ; --Drop first time flag first_flag := false ; END LOOP; end $$;</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Importing dump</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pg_restore -d postgres --data-only --format=c --table=shipment --verbose shipment.dmp &gt; /tmp/data_dump/shipment_restore.log 2&gt;&amp;1</code> </pre> </div></div><br><h2>  Check partitioning results </h2><br>  What do we have as a result?  The full text of the implementation plan is large and boring, so it is quite possible to limit ourselves to the totals. <br><br><h3>  It was </h3><br>  <b>Cost:</b> 502 997.55 <br>  <b>Execution time:</b> 505 seconds. <br><br><h3>  It became </h3><br>  <b>Cost:</b> 77 872.36 <br>  <b>Execution time:</b> 79 seconds. <br><br>  It is a good result.  Reduced cost and lead time.  Thus, the use of partitioning gives the expected effect and, in general, without surprises. <br><br><h2>  Please customer </h2><br>  Test results were submitted to the customer for review.  And after reading them, a somewhat unexpected verdict was issued: ‚ÄúGreat, section the‚Äú data ‚Äùtable‚Äù. <br><br>  Yes, but we investigated a completely different ‚Äúshipment‚Äù table, the ‚Äúdata‚Äù table does not have a ‚ÄúSHIPMENT_DATE‚Äù field. <br><br>  Not a problem, add, change.  The main thing is that the customer is satisfied with what happens as a result, the implementation details are not particularly important. <br><br><h2>  We partition the main table "data" </h2><br>  In general, no particular difficulties arose.  Although, the partitioning algorithm, of course, has changed somewhat. <br><br><div class="spoiler">  <b class="spoiler_title">Add the column ‚ÄúSHIPMENT_DATA‚Äù to the table ‚Äúdata‚Äù</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">psql -h  -U  -d  =&gt; ALTER TABLE data ADD COLUMN "SHIPMENT_DATE" timestamp without time zone ;</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Fill in the values ‚Äã‚Äãof the column ‚ÄúSHIPMENT_DATA‚Äù in the table ‚Äúdata‚Äù with the values ‚Äã‚Äãof the same column from the table ‚Äúshipment‚Äù</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">----------------------------- --update_data.sql --updating for altered table "data" to values of "shipment_data" from the table "shipment" --version 1.0 do language plpgsql $$ declare rec_shipment_data RECORD ; shipment_date timestamp without time zone ; row_count integer ; total_rows integer ; begin select count(*) into total_rows from shipment ; RAISE NOTICE 'Total %',total_rows; row_count:= 0 ; FOR rec_shipment_data IN SELECT * FROM shipment LOOP update data set "SHIPMENT_DATE" = rec_shipment_data."SHIPMENT_DATE" where "SHIPMENT_ID" = rec_shipment_data."SHIPMENT_ID"; row_count:= row_count +1 ; RAISE NOTICE 'row count = % , from %',row_count,total_rows; END LOOP; end $$;</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">We save a dump of the data table</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pg_dump postgres --file=/dump/data.dmp --format=c --table=data --verbose &gt; /dump/data.log 2&gt;&amp;1&lt;/source</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Re-create the partitioned data table</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">--create_partition_data.sql --create partitions for the table "wafer data" by range column "shipment_data" with one month duration --version 1.0 do language plpgsql $$ declare rec_shipment_date RECORD ; partition_name varchar; index_name varchar; current_year varchar ; current_month varchar ; begin_year varchar ; begin_month varchar ; next_year varchar ; next_month varchar ; first_flag boolean ; i integer ; begin RAISE NOTICE 'CREATE TEMPORARY TABLE FOR SHIPMENT_DATE'; CREATE TEMP TABLE tmp_shipment_date as select distinct "SHIPMENT_DATE" from shipment order by "SHIPMENT_DATE" ; RAISE NOTICE 'DROP TABLE data'; drop table data cascade ; RAISE NOTICE 'CREATE PARTITIONED TABLE data'; CREATE TABLE public.data ( "RUN_ID" integer, "LASERMARK" character varying(20) COLLATE pg_catalog."default" NOT NULL, "LOTID" character varying(80) COLLATE pg_catalog."default", "SHIPMENT_ID" integer NOT NULL, "PARAMETER_ID" integer NOT NULL, "INTERNAL_VALUE" character varying(75) COLLATE pg_catalog."default", "REPORTED_VALUE" character varying(75) COLLATE pg_catalog."default", "LOWER_SPEC_LIMIT" numeric, "UPPER_SPEC_LIMIT" numeric , "SHIPMENT_DATE" timestamp without time zone ) PARTITION BY RANGE ("SHIPMENT_DATE") WITH ( OIDS = FALSE ) TABLESPACE pg_default ; RAISE NOTICE 'CREATE PARTITIONS FOR TABLE data'; current_year:='0'; current_month:='0'; begin_year := '0' ; begin_month := '0' ; next_year := '0' ; next_month := '0' ; i := 1; FOR rec_shipment_date IN SELECT * FROM tmp_shipment_date LOOP RAISE NOTICE 'SHIPMENT_DATE=%',rec_shipment_date."SHIPMENT_DATE"; current_year := date_part('year' ,rec_shipment_date."SHIPMENT_DATE"); current_month := date_part('month' ,rec_shipment_date."SHIPMENT_DATE") ; --Init borders IF begin_year = '0' THEN RAISE NOTICE '***Init borders'; first_flag := true ; --first time flag begin_year := current_year ; begin_month := current_month ; IF current_month = '12' THEN next_year := date_part('year' ,rec_shipment_date."SHIPMENT_DATE" + interval '1 year') ; ELSE next_year := current_year ; END IF; next_month := date_part('month' ,rec_shipment_date."SHIPMENT_DATE" + interval '1 month') ; END IF; -- RAISE NOTICE 'current_year=% , current_month=% ',current_year,current_month; -- RAISE NOTICE 'begin_year=% , begin_month=% ',begin_year,begin_month; -- RAISE NOTICE 'next_year=% , next_month=% ',next_year,next_month; -- Check current date into borders NOT for First time RAISE NOTICE 'Current data = %',to_char( to_date( current_year||'.'||current_month, 'YYYY.MM'), 'YYYY.MM'); RAISE NOTICE 'Begin data = %',to_char( to_date( begin_year||'.'||begin_month, 'YYYY.MM'), 'YYYY.MM'); RAISE NOTICE 'Next data = %',to_char( to_date( next_year||'.'||next_month, 'YYYY.MM'), 'YYYY.MM'); IF to_date( current_year||'.'||current_month, 'YYYY.MM') &gt;= to_date( begin_year||'.'||begin_month, 'YYYY.MM') AND to_date( current_year||'.'||current_month, 'YYYY.MM') &lt; to_date( next_year||'.'||next_month, 'YYYY.MM') AND NOT first_flag THEN RAISE NOTICE '***CONTINUE'; CONTINUE ; ELSE --NEW borders only for second and after time RAISE NOTICE '***NEW BORDERS'; begin_year := current_year ; begin_month := current_month ; IF current_month = '12' THEN next_year := date_part('year' ,rec_shipment_date."SHIPMENT_DATE" + interval '1 year') ; ELSE next_year := current_year ; END IF; next_month := date_part('month' ,rec_shipment_date."SHIPMENT_DATE" + interval '1 month') ; END IF; IF to_number(current_month,'99') &lt; 10 THEN current_month := '0'||current_month ; END IF ; IF to_number(begin_month,'99') &lt; 10 THEN begin_month := '0'||begin_month ; END IF ; IF to_number(next_month,'99') &lt; 10 THEN next_month := '0'||next_month ; END IF ; RAISE NOTICE 'current_year=% , current_month=% ',current_year,current_month; RAISE NOTICE 'begin_year=% , begin_month=% ',begin_year,begin_month; RAISE NOTICE 'next_year=% , next_month=% ',next_year,next_month; partition_name := 'data_'||begin_year||begin_month||'01_'||next_year||next_month||'01' ; RAISE NOTICE 'PARTITION NUMBER % , TABLE NAME =%',i , partition_name; EXECUTE format('CREATE TABLE ' || quote_ident(partition_name) || ' PARTITION OF data FOR VALUES FROM ( %L ) TO ( %L ) ' , begin_year||'-'||begin_month||'-01' , next_year||'-'||next_month||'-01' ) ; index_name := partition_name||'_shipment_id_parameter_id_idx'; RAISE NOTICE 'INDEX NAME =%',index_name; EXECUTE format('CREATE INDEX ' || quote_ident(index_name) || ' ON '|| quote_ident(partition_name) ||' USING btree ("SHIPMENT_ID", "PARAMETER_ID") TABLESPACE pg_default ' ) ; index_name := partition_name||'_lasermark_idx'; RAISE NOTICE 'INDEX NAME =%',index_name; EXECUTE format('CREATE INDEX ' || quote_ident(index_name) || ' ON '|| quote_ident(partition_name) ||' USING btree ("LASERMARK" COLLATE pg_catalog."default") TABLESPACE pg_default ' ) ; index_name := partition_name||'_shipment_id_idx'; RAISE NOTICE 'INDEX NAME =%',index_name; EXECUTE format('CREATE INDEX ' || quote_ident(index_name) || ' ON '|| quote_ident(partition_name) ||' USING btree ("SHIPMENT_ID") TABLESPACE pg_default ' ) ; index_name := partition_name||'_parameter_id_idx'; RAISE NOTICE 'INDEX NAME =%',index_name; EXECUTE format('CREATE INDEX ' || quote_ident(index_name) || ' ON '|| quote_ident(partition_name) ||' USING btree ("PARAMETER_ID") TABLESPACE pg_default ' ) ; index_name := partition_name||'_shipment_date_idx'; RAISE NOTICE 'INDEX NAME =%',index_name; EXECUTE format('CREATE INDEX ' || quote_ident(index_name) || ' ON '|| quote_ident(partition_name) ||' USING btree ("SHIPMENT_DATE") TABLESPACE pg_default ' ) ; --Drop first time flag first_flag := false ; END LOOP; end $$;</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Load the dump created in step 3.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pg_restore -h  - -d  --data-only --format=c --table=data --verbose data.dmp &gt; data_restore.log 2&gt;&amp;1</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">We create a separate section for old data</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">--------------------------------------------------- --create_partition_for_old_dates.sql --create partitions for keeping old dates --version 1.0 do language plpgsql $$ declare rec_shipment_date RECORD ; partition_name varchar; index_name varchar; begin SELECT min("SHIPMENT_DATE") AS min_date INTO rec_shipment_date from data ; RAISE NOTICE 'Old date is %',rec_shipment_date.min_date ; partition_name := 'data_old_dates' ; RAISE NOTICE 'PARTITION NAME IS %',partition_name; EXECUTE format('CREATE TABLE ' || quote_ident(partition_name) || ' PARTITION OF data FOR VALUES FROM ( %L ) TO ( %L ) ' , '1900-01-01' , to_char( rec_shipment_date.min_date,'YYYY')||'-'||to_char(rec_shipment_date.min_date,'MM')||'-01' ) ; index_name := partition_name||'_shipment_id_parameter_id_idx'; EXECUTE format('CREATE INDEX ' || quote_ident(index_name) || ' ON '|| quote_ident(partition_name) ||' USING btree ("SHIPMENT_ID", "PARAMETER_ID") TABLESPACE pg_default ' ) ; index_name := partition_name||'_lasermark_idx'; EXECUTE format('CREATE INDEX ' || quote_ident(index_name) || ' ON '|| quote_ident(partition_name) ||' USING btree ("LASERMARK" COLLATE pg_catalog."default") TABLESPACE pg_default ' ) ; index_name := partition_name||'_shipment_id_idx'; EXECUTE format('CREATE INDEX ' || quote_ident(index_name) || ' ON '|| quote_ident(partition_name) ||' USING btree ("SHIPMENT_ID") TABLESPACE pg_default ' ) ; index_name := partition_name||'_parameter_id_idx'; EXECUTE format('CREATE INDEX ' || quote_ident(index_name) || ' ON '|| quote_ident(partition_name) ||' USING btree ("PARAMETER_ID") TABLESPACE pg_default ' ) ; index_name := partition_name||'_shipment_date_idx'; EXECUTE format('CREATE INDEX ' || quote_ident(index_name) || ' ON '|| quote_ident(partition_name) ||' USING btree ("SHIPMENT_DATE") TABLESPACE pg_default ' ) ; end $$;</code> </pre> </div></div><br><br><h3>  Final results: </h3><br>  <b>It was</b> <br>  <b>Cost:</b> 502 997.55 <br>  <b>Execution time</b> : 505 seconds. <br><br>  <b>It became</b> <br>  <b>Cost:</b> 68 533.70 <br>  <b>Execution time:</b> 69 seconds <br><br>  Worthy, quite worthy.  And considering that along the way, we managed to more or less master the partitioning mechanism in PostgreSQL 10 - Excellent result. <br><br><h2>  Lyrical digression </h2><br><div class="spoiler">  <b class="spoiler_title">And you can do even better - YES, YOU CAN!</b> <div class="spoiler_text">  For this you need to use MATERIALIZED VIEW. <br><div class="spoiler">  <b class="spoiler_title">CREATE MATERIALIZED VIEW LASERMARK_VIEW</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">CREATE MATERIALIZED VIEW LASERMARK_VIEW AS SELECT w."LASERMARK" , MAX(s."SHIPMENT_DATE") AS "SHIPMENT_DATE" FROM shipment s INNER JOIN data w ON s."SHIPMENT_ID" = w."SHIPMENT_ID" GROUP BY w."LASERMARK" ; CREATE INDEX lasermark_vw_shipment_date_ind on lasermark_view USING btree ("SHIPMENT_DATE") TABLESPACE pg_default; analyze lasermark_view ;</code> </pre></div></div><br>  Once again we rewrite the query: <br><br><div class="spoiler">  <b class="spoiler_title">Query using materialized view</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">SELECT p."PARAMETER_ID" as parameter_id, pc."PC_NAME" AS pc_name, pc."CUSTOMER_PARTNUMBER" AS customer_partnumber, w."LASERMARK" AS lasermark, w."LOTID" AS lotid, w."REPORTED_VALUE" AS reported_value, w."LOWER_SPEC_LIMIT" AS lower_spec_limit, w."UPPER_SPEC_LIMIT" AS upper_spec_limit, p."TYPE_CALCUL" AS type_calcul, s."SHIPMENT_NAME" AS shipment_name, s."SHIPMENT_DATE" AS shipment_date, extract(year from s."SHIPMENT_DATE") AS year, extract(month from s."SHIPMENT_DATE") as month, s."REPORT_NAME" AS report_name, p."STC_NAME" AS STC_name, p."CUSTOMERPARAM_NAME" AS customerparam_name FROM data w INNER JOIN shipment s ON s."SHIPMENT_ID" = w."SHIPMENT_ID" INNER JOIN parameters p ON p."PARAMETER_ID" = w."PARAMETER_ID" INNER JOIN shipment_pc sp ON s."SHIPMENT_ID" = sp."SHIPMENT_ID" INNER JOIN pc pc ON pc."PC_ID" = sp."PC_ID" INNER JOIN LASERMARK_VIEW md ON md."SHIPMENT_DATE" = s."SHIPMENT_DATE" AND md."LASERMARK" = w."LASERMARK" WHERE s."SHIPMENT_DATE" &gt;= '2018-07-01' AND s."SHIPMENT_DATE" &lt;= '2018-09-30';</code> </pre></div></div><br>  <b>And we get another result:</b> <br>  <b>It was</b> <br>  <b>Cost:</b> 502 997.55 <br>  <b>Execution time</b> : 505 seconds <br><br>  <b>It became</b> <br>  <b>Cost:</b> 42 481.16 <br>  <b>Execution time:</b> 43 seconds. <br><br>  Although of course, he promises such a promising result, ideas need to be refreshed.  So the final time of data acquisition is not very helpful.  But as an experiment, it is quite interesting. <br><br>  In fact, as it turned out, thanks again to <a href="https://habr.com/ru/users/asmm/" class="user_link">asmm</a> and Habra! - the <a href="https://habr.com/ru/company/icl_services/blog/446314/">query can be further improved.</a> </div></div><br><h2>  Afterword </h2><br>  So, the customer is satisfied.  And <b>you need to take</b> advantage of the situation. <br><br>  <b>New task</b> : What can you think of this to deepen and expand? <br><br>  And then I remember - guys, and in fact we do not have monitoring of our PostgreSQL databases. <br><br>  Hand on heart, there is some monitoring in the form of Cloud Watch on AWS.  But what is the use of this monitoring for DBA?  In general, almost none. <br><br>  <b>If you have a chance to make something useful and interesting for yourself, you should not take advantage of this chance ...</b> <b><br><br></b>  <b>FOR</b> <br><br><img src="https://habrastorage.org/webt/lk/6j/wf/lk6jwfs2fztftdyfx76xq7ulpc8.jpeg"><br><br>  That's how we came to the most interesting: <br><blockquote>  <b>December 3, 2018</b> <br>  Make a decision about starting research on the existing capabilities for monitoring PostgreSQL query performance. <br></blockquote>  <b>But this is a completely different story.</b> <br><br>  <i>To be continued...</i> </div><p>Source: <a href="https://habr.com/ru/post/446442/">https://habr.com/ru/post/446442/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446432/index.html">A seminar on technical document circulation was held in Crimea</a></li>
<li><a href="../446434/index.html">Scaling Zimbra Collaboration Suite</a></li>
<li><a href="../446436/index.html">How to generate hypotheses about the needs of potential consumers of your future product</a></li>
<li><a href="../446438/index.html">Our experience in creating API Gateway</a></li>
<li><a href="../446440/index.html">The book "React quickly. Web applications on React, JSX, Redux and GraphQL ¬ª</a></li>
<li><a href="../446444/index.html">From Skype to WebRTC: how we organized video calling over the web</a></li>
<li><a href="../446446/index.html">Basics of JavaScript engines: common forms and inline caching. Part 1</a></li>
<li><a href="../446448/index.html">5 basic rules for conducting problem interviews to identify consumer needs</a></li>
<li><a href="../446452/index.html">Lunar mission "Bereshit" - April 4, 2019 made a transition to lunar orbit, ahead of 7 days of flight, 6 maneuvers and 1 landing</a></li>
<li><a href="../446454/index.html">Web server development on Golang - from easy to hard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>