<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why do we all need SAT and all these P-NPs (part one)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SAT is already so good that it leads the mind in order 
 Lomonosov ( original ) 

 Introduction 
 On Habr√© already many articles devoted to the proble...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why do we all need SAT and all these P-NPs (part one)</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  SAT is already so good that it leads the mind in order <br>  Lomonosov ( <a href="">original</a> ) <br></blockquote><br><h4>  Introduction </h4><br>  On Habr√© already many articles devoted to the problem of P vs.  NP and the problem of the feasibility of logical formulas (SATisfiability problem).  However, most of them do not answer some of the most important questions.  Why is this problem really important to us?  What happens if they decide it?  Where does all this apply?  And why is it necessary to have at least a general idea of ‚Äã‚Äãwhat it is about? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/854/10f/e5e/85410fe5e72138afd3136ec955a16af1.gif" alt="image"><br><br>  If we analyze in detail the most notable works on Habr√© on this topic [ <a href="http://habrahabr.ru/post/112305/">1</a> , <a href="http://habrahabr.ru/post/132127/">2</a> , <a href="http://habrahabr.ru/post/112161/">3</a> , <a href="http://habrahabr.ru/post/101271/">4</a> , <a href="http://habrahabr.ru/post/43224/">5</a> , <a href="http://habrahabr.ru/post/175113/">6</a> , <a href="http://habrahabr.ru/post/164557/">7</a> ], then we note that on the one hand, people with knowledge of computational complexity will not be able to learn anything fundamentally new these articles.  On the other hand, these articles are still not publicly available.  The illustration from the title clearly demonstrates the problem: to those who were not clear, nothing was clear from it, and those who had already heard about it did not need it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This article has two goals: the first is to give a general idea of ‚Äã‚Äãthe problem and answer the question of why we should be aware of this task (the first part), the second is to provide material for ‚Äúgrowth‚Äù that will be of interest to people interested in topics, as well as It may be useful to study the topic in the future (second part). <br><br><a name="habracut"></a><br><h4>  Article structure </h4><br>  For ease of reading and navigation provide a brief overview of the contents of the article. <br><br><ul><li>  Generally available material <br><ol><li>  Why is SAT important to all of us?  Applications / Interesting NP tasks and SAT </li><li>  The history of SAT and NP-completeness </li><li>  "Intuitive Definition" SAT, NP and P </li><li>  What happens if ... P! = NP, P = NP </li><li>  2-SAT polynomial: algorithm and intuition </li><li>  A challenge to think about </li></ol><br></li><li>  Specialized material (see in the following series) <br><ol><li>  Formal definition.  Asymmetry of the solvability problem for NP and CoNP </li><li>  2 + p-SAT polynomial? </li><li>  The dependence of the complexity of the number of variables </li><li>  I decided to P vs.  NP, what should I do?  Where should i write? </li><li>  Inexpressibility theorems: why the article by Romanov [ <a href="http://habrahabr.ru/post/112161/">3</a> ] expects reject </li><li>  About modern SAT solvers </li><li>  What to read? </li><li>  A challenge to think about </li></ol><br></li></ul><br><h5>  Disclaimer </h5><br>  This work is a general educational material and is intended solely for familiarization with SAT issues.  Computational complexity and SAT are not the main directions of my research, but lie in the adjacent scientific field, so in case of doubt, always refer to the specified source. <br><br><h4>  Generally available material </h4><br><h5>  Why is SAT important to all of us?  Applications </h5><br>  In order to answer this question it is necessary first of all to understand which mathematical problems affect our everyday actual life without our knowledge and how these tasks are related to the SAT. <br><br>  We give a list of tasks that occur around us and say how they relate to the SAT. <br><ul><li>  First of all, we mention <a href="http://ru.wikipedia.org/wiki/RSA">the RSA cryptographic algorithm</a> , which is used to ensure the security of banking transactions, as well as to create a secure connection.  The RSA algorithm can be ‚Äúhacked‚Äù using SAT. </li><li>  Many recommender systems (for example, as part of Netflix) use a Boolean decomposition algorithm to recommend content.  The optimal decomposition of such matrices can be found using SAT. </li><li>  The task of optimal distribution of tasks among processors can be solved with the help of SAT.  A large number of planning tasks are reduced to SAT, for example, <a href="http://en.wikipedia.org/wiki/Open_shop_scheduling">open shop scheduling</a> , where tasks (jobs) must go through certain stages (performed by certain workers) and it is necessary to minimize the total processing time of all tasks. </li><li>  NASA verifies its <a href="http://babelfish.arc.nasa.gov/trac/jpf/wiki/intro/testing_vs_model_checking">software</a> specifications and its hardware <a href="http://shemesh.larc.nasa.gov/fm/fm-collins-formal-methods.html">models</a> using <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B5%25D1%2580%25D0%25BA%25D0%25B0_%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25B9">model checking</a> methods directly related to the SAT. </li><li>  The popular <a href="http://en.wikipedia.org/wiki/K-means_clustering">k-means</a> clustering method <a href="http://en.wikipedia.org/wiki/K-means_clustering">(k-means</a> method) can be solved with the help of SAT. </li><li>  Most of the interesting tasks associated with graphs (for example, in social networks, a graph is a friendship between users) is the search for the largest community, where everyone is friendly with each other, the search for the longest path and many other tasks on the graphs can be solved using the SAT.  The task of the life of the Moscow region (and not only): to make a schedule of garbage trucks in such a way that they traveled all the garbage collection points once in a minimum time.  A large number of tasks in logistics is reduced to the task of SAT. </li><li>  Even <a href="http://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BE_%25D1%2580%25D0%25B0%25D0%25BD%25D1%2586%25D0%25B5">the knapsack problem</a> can be solved with the help of the SAT.  The task is to have a backpack of a fixed size, to collect in it items of the greatest value (knowing the size of all items in advance). </li><li>  Many video games can be solved with the help of SAT (and even <a href="http://habrahabr.ru/post/139993/%26post%3D1203984_258/">Mario</a> !) Also puzzle <a href="http://www-imai.is.s.u-tokyo.ac.jp/~yato/data2/SIGAL87-2.pdf">Sudoku</a> and, attention, <a href="http://web.mat.bham.ac.uk/R.W.Kaye/minesw/">Minesweeper</a> can be solved with the help of SAT! </li><li>  The tasks of <a href="http%253A%252F%252Fwebcourse.cs.technion.ac.il%252F236825%252FSpring2013%252Fho%252FWCFiles%252FThe%252520Serializability%252520of%252520Concurrent%252520Database%252520Updates.pptx%26ei%3DGcW4UqHaNMWI4ASF2oGIAQ%26usg%3DAFQjCNHwtnWzinXu5qvjMlkNfb_kX4pBww%26sig2%3DU07eTRZb-qmapyHZ5IJLBw%26bvm%3Dbv.58187178,d.bGE%26cad%3Drjt">serializing transaction history</a> in databases can be solved using SAT. </li></ul><br><br>  Visualization of tasks solved with the help of SAT (due to Bart Selman, taken <a href="http://www.slidefinder.net/1/10_17_phase_transition/32669527">from here</a> ) <br><img src="https://habrastorage.org/getpro/habr/post_images/59d/919/610/59d91961001799774470d6afa2bf1b5d.png"><br><br><h5>  What does it mean ‚Äúcan be solved‚Äù and what does NP have to do with it </h5><br>  Simply put, if we have an effective solution to the SAT problem, then we can effectively solve all the above tasks.  What exactly is meant by efficiency depends on a specific task, but here we will assume that the work time is acceptable for the user (we can devote a couple of days to calculations for making the school schedule for the semester, and for the clustering method, we would like to get the result in interactive mode ).  And for many of the above problems, the reverse is also true; if we can solve them effectively, then we can solve SAT effectively (this is called NP-completeness - this definition is informal, but enough for a common understanding). <br><br>  All these tasks lie in the NP class - later we will describe the class in more detail, but now we should note that if the effective solution of the SAT problem is known, then we can effectively solve <b>any</b> problem in the NP class.  In other words, SAT is a class representative task; it is ‚Äúmost difficult‚Äù in its class and allows solving all other tasks in the NP. <br><br><h5>  The history of SAT and NP-completeness </h5><br><h6>  NP-completeness </h6><br>  <a href="http://en.wikipedia.org/wiki/Computational_complexity_theory">The theory of computational complexity</a> , in which languages ‚Äã‚Äãand functions are allocated to different classes according to the amount of time and memory necessary for their calculations, was born from the <a href="http://en.wikipedia.org/wiki/Theory_of_computation">theory of computability</a> (ie, the <a href="http://en.wikipedia.org/wiki/History_of_the_Church%25E2%2580%2593Turing_thesis">works of the</a> 30s of G√∂del, Church and Turing) when Hartmanis, Sternc, Lewis (1965 ) offered one of the first similar classifications of functions (original works: <a href="http://www.ams.org/journals/tran/1965-117-00/S0002-9947-1965-0170805-7/S0002-9947-1965-0170805-7.pdf">here</a> and <a href="http://www.cs.albany.edu/~res/space.pdf">here</a> ). <br><br>  The concept of NP-completeness developed in the 1960s-1970s independently in the USSR and the USA (Edmonds, Levin, Yablonsky et al.).  In 1971, Stephen Cook formulated the P vs. hypothesis.  Np.  The theorem that SAT is a ‚Äúuniversal problem‚Äù for the class NP and allows solving any problem in this class (NP-completeness) was independently proved by Leonid Levin (1973) and Stephen Cook, and is called <a href="http://en.wikipedia.org/wiki/Cook-Levin_theorem">the Levin-Cook theorem</a> .  In 1982, Cook will receive a Turing Award for this job. <br><br>  In 1972, Karp publishes <a href="http://www.win.tue.nl/~gwoegi/AC/karp-1971.pdf">Reducibility among combinatorial problems</a> , a list showing that the SAT is far from the only interesting problem in the NP and a huge number of problems lies in the NP and is equivalent to the SAT.  In 1985 Karp will receive a Turing Award for this job. <br><br>  In 1974, Fagin will show that NP is closely related to classical logic, namely, that NP is equivalent to existential logical structures of second order ( <a href="http://en.wikipedia.org/wiki/Fagin%27s_theorem">Fagin's theorem</a> ). <br><br>  In 1975, Baker, Jill, Solovey received the first fundamental meta-result on the unsolvability of the P vs. task.  NP using regularized methods i.  this is the first result showing that a whole class of methods cannot answer the question of equality P vs.  NP (more on this is written <a href="http://www.scottaaronson.com/papers/alg.pdf">here</a> ). <br><br>  In 1979, Gary and Johnson will write <a href="http://en.wikipedia.org/wiki/Computers_and_Intractability:_A_Guide_to_the_Theory_of_NP-Completeness">Computing Machines and Unresolved Problems</a> , one of the most comprehensive sources of information on NP-completeness and a detailed catalog of problems.  Despite the fact that some theoretical results are currently considered obsolete, this is one of the most fundamental works in the field of computational complexity. <br><br>  Visualization of the relationship between formal languages, theories of computational complexity and the theory of computation ( <a href="http://en.wikipedia.org/wiki/Computational_complexity_theory">hence</a> ): <br><img src="https://habrastorage.org/getpro/habr/post_images/8da/c1a/fd5/8dac1afd550b814bf49a36f2fba1cd54.png"><br><br><h6>  A very brief history of SAT-solvers </h6><br>  In the 1960s, Davis and Putman began to apply classically deductive (to put it simply, methods to prove theorems) methods to solve the SAT ( <a href="http://www.ensiie.fr/~blazy/ipr/article1.pdf">original work</a> ). <br><br>  In 1962, Davis, Putnam, Logeman, Loveland proposed the <a href="http://en.wikipedia.org/wiki/DPLL_algorithm">DPLL algorithm</a> based on search with the return and distribution of deterministic calculations (unit-propagation).  To put it simply, the algorithm assumed the value of some variable to be equal to truth and calculated all the deterministic consequences of such a solution and repeated until it found a solution.  This algorithm has served as the basis for many SAT solvers for decades. <br><br>  In 1992, Selman, Levesque and Mitchell proposed a local search method in <a href="http://www.cfdvs.iitb.ac.in/download/Docs/verification/papers/sat/original-papers/gsat.pdf">a GSAT article.</a>  GSAT - means Greedy SAT, local as it decides on the value of variables based on local information only.  The algorithm began with an arbitrary assignment of variable values ‚Äã‚Äãand changed the value of a variable if it gave the greatest increase in the executed sentences.  Subsequently, local search methods in a wide variety of variations were integrated into most SAT solvers ‚Äî in 1999 Hegler Hus led an extensive study of local stochastic search and its applications in his PhD thesis (the work is available <a href="http://www.cs.ubc.ca/~hoos/ps/phd-thesis.pdf">here</a> ). <br><br>  In 1996, Marques-Silva and Sakalah suggested an algorithm called Conflict-Driven-Clause-Learning ( <a href="http://en.wikipedia.org/wiki/Conflict_Driven_Clause_Learning">CDCL</a> ), like DPLL, he decides on the value of variables and performs deterministic calculations, on the other hand he keeps in memory the implication graph and remembers some combinations that do not lead to a solution and can effectively avoid ‚Äúuseless‚Äù solutions and effectively cut off the solution space containing the conflict previously established. <br><br>  From 2001, Locality Based Search SAT-solvers began to emerge, effectively selecting subspaces for a full search based on local information, such as <a href="http://eigold.tripod.com/BerkMin.html">BerkMin</a> (Berkley-Minsk) and many others. <br><br><h4>  "Intuitive Definition" SAT, NP and P </h4><br><h5>  SAT </h5><br>  We begin by defining what <a href="http://ru.wikipedia.org/wiki/%25D0%259B%25D0%25BE%25D0%25B3%25D0%25B8%25D0%25BA%25D0%25B0_%25D0%25B2%25D1%258B%25D1%2581%25D0%25BA%25D0%25B0%25D0%25B7%25D1%258B%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B9">propositional logic is</a> : it is a set of variables {x, y, z, ...} and a set of connectors {and, or, - (not), ‚Üí}.  Each variable can be either "false" or "true."  Connectors are defined standardly: <br><ul><li>  x and y is true if and only if (for brevity we write iff - if and only if) x is true and y is true, the classic "AND" </li><li>  x or y is true iff at least one of the variables x \ y is true, the classic "OR" </li><li>  -x true iff x false, classic negation </li><li>  x ‚Üí y is false iff x is true, and y is false - let's look at an example: <br>  ‚ÄúIf it was raining, the grass is wet‚Äù <br>  A statement is false if and only if the rain was (x true) and the grass is still dry (y is false). </li></ul><br><br>  Formula F is a syntactically correct set of variables and connectors, i.e., ‚Üí, and, or connect variables or other formulas, (not) stands before a variable or formula.  Example, F = (x ‚Üí (y or z)) and (z ‚Üí -x). <br><br>  It is said that the formula F is satisfiable (SAT), iff its variables can be assigned the values ‚Äã‚Äã"true" \ "false" (we call this function <b>I</b> from the English <b>I</b> nterpretation), so that F is true.  For brevity, we write <b>I</b> (F) = "true." <br><br>  Any propositional formula F can be reduced to the form CNF (conjunctive normal form), i.e. be represented as <br>  F '= c <sub>1</sub> and c <sub>2</sub> and ... c <sub>n</sub> <br>  where c <sub>i</sub> is (x or y or z), and x, y, z are variables or their negations. <br><br>  Example F = (x or -y or -z) and (-x or -y or h) and (z or h). <br><br>  More information about this conversion is written <a href="http://en.wikipedia.org/wiki/Conjunctive_normal_form">here</a> (in order for each sentence to contain no more than three variables, you will need to introduce additional variables, but these are only technical details). <br><br>  In this form, when the formula has the form described above, the task is called 3-SAT, emphasizing the fact that each sentence c <sub>i</sub> contains no more than three variables or their negations. <br><br>  The formulation of the 3-SAT task is as follows: <br>  <b>Given:</b> 3-CNF Propositional Formula F <br>  <b>Find::</b> function <b>I</b> , assigning the value "true" \ "false" to all variables, such that <b>I</b> (F) = "true" <br><br><h5>  class P </h5><br>  P is also PTIME ‚Äî problems solvable in polynomial time, this means that the number of steps of the algorithm in a given class grows no more than some polynomial from the input data.  More about various algorithms and complexity analysis in PTIME has already been written on Habr√© [ <a href="http://habrahabr.ru/post/196560/">9</a> , <a href="http://habrahabr.ru/post/195482/">10</a> , <a href="http://habrahabr.ru/post/195996/">11</a> , <a href="http://habrahabr.ru/post/196226/">12</a> , <a href="http://habrahabr.ru/post/188010/">13</a> ]. <br><br>  For illustration, here‚Äôs a simple example: bubble sorting algorithm ( <a href="http://en.wikipedia.org/wiki/Bubble_sort">pseudocode</a> from wiki) <br><pre><code class="matlab hljs">procedure bubbleSort( A : list of sortable items ) n = <span class="hljs-built_in"><span class="hljs-built_in">length</span></span>(A) repeat swapped = <span class="hljs-built_in"><span class="hljs-built_in">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> to n<span class="hljs-number"><span class="hljs-number">-1</span></span> inclusive do <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>] &gt; A[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] then swap(A[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>], A[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) swapped = <span class="hljs-built_in"><span class="hljs-built_in">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n = n - <span class="hljs-number"><span class="hljs-number">1</span></span> until not swapped <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> procedure</code> </pre> <br>  The input parameter is an array of numbers to sort.  We are interested in the growth of time depending on the growth of the array length, i.e.  time dependence of TIME on n.  Note that each iteration of the repeat loop performs no more than 3 * n steps and sets at least one array element to the right place.  This means that the repeat loop is executed no more than n times.  This means that the number of operations (it‚Äôs TIME) grows as a certain square of the array length (and the linear term in ‚Äún = length (A)‚Äù), i.e. <br><br>  TIME (n) = a * n <sup>2</sup> + b * n + C <br><br>  In other words, the running time of the algorithm is limited by a certain polynomial in n, in this case we say that the running time of the algorithm does not grow faster than the square of the number of elements and write it using the <a href="http://en.wikipedia.org/wiki/Big_O_notation">Big-O</a> entry <br><br><img src="https://habrastorage.org/getpro/habr/post_images/416/666/c7a/416666c7aa781615ea954d1d123d692b.png"><br><br><h5>  NP class </h5><br>  NP stands for nondeterministic polynomial time.  Very often it is mistakenly called non-polynomial time, a joke was born on this occasion: <blockquote>  To divide algorithms into polynomial and non-polynomial, it is about how to divide the universe into bananas and non-bananas. </blockquote><br>  In this article, we are not interested in the formal definition of NP (this will be in the specialized material), but we consider the intuitive representation of the class NP.  The very nature and internal mechanisms of NP follow the so-called guess-and-check method.  Those.  the solution search space is exponential (large enough to eliminate the possibility of iteration), and checking the solution is a simple task.  You can consider NP as a class of problems in which you need to find a solution (‚Äúguess‚Äù - guess part) among a large number of options, and then verify its correctness (check part). <br><br>  From the point of view of the SAT, the solution space is all possible sets of variable values, if we have k different variables in the formula, then we have 2 <sup>k</sup> possible ‚Äúinterpretations‚Äù of the formula, i.e.  search space <b>I</b> exponentially.  However, if we "guessed" <b>I</b> , then we can verify the truth of the formula in polynomial time. <br><br><h5>  What happens if P! = NP </h5><br>  Nothing will happen, only someone <a href="http://en.wikipedia.org/wiki/Millennium_Prize_Problems">will get a million dollars</a> . <br><br><h5>  What happens if P = NP </h5><br>  There are two news: good and bad. <br><br>  <i>Good ones.</i>  We will very quickly solve a bunch of optimization tasks, tasks for graphs, make schedules, assemble puzzles, check various properties of databases, and also effectively test the performance of NASA specifications. <br><br>  <i>The bad.</i>  All modern cryptography collapses, and with it, the banking system hits.  People will start writing bots for Mario. <br><br><h4>  2-SAT in P. </h4><br>  Consider an interesting variation of the SAT, in which each clause is limited to two variables.  Hereinafter, the author greatly simplifies everything to facilitate the perception of the material. <br><br>  <b>Given</b> : F - formula of the form c <sub>1</sub> and c <sub>2</sub> and c <sub>3</sub> ... and c <sub>n</sub> , <br>  where c <sub>i</sub> has the form (x or y) and x, y are variables or their negations, i.e. x is some variable v or -v. <br>  <b>Find</b> : function <b>I</b> , assigning the value "true" \ "false" to all variables, such that <b>I</b> (F) = "true" <br>  <b>Statement</b> : I exist a polynomial algorithm P, such that if the function <b>I</b> exists, then P (F) = <b>I</b> , and otherwise, P (F) = {}. <br><br>  (*) function <b>I is</b> not unique if it exists and P returns some function <b>I</b> (in books on the theory of algorithms and complexity, everything will be the same written in formal language, but these details are irrelevant for perceiving the general idea of ‚Äã‚Äãwhy 2-SAT is polynomial ) <br><br><h5>  Sketch of evidence: <br></h5><br>  To begin with, we transform the original formula using the following equality: <br><img src="https://habrastorage.org/getpro/habr/post_images/cfa/e60/418/cfae60418e09a7896e3ac33ade0b5bd5.png"><br>  You can check it with a truth table.  The intuition behind this rule is as follows: <br>  ‚ÄúIf it was raining, the grass is wet‚Äù (x ‚Üí y, x - it was raining, y - grass is wet) <br>  This means that if the grass is dry (not wet: y is false), then there was definitely no rain (x is false). <br>  If the grass is wet, then either the rain was (x true, in a sense, x "explains" why y is true), or there was no rain (x false), on an intuitive level, we mean that there is another reason due to which y true (z - the neighbor watered the lawn and therefore the grass is wet). <br><br>  We transform F using (*) to the form c ' <sub>1</sub> and c' <sub>2</sub> ... and c ' <sub>n</sub> where c' <sub>i</sub> has the form (x ‚Üí y), x, y are variables or their negations.  As a result, F is a graph of implications.  An example of a similar graph below: <br>  c <sub>1</sub> = If it was raining, the grass is wet. <br>  c <sub>2</sub> = If a neighbor is watering the lawn, the grass is wet. <br>  c <sub>3</sub> = If the grass is wet, weeds grow well. <br><img src="https://habrastorage.org/getpro/habr/post_images/6a8/d9e/1bf/6a8d9e1bfdaf88360658eb5096f0e9e2.png"><br><br>  We see that if in the graph of implications coming out of some vertex v (for example, there was rain), it is impossible to reach the vertex -v (there was no rain), then the system of implications is consistent.  Intuition is as follows: if we make some assumption, for example, that there was rain, we immediately conclude that the grass is wet and weeds grow (it remains only to choose whether the lawn was watered by the neighbor) and we do not get a contradiction, then we have part of function <b>I</b> , in particular deciding that it was raining, we got the values ‚Äã‚Äãfor ‚Äúwet grass‚Äù and ‚Äúweeds grow well‚Äù, we are left to decide on the meaning ‚Äúneighbor watered the lawn‚Äù. <br><br>  How many such decisions need to be made?  No more than n is the number of sentences.  How many operations do you need to make when making one decision?  For each solution, we need to bypass the edges of the graph no more than once, that is, perform no more than n operations per solution.  This means that no more than n <sup>2</sup> operations need to be performed to find <b>I.</b>  ‚ñ† <br><br><h4>  The task "to think" </h4><br>  This task may require additional study and literature search. <br><h5>  Trivial SAT Solution <br></h5>  <b>Condition</b> <br>  Each propositional formula F = c <sub>1</sub> and c <sub>2</sub> and c <sub>3</sub> and c <sub>n</sub> can be brought to the disjunctive normal form (DNF), that is, to the form F '= c' <sub>1</sub> or c ' <sub>2</sub> ... or c' <sub>k</sub> , where c ' <sub>i</sub> has the form (x and y and z), x, y, z are variables or their negations.  For example, by consistently applying the rules of De Morgan (reference) and disclosing parentheses. <br>  For F ', there is a trivial algorithm for searching for function I. It is necessary that at least one of c' <sub>i is</sub> true.  Let's write a simple pseudocode solving problem: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#Input: F ‚Äî propositional formula in disjunctive normal form (DNF) #Output: {SAT, UNSAT} for each c in F do if c is SAT: return SAT return UNSAT</span></span></code> </pre><br>  For each sentence (clause) c <sub>i,</sub> the search algorithm <b>I</b> is also trivial, if the sentence c <sub>i</sub> does not contain some variable v and its negation simultaneously, then c <sub>i is</sub> feasible (SAT). <br>  <b>Total</b> : we get the trivial algorithm for checking the formula for feasibility <br>  <b>Find</b> : where is the error? <br><br><h4>  Links and sources </h4><br><br>  The picture in the introduction is taken from <br>  <a href="http://www.scottaaronson.com/talks/anthropic.html">Computational Complexity and Anthropic Principle Scott Aaronson</a> <br><br>  Slides <br>  <a href="http://www.slidefinder.net/1/10_17_phase_transition/32669527">Why SAT Scales: Phase Transition Phenomena &amp; Back Doors to Complexity</a> Courses of Bart Selman Cornell University. <br>  Slides based on the article: <br>  <a href="http://www.cs.cornell.edu/selman/papers/pdf/99.random.typical.pdf">2 + P-SAT: Relation of typical phase transition</a> (Monasson, Remi; Zecchina, Riccardo; Kirkpatrick, Scott; Selman, Bart; and Troyansky, Lidror.) <br>  Other articles can be found <a href="http://www.cs.cornell.edu/selman/papers/">here.</a> <br><br>  More information about the history of NP can be found here: <br>  <a href="http://www.cs.princeton.edu/courses/archive/spr07/cos522/SipserNP.pdf">The Question of Michael Sipser</a> <br>  <a href="http://www.unizar.es/acz/05Publicaciones/Monografias/MonografiasPublicadas/Monografia26/057Mayordomo.pdf">P versus NP by Elvira Mayordomo</a> <br><br>  More about SAT-solver'ah: <br>  <a href="http://www.cs.princeton.edu/courses/archive/spring10/cos598D/SharadMalikCOS598d.pdf">SAT Solvers: A Condensed History</a> <br>  <a href="http://www.mpi-inf.mpg.de/vtsa12/slides/biere/Biere-VTSA12-talk.pdf">Understanding Modern SAT Solvers</a> - by Armin Biere, perhaps the most famous developer of SAT Solvers in the world.  Donald Knut, who is now writing ‚ÄúThe Art of Computer Programming: Volume 4B, Pre-fascicle 6A Satisfiability,‚Äù says he is consulting with him on many issues. <br>  <a href="https://www.cosic.esat.kuleuven.be/ecrypt/courses/mykonos12/slides/day1/slides-LS-SAT-1.pdf">Towards SAT Solvers</a> <br><br>  Material from Habra: <br>  [1] <a href="http://habrahabr.ru/post/112305/">Why I do not believe in simple algorithms for NP-complete problems</a> <br>  [2] <a href="http://habrahabr.ru/post/132127">A little more about P and NP</a> <br>  [3] <a href="http://habrahabr.ru/post/112161/">An open letter to scientists and the reference implementation of the Romanov algorithm for the NP-complete 3-SP problem.</a> <br>  [4] <a href="http://habrahabr.ru/post/101271">Published evidence of P ‚â† NP?</a> <br>  [5] <a href="http://habrahabr.ru/post/43224/">P = NP?</a>  <a href="http://habrahabr.ru/post/43224/">The most important unsolved problem of theoretical computer science.</a> <br>  [6] <a href="http://habrahabr.ru/post/175113/">Theoretical computer science at the Academic University</a> <br>  [7] <a href="http://habrahabr.ru/post/164557/">Top-10 results in the field of algorithms for 2012</a> <br>  [8] <a href="http://habrahabr.ru/post/139993/%26post%3D1203984_258/">It has been proven that Super Mario is an NP-complete challenge.</a> <br>  [9] <a href="http://habrahabr.ru/post/196560/">Introduction to the analysis of the complexity of algorithms (part 1)</a> <br>  [10] <a href="http://habrahabr.ru/post/195482/">Introduction to the analysis of the complexity of algorithms (part 2)</a> <br>  [11] <a href="http://habrahabr.ru/post/195996/">Introduction to the analysis of the complexity of algorithms (part 3)</a> <br>  [12] <a href="http://habrahabr.ru/post/196226/">Introduction to the analysis of the complexity of algorithms (part 4)</a> <br>  [13] <a href="http://habrahabr.ru/post/188010/">Know the complexity of algorithms.</a> </div><p>Source: <a href="https://habr.com/ru/post/207112/">https://habr.com/ru/post/207112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207102/index.html">Object naming in Oracle. View from the outside"</a></li>
<li><a href="../207106/index.html">When to register a startup?</a></li>
<li><a href="../207108/index.html">Fukami, part 1.1: We bring the scene to the theme of the project</a></li>
<li><a href="../20711/index.html">Moroccan sentenced to 3 years in prison for akkanut Facebook on someone else's name</a></li>
<li><a href="../207110/index.html">Peewee - easy, flexible and very fast ORM in Python</a></li>
<li><a href="../207116/index.html">Autodesk Simulation CFD 2014 Quick Start Guide</a></li>
<li><a href="../207118/index.html">iTunes - the payment system of the future?</a></li>
<li><a href="../207120/index.html">New trends in cryptocurrencies: 100% proof-of-stake and Nxt</a></li>
<li><a href="../207122/index.html">A kosher way to modify write-protected areas of the Linux kernel</a></li>
<li><a href="../207124/index.html">Yandex.Disk congratulates the new year</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>