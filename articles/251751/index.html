<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Proof of the incorrect sorting algorithm Android, Java and Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tim Peters developed the Timsort hybrid sorting algorithm in 2002. The algorithm is a skillful combination of ideas of merge sorting and sorting inser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Proof of the incorrect sorting algorithm Android, Java and Python</h1><div class="post__text post__text-html js-mediator-article">  Tim Peters developed the <a href="http://ru.wikipedia.org/wiki/Timsort">Timsort hybrid sorting algorithm</a> in 2002.  The algorithm is a skillful combination of ideas of merge sorting and sorting inserts and sharpened to work effectively with real data.  Timsort was first developed for Python, but then <a href="http://en.wikipedia.org/wiki/Joshua_Bloch">Joshua Bloch</a> (the creator of the Java collections, who, incidentally, noted that <a href="http://habrahabr.ru/post/203398/">most binary search algorithms contain an error</a> ) ported it to Java (the java.util.Collections.sort and java.util.Arrays methods .sort)  Today Timsort is the standard sorting algorithm in the Android SDK, Oracle JDK and OpenJDK.  Given the popularity of these platforms, it can be concluded that computers, cloud services, and mobile devices that use Timsort for sorting are worth billions. <br><br>  But back in 2015 year.  After we successfully verified the Java implementations of <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D0%25BF%25D0%25BE%25D0%25B4%25D1%2581%25D1%2587%25D1%2591%25D1%2582%25D0%25BE%25D0%25BC">sorting by counting</a> and <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2580%25D0%25B0%25D0%25B7%25D1%2580%25D1%258F%25D0%25B4%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0">bitwise sorting</a> ( <a href="http://link.springer.com/article/10.1007%252Fs10817-013-9300-y">J. Autom. Reasoning 53 (2), 129-139</a> ) with our formal verification tool called <a href="http://www.key-project.org/">KeY</a> , we looked for a new object to learn.  Timsort seemed to be a suitable candidate, because it is quite complex and widely used.  Unfortunately, we could not prove its correctness.  The reason for this, when examined in detail, turned out to be simple: there is a bug in the Timsort implementation.  Our theoretical studies have shown us where to look for the error (curiously, the error was already in the Python implementation).  This article describes how we achieved this. <br><br>  An article with a more complete analysis, as well as several test programs are available on <a href="http://www.envisage-project.eu/timsort-specification-and-verification/">our website</a> . <br><a name="habracut"></a><br>  <b>Content</b> <br><ol><li>  <a href="https://habr.com/ru/post/251751/">Timsort implementation bug on Android, Java and Python</a> <br>  <a href="https://habr.com/ru/post/251751/">1.1 Reproduce Timsort bug in Java</a> <br>  <a href="https://habr.com/ru/post/251751/">1.2 How does Timsort work?</a> <br>  <a href="https://habr.com/ru/post/251751/">1.3 Bug Timsort step by step</a> </li><li>  <a href="https://habr.com/ru/post/251751/">Proof of (not) correct Timsort</a> <br>  <a href="https://habr.com/ru/post/251751/">2.1 KeY Verification System</a> <br>  <a href="https://habr.com/ru/post/251751/">2.2 Correction and its formal specification</a> <br>  <a href="https://habr.com/ru/post/251751/">2.3 Analysis of the results of KeY</a> </li><li>  <a href="https://habr.com/ru/post/251751/">Proposed bug fixes for Timsort implementations in Python and Android / Java</a> <br>  <a href="https://habr.com/ru/post/251751/">3.1 Incorrect function merge_collapse (Python)</a> <br>  <a href="https://habr.com/ru/post/251751/">3.2 Corrected merge_collapse (Python) function</a> <br>  <a href="https://habr.com/ru/post/251751/">3.3 Incorrect mergeCollapse function (Java / Android)</a> <br>  <a href="https://habr.com/ru/post/251751/">3.4 Corrected mergeCollapse function (Java / Android)</a> </li><li>  <a href="https://habr.com/ru/post/251751/">Conclusion: what conclusions follow from this?</a> </li></ol><br><h2><a name="sec1"></a>  1. A bug in the Timsort implementation on Android, Java and Python </h2><br>  So what is the bug?  And why don't you try to play it yourself? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3><a name="sec11"></a>  1.1 Reproduce Timsort bug in Java </h3><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">git</span></span> clone https://github.com/abstools/java-timsort-bug.git cd java-timsort-bug javac <span class="hljs-regexp"><span class="hljs-regexp">*.java</span></span> java TestTimSort <span class="hljs-number"><span class="hljs-number">67108864</span></span></code> </pre> <br>  <b>If a bug is present, you will see this result.</b> <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Exception</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">thread</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span>" <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ArrayIndexOutOfBoundsException</span></span>: 40 <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.util</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TimSort</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.pushRun</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TimSort</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.java</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:413)</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.util</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TimSort</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.sort</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TimSort</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.java</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:240)</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.util</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Arrays</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.sort</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Arrays</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.java</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:1438)</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">TestTimSort</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TestTimSort</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.java</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:18)</span></span></code> </pre><br>  <strong>Video playback playback errors</strong> <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/HSyJ8f7h0jI%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700253&amp;usg=ALkJrhhXcH3GqbeVHorH5Y9vmwSng1JFug" frameborder="0" allowfullscreen=""></iframe><br><br><h3><a name="sec12"></a>  1.2 How does Timsort work? </h3><br>  Timsort is a hybrid algorithm that uses insert sorting and merge sorting. <br><br>  The algorithm reorders the input array from left to right, finding in it consecutive (non-overlapping) sorted segments (‚Äúseries‚Äù, or runs).  If the series is shorter than a certain minimum length, it is supplemented by subsequent elements and sorted by insertion.  The lengths of the created series are added to the end of the <b>runLen</b> array.  When a new series is added to <b>runLen</b> , the mergeCollapse method merges the series until the last three elements in <b>runLen</b> satisfy the following pair of conditions, which is called the " <b>invariant</b> ": <br><br><ol><li>  <b>runLen</b> [n-2]&gt; <b>runLen</b> [n-1] + <b>runLen</b> [n] </li><li>  <b>runLen</b> [n-1]&gt; <b>runLen</b> [n] </li></ol><br>  Here n is the index of the last series in runLen.  The idea was that checking this invariant for the last three series guarantees that all successive triples of series will satisfy it.  At the end, all the series are merged, resulting in a fully sorted input array. <br><br>  For reasons of efficiency, it is desirable to allocate as little memory as possible under <b>runLen</b> , but it should be enough for all the series to fit there.  If the invariant is satisfied for all series, the length of the series will grow exponentially (even faster than the Fibonacci numbers: the length of each series is strictly greater than the sum of the lengths of the next two).  Since the series do not overlap, they will not need much to completely sort even a huge input array. <br><br><h3><a name="sec13"></a>  1.3 Bug Timsort step by step </h3><br>  The following code snippet shows that the implementation of mergeCollapse checks an invariant for the last three series in <b>runLen</b> : <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mergeCollapse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (stackSize &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = stackSize - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; runLen[n-<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= runLen[n] + runLen[n+<span class="hljs-number"><span class="hljs-number">1</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (runLen[n - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; runLen[n + <span class="hljs-number"><span class="hljs-number">1</span></span>]) n--; mergeAt(n); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (runLen[n] &lt;= runLen[n + <span class="hljs-number"><span class="hljs-number">1</span></span>]) { mergeAt(n); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   } } }</span></span></code> </pre><br>  Unfortunately, this is not enough for all series to satisfy the invariant.  Suppose that <b>runLen</b> contains such a set of lengths before executing mergeCollapse (n = 4): <br><pre> <code class="hljs">120, 80, 25, 20, 30</code> </pre> <br>  On the first pass of the while loop, series of lengths 25 and 20 will be combined (since 25 &lt;20 + 30 and 25 &lt;30): <br><pre> <code class="hljs">120, 80, 45, 30</code> </pre> <br>  In the second pass of the cycle (now n = 3), we determine that the invariant is set for the last three series, because 80&gt; 45 + 30 and 45&gt; 30, so the mergeCollapse ends the work.  <b>But mergeCollapse did not restore the invariant for the whole array: it is broken in the first three, since 120 &lt;80 + 45.</b> <br><br>  The test generator on our <a href="http://www.envisage-project.eu/timsort-specification-and-verification/">website</a> allows you to identify this problem.  It creates an input array with many short series, while their length does not satisfy the invariant, which leads to the fall of Timsort.  The real reason for the error is that due to the violation of the invariant, the length of the series grows slower than expected, resulting in their number exceeds <b>runLen.length</b> and this leads to an ArrayOutOfBoundsException. <br><br><h2><a name="sec2"></a>  2. Proof of (Incorrect) Timsort </h2><br>  We found that the mergeCollapse invariant is violated when we tried to formally verify Timsort.  Fortunately, we also understood how to fix it.  As a result, we even managed to verify the corrected version, in which the invariant is actually observed.  But let's not hurry.  To begin with, let's see what a formal verification is and how it is performed. <br><br><h3><a name="sec21"></a>  2.1 KeY Verification System </h3><br>  <a href="http://www.key-project.org/">KeY</a> is a deductive verification platform for single-threaded Java and JavaCard programs.  It allows you to <b><i>prove the</i></b> correctness of programs for a given specification.  Roughly speaking, the specification consists of <b>preconditions</b> (in terms of KeY - <b>requires</b> ) and <b>postconditions</b> (in terms of KeY - <b>ensures</b> ).  Specifications are given before the methods that implement them (for example, before the mergeCollapse () mentioned above).  The specification of a method is also called its <b>contract</b> . <br><br>  In the case of sorting, the precondition simply states that a non-empty array is fed to the input, and the post-condition requires that the resulting array be sorted and be a permutation of the input.  The KeY system proves that if a verifiable method is called with input data that satisfies the preconditions, then the method will end normally and the resulting state will satisfy the postcondition.  This is also called <b>complete correctness</b> , because the normal completion of the method is also proved.  As we saw, the java.util.Arrays.sort () method from OpenJDK does not honor this contract, because for certain input data it ends with an exception. <br><br>  Additionally, class and object invariants are used to indicate general constraints on field values.  The consistency of data or boundary conditions is usually checked: <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*@ private invariant @ runBase.length == runLen.length &amp;&amp; runBase != runLen; @*/</span></span></code> </pre><br>  This invariant says that the lengths of the runBase and runLen arrays must match, but at the same time they must be two different arrays.  The semantics of invariants implies that each output method must not only provide the postconditions of its contract, but also the invariants of its own object ‚Äúthis‚Äù. <br><br>  KeY uses the <a href="http://www.jmlspecs.org/">Java Modeling Language</a> (JML) as its specification language.  Expressions on it are written in the usual Java language, so Java programmers can easily master it.  The main JML extension is quantifiers ( <b>\ forall</b> T x - for any T, <b>\ exists</b> T x - there is T) and, of course, special keywords for contracts.  JML specifications are provided in java-file comments before the code to which they refer.  The following is a simple example of a Java method with a JML specification: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*@ private normal_behavior @ requires @ n &gt;= MIN_MERGE; @ ensures @ \result &gt;= MIN_MERGE/2; @*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">/*@ pure @*/</span></span> minRunLength(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> n &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  1          /*@ loop_invariant n &gt;= MIN_MERGE/2 &amp;&amp; r &gt;=0 &amp;&amp; r&lt;=1; @ decreases n; @ assignable \nothing; @*/ while (n &gt;= MIN_MERGE) { r |= (n &amp; 1); n &gt;&gt;= 1; } return n + r; }</span></span></code> </pre><br>  The minRunLength () contract contains one precondition: the input parameter must be no less than MIN_MERGE.  In this case (and only in this) the method promises to end normally (do not get hung up and do not throw an exception) and return a value that is greater than or equal to MIN_MERGE / 2.  Additionally, the method is marked as <b>pure</b> .  This means that the method does not modify the heap. <br><br>  The key point is that the KeY system is able to <b>statically</b> prove contracts of similar methods for <b>any</b> input parameters.  How is this possible?  KeY performs symbolic execution of a verifiable method, that is, executes it using character values, so that all possible execution paths are taken into account.  But this is not enough, because the symbolic execution of loops with a non-fixed number of iterations (such as a loop in mergeCollapse (), where we don‚Äôt know the value of stackSize) will never end.  To make the symbolic execution of loops finite, the logic of invariants is used.  For example, the above minRunLength () method contains a cycle, the specification of which is expressed by a cycle invariant.  The invariant states that after each iteration the condition <code>n &gt;= MIN_MERGE/2 &amp;&amp; r &gt;= 0 &amp;&amp; r &lt;= 1</code> is satisfied, and from this one can prove the postcondition of the entire method.  The summary, <b>Redu,</b> is used to prove the end of a loop.  It indicates an expression whose value is non-negative and strictly decreases.  The <b>assignable</b> construct lists heap objects that can be modified in a loop.  The keyword <b>\ nothing</b> means that the heap is not modified.  And indeed: the loop changes only the local variable r and the argument n. <br><br>  In general, there are not enough method contracts for formal verification.  It is also necessary to provide cycle invariants.  Sometimes it is very difficult to come up with an invariant that is observed in a cycle and is strong enough to derive the post-condition of the method from it.  Without instrumental support and the technology of automated proof of theorems, it is hardly possible to make correct cycle invariants in non-trivial programs.  In fact, this is where the Timsort creators mistake lies.  Under certain conditions, a loop in mergeCollapse violates the following invariant of the Timsort class (see section <a href="http://sec13/">1.3 Timsort Bug Step by Step</a> ): <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*@ private invariant @ (\forall int i; 0&lt;=i &amp;&amp; i&lt;stackSize-4; @ runLen[i] &gt; runLen[i+1] + runLen[i+2])) @*/</span></span></code> </pre><br>  This invariant states that runLen [i] must be greater than the sum of two subsequent elements, for any non-negative i, less than stackSize-4.  The invariant is not restored even after the loop, so the entire mergeCollapse method does not save the class invariant.  Therefore, the loop invariant is not as strict as the developers assumed.  This is what we discovered during our attempt to verify Timsort with KeY.  Without a special tool, it would be almost impossible to detect. <br><br>  Although JML is very similar to Java, it is a full-fledged contract programming language suitable for full functional verification of Java programs. <br><br><h3><a name="sec22"></a>  2.2 Correction and its formal specification </h3><br>  <i>A simplified</i> version of the contract, which according to the authors' idea should be respected in mergeCollapse, is given below. <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*@ requires @ stackSize &gt; 0 &amp;&amp; @ runLen[stackSize-4] &gt; runLen[stackSize-3]+runLen[stackSize-2] @ &amp;&amp; runLen[stackSize-3] &gt; runLen[stackSize-2]; @ ensures @ (\forall int i; 0&lt;=i &amp;&amp; i&lt;stackSize-2; @ runLen[i] &gt; runLen[i+1] + runLen[i+2]) @ &amp;&amp; runLen[stackSize-2] &gt; runLen[stackSize-1] @*/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mergeCollapse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre><br>  Two <b>ensured formulas</b> imply that when mergeCollapse is completed, <b><i>all</i></b> series satisfy the invariant given in <a href="https://habr.com/ru/post/251751/">section 1.2</a> .  We have already seen that this contract is not being executed in the current implementation of mergeCollapse ( <a href="https://habr.com/ru/post/251751/">section 1.3</a> ).  Now we present a revised version that honors the contract: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newMergeCollapse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (stackSize &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = stackSize - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; runLen[n-<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= runLen[n] + runLen[n+<span class="hljs-number"><span class="hljs-number">1</span></span>] || n-<span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; runLen[n-<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;= runLen[n] + runLen[n-<span class="hljs-number"><span class="hljs-number">1</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (runLen[n - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; runLen[n + <span class="hljs-number"><span class="hljs-number">1</span></span>]) n--; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> || runLen[n] &gt; runLen[n + <span class="hljs-number"><span class="hljs-number">1</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   } mergeAt(n); } }</span></span></code> </pre><br>  The main idea of ‚Äã‚Äãthis version is to check that the invariant is observed for the <i>last four series</i> in runLen instead of <i>three</i> .  As we will see below, this is enough for the lengths of <b>all</b> series to satisfy the invariant after the mergeCollapse is completed. <br><br>  The first step in proving a contract for a revised version of mergeCollapse is to find a suitable loop invariant.  Here is its simplified version: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*@ loop_invariant @ (\forall int i; 0&lt;=i &amp;&amp; i&lt;stackSize-4; @ runLen[i] &gt; runLen[i+1] + runLen[i+2]) @ &amp;&amp; runLen[stackSize-4] &gt; runLen[stackSize-3]) @*/</span></span></code> </pre><br>  Intuitively, the cycle invariant states that all series except, perhaps, the last four, satisfy the condition.  In this case, we note that the cycle ends (according to the break operator) only if the last four series also satisfy it.  Thus, it is possible to guarantee that all series satisfy the invariant. <br><br><h3><a name="sec23"></a>  2.3 Analysis of the results of KeY </h3><br>  When we feed KeY with a corrected version of mergeCollapse along with a contract and a cycle invariant, the system performs a symbolic execution of the cycle and generates verification conditions: formulas that imply that the mergeCollapse contract is fulfilled.  The following (simplified) formula shows the main condition for proving the correctness of a mergeCollapse generated by KeY: <br><br><img src="http://habrastorage.org/getpro/habr/post_images/987/b13/cfe/987b13cfef5913dfc19ff3677c7960f6.png" width="450"><br><br>  The formula states that the conditions in brackets that are true after the end of the cycle should follow the post condition mergeCollapse.  It is clear where the expressions in brackets came from: the break statement that completes the loop is executed only when they are all true.  We formally proved this formula (and all other verification conditions) with the help of KeY in semi-automatic mode.  The following is a sketch of evidence: <br><br>  <i>Proof</i> .  The formula <i>runLen [stackSize-2]&gt; runLen [stackSize-1]</i> from the post-condition mergeCollapse directly follows from <i>n&gt; = 0 ==&gt; runLen [n]&gt; runLen [n + 1]</i> . <br><br>  We prove the following formula: <br><br>  <i>\ forall int i;</i>  <i>0 &lt;= i &amp;&amp; i &lt;stackSize-2;</i>  <i>runLen [i]&gt; runLen [i + 1] + runLen [i + 2]</i> . <br><br>  The following options are possible i: <br><br><ul><li>  i &lt;stackSize-4: corresponds to the loop invariant </li><li>  i = stackSize-4: follows from n&gt; 1 ==&gt; runLen [n-2]&gt; runLen [n-1] + runLen [n] </li><li>  i = stackSize-3: follows from n&gt; 0 ==&gt; runLen [n-1]&gt; runLen [n] + runLen [n + 1] </li></ul><br>  This proof shows that the new version of <i>mergeCollapse is</i> completed only when <b>all</b> series satisfy the invariant. <br><br><h2><a name="sec3"></a>  3. Proposed bug fixes for Timsort implementations in Python and Android / Java </h2><br>  Our error analysis (including the <i>mergeCollapse</i> fix) has been sent, reviewed and accepted into the <a href="https://bugs.openjdk.java.net/browse/JDK-8072909">Java bugtracker</a> . <br><br>  The bug is present at least in the Java version for Android, OpenJDK and OracleJDK: all use the same Timsort code.  Also a bug is present in Python.  The following sections provide the original and revised versions. <br><br>  As mentioned above, the idea of ‚Äã‚Äãa fix is ‚Äã‚Äãvery simple: check that the invariant is executed for the last four series in runLen, and not just for three. <br><br><h3><a name="sec31"></a>  3.1 Incorrect function merge_collapse (Python) </h3><br>  Timsort for Python (written in C using the Python API) is available <a href="">in the subversion repository</a> - Algorithm is also described <a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">here</a> . <br><br>  The Timsort version for Java was ported with CPython.  The CPython version contains an error, designed to support arrays of up to 2 <sup>64</sup> elements, also contains an error.  However, it is impossible to cause an array overflow error on modern machines: the algorithm allocates 85 elements for runLen, and this is enough (as our analysis shows in the full article) for arrays containing no more than 2 <sup>49</sup> elements.  For comparison, the most powerful supercomputer to date <a href="http://en.wikipedia.org/wiki/Tianhe-2">Tianhe-2</a> has 2 <sup>50</sup> bytes of memory. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* The maximum number of entries in a MergeState's * pending-runs stack. * This is enough to sort arrays of size up to about * 32 * phi ** MAX_MERGE_PENDING * where phi ~= 1.618. 85 is ridiculously large enough, * good for an array with 2**64 elements. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_MERGE_PENDING 85 merge_collapse(MergeState *ms) { struct s_slice *p = ms-&gt;pending; assert(ms); while (ms-&gt;n &gt; 1) { Py_ssize_t n = ms-&gt;n - 2; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (n &gt; 0 &amp;&amp; p[n-1].len &lt;= p[n].len + p[n+1].len) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p[n-1].len &lt; p[n+1].len) --n; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (merge_at(ms, n) &lt; 0) return -1; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p[n].len &lt;= p[n+1].len) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (merge_at(ms, n) &lt; 0) return -1; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> break; } return 0; }</span></span></code> </pre><br><h3><a name="sec32"></a>  3.2 Corrected merge_collapse (Python) function </h3><br><pre> <code class="cpp hljs">merge_collapse(MergeState *ms) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_slice</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ms</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pending</span></span></span><span class="hljs-class">;</span></span> assert(ms); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ms-&gt;n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { Py_ssize_t n = ms-&gt;n - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; p[n<span class="hljs-number"><span class="hljs-number">-1</span></span>].len &lt;= p[n].len + p[n+<span class="hljs-number"><span class="hljs-number">1</span></span>].len || (n<span class="hljs-number"><span class="hljs-number">-1</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; p[n<span class="hljs-number"><span class="hljs-number">-2</span></span>].len &lt;= p[n].len + p[n<span class="hljs-number"><span class="hljs-number">-1</span></span>].len)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[n<span class="hljs-number"><span class="hljs-number">-1</span></span>].len &lt; p[n+<span class="hljs-number"><span class="hljs-number">1</span></span>].len) --n; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (merge_at(ms, n) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[n].len &lt;= p[n+<span class="hljs-number"><span class="hljs-number">1</span></span>].len) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (merge_at(ms, n) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><h3><a name="sec33"></a>  3.3 Incorrect mergeCollapse function (Java / Android) </h3><br>  The error is completely similar to the error in Python: <br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mergeCollapse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (stackSize &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = stackSize - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; runLen[n-<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= runLen[n] + runLen[n+<span class="hljs-number"><span class="hljs-number">1</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (runLen[n - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; runLen[n + <span class="hljs-number"><span class="hljs-number">1</span></span>]) n--; mergeAt(n); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (runLen[n] &lt;= runLen[n + <span class="hljs-number"><span class="hljs-number">1</span></span>]) { mergeAt(n); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   } } }</span></span></code> </pre><br><h3><a name="sec34"></a>  3.4 Corrected mergeCollapse function (Java / Android) </h3><br>  The fix is ‚Äã‚Äãsimilar to the one above for Python. <br>  [UPDATE 26/2: we changed the code from the original version of the article.  The old code was equivalent, but contained redundant checks and differed in style.  Thanks to everyone who noticed!] <br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newMergeCollapse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (stackSize &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = stackSize - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (n &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; runLen[n-<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= runLen[n] + runLen[n+<span class="hljs-number"><span class="hljs-number">1</span></span>]) || (n &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; runLen[n-<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;= runLen[n] + runLen[n-<span class="hljs-number"><span class="hljs-number">1</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (runLen[n - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; runLen[n + <span class="hljs-number"><span class="hljs-number">1</span></span>]) n--; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (runLen[n] &gt; runLen[n + <span class="hljs-number"><span class="hljs-number">1</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   } mergeAt(n); } }</span></span></code> </pre><br><h2><a name="sec4"></a>  4. Conclusion: which conclusions follow from this? </h2><br>  When trying to verify Timsort, we were unable to establish an invariant of the sort object.  Analyzing the reasons for the failure, we found an error in the Timsort implementation, which causes an ArrayOutOfBoundsException for certain input data.  We suggested correcting an erroneous method (without a perceptible reduction in performance) and formally proved that the correction is correct and there is no more error. <br><br>  From this story, in addition to the actual error found, several observations can be made. <br><ol><li>  Programmers often consider formal methods impractical and / or far from real tasks.  This is not the case: we found and fixed a software bug that billions of users use every day.  As our analysis showed, it would be almost impossible to find and fix such a bug without formal analysis and a tool for verification.  Error for many years lived in the standard library of languages ‚Äã‚ÄãJava and Python.  Its manifestations were <a href="https://bugs.openjdk.java.net/browse/JDK-8011944">noticed earlier</a> and even thought that they had corrected, but in reality they only achieved that the error began to occur less frequently. </li><li>  Although it is unlikely that such an error will occur by chance, it is easy to imagine how it can be used to attack.  Probably, in the standard libraries of popular programming languages ‚Äã‚Äãlie other unnoticed errors.  Maybe it is worth to look for them before they cause harm or will be used by hackers? </li><li>  The response of Java developers to our report is somewhat disappointing.  Instead of using our corrected (and verified!) Version of mergeCollapse (), they <a href="http://hg.openjdk.java.net/jdk9/dev/jdk/rev/e276aa5b8a4b">preferred to increase the</a> selected runLen size to ‚Äúsufficient‚Äù size.  As we have shown, it was not at all necessary to do so.  But now everyone who uses java.utils.Collection.sort () will have to spend more memory.  Given the astronomical number of programs that use such a basic function, this will lead to noticeable additional energy costs.  We can only guess why our decision was not made: perhaps the JDK developers did not bother to read our report completely and therefore did not understand the essence of the fix and decided not to rely on it.  In the end, OpenJDK develops a community largely composed of volunteers who do not have much time. </li></ol><br><br>  What conclusions follow from this?  We would be happy if our work served as a starting point for closer interaction between researchers of formal methods and developers of open software platforms.  Formal methods are already being successfully applied in <a href="http://research.microsoft.com/en-us/um/people/lamport/tla/formal-methods-amazon.pdf">Amazon</a> and <a href="https://research.facebook.com/publications/422671501231772/moving-fast-with-software-verification/">Facebook</a> .  Modern languages ‚Äã‚Äãof formal specification and formal verification tools <b>are not</b> so confusing and super-complex to learn.  Their usability and automation is constantly improving.  But we need more people to try, test and use our tools.  Yes, it will take some effort to start writing formal specifications and verifying the code, but this is no more difficult than, for example, figuring out how to use the compiler or the project build tool.  But we are talking about days or weeks, not months or years.  Well, how <b>do you</b> accept the challenge? <br><br>  Best wishes, <br>  <a href="https://www.cwi.nl/people/2306">Stein de Gove</a> , <a href="http://jurriaan.me/">Jurian Roth</a> , <a href="http://homepages.cwi.nl/~frb/">Frank de Boer</a> , <a href="https://www.se.tu-darmstadt.de/se/group-members/richard-bubel/">Richard Bubel</a> and <a href="https://www.se.tu-darmstadt.de/se/group-members/reiner-haehnle/">Rainer Henle</a> . <br><br><h4>  Thanks </h4><br>  This work was partially supported by the project of the seventh framework program of the European Union FP7-610582 ENVISAGE: <a href="http://www.envisage-project.eu/">Engineering Virtualized Services</a> . <br>  This article would not have been written without the support and polite reminders of <a href="http://memkite.com/team/">Amunde Tveit</a> !  We also want to thank Beruza Nobacte for providing us with a video showing an error. <br><br><img src="http://habrastorage.org/getpro/habr/post_images/28e/d55/c0a/28ed55c0ad2cfa8b7346d26938cd17b4.gif" alt="Envisage logo" width="240" height="80"></div><p>Source: <a href="https://habr.com/ru/post/251751/">https://habr.com/ru/post/251751/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../251723/index.html">Create your first desktop application with HTML, JS and Node-WebKit</a></li>
<li><a href="../251729/index.html">Practice functional JavaScript programming using Ramda</a></li>
<li><a href="../251745/index.html">MongoDB 3 Announcement</a></li>
<li><a href="../251747/index.html">Do it yourself: MSc Computer Science at the level of top American universities from home</a></li>
<li><a href="../251749/index.html">FindBugs 3.0.1 released</a></li>
<li><a href="../251755/index.html">Visualize it</a></li>
<li><a href="../251757/index.html">Work on the modernization of the explorer in ReactOS completed</a></li>
<li><a href="../251759/index.html">Some interesting and useful things for web developer # 40</a></li>
<li><a href="../251765/index.html">Filling text templates with model-based data. Implementing on .NET using dynamic functions in bytecode (IL)</a></li>
<li><a href="../251777/index.html">Feedback of the PVS-Studio team on the C ++ Russia conference, 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>