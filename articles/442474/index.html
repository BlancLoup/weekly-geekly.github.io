<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>On the evaluation and management of software development</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The institute is taught algorithms, data structures, OOP. In a good case, they can talk about design patterns or multi-threaded programming. But I did...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>On the evaluation and management of software development</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/155/f80/f35/155f80f351f5371e12b168498bbb3b97.jpg" alt="image"><br><br>  The institute is taught algorithms, data structures, OOP.  In a good case, they can talk about design patterns or multi-threaded programming.  But I did not hear about the fact that they were told how to correctly estimate labor costs. <br><br>  Meanwhile, this skill is necessary for any programmer every day.  There is always more work than can be done.  Evaluation helps to prioritize the right, and at all to abandon any tasks.  Not to mention such domestic issues as budgeting and planning.  Invalid estimates, on the contrary, create a bunch of problems: understated - conflict situations, processing and holes in budgets, overestimated - cancellation of projects or searches for other performers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To be fair, it should be noted that underestimated estimates are much more common in the design.  Why?  Someone thinks that programmers are <a href="https://habr.com/ru/post/178905/">too optimistic</a> by nature.  I will add another reason to this: being a good programmer and being a good appraiser are not the same thing.  To become a good programmer of one desire is not enough.  Need knowledge and practice.  Why would the assessment be different? <br><br>  In the article I will talk about how my attitude to the assessment of tasks has changed and how projects in our company are being evaluated now.  And I'll start with how to evaluate is not necessary.  If you already know how to ‚Äúdo not‚Äù, go directly to the <a href="https://habr.com/ru/post/442474/">second part of the article</a> . <a name="habracut"></a><br><br><h1>  Anti-evaluation patterns </h1><br>  Most assessments in projects are done at the beginning of their life cycle.  And this does not confuse us until we understand that the estimates are obtained before the requirements are defined, and accordingly before the task itself is studied.  Therefore, the assessment is usually done at the wrong time.  This process is correctly called not an estimate, but a guessing or a prediction, because every spot in the requirements is a guessing game.  How much does this uncertainty affect the final assessment results and its quality? <br><br><h3>  Trifle, but unpleasant </h3><br><img src="https://habrastorage.org/storage2/2ea/9a5/2ed/2ea9a52edb82bbf3069a65cfc2d2a211.jpg" alt="image" align="right">  Suppose you are developing a system for entering orders, but have not yet been able to work out the requirements for entering phone numbers.  Among the uncertainties that can affect the evaluation of the program, the following can be highlighted: <br><br><ol><li>  Does the client need the phone number to be checked for validity? </li><li>  If the customer needs a phone number verification system, which version will he prefer - cheap or expensive? </li><li>  If you implement a cheap version of checking phone numbers, will the client want to switch to an expensive one later? </li><li>  Is it possible to use a ready-made system for checking phone numbers or, due to some design restrictions, do you need to develop your own? </li><li>  How will the verification system be designed? </li><li>  How long does it take to program a phone number verification system? </li></ol><br>  And these are just a few questions from the list that arises in the head of an experienced project manager ... As can be seen even from this example, potential differences in the definition, design and implementation of the same opportunities can accumulate and increase the implementation time by hundreds or more times.  And if we combine them in hundreds and thousands of functions of a large project, we will get a tremendous uncertainty in the evaluation of the project itself. <br><blockquote>  Another excellent example of the ‚Äúswelling‚Äù would seem to be an elementary requirement in the article " <a href="https://habr.com/ru/company/infopulse/blog/170777/">How two weeks ?!</a> " </blockquote><br><h3>  Cone of uncertainty </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/429/edc/a33/429edca3349d48734e519ef4e01342ba.png" alt="image"><br><br>  Software development - and many other projects - consists of thousands of solutions.  The researchers found that project estimates at different stages have predictable levels of uncertainty.  The cone of uncertainty shows that the estimates become more accurate as the project progresses.  Please note that at the initial concept stage (where assessments are often made and commitments are taken), the error may reach 400% (four hundred percent, Karl!).  Optimal commitments after the completion of detailed design. <br><br><h3>  Mythical man-month </h3><br>  Until now, there are managers who believe that if the functionality is rigidly fixed, a reduction in the period can be achieved at any time by adding personnel who would do more work in less time.  The error of such reasoning lies in the unit itself used in the assessment and planning: man-month.  Cost is actually measured as the product of the number of employees and the number of months spent.  But not the achieved result.  Therefore, the use of person-months as a unit of measurement of the volume of work is a dangerous delusion.  All researchers agreed that reducing the nominal term increases the total amount of work.  If the nominal term for a group of 7 people is 12 months, then a simple increase in staff up to 12 people will not reduce the period to 7 months. <br><br>  In large groups, the costs of coordination and management increase, and the number of communication paths is growing.  If all parts of the task must be separately coordinated with each other, the costs of communication grow quadratically, and the team‚Äôs ‚Äúpower‚Äù is linear.  For three workers, three times more pair-wise communication is required than for two, for four workers it is six times as much. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/12e/ca6/dc1/12eca6dc1b9b953c11e6dfad5c2d52e3.jpg" alt="image"><br>  <i>The project team is trying to cope with abrasions // Ivan Aivazovsky, 1850</i> <br><br><blockquote>  If 8 people can write a program in 10 months, can 80 people write the same program in one month?  The inefficiency of deadlines is especially evident in extreme cases, such as the 1600 people who have to write a program in one day.  Read more about this in the <a href="https://www.ozon.ru/context/detail/id/83760/">eponymous book by Frederick Brooks</a> . </blockquote><br><h1><a name="patterns"></a>  Evaluation patterns </h1><br>  So, everything is clear with the problems.  What can be done? <br><br><h3>  Decomposition </h3><br>  Instead of estimating a large task, it is better to divide it into many small ones, evaluate them, and get the final assessment as a sum of initial estimates.  Thus, we kill as many as four birds with one stone: <br><br><ol><li>  We better understand the scope of work.  To decompose a task, you need to read the requirements.  Immediately float strange places.  Reduces the risk of misinterpreting the requirements. </li><li>  During the analysis of a more detailed analysis of requirements, the mental process of knowledge systematization is automatically launched.  This reduces the risk of forgetting some part of the work, such as refactoring, testing automation or additional labor costs for laying out and deploying </li><li>  The result of the decomposition can be used for project management, provided that one tool was used for both processes (this issue is discussed in more detail later in the text). </li><li>  If you measure the average error of the estimate of each task obtained during decomposition and compare this error with the error of the total assessment, it turns out that the total error is less than the average.  In other words, such an assessment is more accurate (closer to the real labor costs).  At first glance, this statement is counter-intuitive.  How can the final assessment be more accurate if we make a mistake in evaluating each decomposed task?  Consider an example.  In order to create a new form, you need to a) write code on the backend, b) impose a layout and write code on the frontend, c) test and lay out.  Task A was rated for 5 hours, Task B and C for 3 hours each.  The total score was 11 hours.  In reality, the backend was done in 2 hours, it took 4 on the form, and another 5 were spent on testing and fixing bugs. The total workload was 11 hours.  The perfect hit in the assessment.  In this case, the error of the task A evaluation is 3 hours, the tasks B - 1 hour, B - 2 hours.  The average error is 3 hours.  The fact is that the errors of underestimation and overestimation of the assessment compensate each other.  The 3 hours saved on the backend compensated for the backlog at 1 and 2 hours during the frontend and testing.  Real work is a random variable depending on many factors.  If you get sick, it will be difficult to concentrate and instead of three hours it can take six.  Or some unexpected bug will pop up that will have to be searched and corrected all day.  Or, on the contrary, it may turn out that instead of writing your component, you can use an existing one, etc.  Positive and negative deviations will compensate each other.  Thus, the total error will be reduced. </li></ol><br>
<h3>  Features and Tasks </h3><br><img src="https://habrastorage.org/webt/pv/ip/qb/pvipqbfc1rusvgler3rfvysfnp0.jpeg" align="right"><br>  At the heart of the decomposition we have Feature.  A feature is a unit of delivery of functionality that can be put on production independently of others.  Sometimes this level is called User Story, but we came to the conclusion that User Story is not always well suited for setting tasks, so we decided to use a more general formulation. <br><br>  For one feature, one member of the team is responsible.  Someone can help him with the implementation, but one person passes to testing.  The task is also returned to him for revision.  Depending on the organization of the team, this could be a team lead or the developer directly. <br><br>  Unfortunately, sometimes there are great features.  Alone, working on this volume will take a very long time.  And a long time will have to test and implement the process of acceptance.  Then we change the type of task to epic (Epic).  Epic is just a very fat feature.  Nothing more epic we do not start.  Those.  epics may just be big, huge or gigantic.  In any case, the acceptance of the epic is sent in parts (features). <br><br>  In order to evaluate more precisely, features are decomposed into separate subtasks (Task).  For example, a feature could be the development of a new CRUD interface.  The structure of tasks can look like this: ‚Äúdisplay a table with data‚Äù, ‚Äúfasten filtering and search‚Äù, ‚Äúdevelop a new component‚Äù, ‚Äúadd new tables to the database‚Äù.  The structure of tasks is usually not at all interesting for business, but it is extremely important for the developer. <br><br><h3>  Group Evaluation, Planning Poker </h3><br><img src="https://habrastorage.org/webt/ef/m9/aw/efm9awmzy6ibwje2d9syps5tx5u.jpeg"><br><br>  Programmers are too optimistic about the amount of work.  According to various sources, underestimation of the most often varies in the range of 20-30%.  However, in groups, the error is reduced.  This is due to the best analysis due to different points of view and temperament evaluating. <br>  With the increasing popularity of Agile, the practice of " <a href="https://habr.com/ru/company/retailrocket/blog/334256/">poker planning</a> " has become most widespread. However, two problems are associated with group evaluation: <br><br><ol><li>  Social pressure </li><li>  Time spent </li></ol><br><h3>  Social pressure </h3><br>  In almost any group, the experience and personal effectiveness of the participants will vary.  If the team is a strong team / tech - lead / lead programmer, other members may feel a sense of discomfort and deliberately underestimate ratings: ‚ÄúWell, Vasya can, but what's worse?  I can do that too!".  The reasons may be different: the desire to appear better than it actually is, competitiveness or just conformism.  The result is one: group assessment loses all its advantages and becomes individual.  Timlid assesses the rest, and the rest simply endorse him. <br><blockquote>  I pressed on the team for a long time in order to get ratings, more in line with my expectations.  This invariably led to a decrease in quality and failure to meet deadlines.  As a result, I changed my attitude and now my score often becomes the biggest.  During the discussion, I point out the potential problems that come to mind: ‚Äúhere refactoring would not hurt, here the structure of the database changes, it would be necessary to do a regression test‚Äù. </blockquote>  There are several basic recommendations: <br><br><ol><li>  Most of the estimates are understated.  Can't choose between two grades?  Take the one that is bigger. </li><li>  Not sure about the assessment - throw out the card "?"  or more appreciated.  Perhaps almost never carried by. </li><li>  Always compare plan and fact.  If you know that you do not fit in two times, let's estimate two times higher than what you think.  Began to overstate?  Multiply in mind by one and a half.  After several iterations, the quality of your assessments should improve significantly. </li></ol><br><h3>  Time spent </h3><br>  You know the phrase ‚ÄúDo you want to work?  Gather a meeting! ‚Äù  Not only does one programmer try to predict the future instead of writing code.  Now it makes the whole group.  In addition, group decision making is a much longer process than individual decision making.  Thus, group assessment is an extremely costly process.  It is worth looking at these costs from the other side.  First, in the evaluation process, the group is forced to discuss the requirements.  This means that you have to read them.  Already not bad.  Second, let's compare these costs with those incurred by the company due to underestimation of the project. <br><blockquote>  Many years ago, one November day, I changed jobs to a large company.  It immediately became clear to me that the work was in full swing.  Half the company worked to release the product before the end of the year.  But after about a week it seemed to me that they would not have time by the end of the year.  Every next day, the chances of success of this enterprise became more and more elusive ... The project was really passed in December, though next year.  I learned about this much later, because in the summer there were problems with the payment of wages to employees and I quit with about half of the staff.  You can say "well, of course, managers are fools, it was necessary to err."  They insured.  Half a year there were no problems with the payment of wages.  Keeping a stock of working capital for half a year of financing is not an easy task.  I think if the assessment were more accurate, there would be other management decisions at the top management level. </blockquote>  If we consider investments in valuation as investments in making right management decisions, they no longer seem so expensive.  Group size is another matter.  Of course, it is not necessary to force the whole team to evaluate the entire scope of work.  It is much more reasonable to divide the task by <s>modules</s> , ahem, micro-services and provide teams with autonomy.  And at a higher level, use the estimates obtained by each team to draw up a project plan.  Which brings us smoothly to the topic of the next paragraph. <br><br><h3>  Dependency, Gantt charts </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ed8/667/ee1/ed8667ee17cf45fcad67b979b9d5a6a8.jpg" alt="image"></div><br>  If estimates are usually given by programmers, then drawing up a project plan is the lot of middle managers.  Remember, I wrote that you can help these guys if you use one tool for decomposition and project management.  Score and calendar date is not the same.  For example, to display a simple table with data you need: <br><br><ol><li>  Table in DB </li><li>  Backend code </li><li>  Code on the frontend </li></ol><br>  To perform tasks in this order is easiest from a technical point of view.  However, in reality there are different specializations.  Frontend specialist may be released earlier.  Instead of standing idle, it is more logical for him to start developing the UI, replacing the request to the server with a mock or hard-coded data.  Then, by the time the API is ready, all that remains is to replace the code with a call to the real method ... in theory.  In practice, the maximum level of parallelism can be achieved as follows: <br><br><ol><li>  First, we quickly do the swagger to match the API specification. </li><li>  Then hardcode data on the back or at the front, depending on who is at hand. </li><li>  In parallel, we do database, backend and fronted.  The database and backend partially block each other, but most often these competencies are combined in one person and the work actually goes sequentially: first, backend, then backend </li><li>  We collect everything and test </li><li>  Fix bugs and test again </li></ol><br>  It is important that items 1, 4 and 5 are executed as quickly as possible to reduce the number of locks.  In addition to technological limitations and limitations in the availability of specialists of the necessary competence, there are also business priorities!  And this means that after three weeks a demonstration was already scheduled for an important client and he didn‚Äôt want to care about the first half of your project plan.  He wants to see the end result, which will be available no earlier than two months.  Well, then you have to prepare a separate plan for this demonstration.  We add in the plan to score the necessary data of the database, insert new links for transitions in the UI, etc.  It is also desirable that the result should be about 20% of the code, and not the entire demonstration. <br><br>  The artistic cutting of such a plan is not an easy task.  Dependency dependency greatly simplifies the process.  Before starting the report module, you need to make a data entry module.  Is it logical  Add a dependency.  Repeat for all related tasks.  Believe me, many of the dependencies will come as a surprise to you. <br><br>  The tasks of automating business processes usually result in several long ‚Äúsnakes‚Äù of related tasks. With several large blocking nodes.  Most often, the original plan is not efficient in terms of resource utilization and / or too long in calendar terms.  Revising the estimate of labor costs maybe get faster - not an option.  Estimation, so, most likely optimistic.  We have to go back to decomposition, look for too long chains and add additional ‚Äúforks‚Äù in order to increase the degree of parallelism.  Thus, by increasing the total labor costs (more people are working on one project in parallel), the project‚Äôs calendar time is reduced.  Remember the "mythical man month"?  Compress the plan by more than 30% is unlikely to work.  So that the budget and deadline agreed plan may be revised several times.  There are several techniques that make the process faster and easier. <br><br><h3>  Task lock </h3><br>  The first reason for blocking - dependencies - we have already considered.  In addition, there may simply be not clear / exact requirements.  A tool is needed to block tasks and ask questions.  With clarification of requirements, you can unlock tasks and adjust the assessment.  This process, by the way, almost always takes place during the project, and not before it. <br><br><h3>  Critical path, risks ahead </h3><br><blockquote>  The <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25BA%25D1%2580%25D0%25B8%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25BF%25D1%2583%25D1%2582%25D0%25B8">method of the critical path</a> is based on the determination of the longest task sequence from the beginning of the project to its completion, taking into account their interrelation.  Tasks that lie on a critical path (critical tasks) have a zero reserve of execution time, and, in the event of a change in their duration, the timing of the entire project changes.  In this regard, in carrying out a project, critical tasks require more careful monitoring, in particular, the timely identification of problems and risks affecting the deadlines for their implementation and, consequently, the timing of the project as a whole.  In the process of project implementation, the critical path of the project may change, as if the duration of the tasks changes, some of them may be on the critical path. </blockquote><br><img src="https://habrastorage.org/webt/rc/ml/ns/rcmlns100chhl2typquz3rfb7x4.png"><br><br>  In short, if you mess up with the structure of the database, you have to rewrite the Beck, do not calculate the load, you may have to change the technology altogether.  Details about the risks of design work, I wrote in the article " <a href="https://habr.com/ru/post/233221/">Cost-effective code</a> ."  The sooner the risks standing on the critical path materialize, the better.  After all, there is still time and something can be done.  Even better, if they do not materialize at all, but let's be realistic. <br><br>  Therefore, you need to start with the most turbid, difficult and unpleasant tasks, put them in the status of "blocked" and clarify, overestimate and remove dependencies wherever possible. <br><br><h3>  Acceptance criteria, test cases </h3><br><img src="https://habrastorage.org/storage2/879/31b/1d7/87931b1d714451471866861782fc85c8.png" align="right"><br>  Natural language: Russian, English or Chinese - it does not matter - it can be both redundant and not accurate.  <a href="https://habr.com/ru/post/166747/">Test cases</a> make it possible to overcome these limitations.  In addition, it is a good communication tool between developers, business users and the quality department. <br><br><h3>  Project management </h3><br>  Do you want to make God laugh?  Tell him about your plans.  Even if a miracle happened and you collected and clarified all the requirements before starting work, you have enough competent people, the plan allows you to do most of the work in parallel, you are still not immune to employee diseases, errors of assessment and materialization of other risks.  Therefore, it is necessary to update the plan on a regular basis and compare it with the fact.  And for this, the accounting of working time is important. <br><br><h3>  Time tracking aka time tracking </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a06/fe0/28e/a06fe028eed2c78fe889e182e635e1b3.jpg"></div><br><br>  Accounting for working time has long become the de facto standard in the industry.  It is highly desirable that it be produced in the same instrument as the evaluation.  This allows you to track the deviation of the actual elapsed time from the estimated.  Well, if this tool also uses the project manager.  Then all delays in the critical path will be immediately noticeable.  The variant with different tools is also possible, but it will require much greater labor costs for the maintenance of the process, which means that there will be a temptation to cheat.  We already know how this ends.  We use <a href="https://www.jetbrains.com/youtrack/">YouTrack</a> .  Everything about what I wrote in the article is currently available out of the box, although it requires a little tweaking. <br><br><h3>  Conclusion </h3><br><ol><li>  Evaluation is difficult </li><li>  Decomposition allows you to find gaps in the requirements and improve the quality of assessment </li><li>  Group estimates are more specific than individual, use poker </li><li>  Blockers, test cases and formal acceptance criteria improve communication, which in turn increases the project's chances of success. </li><li>  It is necessary to begin with the most risky tasks on the critical path of the project. </li><li>  Evaluation is not a one-time action, but an inseparable process from project management. </li><li>  Without taking into account the working time it is impossible to keep the project status relevant and adjust their estimates. </li></ol><br><h3>  Want to know more about project evaluation? </h3><br>  Read the book ‚Äú <a href="https://www.ozon.ru/context/detail/id/3115179/">How much does a software project</a> ‚Äù by Steve McConelle and other articles on this topic on Habr√©: <br><br><ol><li>  <a href="https://habr.com/ru/company/infopulse/blog/170777/">habr.com/ru/company/infopulse/blog/170777</a> </li><li>  <a href="https://habr.com/ru/post/308494/">habr.com/en/post/308494</a> </li><li>  <a href="https://habr.com/ru/company/ruswizards/blog/151029/">habr.com/ru/company/ruswizards/blog/151029</a> </li><li>  <a href="https://habr.com/ru/company/mindbox/blog/321270/">habr.com/ru/company/mindbox/blog/321270</a> </li><li>  <a href="https://habr.com/ru/post/307820/">habr.com/en/post/307820</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/442474/">https://habr.com/ru/post/442474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442460/index.html">We help Queryable Provider to deal with interpolated strings</a></li>
<li><a href="../442464/index.html">How to grow manned "Dragon"</a></li>
<li><a href="../442466/index.html">How to promote incremental game? Free, fast and efficient *</a></li>
<li><a href="../442468/index.html">In a unique experiment, mice received infrared vision</a></li>
<li><a href="../442472/index.html">The digest of fresh materials from the world of the frontend for the last week No. 354 (February 25 - March 3, 2019)</a></li>
<li><a href="../442476/index.html">One Web is ahead of SpaceX in deploying the Internet satellite network</a></li>
<li><a href="../442478/index.html">How can you simplify and speed up the calculation of the neural network of direct propagation</a></li>
<li><a href="../442480/index.html">The first public round table ‚ÄúDo we need national standards on the Internet of Things?‚Äù At the InoThings ++ conference</a></li>
<li><a href="../442484/index.html">What shines Crew Dragon Roscosmos</a></li>
<li><a href="../442486/index.html">ReactOS 0.4.11 - one hundred more applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>