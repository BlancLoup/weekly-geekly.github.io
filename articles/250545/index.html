<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Intel¬Æ Graphics Technology. Part II: ‚Äúunload‚Äù calculations on graphics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue our discussion about Intel¬Æ Graphics Technology, namely, what we have in terms of writing code: offload and offload_attribute for offloadi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Intel¬Æ Graphics Technology. Part II: ‚Äúunload‚Äù calculations on graphics</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/f23/ce7/796/f23ce7796fa54823b81d794b3255d526.png"></div><br>  We continue our <a href="http://habrahabr.ru/company/intel/blog/249743/">discussion</a> about Intel¬Æ Graphics Technology, namely, what we have in terms of writing code: <i>offload</i> and <i>offload_attribute</i> for offloading, <i>target (gfx)</i> and <i>target (gfx_kernel) attributes</i> , <i>__GFX__</i> and <i>__INTEL_OFFLOAD macros</i> , intrinsic and a set of API functions for asynchronous offload.  This is all we need for happiness.  I almost forgot: of course, we need a compiler from Intel and the magic option <i>/ Qoffload</i> . <br><br>  But about everything in order.  One of the main ideas is the relatively easy modification of the existing code executed on the CPU to run it on the graphics integrated into the processor. <br><a name="habracut"></a><br>  The easiest way to show this is with a simple example of summing two arrays: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector_add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *c)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) c[i] = a[i] + b[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  With <a href="http://habrahabr.ru/company/intel/blog/204838/">Intel¬Æ Cilk ‚Ñ¢ Plus</a> technology, we can easily make it parallel by replacing the <i>for</i> loop with <i>cilk_for</i> : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector_add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *c)</span></span></span></span>{ cilk_for(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) c[i] = a[i] + b[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre><br>  Well, in the next step we already ship the calculations to the graphics using the <i>#pragma offload directive</i> in synchronous mode: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector_add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *c)</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> offload target(gfx) pin(a, b, c:length(N)) cilk_for(int i = 0; i &lt; N; i++) c[i] = a[i] + b[i]; return; }</span></span></code> </pre><br>  Or we create a kernel for asynchronous execution using the <i>__ declpec ((gfx_kernel)) specifier</i> before the function: <br><br><pre> <code class="cpp hljs">__declspec(target(gfx_kernel)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector_add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *c)</span></span></span></span>{ cilk_for(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) c[i] = a[i] + b[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre><br>  By the way, everywhere there is a set of letters <i>GFX</i> , which should lead us to believe that we are working with integrated graphics ( <i>GFX - Graphics</i> ), and not with the <i>GPU</i> , which is often referred to as discrete graphics. <br><br>  As you already understood, the procedure has a number of features.  Well, first of all, everything works only with <i>cilk_for</i> cycles.  It is clear that for good work there should be a parallel version of our code, but for the time being it is the mechanism for working with cycles from Cilk that is supported, that is, the same OpenMP goes past the cash register.  It must be remembered that the graphics do not work very well with 64-bit ‚Äúfleets‚Äù and integers ‚Äî especially hardware, so you shouldn‚Äôt expect high performance with such operations. <br><br>  There are two main modes for computing on the graph: synchronous and asynchronous.  For the implementation of the first, compiler directives are used, and for the second, a set of API functions are used, while for the implementation of the offload it will be necessary to put the function (kernel) declared in this way into the execution queue. <br><br>  <b>Synchronous mode</b> <br>  It is implemented using the <i>#pragma offload target (gfx) directive</i> in front of the <i>cilk_for</i> cycle <i>that</i> interests us. <br>  In a real application in this loop, there may well be a call to a certain function, so it must also be declared with <i>__ declspec (target (gfx))</i> . <br>  The synchronism is that the thread executing the code on the host (CPU) will wait until the end of the calculations on the graph.  At the same time, the compiler generates code for both the host and graphics, which allows for greater flexibility when working with different hardware.  If offload is not supported, then the entire code is executed on the CPU.  In the first post we already talked about how this is implemented. <br>  The directive can specify the following parameters: <br><ul><li>  <i>if (condition)</i> - the code will be executed only on the chart, if the condition is true </li><li>  <i>in | out | inout | pin (variable_list: length (length_variable_in_elements))</i> <br>  <i>in</i> , <i>out</i> , or <i>inout</i> - specify which variables are copied between the CPU and graphics </li><li>  <i>pin</i> - set variables common to CPU and graphics.  In this case, no data is copied, and the memory used cannot be swapped. </li><li>  <i>Length</i> is a must have when working with pointers.  You need to set the size of the data that you want to copy to / from the graphics memory, or that you want to share with the CPU.  Set as a number of pointer type elements.  For a pointer to an array, this is the number of corresponding elements of the array. </li></ul><br>  Important note - using <i>pin</i> can significantly reduce the overhead of using offload.  Instead of copying data back and forth, we will organize access to physical memory available to both the host (CPU) and integrated graphics.  If the size of the data is insignificant, then we will not see a large increase. <br>  Since the OS does not know that the processor graphics uses memory, the obvious solution was to make the used memory pages impossible to swap, in order to avoid an unpleasant situation.  Therefore, you need to be careful and do not pinch a lot - otherwise you will get many pages for which you cannot make a swap.  Naturally, the speed of the system as a whole will not increase. <br><br>  In our example of summing two arrays, we just use the <i>pin (a, b, c: length (N))</i> parameter: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> offload target(gfx) pin(a, b, c:length(N))</span></span></code> </pre><br>  That is, arrays <i>a</i> and <i>b are</i> not copied into the graphics memory, but remain available in shared memory, and the corresponding page is not swapped until we finish the work. <br>  By the way, to ignore pragmas, the <i>/ Qoffload-</i> option is used.  Well, if we suddenly get tired of offload.  By the way, ifdef'y nobody canceled, and this technique is still very relevant: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __INTEL_OFFLOAD cout &lt;&lt; </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\nThis program is built with __INTEL_OFFLOAD.\n"</span></span></span><span class="hljs-meta"> &lt;&lt; </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"The target(gfx) code will be executed on target if it is available\n"</span></span></span><span class="hljs-meta">; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> cout &lt;&lt; </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\nThis program is built without __INTEL_OFFLOAD\n"</span></span></span><span class="hljs-meta">; &lt;&lt; </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"The target(gfx) code will be executed on CPU only.\n"</span></span></span><span class="hljs-meta">; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  <b>Asynchronous mode</b> <br>  Consider now another mode offload, which is based on the use of API functions.  Graphics have their own queue for execution, and all we need is to create the kernels (gfx_kernel) and put them into this queue.  You can create a kernel with the <i>__declspec (target (gfx_kernel)) specifier</i> before the function.  In this case, when a thread on the host sends the kernel to the queue for execution, it continues execution.  However, it is possible to wait until the execution is completed on the graph using the <i>_GFX_wait ()</i> function. <br><br>  In the synchronous mode of operation, every time we enter the region with offload, we pin the memory (if we don‚Äôt want to copy, of course), and when we exit the cycle, we stop this process.  This happens implicitly and does not require any construction.  Therefore, if offload is performed in some cycle, then we will get very large overheads (overhead).  In the asynchronous case, we can explicitly specify when to start pinning the memory and when to end using the API functions. <br><br>  In addition, in asynchronous mode, code generation is not provided for both the host and the graphics.  So you have to take care of implementing the code only for the host itself. <br><br>  Here is the code for calculating the sum of arrays in asynchronous mode (the asynchronous version of the code for <i>vec_add</i> was presented above): <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[TOTALSIZE]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[TOTALSIZE]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[TOTALSIZE]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[TOTALSIZE]; a[<span class="hljs-number"><span class="hljs-number">0</span></span>:TOTALSIZE] = <span class="hljs-number"><span class="hljs-number">1</span></span>; b[<span class="hljs-number"><span class="hljs-number">0</span></span>:TOTALSIZE] = <span class="hljs-number"><span class="hljs-number">1</span></span>; c[<span class="hljs-number"><span class="hljs-number">0</span></span>:TOTALSIZE] = <span class="hljs-number"><span class="hljs-number">0</span></span>; d[<span class="hljs-number"><span class="hljs-number">0</span></span>:TOTALSIZE] = <span class="hljs-number"><span class="hljs-number">0</span></span>; _GFX_share(a, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)*TOTALSIZE); _GFX_share(b, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)*TOTALSIZE); _GFX_share(c, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)*TOTALSIZE); _GFX_share(d, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)*TOTALSIZE); _GFX_enqueue(<span class="hljs-string"><span class="hljs-string">"vec_add"</span></span>, c, a, b, TOTALSIZE); _GFX_enqueue(<span class="hljs-string"><span class="hljs-string">"vec_add"</span></span>, d, c, a, TOTALSIZE); _GFX_wait(); _GFX_unshare(a); _GFX_unshare(b); _GFX_unshare(c); _GFX_unshare(d);</code> </pre><br>  So, we declare and initialize 4 arrays.  Using the <i>_GFX_share</i> function, <i>we</i> explicitly say that this memory (starting address and length in bytes are set by the function parameters) needs to be pinned, that is, we will use the shared memory for the CPU and graphics.  After that, we put in the queue the desired function <i>vec_add</i> , which is defined using <i>__ declspec (target (gfx_kernel))</i> .  In it, as always, the <i>cilk_for</i> loop is <i>used</i> .  The thread on the host puts the second miscalculation of the <i>vec_add</i> function with new parameters into the queue without waiting for the first one to complete.  With <i>_GFX_wait,</i> we expect all cores in the queue to be executed.  And at the end, we clearly stop the pinning of memory using <i>_GFX_unshare</i> . <br><br>  Do not forget that to use the API functions, we need the header file <i>gfx_rt.h</i> .  In addition, to use <i>cilk_for</i> you need to connect <i>cilk / cilk.h.</i> <br>  An interesting point is that the default installed compiler <i>could</i> not find <i>gfx_rt.h</i> - I had to set the path to its daddy ( <i>C: \ Program Files (x86) \ Intel \ Composer XE 2015 \ compiler \ include \ gfx</i> in my case) with pens in the project settings. <br><br>  I also found one interesting option, which I did not mention in the previous post, when I talked about code generation by the compiler.  So, if we know in advance what kind of hardware we will work on, then we can indicate this to the compiler explicitly with the help of the <i>/ Qgpu-arch</i> option.  So far there are only two options: <i>/ Qgpu-arch: ivybridge</i> or <i>/ Qgpu-arch: haswell</i> .  As a result, the linker will call the compiler to translate the code from the vISA architecture to the one we need, and we will save on JIT'ing. <br><br>  And finally, an important note about the work offload on Windows 7 (and DirectX 9).  It is critical that the display is active, otherwise it will not work.  In Windows 8, there is no such limit. <br><br>  Well, remember that we are talking about integrated graphics in the processor.  The described constructions do not work with discrete graphics - we use OpenCL for it. </div><p>Source: <a href="https://habr.com/ru/post/250545/">https://habr.com/ru/post/250545/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250531/index.html">Antivirus, Android and x86. Interaction features</a></li>
<li><a href="../250535/index.html">Annual Review: What's new for eBay?</a></li>
<li><a href="../250537/index.html">PIC16F1503. Wheelbarrow for pumping - 3. Power</a></li>
<li><a href="../250539/index.html">Making an online cinema for the blind (WCAG 2.0 AAA)</a></li>
<li><a href="../250541/index.html">Wiring diagrams with LaTeX and TikZ</a></li>
<li><a href="../250549/index.html">The boot server - as a bootable USB flash drive, only the server and the network</a></li>
<li><a href="../250551/index.html">Overview of the site for testing web vulnerabilities OWASP Top-10 for example bWAPP</a></li>
<li><a href="../250553/index.html">February 14 - the day of the programmer</a></li>
<li><a href="../250555/index.html">Putting the glove to determine the position of the hands themselves</a></li>
<li><a href="../250557/index.html">Practical programming of artificial intelligence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>