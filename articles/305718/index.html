<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Checking the source code of FlashDevelop with PVS-Studio</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To check the quality of diagnostics of our static analyzer and its advertising, we regularly analyze open source projects. The developers of the Flash...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Checking the source code of FlashDevelop with PVS-Studio</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/981/4ac/b99/9814acb999352a1eee95c0889611fc2c.png" align="left">  To check the quality of diagnostics of our static analyzer and its advertising, we regularly analyze open source projects.  The developers of the FlashDevelop project themselves asked us to check their product, which we gladly did. <br><br><h2>  Introduction </h2><br>  <a href="http://www.flashdevelop.org/">FlashDevelop</a> is a popular Flash development environment that supports Action Script versions 2 and 3, Haxe, JavaScript, HTML, PHP, C #, and has the functionality inherent in modern code editors, such as code completion, built-in support for svn, git, mercurial, templates , third-party plug-ins, syntax highlighting themes and more.  It is noteworthy that FlashDevelop used Fireaxis Games in the development of <a href="https://xcom.com/ru/xcom-enemy-unknown">XCOM: Enemy Unknown</a> . <br><a name="habracut"></a><br><h2>  Test results </h2><br>  Considering that FlashDevelop is an open source product and is written in C #, we wanted to test it with our analyzer.  For the analysis, the static analyzer PVS-Studio v6.05 was used.  Since it is not possible to sort out all the problem areas found within this article, we consider the most interesting messages of the analyzer. <br><br><h3>  Unused return values ‚Äã‚Äãof methods </h3><br>  As you know, strings in C # are immutable objects, and the methods responsible for changing the string actually return a new object of type String, keeping the original string unchanged.  However, as practice shows, developers forget about this feature.  For example, the analyzer detected the following errors: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://www.viva64.com/ru/d/0406/">V3010</a>  ASPrettyPrinter.cs 1263 <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IToken tok)</span></span></span><span class="hljs-function"> </span></span>{ .... lineData.Insert(<span class="hljs-number"><span class="hljs-number">0</span></span>, mSourceData.Substring(prevLineEnd, ((CommonToken)t).StartIndex - prevLineEnd)); .... }</code> </pre> <br>  <a href="http://www.viva64.com/ru/d/0406/">V3010</a>  MXMLPrettyPrinter.cs 383 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (aToken.Line == currentLine) { lineData.Insert(<span class="hljs-number"><span class="hljs-number">0</span></span>, aToken.Text); .... } .... }</code> </pre> <br>  Probably, the developer had in mind this design: <br><pre> <code class="cpp hljs">lineData = lineData.Insert(....);</code> </pre> <br>  Another example of the V3010 diagnostic trigger: <br><br>  <a href="http://www.viva64.com/ru/d/0406/">V3010</a> The return value of the function 'NextDouble' is required to be utilized.  ASFileParser.cs 196 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRandomStringRepl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ random.NextDouble(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"StringRepl"</span></span> + random.Next(<span class="hljs-number"><span class="hljs-number">0xFFFFFFF</span></span>); }</code> </pre> <br>  This code does not contain an error from the point of view of the functional, however, the call to <i>random.NextDouble ()</i> does not carry any meaning and can be deleted. <br><br><h3>  Check for null after casting </h3><br>  The standard practice after a type cast operation is to check the resulting value for null in case the original type cannot be brought to the desired one.  When performing such a routine operation, the developer may be inattentive and check the wrong variable.  Our analyzer does not get tired and is closely watching such things: <br><br>  <a href="http://www.viva64.com/ru/d/0388/">V3019</a> Possibly incorrectly variable conversion compared to null after type conversion using 'as' keyword.  Check variables 'item', 'val'.  WizardHelper.cs 67 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetControlValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> val = item as <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item == null) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... }</code> </pre> <br>  Obviously, in this example, the null variable should be checked for the variable <i>val</i> , not <i>item</i> , and the code should look like this: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> val = item as <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val == null) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;</code> </pre> <br><h3>  Duplication of method bodies </h3><br>  When in a code there are methods with identical bodies, it always causes suspicions.  At best, such code requires refactoring, and at worst, mechanical copy-paste distorts the logic of the program.  Not to be unfounded, consider the following examples. <br><br>  <a href="http://www.viva64.com/ru/d/0389/">V3013</a> It is odd that the body of the SuspendMdiClientLayout function is fully equivalent to the body of the PerformMdiClientLayout function (377, line 389).  DockPanel.MdiClientController.cs 377 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SuspendMdiClientLayout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetMdiClientController().MdiClient != null) GetMdiClientController().MdiClient.PerformLayout(); <span class="hljs-comment"><span class="hljs-comment">//&lt;= } private void PerformMdiClientLayout() { if (GetMdiClientController().MdiClient != null) GetMdiClientController().MdiClient.PerformLayout(); }</span></span></code> </pre> <br>  As we can see, the bodies of the <i>SuspendMdiClientLayout</i> and <i>PerformMdiClientLayout methods are</i> absolutely identical.  This was probably due to copying the code.  The name of the <i>SuspendMdiClientLayout</i> method assumes that it is responsible for suspending the layout, however, the layout is redrawn instead: <i>MdiClient.PerformLayout ()</i> .  I assume that the correct implementation of this method should be like this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SuspendMdiClientLayout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetMdiClientController().MdiClient != null) GetMdiClientController().MdiClient.SuspendLayout(); <span class="hljs-comment"><span class="hljs-comment">//&lt;= }</span></span></code> </pre> <br>  Another example.  The project is implemented type <i>Lexer</i> , intended for the lexical analysis of something.  In this type, 28 methods of the same type are implemented with signatures of the type <i>private static bool StateXX (FsmContext ctx)</i> , where XX is in the range from 1 to 28. It is not surprising that when performing this amount of routine work, the developer‚Äôs eyes may be blurred, which resulted in in the error code, to which the PVS-Studio analyzer responds as follows: <br><br>  <a href="http://www.viva64.com/ru/d/0389/">V3013</a> It is odd that the body of the State11 function is fully equivalent to the body of the State15 function (532, line 589).  Lexer.cs 532 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State11</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FsmContext ctx)</span></span></span><span class="hljs-function"> </span></span>{ ctx.L.GetChar (); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ctx.L.input_char) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span>: ctx.Return = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ctx.NextState = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State15</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FsmContext ctx)</span></span></span><span class="hljs-function"> </span></span>{ ctx.L.GetChar (); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ctx.L.input_char) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span>: ctx.Return = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ctx.NextState = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  The fact that the two methods handle the same situation seems highly suspicious.  It is not clear how to fix this problem, the logic of the work is known only to the author.  I also doubt that this problem could easily be detected during the code review, because reading a large number of monotonous code is much more difficult than writing it.  On the other hand, static analyzers are helpful here. <br><br><h3>  Unconditional exit from a cycle </h3><br>  Further analysis revealed an interesting point: <br><br>  <a href="http://www.viva64.com/ru/d/0410/">V3020</a> An unconditional 'break' within a loop.  AirWizard.cs 1760 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExtensionBrowseButton_Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (var existingExtension in _extensions) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (existingExtension.ExtensionId == extensionId) extension = existingExtension; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br>  I would venture to suggest that the developer wanted to run through the elements of the <i>_extensions</i> collection, find the first <i>existingExtension</i> object with the appropriate <i>extensionId,</i> and exit the loop.  But because of the savings on the parentheses, the loop certainly ends after the first iteration, which significantly affects the logic of the program. <br><br><h3>  Expression is always true / false </h3><br>  Another common source of error is conditional expressions.  If the expression includes a large number of variables, boundary values, a fairly complex branch, the probability of an error increases.  Consider, for example, the following conditional operator: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SettingChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> setting)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (setting == <span class="hljs-string"><span class="hljs-string">"ExcludedFileTypes"</span></span> || setting == <span class="hljs-string"><span class="hljs-string">"ExcludedDirectories"</span></span> || setting == <span class="hljs-string"><span class="hljs-string">"ShowProjectClasspaths"</span></span> || setting == <span class="hljs-string"><span class="hljs-string">"ShowGlobalClasspaths"</span></span> || setting == <span class="hljs-string"><span class="hljs-string">"GlobalClasspath"</span></span>) { Tree.RebuildTree(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (setting == <span class="hljs-string"><span class="hljs-string">"ExecutableFileTypes"</span></span>) { FileInspector.ExecutableFileTypes = Settings.ExecutableFileTypes; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (setting == <span class="hljs-string"><span class="hljs-string">"GlobalClasspath"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//&lt;= { // clear compile cache for all projects FlexCompilerShell.Cleanup(); } }</span></span></code> </pre> <br>  The PVS-Studio static analyzer reports the following error: <br><br>  <a href="http://www.viva64.com/ru/d/0391/">V3022</a> Expression 'setting == "GlobalClasspath"' is always false.  PluginMain.cs 1194 <br><br>  Indeed, the condition <i>else if (setting == "GlobalClasspath")</i> will never be fulfilled, because the same condition is present in the very first <i>if</i> .  But the fulfillment of some condition depends on the fulfillment of this condition.  To simplify the readability of this method, I would rewrite it using the <i>switch statement</i> . <br><br>  The following example is a never-satisfiable condition: <br><br>  <a href="http://www.viva64.com/ru/d/0391/">V3022</a> Expression 'high == 0xBF' is always false.  JapaneseContextAnalyser.cs 293 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte[] buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> charLen)</span></span></span><span class="hljs-function"> </span></span>{ byte high = buf[offset]; <span class="hljs-comment"><span class="hljs-comment">//find out current char's byte length if (high == 0x8E || high &gt;= 0xA1 &amp;&amp; high &lt;= 0xFE) charLen = 2; else if (high == 0xBF) charLen = 3; .... }</span></span></code> </pre> <br>  The analyzer tells us that the expression <i>'high == 0xBF' is</i> always false.  This is true because the value <i>0xBF</i> falls into the range <i>high&gt; = 0xA1 &amp;&amp; high &lt;= 0xFE</i> , checked in the first <i>if</i> . <br><br>  Another example message from the V3022 diagnostic: <br><br>  <a href="http://www.viva64.com/ru/d/0391/">V3022</a> Expression '! Outline.FlagTestDrop' is always true.  DockPanel.DockDragHandler.cs 769 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestDrop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Outline.FlagTestDrop = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Outline.FlagTestDrop) { .... } .... }</code> </pre> <br>  In this snippet, we see that the <i>Outline.FlagTestDrop</i> field, which is assigned the value false and which does not change further in the code, is used in the conditional <i>if statement</i> .  Perhaps, this method did not implement the functionality that changes the value of this field, because for some reason the developer implemented the <i>if (! Outline.FlagTestDrop) check</i> . <br><br><h3>  Using an instance before it was checked for null </h3><br>  In practice, there is always a need to check the variable for null, for example, after casting, selecting an item from the collection, etc.  In such situations, we check that the resulting variable is not null, and then use it.  However, as our practice shows, the developer can start using the received object immediately, and only then check that it is not null.  Such errors are reported by the V3095 diagnostics: <br><br>  It was verified against null.  Check lines: 364, 365. ProjectContextMenu.cs 364 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFolderItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MergableMenu menu, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path)</span></span></span><span class="hljs-function"> </span></span>{ .... DirectoryNode node = projectTree.SelectedNode as DirectoryNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.InsideClasspath == node) menu.Add(RemoveSourcePath, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node != null &amp;&amp; ....) { menu.Add(AddSourcePath, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } .... }</code> </pre> <br>  In this example, the <i>projectTree.SelectedNode</i> field is of type <i>GenericNode</i> , which is the base type for <i>DirectoryNode</i> .  Casting an object of a base type to a derived type may fail, and as a result, the node variable may contain a null reference.  However, as we can see, after the type cast operation, the developer immediately accesses the <i>node.InsideClasspath</i> field, and only then checks the <i>node</i> variable for null.  Such an implementation can lead to a <i>NullReferenceException</i> . <br><br><h3>  Overwrites the value of the argument passed. </h3><br>  The analyzer revealed such a potentially problematic place in the code: <br><br>  <a href="http://www.viva64.com/ru/d/0468/">V3061</a> Parameter 'b' is always rewritten in method body before being used.  InBuffer.cs 56 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadByte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte b)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// check it { if (m_Pos &gt;= m_Limit) if (!ReadBlock()) return false; b = m_Buffer[m_Pos++]; //&lt;= return true; }</span></span></span></span></code> </pre> <br>  The value of the argument passed to this method <i>b is</i> not used, then overwritten, and still not further.  It can be assumed that this method is not implemented as intended (the comment " <i>// check it</i> " also hints at this).  Perhaps the signature of this method should look like this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadByte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref byte b)</span></span></span><span class="hljs-function"> </span></span>{ .... }</code> </pre> <br><h3>  Invalid order of arguments passed to method </h3><br>  The following suspicious place found by the analyzer is not so easy to notice during the code review: <br><br>  <a href="http://www.viva64.com/ru/d/0459/">V3066</a> method can be passed to '_channelMixer_OVERLAY' method: 'back' and 'fore'.  BBCodeStyle.cs 302 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _channelMixer_HARDLIGHT(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> back, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fore) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _channelMixer_OVERLAY(fore, back); }</code> </pre> <br>  The _channelMixer_OVERLAY method has the following signature: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _channelMixer_OVERLAY(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> back, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fore)</code> </pre> <br>  Perhaps that is exactly what was intended.  However, it is likely that when referring to this method, the <i>fore</i> and <i>back</i> arguments were interchanged.  And the analyzer helps to check such places. <br><br><h3>  Insecure call to event handler </h3><br>  Diagnostics <a href="http://www.viva64.com/ru/d/0485/">V3083 is</a> designed to detect potentially unsafe calls to event handlers.  In the analyzed project, this diagnosis revealed a large number of such places.  Let us examine the situation of an unsafe handler call using a specific example: <br><br>  <a href="http://www.viva64.com/ru/d/0485/">V3083</a> Unsafe invocation of event 'OnKeyEscape', NullReferenceException is possible.  Consider assigning an event to a local variable before invoking it.  QuickFind.cs 849 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressEscapeKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OnKeyEscape != null) OnKeyEscape(); }</code> </pre> <br>  At first glance, the code seems to be absolutely correct: if the OnKeyEscape field is not null, we call this event.  However, this approach is not recommended.  Suppose that the OnKeyEscape event has one subscriber, and suppose that after checking this field for null, this subscriber unsubscribes from this event (on another thread, for example).  After the event has no subscribers left, the OnKeyEscape field will contain a blank reference, and an attempt to trigger an event will result in a NullReferenceException. <br><br>  It is especially unpleasant that this is an extremely difficult to reproduce error.  User may complain that pressing ESC resulted in an error.  However, even pressing ESC a thousand times, it is unlikely that the programmer will be able to understand what is wrong. <br><br>  You can secure the event call by declaring an additional intermediate variable: <br><pre> <code class="cpp hljs">var handler = OnKeyEscape <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != null) handler();</code> </pre> <br>  In C # version 6, a check for null (?.) Operator appeared, which allows to simplify the code considerably: <br><pre> <code class="cpp hljs">OnKeyEscape?.Invoke();</code> </pre> <br><h3>  Possible typos </h3><br>  The heuristic capabilities of our analyzer allow us to detect very interesting suspicious places in the code.  For example: <br><br>  <a href="http://www.viva64.com/ru/d/0453/">V3056</a> Consider reviewing the correctness of 'a1' item's usage.  LzmaEncoder.cs 225 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPrices</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ UInt32 a0 = _choice.GetPrice0(); UInt32 a1 = _choice.GetPrice1(); UInt32 b0 = a1 + _choice2.GetPrice0(); UInt32 b1 = a1 + _choice2.GetPrice1(); .... }</code> </pre> <br>  It is likely that this code was written by copy-paste.  And it seems to me that the variable <i>a0</i> should be used instead of <i>a1</i> to calculate the value of the variable <i>b0</i> .  In any case, the found suspicious place should serve as a reason for developers to look closely at this code.  And in general, it is better to use more informative variable names. <br><br><h3>  Re-forwarding exceptions </h3><br>  In the code, several places were found in which the intercepted exception is forwarded further.  This is implemented, for example, as follows: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toPath)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (UserCancelException uex) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> uex; } .... }</code> </pre> <br>  When checking this method, the analyzer displays the following message: <br><br>  <a href="http://www.viva64.com/ru/d/0456/">V3052</a> The original exception object 'uex' was swallowed.  Stack of original exception could be lost.  FileActions.cs 598 <br><br>  Such throwing an exception causes the original call stack to be overwritten by a new one, starting with the current method.  This makes it very difficult to find the place where the original exception occurred during debugging. <br><br>  To preserve the original call stack when re-generating exceptions, you just need to use the <i>throw</i> statement: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (UserCancelException uex) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; }</code> </pre> <br><h3>  The likely occurrence of an InvalidCastException exception while traversing a collection </h3><br>  Further analysis of the code revealed a potentially unsafe place: <br><br>  <a href="http://www.viva64.com/ru/d/0489/">V3087 cas in</a> variable variable cas cas cas cas cas cas  VS2005DockPaneStrip.cs 1436 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WindowList_Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object sender, EventArgs e)</span></span></span><span class="hljs-function"> </span></span>{ .... List&lt;Tab&gt; tabs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Tab&gt;(Tabs); foreach (TabVS2005 tab in tabs) .... }</code> </pre> <br>  The <i>tabs</i> collection contains elements of type <i>Tab</i> , while iterating elements of this collection are <i>reduced</i> to type <i>TabVS2005</i> , which is a successor of type <i>Tab</i> .  This cast is unsafe and can cause a <i>System.InvalidCastException</i> exception. <br><br>  The same diagnostics found similar unsafe code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DocumentsCount { get { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; foreach (DockContent content in Documents) count++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; } }</code> </pre> <br>  Here, the <i>Documents</i> collection contains <i>IDockContent</i> elements, and explicitly converting them to the <i>DockContent</i> type may be unsafe. <br><br><h3>  Redundant condition check </h3><br>  Well, and finally, let's look at examples of code that does not contain errors, but, nevertheless, overly complicated: <br><br>  <a href="http://www.viva64.com/ru/d/0416/">V3031 Anonymous</a> check can be simplified.  The '||'  operator is surrounded by opposite expressions.  DockContentHandler.cs 540 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDockState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Pane != oldPane) || (Pane == oldPane &amp;&amp; oldDockState != oldPane.DockState)) { RefreshDockPane(Pane); } .... }</code> </pre> <br>  The terms <i>Pane! = OldPane</i> and <i>Pane == oldPane</i> are mutually exclusive, and therefore this expression can be simplified: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pane != oldPane || oldDockState != oldPane.DockState)</code> </pre> <br>  Similarly, a conditional expression in another method: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetProject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!internalOpening || (internalOpening &amp;&amp; !PluginBase.Settings.RestoreFileSession)) { RestoreProjectSession(project); } .... }</code> </pre> <br>  can also be simplified to: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!internalOpening || !PluginBase.Settings.RestoreFileSession)</code> </pre> <br><h2>  Conclusion </h2><br>  The FlashDevelop project has been developing for more than 10 years and has a rather large code base.  The use of static code analyzers on such projects brings interesting results and improves the quality of the software product.  I think the project developers will be interested to look at the errors found.  I suggest all developers in C, C ++ or C # to <a href="http://www.viva64.com/ru/pvs-studio-download/">download the latest version</a> of the PVS-Studio static code analyzer and check their projects. <br><br>  If the trial version is not enough ( <a href="http://www.viva64.com/ru/b/0395/">details</a> ), then we suggest <a href="http://www.viva64.com/ru/about-feedback/">contacting</a> us and getting a key for a more detailed study of the tool. <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0412/"><img src="https://habrastorage.org/getpro/habr/post_images/35e/064/ddf/35e064ddf91f5d99b620384893909ff7.png"></a> </div><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Pavel Kusnetsov.  <a href="http://www.viva64.com/en/b/0412/">Checking the Source Code of FlashDevelop with PVS-Studio</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/305718/">https://habr.com/ru/post/305718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305708/index.html">Impressions from the best reports at the International PHP Conference</a></li>
<li><a href="../305710/index.html">GIMP 2.9.4 released</a></li>
<li><a href="../305712/index.html">ViaLatM and social functions</a></li>
<li><a href="../305714/index.html">Introducing Iron: Melt Ore on Rust</a></li>
<li><a href="../305716/index.html">Opening API for working with services from Russian low-cost host (part 1)</a></li>
<li><a href="../305720/index.html">Business Processes: How everything is started and confused. Chapter Three General BPM Classification and BPMS Philosophy</a></li>
<li><a href="../305722/index.html">How to write a good text for a site or email-letter: WIIFM technology</a></li>
<li><a href="../305724/index.html">Features of the choice of solid-state drives (SSD) for servers and RAID-arrays</a></li>
<li><a href="../305726/index.html">Kerio Connect 9.1 - helps small and medium-sized companies work more productively</a></li>
<li><a href="../305728/index.html">Computer vision for blind people. Intel Edison Application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>