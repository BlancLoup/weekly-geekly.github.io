<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compare Nim and Rust</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I offer the readers of Habrakhabr a translation of the article ‚ÄúA Quick Comparison of Nim vs. Rust . My comments will be in italics. 

 Rust and Nim a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compare Nim and Rust</h1><div class="post__text post__text-html js-mediator-article">  <em>I offer the readers of Habrakhabr a translation of the article <a href="http://arthurtw.github.io/2015/01/12/quick-comparison-nim-vs-rust.html">‚ÄúA Quick Comparison of Nim vs.</a></em>  <em><a href="http://arthurtw.github.io/2015/01/12/quick-comparison-nim-vs-rust.html">Rust</a> .</em>  <em>My comments will be in italics.</em> <br><br>  <a href="http://www.rust-lang.org/">Rust</a> and <a href="http://nim-lang.org/">Nim</a> are two new programming languages ‚Äã‚Äãfor which I follow the development.  Soon, after my <a href="http://arthurtw.github.io/2014/12/21/rust-anti-sloppy-programming-language.html">first post</a> about Rust, <a href="http://nim-lang.org/news.html">Nim 0.10.2 was published</a> .  This prompted me to get to know Nim and, of course, compare it with Rust. <br><br>  In this post I am going to show you two simple programs written in Nim and Rust with a rough comparison of their execution times and will express my subjective impressions of programming in these languages. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h2>  Example # 1: Word counting (wordcount) </h2><br><br>  This example uses file I / O, regular expressions, hash tables (associative arrays), and parsing the arguments passed to the command.  As the name implies, the program counts the number of words in files or <b>stdin</b> . <br><br>  Usage example: <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Usage</span></span>: wordcount [<span class="hljs-keyword"><span class="hljs-keyword">OPTIONS</span></span>] [FILES] <span class="hljs-keyword"><span class="hljs-keyword">Options</span></span>: -o:<span class="hljs-type"><span class="hljs-type">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> output file <span class="hljs-type"><span class="hljs-type">name</span></span> -i <span class="hljs-comment"><span class="hljs-comment">--ignore-case ignore case -h --help print this help menu</span></span></code> </pre> <br><br>  If we pass the argument <b>-i</b> , the result will be as follows: <br><br><pre> <code class="hljs mel"><span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> files <span class="hljs-number"><span class="hljs-number">1</span></span> h <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">help</span></span> ...</code> </pre><br><br><h3>  Nim version </h3><br><br>  The program on Nim is quite simple.  It uses <a href="http://nim-lang.org/docs/tables.html">tables</a> .  <b>CountTable</b> to count words, <a href="http://nim-lang.org/docs/parseopt2.html">parseopt2</a> .  <b>getopt</b> for parsing command and <a href="http://nim-lang.org/docs/sequtils.html">sequtils arguments</a> .  <b>mapIt</b> for functional mapping operation.  For regular expressions, I chose the <a href="http://nim-lang.org/docs/pegs.html">pegs</a> module, which is recommended by the Nim documentation instead of <a href="http://nim-lang.org/docs/re.html">re</a> . <br><br>  The <b>{.raises: [IOError].} Directive</b> on line 3 guarantees that the <b>doWork</b> procedure throws only an <b>IOError</b> exception.  To do this, I put <b>input.findAll (peg "\ w +")</b> inside a <b>try</b> expression in line 21 to catch exceptions that, theoretically, can occur. <br><br>  Part of the <a href="">wordcount.nim</a> code: <br><br><pre> <code class="hljs markdown">proc doWork(inFilenames: seq[<span class="hljs-string"><span class="hljs-string">string</span></span>] = nil, outFilename: string = nil, ignoreCase: bool = false) {.raises: [<span class="hljs-string"><span class="hljs-string">IOError</span></span>].} = # Open files var infiles: seq[<span class="hljs-string"><span class="hljs-string">File</span></span>] = @[<span class="hljs-string"><span class="hljs-string">stdin</span></span>] outfile: File = stdout if inFilenames != nil and inFilenames.len &gt; 0: infiles = inFilenames.mapIt(File, (proc (filename: string): File = if not open(result, filename): raise newException(IOError, "Failed to open file: " &amp; filename) )(it)) if outFilename != nil and outFilename.len &gt; 0 and not open(outfile, outFilename, fmWrite): raise newException(IOError, "Failed to open file: " &amp; outFilename) # Parse words var counts = initCountTable[<span class="hljs-string"><span class="hljs-string">string</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) for infile in infiles: for line in infile.lines: let input = if ignoreCase: line.tolower() else: line let words = try: input.findAll(peg"\w+") except: @[] for word in words: counts.inc(word) # Write counts var words = toSeq(counts.keys) sort(words, cmp) for word in words: outfile.writeln(counts[word], '\t', word)</code> </pre><br><br><h3>  Rust version </h3><br><br>  For a better understanding of Rust, I implemented a simple <b>BTreeMap</b> structure akin to <b>collections :: BTreeMap</b> , but ultimately I used <b>collections :: HashMap</b> for a fair comparison with Nim (the <b>BTreeMap</b> code remained in the repository for review).  The <a href="http://doc.rust-lang.org/getopts/getopts/index.html">getopts</a> package is used to parse the command arguments into my <b>Config</b> structure.  Then everything should be clear. <br><br>  Part of the code from my <a href="https://github.com/arthurtw/rust-examples/tree/master/wordcount">Rust wordcount</a> project: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_work</span></span></span></span>(cfg: &amp;config::Config) -&gt; io::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;()&gt; { <span class="hljs-comment"><span class="hljs-comment">// Open input and output files let mut readers = Vec::with_capacity(std::cmp::max(1, cfg.input.len())); if cfg.input.is_empty() { readers.push(BufReader::new(Box::new(io::stdin()) as Box&lt;Read&gt;)); } else { for name in &amp;cfg.input { let file = try!(File::open(name)); readers.push(BufReader::new(Box::new(file) as Box&lt;Read&gt;)); } } let mut writer = match cfg.output { Some(ref name) =&gt; { let file = try!(File::create(name)); Box::new(BufWriter::new(file)) as Box&lt;Write&gt; } None =&gt; { Box::new(io::stdout()) as Box&lt;Write&gt; } }; // Parse words let mut map = collections::HashMap::&lt;String, u32&gt;::new(); let re = regex!(r"\w+"); // let re = Regex::new(r"\w+").unwrap(); // let re = regex!(r"[a-zA-Z0-9_]+"); // let re = Regex::new(r"[a-zA-Z0-9_]+").unwrap(); for reader in &amp;mut readers { for line in reader.lines() { for caps in re.captures_iter(&amp;line.unwrap()) { if let Some(cap) = caps.at(0) { let word = match cfg.ignore_case { true =&gt; cap.to_ascii_lowercase(), false =&gt; cap.to_string(), }; match map.entry(word) { Occupied(mut view) =&gt; { *view.get_mut() += 1; } Vacant(view) =&gt; { view.insert(1); } } } } } } // Write counts let mut words: Vec&lt;&amp;String&gt; = map.keys().collect(); words.sort(); for &amp;word in &amp;words { if let Some(count) = map.get(word) { try!(writeln!(writer, "{}\t{}", count, word)); } } Ok(()) }</span></span></code> </pre><br><br>  Zachary Dremann suggested a <a href="https://github.com/arthurtw/rust-examples/pull/1/files">pull request</a> using <b>find_iter</b> .  I left <b>captures_iter</b> for consistency with the Nim version, but improved my code a bit. <br><br><h3>  Runtime comparison </h3><br><br>  I compiled the code with the <b>-d: release</b> flags for Nim and <b>--release</b> for Rust.  For example, I took a 5 megabyte file compiled from the Nim compiler sources: <br><br><pre> <code class="hljs lua">$ cat c_code/<span class="hljs-number"><span class="hljs-number">3</span></span>_3/*.c &gt; /tmp/<span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.txt $ wc /tmp/<span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.txt <span class="hljs-number"><span class="hljs-number">217898</span></span> <span class="hljs-number"><span class="hljs-number">593776</span></span> <span class="hljs-number"><span class="hljs-number">5503592</span></span> /tmp/<span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.txt</code> </pre><br><br>  The command to run the program: <br><br><pre> <code class="hljs pgsql">$ <span class="hljs-type"><span class="hljs-type">time</span></span> ./wordcount -i -o:result.txt <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.txt</code> </pre><br><br>  Here is the result on my Mac mini with a 2.3 GHz Intel Core i7 processor and 8 GB of memory: (1x = 0.88 seconds) <br><br><table><tbody><tr><td>  Rusty </td><td>  regex!  \ w </td><td>  Regex \ w </td><td>  regex!  [...] </td><td>  Regex [...] </td><td>  Nim </td></tr><tr><td>  release, -i </td><td>  1x </td><td>  1.30x </td><td>  0.44x </td><td>  1.14x </td><td>  0.75x </td></tr><tr><td>  release </td><td>  1.07x </td><td>  1.33x </td><td>  0.50x </td><td>  1.24x </td><td>  0.73x </td></tr><tr><td>  debug, -i </td><td>  12.65x </td><td>  20.14x </td><td>  8.77x </td><td>  19.42x </td><td>  3.51x </td></tr><tr><td>  debug </td><td>  12.41x </td><td>  20.09x </td><td>  8.84x </td><td>  19.33x </td><td>  3.25x </td></tr></tbody></table><br><br>  Notes: <br><ol><li>  In the Rust <b>regex!</b>  works faster than <b>Regex</b> , and <b>r "[a-zA-Z0-9 _] + is</b> faster than <b>r" \ w + "</b> .  All 4 combinations were tested. <br></li><li>  The debug version is just for comparison. <br></li><li>  Nim works 1-2% slower with the <b>--boundChecks: on</b> flag, I didn‚Äôt add this result to the example. <br></li></ol><br><br><h2>  Example number 2: the game "Life" </h2><br><br>  This example launches <a href="https://ru.wikipedia.org/wiki/%25D0%2596%25D0%25B8%25D0%25B7%25D0%25BD%25D1%258C_(%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0)">Life</a> in the console with a fixed field size and a template (edit the source code to change the size or pattern).  It uses <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D1%258F%25D1%258E%25D1%2589%25D0%25B8%25D0%25B5_%25D0%25BF%25D0%25BE%25D1%2581%25D0%25BB%25D0%25B5%25D0%25B4%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8_ANSI">ANSI CSI</a> code to redraw the screen. <br><br>  After launch, the screen will look something like this: <br><br><pre> <code class="hljs pgsql">. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (). (). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (). . . (). . . . . . . . . . . . . . . . . . . . . . . . . (). . . . . . . (). . . . . . . . . . . . ()(). . . . . . . . . . . . . . ()()()(). . . . (). . . . (). . . . . . . . ()(). . ()(). . . . . . . . . ()(). (). (). . . . (). . . . . . . . . . . . . . . . ()(). . . . . . . . ()()(). (). . (). . . (). . . (). . . . . . . . . . . . . . . . . . . . . . . ()(). (). (). . . . . . (). (). . . . . . . . . . . . . . . . . . . . . . . . ()()()(). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (). (). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ()(). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ()()(). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . n = <span class="hljs-number"><span class="hljs-number">300</span></span> Press ENTER <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span></code> </pre><br><br>  The program uses another stream to read from <b>stdin</b> and interrupts the game when it receives any character. <br><br><h3>  Nim version </h3><br><br>  Here is part of the code from my <a href="https://github.com/arthurtw/nim-examples/tree/master/conway">Nim conway</a> project: <br><br><pre> <code class="hljs swift">type <span class="hljs-type"><span class="hljs-type">Cell</span></span> = bool <span class="hljs-type"><span class="hljs-type">ConwayMap</span></span>* = array[<span class="hljs-number"><span class="hljs-number">0</span></span>.. &lt;mapHeight, array[<span class="hljs-number"><span class="hljs-number">0</span></span>.. &lt;mapWidth, <span class="hljs-type"><span class="hljs-type">Cell</span></span>]] proc <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>*(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-type"><span class="hljs-type">ConwayMap</span></span>, pattern: openarray[string]) = ## <span class="hljs-type"><span class="hljs-type">Initialise</span></span> the <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ix = <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(mapWidth, <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(@pattern.mapIt(int, it.len))) iy = <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(mapHeight, pattern.len) dx = int((mapWidth - ix) / <span class="hljs-number"><span class="hljs-number">2</span></span>) dy = int((mapHeight - iy) / <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.. &lt;iy: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.. &lt;ix: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &lt; pattern[y].len and pattern[y][x] notin <span class="hljs-type"><span class="hljs-type">Whitespace</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[y + dy][x + dx] = <span class="hljs-literal"><span class="hljs-literal">true</span></span> proc <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>*(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>: <span class="hljs-type"><span class="hljs-type">ConwayMap</span></span>) = ## <span class="hljs-type"><span class="hljs-type">Display</span></span> the <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>. ansi.csi(<span class="hljs-type"><span class="hljs-type">AnsiOp</span></span>.<span class="hljs-type"><span class="hljs-type">Clear</span></span>) ansi.csi(<span class="hljs-type"><span class="hljs-type">AnsiOp</span></span>.<span class="hljs-type"><span class="hljs-type">CursorPos</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cell <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> row: <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cell: <span class="hljs-string"><span class="hljs-string">"()"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-string"><span class="hljs-string">". "</span></span> stdout.write(s) stdout.write(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) proc next*(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-type"><span class="hljs-type">ConwayMap</span></span>) = ## <span class="hljs-type"><span class="hljs-type">Iterate</span></span> to next state. <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> oldmap = <span class="hljs-built_in"><span class="hljs-built_in">map</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.. &lt;mapHeight: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.. &lt;mapWidth: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nlive = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)..<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(i+<span class="hljs-number"><span class="hljs-number">1</span></span>, mapHeight-<span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(j-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)..<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(j+<span class="hljs-number"><span class="hljs-number">1</span></span>, mapWidth-<span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oldmap[i2][j2] and (i2 != i or j2 != j): inc nlive <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[i][j]: <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[i][j] = nlive &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span> and nlive &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[i][j] = nlive == <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br><br><h3>  Rust version </h3><br><br>  Here is part of the code from my <a href="https://github.com/arthurtw/rust-examples/tree/master/conway">Rust conway</a> project: <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span></span> = <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>; <span class="hljs-meta"><span class="hljs-meta">#[derive(Copy)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Conway</span></span></span></span> { map: [[Cell; MAP_WIDTH]; MAP_HEIGHT], } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Conway { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; Conway { Conway { map: [[<span class="hljs-literal"><span class="hljs-literal">false</span></span>; MAP_WIDTH]; MAP_HEIGHT], } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, pattern: &amp;[&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> h = pattern.len(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> h0 = (MAP_HEIGHT - h) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..(h) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> row = pattern[i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> w = row.len(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> w0 = (MAP_WIDTH - w) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j, c) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> row.chars().enumerate() { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.map[i + h0][j + w0] = c == <span class="hljs-string"><span class="hljs-string">'1'</span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">/// Iterate to next state. Return false if the state remains unchanged. pub fn next(&amp;mut self) -&gt; bool { let mut newmap = [[false; MAP_WIDTH]; MAP_HEIGHT]; for i in 0..(MAP_HEIGHT) { for j in 0..(MAP_WIDTH) { let mut nlive = 0; for i2 in i.saturating_sub(1)..cmp::min(i+2, MAP_HEIGHT) { for j2 in j.saturating_sub(1)..cmp::min(j+2, MAP_WIDTH) { if self.map[i2][j2] &amp;&amp; (i2 != i || j2 != j) { nlive += 1; } } } newmap[i][j] = match (self.map[i][j], nlive) { (true, 2) | (true, 3) =&gt; true, (true, _) =&gt; false, (false, 3) =&gt; true, (false, _) =&gt; false, }; } } // let changed = self.map != newmap; let changed = true; self.map = newmap; changed } } impl fmt::Display for Conway { fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result { for row in self.map.iter() { for cell in row.iter() { try!(write!(f, "{}", if *cell { "()" } else { ". " })); } try!(write!(f, "\n")); } Ok(()) } }</span></span></code> </pre><br><br>  In line 49, I defined a variable to track the change in the display, but a simple comparison of <b>self.map! = Newmap</b> does not work for arrays longer than 32 elements, unless you implement the PartialEq <b>treit</b> . <br><br>  Note that I used insecure <b>libc :: exit</b> in my <a href="">main.rs</a> , which is not very typical for Rust.  Zachary Dremann suggested a <a href="https://github.com/arthurtw/rust-examples/pull/2/files">pull request</a> in which <b>libc :: exit is</b> elegantly avoided using the <b>select</b> macro <b>!</b>  and non-blocking timer.  You might want to watch. <br><br><h3>  Runtime comparison </h3><br><br>  To compare the execution time, you need to make some changes in the code: <br><br><ol><li>  Comment out the sleep call in <a href="">conway.nim</a> and <br>  <a href="">main.rs</a> <br></li><li>  Change the number of loop iterations from 300 to 3000 <br></li><li>  Redrawing a field spends a lot of time, so two measurements were made (1) with redrawing and (2) without it (i.e., with commented out lines for printing a field in <a href="">conway.nim</a> and <a href="">main.rs</a> ) <br></li></ol><br><br>  Here are the results when compiling with the <b>-d</b> flags <b>: release</b> for Nim and <b>--release</b> for Rust: <br><br><table><tbody><tr><td></td><td>  Rusty </td><td>  Nim </td><td>  Nim / bc: on </td><td>  n = 30,000 </td></tr><tr><td>  (1) with map print </td><td>  1x </td><td>  1.75x </td><td>  1.87x </td><td>  1x = 3.33s </td></tr><tr><td>  (2) without map print </td><td>  1x </td><td>  1.15x </td><td>  1.72x </td><td>  1x = 0.78 </td></tr></tbody></table><br><br>  Since  Rust does a check for going beyond the list, for justice, I added a <b>Nim / bc: on</b> column for the Nim version compiled with the <b>--boundChecks: on</b> flag. <br><br><h2>  Nim or Rust </h2><br><br>  Although Nim and Rust are compiled languages ‚Äã‚Äãwith good performance, they are very different.  For me, their similarities are as follows: <br><br><ul><li>  compiled and statically typed <br></li><li>  calculation for good performance (each of them can work faster depending on the implementation of the program and its further optimizations) <br></li><li>  composition instead of inheritance (similar to the trend in new languages?) <br></li><li>  simple bundle with C <br></li><li>  popular language delicacies: generics, closures, functional approaches, type inference, macros, operators in the form of instructions, etc. <br></li></ul><br><br>  But their differences are more interesting. <br><br><h3>  Philosophy: freedom or discipline </h3><br><br>  When programming on Nim, it seems that you write in a scripting language.  He really blurs the line.  Nim tries to get rid of the noise in the code as much as possible, and therefore it is fun to program on it. <br><br>  However, there is a downside to such freedom: clarity, purity and sustainability may suffer.  Here is a small example: in Nim <b>import</b> imports all module names into your namespace.  Names from an imported module can be limited to using the <b>module.symbol</b> syntax or using <b>from module import nil</b> for controlled import of names, but tell me who uses it?  Moreover, this approach is not typical for Nim.  As a result, you will not be able to understand which names came from which module when reading someone else's (or your own) code (fortunately, there are no contradictions of names, because in such cases Nim makes it impossible to separate flies from cutlets). <br><br>  Other examples: <a href="http://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax">UFCS</a> allows you to use <b>len (x)</b> , <b>len x</b> , <b>x.len ()</b> or <b>x.len</b> as you like;  does not share names with underscore and different case, so <b>mapWidth</b> , <b>mapwidth</b> and <b>map_width</b> will be converted to the same name (I am glad that they included the "partial case sensitivity" rule in version 0.10.2, therefore <b>Foo</b> and <b>foo</b> will be considered different names) ;  in the order of things is the use of uninitialized variables.  In theory, you can follow strict coding principles, but when programming in Nim you will feel more relaxed. <br><br>  On the other hand, Rust honors discipline.  His compiler is very strict.  Everything should be very clear.  You get the right approaches in advance.  Ambiguity is not about the code on Rust ... <br>  This approach is usually good for long-lived projects and for maintainability, but when programming with Rust, you start to take care of such details that you might not be interested in at all.  You start thinking about using memory or increasing performance, even if it is not a priority for your task.  Rust makes you more disciplined. <br><br>  Both have their pros and cons.  As a programmer, I enjoy Nim more;  as a maintainer, I'd rather accompany products written in Rust. <br><br><h3>  Visual style: Python or C ++ </h3><br><br>  Like Python, Nim uses padding to separate blocks of code and there are fewer <a href="http://en.wikipedia.org/wiki/Sigil_(computer_programming)">characters</a> than it.  Rust is more like C ++.  <b>{}</b> , <b>::</b> , <b>&lt;&gt;</b> and <b>&amp;</b> will be familiar to C ++ programmers, plus Rust adds some new things like <b>'a</b> . <br><br>  Sometimes Nim can be too literal.  For example, I think the <b>match</b> syntax in Rust: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> key.cmp(&amp;node.key) { Less =&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> insert(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> node.left, key, value), Greater =&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> insert(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> node.right, key, value), Equal =&gt; node.value = value, }</code> </pre><br><br>  looks cleaner than the Nim <b>case</b> expression <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "help", "h": echo usageString <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ignore-case", "i": ignoreCase = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "o": outFilename = val <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">discard</span></span></code> </pre><br><br>  But, in general, the code at Nim is less noisy.  In my opinion, the special parameters in Rust are introduced by the <em>lifetime parameters</em> and this will not change. <br><br><h3>  Memory Management: Garbage Collector or Manual Control </h3><br><br>  Although Nim allows unsafe memory management and provides support for managing the garbage collector in runtime for more predictable behavior.  It is still a language with a garbage collector, which has all the advantages and disadvantages of it.  Objects in Nim are assigned copies of the values.  If the garbage collector doesn‚Äôt hurt your task, memory management in Nim will not cause you problems. <br><br>  Rust provides limited support for the garbage collector, but more often you will rely on a memory management system.  As a Rust programmer, you must fully understand his memory management model (ownership, borrowing, and lifetime) before you start writing programs efficiently, which is the first barrier for newbies. <br><br>  On the other hand, this is also the strength of Rust - secure memory management without the use of a garbage collector.  Rust copes with this task.  Along with the security of shared resources, the security of concurrent data access and the elimination of null Rust pointers is an extremely reliable programming language with no overhead for resource consumption at runtime. <br><br>  Depending on your requirements, either the Nim garbage collector will be enough for you, or your choice will fall on Rust. <br><br><h2>  Other differences </h2><br><br>  Nim's strengths: <br><br><ol><li>  Productivity: in the same time frame, you will overwrite more features in Nim </li><li>  Ease of learning </li><li>  Compiled language as a scripting language, good for prototyping, interactive research, batch processing, etc. </li><li>  Fishechki: <br><ul><li>  method redefinition </li><li>  definition of new operators </li><li>  named arguments and default values </li><li>  powerful macros </li></ul><br></li></ol><br><br>  Rust's strengths: <br><br><ol><li>  This system programming language: embedded, without garbage collector, <a href="http://en.wikipedia.org/wiki/Bare_machine">close to hardware</a> </li><li>  Safe, disciplined, reliable </li><li>  Strong core team and active community </li><li>  Fishechki: <br><ul><li>  excellent <em>pattern matching</em> implementation </li><li>  enumerations <em>(enum)</em> , although enums are also good in Nim </li><li>  <b>let mut</b> instead of <b>var</b> (small but important thing) </li><li>  powerful syntax for dereferencing structures </li></ul><br></li></ol><br><br>  Error handling: Nim uses a generic exception mechanism, Rust uses the return type <b>Result</b> (and the macro <b>panic!</b> ).  I have no preference for this, but I found it important to mention this distinction. <br><br><h2>  Release 1.0 is coming soon </h2><br><br>  Nim and Rust should be released this year <em>(Rust is <a href="http://habrahabr.ru/post/258069/">released</a> )</em> .  It's great!  Rust has already received quite a lot of attention, but Nim is becoming more famous.  They are very different in taste, but both are great new programming languages.  Rust shows its best in terms of performance and security.  Nim agile <em>(pun: Nim is nimble)</em> , expressive, realizes the strengths of scripting and compiled languages.  Both of them will be a great addition to your toolkit. <br><br>  I hope, after reading this article, you have made your opinion about these programming languages. </div><p>Source: <a href="https://habr.com/ru/post/259993/">https://habr.com/ru/post/259993/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259981/index.html">My approach to setting up the economy of the game: spreadsheets</a></li>
<li><a href="../259983/index.html">Google Developers Launchpad - everything you need for a successful launch</a></li>
<li><a href="../259987/index.html">java.js for Java developers: first steps</a></li>
<li><a href="../259989/index.html">Webinars from the Centos-admin.ru team</a></li>
<li><a href="../259991/index.html">Getting ready for a PHP interview: pseudo-type "callable"</a></li>
<li><a href="../259995/index.html">Vim in full: Project level and file system</a></li>
<li><a href="../259997/index.html">Entropy-based smart crop</a></li>
<li><a href="../260003/index.html">Creating native Android applications using the Intel C ++ Compiler compiler in Android Studio 1.0.1</a></li>
<li><a href="../260005/index.html">Architecture of storing photos in Badoo - an interview with the speaker of DevConf 2015</a></li>
<li><a href="../260007/index.html">Practice of using Laurent-2, Laurent-112, KBX-3D modules</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>