<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write a simple plugin for VirtualDub</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despite the fact that video processing slowly moves to OpenCL / CUDA VirtualDub remains a convenient tool for simple actions with video. Trimming a fr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write a simple plugin for VirtualDub</h1><div class="post__text post__text-html js-mediator-article">  Despite the fact that video processing slowly moves to OpenCL / CUDA VirtualDub remains a convenient tool for simple actions with video.  Trimming a frame, adding filters or overlaying is much more convenient than from the ffmpeg console.  In addition, over the years, a lot of filters have been developed that allow you to perform many operations quickly and conveniently.  Despite the simplicity of the SDK, some nuances arise when writing a plugin.  The article is devoted to working with them. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qo/ua/w1/qouaw1my2hgzodzbmlxecg6dtzm.png"></div><a name="habracut"></a><br>  The SDK is available at the <a href="http://www.virtualdub.org/filtersdk.html">link</a> from <a href="http://www.virtualdub.org/">the author‚Äôs site</a> .  The latest version is 1.1 (VDPluginSDK-1.1.zip).  Download and unpack in a convenient folder for you.  Inside there is a help file PluginSDK.chm, a partial translation of which this text is.  Development will be conducted in Microsoft Visual Studio Community 2015, you can use both older and newer versions.  To check the environment settings, you can use the project files with examples that are in the src folder, Samples.sln for new studio versions or SamplesVC6.dsw for the good old Visual Studio 6. After building the samples, the file SampleVideoFilter.vdf will appear in the out \ Release or out \ Debug folder .  This is a test filter.  To check it, just put it in the VirtualDub \ plugins folder and add it from the filters menu.  If everything works, then Visual Studio is installed correctly. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sf/f0/oo/sff0oor1mxxka64xtlgxbyoohsm.png"></div><br>  As an example, we write a filter from scratch.  Tutorial is designed for beginners or remembering Win32 API.  Create an empty DLL project in the studio. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/webt/sk/0-/yn/sk0-yn6z2ard0xhhlbaplfcvunw.png"></div><br>  VirtualDub plug-ins have the vdf extension, so in order not to rename it, we change the extension to the properties Properties ‚Üí General ‚Üí Target extension to .vdf each time.  We change for all configurations, so do not forget to switch them on the Configuration settings tab: to All Configurations and Platform to All platforms. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cz/b-/ai/czb-aiiveifaniki5a0t1z-1yf4.png"></div><br>  Copy the include folder from the unpacked SDK into the project and add files from it to the project via Atl-Shift-A or the Add ‚Üí Existing Item menu.  To work, we need the header files from the include folder and the VDXFrame helper file set.  Do not forget to add the include folder to the list of folders where the system will search for them.  This is done from Properties ‚Üí VC ++ Directories ‚Üí Include Directories, add a link to the project root in the form $ (ProjectDir) \ include. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pr/ds/fc/prdsfcurikgcammpur-racthciu.png"></div><br>  We add the VDXFrame library to the project, in the examples it is used as a separate module, but since the license allows, we will add it in the form of source code.  Create the src folder in the project directory and copy the VideoFilter.cpp, VideoFilterEntry.cpp, VideoFilterDialog.cpp and stdafx.cpp files into the SDK from the SDK.  Next, copy the header file from include \ stdafx.h to the previously created include folder.  Do not forget to add copied files to the project via Atl-Shift-A or from the Add ‚Üí Existing Item menu.  This completes the integration of the helper library. <br><br>  Moving on to writing code.  Add a new main.cpp file to the project via Add ‚Üí Existing Item or the Ctrl-Shift-A key combination.  Add the following lines to main <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vd2/VDXFrame/VideoFilter.h&gt; #include &lt;BlackWhiteFilter.h&gt; VDXFilterDefinition filterDef_blackWhite = VDXVideoFilterDefinition&lt;BlackWhiteFilter&gt;("Shadwork", "Black White filter", "Example for VirtualDub Plugin SDK: Applies a Black White filter to video."); VDX_DECLARE_VIDEOFILTERS_BEGIN() VDX_DECLARE_VIDEOFILTER(filterDef_blackWhite) VDX_DECLARE_VIDEOFILTERS_END() VDX_DECLARE_VFMODULE()</span></span></span></span></code> </pre> <br>  A plugin can contain an arbitrary number of filters described by the VDX_DECLARE_VIDEOFILTER macro with a parameter in the form of the VDXFilterDefinition class as the employee wrapper above the filter class.  The filter itself is described in three text fields: Author, Title and Description.  Create a filter class named BlackWhiteFilter, the author of VirtualDub classes are named using CamelCase so we create a new class inherited from VDXVideoFilter in the BlackWhiteFilter.h file.  The variable g_VFVAPIVersion will contain the API version.  Functions defined with virtual are part of the SDK, and the ToBlackAndWhite method will implement image conversion. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vd2/VDXFrame/VideoFilter.h&gt; #include &lt;vd2/VDXFrame/VideoFilterEntry.h&gt; #ifndef FILTER_VD_BLACK_WHITE #define FILTER_VD_BLACK_WHITE extern int g_VFVAPIVersion; class BlackWhiteFilter : public VDXVideoFilter { public: virtual uint32 GetParams(); virtual void Start(); virtual void Run(); protected: void ToBlackAndWhite(void *dst, ptrdiff_t dstpitch, const void *src, ptrdiff_t srcpitch, uint32 w, uint32 h); }; #endif</span></span></span></span></code> </pre> <br>  We write the implementation in the BlackWhiteFilter.cpp file, the Start () method is executed first, it is intended for any preliminary actions, for example, to determine compatibility with the AVX instruction set or CUDA support.  Leave it empty for now.  Within the scope of this class, the VDXFrame helper provides a pointer to an instance of the VDXFilterActivation class, named fa, containing information about the frame and buffers. <br><br>  The GetParams () method is used by VirtualDub to determine the compatibility of the filter; it must return the bit mask from the FILTERPARAM enumeration. <br><br><ul><li>  <b>FILTERPARAM_SWAP_BUFFERS</b> creates two independent buffers for the input and output frames, it is recommended to always use so as not to create such buffers by hand </li><li>  <b>FILTERPARAM_NEEDS_LAST</b> transfers not only the current frame to the filter but also the one before it, which is used for filters whose state depends on the previous frame </li><li>  <b>FILTERPARAM_SUPPORTS_ALTFORMATS</b> informs VirtualDub that the plugin supports frame encoding other than RGB32, for example YUV, which allows optimization of calculations </li><li>  <b>FILTERPARAM_ALIGN_SCANLINES</b> filter requires data alignment of 16 bytes, and therefore does not support for example the length of a string of 13 bytes </li><li>  <b>FILTERPARAM_PURE_TRANSFORM</b> filter behavior depends only on the data in the frame buffer, allows you to speed up the processing and display of the filter </li><li>  <b>FILTERPARAM_NOT_SUPPORTED</b> filter does not support input data in this format and will not work </li></ul><br>  For a filter that will convert an image of RGB32 to black and white, FILTERPARAM_SWAP_BUFFERS and FILTERPARAM_PURE_TRANSFORM are suitable.  If we want to support the color coding different from RGB32 and the SDK version is less than 12, we write a check for g_VFVAPIVersion and if it is supported we check the format of the resulting image in the field fa-&gt; src.mpPixmapLayout-&gt; format.  Early versions of VirtualDub did not support the presentation of a color other than RGB32.  To simplify processing, we will follow the RGB32 format, but in general VirtualDub supports a large list of formats listed in the VDXPixmapFormat. <br><br><pre> <code class="cpp hljs">uint32 BlackWhiteFilter::GetParams() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g_VFVAPIVersion &gt;= <span class="hljs-number"><span class="hljs-number">12</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (fa-&gt;src.mpPixmapLayout-&gt;format) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> nsVDXPixmap::kPixFormat_XRGB8888: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FILTERPARAM_NOT_SUPPORTED; } } fa-&gt;dst.offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FILTERPARAM_SWAP_BUFFERS; }</code> </pre> <br>  Frame processing is performed by the Run () method.  Data on the frame and the input and output buffers are stored in the variable fa, which is an instance of the class VDXFilterActivation.  VirtualDub supports frame cropping, so the processing algorithm can be optimized by obtaining information about a window selected by the user with coordinates x1, y1, x2, y2.  Frame data is stored in the src and dst objects, respectively, the input and output buffer. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VDXFilterActivation</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VDXFilterDefinition *filter; <span class="hljs-comment"><span class="hljs-comment">// void *filter_data; VDXFBitmap&amp; dst; VDXFBitmap&amp; src; VDXFBitmap *_reserved0; VDXFBitmap *const last; uint32 x1; uint32 y1; uint32 x2; uint32 y2; VDXFilterStateInfo *pfsi; IVDXFilterPreview *ifp; IVDXFilterPreview2 *ifp2; // (V11+) uint32 mSourceFrameCount; // (V14+) VDXFBitmap *const *mpSourceFrames; // (V14+) VDXFBitmap *const *mpOutputFrames; // (V14+) };</span></span></code> </pre> <br>  If we continue to write code with SDK support less than version 12, the implementation of the Run () method will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> BlackWhiteFilter::Run() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g_VFVAPIVersion &gt;= <span class="hljs-number"><span class="hljs-number">12</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VDXPixmap&amp; pxdst = *fa-&gt;dst.mpPixmap; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VDXPixmap&amp; pxsrc = *fa-&gt;src.mpPixmap; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (pxdst.format) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> nsVDXPixmap::kPixFormat_XRGB8888: ToBlackAndWhite(pxdst.data, pxdst.pitch, pxsrc.data, pxsrc.pitch, pxsrc.w, pxsrc.h); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ToBlackAndWhite(fa-&gt;dst.data, fa-&gt;dst.pitch, fa-&gt;src.data, fa-&gt;src.pitch, fa-&gt;dst.w, fa-&gt;dst.h); } }</code> </pre> <br>  The location of the raw data in the structure depends on the version supported by the plugin.  So, 6 parameters will be passed to the ToBlackAndWhite function: <br><br><ol><li>  <b>void * dst0</b> - output frame buffer </li><li>  <b>ptrdiff_t dstpitch</b> - the full length of the string in bytes of the output buffer </li><li>  <b>const void * src0</b> - input frame buffer </li><li>  <b>ptrdiff_t srcpitch</b> - the full length of the input buffer string </li><li>  <b>uint32 w</b> - frame width in pixels </li><li>  <b>uint32 h</b> - frame height in pixels </li></ol><br>  To simplify the code, we will ignore the cropping parameters, so the frame will be processed at the same speed regardless of the Crop parameter in the settings.  The point in the buffer is stored in the kPixFormat_XRGB8888 format and occupies 32 bits.  We implement the simplest frame conversion to black and white.  We don‚Äôt have an optimization task, so we‚Äôll consider it by the formula with the calculation in floating point arithmetic <br><br>  <i><b>GRAY = 0.299 * R + 0.587 * G + 0.114 * B</b></i> <br><br>  We organize two cycles, one goes through the lines and the second through the points; the boundary level for determining the color of the point is assumed to be 128. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> BlackWhiteFilter::ToBlackAndWhite(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *dst0, <span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> dstpitch, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *src0, <span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> srcpitch, uint32 w, uint32 h) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *dst = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)dst0; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *src = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)src0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint32 y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y&lt;h; ++y) { <span class="hljs-comment"><span class="hljs-comment">// Get scanline uint32 *srcline = (uint32 *)src; uint32 *dstline = (uint32 *)dst; for (uint32 x = 0; x&lt;w; ++x) { // Process pixels uint32 data = srcline[x]; float gray = 0.299f * (data &amp; 0x000000ff) + 0.587f * ((data &amp; 0x0000ff00) &gt;&gt; 8) + 0.114f *((data &amp; 0x00ff0000) &gt;&gt; 16); dstline[x] = gray &lt; 128 ? 0x00000000 : 0x00ffffff; } src += srcpitch; dst += dstpitch; } }</span></span></code> </pre> <br>  We assemble the plugin, copy the Windows-VirtualDub-Plugin-BlackWhite.vdf file into the VirtualDub plugins folder and make it active.  In the list it will be visible under the name that we defined in the VDXFilterDefinition class - Black White filter.  The plugin compiled for the 64-bit version will not be visible in the 32-bit version of VirtualDub, so do not forget to check the active configuration of the project. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qo/ua/w1/qouaw1my2hgzodzbmlxecg6dtzm.png"></div><br>  The plugin without settings is pretty dull, we add the ability to configure and preview button.  To do this, we would have to dive into the jungle of the Win32 API, but there are enough books written on this topic, so we will not go into details. <br><br>  For a visual representation of the settings window, we need a dialog box.  Create a new resource file via the menu Ctrl-Shift-A ‚Üí Resource ‚Üí Resource File with the name Resource.rc.  Add a dialog box to it through the Add Resource ‚Üí Dialog menu and change its name to IDD_DIALOG_BLACKWHITE_SETTING.  By default, we already have two buttons, Ok and Cancel.  It is better to create resources in the English locale, otherwise you can get a problem with the unreadable Russian font on the Cancel button.  Add a preview button to the screen with the name IDC_SLIDER_THRESHOLD.  In order not to return later we will add the rest of the controls for the settings, this will be a slider for changing the IDC_SLIDER_THRESHOLD threshold value and the IDbox_CHECK_INVERTED checkbox allowing you to invert the image.  It can be done like this. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jv/2i/oo/jv2ioogd-rwqqjpg8e0xthabnw4.png"></div><br>  Create a dialog class BlackWhiteFilterDialog inherited from VDXVideoFilterDialog. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;windows.h&gt; #include &lt;commctrl.h&gt; #include &lt;resource.h&gt; #include &lt;vd2/VDXFrame/VideoFilterDialog.h&gt; #include &lt;vd2/VDXFrame/VideoFilter.h&gt; #ifndef FILTER_VD_BLACK_WHITE_DIALOG #define FILTER_VD_BLACK_WHITE_DIALOG class BlackWhiteFilterDialog : public VDXVideoFilterDialog { public: BlackWhiteFilterDialog(IVDXFilterPreview *ifp); bool Show(HWND parent); virtual INT_PTR DlgProc(UINT msg, WPARAM wParam, LPARAM lParam); protected: IVDXFilterPreview *const mifp; bool OnInit(); bool OnCommand(int cmd); void OnDestroy(); }; #endif</span></span></span></span></code> </pre> <br>  A reference to the IVDXFilterPreview class that controls the preview window is passed to the constructor; we will store the local reference in the mifp variable. <br><br><pre> <code class="cpp hljs">BlackWhiteFilterDialog::BlackWhiteFilterDialog(IVDXFilterPreview *ifp):mifp(ifp){ }</code> </pre> <br>  The Show method (HWND parent) is overloaded with a call to the parent constructor and uses the ID of the settings dialog resource IDD_DIALOG_BLACKWHITE_SETTING as a parameter. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BlackWhiteFilterDialog::Show(HWND parent) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> != VDXVideoFilterDialog::Show(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, MAKEINTRESOURCE(IDD_DIALOG_BLACKWHITE_SETTING), parent); };</code> </pre> <br>  DlgProc is used to process messages from the dialog box and implements the processing of the life cycle of the dialog in the OnInit (), OnDestroy () methods and event handling from the controls in OnCommand. <br><br><pre> <code class="cpp hljs">INT_PTR BlackWhiteFilterDialog::DlgProc(UINT msg, WPARAM wParam, LPARAM lParam) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (msg) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WM_INITDIALOG: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !OnInit(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WM_DESTROY: OnDestroy(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WM_COMMAND: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OnCommand(LOWORD(wParam))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TRUE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WM_HSCROLL: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mifp) mifp-&gt;RedoFrame(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TRUE; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; }</code> </pre> <br>  First, let's process the closing of the dialog using the Ok and Cancel buttons.  In addition, we need a Preview handler that controls the display of the preview window via the Toggle method ((VDXHWND) mhdlg). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BlackWhiteFilterDialog::OnCommand(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cmd) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (cmd) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IDOK: EndDialog(mhdlg, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IDCANCEL: EndDialog(mhdlg, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IDC_PREVIEW: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mifp) mifp-&gt;Toggle((VDXHWND)mhdlg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  The class for working with the dialog is written, now it needs to be called, for this we overload the Configure method (VDXHWND hwnd) in the BlackWhiteFilter class and implement it <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BlackWhiteFilter::Configure(VDXHWND hwnd) { <span class="hljs-function"><span class="hljs-function">BlackWhiteFilterDialog </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dlg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fa-&gt;ifp)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dlg.Show((HWND)hwnd); }</code> </pre> <br>  We compile the project, copy the plugin file to the VirtualDub folder, add a new filter to the list and see our dialog and the available Preview button. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ar/y2/he/ary2heefy0jjgaaxdqfv_9v7_jc.png"></div><br>  We have a configuration window, but the filter has no settings yet, we proceed to the implementation.  The settings will be stored in the BlackWhiteFilterConfig class containing only two variables, mTreshold as the threshold value and the inversion flag mInvert. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> FILTER_VD_BLACK_WHITE_CONFIG #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FILTER_VD_BLACK_WHITE_CONFIG class BlackWhiteFilterConfig { public: BlackWhiteFilterConfig() { mTreshold = 128; mInvert = 0; } public: int mTreshold; int mInvert; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Edit the BlackWhiteFilterDialog class by adding two BlackWhiteFilterConfig instances to it to store the mConfigNew and mConfigOld configurations.  These variables will keep the old and changed state of the settings and we will need to use the button <br>  Ok and Cancel.  Edit the constructor by adding a parameter that stores the settings and initializes the configuration. <br><br><pre> <code class="cpp hljs">BlackWhiteFilterDialog::BlackWhiteFilterDialog(BlackWhiteFilterConfig&amp; config, IVDXFilterPreview *ifp):mifp(ifp){ mConfigNew = config; }</code> </pre> <br>  The settings should be stored somewhere, add the BlackWhiteFilterConfig mConfig variable to the BlackWhiteFilter class and change the initialization of the BlackWhiteFilterDialog class in the Configure method to a new one. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BlackWhiteFilter::Configure(VDXHWND hwnd) { <span class="hljs-function"><span class="hljs-function">BlackWhiteFilterDialog </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dlg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mConfig, fa-&gt;ifp)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dlg.Show((HWND)hwnd); }</code> </pre> <br>  Now you need to work again with the Win32 controls.  In the BlackWhiteFilterDialog class, we will write two methods that connect our configuration and its implementation in a dialog. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> BlackWhiteFilterDialog::LoadFromConfig() { SendDlgItemMessage(mhdlg, IDC_SLIDER_THRESHOLD, TBM_SETPOS, TRUE, mConfigNew.mTreshold); SendMessage(mhdlg, IDC_CHECK_INVERTED, mConfigNew.mInvert, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BlackWhiteFilterDialog::SaveToConfig() { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> threshold = SendDlgItemMessage(mhdlg, IDC_SLIDER_THRESHOLD, TBM_GETPOS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> inverted = SendDlgItemMessage(mhdlg, IDC_CHECK_INVERTED, BM_GETCHECK, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (threshold != mConfigNew.mTreshold || inverted!= mConfigNew.mInvert) { mConfigNew.mTreshold = threshold; mConfigNew.mInvert = inverted; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  It remains to use these two methods in the life cycle of the dialogue.  In OnCommand, for the Ok button, we call SaveToConfig (), and for the Cancel button, we restore the old set of settings by assigning mConfigNew = mConfigOld.  The initial parameters of the dialog are configured in the OnInit () method, the slider range is set to 0-255 and focus is set to it. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BlackWhiteFilterDialog::OnInit() { mConfigOld = mConfigNew; <span class="hljs-comment"><span class="hljs-comment">// Set up slider to range 0-255 SendDlgItemMessage(mhdlg, IDC_SLIDER_THRESHOLD, TBM_SETRANGE, TRUE, MAKELONG(0, 255)); LoadFromConfig(); // gain focus to slide control HWND hwndFirst = GetDlgItem(mhdlg, IDC_SLIDER_THRESHOLD); if (hwndFirst) SendMessage(mhdlg, WM_NEXTDLGCTL, (WPARAM)hwndFirst, TRUE); // init preview button HWND hwndPreview = GetDlgItem(mhdlg, IDC_PREVIEW); if (hwndPreview &amp;&amp; mifp) { EnableWindow(hwndPreview, TRUE); mifp-&gt;InitButton((VDXHWND)hwndPreview); } return false; }</span></span></code> </pre> <br>  Changing the settings should be displayed in the preview window using the RedoFrame () method. To do this, edit the DlgProc method by adding the call to save the parameters in the method in the WM_HSCROLL handler for the slider to check that the Preview window is enabled if (mifp &amp;&amp; SaveToConfig ()) mifp-&gt; RedoFrame ( ).  To process the CheckBox, we add a condition for the case to the IDC_CHECK_INVERTED identifier in the OnCommand method and perform the same update. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IDC_CHECK_INVERTED: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mifp &amp;&amp; SaveToConfig())mifp-&gt;RedoFrame(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br>  Let's rewrite the ToBlackAndWhite method to use the configuration, taking into account two parameters, inversion and threshold values.  The constant BST_UNCHECKED is inherited from the Win32 API and is used as the value of the flag true / false. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mConfig.mInvert == BST_UNCHECKED) { dstline[x] = gray &lt; mConfig.mTreshold ? <span class="hljs-number"><span class="hljs-number">0x00000000</span></span> : <span class="hljs-number"><span class="hljs-number">0x00ffffff</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dstline[x] = gray &gt; =mConfig.mTreshold ? <span class="hljs-number"><span class="hljs-number">0x00000000</span></span> : <span class="hljs-number"><span class="hljs-number">0x00ffffff</span></span>; }</code> </pre> <br>  We put together a project and test the filter in VirtualDub again, turning on the inversion turned the cute cat into something gothic scary. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cv/8b/e4/cv8be4nddekgjia619ts2maxvoe.png"></div><br>  We are left quite a bit before the final.  VirtualDub filters support saving parameters to the settings file, for this you need to serialize our settings class.  To do this, there is a macro VDXVF_DECLARE_SCRIPT_METHODS () which is added to the header of the BlackWhiteFilter class and a set of methods for recording and displaying the settings GetSettingString, GetScriptString and the ScriptConfig method for parsing the parameters from the settings file.  The number and arguments there are specified in the macro VDXVF_DEFINE_SCRIPT_METHOD as the last parameter.  The new version of the BlackWhiteFilter class will look like this. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vd2/VDXFrame/VideoFilter.h&gt; #include &lt;vd2/VDXFrame/VideoFilterEntry.h&gt; #include &lt;BlackWhiteFilterDialog.h&gt; #ifndef FILTER_VD_BLACK_WHITE #define FILTER_VD_BLACK_WHITE extern int g_VFVAPIVersion; class BlackWhiteFilter : public VDXVideoFilter { public: virtual uint32 GetParams(); virtual void Start(); virtual void Run(); virtual bool Configure(VDXHWND hwnd); virtual void GetSettingString(char *buf, int maxlen); virtual void GetScriptString(char *buf, int maxlen); VDXVF_DECLARE_SCRIPT_METHODS(); protected: void ToBlackAndWhite(void *dst, ptrdiff_t dstpitch, const void *src, ptrdiff_t srcpitch, uint32 w, uint32 h); BlackWhiteFilterConfig mConfig; void ScriptConfig(IVDXScriptInterpreter *isi, const VDXScriptValue *argv, int argc); }; #endif</span></span></span></span></code> </pre><br>  We implement methods that are not enough.  We declare the number of parameters and their type in the macro VDXVF_DEFINE_SCRIPT_METHOD, we have two of them, both are integer, so the initialization string will be ‚Äúii‚Äù.  The list of supported formats can be viewed in the class IVDXScriptInterpreter, the whole, fractional and string parameters are available.  The GetSettingString method displays the parameters in the settings bar, it is needed for a person who can quickly see the parameters in the Filters window, in the Filter description column.  The GetScriptString method formats the parameters for saving them to the VirtualDub configuration file (* .vcf) and then reading them with the ScriptConfig method. <br><br><pre> <code class="cpp hljs">VDXVF_BEGIN_SCRIPT_METHODS(BlackWhiteFilter) VDXVF_DEFINE_SCRIPT_METHOD(BlackWhiteFilter, ScriptConfig, <span class="hljs-string"><span class="hljs-string">"ii"</span></span>) VDXVF_END_SCRIPT_METHODS() <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> BlackWhiteFilter::GetSettingString(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxlen) { SafePrintf(buf, maxlen, <span class="hljs-string"><span class="hljs-string">" (Treshold:%d, Invert:%d)"</span></span>, mConfig.mTreshold, mConfig.mInvert); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> BlackWhiteFilter::GetScriptString(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxlen) { SafePrintf(buf, maxlen, <span class="hljs-string"><span class="hljs-string">"Config(%d, %d)"</span></span>, mConfig.mTreshold, mConfig.mInvert); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> BlackWhiteFilter::ScriptConfig(IVDXScriptInterpreter *isi, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VDXScriptValue *argv, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc) { mConfig.mTreshold = argv[<span class="hljs-number"><span class="hljs-number">0</span></span>].asInt(); mConfig.mInvert = argv[<span class="hljs-number"><span class="hljs-number">1</span></span>].asInt(); }</code> </pre> <br>  By adding this code and assembling the plugin, we will be able to see the filter settings in the Filters window and save them to a file via the Save processing setting file menu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vs/1k/f4/vs1kf4cbgcbu-3vrnwnfeanbxz4.png"></div><br>  By default, a project is built with dependencies on the VC Runtime installed in the system, if you plan to use it on other computers, you need to specify the Multi-threaded (/ MT) option from the Configuration-&gt; C / C ++ -&gt; Code Generation-&gt; Runtime Library configuration menu. .  The plugin will increase its size tenfold, but users will not have to select Runtime for the version of Visual Studio that the developer used. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0p/vs/kb/0pvskbg6m2awuuufte2qp94btwu.png"></div><br>  The project code is available on <a href="https://github.com/shadwork/Windows-VirtualDub-Plugin-BlackWhite">github</a> .  The material is aimed at people who need to do something quickly and remember the subtleties of working with the Win32 API reluctance.  I needed this plugin to transfer the video to the platform with a one-bit color representation, and every time I drove a set of frames through XnView. </div><p>Source: <a href="https://habr.com/ru/post/352844/">https://habr.com/ru/post/352844/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352834/index.html">We are programmers</a></li>
<li><a href="../352836/index.html">Why the interface should be accessible to everyone and how to do it</a></li>
<li><a href="../352838/index.html">Your first mobile app: choose a platform</a></li>
<li><a href="../352840/index.html">News from Go, or what's new in GoLand 2018.1</a></li>
<li><a href="../352842/index.html">Arrested the leader of the cyber group, who stole more than 1 billion euros from banks around the world</a></li>
<li><a href="../352846/index.html">Distrust of authority and economy: main trends of millenial investment activity according to Robinhood service statistics</a></li>
<li><a href="../352848/index.html">Backend United # 1. The vinaigrette. Announcement</a></li>
<li><a href="../352850/index.html">We are preparing an iOS client for GraphQL</a></li>
<li><a href="../352852/index.html">Excel-calculator of complex wave resistance transformation on waveguide line segments</a></li>
<li><a href="../352854/index.html">We keep the design of the system under control using isolated unit testing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>