<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementation of the minimization of logical functions by the method of Kvayna \ Mac Klasky</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the possible implementations of the minimization algorithm for logical (Boolean) functions (LF) specified in the form of a perfect disjunctive ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementation of the minimization of logical functions by the method of Kvayna \ Mac Klasky</h1><div class="post__text post__text-html js-mediator-article">  One of the possible implementations of the minimization algorithm for logical (Boolean) functions (LF) specified in the form of a perfect disjunctive normal form (CDNF) by the Quine \ Mac Klaski method (hereinafter referred to simply as Mac Klaski) and the problems identified during its testing are proposed for consideration.  In the studied variant, the McClasky algorithm is implemented in C # using the .NET Generic collections. <br><br>  I would like to note that the task of minimizing LF, in my opinion, is unjustly bypassed by the subject of machine learning algorithms, since in its sense it implements a learning procedure with a teacher for a certain set of input terms (simple conjunctions), on which the optimized function accepts true (true) value.  Consequently, this set of input terms, out of their total number <math> </math> $ inline $ 2 ^ N $ inline $   , where <i>N</i> is the number of two class categorical (binary) variables in terms, is a training sample for a teaching task with a teacher with a known (in this case, true) output value of the objective function.  For all other possible terms that are not included in the training sample, the minimized LF should take a false (false) value. <br><br>  One of the easy-to-implement LF minimization algorithms for any number of variables is the McClasky method.  According to the theory, the McClasky method consists of two main stages: <br><a name="habracut"></a><br><ol><li>  Finding all simple LF terms using the gluing rule (laws): <br>  a) (A &amp; B) ‚à® (A &amp;! B) ‚â° A; <br>  b) (A ‚à® B) &amp; (A! B) ‚â° A; <br>  where &amp; is the logical ‚ÄúAND‚Äù operation;  ‚à® - logical operation "OR" ;!  - the operation of logical negation "NOT". 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li><li>  Minimizing the number of simple terms of the resulting set, as the problem of finding the optimal coverage of a set of subsets of different lengths. </li></ol><br><div class="spoiler">  <b class="spoiler_title">The implementation code is as follows (click to view):</b> <div class="spoiler_text"><pre><code class="hljs perl">using System; using System.IO; using System.Collections.Generic; using System.Linq; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ &lt;summary&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      //<span class="hljs-regexp"><span class="hljs-regexp">/ &lt;/summary</span></span>&gt; public abstract class LogicFunction { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    public readonly ICollection&lt;char[]&gt; Terms = new LinkedList&lt;char[]&gt;(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   public abstract bool Calculate(bool[] X); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   public virtual bool Calculate(char[] X) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Calculate(X.Select(<span class="hljs-string"><span class="hljs-string">p =&gt;</span></span> p != <span class="hljs-string"><span class="hljs-string">'0'</span></span>).ToArray()); } } //<span class="hljs-regexp"><span class="hljs-regexp">/ &lt;summary&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    //<span class="hljs-regexp"><span class="hljs-regexp">/ &lt;/summary</span></span>&gt; public class Dnf : LogicFunction { public override bool Calculate(bool[] X) { bool bResult = false; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (char[] term in Terms) { bool TermVal = true; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; term.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (term[i] == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; TermVal &amp;= (term[i] != <span class="hljs-string"><span class="hljs-string">'0'</span></span> ? X[i] : !X[i]); } bResult |= TermVal; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bResult; } } //<span class="hljs-regexp"><span class="hljs-regexp">/ &lt;summary&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    //<span class="hljs-regexp"><span class="hljs-regexp">/ &lt;/summary</span></span>&gt; public class Knf : LogicFunction { public override bool Calculate(bool[] X) { bool bResult = true; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (char[] term in Terms) { bool TermVal = false; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; term.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (term[i] == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; TermVal |= (term[i] != <span class="hljs-string"><span class="hljs-string">'0'</span></span> ? X[i] : !X[i]); } bResult &amp;= TermVal; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bResult; } } //<span class="hljs-regexp"><span class="hljs-regexp">/ &lt;summary&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ---- //<span class="hljs-regexp"><span class="hljs-regexp">/ &lt;/summary</span></span>&gt; public class Quine_McCluskey { private readonly Dnf _result = new Dnf(); public Dnf Result { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _result; } } //  public void Start(IEnumerable&lt;char[]&gt; TermInput) { LogicFuncMinimize(TermInput, _result.Terms); } //  public void Start(string sFileName) { Start(LoadDsnfFromFile(sFileName)); } //    private static void LogicFuncMinimize(IEnumerable&lt;char[]&gt; X1, ICollection&lt;char[]&gt; OutR) { Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, LinkedList&lt;TreeNodeEnd&gt;&gt; OutTemp = new Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, LinkedList&lt;TreeNodeEnd&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X1.First().Length &lt;= <span class="hljs-number"><span class="hljs-number">40</span></span>) { Dictionary&lt;UInt64, TreeNodeEnd&gt; X1Tree = new Dictionary&lt;UInt64, TreeNodeEnd&gt;(); DeleteDublicatingTerms(X1, X1Tree); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iLevelCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (X1Tree.Count != <span class="hljs-number"><span class="hljs-number">0</span></span>) { Dictionary&lt;UInt64, TreeNodeEnd&gt; X2Tree = new Dictionary&lt;UInt64, TreeNodeEnd&gt;(); Skleivanie(X1Tree, X2Tree, OutTemp, iLevelCounter++); X1Tree = X2Tree; GC.Collect(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        !!! } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TreeFuncTerm X1Tree = new TreeFuncTerm(); DeleteDublicatingTerms(X1, X1Tree); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iLevelCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (X1Tree.Count != <span class="hljs-number"><span class="hljs-number">0</span></span>) { TreeFuncTerm X2Tree = new TreeFuncTerm(); Skleivanie(X1Tree, X2Tree, OutTemp, iLevelCounter++); X1Tree = X2Tree; GC.Collect(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        !!! } } HashSet&lt;TreeNodeEnd&gt; OutRes = new HashSet&lt;TreeNodeEnd&gt;(); ReduceRedundancyTerms(OutTemp, OutRes); OutR.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (TreeNodeEnd term in OutRes) OutR.Add(term.Term); } //         private static ICollection&lt;char[]&gt; LoadDsnfFromFile(string sFullFileName) { ICollection&lt;char[]&gt; DSNF = new LinkedList&lt;char[]&gt;(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    using (StreamReader InFile = new StreamReader(sFullFileName)) { string sLine = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((sLine = InFile.ReadLine()) != null) { DSNF.Add(sLine.ToArray()); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DSNF; } //      //       private static void DeleteDublicatingTerms(IEnumerable&lt;char[]&gt; InX1, Dictionary&lt;UInt64, TreeNodeEnd&gt; OutX2Tree) { OutX2Tree.Clear(); TreeNodeEnd pCurrNode = null; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (char[] x1 in InX1) { UInt64 iCode = GetTermCode(x1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OutX2Tree.ContainsKey(iCode)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; pCurrNode = new TreeNodeEnd(x1, null, null, pCurrNode, OutX2Tree.Count); OutX2Tree.Add(iCode, pCurrNode); } } //      //       private static void DeleteDublicatingTerms(IEnumerable&lt;char[]&gt; InX1, TreeFuncTerm OutX2Tree) { OutX2Tree.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (char[] x1 in InX1) { OutX2Tree.AddTerm(x1, null, null); } } //     private static void Skleivanie(TreeFuncTerm X1Tree, TreeFuncTerm X2Tree, Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, LinkedList&lt;TreeNodeEnd&gt;&gt; OutResult, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iLevel) { LinkedList&lt;TreeNodeEnd&gt; OutR = new LinkedList&lt;TreeNodeEnd&gt;(); OutResult.Add(iLevel, OutR); Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, TreeNodeEnd&gt; FindTerms = new Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, TreeNodeEnd&gt;(); TreeNodeEnd x1 = X1Tree.Last; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x1 != null) { X1Tree.SearchDiff1(x1, FindTerms); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FindTerms.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,       OutR.AddLast(x1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, TreeNodeEnd&gt; kvp in FindTerms) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>,         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x1.Number &lt; kvp.Value.Number) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      char cSymbSav = x1.Term[kvp.Key]; x1.Term[kvp.Key] = <span class="hljs-string"><span class="hljs-string">'*'</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  X2Tree.AddTerm(x1.Term, x1, kvp.Value); x1.Term[kvp.Key] = cSymbSav; } } x1 = x1.Prev; } } //     private static UInt64 GetTermCode(char[] pTerm) { UInt64 iMultip = <span class="hljs-number"><span class="hljs-number">1</span></span>, iCode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pTerm.Length; i++) { switch (pTerm[i]) { case <span class="hljs-string"><span class="hljs-string">'0'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case <span class="hljs-string"><span class="hljs-string">'1'</span></span>: iCode += iMultip; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case <span class="hljs-string"><span class="hljs-string">'*'</span></span>: iCode += (iMultip + iMultip); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } iMultip *= <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iCode; } //     private static void Skleivanie(Dictionary&lt;UInt64, TreeNodeEnd&gt; X1Tree, Dictionary&lt;UInt64, TreeNodeEnd&gt; X2Tree, Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, LinkedList&lt;TreeNodeEnd&gt;&gt; OutResult, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iLevel) { LinkedList&lt;TreeNodeEnd&gt; OutR = new LinkedList&lt;TreeNodeEnd&gt;(); OutResult.Add(iLevel, OutR); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (KeyValuePair&lt;UInt64, TreeNodeEnd&gt; x1 in X1Tree) { bool bIsSkleiv = false; UInt64 iMultip = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iPos = <span class="hljs-number"><span class="hljs-number">0</span></span>; iPos &lt; x1.Value.Term.Length; iPos++) { char cSymbSav = x1.Value.Term[iPos]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cSymbSav != <span class="hljs-string"><span class="hljs-string">'*'</span></span>) { UInt64 iCode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cSymbSav == <span class="hljs-string"><span class="hljs-string">'0'</span></span>) iCode = x1.Key + iMultip; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> //_if (cSymbSav == <span class="hljs-string"><span class="hljs-string">'1'</span></span>) iCode = x1.Key - iMultip; TreeNodeEnd pSkleivNode = null; X1Tree.TryGetValue(iCode, out pSkleivNode); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pSkleivNode != null) { bIsSkleiv = true; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>,         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x1.Value.Number &gt; pSkleivNode.Number) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cSymbSav == <span class="hljs-string"><span class="hljs-string">'0'</span></span>) iCode = x1.Key + iMultip + iMultip; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> //_if (cSymbSav == <span class="hljs-string"><span class="hljs-string">'1'</span></span>) iCode = x1.Key + iMultip; x1.Value.Term[iPos] = <span class="hljs-string"><span class="hljs-string">'*'</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!X2Tree.ContainsKey(iCode)) X2Tree.Add(iCode, new TreeNodeEnd(x1.Value.Term, x1.Value, pSkleivNode, null, X2Tree.Count)); x1.Value.Term[iPos] = cSymbSav; } } } iMultip *= <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!bIsSkleiv) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,       OutR.AddLast(x1.Value); } } } //           . private static void ReduceRedundancyTerms(Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, LinkedList&lt;TreeNodeEnd&gt;&gt; X, HashSet&lt;TreeNodeEnd&gt; ResultNumbers) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ResultNumbers.Clear(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       -    HashSet&lt;TreeNodeEnd&gt; pNumbersForAdd = new HashSet&lt;TreeNodeEnd&gt;(); Dictionary&lt;TreeNodeEnd, uint&gt; Numbers2Terms = new Dictionary&lt;TreeNodeEnd, uint&gt;(); Dictionary&lt;TreeNodeEnd, HashSet&lt;TreeNodeEnd&gt;&gt; Terms2Numbers = new Dictionary&lt;TreeNodeEnd, HashSet&lt;TreeNodeEnd&gt;&gt;(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iLevel in X.Keys.OrderByDescending(<span class="hljs-string"><span class="hljs-string">p =&gt;</span></span> p).AsQueryable()) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (TreeNodeEnd term in X[iLevel]) { HashSet&lt;TreeNodeEnd&gt; TermNumberCont = new HashSet&lt;TreeNodeEnd&gt;(); HashSet&lt;TreeNodeEnd&gt; ListNumbers = new HashSet&lt;TreeNodeEnd&gt;(); ListNumbers.Add(term); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ListNumbers.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { TreeNodeEnd pCurrNode = ListNumbers.First(); ListNumbers.Remove(pCurrNode); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pCurrNode.Parent1 != null &amp;&amp; pCurrNode.Parent2 != null) { ListNumbers.Add(pCurrNode.Parent1); ListNumbers.Add(pCurrNode.Parent2); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Numbers2Terms.ContainsKey(pCurrNode)) Numbers2Terms.Add(pCurrNode, <span class="hljs-number"><span class="hljs-number">0</span></span>); Numbers2Terms[pCurrNode]++; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    TermNumberCont.Add(pCurrNode); } } //<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iIntersectNumbers = pNumbersForAdd.Intersect(TermNumberCont).Count(); <span class="hljs-regexp"><span class="hljs-regexp">//if</span></span> (iIntersectNumbers &lt; TermNumberCont.Count) { pNumbersForAdd.UnionWith(TermNumberCont); Terms2Numbers.Add(term, TermNumberCont); } } } //   -      pNumbersForAdd = new HashSet&lt;TreeNodeEnd&gt;(pNumbersForAdd.OrderBy(<span class="hljs-string"><span class="hljs-string">p =&gt;</span></span> Numbers2Terms[p])); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>           Dictionary&lt;TreeNodeEnd, HashSet&lt;TreeNodeEnd&gt;&gt; SelectedTerms = new Dictionary&lt;TreeNodeEnd, HashSet&lt;TreeNodeEnd&gt;&gt;(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (pNumbersForAdd.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   TreeNodeEnd pSrcTerm = pNumbersForAdd.First(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,         TreeNodeEnd BestTerm = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iBestTermNumbersCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (KeyValuePair&lt;TreeNodeEnd, HashSet&lt;TreeNodeEnd&gt;&gt; CurrTerm in Terms2Numbers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CurrTerm.Value.Contains(pSrcTerm)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iCurrTermNumbersCount = CurrTerm.Value.Intersect(pNumbersForAdd).Count(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((BestTerm == null) || (iBestTermNumbersCount &lt; iCurrTermNumbersCount)) { BestTerm = CurrTerm.Key; iBestTermNumbersCount = iCurrTermNumbersCount; } } ResultNumbers.Add(BestTerm); HashSet&lt;TreeNodeEnd&gt; pBestTermSrcNodes = Terms2Numbers[BestTerm]; Terms2Numbers.Remove(BestTerm); SelectedTerms.Add(BestTerm, pBestTermSrcNodes); pNumbersForAdd.RemoveWhere(<span class="hljs-string"><span class="hljs-string">p =&gt;</span></span> pBestTermSrcNodes.Contains(p)); } //    Terms2Numbers = SelectedTerms; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        TreeNodeEnd termForDelete = null; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { termForDelete = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iTermForDeleteUsedNumbCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (KeyValuePair&lt;TreeNodeEnd, HashSet&lt;TreeNodeEnd&gt;&gt; term1 in SelectedTerms) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iUsedNumbCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (TreeNodeEnd numb in term1.Value) { bool bFind = false; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (KeyValuePair&lt;TreeNodeEnd, HashSet&lt;TreeNodeEnd&gt;&gt; term2 in SelectedTerms) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (term1.Key == term2.Key) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bFind = term2.Value.Contains(numb)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bFind) iUsedNumbCounter++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((iUsedNumbCounter == term1.Value.Count) &amp;&amp; ((termForDelete == null) || (iUsedNumbCounter &lt;= iTermForDeleteUsedNumbCount))) { termForDelete = term1.Key; iTermForDeleteUsedNumbCount = iUsedNumbCounter; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (termForDelete != null) { ResultNumbers.Remove(termForDelete); SelectedTerms.Remove(termForDelete); } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (termForDelete != null); } } //<span class="hljs-regexp"><span class="hljs-regexp">/ &lt;summary&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   //<span class="hljs-regexp"><span class="hljs-regexp">/ &lt;/summary</span></span>&gt; public class TreeFuncTerm { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> private readonly TreeNodeMiddle rootNode = new TreeNodeMiddle(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>          private TreeNodeEnd _lastTreeNode = null; public TreeNodeEnd Last { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _lastTreeNode; } } //     private <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count = <span class="hljs-number"><span class="hljs-number">0</span></span>; public <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _count; } } // public TreeFuncTerm() { Clear(); } //  public void Clear() { rootNode.Clear(); _count = <span class="hljs-number"><span class="hljs-number">0</span></span>; _lastTreeNode = null; } //     public void AddTerm(char[] term, TreeNodeEnd pParent1, TreeNodeEnd pParent2) { TreeNodeMiddle pCurrNode = rootNode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; term.Length; j++) { TreeNodeBase item = pCurrNode.GetChild(term[j]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item == null) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; term.Length) { item = new TreeNodeMiddle(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { item = new TreeNodeEnd(term, pParent1, pParent2, _lastTreeNode, _count); _lastTreeNode = (TreeNodeEnd)item; _count++; } pCurrNode.AddChild(item, term[j]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item is TreeNodeMiddle) pCurrNode = (TreeNodeMiddle)item; } } //          public void SearchDiff1(TreeNodeEnd x1, Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, TreeNodeEnd&gt; result) { result.Clear(); TreeNodeMiddle pCurrNode = rootNode; Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, TreeNodeMiddle&gt; OneDiffNodesList = new Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, TreeNodeMiddle&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iPos = <span class="hljs-number"><span class="hljs-number">0</span></span>; iPos &lt; x1.Term.Length; iPos++) { char cSymbol = x1.Term[iPos]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pCurrNode != null) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cSymbol != <span class="hljs-string"><span class="hljs-string">'*'</span></span>) { TreeNodeBase item = pCurrNode.GetChild(cSymbol == <span class="hljs-string"><span class="hljs-string">'0'</span></span> ? <span class="hljs-string"><span class="hljs-string">'1'</span></span> : <span class="hljs-string"><span class="hljs-string">'0'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item != null) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item is TreeNodeMiddle) { OneDiffNodesList.Add(iPos, (TreeNodeMiddle)item); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> //<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item is TreeNodeEnd) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     result.Add(iPos, (TreeNodeEnd)item); } } } TreeNodeBase pNextNode = pCurrNode.GetChild(cSymbol); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((pNextNode != null) &amp;&amp; (pNextNode is TreeNodeMiddle)) { pCurrNode = (TreeNodeMiddle)pNextNode; } } // ,    , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iKey = <span class="hljs-number"><span class="hljs-number">0</span></span>; iKey &lt; iPos; iKey++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!OneDiffNodesList.ContainsKey(iKey)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; TreeNodeMiddle pValue = OneDiffNodesList[iKey]; TreeNodeBase item = pValue.GetChild(cSymbol); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item == null) { OneDiffNodesList.Remove(iKey); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item is TreeNodeMiddle) { OneDiffNodesList[iKey] = (TreeNodeMiddle)item; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> //<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item is TreeNodeEnd) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     result.Add(iKey, (TreeNodeEnd)item); } } } } } //<span class="hljs-regexp"><span class="hljs-regexp">/ &lt;summary&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      //<span class="hljs-regexp"><span class="hljs-regexp">/ &lt;/summary</span></span>&gt; public interface TreeNodeBase { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   void Clear(); } //<span class="hljs-regexp"><span class="hljs-regexp">/ &lt;summary&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     //<span class="hljs-regexp"><span class="hljs-regexp">/ &lt;/summary</span></span>&gt; public class TreeNodeEnd : TreeNodeBase { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>,   private char[] _term; public char[] Term { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _term; } } //            private TreeNodeEnd _prev; public TreeNodeEnd Prev { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _prev; } } //        private TreeNodeEnd _parent1; public TreeNodeEnd Parent1 { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _parent1; } } //        private TreeNodeEnd _parent2; public TreeNodeEnd Parent2 { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _parent2; } } // ,           public readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Number; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> public TreeNodeEnd(char[] pTermRef, TreeNodeEnd pParent1, TreeNodeEnd pParent2, TreeNodeEnd pPrevTreeNode, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iNumber) { pTermRef.CopyTo(_term = new char[pTermRef.Length], <span class="hljs-number"><span class="hljs-number">0</span></span>); _parent1 = pParent1; _parent2 = pParent2; _prev = pPrevTreeNode; Number = iNumber; } //   public void Clear() { _term = null; _parent1 = null; _parent2 = null; _prev = null; } } //<span class="hljs-regexp"><span class="hljs-regexp">/ &lt;summary&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     //<span class="hljs-regexp"><span class="hljs-regexp">/ &lt;/summary</span></span>&gt; public class TreeNodeMiddle : TreeNodeBase { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  private TreeNodeBase Childs<span class="hljs-number"><span class="hljs-number">0</span></span>; private TreeNodeBase Childs1; private TreeNodeBase Childs2; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   public void Clear() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Childs<span class="hljs-number"><span class="hljs-number">0</span></span> != null) &amp;&amp; (Childs<span class="hljs-number"><span class="hljs-number">0</span></span> is TreeNodeMiddle)) ((TreeNodeMiddle)Childs<span class="hljs-number"><span class="hljs-number">0</span></span>).Clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Childs1 != null) &amp;&amp; (Childs1 is TreeNodeMiddle)) ((TreeNodeMiddle)Childs1).Clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Childs2 != null) &amp;&amp; (Childs2 is TreeNodeMiddle)) ((TreeNodeMiddle)Childs2).Clear(); Childs<span class="hljs-number"><span class="hljs-number">0</span></span> = Childs1 = Childs2 = null; } //   public TreeNodeBase GetChild(char cSymbol) { switch (cSymbol) { case <span class="hljs-string"><span class="hljs-string">'0'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Childs<span class="hljs-number"><span class="hljs-number">0</span></span>; case <span class="hljs-string"><span class="hljs-string">'1'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Childs1; case <span class="hljs-string"><span class="hljs-string">'*'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Childs2; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } //   public void AddChild(TreeNodeBase newChild, char cSymbol) { switch (cSymbol) { case <span class="hljs-string"><span class="hljs-string">'0'</span></span>: Childs<span class="hljs-number"><span class="hljs-number">0</span></span> = newChild; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case <span class="hljs-string"><span class="hljs-string">'1'</span></span>: Childs1 = newChild; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case <span class="hljs-string"><span class="hljs-string">'*'</span></span>: Childs2 = newChild; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre> <br></div></div><br>  The Quine_McCluskey class is actually an implementation of this algorithm, which is assisted by other classes and interfaces: Dnf, TreeNodeBase, TreeNodeMiddle, TreeNodeEnd, TreeFuncTerm.  To start the optimization, you need to call one of the overloaded Start methods. <br><br>  In paragraph 1, repeated pairwise search of a term occurs in order to identify the possibility of their gluing.  Two terms are glued together if they differ from each other in values ‚Äã‚Äãonly in one of the positions: one has '0', and the other has '1'.  Adhering source (parent) terms are excluded from further work, and instead of two of them, the next child term is considered at the next iteration of Section 1 of the algorithm, with the term '*' in the position of differing parent variable variables.  Thus, the binary alphabet of the input source terms inside the algorithm expands to the ternary one: '0', '1', '*'. <br><br>  Point 1 in the Quine_McCluskey class is implemented in the LogicFuncMinimize procedure in two fundamentally different ways.  The first method, based on 64-bit integer hash codes and searching in the .NET Dictionary &lt;UInt64, ...&gt; dictionary, works when the number of input variables of the Boolean function is less than or equal to 40, and the second one, based on the search in the ternary tree, is activated when more quantity.  This bifurcation is due to the fact that the first method works somewhat faster than the second one, therefore its use is higher priority, but it works correctly only with the number of input variables up to 40, and with more of them, the bit grid of the integer hash code used for the operation of the algorithm.  Indeed, since ternary logic is used in terms within the algorithm, then when the number of input variables is 41, the maximum hash code value <math> </math> $ inline $ 3 ^ {41} $ inline $   already exceeds the maximum value ( <math> </math> $ inline $ 2 ^ {64} $ inline $   -1), which can be written to 64 bit variable. <br><br>  The second method of operation of clause 1, which operates when the number of variables in the input terms is more than 40, is based on the search tree term TreeFuncTerm.  Intermediate nodes of the tree are implemented using the TreeNodeMiddle class.  Each of them can refer to a maximum of three subsequent nodes, depending on whether the corresponding terms have been added to the tree.  All leaf nodes are instances of the TreeNodeEnd class, the depth to which they are all the same from the root and equal to the number of input variables.  Each leaf node also has a link to another TreeNodeEnd node that was added to it, thus implementing a unidirectional linked list.  This kind of list is used to quickly search through all the final nodes of the search tree in the process of gluing them. <br><br>  If in clause 1 for a term there is no other term that differs from it only in one position, i.e., the term does not stick to anyone, then it is considered to be one of the results of clause 1 of the algorithm, excluded from further work in it and enters to the input of paragraph 2 of the algorithm, implemented in the procedure ReduceRedundancyTerms. <br><br>  Discarding redundant terms in ReduceRedundancyTerms is performed using an algorithm for approximate solving the problem of covering a set of variable-length sets with subsets.  A close to the shortest coverage gives a cover table (TP) conversion algorithm based on the ‚Äúminimum column-maximum row‚Äù method, which can be viewed, for example, <a href="http://www.studfiles.ru/preview/5175815/page:4/">here</a> . <br><br>  The approximate logic of his work is as follows: <br><br><ol><li>  The source table is considered to be the current transformable TP, the set of rows of covers is empty; </li><li>  The current table is highlighted in the column with the smallest number of units.  Among the rows containing the units in this column, the one with the most units is selected.  This row is included in the coverage, the current table is shortened by deleting all columns in which the selected row has one; </li><li>  If there are not crossed out columns in the table, then p.2 is executed, otherwise the coating is constructed. </li></ol><br>  Note: When counting the number of units in a row, the units in the uncut columns are taken into account. <br><br>  To test the algorithm, two test functions are used.  The first procedure allows for a set of input variables of the number <i>N to</i> form a set of term number <math> </math> $ inline $ 2 ^ N $ inline $   , calculate the random value of LF for each term and upload to the file only those terms for which the corresponding value of the function was TRUE.  After that, the correctness of the minimized form of the function is checked by calculating its value for each term and comparing with the original one. <br><br><div class="spoiler">  <b class="spoiler_title">TestQuineMcCluskeyRandom (click to view)</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> TestQuineMcCluskeyRandom(string sFileName, <span class="hljs-type"><span class="hljs-type">int</span></span> iVariableAmount) { <span class="hljs-type"><span class="hljs-type">int</span></span> iTotalCombines = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; iVariableAmount; ICollection&lt;KeyValuePair&lt;string, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt; FuncResult = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> List&lt;KeyValuePair&lt;string, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt;(iTotalCombines); File.<span class="hljs-keyword"><span class="hljs-keyword">Delete</span></span>(sFileName); Random rnd = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Random(); <span class="hljs-type"><span class="hljs-type">int</span></span> iLogicFuncMask = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (iLogicFuncMask == <span class="hljs-number"><span class="hljs-number">0</span></span>) iLogicFuncMask = rnd.Next(iTotalCombines); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> iCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; iCounter &lt; iTotalCombines; iCounter++) { <span class="hljs-type"><span class="hljs-type">int</span></span> iCurValue = iCounter; string sLine = ""; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iVariableAmount; i++) { sLine += (iCurValue % <span class="hljs-number"><span class="hljs-number">2</span></span>).ToString(); iCurValue /= <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-type"><span class="hljs-type">bool</span></span> bFuncValue = (iCounter &amp; iLogicFuncMask) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bFuncValue) { File.AppendAllText(sFileName, sLine + Environment.NewLine); } FuncResult.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> KeyValuePair&lt;string, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;(sLine, bFuncValue)); } //   DateTime DtStart = DateTime.Now; Console.WriteLine(" - " + DtStart.ToLongTimeString()); Quine_McCluskey Logic = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Quine_McCluskey(); Logic.<span class="hljs-keyword"><span class="hljs-keyword">Start</span></span>(sFileName); DateTime DtEnd = DateTime.Now; TimeSpan Elapsed = DtEnd - DtStart; Console.WriteLine(" - " + DtEnd.ToLongTimeString()); Console.WriteLine(" - " + String.Format("{0:00}:{1:00}:{2:00}", Elapsed.Hours, Elapsed.Minutes, Elapsed.Seconds)); //  <span class="hljs-type"><span class="hljs-type">int</span></span> iErrorsCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (KeyValuePair&lt;string, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt; kvp <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> FuncResult) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Logic.Result.Calculate(kvp.Key.ToArray()) != kvp.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>) iErrorsCounter++; } Console.WriteLine("-  = " + Logic.Result.Terms.Count); Console.WriteLine("-  = " + iErrorsCounter); Console.ReadLine(); }</code> </pre><br></div></div><br>  The second test procedure allows you to load from the file the sets recorded by the previous test function TestQuineMcCluskeyRandom, for which the boolean procedure should be TRUE and verify the correctness of the minimized function. <br><br><div class="spoiler">  <b class="spoiler_title">TestQuineMcCluskeyFile (click to view)</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> TestQuineMcCluskeyFile(string sFileName, <span class="hljs-type"><span class="hljs-type">int</span></span> iVariableAmount) { <span class="hljs-type"><span class="hljs-type">int</span></span> iTotalCombines = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; iVariableAmount; ICollection&lt;KeyValuePair&lt;string, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt; FuncResult = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> List&lt;KeyValuePair&lt;string, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;&gt;(iTotalCombines); string sFileContent = File.ReadAllText(sFileName); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> iCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; iCounter &lt; iTotalCombines; iCounter++) { <span class="hljs-type"><span class="hljs-type">int</span></span> iCurValue = iCounter; string sLine = ""; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iVariableAmount; i++) { sLine += (iCurValue % <span class="hljs-number"><span class="hljs-number">2</span></span>).ToString(); iCurValue /= <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-type"><span class="hljs-type">bool</span></span> bFuncValue = sFileContent.Contains(sLine + Environment.NewLine); FuncResult.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> KeyValuePair&lt;string, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt;(sLine, bFuncValue)); } //   DateTime DtStart = DateTime.Now; Console.WriteLine(" - " + DtStart.ToLongTimeString()); Quine_McCluskey Logic = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Quine_McCluskey(); Logic.<span class="hljs-keyword"><span class="hljs-keyword">Start</span></span>(sFileName); DateTime DtEnd = DateTime.Now; TimeSpan Elapsed = DtEnd - DtStart; Console.WriteLine(" - " + DtEnd.ToLongTimeString()); Console.WriteLine(" - " + String.Format("{0:00}:{1:00}:{2:00}", Elapsed.Hours, Elapsed.Minutes, Elapsed.Seconds)); //  <span class="hljs-type"><span class="hljs-type">int</span></span> iErrorsCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (KeyValuePair&lt;string, <span class="hljs-type"><span class="hljs-type">bool</span></span>&gt; kvp <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> FuncResult) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Logic.Result.Calculate(kvp.Key.ToArray()) != kvp.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>) iErrorsCounter++; } Console.WriteLine("-  = " + Logic.Result.Terms.Count); Console.WriteLine("-  = " + iErrorsCounter); Console.ReadLine(); }</code> </pre><br></div></div><br>  When testing the implementation of the Mac-Klasky algorithm, its essential drawback was revealed: when the number of input variables in terms is more or equal to 16, the program is terminated due to the lack of memory in the Skleivanie procedure on the lines: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">X2Tree</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Add</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">iCode</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">TreeNodeEnd</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Term</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">x1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Value</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">pSkleivNode</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">null</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">X2Tree</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Count</span></span>)); <span class="hljs-selector-tag"><span class="hljs-selector-tag">X2Tree</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.AddTerm</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Term</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">x1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">kvp</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Value</span></span>);</code> </pre><br>  Moreover, this problem occurs when working on the first and second versions of paragraph 1, respectively, the order of the lines above, which are briefly described at the beginning of the article. <br><br>  However, it should be noted that the problem of low memory arises only if optimization occurs on a set of input terms of a size slightly smaller than the maximum number <math> </math> $ inline $ 2 ^ N $ inline $   where <i>N</i> is the number of variables.  If an abbreviated (incomplete) set is used with the number Q &lt;Q  p &lt; <math> </math> $ inline $ 2 ^ N $ inline $   , then the problem does not arise until the size of the input data set exceeds a certain threshold Qth critical for the algorithm. <br><br>  As possible ways to overcome this problem, the possibility of defining TreeNodeEnd and TreeNodeMiddle not in the form of C # language classes, but in the form of structures was investigated.  But due to the fundamental difference between classes and structures, consisting in the fact that it is impossible to get a reference to the structure, this path turned out to be a dead end due to the fact that the implementation in question is based on the references to TreeNodeEnd and TreeNodeMiddle. <br><br>  Another way to overcome the memory problem was to maximize memory clearing by the garbage collector before each iteration in the inside of item 1, where extreme memory consumption occurs.  To do this, explicit calls to the garbage collector have been added to the LogicFuncMinimize function code.  It turned out that working time with garbage is much less than without it!  Although it would seem that time should be wasted on the work of the garbage collector, which should have worsened the result.  A possible explanation of this ‚Äúphenomenon‚Äù is that the release of memory by the collector reduces its defragmentation in the heap, which has a positive effect on the speed of searching for free sites during its subsequent mass allocation. <br><br>  I do not see any other possibilities for overcoming troubles with a lack of memory.  In this connection, the question arises whether it is possible to change something in order to achieve stable operation of the algorithm on the full set of input terms with the number of variables at least up to 30?  Or is it a congenital property of this algorithm that cannot be corrected? <br><br>  Nevertheless, in spite of possible memory problems, the proposed implementation of the McClasky algorithm in real-world problems can be used as a sufficiently fast and reliable LF optimizer, given by a set of terms of its input variables, in which the logical function takes the true value when the number of variables <i>N</i> &lt;16 or the number of term Q &lt;&lt; <math> </math> $ inline $ 2 ^ N $ inline $   . </div><p>Source: <a href="https://habr.com/ru/post/328506/">https://habr.com/ru/post/328506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328496/index.html">Why business processes are not scary</a></li>
<li><a href="../328498/index.html">Unity3d We play with the mesh. Part 1 - Generating a mesh using an elevation map</a></li>
<li><a href="../328500/index.html">New Rust-mitap is already on May 18 in the LC: come - it will be useful</a></li>
<li><a href="../328502/index.html">Cisco ACR 2017 Threat Research: Changes on the Other Side of the Barricade</a></li>
<li><a href="../328504/index.html">Interesting questions on knowledge of C # and .NET mechanisms</a></li>
<li><a href="../328508/index.html">A blood test: from a light microscope to hematology analyzers</a></li>
<li><a href="../328510/index.html">GameDev from scratch: How to get out of chaos and start working</a></li>
<li><a href="../328512/index.html">Turns the screen on Android without pain</a></li>
<li><a href="../328516/index.html">Using NES-game research tools on the example of parsing the Felix The Cat compression format</a></li>
<li><a href="../328518/index.html">Preview Rambler.iOS # 9</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>