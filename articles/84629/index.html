<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How GIL works in Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Why after paralleling the execution of your program can be halved? 
 Why after creating a stream does Ctrl-C stop working? 
 I present to you the tran...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How GIL works in Python</h1><div class="post__text post__text-html js-mediator-article">  Why after paralleling the execution of your program can be halved? <br>  Why after creating a stream does Ctrl-C stop working? <br>  I present to you the translation of David Beazley <a href="http://www.dabeaz.com/python/GIL.pdf">'s</a> article <a href="http://www.dabeaz.com/python/GIL.pdf">‚ÄúInside the Python GIL‚Äù</a> .  It discusses some of the subtleties of streaming and signal processing in Python. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/186/54c/962/18654c9629e7361c85336380dd7c466d.png" alt="GIL"><br><a name="habracut"></a><br><h4>  Introduction </h4><br>  As you know, in Python, Global Interpreter Lock (GIL) is used, which imposes some restrictions on threads.  Namely, you can not use multiple processors at the same time.  This is a hackneyed topic for Python's holivars, along with tail-call optimization, lambda, whitespace, etc. <br><br><h4>  Disclaimer </h4><br>  I am not deeply perturbed about using GIL in Python.  But for parallel computing using multiple CPUs, I prefer messaging and inter-process interaction using threads.  However, I am interested in the unexpected behavior of GIL on multi-core processors. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Performance test </h4><br>  Consider a trivial CPU-dependent function (i.e., a function whose execution speed depends mainly on processor performance): <br><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: n -= <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  First, run it twice in turn: <br><pre> <code class="hljs swift"><span class="hljs-built_in"><span class="hljs-built_in">count</span></span>(<span class="hljs-number"><span class="hljs-number">100000000</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>(<span class="hljs-number"><span class="hljs-number">100000000</span></span>)</code> </pre><br>  Now run it in parallel in two threads: <br><pre> <code class="hljs swift">t1 = <span class="hljs-type"><span class="hljs-type">Thread</span></span>(target=<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>,args=(<span class="hljs-number"><span class="hljs-number">100000000</span></span>,)) t1.start() t2 = <span class="hljs-type"><span class="hljs-type">Thread</span></span>(target=<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>,args=(<span class="hljs-number"><span class="hljs-number">100000000</span></span>,)) t2.start() t1.<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>(); t2.<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>()</code> </pre><br>  The following results were obtained on a dual-core MacBook: <br><ul><li>  sequential launch - <b>24.6 s</b> </li><li>  parallel launch - <b>45.5 s</b> (almost 2 times slower!) </li><li>  parallel start after disabling one of the cores - <b>38.0 s</b> </li></ul><br>  I <i>do not like</i> inexplicable magical phenomena.  As part of a project launched by me in May, I began to understand the implementation of GIL in order to understand <i>why</i> I received such results.  I went through all the steps, starting with the Python scripts and ending with the source code of the pthreads library (yes, maybe I should go out more often).  So let's get this in order. <br><br><h4>  More about threads </h4><br>  Python threads are real threads (POSIX threads or Windows threads), fully controlled by the OS.  Consider threading through the Python interpreter process (written in C).  When creating a thread, it simply executes the run () method of the Thread object or any given function: <br><pre> <code class="hljs python"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CountdownThread</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(threading.Thread)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,count)</span></span></span><span class="hljs-function">:</span></span> threading.Thread.__init__(self) self.count = count ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Counting down"</span></span>, self.count self.count -= <span class="hljs-number"><span class="hljs-number">1</span></span> time.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre><br>  In fact, much more happens.  Python creates a small data structure (PyThreadState) that lists: the current stack frame in Python code, the current recursion depth, the thread identifier, some information about exceptions.  The structure is less than 100 bytes.  Then a new thread (pthread) is started, in which C code calls PyEval_CallObject, which starts what is specified in Python callable. <br><br>  The interpreter stores in the global variable a pointer to the current active thread.  The actions performed are entirely dependent on this variable: <br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/* Python/pystate.c */</span></span> ... PyThreadState *_PyThreadState_Current = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>;</code> </pre><br><h4>  The infamous gil </h4><br>  That's the catch: at any time, only one Python stream can be executed.  Global interpreter locking - GIL - carefully monitors thread execution.  GIL guarantees each thread <i>exclusive</i> access to interpreter variables (and the corresponding C-extension calls work correctly). <br><br>  The principle of operation is simple.  Threads hold GIL while they are running.  However, they release it when blocking for I / O operations.  Each time a thread is forced to wait, others that are ready for execution, the threads use their chance to start. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/511/3b5/d65/5113b5d653969216cff4d9dd6ec929b2.png" alt="GIL"><br><br>  When working with CPU-dependent threads that never perform I / O operations, the interpreter periodically checks (‚Äúthe periodic check‚Äù). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/41a/f47/64d/41af4764d00082dcec7989ac9dd3a5a5.png" alt="GIL"><br><br>  By default, this happens every 100 ticks, but this parameter can be changed using sys.setcheckinterval ().  The check interval is a global counter that is completely independent of the order in which threads are switched. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ff/daf/140/2ffdaf1406a87c6f8d5b51c9cc6b94f2.png" alt="GIL"><br><br>  When periodically checking in the main thread, signal handlers are started, if any.  Then GIL turns off and on again.  At this stage, it is possible to switch several CPU-dependent threads (with a short release of GIL, other threads have a chance to start). <br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/* Python/ceval.c */</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (--_Py_Ticker &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ... _Py_Ticker = _Py_CheckInterval; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (things_to_do) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Py_MakePendingCalls() &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ... } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interpreter_lock) { <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> ... PyThread_release_lock(interpreter_lock); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> PyThread_acquire_lock(interpreter_lock, <span class="hljs-number"><span class="hljs-number">1</span></span>); ... }</code> </pre><br>  Ticks roughly correspond to the execution of instructions of the interpreter.  They are <i>not based</i> on time.  In fact, a long operation can block everything: <br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; nums = xrange(<span class="hljs-number"><span class="hljs-number">100000000</span></span>) &gt;&gt;&gt; -<span class="hljs-number"><span class="hljs-number">1</span></span> in nums <span class="hljs-comment"><span class="hljs-comment"># 1  (6,6 ) False &gt;&gt;&gt;</span></span></code> </pre><br>  Tiki can not be interrupted, Ctrl-C in this case will not stop the program. <br><br><h4>  Signals </h4><br>  Let's talk about Ctrl-C.  A very common problem is that a program with multiple threads cannot be interrupted using keyboard interrupt.  This is <i>very annoying</i> (you have to use kill -9 in a separate window).  <i>(From the translator: I managed to kill such programs by Ctrl + F4 in the terminal window.)</i> It's amazing why Ctrl-C doesn't work? <br><br>  When a signal arrives, the interpreter starts a ‚Äúcheck‚Äù <i>after each tick</i> , until the main thread starts.  Since signal handlers can only be run in the main thread, the interpreter often turns off and on GIL until the main thread starts. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb0/c73/2b9/cb0c732b9aa1c75dab9a29083cc797b2.png" alt="GIL"><br><br><h4>  Thread Scheduler </h4><br>  Python does not have the means to determine which thread should start next.  No prioritization, preemptive multitasking, round-robin, etc.  This function is entirely assigned to the operating system.  This is one of the reasons for the strange operation of the signals: the interpreter cannot control the start of threads in any way, it simply switches them as often as possible, hoping that the main thread will start. <br><br>  Ctrl-C often does not work in multi-threaded programs, because the main thread is usually blocked by uninterrupted thread-join or lock.  While it is locked, it will not start.  As a result, it will not be able to execute a signal handler. <br><br>  As an added bonus, the interpreter remains in a state where it tries to switch the stream after each tick.  Not only can you not interrupt the program, it also works more slowly. <br><br><h4>  GIL implementation </h4><br>  GIL is not an ordinary mutex.  This is either a nameless POSIX semaphore, or the pthreads conditional variable.  Interpreter blocking is based on sending signals. <br><ul><li>  To enable GIL, check if it is free.  If not, wait for the next signal. </li><li>  To turn GIL off, release it and send a signal. </li></ul><br>  Switching threads fraught with more subtleties than programmers usually think. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bdf/5ac/8b2/bdf5ac8b2e98daf751e2eaa4c7b7d0b4.png" alt="GIL"><br><br>  The delay between sending a signal and starting a stream can be quite substantial, it depends on the operating system.  And it takes into account the priority of implementation.  At the same time, tasks requiring I / O operations have a higher priority than CPU-dependent ones.  If a signal is sent to a low priority thread, and the processor is busy with more important tasks, then this thread will not run for a long time. <br><br>  As a result, the signals that the GIL stream sends out becomes too much. <br>  Every 100 ticks, the interpreter blocks the mutex, sends a signal to a variable or semaphore process that waits for this <i>all the time</i> . <br><br>  Let's measure the number of system calls. <br>  For sequential execution: 736 (Unix), 117 (Mac). <br>  For two streams: 1149 (Unix), <b>3.3 million</b> (Mac). <br>  For two threads on a dual-core system: 1149 (Unix), <b>9.5 million</b> (Mac). <br><br>  On a multi-core system, CPU-dependent processes are switched simultaneously (on different cores), resulting in a battle for GIL: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/582/f91/16f/582f9116f226b74ca3459e7100717735.png" alt="GIL"><br><br>  A waiting thread may make hundreds of unsuccessful attempts to capture GIL. <br>  We see the battle for two mutually exclusive goals going on.  Python just wants to run no more than one thread at a time.  And the operating system (‚ÄúOoo, many cores!‚Äù) Generously switches threads, trying to extract the maximum benefit from all cores. <br><br>  Even a single CPU-dependent thread causes problems ‚Äî it increases the response time of an I / O-dependent thread. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/186/54c/962/18654c9629e7361c85336380dd7c466d.png" alt="GIL"><br><br>  The final example is the bizarre form of the problem of changing priorities.  A CPU-dependent process (low priority) blocks the execution of an I / O-dependent (high priority).  This happens only on multi-core processors, because the I / O stream cannot wake up quickly enough and get GIL before a CPU-dependent one. <br><br><h4>  Conclusion </h4><br>  The implementation of GIL in Python has hardly changed in the last 10 years.  The corresponding code in Python 1.5.2 looks almost the same as in Python 3.0.  I don‚Äôt know if GIL‚Äôs behavior has been well studied (especially on multi-core processors).  It is more useful to delete GIL in general, than to change it.  It seems to me that this subject requires further study.  If GIL stays with us, it's worth correcting its behavior. <br><br>  How to get rid of this problem?  I have a few vague ideas, but they are all "complicated."  It is necessary for Python to have its own thread manager (or at least an interaction mechanism with the OS dispatcher).  But this requires a non-trivial interaction between the interpreter, the OS scheduler, the thread library, and, worst of all, the C-extension modules. <br><br>  Is it worth it?  Correcting GIL's behavior would make the execution of threads (even with GIL) more predictable and less demanding of resources.  It may improve performance and decrease application response time.  I hope, at the same time it will be possible to avoid a complete rewriting of the interpreter. <br><br><h4>  Afterword from the translator </h4><br>  The original was designed as a presentation, so I had to change the order of the story a little to make the article easier to read.  I also excluded traces of the interpreter's work - if you are interested, look in the original. <br><br>  Habralyudi, advise interesting English articles on Python, which would be good to translate.  I have in mind a couple of articles, but I want more options. </div><p>Source: <a href="https://habr.com/ru/post/84629/">https://habr.com/ru/post/84629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../84616/index.html">Award for 10 billion downloads from iTunes</a></li>
<li><a href="../84620/index.html">Where did Akado get my personal data?</a></li>
<li><a href="../84625/index.html">Drupal nostalgia</a></li>
<li><a href="../84627/index.html">Web interface for runit</a></li>
<li><a href="../84628/index.html">Test budget navigator Lexand si-365</a></li>
<li><a href="../84631/index.html">the cheapest mobile phones in the world</a></li>
<li><a href="../84635/index.html">SUID and security</a></li>
<li><a href="../84638/index.html">Over 100 Android phones in 2010</a></li>
<li><a href="../84640/index.html">JetBrains PhpStorm (AKA WebIDE) - Public Assembly 94.335</a></li>
<li><a href="../84646/index.html">Alphabet n516</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>