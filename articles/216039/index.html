<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Transcend WiFi. We write client Shoot & View for Windows, Mac and Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√©, they repeatedly mentioned the SDHC memory card with an integrated WiFi transmitter. Having bought this card, I was disappointed with the ter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Transcend WiFi. We write client Shoot & View for Windows, Mac and Linux</h1><div class="post__text post__text-html js-mediator-article"><img width="400" align="left" src="https://habrastorage.org/getpro/habr/post_images/16b/e18/a55/16be18a553ec0063b4fd4c36013923c0.jpg">  On Habr√©, they repeatedly <a href="http://habrahabr.ru/post/191742/">mentioned</a> the SDHC memory card with an integrated WiFi transmitter.  Having bought this card, I was disappointed with the terrible software that comes bundled with the card.  If an application for iOS and Android can be used at least as it is, then the lack of a client under windows and macos prevents the card from being used by professionals.  More precisely, the PC has a web interface, but apart from the terrible appearance, I was disappointed by the lack of the Shoot &amp; View function in demand by photographers, which allows you to see the result of shooting on the big computer screen almost instantly. <br><br>  Fans of geek-porno will most likely be disappointed - we will not modify the firmware, hack it, open the memory card itself.  We will work with the "stock" memory card, without any modifications. <br><br>  So, in this article, we will analyze the Transcend WiFi card's Shoot &amp; View protocol and write a cross-platform client on python that will run on windows, linux and MacOS.  And for the most impatient, at the end of the article you will find a ready python module for your projects, a console client, as well as a GUI utility that runs on windows, linux and macos. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  Search memory card online. </h4><br>  A memory card can operate in two modes - the access point mode, when the card creates its own access point, and the connection mode to the access point, when the card ‚Äúclings‚Äù to the access points previously set in its settings.  For our experiments, it is better to enable the connection mode to the access point, having previously configured the connection from the application to android or ios.  Just do not forget to configure ‚ÄúTurn Off WiFi‚Äù by setting Never.  This option is responsible for disabling WiFi, if no one has connected to the map.  In the first stage, I advise you to connect the card to the card reader, or set up the camera so that it does not turn off when idle. <br><br>  Perhaps we begin to program.  For the console client, we will not need any additional modules, only ‚Äúbatteries included‚Äù.  And we begin with: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> socket <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SDCard</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,home_dir=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self.home_dir=home_dir <span class="hljs-comment"><span class="hljs-comment">#  ip  ,       self.ip=socket.gethostbyname(socket.gethostname()) #   ip  self.card_ip=None if __name__=='__main__': #      HOME_DIR=os.path.expanduser('~') if not os.path.exists(HOME_DIR+'/'+'ShootAndView'): os.mkdir(HOME_DIR+'/'+'ShootAndView') HOME_DIR=HOME_DIR+'/ShootAndView/' sd=SDCard(home_dir=HOME_DIR)</span></span></code> </pre> <br><br>  If the card is connected to an access point, its ip-address can be viewed, for example, in the router's web interface, and if we have a direct connection to the card, then its ip-address is 192.168.11.254 (in accordance with the default settings). <br>  But I don‚Äôt want to search for it manually, especially as the map creators provided for searching it on the network, as it was done in a mobile application.  For this we need: <br><ol><li>  Create a socket on port 58255 </li><li>  Send an empty broadcast request to port 55777 </li><li>  Expect a <s>miracle</s> card response </li></ol><br>  If we are lucky, we will receive the following text in response: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Transcend</span></span> WiFiSD - interface=mlan0 ip=<span class="hljs-number"><span class="hljs-number">192.168.0.16</span></span> netmask=<span class="hljs-number"><span class="hljs-number">255.255.255.0</span></span> router=<span class="hljs-number"><span class="hljs-number">192.168.0.1</span></span> mode=client essid=WiFiSDCard apmac=CE:5D:4E:5B:<span class="hljs-number"><span class="hljs-number">70</span></span>:<span class="hljs-number"><span class="hljs-number">48</span></span></code> </pre><br>  From all this, we need only the ip address.  Now it remains to program the whole thing: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> socket <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> thread <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SDCard</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,home_dir=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self.home_dir=home_dir self.ip=socket.gethostbyname(socket.gethostname()) self.card_ip=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_card</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,callback=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    """</span></span> thread.start_new_thread(self.find_card_thread,(callback,)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_card_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,callback=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.card_ip: <span class="hljs-string"><span class="hljs-string">""" UDP  """</span></span> s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.settimeout(<span class="hljs-number"><span class="hljs-number">5</span></span>) s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number"><span class="hljs-number">1</span></span>) s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"""      """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>:s.bind((self.ip, <span class="hljs-number"><span class="hljs-number">58255</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> socket.error: s.close() time.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-string"><span class="hljs-string">"""      55777"""</span></span> s.sendto(<span class="hljs-string"><span class="hljs-string">''</span></span>, (<span class="hljs-string"><span class="hljs-string">'&lt;broadcast&gt;'</span></span>, <span class="hljs-number"><span class="hljs-number">55777</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: resp=s.recv(<span class="hljs-number"><span class="hljs-number">400</span></span>) s.close() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-string"><span class="hljs-string">"""    """</span></span> self.card_ip=resp.split(<span class="hljs-string"><span class="hljs-string">'ip='</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>].split(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> IndexError: <span class="hljs-string"><span class="hljs-string">"""     """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> callback:callback(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-string"><span class="hljs-string">"""   ip"""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> callback:callback(self.card_ip) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> socket.timeout: callback(self.card_ip) <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: time.sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">monitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ip)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> ip:<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'Find card on ip:'</span></span>,ip <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__==<span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: HOME_DIR=os.path.expanduser(<span class="hljs-string"><span class="hljs-string">'~'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(HOME_DIR+<span class="hljs-string"><span class="hljs-string">'/'</span></span>+<span class="hljs-string"><span class="hljs-string">'ShootAndView'</span></span>): os.mkdir(HOME_DIR+<span class="hljs-string"><span class="hljs-string">'/'</span></span>+<span class="hljs-string"><span class="hljs-string">'ShootAndView'</span></span>) HOME_DIR=HOME_DIR+<span class="hljs-string"><span class="hljs-string">'/ShootAndView/'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> options.dir:HOME_DIR=options.dir sd=SDCard(home_dir=HOME_DIR) <span class="hljs-comment"><span class="hljs-comment">#      "", #    GUI    sd.find_card(callback=monitor) #       , #     while 1: time.sleep(1)</span></span></code> </pre><br><br>  In fact, the hard part is over.  It remains only to find out how we can receive information about the ‚Äúarrival‚Äù of new photos and download them. <br><br><h4>  Getting new photos. </h4><br>  With the receipt of photos, everything is very simple.  After we have found the card, it is enough to join the card on port 5566. <br>  Now, as soon as the camera makes a new frame, after 7-8 seconds, information about new files that appeared on the card will come to us through an open socket, it looks like this: <br> <code>&gt;/mnt/DCIM/101CANON/IMG_1754.JPG <br></code> <br>  If you took several photos, in one message these lines are separated by zero byte (0x00) <br><br>  I want to emphasize - in just 7-8 seconds.  Why this is done is not entirely clear, but we cannot influence this.  Also, only information about new images in jpeg format comes, and the map software has the ability to pull out the jpg stitched preview from the RAW file (more on this below), but programmers chose to prevent us from shooting in jpg, forcing to shoot in RAW + jpg, or write RAW on one card, and jpg on another.  Also, I could not copy photos from the card reader, Shoot &amp; View responds only to new pictures taken by the camera. <br><br>  Program the whole thing easy.  I‚Äôll probably begin to show code snippets, and you can find the full code at the end of the article: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listener_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,callback)</span></span></span><span class="hljs-function">:</span></span> sock=socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="hljs-comment"><span class="hljs-comment">#     sock.connect((self.card_ip, 5566)) while self.listen_flag: message=sock.recv(1024) #      (   ) new_files=message.split('\00') for x in new_files: if x: #       self.all_files.append(x[1:]) # x[1:] -   "&gt;",     #       self.download_list.put(self.all_files[-1]) if callback:callback(self.all_files[-1])</span></span></code> </pre><br><br><h4>  Download photos from a memory card </h4><br>  Now we have a list of new files, the very last step remains - uploading photos to your computer.  By itself, the download is implemented through the built-in web server card.  Surprisingly, but the fact is that everything we did before, as well as downloading photos and some actions, such as getting a list of files, getting previews, etc., DO NOT DEMAND AUTHORIZATION at all.  That is, if the card is configured as an access point, and the user has not changed the WiFi password, you can safely connect to it and download everything there.  It will be necessary as a walk in the summer at tourist places and look for a WiFi network among tourists with cameras. <br><br>  If you look into the cgi-bin folder, we will find a lot of interesting things that may be needed in other projects.  It is easy to look into it, just pick it up on a telnet card, according to simple <a href="http://wwwstud.informatik.uni-rostock.de/ad001/inf/transcend-wifi-ftpd.html">instructions</a> .  And inside of us: <br><img src="https://habrastorage.org/getpro/habr/post_images/a5b/463/620/a5b463620a2c7e3ab6961adf8fbabb54.png"><br><br>  For example, the wifi_filelist binary will give us a list of files in a directory (in XML format), just refer to it like this: <a href="http://card_ip/cgi-bin/wifi_filelist%3Ffn%3DDIR">CARD_IP / cgi-bin / wifi_filelist? Fn = DIR</a> , where CARD_IP is the ip address of the memory card we already found, and DIR - directory (for example, / mnt / DCIM).  Binary thumbNail will give us a thumbnail of the photo, just feed him the same way to the file.  And on the server side the resource-intensive photo resizing is not done, but the thumbnail sewn in jpg or raw is pulled out. <br><br>  But we are interested in downloading photos.  Getting the photo you <a href="http://card_ip/cgi-bin/wifi_download%3Ffn%3DIMAGE_PATH">want is done with a</a> simple GET request to the address <a href="http://card_ip/cgi-bin/wifi_download%3Ffn%3DIMAGE_PATH">CARD_IP / cgi-bin / wifi_download? Fn = IMAGE_PATH</a> , where IMAGE_PATH is the path to the photos that comes to us on the socket that we created above.  For loading in python, the urlretrieve function of the urllib library is suitable in this case.  It allows you to immediately save the result of the request to a file, and most importantly - to get the download progress, which is then useful in the GUI. <br>  The download function looks like this: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">download_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,download_callback,download_complete)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.listen_flag: <span class="hljs-comment"><span class="hljs-comment">#       if not self.download_list.empty(): #     fl=self.download_list.get(block=0) #        urllib.urlretrieve('http://%s/cgi-bin/wifi_download?fn=%s'%(self.card_ip,fl),self.home_dir+fl.split('/')[-1],download_callback if download_callback else None) if download_complete:download_complete(self.download_now) time.sleep(0.1)</span></span></code> </pre><br><br>  Now we put everything together, creating a ready-made module, at the same time getting a console client that will work on windows, linux and macos. <br><br><div class="spoiler">  <b class="spoiler_title">sdwificard.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#coding:utf-8 """ Copyright (C) 2010 Igor zalomskij &lt;igor.kaist@gmail.com&gt; This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. """ import os import socket import thread import time import ping import Queue import urllib import sys class SDCard: def __init__(self,home_dir=''): self.home_dir=home_dir #  ip     self.ip=socket.gethostbyname(socket.gethostname()) self.card_ip=None #  ip    self.all_files=[] #    self.download_list=Queue.Queue() #     self.in_queue=[] #     ,   GUI def find_card(self,callback=None): #       thread.start_new_thread(self.find_card_thread,(callback,)) def find_card_thread(self,callback=None): """     """ while not self.card_ip: #  UDP  s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.settimeout(5) s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1) try:s.bind((self.ip, 58255)) #     except socket.error: s.close() time.sleep(1) continue #      55777 s.sendto('', ('&lt;broadcast&gt;', 55777)) try: resp=s.recv(400) s.close() try: #    self.card_ip=resp.split('ip=')[1].split('\n')[0] except IndexError: #     if callback:callback(None) if callback:callback(self.card_ip) except socket.timeout: callback(None) finally: time.sleep(2) def start_listen(self,callback=None,download_callback=None,download_complete=None): """    .    """ self.listen_flag=True #  ,        thread.start_new_thread(self.listener_thread,(callback,)) #      ,    . thread.start_new_thread(self.ping_card,()) #     thread.start_new_thread(self.download_thread,(download_callback,download_complete)) def ping_card(self): #     20 . while self.listen_flag: try: resp=ping.do_one(self.card_ip) except socket.error: #          ,   pass time.sleep(20) def listener_thread(self,callback): #       sock=socket.socket(socket.AF_INET, socket.SOCK_STREAM) #      5566 sock.connect((self.card_ip, 5566)) while self.listen_flag: message=sock.recv(1024) new_files=message.split('\00') #      (   ) for x in new_files: if x: #        ;) self.all_files.append(x[1:]) # x[1:]    "&gt;",     self.download_list.put(self.all_files[-1]) #        self.in_queue.append(self.all_files[-1]) #      ,    GUI if callback:callback(self.all_files[-1]) def download_thread(self,download_callback,download_complete): #    while self.listen_flag: if not self.download_list.empty(): #     fl=self.download_list.get(block=0) self.download_now=fl #     ,   GUI #  urllib.urlretrieve('http://%s/cgi-bin/wifi_download?fn=%s'%(self.card_ip,fl),self.home_dir+fl.split('/')[-1],download_callback if download_callback else None) if download_complete:download_complete(self.download_now) time.sleep(0.1) def find_callback(ip): if not ip:return print 'Find card on ip:',ip #   IP  ,     sd.start_listen(download_complete=download_complete) def download_complete(fname): print 'New image: %s'%(HOME_DIR+fname.split('/')[-1]) if __name__=='__main__': """   ,  .        ,  ip    """ from optparse import OptionParser parser = OptionParser() parser.add_option("-d", "--dir", dest="dir",default=None,help="directory for storing images") parser.add_option("-i", "--ip", dest="ip",default=None,help="ip address of the computer (default %s)"%(socket.gethostbyname(socket.gethostname()))) (options, args) = parser.parse_args() #       . HOME_DIR=os.path.expanduser('~') if not os.path.exists(HOME_DIR+'/'+'ShootAndView'): os.mkdir(HOME_DIR+'/'+'ShootAndView') HOME_DIR=HOME_DIR+'/ShootAndView/' if options.dir:HOME_DIR=options.dir sd=SDCard(home_dir=HOME_DIR) if options.ip:sd.ip=options.ip print 'Finding sd card...' #     sd.find_card(callback=find_callback) while 1: time.sleep(1)</span></span></code> </pre><br><br></div></div><br><br>  I ask you not to scold me for possible deviations from pep-8, now I practice programming quite rarely, and I like to repeat to myself: ‚ÄúI‚Äôm not reading pep-8 in my sawdust head, I didn‚Äôt read pep-8, yes-yes ". <br>  All source code you can get at <a href="https://github.com/kaist/shoot-and-view">github.com/kaist/shoot-and-view</a> <br><br>  I forgot to mention that while working with a memory card, it is desirable to ping it from time to time.  In the script, I did not look for ways to do ping on different platforms, especially since the console ping utility on some platforms requires administrator privileges.  I just used <a href="https://gist.github.com/pklaus/856268">the</a> ping <a href="https://gist.github.com/pklaus/856268">implementation</a> on pure python.  This module must be placed next to the script. <br><br><h4>  GUI </h4><br>  For the GUI, I used the simplest tool in python, this is Tkinter.  It is available ‚Äúout of the box‚Äù in windows and MacOS, and also takes up little space if you build a standalone application.  Perhaps I will not describe the process of writing a GUI, I will confine myself to a small instruction: <br><br><ol><li>  Import Tkinter <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Tkinter <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> *</code> </pre> <br></li><li>  Write GUI <br><img src="https://habrastorage.org/getpro/habr/post_images/0ef/ad7/768/0efad776809cee2a032ed0afaf4f390c.png"><br></li></ol><br><br>  The console application does not require additional libraries, but the GUI version wants different buns, such as reading exif, working with images, etc. If you want to run it from source (sorry, I only prepared this option on Linux), then you will need: <br> <code>sudo apt-get install python-tk python-imagetk python-imaging libimage-exiftool-perl</code> <br>  And also, manually install the <a href="https://github.com/smarnach/pyexiftool">binding to exiftool</a> ( <code>sudo python setup.py install</code> ) <br>  In windows, besides python 2.7 and binding to exiftool, <a href="http://www.pythonware.com/products/pil/">PIL</a> and <a href="http://www.sno.phy.queensu.ca/~phil/exiftool/">exiftool are required</a> . <br>  Just installing exiftool and binding to it is required on MacOS, see links above. <br><br>  The application is built using py2exe on windows and py2app on MacOS, you can also find scripts among the sources. <br><br><h4>  Total </h4><br>  As promised, ready-made builds for Windows and MacOS are available for the laziest.  You can take them on this <a href="http://shootandview.zalomskij.ru/">page</a> . <br>  Some of the possibilities: <br><ul><li>  Shooting history - the ability of the left-right keys to view the previous or next captured photo. </li><li>  Zoom - when you press the "problems" key, the photo is zoomed to 100% </li><li>  Automatic memory card search </li><li>  And of course, everything is free for commercial and non-commercial use.  Sources are available under the GPL v2 license </li></ul><br><br>  And finally, a couple of screenshots: <br><br><img width="800" src="https://habrastorage.org/getpro/habr/post_images/95d/4e5/8ce/95d4e58ce4cb1f782d717d30b5efeb30.jpg"><br><br><img width="800" src="https://habrastorage.org/getpro/habr/post_images/72b/574/bfa/72b574bfa3cf53fcab54a3a360dd5e30.jpg"><br><br><img width="800" src="https://habrastorage.org/getpro/habr/post_images/aba/52d/707/aba52d707c2b869f679552d285eab79a.jpg"><br><br>  PS I was building an application for MacOS for the first time, please test whether it works, especially not on the python developers' machine) <br><br>  <i>This article is distributed under the <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported License (CC BY 3.0)</a></i> </div><p>Source: <a href="https://habr.com/ru/post/216039/">https://habr.com/ru/post/216039/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../216025/index.html">The original concept of the Apollo spacecraft by North American Aviation, Inc.</a></li>
<li><a href="../216029/index.html">Debugging Arduino Code in Crystal</a></li>
<li><a href="../216033/index.html">Google Self-Eating Program</a></li>
<li><a href="../216035/index.html">The eagle flew away. Apollo canceled missions</a></li>
<li><a href="../216037/index.html">Git and Visual Studio: how to cook</a></li>
<li><a href="../216041/index.html">Richard Stallman is 61 years old</a></li>
<li><a href="../216043/index.html">Webinar Recording - Microsoft 70-410 Exam Preparation and Webinar 70-411 Invitation</a></li>
<li><a href="../216047/index.html">Using Redis EXPIRE to Track Rails Online Audiences</a></li>
<li><a href="../216049/index.html">Concurrency: 6 ways to live with shared state</a></li>
<li><a href="../216051/index.html">Sony PlayStation 4: Human Tested</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>