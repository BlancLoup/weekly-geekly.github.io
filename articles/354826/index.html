<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Procedural dungeon generation in roguelike</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Procedurally generated maps are a basic roguelike feature. For a genre that is almost synonymous with ‚Äúrandomness‚Äù (and there are reasons for that), r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Procedural dungeon generation in roguelike</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39d/4a6/b4b/39d4a6b4b4cee4c7a732148d61a66f22.png" alt="image"></div><br>  Procedurally generated maps are a basic roguelike feature.  For a genre that is almost synonymous with ‚Äúrandomness‚Äù (and there are reasons for that), randomized maps have become the easiest way to demonstrate its key element, because they affect many aspects of gameplay, from exploration strategy and tactical positioning to the location of objects and enemies. <br><br>  Note - in the tips for passing strategic games, key points on a common battle map are usually described and what should be done in them - by following the specified sequence of steps, you can win every time.  Of course, players can enjoy trying to solve a puzzle, but no matter how exciting the game is, interest disappears after finding all the solutions. <br><br>  Therefore, randomized cards provide us with infinite replayability, each time setting us different tasks.  In addition, the pleasure is enhanced by the fact that the player's progress depends on his own skill, and not on trial and error.  The scheme of each new card is 100% unknown, which also adds to the intensity of the process of studying it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of course, the advantages of procedural maps are meaningless without a great variety of mechanics and content - monotonous hack-and-slash will not work here.  Therefore, all roguelike who have stood the test of time have deep gameplay. <br><br>  This post is the result of my work on the generation of maps for Cogmind. <br><a name="habracut"></a><br><h1>  Ways </h1><br>  There are many ways to generate maps.  Naturally, no method is a universal solution, so most developers customize their chosen <br>  ways for their games.  Of course, it is possible to develop your own way from scratch, but in order to start exploring this topic, it is better to consider the most popular approaches. <br><br>  I will not go into details of the implementation, because such information is full on the Internet;  instead, I‚Äôll just leave links to the sources for each image where explanations can be found. <br><br><h2>  Bsp-trees </h2><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2580%25D0%25B0%25D0%25B7%25D0%25B1%25D0%25B8%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25B0">BSP-trees</a> can be used to create the simplest and most characteristic of roguelike maps - rectangular rooms connected with each other by corridors. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/606/499/82e/60649982ef51cc1042af769977faba5e.png"></div><br>  <i>BSP-tree, example 1 ( <a href="http://eskerda.com/bsp-dungeon-generation/">source</a> )</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/3c4/46c/0a23c446c43d7176b9123c1e4292d255.png"></div><br>  <i>BSP-tree, example 2 ( <a href="http://gamedevelopment.tutsplus.com/tutorials/how-to-use-bsp-trees-to-generate-game-maps--gamedev-12268">source</a> )</i> <br><br><h2>  Tunneling algorithms </h2><br>  Tunneling algorithms (tunneling algorithms) dig through corridors and rooms in solid ‚Äúground‚Äù, almost in the same way as a real dungeon architect.  Except that when using algorithms, useless or unnecessary paths are often obtained. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88d/3cc/156/88d3cc15673fc80f0c289457ea6fb6a8.png"></div><br>  <i>Example Tunnel Plotter ( <a href="http://dungeonmaker.sourceforge.net/DM2_Manual/manual1.html">source</a> )</i> <br><br>  The highly-randomized tunneling algorithm of the Drunkard's Walk (‚ÄúDrunk Walk‚Äù) is useful in creating cave-like maps with a mix of open and closed spaces. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d04/314/981/d043149819e954828e419a37c0fbb092.png"></div><br>  <i>Drunkard's Walk, Example 1 ( <a href="http://forums.roguetemple.com/index.php%3Ftopic%3D4128.0">source</a> )</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf3/985/002/cf3985002d46f2238f8bf9eaba46b39d.png"></div><br>  <i>Drunkard's Walk, 2 ( <a href="http://www.roguebasin.com/index.php%3Ftitle%3DRandom_Walk_Cave_Generation">source</a> )</i> <br><br><h2>  Cellular Automata </h2><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BB%25D0%25B5%25D1%2582%25D0%25BE%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">Cellular machines are</a> great for digging out natural-looking cave systems.  In contrast to other methods in this, the developer, after generating a map, must independently provide connections, because some algorithms have a high probability of creating divided areas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5a/901/aec/a5a901aec297bf66ceba7d7be0c3db58.png"></div><br>  <i>Cellular automata, example 1 ( <a href="http://gamedevelopment.tutsplus.com/tutorials/generate-random-cave-levels-using-cellular-automata--gamedev-9664">source</a> )</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dec/dd7/f29/decdd7f294f3f52001dd4ca2b3a3734b.png"></div><br>  <i>Cellular automata, example 2 ( <a href="http://www.roguebasin.com/index.php%3Ftitle%3DCellular_Automata_Method_for_Generating_Random_Cave-Like_Levels">source</a> )</i> <br><br>  As can be seen from the above types of algorithms, in the article I want to talk about procedural generation of <em>dungeons</em> .  The action of most roguelike takes place underground, which is logical in terms of design.  The very randomized nature of the bagels means that at some point in time (and quite often) a player can meet an opponent for whom he is completely unprepared and must run.  In the dungeons there is a sufficient amount of negative space that can be used to control the visible and invisible from the point of view areas, and all this is presented in an easily digestible form, i.e.  in the form of rectangular rooms, corridors and walls of caves.  Separating meetings with enemies into rooms allows you to create more intense gameplay and fit more content in a small space.  Yes, when you are trying to escape, a meeting with one enemy may end with a meeting with another, but this is why every experienced roguelike lover will advise you never to run into suspense! <br><br><h1>  Design </h1><br>  In addition to choosing the method of generation (or a combination of several methods), you must set and configure all the parameters to create maps that are suitable for gameplay.  Many small rooms or a few large ones?  A bunch of long corridors or no corridors at all, just rooms connected by doors?  A spacious winding cavern system stimulating the player to explore, or a linear cave decorated like that for the sake of the atmosphere? <br><br>  The map scheme does not simply reflect the theme, it affects the process of passing the game (or its part).  Many roguelike use rather small rooms and narrow corridors due to the high percentage of close battles.  In Cogmind, the battle is most often conducted at a distance, therefore usually in the game wide corridors and large rooms are used. <br><br><h2>  Study and fascination </h2><br>  In addition to creating maps that complement the game mechanics, it is also important to pay attention to possible routes of movement from one enemy to another.  Empty corridors and rooms are actually useful, because the player does not have to fight at every turn.  Real players should be given the opportunity to relax and, more importantly, to give space in which you can figure out if everything went wrong.  In particular, in Cogmind, such additional space is also useful for using stealth - with the correct use of components and tactics, many opponents can be avoided. <br><br>  But when adjusting card parameters, the main factor to which I pay attention is the number and density of loops.  By loops, I mean places in which several paths lead to one point.  On the map without loops or almost without loops, the player will often have to go back, and it's <em>not</em> interesting to go back!  Of course, players can decide to go the route of the previous path, for example, to pick up items or avoid the enemy, but it can not be <em>forced to</em> pass several times a single route.  On long paths ending in dead ends, at least there must be treasures or doors to new areas.  In Cogmind, the maps are quite large by the standards of roguelike, so I had to be especially attentive to senseless ways. <br><br>  Here it is also worth noting that the development and configuration of the map generator is often not performed in the game itself.  You can see the whole map and study it at a high level, but this does not mean that if the card ‚Äúlooks good‚Äù, then it will be interesting to play on it! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/bc9/04b/970bc904b573c540dd605264cd1d6f93.png"></div><br>  <i>Here is an example of a map that looks good like a cave system, but without proper mechanics, it will not be very interesting to play - too many long paths ending in dead ends.</i> <br><br>  Testing connections on the card after the generation stage is an important step for deciding whether to use the card (more on this below).  More complex procedural methods allow you to embed this requirement in the generation process itself: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44a/b80/0a4/44ab800a45031c698bffd6e393e4b2e7.png"></div><br>  <i>A graph-based map generation technique that provides the total number of loops ( <a href="http://www.reddit.com/r/gamedev/comments/1dlwc4/procedural_dungeon_generation_algorithm_explained/">source</a> ).</i> <br><br><h1>  Content </h1><br>  Another challenge is the location on the maps of objects.  Its decision depends very much on the game itself.  The random arrangement of objects can be interesting (yes, that's exactly what I did for 7DRL!), But the most fascinating gameplay can be obtained only by taking into account the terrain and reasonably choosing places.  This stage often depends on the parameters of the dungeon, which will be discussed below in a separate section. <br><br>  It is worth mentioning that in my game Cogmind dungeon areas are used, partially created by hand.  Such procurement areas need to be built into ready-made dungeon generation algorithms.  Before making such blanks, I had the problem of creating and modifying them;  This process is more convenient to perform in <a href="http://www.gridsagegames.com/rexpaint">REXPaint</a> in combination with text files. <br><br>  The fragments of the map fragments have many advantages, in fact, having all the advantages of manually created levels: the control over a separate part of the gameplay is improved, and their uniqueness attracts attention to them and makes them more memorable / meaningful.  In addition, they become points of contact that players can discuss among themselves.  I'm not too zealous in the creation of blanks - another advantage of procedural maps is to <em>save</em> time on creating content.  But you may need more control over the appearance and content of locations that are important from the point of view of the plot. <br><br><h1>  Cogmind </h1><br>  Cogmind maps use a combination of tunneling algorithms and cellular automata, which we will discuss below. <br><br><h2>  Part 2. Map generation: tunneling algorithm </h2><br>  Maps of the main Cogmind dungeon "prokapyvayutsya" tunneling.  Corridors and rooms are dug up in much the same way as a dungeon architect would build housing for his master's servants.  An empty map is generated by one or several tunneling mechanisms that move around the map, revealing all areas that will become free space: corridors, doors, rooms and halls. <br><br>  I like tunneling algorithms, because with the right parameters, they can create fairly realistic environments. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4c/11f/771/b4c11f771f7dbb658d8912c342eb46fb.png"></div><br>  <i>See the underground complex controlled by robots!</i> <br><br><h1>  sources of inspiration </h1><br>  First, I need to pay tribute to the sources of my inspiration.  Previously, tunneling algorithms did not interest me, because when generating large dungeons, they usually created boring repetitive patterns.  But a few years ago I came across <a href="http://dungeonmaker.sourceforge.net/DM2_Manual/index.html">this project</a> , which introduced me to the most important concept - the tunneling mechanisms can <em>change</em> their own parameters in the process of movement (this site has a good overview of this idea).  The result is a more diverse dungeon, especially on larger maps that are used in Cogmind. <br><br>  Specifically, this algorithm has some oddities - why do we need all these useless and redundant corridors?  Why does he never create corridors of even width? * I think that many of his flaws never became obvious, because the creator of the algorithm did not use it in a real game: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88d/3cc/156/88d3cc15673fc80f0c289457ea6fb6a8.png"></div><br>  <i>It looks cool, but not too realistic.</i> <br><br>  * I suspect that this is somehow related to the fact that it is easier to work with symmetric tunneling mechanisms in the code.  Although I wrote my own algorithm for working with an arbitrary width of the corridors, because from the logic point of view, the tunnels should narrow and expand by two pixels, the corridors of even width gradually became corridors of odd width, because they narrowed to a width of one cell, and then they began to expand again ! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61d/0a9/597/61d0a9597a46620c438eff26776db74a.png"></div><br>  <i>A dungeon dug out by a single tunneling mechanism with an even width (starting from the upper center point) eventually begins to create more corridors with an odd width (blue), although originally corridors with an even width (orange) were created.</i> <br><br>  I can not worry about using even-width corridors because they are more likely to create off-center connections that do not look very nice.  I like the corridors 2 cells wide in terms of gameplay, because they are narrow, but still provide enough space for maneuver around other units.  But as a standard for a game like Cogmind, corridors 3 cells wide will most likely be better, because battles in it are usually fought at a distance ‚Äî enough space is needed to select the right line of fire. <br><br>  Anyway, over the years I have created my own algorithm based on the same principle: tunneling mechanisms that create a dungeon can evolve over time in order to vary the schemes. <br><br><h1>  Options </h1><br>  In the behavior of the tunneling mechanism, you can control a variety of parameters: width, direction, speed, probability of rotation, probability of creating rooms, size and shape of created rooms, space left between the mechanism and other objects of the dungeon, the moment of completion of the work ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/932/c6a/a51/932c6aa51633750899101e5618750f59.png"></div><br>  Example: an increased border between corridors and rooms may be desirable if you do not want to make it easier for the player to pave the way to the next room / corridor.  In my case, I made the border small, because what good is in a destructible relief, if it cannot be used in my favor to make situations more dynamic?  (But be careful - a determined enemy can even shoot at you through the wall!) <br><br>  Everyone who is familiar with procedural card generation knows that the same algorithm can, when changing parameters, create very different results.  Later, I will show other functions that, in combination with this algorithm, make it even more dynamic, but in fact we have already considered everything necessary for the basis of the game. <br><br><h1>  The size </h1><br>  Many Cogmind maps will be even more than 7DRL, and they will have more open spaces.  The main dungeon was 100 √ó 100 per card, and the largest cards would be up to 200 √ó 200.  This is <em>four</em> times more: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f7/b3e/045/2f7b3e045a9945e2abae2ffd9e43ff1c.png"></div><br>  <i>The biggest card.</i>  <i>The scheme and style are not fully ready yet, but the algorithm itself is 90% complete - you need to clean the code to reduce jagging.</i> <br><br>  Why do we need big cards?  First, Cogmind always needed more space, because the battle is mainly fought at long distances ‚Äî on average, enemies are 15 or more cells away from the player.  Maps become even more in order to fit the changes in the content of the game. <br><br>  The world will become bigger and more places will appear in it, so we need to distribute the main maps so that transitions between regions occur less frequently.  With some styles of play, battles may become larger;  who knows, maybe you decide to create a small army of robots to start a small war?  The player can now do more in the game, so he needs more space for this. <br><br>  In addition, the game now focuses more on gathering information.  In addition to the sensor parts that were in the 7DRL version of the game, the player will be able to examine the card using the terminals.  Large cards will motivate players to use these sources of information whenever possible.  Having learned more about the map of the map and the movements of the enemies, you can take a hiding route, but the map is not so small that this knowledge leads to success too quickly. <br><br>  Many map areas that are empty on 7DRL will now be occupied by machines, so less map space will be free.  At the current stage of card generation, the algorithm is interested only in the connectedness of the map, its passage and the ratio of open / closed spaces;  the location of the objects will be discussed below. <br><br><h1>  Composition </h1><br>  As mentioned above (and shown in the images), there are quite a lot of wide corridors and open areas on the new maps. <br><br>  In the 7DRL version there were much more hidden corridors and places, so it seemed that it was easier to hide than it actually is - the enemy can find you without any problems or even get around you on a short path, because he knows the dungeon better than you! <br><br>  The openness of the card makes the player think more about attracting attention, because it can lead to a collision with the enemy. <br><br><h1>  Scheme </h1><br>  In the process of generating tunneling mechanisms pave the way for the player to move from the entrance to the exit, which are usually several and they are separated by a guaranteed distance.  The way of movement of tunneling mechanisms and their decision making is the most important aspect that determines the appearance of the map. <br><br>  Whenever possible, most mechanisms try to break through rooms along their ribs.  They are used as places where you can hide / wait or find details.  They may also contain cars that are sometimes used simply for the atmosphere, and sometimes <a href="http://www.gridsagegames.com/blog/2013/10/machines/">not</a> .  Rooms with several doors are usually a kind of intersection, opening access to branches from the main corridor. <br><br>  When cornering or changing widths, tunneling mechanisms sometimes create connections.  They are used not only for aesthetics - in such connections there can be terminals through which the bots-operators can control the activity occurring in the neighborhood. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6bb/ef1/669/6bbef16690f1afed9a85dfd8c93b0bb2.png"></div><br>  <i>These connections, located along the main corridors, most likely contain access to the terminals.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd4/291/ab2/fd4291ab2ab7d87ee29df5f83ce71c45.png"></div><br>  <i>The idea of ‚Äã‚Äãpresence in the connections of the corridors of the terminals was used in the very first layout of the game.</i> <br><br>  Also, tunneling mechanisms contribute to large areas called halls.  If you want to go unnoticed, then before passing through such halls you should think twice, because when you move close to a patrol or scout you will most likely be found. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bec/f08/c48/becf08c484b0a37708e5f8d12c4958bf.png"></div><br>  <i>The halls usually contain large cars that can be divided and create obstacles out of which to hide.</i> <br><br>  We will return to the maps generated by tunneling in the following parts of the post. <br><br><h2>  Part 3. Card generation: cellular automata </h2><br>  Unlike the 7DRL game, which only extended to a ten-level ‚Äúmain dungeon,‚Äù Cogmind will cover a much larger area.  Naturally, the larger the world, the higher should be the variability of areas for study.  The action takes place underground, so many areas will turn out to be caves, and cellular automata are usually the best choice for generating them. <br><br>  But in fact, I will not use the standard cellular automaton solution.  (The process standard is written <a href="http://jeremykun.com/2012/07/29/the-cellular-automaton-method-for-cave-generation/">here</a> , <a href="http://gamedevelopment.tutsplus.com/tutorials/generate-random-cave-levels-using-cellular-automata--gamedev-9664">here</a> and <a href="http://www.roguebasin.com/index.php%3Ftitle%3DCellular_Automata_Method_for_Generating_Random_Cave-Like_Levels">here</a> ; I will not look at it in detail.) Instead, I will use Andy‚Äôs ‚ÄúEvil Scientist‚Äù Stobirsky‚Äôs idea that I love, which he described in <a href="http://www.evilscience.co.uk/%3Fp%3D624">his blog</a> . <br><br><h1>  Evil science </h1><br>  In this method, cellular automata are also used ‚Äî we apply the neighborhood rules to open and close cells in a natural way, but instead of constantly applying the rules for the entire map, we simultaneously select cells <em>randomly</em> .  (We make roguelike and love random, so we use random!) <br><br>  In terms of performance with full optimization, the Andy method is faster than the standard one, while yielding comparable results <em>and</em> at the same time it is much more flexible for my purposes.  I do not have much experience with cellular automata, but having experimented with them, I could hardly adjust them to get a good result.  Andy's method <em>easily</em> creates good results.  Of course, ‚Äúgood‚Äù is a subjective point of view, but what I wanted, I could not achieve with the help of vanilla cellular automata.  I needed more variability, and the flexibility of this method made it very easy to achieve many beautiful cards.  I am sure that variability can be achieved with the help of cellular automata (due to the change of rules in the generation process), but this will not be as easy as I managed: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/455/eac/13c/455eac13c0e75494d146f64e5db38217.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecc/72d/3fb/ecc72d3fb77611406ecb8860ea4ba8e1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bf/537/2bb/2bf5372bbb6d3566b2f6d63f8704ed0b.png"></div><br>  I like how on many maps the random distribution of the application of the rules creates variability even within one map in the form of a mix of sharp and rounded, large and small areas. <br><br>  One of the variables that can be changed using this method is usually not possible when using cellular automata - the number of cells visited at random from which additional variability is created from.  By reducing the number of rules applied, coarser maps are created, but the last smoothing phase is still applicable to them and creates quite interesting results: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3e/a13/72c/c3ea1372c6ee2cd3b03594cfcf66d8ec.png"></div><br><h1>  Connectedness </h1><br>  As in the case of any algorithms for procedural generation of cards based on cellular automata, an important task is to ensure connectivity.  If there is no way to move between several unrelated areas of the map, then these areas do not seem to exist at all.  One solution is to completely remove such remote unrelated areas, but in the case of some styles of caves it is inapplicable, because naturally there are a <em>lot of</em> inconsistencies that arise when using algorithms for creating long maps with narrow corridors (instead of large room spots). <br><br>  Therefore, it will be better to create new connections for connecting these areas.  One option is to ‚Äúgrow‚Äù some areas so that they can connect with others again.  The second is to break through the tunnels between them.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I prefer tunnel connections, because they 1) correspond to the style and theme I need, and 2) create a system of caves from a multitude of small caves, which can be considered as rooms and place objects in them (this advantage will become obvious in the next section on dungeon metrics).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here my solution is slightly different from the solution of Mr. Evil Scientist (mainly because I take into account the specifics of its use in the game, and it creates a more general generator). </font><font style="vertical-align: inherit;">In my decision, most of the U-shaped folds are eliminated, it performs several phases of digging corridors that may not apply to all caves, has a customizable ratio of corridors and branching corridors created as caves. </font><font style="vertical-align: inherit;">Sometimes he decides to dig wider tunnels based on the parameters set, as well as the relative size of the caves to be joined.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6be/c01/a80/6bec01a80f0882110745429841776ad7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tunnels connecting separate caves.</font></font></i> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Managed Generation </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Cogmind cave maps won't be as big as the main dungeon maps I showed in the previous section, but even small square cave maps are not so interesting to explore, at least in the split style I chose. Take for example the map shown above (this is one of the styles I'm going to use for now):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/288/24f/c2d/28824fc2d36d4bdca1d43e09c0b3e7de.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The path of the square cave map.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If we assume that we do not have any significant destination at each impasse, then on the map above we will often need to go back, and even more tunnels that have been dug out will only turn it into a more complex network of connections (which will create more loops). But the map will still not be very interesting to explore because of the fundamental difference between caves and ordinary dungeon maps: the rough edges of the map are full of back streets, which need to be carefully examined so as not to miss an important passage.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In an ordinary dungeon with flat walls and square rooms, we can quickly glance around the entire visible area and quite accurately determine where the passage is and where it is not. </font><font style="vertical-align: inherit;">In the caves you can not be sure that you did not miss something important until you check everything carefully. </font><font style="vertical-align: inherit;">It becomes boring, especially when you do not immediately move in the right direction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The solution lies in "controlled" cellular automata. </font><font style="vertical-align: inherit;">Let the generation be done in the usual way, but we will limit the general shape in which the cave should fit, for example, as shown in the narrow corridor below.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/6ef/2ff/36a6ef2ffae3ecc66097788c058b0425.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interesting caves created by controlled cellular automata. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we will be able to use a sharp and sharp style with long branches, but at the same time everything will move in one general direction.</font></font><br><br><h1>  Mines </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another variation of this algorithm can be used for mines. </font><font style="vertical-align: inherit;">These are usually smaller maps, on which there are rectangular areas excavated for storage and processing machines, as well as the areas of the mines themselves, connected to them by corridors.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ff/6a0/25d/6ff6a025de75ecd6590406a972fc6c42.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the mines more connections and loops.</font></font></i> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Composite Cards </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Who said that the whole card should be controlled by one algorithm? </font><font style="vertical-align: inherit;">In special cases, for special areas, cellular automata can be well combined with tunneling algorithms.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1db/000/453/1db000453b55e4fb233aca7567178874.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secret base?</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 4. Dungeon Metrics </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The algorithm can rarely create an ideal procedurally generated map, and even this happens, some post-processing is required to analyze its scheme. When we look at the map created by the generator, we can quickly understand if this scheme is enough for our needs; we will also most likely notice the bottlenecks in which enemies can gather to stop the player, and areas outside the main path in which treasures can lie. However, for a program, a map is simply coordinates that indicate what this or that area is and do not give any clues about the overall composition or scheme. How can we teach the game to understand and use the map in the same way as we do? We need "dungeon metrics."</font></font><br><br><h1>  Requirements </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first and most important thing is to make sure that </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we need</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the resulting card. </font><font style="vertical-align: inherit;">Without limiting the results, one algorithm can create many variations of maps, and some of them may be unsuitable or non-playable at all. </font><font style="vertical-align: inherit;">In such cases, we should discard such a card and start generating anew.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Composition </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The basic simplest requirement is the resulting volume of playable, ‚Äúopen‚Äù space. </font><font style="vertical-align: inherit;">The lower limit ensures that the card will not be too tight, the upper will make it not too open.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/838/cd7/658/838cd7658873941daa21f41e05ea8fab.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These two caves are generated by the same algorithm, differing only in one parameter: the volume of the required open space (top - 15-30%, bottom - 40-60%). </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another important requirement is the number of individual rooms / caves of different sizes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/028/94a/3a8/02894a3a8e8deda16ee4e1047b25fba6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These two maps are generated using the same algorithm, only the required number of rooms differs (at the top - 20 or more small rooms, at the bottom - 20 medium and 5 large).</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Search for ways </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In some games, pre-computed map data is used to optimize the search for paths, but here I will not consider them (besides, they are not very useful in Cogmind with a completely destructible environment). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finding paths is an important part of map analysis, because we need to make sure that we can reach one or more exits from the entry point to the map. </font><font style="vertical-align: inherit;">This will not be a problem for cellular automata, if we assume that the tunneling phase performs its work, but tunneling algorithms that create maps using several tunneling mechanisms should check that all the mechanisms connect the tunnels created by them.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another possible constraint that the search for paths may impose is the minimum distance between inputs and outputs. </font><font style="vertical-align: inherit;">If they are too close to each other, then most of the map will remain unexplored, which is especially true in Cogmind, because it does not have an XP system - the best reward (development / leveling) the player receives when they reach the exit. </font><font style="vertical-align: inherit;">If the exit is too close to the entrance, then this design can be considered bad, because the player will have little motivation to explore the map.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All the rest </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An alternative to automating the selection process is procedural generation with a manual selection of a set of cards used in the game. This approach works, but the number of map variations is limited by the set chosen by the developer. (However, in some games this method is used.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When choosing cards for use in the game or simply to improve the algorithm, it is useful to examine the map from different angles. For example, the monochrome map view is useful for checking the available space in the game and the general scheme, without being distracted by separate parts of the map.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/045/fc5/b75/045fc5b75274811d76cdf63f78951267.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The usual left view is convenient for accurate recognition and positioning of caves, and the monochrome view more clearly shows the playing and non-playable space. It is closer to what the player himself sees and feels.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Look at the images in the previous sections, which have separate tunnels, caves, rooms, connections, halls, etc. These are not processed images - the debugging functions of the card generator itself have many different modes that help in development.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another piece of advice for effectively solving problems in the development process: always output a random seed number (seed) used to generate each card (I add them to the list). </font><font style="vertical-align: inherit;">Because of this, we can always transfer this number back to the generator in order to regenerate the same map and deal with errors or consider options for improving the algorithm.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Records </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having decided to choose a generated map, we have to do much more. It is time to analyze the content and the scheme in order to record as much useful information as possible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The simplest component that we want to remember is the location of all the rooms / caves. Rooms (and corridors) dug by tunneling mechanisms are easy to record, because we create them ourselves and we can record them in the process. Caves are another story because they are grown randomly. To find them, we simply scan the map with a standard floodfill algorithm.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/599/60e/4ea/59960e4eae3f84dd05ea8717e5c41c75.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finding caves on the map using the fill before connecting them.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is another advantage of the creation of numerous caves not connected to each other by cellular automata and their connection at the post-processing stage: the caves are naturally divided into separate ‚Äúrooms‚Äù by the algorithm itself! This means that in the future we can take advantage of the analysis methods used for ordinary dungeons with rooms and corridors. More on this we will explain later.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When choosing how to use different parts of the map, location and size are not the only important information. </font><font style="vertical-align: inherit;">We can record the location of doors and their direction (which is used to optimize some types of path finding or ambush), connecting rooms and corridors with certain connections, connecting tunnels with caves, as well as caves that are accessible from the current cave. </font><font style="vertical-align: inherit;">My favorite data, which I will discuss later, is relative isolation / connectedness.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The decision on how to use the map as a whole may also be affected by the overall statistics obtained for the finished map. </font><font style="vertical-align: inherit;">This data is such as the percentage of cell types, the maximum and average isolation of areas, the largest cave / hall, etc. </font><font style="vertical-align: inherit;">Of course, they can also be used as additional requirements for screening out unsuitable cards.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Analysis and its application </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How can we use all of these collected data, except to make a decision about its suitability? </font><font style="vertical-align: inherit;">The most obvious application is the placement of items. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Robots and parts in the game for the 7DRL were created without taking into account whether they are in a room or a corridor; </font><font style="vertical-align: inherit;">it was possible to find a bunch of parts lying around somewhere in an arbitrary place. </font><font style="vertical-align: inherit;">It would be more logical to keep them mostly in rooms, both for realism and in terms of gameplay (‚Äúis it worth opening the door to look for details, even if my scanners show that there are robots behind it that may be hostile?‚Äù) .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As mentioned above, there is a high probability of having terminals in the corridor connections, and there must be more cars in large halls. </font><font style="vertical-align: inherit;">Security guards most often patrol intersections. </font><font style="vertical-align: inherit;">Choosing the best places would be difficult without recording the details of the map scheme.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Connectedness </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> My favorite tool for analyzing cavern systems is to determine the relative connectedness of each cave. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e0/371/699/9e0371699d2dbc2a7d6e751ccf20f8d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualization of connectedness of caves. </font><font style="vertical-align: inherit;">The brighter the cave, the better it is connected to the system. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the number of direct connections is not useful in many cases, I define ‚Äúconnectedness‚Äù as the number of directly connected caves </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plus the</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> number of caves with which they are connected. </font><font style="vertical-align: inherit;">In the visualization shown above, the separately located caves have a darker shade, which means a smaller value of connectedness. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Less connected caves in different parts of the map are likely entry / exit positions, others will be good candidates for placing loot, secrets, or surprises unpleasant for curious researchers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the other hand, in caves with high cohesion, the concentration of activity of enemies is most probable.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isolation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All rooms of the maps created by the tunneling algorithm are evaluated by the value of "isolation". </font><font style="vertical-align: inherit;">For isolation, a different calculation criterion is used, because the connectedness of the map is much higher. </font><font style="vertical-align: inherit;">It is based on the distance to the shortest path that a player can go from entry to exit.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/526/db3/62f/526db362f1f35f914d6610ff062dfb58.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualization of isolation of rooms. </font><font style="vertical-align: inherit;">Dark red rooms are further from the shortest routes on the map.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Four entrances / exits (pink dots) are connected by the shortest paths between them (green lines), then from the entrance to each room a search is made for the paths to the nearest point of any of these lines. </font><font style="vertical-align: inherit;">Note that the farther the room is from the path, the darker is its shade of red. </font><font style="vertical-align: inherit;">(In this visualization, all rooms whose relative isolation is below average are not red. The ‚Äúaverage‚Äù is based on the map values.) The more isolated the room, the more likely it will contain something valuable or interesting to the player. </font><font style="vertical-align: inherit;">Of course, the idea of ‚Äã‚Äã‚Äúisolation‚Äù implies that the player knows where to go, although in reality this is not so! </font><font style="vertical-align: inherit;">But this is normal, because the player deserves a small reward for a strong deviation from his path and overcoming a large number of obstacles.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 5. Dungeon Blanks </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procedurally generated maps are great, but even with the variability built into the algorithm, it will not be able to create anything beyond its parameters. This is good because it allows to preserve the integrity of the style, but separate areas become victims of this. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragments of maps created manually make it possible, if necessary, to restore the necessary specificity of the style, be it a combination with the generated content or areas important for the plot, in which a specific atmosphere is required. Billets, integrated into the rest of the card, are very highlighted and remembered by this.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b3/d0c/277/2b3d0c277808f53e81d4ba66fdfa1d64.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just a stupid example, but writing a separate algorithm for procedural skull generation would be too big a brute force.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blanks allow you to deviate from the path, which otherwise would be too repetitive gameplay (even if the repeatability is hidden by several layers of random content). In addition, they provide players with a "common foundation", which allows them to discuss individual parts of the game. The more random and unpredictable the roguelike, the more the discussion is limited to "general survival tips." Immutable areas allow us to open up a completely new category of discussions - ‚Äúwhat can we do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù, instead of ‚Äúwhat can we do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> XYZ‚Äù.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this is not the only strategy - thanks to the unchangeable areas, a completely new category of stories may arise, because readers who have played the game will more clearly understand </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the story is going on, having already seen the same area with their own eyes.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating blanks </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I decided to paint the blanks in </font></font><a href="http://www.gridsagegames.com/rexpaint"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">REXPaint</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , assigning each type of cells different colors of the palette and painting them on the first layer.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/587/579/1fa/5875791fa9459c883161bdf22c6f7d82.png"></div><br>  In the initial tests, the same palette was used as in the algorithm development program. <br><br>  Additional information is stored in other layers of the image, because blanks are more than just their layout. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23e/135/5bf/23e1355bf88bd60e518d20562ed85117.png"></div><br>  <i>I changed the palette to simplify the design process, giving it a black background, similar to the one used in the game.</i> <br><br>  The figure above shows a fully customized blank with test content.  Layer 2 (above Layer 1) contains the connection / integration information with the map (this yellow two, <br>  which I will discuss below).  On layer 3 unique cars / interior elements are drawn (these gray lines and rectangles).  Layer 4 contains links pointing to the location of static objects (green numbers / numbers). <br><br>  All blanks that have certain objects (and there are most of them) must have an accompanying text file that describes the objects placed on layer 4. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/509/db1/652/509db1652348fdc0d6d3ba4826c09ad8.png"></div><br>  Test data / script for the preparation of the skull, which contains a random range of objects.  Ideally, this information would be entered / viewed / modified directly in the workpiece editor, but in the case of Cogmind, workpieces and their objects are quite simple, so I decided to use text files. <br><br>  Objects can be listed in any order, and we can use any letter or number as a reference.  Additional functions, including the possibility of randomized objects, will be implemented if necessary - we have created only what is necessary for the game to work at the most basic level. <br><br>  And this is how the blank is loaded in the game on a real map: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8dd/a63/cb2/8dda63cb21eb4cb13fe3a85a6329444b.png"></div><br>  A skull test appears in the game.  (The map generator added an extra robot and item to it, because this area is not turned off from the limits of the random spawn of objects.) <br><br><h1>  Integration </h1><br>  The main problem with the blanks now is how to connect them with the rest of the map.  If you just allow the generator to do whatever it pleases, then we can turn the workpiece into chaos and destroy all its meaning, so the dark gray cells around the skull prohibit the card generator to block them.  Instead, we control connections from the workpiece. <br><br>  First, based on the instructions from the text file of the card description, the algorithm reads the .xp files (created by REXPaint), parses their contents, and then places the cells on the card (if indicated, in random places) before doing another generation.  The yellow box in the skull example indicates that when the construction of the corridors begins, the tunneling mechanism should start digging a 2 cell wide tunnel to the south (closest border), starting from this point, and then connect to the rest of the map. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/364/4f1/6d7/3644f16d730c46d7f3ee9c2bb0a7c32d.png"></div><br>  The part of the map description file that hosts the stub, where ‚Äútype &amp;‚Äù is the name of the file containing the image.  In addition to map blanks, other generalized [FEATURE] (elements) are also most useful for specifying areas outside the generator. <br><br>  Since the elements are arranged before the start of tunneling and random generation, they also support random placement, so, for example, you will never find the same interesting point in the same area of ‚Äã‚Äãthe map. <br><br><h1>  Application </h1><br>  Cutting skulls and other interesting shapes from the map is not exactly what I mean by her ‚Äúcharacter‚Äù.  The blanks are ideal for creating more functional schemes that meet the specific requirements of the game, like special NPC and areas important for the plot. <br><br>  I do not want the players to ‚Äúlook for‚Äù a certain point on the map so that the necessary meeting takes place.  I just create it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2b/54d/45f/f2b54d45f1bd650bce2941bd7cbe886e.png"></div><br>  <i>You meet a potential ally in the main hall, and if he doesn‚Äôt like what you say, his servants will be attacking you in the side rooms, otherwise he will let you into a secret armory in the far room.</i>  <i>(Or you can use a relief scanner to find out that you can simply shoot / drill a hole in the back room from another part of the map and take whatever you want.)</i> <br><br>  Approximately the same method is used to add manually created content to the caves, although here, instead of the tunneling algorithm, it is more useful to use direct links so that they do not get out of control and flood the caves. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c7/8e8/627/1c78e8627ec71b5f2119d63476c6e295.png"></div><br>  <i>Um, we can go in the front door or not.</i> <br><br><h2>  Part 6. Generation and filling of caves </h2><br>  Up to this point, most of the Cogmind maps were generated in the ‚Äúrooms and corridors‚Äù style.  A wide range of customizable parameters in combination with a variety of thematic content (and blanks!) Gave this style a great potential in creating unique gameplay for different areas of the world. <br><br>  On the other hand, ‚Äúbagels‚Äù, combining several different card generators, can cope much better with posing new challenges and challenges for the player.  Look at the build of <em>some</em> of the types of maps used in Dungeon Crawl: Stone Soup: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d76/359/590/d76359590ceba49fec8f5bd1466f179d.png"></div><br>  <i>Examples of card generation variability in DCSS (see some descriptions <a href="https://www.reddit.com/r/roguelikedev/comments/3n63hw/faq_friday_22_map_generation/cvnd65e">here</a> ).</i> <br><br>  Impressive! <br><br>  Along with pure gameplay variation, I need to consider the entourage, ent and atmosphere of Cogmind, so the design of the cards depends on them, which reduces the possibility of too radical changes.  But besides the fully automatically created parts of the world there is the possibility of adding more natural areas that are in the insides of the planet, namely caves. <br><br>  Of course, the problems of creating caves are different from the tasks of the original maps and the associated algorithms.  Fortunately, in terms of lora and gameplay, caves have a completely different meaning, and they lack the <a href="http://www.gridsagegames.com/blog/2015/04/living-dungeon/">‚Äúliving ecosystem‚Äù</a> used in the main areas of the world, so there is no need to migrate these ready-made systems to fit the new architecture.  (In addition, such a migration would reduce the effect of using a completely different map generator!) Therefore, all the caves are located in <em>branches</em> - this concept is described in the Layout section of <a href="http://www.gridsagegames.com/blog/2015/04/world-robots/">this article</a> .  Such branches have a different composition and purpose;  You can read about them if you are not familiar with them. <br><br>  In this part I will not consider the content in detail (therefore there are almost no spoilers);  instead, we will study design and technical solutions that are taken into account when generating caves. <br><br><h1>  Cave generation </h1><br>  I have already done a brief introduction to the method of generating caves above, in the part devoted to the algorithm of randomized cellular automata.  Here I will not repeat the basic information, although at the time of writing this part, the parameters for adding caves to the world (images created in the demo of the map generator test program) have not yet been configured, so you should look at how the game of the caves actually look like. <br><br>  First, you need to know that after the release last year <em>,</em> one variation in the form of mines was <em>added</em> to the working cavern generator: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e51/8f8/6bd/e518f86bd7931bafcc34342171ddf1e5.png"></div><br>  <i>Fully explored mine.</i> <br><br>  In fact, these are small square areas containing scattered caves interspersed with dug rooms, which are connected by tunnels. <br><br>  Real cave systems are much larger, and since individual caves have more room to expand, they are more likely to generate additional back streets. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a54/9c7/61b/a549c761ba8ce0becacee2f29eccaa85.png"></div><br>  <i>Fully open map of caves with no content.</i>  <i>On the map superimposed images of the main loops and paths.</i> <br><br>  For reference, I have drawn illustrations that demonstrate the relatively <a href="">linear structure of the passage</a> and the <a href="">main loops</a> .  Of course, there are loops that can be used for tactical purposes, but in general they are much smaller than in other areas of the world - for some players this can greatly affect the strategy.  Design in the style of "linearity with loops" should not allow the card to be <em>too</em> linear, while saving the player from the annoying return back.  (And of course, the player can create loops by himself, destroying the necessary walls.) <br><br><h1>  Filling caves </h1><br>  Although the system for creating procedural schemes of caves was ready in 2014, I added the first stage of content generation only last year. <br><br>  It has the form of "meetings", in which each of the caves (similar to rooms on maps of rooms and corridors) has its own content, obtained from a pool of possible meetings, divided into four categories: small things, rewards, risk and rewards, threat.  The meeting system is described in more detail at the end of the post about <a href="http://www.gridsagegames.com/blog/2015/05/map-composition/">card composition</a> . <br><br>  For example, in the case of a mine, the potential distribution of meetings might look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39d/4a6/b4b/39d4a6b4b4cee4c7a732148d61a66f22.png"></div><br>  <i>Mine with distributed meeting types marked with the appropriate color category.</i> <br><br>  This function was used to fill in other branches, including for maps of caves in the form of mines.  But the mines are relatively small and they contain a rather limited set of simple meetings, so they do not need the support of blanks, which allowed me quite simply to create a wider range of unique (but still dynamic) content.  Honestly, I didn‚Äôt have enough time to sell the caves before the release of the game in 2015, which also played a role. <br><br>  In full-sized caves, which are much larger than mines, better meetings are also required.  And there should definitely be <em>more of them</em> .  Stubs can help a lot in these areas because the hard task of content is a slow and error-prone process.  Support for scripting for meetings is significantly improved compared to the description from the previous part, while other branches also added many features for content blanks. <br><br>  The last thing I really needed was the support of the blanks in the caves.  Well, yes, in the caves there is support for blanks, but not blanks for <em>meetings</em> , which are a more important and flexible type. <br><br>  There are two ways to add blanks to Cogmind maps.  The first is to integrate them into the cave generator itself, which is not even part of the game engine (i.e., it can be run without Cogmind itself), and by its very nature its capabilities are limited because it has presets even <em>before</em> it is generated caves.  Therefore, these blanks had to play a major role on the map, for example, to be a huge and important unchangeable area or special inputs / outputs.  If you use this type of workpiece too actively, as a result, the cards will become too repetitive and recognizable, because this system is not very flexible (at least, if you do not put extra effort into working on each new card).  Therefore, it will be more efficient to add most of the cave blanks using the second method, the meeting system. <br><br>  Here a problem arises: how to integrate static blanks into a map of caves that has already been generated? <br><br>  By themselves, the blanks have a predetermined shape, and it is obvious that we cannot change it to adapt to the environment, so the only option for us is to terraform the caves so that they fit the blanks.  This process should not affect the connectedness of the caves, and the result should look good and not turn the map into chaos. <br><br>  I added two ways to integrate billets and caves.  I hope they will be enough. <br><br><h2>  Centered workpieces </h2><br>  The most easily realized preparation of the cave is very intrusive, it is simply inserted into the geometric center of the parent cave.  (It must be recalled that here, under the cave, I mean a separate room-cave, one of the many that make up the cave system.) Here is an example of an outpost-blank, inserted directly into a large enough cave: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/411/a87/098/411a87098d7317c88338a93016c91c7c.png"></div><br>  <i>Geometrical centering of the outpost in the parent cave.</i> <br><br>  Notice that the outpost territory completely rewrites the enclosed and open areas under it, and there is an open buffer zone around it.  The solution is radical, but quite suitable here. <br><br>  I decided to center the workpiece relative to the <em>geometric</em> center of its cave (that is, to the position tending to the largest open areas of this cave) in case one end of the parent cave is a large open area, and the other is a long stretched corridor.  In this case, the geometric center of the cave will be located at some distance from the simple coordinate center.  In such a situation, the coordinate center is likely to violate one of the rules governing the placement of blanks of this type: blanks can be superimposed on any land and the parent cave itself, <em>but not other caves</em> . <br><br>  One of the limitations of the design with centered blanks is that they should be rectangular, but in the future I can get rid of this limitation if it seems annoying to me.  Organic / rounded centered blanks may have a thematic purpose, especially in caves, but technically in the existing system they can be simulated by rounding the corners of the blank. <br><br>  Here I must remind readers that the blanks are not static - many have different schemes and randomized content, so even for one type of meeting there is a lot of variation.  This leads to funny situations for new players (‚Äúoh, I remember this place from the last time, there is a friendly robot inside - GOD WHY HE FIRING IN ME‚Äù), and at the same time creates strategic difficulties for experienced players (‚Äúthere definitely there is useful loot and I can take out the usual guards, but is it worth the small chance that I will be ambushed by more powerful opponents? ‚Äù). <br><br>  As I mentioned several times when I spoke about the structure of the world, the branches should become less predictable parts of the world, compared to the main complex, in which procedurally controlled systems are actively used, but they are fairly constant and predictable for an experienced player.  In this way, I create two different types of main areas between which a player can move.  From the point of view of the design, the blanks are ‚Äúmanual‚Äù content located in the branches, so it is very important to implement them correctly. <br><br><h2>  Embedded blanks </h2><br>  These systems were more difficult. <br><br>  It was necessary to find a way to add areas of blanks that would have almost no effect on the structure in order to create a more standard cave system in which the player finds interesting encounters outside the main route, or at least so that they are not inserted right in the middle of the cave.  This meant that I needed to find a way to pull out areas for billets on the borders of existing caves.  That is, for such excavations it was necessary to have enough space, as well as a way to effectively find such spaces. <br><br>  As seen in the image above, the caves are packed quite tightly.  Therefore, at first I decided that in order to significantly increase the amount of land (an area that can be dug) between the caves, it is necessary to perform the generation of caves in two stages: in the first stage, the process of specifying cavernous spots marking the boundaries during the normal map generation process is used;  in the second stage, the usual process is performed, which will automatically avoid the ‚Äúvoids‚Äù dug in the first stage.  These voids in the future should be available for tearing blanks.  Although it sounds promising, but the more useful this approach (that is, the more voids), the more it affects the caves as a whole: it extends the corridors and increases the spaces between the individual caves, even if there are no blanks between them.  This decision seemed to me too excessive. <br><br>  There is a much simpler alternative that does not reduce the integrity of the ready-made cave schemes: you can simply expand the area to be excavated around the outer borders of the map.  Now we will have a lot of space to dig!  Then comes the next step: where exactly to start digging?  It is very easy to determine by sight - we can immediately see the places that are ideal for digging out small caves, but in the cave code they are simply numbered areas with a list of internal coordinates.  Therefore, at this stage, the question was to select a minimum set of rules that would allow you to search for suitable places and satisfy all conditions and potential schemes when pulling out areas for billets. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f9/af7/965/9f9af7965667986260e310574dea3e43.jpg"></div><br>  <i>It took me two hours to work out a suitable set of rules.</i> <br><br>  The resulting rules turned out to be quite a brute force, but they worked, so I decided to use them. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd8/3bd/cd0/cd83bdcd0129e04bd5e967ef832dc57f.png"></div><br>  <i>Steps for embedding the blank into the cave wall.</i> <br><br><ol><li>  Select a random billet for a given meeting and rotate it to look at a random side of the world. </li><li>  Select a random open cell in the cave, which should be one front corner of the location of the workpiece.  Then, based on the length of the front face of the workpiece, we determine where the opposite angle should be.  If the second corner is outside the cave, then try to pick up other points. </li><li>  Measure the distance along the imaginary sides of the workpiece until it collides with the wall. </li><li>  Each workpiece has a manually set value of ‚Äúmaximum length‚Äù (maxProtrusion).  It is a limitation of the depth at which it can go into the parent cave.  If the distance measured on either side exceeds the maxProtrusion value, then we shift the angles back to the wall until both values ‚Äã‚Äãare within this value.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (If the distance at which the length value can be observed on both sides, then go back to step 2.) </font></font></li><li>     : ¬´ ¬ª     (    )  ¬´ ¬ª     ‚Äî        ,      /     . </li><li>  ,                 (  , ,         ). </li><li>    !          ,      . </li><li>       , , ,        . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If during a certain number of attempts in the current cave no suitable areas were found, then we try to pick up other random meeting preparations, and if they do not fit, then proceed to the next cave. </font><font style="vertical-align: inherit;">(Meetings are selected first, so the task is to find a suitable place for them.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unlike centered blanks, recessed blanks may not be rectangular, because their sides and rear borders are guaranteed to be in the ground, i.e., their appearance will resemble a cave, as shown in the example above. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The above schemes are drawn in </font></font><a href="http://www.gridsagegames.com/rexpaint/" title="REXPaint"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">REXPaint</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Here are screenshots of the real blanks generated in the game:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68e/d67/ef4/68ed67ef4cd199bc4d02ce90e55c1d01.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of embedded workpiece in the game.</font></font></i> </div><p>Source: <a href="https://habr.com/ru/post/354826/">https://habr.com/ru/post/354826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354816/index.html">Blockchain When should it be applied?</a></li>
<li><a href="../354818/index.html">Synchronous system interface interaction with peripheral blocks in the volume of the crystal VLSI or FPGA. STI 1.0</a></li>
<li><a href="../354820/index.html">Program Overview Heisenbug 2018 Piter</a></li>
<li><a href="../354822/index.html">Studies show: people who have ‚Äútoo many interests‚Äù are more likely to succeed</a></li>
<li><a href="../354824/index.html">Payment system architecture. Experience proven banality</a></li>
<li><a href="../354828/index.html">The science of emotion: how smart technologies learn to understand people</a></li>
<li><a href="../354830/index.html">How to detect FinFisher. ESET Manual</a></li>
<li><a href="../354832/index.html">Biomechanics. Start</a></li>
<li><a href="../354834/index.html">DevConf: a little about blockchain</a></li>
<li><a href="../354836/index.html">Secure Development Section on the PHDays 8 Forum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>