<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create 2D portals using shaders</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will talk about how to achieve this effect: 



 Essentially, the shader in question works as a post effect for the camera or the bu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create 2D portals using shaders</h1><div class="post__text post__text-html js-mediator-article">  In this article I will talk about how to achieve this effect: <br><br><img src="https://habrastorage.org/files/562/79b/470/56279b4705ab4342806d29058661202c.gif"><br><br>  Essentially, the shader in question works as a post effect for the camera or the built-in blur and vignette filters in Unity.  It takes an input image (more precisely, RenderTexture) and displays it with superimposed effects. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It all started with the game for the thirtieth gamedzhe Ludum Dare on the subject of Connected Worlds.  The idea was as follows: two characters are on different sides of the screen, divided into two identical parts, and send signals to each other.  Many players could not understand this mechanics, so I slightly changed it. <br><br>  I made it so that, entering the portal, the signal would materialize in a parallel world - on another part of the screen.  At the same time, I came up with several options for the portal, for example, when the characters got into it, they changed places.  But all this was incomprehensible and even more confusing. <br><br>  I puzzled over this problem for a long time, but it would be too difficult to tune each moving object.  Then I decided that for this purpose you need to write a shader. <br>  In fact, the shader, which will be discussed, works as a post-effect for the camera or the built-in Blur and Vignette filters in Unity.  It takes an input image (more precisely, RenderTexture) and displays it with superimposed effects. <br><br>  <b>1. Configure the shader and post effects</b> <br><br>  Let's start with the least important post effect to test this configuration.  First, create a camera, leaving most of the default settings: <br><br><img src="https://habrastorage.org/files/083/d6a/5b0/083d6a5b0bb64eb5994fc9856ce4e70d.png"><br><br>  The most important thing is to change the Clear Flags parameter (so that the screen is not updated when rendering), switch the camera to orthographic mode and set the depth value higher than for other cameras (to put the camera in the last drawing queue).  Then we write a new script (PortalEffect.cs) with the following source code: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityStandardAssets.ImageEffects; [ExecuteInEditMode] [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Camera))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PortalEffect</span></span> : <span class="hljs-title"><span class="hljs-title">PostEffectsBase</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Material portalMaterial; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Shader PortalShader = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckResources</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CheckSupport(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); portalMaterial = CheckShaderAndCreateMaterial(PortalShader, portalMaterial); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isSupported) ReportAutoDisable(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isSupported; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDisable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (portalMaterial) DestroyImmediate(portalMaterial); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRenderImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RenderTexture source, RenderTexture destination</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CheckResources() || portalMaterial == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Graphics.Blit(source, destination); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Graphics.Blit(source, destination, portalMaterial); } }</code> </pre> <br><br>  Now create a new shader PortalShader.shader with the following code: <br><br><pre> <code class="cs hljs">Shader <span class="hljs-string"><span class="hljs-string">"VividHelix/PortalShader"</span></span> { Properties { _MainTex (<span class="hljs-string"><span class="hljs-string">"Base (RGB)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} } SubShader { Pass { CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> vertex vert #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> fragment frag #include "UnityCG.cginc" uniform sampler2D _MainTex; struct vertOut { float4 pos:SV_POSITION; }; vertOut vert(appdata_base v) { vertOut o; o.pos = mul (UNITY_MATRIX_MVP, v.vertex); return o; } fixed4 frag(vertOut i) : SV_Target { return fixed4(.5,.5,.5,.1); } ENDCG } } }</span></span></code> </pre><br><br>  Having created a shader, do not forget to set it in the PortalShader property of the PortalEffect script. <br>  This is how the screen looks like before the effect is activated: <br><br><img src="https://habrastorage.org/files/613/1b2/fe4/6131b2fe406d4575afa10bf6928da88e.png"><br><br>  And so - after activation: <br><br><img src="https://habrastorage.org/files/7d1/016/df3/7d1016df3f1947a1b56edc791489eb99.png"><br><br>  Gray appears because of the fixed4 line (.5, .5, .5, .1) and consists of 50% red, green, blue, and alpha with a value of 1. <br><br>  <b>2. Add UV Coordinates</b> <br><br>  Now add the UV coordinates to the shader.  Their values ‚Äã‚Äãcan range from 0 to 1. It is easiest to imagine that this effect is superimposed on a quad, made to fit the screen, with a texture drawn by the previous cameras. <br><br>  The following code snippet: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> vertOut { float4 pos:SV_POSITION; float4 uv:TEXCOORD0; }; <span class="hljs-function"><span class="hljs-function">vertOut </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">appdata_base v</span></span></span><span class="hljs-function">)</span></span> { vertOut o; o.pos = mul (UNITY_MATRIX_MVP, v.vertex); o.uv = v.texcoord; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; } <span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">vertOut i</span></span></span><span class="hljs-function">) : SV_Target</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2D(_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>-i.uv); }</code> </pre><br><br>  Thus, we double-flip the image vertically and horizontally, which corresponds to a 180-degree rotation: <br><br><img src="https://habrastorage.org/files/47c/e8f/d37/47ce8fd3790d419fa879fc02d2142afe.png"><br><br>  Pay attention to the piece 1-i.uv.  If we reduce it to i.uv, we get the so-called identical effect, which leaves the original image unchanged.  The return tex2D string (_MainTex, float2 (1-i.uv.x, i.uv.y)) will simply flip the image horizontally (from left to right): <br><br><img src="https://habrastorage.org/files/ef7/10f/0a4/ef710f0a45bc46e7b0784eb55ef68fd4.png"><br><br>  <b>3. Transfer the screen area</b> <br><br>  We can slightly modify the shader by changing the values ‚Äã‚Äãof the UV-coordinates to impose a specific area on another part of the screen. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">vertOut i</span></span></span><span class="hljs-function">) : SV_Target</span></span> { float2 newUV = float2(i.uv.x, i.uv.y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i.uv.x &lt; <span class="hljs-number"><span class="hljs-number">.25</span></span>){ newUV.x = newUV.x + <span class="hljs-number"><span class="hljs-number">.5</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2D(_MainTex, newUV); }</code> </pre><br><br><img src="https://habrastorage.org/files/b6c/494/895/b6c494895f3940a9823e54d25e2610e5.png"><br><br>  In the screenshot you can see how the area on the left of the screen is copied from the right.  The size of this section can be adjusted by changing the value of .25.  We also add .5 so that the image moves to the opposite part of the screen - from 0‚Äì0.25 to 0.5‚Äì0.75 on the x axis. <br><br>  <b>4. Transferring the circular area</b> <br><br>  To transfer the circular area in the same way, add the distance function: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(i.uv.xy, float2(<span class="hljs-number"><span class="hljs-number">.25</span></span>,<span class="hljs-number"><span class="hljs-number">.75</span></span>)) &lt; <span class="hljs-number"><span class="hljs-number">.1</span></span>){ newUV.x = newUV.x + <span class="hljs-number"><span class="hljs-number">.5</span></span>; }</code> </pre><br><br><img src="https://habrastorage.org/files/80a/7ca/541/80a7ca541c6a404689b977a0edc6e9bb.png"><br><br>  As you can see, instead of a circle, we have an oval.  The problem is that the width and height of the screen are not identical (we calculate the distance in the range of 0‚Äì1).  The height of the oval is 20% of the height of the screen, and the width is 20% of its width (based on a radius of .1 or 10%). <br><br>  <b>5. Transfer the circular area again</b> <br><br>  To solve this problem, we need to rewrite the distance function according to the width and height of the screen. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">vertOut i</span></span></span><span class="hljs-function">) : SV_Target</span></span> { float2 scrPos = float2(i.uv.x * _ScreenParams.x, i.uv.y * _ScreenParams.y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(scrPos, float2(<span class="hljs-number"><span class="hljs-number">.25</span></span> * _ScreenParams.x,<span class="hljs-number"><span class="hljs-number">.75</span></span> * _ScreenParams.y)) &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>){ scrPos.x = scrPos.x + _ScreenParams.x/<span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2D(_MainTex, float2(scrPos.x/_ScreenParams.x, scrPos.y/_ScreenParams.y)); }</code> </pre><br><br><img src="https://habrastorage.org/files/1a8/565/773/1a856577325e4de29fb954c149efdf7c.png"><br><br>  <b>6. Swap areas</b> <br><br>  To complete a double replacement, we need to move a similar area to the right half of the screen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(scrPos, float2(<span class="hljs-number"><span class="hljs-number">.25</span></span> * _ScreenParams.x,<span class="hljs-number"><span class="hljs-number">.75</span></span> * _ScreenParams.y)) &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>){ scrPos.x = scrPos.x + _ScreenParams.x/<span class="hljs-number"><span class="hljs-number">2</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(scrPos, float2(<span class="hljs-number"><span class="hljs-number">.75</span></span> * _ScreenParams.x,<span class="hljs-number"><span class="hljs-number">.75</span></span> * _ScreenParams.y)) &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>){ scrPos.x = scrPos.x - _ScreenParams.x/<span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre><br><br>  This is what should happen: <br><br><img src="https://habrastorage.org/files/4ac/bc8/7c7/4acbc87c781745f7a3979110f3bd418b.png"><br><br>  <b>7. Add blurry edges</b> <br><br>  Now the transition looks quite sharp, so we need to blur the edges a little.  For this we use linear interpolation. <br><br>  At first, everything is simple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lerpFactor=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(scrPos, float2(<span class="hljs-number"><span class="hljs-number">.25</span></span> * _ScreenParams.x,<span class="hljs-number"><span class="hljs-number">.75</span></span> * _ScreenParams.y)) &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>){ scrPos.x = scrPos.x + _ScreenParams.x/<span class="hljs-number"><span class="hljs-number">2</span></span>; lerpFactor = <span class="hljs-number"><span class="hljs-number">.8</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(scrPos, float2(<span class="hljs-number"><span class="hljs-number">.75</span></span> * _ScreenParams.x,<span class="hljs-number"><span class="hljs-number">.75</span></span> * _ScreenParams.y)) &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>){ scrPos.x = scrPos.x - _ScreenParams.x/<span class="hljs-number"><span class="hljs-number">2</span></span>; lerpFactor = <span class="hljs-number"><span class="hljs-number">.8</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lerp(tex2D(_MainTex, i.uv), tex2D(_MainTex, float2(scrPos.x/_ScreenParams.x, scrPos.y/_ScreenParams.y)), lerpFactor);</code> </pre><br><br>  This code will blur the edges of the moved areas using 80% (this corresponds to 0.8) of the moved pixels: <br><br><img src="https://habrastorage.org/files/9b1/009/95c/9b100995c43e4940beb3edd559f440fb.png"><br><br>  Now let's make the transition even smoother using the distance function.  Instead of doing a double substitution, we will focus on one area for now. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lerpFactor=<span class="hljs-number"><span class="hljs-number">0</span></span>; float2 leftPos = float2(<span class="hljs-number"><span class="hljs-number">.25</span></span> * _ScreenParams.x,<span class="hljs-number"><span class="hljs-number">.75</span></span> * _ScreenParams.y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(scrPos, leftPos) &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>){ lerpFactor = (<span class="hljs-number"><span class="hljs-number">50</span></span>-distance(scrPos, leftPos))/<span class="hljs-number"><span class="hljs-number">50</span></span>; scrPos.x = scrPos.x + _ScreenParams.x/<span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lerp(tex2D(_MainTex, i.uv), tex2D(_MainTex, float2(scrPos.x/_ScreenParams.x, scrPos.y/_ScreenParams.y)), lerpFactor);</code> </pre><br><br>  As you can see, it works, but requires additional configuration: <br><br><img src="https://habrastorage.org/files/5dd/dd0/0e5/5dddd00e527149408882335793d59d3a.png"><br><br>  <b>8. Blur faces with vignetting effect.</b> <br><br>  To solve this problem, I propose to go a workaround.  Suppose we want to blur only the outer boundary with a thickness of 15. This means that for distances of 35 or less, the linear interpolation coefficient should be equal to one, and for a distance of 50 it should be zero.  In the if branch, the distance is in the range from 0 to 50. So, to derive the final formula, we make up a small table: <br><br><img src="https://habrastorage.org/files/27f/e35/3ee/27fe353ee1154677bdec34732ed625b2.png"><br><br>  The Saturate function is equal to Clamp (0,1), converting negative values ‚Äã‚Äãto 0. <br>  Using the final formula lerpFactor = 1 - saturate ((distance (scrPos, leftPos) -35) / 15), we get the following result: <br><br><img src="https://habrastorage.org/files/ef7/10f/0a4/ef710f0a45bc46e7b0784eb55ef68fd4.png"><br><br>  Here is the full code for blurring the faces of two areas: <br><br><pre> <code class="cs hljs">float2 leftPos = float2(<span class="hljs-number"><span class="hljs-number">.25</span></span> * _ScreenParams.x,<span class="hljs-number"><span class="hljs-number">.75</span></span> * _ScreenParams.y); float2 rightPos = float2(<span class="hljs-number"><span class="hljs-number">.75</span></span> * _ScreenParams.x,<span class="hljs-number"><span class="hljs-number">.75</span></span> * _ScreenParams.y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(scrPos, leftPos) &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>){ lerpFactor = <span class="hljs-number"><span class="hljs-number">1</span></span>-saturate((distance(scrPos, leftPos)<span class="hljs-number"><span class="hljs-number">-35</span></span>)/<span class="hljs-number"><span class="hljs-number">15</span></span>); scrPos.x = scrPos.x + _ScreenParams.x/<span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(scrPos, rightPos) &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>){ lerpFactor = <span class="hljs-number"><span class="hljs-number">1</span></span>-saturate((distance(scrPos, rightPos)<span class="hljs-number"><span class="hljs-number">-35</span></span>)/<span class="hljs-number"><span class="hljs-number">15</span></span>); scrPos.x = scrPos.x - _ScreenParams.x/<span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre><br><br><img src="https://habrastorage.org/files/4ac/bc8/7c7/4acbc87c781745f7a3979110f3bd418b.png"><br><br>  <b>9. Configure Shader Parameters</b> <br><br>  Our shader is almost ready, but with hardcoded values ‚Äã‚Äãit is of little use.  We can extract them into the shader parameters and modify them with code. <br>  After extraction, the final shader code looks like this: <br><br><pre> <code class="cs hljs">Shader <span class="hljs-string"><span class="hljs-string">"VividHelix/PortalShader"</span></span> { Properties { _MainTex (<span class="hljs-string"><span class="hljs-string">"Base (RGB)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Radius (<span class="hljs-string"><span class="hljs-string">"Radius"</span></span>, Range (<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">200</span></span>)) = <span class="hljs-number"><span class="hljs-number">50</span></span> _FallOffRadius (<span class="hljs-string"><span class="hljs-string">"FallOffRadius"</span></span>, Range (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>)) = <span class="hljs-number"><span class="hljs-number">20</span></span> _RelativePortals (<span class="hljs-string"><span class="hljs-string">"RelativePortals"</span></span>, Vector) = (<span class="hljs-number"><span class="hljs-number">.25</span></span>,<span class="hljs-number"><span class="hljs-number">.25</span></span>,<span class="hljs-number"><span class="hljs-number">.75</span></span>,<span class="hljs-number"><span class="hljs-number">.75</span></span>) } SubShader { Pass { CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> vertex vert #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> fragment frag #include "UnityCG.cginc" uniform sampler2D _MainTex; uniform half _Radius; uniform half _FallOffRadius; uniform half4 _RelativePortals; struct vertOut { float4 pos:SV_POSITION; float4 uv:TEXCOORD0; }; vertOut vert(appdata_base v) { vertOut o; o.pos = mul (UNITY_MATRIX_MVP, v.vertex); o.uv = v.texcoord; return o; } fixed4 frag(vertOut i) : SV_Target { float2 scrPos = float2(i.uv.x * _ScreenParams.x, i.uv.y * _ScreenParams.y); float lerpFactor=0; float2 leftPos = float2(_RelativePortals.x * _ScreenParams.x,_RelativePortals.y * _ScreenParams.y); float2 rightPos = float2(_RelativePortals.z * _ScreenParams.x,_RelativePortals.w * _ScreenParams.y); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (distance(scrPos, leftPos) &lt; _Radius){ lerpFactor = 1-saturate((distance(scrPos, leftPos) - (_Radius-_FallOffRadius)) / _FallOffRadius); scrPos.x = scrPos.x + rightPos.x - leftPos.x; scrPos.y = scrPos.y + rightPos.y - leftPos.y; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (distance(scrPos, rightPos) &lt; _Radius){ lerpFactor = 1-saturate((distance(scrPos, rightPos)- (_Radius-_FallOffRadius)) / _FallOffRadius); scrPos.x = scrPos.x + leftPos.x - rightPos.x; scrPos.y = scrPos.y + leftPos.y - rightPos.y; } return lerp(tex2D(_MainTex, i.uv), tex2D(_MainTex, float2(scrPos.x/_ScreenParams.x, scrPos.y/_ScreenParams.y)), lerpFactor); } ENDCG } } }</span></span></code> </pre><br><br>  Standard (asymmetric) values ‚Äã‚Äãgive us this result: <br><br><img src="https://habrastorage.org/files/120/049/1f8/1200491f8c0d4afea789a59333b136ea.png"><br><br>  In our case, the shader parameters can be set in PortalEffect.cs: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRenderImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RenderTexture source, RenderTexture destination</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CheckResources() || portalMaterial == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Graphics.Blit(source, destination); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } portalMaterial.SetFloat(<span class="hljs-string"><span class="hljs-string">"_Radius"</span></span>, Radius); portalMaterial.SetFloat(<span class="hljs-string"><span class="hljs-string">"_FallOffRadius"</span></span>, FallOffRadius); portalMaterial.SetVector(<span class="hljs-string"><span class="hljs-string">"_RelativePortals"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector4(<span class="hljs-number"><span class="hljs-number">.2</span></span>f, <span class="hljs-number"><span class="hljs-number">.6</span></span>f, <span class="hljs-number"><span class="hljs-number">.7</span></span>f, <span class="hljs-number"><span class="hljs-number">.6</span></span>f)); Graphics.Blit(source, destination, portalMaterial); }</code> </pre><br><br>  <b>10. Finishing Touches</b> <br><br>  Even with the vignetting effect, the transition does not look as we would like.  This can be corrected by adding a border.  In an older version of the code for this purpose, I used a particle system: <br><br><img src="https://habrastorage.org/files/3f9/850/258/3f98502588a74ddd9cde93f2ee6476e2.gif"><br><img src="https://habrastorage.org/files/6f7/e4b/055/6f7e4b055cf04bdd9a924a8f99b58c64.gif"><br><img src="https://habrastorage.org/files/9b9/518/5d9/9b95185d953e4d51b37bc31111c89b55.gif"><br><br>  Drastically changing the style of the game, I used the Walls on fire shader to render regular round sprites around portals.  Given that the rendering process takes place before the portals are swapped, this effect looks pretty cool: <br><br><img src="https://habrastorage.org/files/687/a32/f95/687a32f9599f4553b8bdf945607890c8.gif"><br><img src="https://habrastorage.org/files/7c8/bdb/8c0/7c8bdb8c015f4071b79a553265cedbce.gif"><br><img src="https://habrastorage.org/files/a37/1d3/b61/a371d3b61105489fbff293e96d030729.gif"><br><br>  <b>11. End result</b> <br><br>  Here are some more gifs demonstrating the final result in action: <br><br><img src="https://habrastorage.org/files/7b0/c63/c62/7b0c63c622f94ea3a7ccb219ac2eb4be.gif"><br><img src="https://habrastorage.org/files/562/79b/470/56279b4705ab4342806d29058661202c.gif"></div><p>Source: <a href="https://habr.com/ru/post/274509/">https://habr.com/ru/post/274509/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274495/index.html">Flash Player (ActiveX) update for January 1, 2016</a></li>
<li><a href="../274497/index.html">Centrifugal compressor installations. Surge protection</a></li>
<li><a href="../274499/index.html">Definition of gender by name - when accuracy is really important</a></li>
<li><a href="../274501/index.html">IBM opens blockchain lab</a></li>
<li><a href="../274503/index.html">Attackers have targeted the BlackEnergy Trojan at Ukrainian energy companies</a></li>
<li><a href="../274511/index.html">Benchmark 32 and 64-bit versions of browsers: faster, stronger, higher?</a></li>
<li><a href="../274513/index.html">Meet-up "Productive work of the front-end developer in the conditions of legacy-code support": transition to Dart</a></li>
<li><a href="../274515/index.html">Meet-up ‚ÄúProductive work of a front-end developer under conditions of legacy-code support‚Äù: talking about useful tools</a></li>
<li><a href="../274519/index.html">Programming microcomputer LEGO NXT Mindstorms 2.0. Introduction</a></li>
<li><a href="../274523/index.html">Angular 2 vs. React: And there will be blood</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>