<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How lazy calculations work</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Little Lambda decided that cleaning the room can be postponed until later. 

 Lazy computing is a commonly used technique in computer execution of Has...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How lazy calculations work</h1><div class="post__text post__text-html js-mediator-article">  <i>Little Lambda decided that cleaning the room can be postponed until later.</i> <br><br>  Lazy computing is a commonly used technique in computer execution of Haskell programs.  They make our code simpler and more modular, but they can also cause confusion, especially when it comes to memory usage, becoming a common trap for newbies.  For example, a harmless looking expression <pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldl</span></span> (+) <span class="hljs-number"><span class="hljs-number">0</span></span> [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.10</span></span>^<span class="hljs-number"><span class="hljs-number">8</span></span>]</code> </pre>  will require for its calculation gigabytes of memory. <br><br>  In this tutorial, I want to explain how lazy calculations work and what they mean for the execution time and the amount of memory expended by Haskell programs.  I will begin the story with the fundamentals of graph reduction, and then I will proceed to discussing the strict left convolution - the simplest example for understanding and eliminating memory leaks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The topic of lazy computing has been addressed in many textbooks (for example, in Simon Thompson <a href="http://www.haskellcraft.com/">‚Äôs</a> book <a href="http://www.haskellcraft.com/">"Haskell - The Craft of Functional Programming"</a> ), but information about them seems to be still problematic to find on the net.  I hope my guide will help solve this problem. <br><br>  Lazy computing is a tradeoff.  On the one hand, they help us make the code more modular.  On the other hand, it is sometimes impossible to fully understand how the calculation takes place in a particular program - there are always some slight differences between reality and what you think about it.  At the end of the article I will give recommendations on how to deal with situations of this kind.  So let's get started! <br><br><a name="habracut"></a><br><h3>  Basics: graph reduction </h3><br><h4>  Expressions, graphs and redexes </h4><br>  Running Haskell programs means evaluating expressions.  The basic idea behind this is called <i>applying a function</i> .  Let function be given <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">square</span></span> x = x*x</code> </pre><br>  We can calculate the expression <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">square</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>),</code> </pre><br>  replacing <code>square</code> on the left side of the definition with its right side until we get the value of the variable <code>x</code> for the current argument. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">square</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>) =&gt; (<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>)*(<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br>  Two functions are used here: <code>+</code> and <code>*</code> <br><pre> <code class="haskell hljs">(<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>)*(<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>*(<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>*<span class="hljs-number"><span class="hljs-number">3</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre><br>  Please note that in this case we have to calculate <code>(1+2)</code> twice.  However, it is clear that in fact the answers are the same, since both expressions are associated with the same argument <code>x</code> . <br><br>  To avoid unnecessary duplication, we use a method called ‚Äú <b>graph reduction</b> ‚Äù.  Generally speaking, any expression can be represented as a graph.  For our example, it looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/38f/aad/4a7/38faad4a7fece9ee174cb06a30722591.png" alt="image"><br>  Each block corresponds to the use of the corresponding function, whose name is written on a white field, and gray fields indicate arguments.  This graphic notation is similar to how the compiler actually represents an expression with pointers to memory cells. <br><br>  Each function defined by the programmer corresponds to a <b>reduction rule</b> .  For example, the rule for <code>square</code> looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/3e1/fe5/8f8/3e1fe58f8907d6685cfd03ddde1717a1.png" alt="image"><br>  Circled <code>x</code> replaces the subgraph.  Note that both arguments to the multiplication function point to the same subgraph.  Such a way of its general use is the key to the absence of duplication. <br><br>  Any subgraph that matches the rule is called a reducible expression or <b>redex</b> for short.  Wherever we meet redex, it can be shortened and updated the selected rectangle corresponding to the rule.  In our example, there are two Redexes: you can reduce either the <code>square</code> function or addition <code>(+)</code> . <br><img src="https://habrastorage.org/getpro/habr/post_images/ed8/e82/778/ed8e82778a7279bbadf1eaa7b1a4f5aa.png" alt="image"><br>  If we start with redex <code>square</code> , and then continue the calculation with the redex addition, we get the chain <br><img src="https://habrastorage.org/getpro/habr/post_images/295/429/ede/295429ede71982a0ce68544095ffed35.png" alt="image"><br>  At each step, the redex, highlighted in color, is updated.  On the penultimate graph, a new redex appears, which is related to the multiplication rule.  By completing this reduction, we get the final result <code>9</code> . <br><br><h4>  Normal form and weak header normal form </h4><br>  If the expression (graph) does not contain redexes, i.e.  nothing can be cut in it, then the deed is done.  When this happens, we say that the expression is in <b>normal form</b> .  This is the final result of the calculation.  In the previous example, the normal form was the single number represented by the graph. <br><img src="https://hackhands.com/wp-content/uploads/2014/11/blocks-9.png" alt="image"><br>  But constructors like <code>Just</code> , <code>Nothing</code> or list constructors <code>:</code> and <code>[]</code> also reduced to normal form.  At the same time, they look like functions, but since they are represented by the <code>data</code> declaration and do not have the right part, there is no reduction rule for them.  For example, the graph <br><img src="https://habrastorage.org/getpro/habr/post_images/bd7/1ca/4f6/bd71ca4f639ea360db4b9966446e5459.png" alt="image"><br>  The normal form of the list is <code>1:2:3:[]</code> . <br><br>  Generally speaking, there are two more requirements for the graph so that it can be called to be in normal form.  First, it must be <i>finite</i> , and second, <i>it must not have cycles</i> .  The opposite of these conditions is sometimes found during recursion.  For example, an expression defined as <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ones</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> : ones</code> </pre><br>  correlated with cyclic graph <br><img src="https://habrastorage.org/getpro/habr/post_images/76b/740/316/76b740316cb9f87f024dbe341cd65acc.png" alt="image"><br>  It has no redexes, but is not in normal form: the tail of the list recursively points to the list itself, resulting in an infinite loop. <br><br>  In Haskell, we usually do not display the normal form completely.  Moreover, most often we stop when the graph reaches a <b>weak head normal form</b> (WHNF).  A graph is said to be in WHNF if its topmost node is a <i>constructor</i> .  For example, the expression <code>(7+12):[]</code> or <br><img src="https://habrastorage.org/getpro/habr/post_images/1ec/bb9/b87/1ecbb9b873d806a42ef7e5e42aa49a16.png" alt="image"><br>  is located in WHNF because its top node is the list constructor <code>(:)</code> .  And this is not a normal form, since the first argument contains redex. <br><br>  On the other hand, any graph that is <i>not</i> in the WHNF is called an uncalculated <b>expression</b> or <b>converter</b> .  An expression that begins with a constructor is in the WHNF, but its arguments may easily not be computed. <br><br>  A very interesting example of a graph in WHNF is the graph of the <code>ones</code> function mentioned above.  In the end, its uppermost element is the constructor.  In Haskell, we can create and manipulate endless lists!  They are great for making code more modular. <br><br><h4>  The order of calculations, lazy calculations </h4><br>  Often an expression contains several redexes.  How important is the sequence in which we will shorten them? <br><br>  One of the reduction orders, called <b>energetic calculation</b> , calculates the function's arguments to their normal form before reducing it.  This strategy is used in most programming languages. <br><br>  However, Haskell compilers typically use a different order of computation, called <b>lazy</b> , when the topmost application of a function is reduced primarily.  In this case, it may be necessary to calculate some arguments, but only in the required quantity.  Consider a function defined by several equations using pattern matching.  For each of them, the arguments will be calculated from left to right until their top node contains a constructor corresponding to the pattern.  If the comparison is made with a regular variable, then the arguments are not evaluated.  If the sample is a constructor, then this means a calculation before the WHNF. <br><br>  Hopefully, an example will make this concept clearer.  Let given function <code>(&amp;&amp;)</code> , which implements the logical I. Its definition is as follows: <br><pre> <code class="haskell hljs">(&amp;&amp;) :: <span class="hljs-type"><span class="hljs-type">Bool</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-type"><span class="hljs-type">True</span></span> &amp;&amp; x = x <span class="hljs-type"><span class="hljs-type">False</span></span> &amp;&amp; x = <span class="hljs-type"><span class="hljs-type">False</span></span></code> </pre><br>  It is represented by two reduction rules depending on the value of the first argument: <code>True</code> or <code>False</code> . <br><img src="https://habrastorage.org/getpro/habr/post_images/dc4/eed/151/dc4eed15184fe1bc3325378d5c7a1706.png" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/19b/5ca/06e/19b5ca06e0818a8f5a123d73c635e021.png" alt="image"><br>  Now consider the expression <br><pre> <code class="haskell hljs">('<span class="hljs-type"><span class="hljs-type">H'</span></span> == 'i') &amp;&amp; ('a' == 'm')</code> </pre><br>  represented as <br><img src="https://habrastorage.org/getpro/habr/post_images/f05/ae8/eaa/f05ae8eaa038137fac6fed8dd75f6ee7.png" alt="image"><br><br>  Both arguments in it are redexes.  The first equation of the function <code>(&amp;&amp;)</code> checks whether the first argument matches the constructor <code>True</code> .  Thus, a lazy evaluation begins with the reduction of the first argument: <br><img src="https://habrastorage.org/getpro/habr/post_images/049/edf/1a6/049edf1a6408d59e2693dd797e298d9a.png" alt="image"><br><br>  The second argument is not evaluated, since the topmost application of the function is already redex.  Lazy evaluation always starts reduction from the topmost node, which we will do using the rule for the <code>(&amp;&amp;)</code> function.  Will get <br><img src="https://habrastorage.org/getpro/habr/post_images/088/205/5eb/0882055eb8ba37e624819c82ce82f550.png" alt="image"><br>  This expression is in normal form - therefore, everything is ready! <br><br>  Note that if you reduce the application <code>(&amp;&amp;)</code> as quickly as possible, you will never need to look for the value of the second argument, which will reduce the overall time cost.  Some imperative languages ‚Äã‚Äãuse a similar trick, called " <a href="http://en.wikipedia.org/wiki/Short-circuit_evaluation">short</a> - <a href="http://en.wikipedia.org/wiki/Short-circuit_evaluation">circuited computation</a> ."  However, usually this functionality is ‚Äústitched‚Äù into the language and works only for logical operations.  In Haskell, this method can be applied to all functions - it is just a sequence of lazy calculations. <br><br>  In the general case, the normal form obtained with the help of lazy calculations never differs from the result of executing the same expression by their energetic counterpart.  So in this sense, it does not matter in what order the reduction occurs.  However, lazy calculations are performed in fewer steps and can deal with cyclical (infinite) graphs, which is not available for energetic calculations. <br><br><h4>  Text view </h4><br>  I hope the visual representation of expressions in the form of graphs helped you to get a general idea of ‚Äã‚Äãlazy calculations, since it clearly emphasizes the concept of redex and the necessary reduction order.  However, for specific calculations, drawing pictures is somewhat burdensome.  To track the reduction process, we usually work with a <b>textual representation</b> using Haskell syntax. <br><br>  Graphs make it easier to visualize common subgraphs.  In the text view, we need to denote common expressions by giving them names using the <code>let</code> keyword.  For example, our very first example of reducing the <code>square (1+2)</code> expression would look like this: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">square</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = (<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x*x =&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x*x =&gt; <span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre><br>  The <code>let ‚Ä¶ in</code> syntax allows you to make the general expression <code>x = (1+2)</code> .  Notice that the lazy evaluation first reduces the <code>square</code> function, and only then calculates the argument <code>x</code> . <br><br>  Our second example - logical AND - turns into <br><pre> <code class="haskell hljs">('<span class="hljs-type"><span class="hljs-type">H'</span></span> == 'i') &amp;&amp; ('a' == 'm') =&gt; <span class="hljs-type"><span class="hljs-type">False</span></span> &amp;&amp; ('a' == 'm') =&gt; <span class="hljs-type"><span class="hljs-type">False</span></span></code> </pre><br>  In this case, there is no need to share any subexpression, so the <code>let</code> keyword is not in the code. <br><br>  From now on, we will use only the textual representation. <br><br><h3>  Time &amp; Memory </h3><br>  Let us now consider how the use of lazy calculations affects the running time and the memory required by Haskell programs.  If until now you dealt only with energetic calculations, then get ready for surprises (especially when it comes to memory). <br><br><h4>  Time </h4><br>  How many steps does the expression evaluation take?  For energetic calculations, the answer is simple: for each application of a function, we add the time required to calculate its arguments with the time required to perform the function body itself.  But what about lazy computing?  Fortunately, the situation is favorable.  We have the following upper limit: <br><br>  <b>Theorem</b> : <i>Lazy calculations never take more computational steps than vigorous calculations.</i> <br><br>  This means that during the analysis of the execution time of the algorithm, we can always pretend that the arguments are calculated "energetically".  For example, you can transliterate the sorting code in Haskell and be sure that the result will have the same (and sometimes the best) algorithmic complexity as its energetic twin. <br><br>  However, the implementation of lazy computing requires certain administrative costs.  For applications with high performance, like image processing or digital simulations, it is beneficial to ‚Äúnot be lazy‚Äù and stay closer to the hardware.  Otherwise, the mantra "simple and modular code" leads us to lazy calculations.  For example, optimizing the compiler called " <a href="http://stackoverflow.com/questions/578063/what-is-haskells-stream-fusion">thread merging</a> " aims to improve the performance of array operations, as with a modular, list-like interface.  This idea is embodied in the <a href="http://hackage.haskell.org/package/vector">vector</a> library. <br><br><h4>  Memory </h4><br>  Unfortunately, the situation with the use of memory is not as simple as over time.  The essence of the problem lies in the fact that the amount of memory required by an uncalculated expression may differ significantly from the volume occupied by its normal form.  The expression uses the more space the more nodes the graph contains.  For example, <br><pre> <code class="haskell hljs">((((<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">3</span></span>) + <span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre><br>  will take up more storage than its normal form <code>10</code> .  An expression like <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">enumFromTo</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre><br>  whose more familiar syntax looks like <code>[1..1000]</code> .  This application of the function consists of only three nodes, which takes up considerably less memory than the <code>1:2:3:‚Ä¶:1000:[]</code> list, containing at least one thousand elements. <br><br>  When a variant with an uncalculated expression goes out of control, <b>a memory leak</b> occurs.  The solution here will be to control the entire calculation process to ensure its completion as quickly as possible.  Haskell has a combinator for this purpose. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">seq</span></span> :: a -&gt; b -&gt; b</code> </pre><br>  As suggested by a type declaration, essentially it simply returns its second argument and behaves more like a function <code>const</code> .  However, the <code>seq xy</code> expression will first calculate <code>x</code> before the WHNF, after which we will continue to work with <code>y</code> .  Conversely, in <code>const xy</code> second argument <code>y</code> not affected at all, and <code>x</code> calculated without delay. <br><br>  Consider a typical example showing how to use <code>seq</code> , and which every Haskell programmer should know: a <b>strict left convolution</b> .  Let the task be given to sum all the numbers from <code>1</code> to <code>100</code> .  We will do this using the accumulating parameter, i.e.  as in the left convolution <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldl</span></span> (+) <span class="hljs-number"><span class="hljs-number">0</span></span> [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>]</code> </pre><br>  For reference: the <a href="http://www.letu.edu/people/jaytevis/Programming-Languages/Haskell/tourofprelude.html">foldl</a> function <a href="http://www.letu.edu/people/jaytevis/Programming-Languages/Haskell/tourofprelude.html">is</a> defined in the <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch9.html">Haskell Prelude</a> as <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldl</span></span> :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a foldl fa [] = a foldl fa (x:xs) = foldl f (fax) xs</code> </pre><br>  The calculation process is as follows: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldl</span></span> (+) <span class="hljs-number"><span class="hljs-number">0</span></span> [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>] =&gt; foldl (+) <span class="hljs-number"><span class="hljs-number">0</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>:[<span class="hljs-number"><span class="hljs-number">2.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>]) =&gt; foldl (+) (<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) [<span class="hljs-number"><span class="hljs-number">2.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>] =&gt; foldl (+) (<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-number"><span class="hljs-number">2</span></span>:[<span class="hljs-number"><span class="hljs-number">3.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>]) =&gt; foldl (+) ((<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">2</span></span>) [<span class="hljs-number"><span class="hljs-number">3.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>] =&gt; foldl (+) ((<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-number"><span class="hljs-number">3</span></span>:[<span class="hljs-number"><span class="hljs-number">4.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>]) =&gt; foldl (+) (((<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">3</span></span>) [<span class="hljs-number"><span class="hljs-number">4.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>] =&gt; ‚Ä¶</code> </pre><br>  As you can see, the accumulating parameter grows from branch to branch ‚Äî a memory leak occurs.  To avoid it, you need a guarantee that the battery is always in the WHNF.  The next version of <code>foldl</code> does this trick: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldl'</span></span> :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a foldl' fa [] = a foldl' fa (x:xs) = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a' = fax <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> seq a' (foldl' fa' xs)</code> </pre><br>  It can be found in the <a href="http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html">Data.List</a> module.  Now the calculation process looks like this: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldl'</span></span> (+) <span class="hljs-number"><span class="hljs-number">0</span></span> [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>] =&gt; foldl' (+) <span class="hljs-number"><span class="hljs-number">0</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>:[<span class="hljs-number"><span class="hljs-number">2.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>]) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a' = <span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> seq a' (foldl' (+) a' [<span class="hljs-number"><span class="hljs-number">2.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>]) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a' = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> seq a' (foldl' (+) a' [<span class="hljs-number"><span class="hljs-number">2.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>]) =&gt; foldl' (+) <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">2.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>] =&gt; foldl' (+) <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>:[<span class="hljs-number"><span class="hljs-number">3.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>]) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a' = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> seq a' (foldl' (+) a' [<span class="hljs-number"><span class="hljs-number">3.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>]) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a' = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> seq a' (foldl' (+) a' [<span class="hljs-number"><span class="hljs-number">3.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>]) =&gt; foldl' (+) <span class="hljs-number"><span class="hljs-number">3</span></span> [<span class="hljs-number"><span class="hljs-number">3.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>] =&gt; ‚Ä¶</code> </pre><br>  During the evaluation, the expression has a constant size.  Using <code>seq</code> ensures that the WHNF accumulative parameter is removed before the next list item is considered. <br><br>  As a rule, the <code>foldl</code> function <code>foldl</code> prone to memory leaks, so it‚Äôs better to use <code>foldl'</code> or <code>foldr</code> instead. <br><br>  By the way, please note that in a language with energetic calculations for the problem of summing digits from <code>1</code> to <code>100</code> you can never write code like the one above.  In fact, in this case, the list <code>[1..100]</code> will first be calculated to the normal form, which takes as much memory space as the ineffective version of the <code>foldl</code> .  If you want to solve the problem effectively, then you need to write a recursive cycle.  But in Haskell, lazy calculations allow you to do this by using one general-purpose combinator for the list <code>[1..100]</code> , which is calculated ‚Äúon demand‚Äù.  This is another example of how code can be made more modular. <br><br>  Another important lesson that can be learned from the task at hand is the following: in fact, the calculation that I showed is not exactly the case.  If we define an enumeration list <code>[n..m]</code> as <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">enumFromTo</span></span> nm = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; m <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> n : enumFromTo (n+<span class="hljs-number"><span class="hljs-number">1</span></span>) m <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> []</code> </pre><br>  then the reduction in WHNF will actually look like this: <br><pre> <code class="haskell hljs">[<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>] =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> : [(<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>).<span class="hljs-number"><span class="hljs-number">.100</span></span>]</code> </pre><br>  those.  the new first argument is not <code>2</code> , but the expression <code>(1+1)</code> .  Not that there was a big difference, but keep in mind: you have to be very careful when tracing lazy calculations accurately - they never do exactly as you imagine.  The actual <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch9.html">code for enumFromTo is</a> slightly different from the one shown above.  In particular, note that <code>[1..]</code> is constructed as a list of numbers that are not in the WHNF. <br><br>  In principle, I talked about this for so long in order to draw a simple conclusion: with lazy calculations, it is not possible to trace the trace in detail, except for very simple examples.  Thus, analyzing the memory usage of Haskell programs is not an easy task.  My advice: do something only in cases where there is a clear memory leak.  For this, I would recommend using <a href="http://stackoverflow.com/a/3276557/403805">profiling tools</a> to figure out what is happening.  After the problem has been formulated, tools like <a href="http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html">space</a> and <code>seq</code> <a href="http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html">invariants</a> can guarantee the calculation of the corresponding expressions in WHNF, regardless of the fine details of performing lazy calculations. <br><br>  That's all I wanted to tell you about lazy computing and memory usage.  There is one more important example of a leak that I did not mention, but which is no less important: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> small' = fst (small, large) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ‚Ä¶ small' ‚Ä¶</code> </pre><br>  The expression <code>small'</code> retains a reference to the <code>large</code> expression even when it is dropped by the <code>fst</code> function.  Perhaps you should somehow calculate the <code>small'</code> expression in the WHNF so that you can easily use the memory occupied by <code>large</code> . </div><p>Source: <a href="https://habr.com/ru/post/247213/">https://habr.com/ru/post/247213/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247201/index.html">Reflection.Emit: array initialization</a></li>
<li><a href="../247205/index.html">Sound Mixing in Cubian</a></li>
<li><a href="../247207/index.html">Disadvantages when working with translations in Qt and ways to deal with them</a></li>
<li><a href="../247209/index.html">New parameter to describe distribution & x.do = in magnet link for FlylinkDC ++. Factors of the choice by the user of a file-sharing network</a></li>
<li><a href="../247211/index.html">Express Specialist</a></li>
<li><a href="../247219/index.html">Pillow 2.7 - Significant improvement in quality and performance</a></li>
<li><a href="../247221/index.html">PROSPECTOR inside</a></li>
<li><a href="../247223/index.html">Apple - environmental responsibility</a></li>
<li><a href="../247225/index.html">Physical and functional objects (continued)</a></li>
<li><a href="../247227/index.html">10 new year questions for the startup creator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>