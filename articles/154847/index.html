<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write our debugger for Windows [part 1]</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 

 All of us, from time to time, use debugger for debugging programs. The debugger can be used with C ++, C #, Java and hundreds of other...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write our debugger for Windows [part 1]</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br><img src="https://habrastorage.org/storage2/6f8/95d/1d0/6f895d1d0cf1840b69be45f5cebea825.jpg"><br>  All of us, from time to time, use debugger for debugging programs.  The debugger can be used with C ++, C #, Java and hundreds of other languages.  It can be either external (WinDbg) or embedded in the development environment (Visual Studio).  But have you ever wondered how the debugger works? <br>  And you are lucky.  In this series of articles we will understand from and to how debugging from the inside works.  This article only covers writing a debugger under Windows.  Without compilers, linkers and other complex systems.  Thus, we can debug executable files only, as we write an external debugger.  This article will require the reader to understand the basics of multithreading. <br><a name="habracut"></a><br>  How to debug a program: <br><ol><li>  Start the process with the flag DEBUG_ONLY_THIS_PROCESS or DEBUG_PROCESS; </li><li>  start a debug cycle that will catch messages and events; </li></ol><br>  Before we begin, remember: <br><ul><li>  A debagger is a process / program that will debug another process; </li><li>  debugged program (OP) is a process / program that is being debugged; </li><li>  it is the debugger that joins the OP.  Also otlachik can connect to different processes (in different threads); </li><li>  you can debug only those processes that were launched from under the debugger.  Thus, CreateProcess and the debugger loop must be in the same thread; </li><li>  when the debugger process ends, it also terminates the OP; </li><li>  When the debugger is busy processing events, it freezes all the threads of the OD for a while.  More on this later; </li></ul><br><h5>  Running a process with a debug flag </h5><br>  We start the process using the CreateProcess function and in the sixth parameter (dwCreationFlags) we specify the flag DEBUG_ONLY_THIS_PROCESS.  This flag tells Windows to prepare the process to be started for debugging (debugging events, process start / end, exceptions, etc.).  A more detailed explanation later.  Please note that we will use DEBUG_ONLY_THIS_PROCESS.  This means that we want to debug only the process that we run, and not also generated by them. <br><pre><code class="cpp hljs">STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory( &amp;si, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(si) ); si.cb = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(si); ZeroMemory( &amp;pi, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pi) ); CreateProcess ( ProcessNameToDebug, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, FALSE, DEBUG_ONLY_THIS_PROCESS, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;si, &amp;pi );</code> </pre> <br>  After that, you should see the new process in the task manager, but in fact, it has not yet started.  The newly created process is still frozen.  No, they did not guess, we should not call ResumeThread, but write a debug loop. <br><h4>  Debug cycle </h4><br>  The debug loop is the heart of the debugger, and it is built around the WaitForDebugEvent function.  It receives two parameters: a pointer to the DEBUG_EVENT structure and a timeout (DWORD).  As a timeout, we specify INFINITE.  This function is contained in kernel32.dll, so we do not need to link any additional libraries. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForDebugEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DEBUG_EVENT* lpDebugEvent, DWORD dwMilliseconds)</span></span></span></span>;</code> </pre><br>  The DEBUG_EVENT structure includes a lot of debugging information: event code, process ID, flow ID, and application event information.  As soon as the WaitForDebugEvent is completed and control returns, we will receive a debugger message, and then call ContinueDebugEvent to continue execution of the code.  Below you can see the minimum debug cycle. <br><pre> <code class="cpp hljs">DEBUG_EVENT debug_event = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!WaitForDebugEvent(&amp;debug_event, INFINITE)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; ProcessDebugEvent(&amp;debug_event); <span class="hljs-comment"><span class="hljs-comment">// User-defined function, not API ContinueDebugEvent(debug_event.dwProcessId, debug_event.dwThreadId, DBG_CONTINUE); }</span></span></code> </pre><br>  Calling ContinueDebugEvent, we ask the OS to continue executing the OP.  dwProcessId and dwThreadId point us to a process and thread.  We got these values ‚Äã‚Äãfrom WaitForDebugEvent.  The last parameter indicates whether to continue or not.  This parameter will have a value only when an exception has been received for debugging.  This we will consider later.  In the meantime, just use DBG_CONTINUE (another possible value is DBG_EXCEPTION_NOT_HANDLED). <br><h4>  Receiving debugging events </h4><br>  There are nine major debugging events, and 20 sub-events in the exception category.  Consider this, starting with the simplest.  Below is the DEBUG_EVENT structure: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DEBUG_EVENT</span></span></span><span class="hljs-class"> {</span></span> DWORD dwDebugEventCode; DWORD dwProcessId; DWORD dwThreadId; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { EXCEPTION_DEBUG_INFO Exception; CREATE_THREAD_DEBUG_INFO CreateThread; CREATE_PROCESS_DEBUG_INFO CreateProcessInfo; EXIT_THREAD_DEBUG_INFO ExitThread; EXIT_PROCESS_DEBUG_INFO ExitProcess; LOAD_DLL_DEBUG_INFO LoadDll; UNLOAD_DLL_DEBUG_INFO UnloadDll; OUTPUT_DEBUG_STRING_INFO DebugString; RIP_INFO RipInfo; } u; };</code> </pre><br>  When the WaitForDebugEvent is successfully completed, it fills this structure.  dwDebugEventCode indicates which debugging event has come to us.  Depending on this code, one of the members of the union'a u contains information about the event.  For example, if dwDebugEventCode == OUTPUT_DEBUG_STRING_EVENT, then only OUTPUT_DEBUG_STRING_INFO will correctly fill. <br><h4>  Processing OUTPUT_DEBUG_STRING_EVENT </h4><br>  To output text to output, developers usually use the OutputDebugString function.  Depending on the language / framework you are using, you should be familiar with the TRACE / ATLTRACE macros.  .NET developers may be familiar with System.Diagnostics.Debug.Print / System.Diagnostics.Trace.WriteLine.  But all of these methods call OutputDebugString if the _DEBUG macro is declared, and the debugger receives the message. <br>  When a debug message is received, we process the DebugString.  The structure of OUTPUT_DEBUG_STRING_INFO is presented below: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OUTPUT_DEBUG_STRING_INFO</span></span></span><span class="hljs-class"> {</span></span> LPSTR lpDebugStringData; <span class="hljs-comment"><span class="hljs-comment">// char* WORD fUnicode; WORD nDebugStringLength; };</span></span></code> </pre><br>  The nDebugStringLength field contains the length of the string, including the terminating null.  The fUnicode field is zero if the string is ANSI, and non-zero if unicode.  In this case, we need to read nDebugStringLength x2 bytes.  Attention!  lpDebugStringData contains a pointer to a message string, but the pointer refers to data <b>on the memory of the program being debugged</b> , not on the debugger. <br>  To read data from the memory of another process, we need to call ReadProcessMemory and we must have permission to do so.  Since we created the process for debugging, there are no problems with resolution. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OUTPUT_DEBUG_STRING_EVENT: { CStringW strEventMessage; <span class="hljs-comment"><span class="hljs-comment">// Force Unicode OUTPUT_DEBUG_STRING_INFO &amp; DebugString = debug_event.u.DebugString; WCHAR *msg=new WCHAR[DebugString.nDebugStringLength]; // Don't care if string is ANSI, and we allocate double... ReadProcessMemory(pi.hProcess, // HANDLE to Debuggee DebugString.lpDebugStringData, // Target process' valid pointer msg, // Copy to this address space DebugString.nDebugStringLength, NULL); if ( DebugString.fUnicode ) strEventMessage = msg; else strEventMessage = (char*)msg; // char* to CStringW (Unicode) conversion. delete []msg; // Utilize strEventMessage }</span></span></code> </pre><br><h6>  What if the OP completes while reading the memory? </h6><br>  Well, this will not happen.  Let me remind you that the debugger freezes all OD threads while debugging a message.  Thus, the process itself will not be able to complete, No task manager (standard or not) will also be able to complete the process.  If you try, in the next message, our debugger will receive the EXIT_PROCESS_DEBUG_EVENT event. <br><h4>  Processing CREATE_PROCESS_DEBUG_EVENT </h4><br>  The event appears when the OP starts up.  This should be the first message the debugger receives.  For this message, the corresponding DEBUG_EVENT field will be CreateProcessInfo.  Below you can see the very structure of CREATE_PROCESS_DEBUG_INFO: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CREATE_PROCESS_DEBUG_INFO</span></span></span><span class="hljs-class"> {</span></span> HANDLE hFile; <span class="hljs-comment"><span class="hljs-comment">// The handle to the physical file (.EXE) HANDLE hProcess; // Handle to the process HANDLE hThread; // Handle to the main/initial thread of process LPVOID lpBaseOfImage; // base address of the executable image DWORD dwDebugInfoFileOffset; DWORD nDebugInfoSize; LPVOID lpThreadLocalBase; LPTHREAD_START_ROUTINE lpStartAddress; LPVOID lpImageName; // Pointer to first byte of image name (in Debuggee) WORD fUnicode; // If image name is Unicode. };</span></span></code> </pre><br>  Please note that hProcess and hThread may differ from those we get in PROCESS_INFORMATION.  The process ID and thread must be the same.  Every handle you get from Windows is different.  There are various reasons for this. <br>  hFile, as well as lpImageName, can be used to get the name of the OP file.  True, we already know the name of this file, because we launched it.  But the location of the EXE or DLL is important for us to know, because when we receive a message LOAD_DLL_DEBUG_EVENT, it is good to know the name of the library. <br>  As you can read in MSDN, lpImageName never contains the full file name and it will be stored in the memory of the OP.  Moreover, there are no guarantees that the full file name will also be in the memory of the OP.  And the file name may be incomplete.  Therefore, we will get the file name from hFile. <br><h4>  How to get file name from hFile </h4><br>  Unfortunately, we will need to use the method described in <a href="http://msdn.microsoft.com/en-us/library/aa366789(VS.85).aspx">MSDN</a> , which contains about 10 function calls.  Below is a shortened version: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CREATE_PROCESS_DEBUG_EVENT: { CString strEventMessage = GetFileNameFromHandle(debug_event.u.CreateProcessInfo.hFile); <span class="hljs-comment"><span class="hljs-comment">// Use strEventMessage, and other members // of CreateProcessInfo to intimate the user of this event. }</span></span></code> </pre><br>  You may have noticed that I did not consider several fields of this structure.  In the following parts we will look at it all thoroughly. <br><h4>  Processing LOAD_DLL_DEBUG_EVENT </h4><br>  This event is similar to CREATE_PROCESS_DEBUG_EVENT, and as you may have guessed, this event is triggered when the OS loads the DLL.  This event is fired whenever a DLL is loaded, either explicitly or implicitly.  Debug information contains only the time when the DLL was loaded, and its virtual address.  To handle the event, we use the union'a LoadDll field.  It has type LOAD_DLL_DEBUG_INFO <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LOAD_DLL_DEBUG_INFO</span></span></span><span class="hljs-class"> {</span></span> HANDLE hFile; <span class="hljs-comment"><span class="hljs-comment">// Handle to the DLL physical file. LPVOID lpBaseOfDll; // The DLL Actual load address in process. DWORD dwDebugInfoFileOffset; DWORD nDebugInfoSize; LPVOID lpImageName; // These two member are same as CREATE_PROCESS_DEBUG_INFO WORD fUnicode; };</span></span></code> </pre><br>  To get the file name, we will use the GetFileNameFromHandle function, the same as we used in CREATE_PROCESS_DEBUG_EVENT.  I'll show this code when I talk about UNLOAD_DLL_DEBUG_EVENT.  The UNLOAD_DLL_DEBUG_EVENT event does not contain complete information about the name of the DLL library. <br><h4>  Processing CREATE_THREAD_DEBUG_EVENT </h4><br>  This event is generated when the OP creates a new thread.  Much like CREATE_PROCESS_DEBUG_EVENT, this event is created before a new thread is started.  To get information about this event, we use the CreateThread field.  The CREATE_THREAD_DEBUG_INFO structure is described below: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CREATE_THREAD_DEBUG_INFO</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Handle to the newly created thread in debuggee HANDLE hThread; LPVOID lpThreadLocalBase; // pointer to the starting address of the thread LPTHREAD_START_ROUTINE lpStartAddress; };</span></span></code> </pre><br>  The thread ID is available in DEBUG_EVENT :: dwThreadId, so it's easy for us to display all the information about the thread: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CREATE_THREAD_DEBUG_EVENT: { CString strEventMessage; strEventMessage.Format(<span class="hljs-string"><span class="hljs-string">L"Thread 0x%x (Id: %d) created at: 0x%x"</span></span>, debug_event.u.CreateThread.hThread, debug_event.dwThreadId, debug_event.u.CreateThread.lpStartAddress); <span class="hljs-comment"><span class="hljs-comment">// Thread 0xc (Id: 7920) created at: 0x77b15e58 }</span></span></code> </pre><br>  lpStartAddress - the address of the beginning of the thread function relative to the OP, not the debugger  We simply display it for completeness.  Please note that this event is not generated when the main OP thread starts working, only when creating a new main thread. <br><h4>  Processing EXIT_THREAD_DEBUG_EVENT </h4><br>  This event is generated as soon as the child thread terminates and returns the return code to the system.  The dwThreadId field in DEBUG_EVENT contains the ID of the terminating thread.  To get the thread handle and other information from CREATE_THREAD_DEBUG_EVENT, we need to store this information in an array.  To get information about this event, we use the ExitThread field, which is of type EXIT_THREAD_DEBUG_INFO: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EXIT_THREAD_DEBUG_INFO</span></span></span><span class="hljs-class"> {</span></span> DWORD dwExitCode; <span class="hljs-comment"><span class="hljs-comment">// The thread exit code of DEBUG_EVENT::dwThreadId };</span></span></code> </pre><br>  Below is the event handler code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EXIT_THREAD_DEBUG_EVENT: { CString strEventMessage; strEventMessage.Format( _T(<span class="hljs-string"><span class="hljs-string">"The thread %d exited with code: %d"</span></span>), debug_event.dwThreadId, debug_event.u.ExitThread.dwExitCode); <span class="hljs-comment"><span class="hljs-comment">// The thread 2760 exited with code: 0 }</span></span></code> </pre><br><h4>  Processing UNLOAD_DLL_DEBUG_EVENT </h4><br>  Of course, the event contains information and unloading DLL from the memory of the OP.  But not everything is so simple!  It is generated only if you call FreeLibrary, and not when the system itself unloads the library.  For information, use UnloadDll (UNLOAD_DLL_DEBUG_INFO): <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UNLOAD_DLL_DEBUG_INFO</span></span></span><span class="hljs-class"> {</span></span> LPVOID lpBaseOfDll; };</code> </pre><br>  As you can see, only the base address of the library is available to us.  That is why I did not immediately tell you about the code for LOAD_DLL_DEBUG_EVENT.  While loading the DLL, we also get lpBaseOfDll.  You can use the Map to store the name of the library, in addition to its address. <br>  It is important to note that not all library load events will receive their unload event.  However, we must store all library names, since LOAD_DLL_DEBUG_EVENT does not give us information about how the library was loaded. <br>  Below is the code to handle both events: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> &lt; LPVOID, CString &gt; DllNameMap; ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LOAD_DLL_DEBUG_EVENT: { strEventMessage = GetFileNameFromHandle(debug_event.u.LoadDll.hFile); <span class="hljs-comment"><span class="hljs-comment">// Storing the DLL name into map. Map's key is the Base-address DllNameMap.insert( std::make_pair( debug_event.u.LoadDll.lpBaseOfDll, strEventMessage) ); strEventMessage.AppendFormat(L" - Loaded at %x", debug_event.u.LoadDll.lpBaseOfDll); } break; ... case UNLOAD_DLL_DEBUG_EVENT: { strEventMessage.Format(L"DLL '%s' unloaded.", DllNameMap[debug_event.u.UnloadDll.lpBaseOfDll] ); // Get DLL name from map. } break;</span></span></code> </pre><br><h4>  Processing EXIT_PROCESS_DEBUG_EVENT </h4><br>  This is one of the simplest events, and as you can guess, it is called when the OP process is completed.  This event shows us how the process ended: normally or urgently (for example, through the task manager), or the program being debugged dropped.  Information we get from EXIT_PROCESS_DEBUG_INFO ExitProcess; <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EXIT_PROCESS_DEBUG_INFO</span></span></span><span class="hljs-class"> {</span></span> DWORD dwExitCode; };</code> </pre><br>  As soon as we receive this event, we need to interrupt the debugging cycle and complete the debug flow.  To do this, we can start a flag that will signal the completion of debugging. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bContinueDebugging=<span class="hljs-literal"><span class="hljs-literal">true</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EXIT_PROCESS_DEBUG_EVENT: { strEventMessage.Format(<span class="hljs-string"><span class="hljs-string">L"Process exited with code: 0x%x"</span></span>, debug_event.u.ExitProcess.dwExitCode); bContinueDebugging=<span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br><br><h4>  Processing EXCEPTION_DEBUG_EVENT </h4><br>  This is the most amazing and difficult thing in all debugging events.  From MSDN: <br><blockquote>  This event is generated when an exception occurs in the process being debugged (possibly when dividing by zero, going beyond the array, executing an int 3 instruction, or any other exception described in SEH).  The DEBUG_EVENT structure contains the EXCEPTION_DEBUF_INFO structure.  It is she who describes the exception. </blockquote><br>  The description of the processing of this event requires a separate article to tell about it completely (yes, even if only partially).  Therefore, I will tell you about one type of exception. <br>  The Exception field contains information about the exception that has just occurred.  Below you can see the description of the EXCEPTION_DEBUG_INFO structure: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EXCEPTION_DEBUG_INFO</span></span></span><span class="hljs-class"> {</span></span> EXCEPTION_RECORD ExceptionRecord; DWORD dwFirstChance; };</code> </pre><br>  The ExceptionRecord field contains detailed information about the exception. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EXCEPTION_RECORD</span></span></span><span class="hljs-class"> {</span></span> DWORD ExceptionCode; DWORD ExceptionFlags; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EXCEPTION_RECORD</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExceptionRecord</span></span></span><span class="hljs-class">;</span></span> PVOID ExceptionAddress; DWORD NumberParameters; ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS]; <span class="hljs-comment"><span class="hljs-comment">// 15 };</span></span></code> </pre><br>  Before we dive into EXCEPTION_RECORD, I would like to discuss EXCEPTION_DEBUG_INFO :: dwFirstChance with you. <br>  When the process is under debugging, the debugger always gets an exception before the OP receives it.  You must have seen the entry ‚ÄúFirst-chance exception at 0x00412882 in SomeModule‚Äù while debugging the application under C ++.  This refers to First Chance exceptions.  The same exceptions may or may not be on second chance exceptions. <br>  When the OP throws an exception, it is treated as a second chance.  The OP can handle this exception, or it can just fall.  These exceptions do not belong to C ++ exceptions, but to the Windows SEH engine.  I will reveal a little more in the next part of the article. <br>  First, the debugger receives the first chance exception, which helps it handle the exception faster than the OP.  Some libraries generate first-chance exceptions to help the debugger do its work. <br><h4>  More about ContinueDebugEvent </h4><br>  The third parameter of this function (dwContinueStatus) is important for us only to receive an exception.  For other events, this parameter is ignored. <br>  After receiving an exception, a ContinueDebugEvent should be called with: <br><ul><li>  DBG_CONTINUE if the exception was successfully caught by the debugger.  Nothing more is needed from the program being debugged and it can run normally. </li><li>  DBG_EXCEPTION_NOT_HANDLED if this exception is not handled (cannot be handled) by the debugger.  The debugger can only record what the exception was. </li></ul><br>  Note that if DBG_CONTINUE is returned during a debugging event in which it cannot be returned, then the exact same exception will be thrown in the debugger, and the same event will come instantly.  But since we are just starting to write a debugger, let's play with a safe slingshot, not a gun, and we will return EXCEPTION_NOT_HANDLED.  The exception in this article is int 3 (breakpoint), which we will discuss later. <br><h4>  Exception Codes </h4><br><br><ol><li>  EXCEPTION_ACCESS_VIOLATION </li><li>  EXCEPTION_ARRAY_BOUNDS_EXCEEDED </li><li>  EXCEPTION_BREAKPOINT </li><li>  EXCEPTION_DATATYPE_MISALIGNMENT </li><li>  EXCEPTION_FLT_DENORMAL_OPERAND </li><li>  EXCEPTION_FLT_DIVIDE_BY_ZERO </li><li>  EXCEPTION_FLT_INEXACT_RESULT </li><li>  EXCEPTION_FLT_INVALID_OPERATION </li><li>  EXCEPTION_FLT_OVERFLOW </li><li>  EXCEPTION_FLT_STACK_CHECK </li><li>  EXCEPTION_FLT_UNDERFLOW </li><li>  EXCEPTION_ILLEGAL_INSTRUCTION </li><li>  EXCEPTION_IN_PAGE_ERROR </li><li>  EXCEPTION_INT_DIVIDE_BY_ZERO </li><li>  EXCEPTION_INT_OVERFLOW </li><li>  EXCEPTION_INVALID_DISPOSITION </li><li>  EXCEPTION_NONCONTINUABLE_EXCEPTION </li><li>  EXCEPTION_PRIV_INSTRUCTION </li><li>  EXCEPTION_SINGLE_STEP </li><li>  EXCEPTION_STACK_OVERFLOW </li></ol><br>  Calm down, I'm not going to describe them all.  EXCEPTION_BREAKPOINT only: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EXCEPTION_DEBUG_EVENT: { EXCEPTION_DEBUG_INFO&amp; exception = debug_event.u.Exception; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>( exception.ExceptionRecord.ExceptionCode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> STATUS_BREAKPOINT: <span class="hljs-comment"><span class="hljs-comment">// Same value as EXCEPTION_BREAKPOINT strEventMessage= "Break point"; break; default: if(exception.dwFirstChance == 1) { strEventMessage.Format(L"First chance exception at %x, exception-code: 0x%08x", exception.ExceptionRecord.ExceptionAddress, exception.ExceptionRecord.ExceptionCode); } dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED; } break; }</span></span></code> </pre><br>  You should know what a breakpoint is.  Outside of the standard point of view, a breakpoint can be called using the DebugBreak API, or using the assembler instruction {int 3}.  In .NET, you can create it using System.Diagnostics.Debugger.Break.  The debugger will receive a STATUS_BREAKPOINT code (the same as EXCEPTION_BREAKPOINT).  The debugger usually uses this event to stop the current process, and can show the source code of the place where the event occurred.  But since our debugger is just beginning to be developed, we will show the user only basic information without the source code. <br>  If the breakpoint is called in an application that is not under the debugger, it will simply fall.  You can use the following design: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !IsDebuggerPresent() ) AfxMessageBox(<span class="hljs-string"><span class="hljs-string">L"No debugger is attached currently."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> DebugBreak();</code> </pre><br>  In conclusion, I would like to give the simplest debugging event: EXCEPTION_DEBUG_EVENT.  This event will come all the time.  Debuggers like Visual Studio ignore it, but WinDbg does not. <br><h4>  Conclusion </h4><br>  Use any debugger for debugme. <br><img src="https://habrastorage.org/storage2/082/3b8/d33/0823b8d333c4580ab49f89bdfed9f53f.jpg"><br>  The second part will be even more interesting and it is on the way! <br>  <b>UPD:</b> <a href="http://habrahabr.ru/post/190800/">Part 2</a> </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/154847/">https://habr.com/ru/post/154847/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../154833/index.html">Welcome to the West Concept blog.</a></li>
<li><a href="../154839/index.html">Updated Raspberry Pi with 512 MB of RAM at the same price</a></li>
<li><a href="../154841/index.html">Individual eye movements as a component of the human identification system</a></li>
<li><a href="../154843/index.html">Syntax extension proposal</a></li>
<li><a href="../154845/index.html">‚ÄúRunet today‚Äù, October 15, 2012. Experts of the issue: Vadim Fedotov, Svetlana Ivannikova</a></li>
<li><a href="../154849/index.html">ThinkPad laptops are 20 years old!</a></li>
<li><a href="../154851/index.html">AndroidAnnotations - simplify and shorten the code without harm to the health of the project (Part I)</a></li>
<li><a href="../154859/index.html">Sublimehaskell</a></li>
<li><a href="../154863/index.html">Competition of ideas and applications for smart TV</a></li>
<li><a href="../154865/index.html">Delivering Kohana ORM from unnecessary database queries</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>