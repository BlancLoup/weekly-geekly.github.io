<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parse Async / Await in JavaScript with examples</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The author of the article examines Async / Await in JavaScript. In general, Async / Await is a convenient way to write asynchronous code. Before the a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parse Async / Await in JavaScript with examples</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/2c8/f4a/252/2c8f4a252d33ee663665fd7df02b45ed.jpg"><br><br>  The author of the article examines Async / Await in JavaScript.  In general, Async / Await is a convenient way to write asynchronous code.  Before the appearance of this feature, a similar code was written using callbacks and promises.  The author of the original article reveals the advantages of Async / Await, examining various examples. <br><a name="habracut"></a><br><blockquote>  <b>We remind:</b> <i>for all readers of "Habr" - a discount of 10,000 rubles when writing to any Skillbox course on the promotional code "Habr".</i> <br><br>  <b>Skillbox recommends:</b> Educational online course <a href="https://skillbox.ru/java/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3DJAVDEV%26utm_content%3Darticles%26utm_term%3Dasync">"Java-developer"</a> . </blockquote><br><h3>  Callback </h3><br>  Callback is a function whose call is postponed indefinitely.  Previously, callbacks were used in those areas of the code where the result could not be obtained immediately. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here is an example of an asynchronous file reading on Node.js: <br><br><pre><code class="javascript hljs">fs.readFile(__filename, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>, (err, data) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); });</code> </pre> <br>  Problems arise at the moment when you need to perform several asynchronous operations at once.  Let's imagine the following scenario: a request is made to the Arfat user database, you need to read its profile_img_url field and upload a picture from the server someserver.com. <br>  After downloading, we convert the image to another format, for example, from PNG to JPEG.  If the conversion is successful, an email is sent to the user's mail.  Further information about the event is recorded in the file transformations.log with the date. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad5/c3f/e3b/ad5c3fe3bf0f7a68a4d3444614c3133e.png"><br><br>  It is worth paying attention to the imposition of callbacks and a large number}) in the final part of the code.  This is called Callback Hell or Pyramid of Doom. <br><br>  The disadvantages of this method are obvious: <br><br><ul><li>  This code is hard to read. </li><li>  It is also difficult to handle errors, which often leads to a deterioration in the quality of the code. </li></ul><br>  In order to solve this problem, promises have been added in JavaScript.  They allow you to replace the deep nesting of callbacks with the word .then. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/503/0ad/9e15030ad0dbb431a63d9f98ec228111.png"><br><br>  The positive point of the promises was that with them the code is read much better, and from top to bottom, and not from left to right.  Nevertheless, promises also have their own problems: <br><br><ul><li>  Need to add a large amount of .then. </li><li>  Instead of try / catch, use .catch to handle all errors. </li><li>  Working with several promises within one cycle is far from always convenient, in some cases they complicate the code. </li></ul><br>  Here is the task that will show the value of the last item. <br><br>  Suppose there is a for loop that outputs a sequence of numbers from 0 to 10 at a random interval (0 ‚Äì n seconds).  Using promises, you need to change this cycle so that the numbers are displayed in the sequence from 0 to 10. So, if the zero output takes 6 seconds and the units 2 seconds, zero should be displayed first, and then the unit output will begin. <br><br>  And of course, to solve this problem, we do not use Async / Await or .sort.  An example of a solution is at the end. <br><br><h3>  Async functions </h3><br>  Adding async functions to ES2017 (ES8) simplified the task of working with promises.  I note that the async functions work "on top" of promises.  These functions are not qualitatively different concepts.  Async functions were thought of as an alternative to code that uses promises. <br><br>  Async / Await allows you to organize work with asynchronous code in a synchronous style. <br><br>  Thus, knowledge of promises makes it easier to understand the principles of Async / Await. <br><br>  <b>Syntax</b> <br><br>  Normally, it consists of two keywords: async and await.  The first word and turns the function into asynchronous.  In such functions, the use of await is permitted.  In any other case, using this function will cause an error. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// With function declaration async function myFn() { // await ... } // With arrow function const myFn = async () =&gt; { // await ... } function myFn() { // await fn(); (Syntax Error since no async) }</span></span></code> </pre><br>  Async is inserted at the very beginning of the function declaration, and in the case of using an arrow function, between the ‚Äú=‚Äù sign and the brackets. <br><br>  These functions can be placed in an object as methods or used in a class declaration. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// As an object's method const obj = { async getName() { return fetch('https://www.example.com'); } } // In a class class Obj { async getResource() { return fetch('https://www.example.com'); } }</span></span></code> </pre> <br>  NB!  It is worth remembering that class constructors and getters / setters cannot be asynchronous. <br><br>  <b>Semantics and execution rules</b> <br><br>  Async functions, in principle, are similar to standard JS functions, but there are exceptions. <br><br>  So, async functions always return promises: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hello'</span></span>; } fn().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">// hello</span></span></code> </pre> <br>  In particular, fn returns the string hello.  Well, since this is an asynchronous function, the string value is wrapped in a promise using a constructor. <br><br>  Here is an alternative design without Async: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>); } fn().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-comment"><span class="hljs-comment">// hello</span></span></code> </pre> <br>  In this case, the return of promis made "manually."  The asynchronous function is always wrapped in a new promise. <br><br>  In that case, if the return value is primitive, the async function returns the value, wrapping it in promise.  In the event that the returned value is the object of promise, its solution is returned in the new promise. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) p <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>; <span class="hljs-comment"><span class="hljs-comment">// true Promise.resolve(p) === p; // true</span></span></code> </pre><br>  But what happens if an error occurs inside an asynchronous function? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>); } foo().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br>  If it is not processed, foo () will return a promise with a reject.  In this situation, the Promise.reject containing the error will be returned instead of the Promise.resolve. <br><br>  Async functions at the output always give a promise, regardless of what is returned. <br><br>  Asynchronous functions are suspended with each await. <br><br>  Await affects expressions.  So, if the expression is promis, the async function is suspended until the promise is executed.  In the event that the expression is not a promise, it is converted into promise through Promise.resolve and then completed. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// utility function to cause delay // and get random value const delayAndGetRandom = (ms) =&gt; { return new Promise(resolve =&gt; setTimeout( () =&gt; { const val = Math.trunc(Math.random() * 100); resolve(val); }, ms )); }; async function fn() { const a = await 9; const b = await delayAndGetRandom(1000); const c = await 5; await delayAndGetRandom(1000); return a + b * c; } // Execute fn fn().then(console.log);</span></span></code> </pre> <br>  And here is a description of how the fn-function works. <br><br><ul><li>  After calling it, the first line is converted from const a = await 9;  in const a = await Promise.resolve (9) ;. </li><li>  After using Await, the execution of the function is suspended until it receives its value (in the current situation it is 9). </li><li>  delayAndGetRandom (1000) suspends the execution of the fn-function until it completes itself (after 1 second).  This is actually the stop of the fn-function for 1 second. </li><li>  delayAndGetRandom (1000) returns a random value through the resolve, which is then assigned to the variable b. </li><li>  But the case of the variable c is similar to the case of the variable a.  After that, everything stops for a second, but now delayAndGetRandom (1000) returns nothing, since this is not required. </li><li>  As a result, the values ‚Äã‚Äãare calculated by the formula a + b * c.  The result is wrapped in a promise with Promise.resolve and returned as a function. </li></ul><br>  These pauses may resemble generators in ES6, but this has <a href="https://codeburst.io/understanding-generators-in-es6-javascript-with-examples-6728834016d5">its own reasons</a> . <br><br><h3>  Solve the problem </h3><br>  Well, now let's consider the solution to the problem that was mentioned above. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/ec5/c45/40bec5c4564dfabbe1810db3d4a60c2d.png"><br><br>  The finishMyTask function uses Await to wait for the results of operations such as queryDatabase, sendEmail, logTaskInFile, and others.  If we compare this solution with where the promises were used, the similarity will become apparent.  Nevertheless, the version with Async / Await rather simplifies all syntactic complexities.  In this case, there are not a large number of callbacks and chains like .then / .catch. <br><br>  Here is a solution with the output of numbers, there are two options. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i, ms</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(i), ms)); <span class="hljs-comment"><span class="hljs-comment">// Implementation One (Using for-loop) const printNumbers = () =&gt; new Promise((resolve) =&gt; { let pr = Promise.resolve(0); for (let i = 1; i &lt;= 10; i += 1) { pr = pr.then((val) =&gt; { console.log(val); return wait(i, Math.random() * 1000); }); } resolve(pr); }); // Implementation Two (Using Recursion) const printNumbersRecursive = () =&gt; { return Promise.resolve(0).then(function processNextPromise(i) { if (i === 10) { return undefined; } return wait(i, Math.random() * 1000).then((val) =&gt; { console.log(val); return processNextPromise(i + 1); }); }); };</span></span></code> </pre> <br>  But the solution is using async functions. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printNumbersUsingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> wait(i, <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); } }</code> </pre> <br>  <b>Error processing</b> <br><br>  Raw errors are wrapped in rejected promises.  However, in async functions, you can use a try / catch construct to perform synchronous error handling. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canRejectOrReturn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// wait one second await new Promise(res =&gt; setTimeout(res, 1000)); // Reject with ~50% probability if (Math.random() &gt; 0.5) { throw new Error('Sorry, number too big.') } return 'perfect number'; }</span></span></code> </pre> <br>  canRejectOrReturn () is an asynchronous function that either successfully executes (‚Äúperfect number‚Äù) or fails with an error (‚ÄúSorry, number too big‚Äù). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br>  Since the example above is expected to execute canRejectOrReturn, then its own failure will result in the execution of a catch block.  As a result, the foo function will end either with undefined (when nothing is returned in the try block) or with error caught.  As a result, this function will not fail because the try / catch will handle the function foo itself. <br><br>  Here is another example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br>  It is worth paying attention to the fact that in the example foo returns canRejectOrReturn.  Foo in this case completes either the perfect number, or an Error (‚ÄúSorry, number too big‚Äù) error is returned.  The catch block will never be executed. <br><br>  The problem is that foo returns the promise sent from canRejectOrReturn.  Therefore, the solution of the foo function becomes the solution for canRejectOrReturn.  In this case, the code will consist of only two lines: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = canRejectOrReturn(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise; }</code> </pre> <br>  This is what will happen if you use await and return together: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br>  In the code above, foo will successfully complete with both the perfect number and error caught.  There will be no failures.  But foo will end with canRejectOrReturn, not with undefined.  Let's verify this by removing the return await canRejectOrReturn () line: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶</span></span></code> </pre> <br><h3>  Common mistakes and pitfalls </h3><br>  In some cases, using Async / Await can lead to errors. <br><br>  <b>Forgotten await</b> <br><br>  This happens quite often - the await keyword is forgotten before the promise: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'caught'</span></span>; } }</code> </pre> <br>  In the code, as you can see, there is no await or return.  Therefore, foo always ends with undefined without a 1 second delay.  But the promise will be done.  If it gives an error or a rejection, then in this case UnhandledPromiseRejectionWarning will be called. <br><br>  <b>Async functions in callbacks</b> <br><br>  Async functions are often used in .map or .filter as callbacks.  An example is the function fetchPublicReposCount (username), which returns the number of repositories open on GitHub.  Suppose there are three users whose indicators we need.  Here is the code for this task: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https://api.github.com/users'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Utility fn to fetch repo counts const fetchPublicReposCount = async (username) =&gt; { const response = await fetch(`${url}/${username}`); const json = await response.json(); return json['public_repos']; }</span></span></code> </pre> <br>  We need accounts ArfatSalman, octocat, norvig.  In this case we execute: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = [ <span class="hljs-string"><span class="hljs-string">'ArfatSalman'</span></span>, <span class="hljs-string"><span class="hljs-string">'octocat'</span></span>, <span class="hljs-string"><span class="hljs-string">'norvig'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counts = users.map(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> username =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; });</code> </pre> <br>  Pay attention to Await in the callback .map.  Here counts is an array of promises, but .map is an anonymous callback for each specified user. <br><br>  <b>Overuse of await</b> <br><br>  As an example, take this code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchAllCounts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counts = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; users.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> username = users[i]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); counts.push(count); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counts; }</code> </pre> <br>  Here the number of the repo is placed in the count variable, then this number is added to the counts array.  The problem with the code is that until the data of the first user comes from the server, all subsequent users will be in standby mode.  Thus, only one user is processed at a single moment. <br><br>  If, for example, it takes about 300 ms to process one user, then for all users it is already a second, the time spent linearly depends on the number of users.  But once the receipt of the number of repos does not depend on each other, the processes can be parallelized.  This requires working with .map and Promise.all: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchAllCounts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promises = users.map(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> username =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promises); }</code> </pre> <br>  Promise.all at the entrance receives an array of promises with the return of promise.  After the completion of all promises in the array or at the first rejection, the last one is completed.  It may happen that all of them do not start at the same time, - in order to ensure simultaneous launch, you can use a p-map. <br><br><h3>  Conclusion </h3><br>  Async functions are becoming increasingly important for development.  Well, for adaptive use of async-functions, you should use <a href="https://github.com/tc39/proposal-async-iteration" rel="nofollow noopener noreferrer">Async Iterators</a> .  A javascript developer should be good at this. <br><br><blockquote>  <b>Skillbox recommends:</b> <br><br><ul><li>  Practical course <a href="https://skillbox.ru/agima/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3DAGIMA%26utm_content%3Darticles%26utm_term%3Dasync">"Mobile Developer PRO"</a> . </li><li>  Applied online course <a href="https://skillbox.ru/python-data/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3DPTNANA%26utm_content%3Darticles%26utm_term%3Dasync">"Data Analytics in Python"</a> . </li><li>  Two-year practical course <a href="https://iamwebdev.skillbox.ru/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3DWEBDEVPRO%26utm_content%3Darticles%26utm_term%3Dasync">"I am a web developer PRO"</a> . </li></ul></blockquote></div><p>Source: <a href="https://habr.com/ru/post/458950/">https://habr.com/ru/post/458950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458936/index.html">‚ÄúIt's easier to answer than to remain silent‚Äù - a great interview with the father of transactional memory, Maurice Herlihy</a></li>
<li><a href="../458940/index.html">How we implemented Agile-testing</a></li>
<li><a href="../458944/index.html">Hiring an employee starts with ... respect. We will interview the engineer</a></li>
<li><a href="../458948/index.html">Habr Weekly # 8 / Yandex Wizards, a book about Prince of Persia, YouTube vs Hackers, Pentagon "heart" laser</a></li>
<li><a href="../45895/index.html">Collective posts</a></li>
<li><a href="../458952/index.html">Setting PostgreSQL Options for Performance Optimization</a></li>
<li><a href="../458954/index.html">What types of detection are useful in video surveillance. Mechanisms and functions</a></li>
<li><a href="../458956/index.html">Machine Learning vs. analytical approach</a></li>
<li><a href="../45896/index.html">Do not allocate Bold</a></li>
<li><a href="../458960/index.html">Corporate Quest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>