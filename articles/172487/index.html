<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We generate on .Net</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="You can generate .Net code in several ways: 


- Reflection Emit. Available from .Net 1.0. 
- CodeDom. Allows you to create dynamic code from the Code...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We generate on .Net</h1><div class="post__text post__text-html js-mediator-article">  You can generate .Net code in several ways: <br><ul><li>  Reflection Emit.  Available from .Net 1.0. </li><li>  CodeDom.  Allows you to create dynamic code from the CodeDom view or directly from source code written in one of the high-level languages, such as C #, VB or JScript.  Available from .Net 1.0. </li><li>  Expression trees.  Available from .Net 3.5.  Allows you to create dynamic code from the Expression view. </li></ul><br>  In this article I want to tell you about the code generation technique using Reflection Emit. <br><a name="habracut"></a><br><h4>  A little more about how to generate </h4><br>  The first is the direct generation of CIL code (also known as MSIL or simply IL) for the .Net virtual machine.  In this case, the generated code is described in CIL, which in appearance resembles an assembler on steroids.  At the output, you get a dynamic assembly (with the ability to save it to disk) with dynamic classes and methods or a ‚Äúbare‚Äù dynamic method.  Then use the generated good at your discretion. <br>  The second is the generation of source code in a high-level language (for example, C # or VB), and then the subsequent compilation of source codes into CIL.  At the output, you get an assembly created by the corresponding compiler. <br>  The third is generation from the Expression Tree view.  You describe some ASD (AST) with the help of Expression methods, and then with the same Expression you generate the described method.  Inside, Expression translates its presentation immediately into CIL code, while producing some useful validation of the described SDA (AST).  But Expression Tree is limited in its capabilities - you cannot generate your types and assemblies and, accordingly, save them to disk. <br><br><h4>  We will generate CIL </h4><br>  Why on CIL, but not in high level language?  Generation on CIL is more efficient, because generation in a high-level language is the creation of source codes in this language, and then compiling them into CIL.  In addition, generation in a top-level language requires the involvement of an external process ‚Äî the compiler.  And yet - this is a rare opportunity to dig out with something like an assembler for a .net programmer.  But the generation in the high-level language has its advantages: it is not necessary to deal with CIL, you generate the code in the familiar language.  In addition, the source code of such code generation can always be saved or dumped into the log, and then validated by eye or even inserted into the IDE and debugged. <br><br><h4>  What is it like </h4><br>  In order to generate code using Reflection Emit, you need to have a minimal understanding of the assembler.  In CIL assembler there are no registers, offsets and tricky addressing.  And what is there?  There is a stack of calculations, all operations work only with it, there are no registers.  In this case, the computation stack is so named not without purpose, it does not include local variables and method arguments ‚Äî for CIL, these are separate concepts.  There are still operations.  They are of two types: ordinary assembler (various kinds of transitions, mathematical operations, method calls, etc. or CLR special (Box / Unbox, Newobj, Isinst, etc.). However, the separation is purely formal. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Enough words, start generating </h4><br>  It is better to see once than hear a hundred times, and even better - podebazhit.  This is me to the fact that enough words, let's look at an example. <br>  Let the task be this: generate a converter from one entity to another.  Those.  There are classes that are essentially the same, but with different property names.  For example: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestSrc</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SomeID { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestTarg</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> SomeOtherID { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  We need to convert TestSrc to TestTarg.  Let our converter look like this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Mapper</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TIn</span></span>, <span class="hljs-title"><span class="hljs-title">TOut</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> TOut </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TIn src</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TOut </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Map</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TIn source</span></span></span><span class="hljs-function">)</span></span> {...} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> MapMethod </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMapMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDictionary&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; mapping</span></span></span><span class="hljs-function">)</span></span> {...} }</code> </pre><br>  The Map method at the first call generates a transforming method, calling GenerateMapMethod, and at subsequent calls it uses the already generated method.  The mapping that we pass to the input. GenerateMapMethod is the matching of fields in the entities (Key is the name of the property in the TIn type. Value is the name of the property in the TOut type). <br><br><h5>  Dynamic build </h5><br>  First we need to make a choice: where will our generated code be placed?  There are two options - in a dynamic assembly or in a dynamic method.  Both are created on the fly. <br>  Dynamic assembly is a full-fledged solution; it allows you to generate real classes and structures with any set of methods.  Another plus of a dynamic assembly is the ability to save it for later use or to analyze what you generated there.  This is for difficult cases. <br>  So, we create an assembly with a class and a static method: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> MapMethod </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMapMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDictionary&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; mapping</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dynGeneratorHostAssembly = AppDomain.CurrentDomain.DefineDynamicAssembly( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AssemblyName(<span class="hljs-string"><span class="hljs-string">"Test.Gen, Version=1.0.0.1"</span></span>), AssemblyBuilderAccess.RunAndSave); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dynModule = dynGeneratorHostAssembly.DefineDynamicModule( <span class="hljs-string"><span class="hljs-string">"Test.Gen.Mod"</span></span>, <span class="hljs-string"><span class="hljs-string">"generated.dll"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dynType = dynModule.DefineType( <span class="hljs-string"><span class="hljs-string">"Test.MapperOne"</span></span>, TypeAttributes.Abstract | TypeAttributes.Sealed | TypeAttributes.Public); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dynMethod = dynType.DefineMethod( <span class="hljs-string"><span class="hljs-string">"callme"</span></span>, MethodAttributes.Static, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TOut), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type[] { <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TIn) }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prm = dynMethod.DefineParameter(<span class="hljs-number"><span class="hljs-number">1</span></span>, ParameterAttributes.None, <span class="hljs-string"><span class="hljs-string">"source"</span></span>); GenerateMapMethodBody(dynMethod.GetILGenerator(), prm, mapping); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalType = dynType.CreateType(); dynGeneratorHostAssembly.Save(<span class="hljs-string"><span class="hljs-string">"generatedasm.dll"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> realMethodInfo = finalType.GetMethod(dynMethod.Name); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> methodToken = dynMethod.GetToken().Token; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> methodInfo = dynModule.ResolveMethod(methodToken); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (MapMethod)Delegate.CreateDelegate( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MapMethod), (MethodInfo)methodInfo); }</code> </pre> <br>  What does this code do?  Yes, in general, what is written, then it does - determines the dynamic assembly in the current domain (you can create a separate one) and indicates how we will use the assembly: just run, only save or all (defined by the AssemblyBuilderAccess enumeration).  It is not known whether a significant overhead projector will be known if you specify AssemblyBuilderAccess.RunAndSave and you do not need to save the assembly.  In .Net 4, it is possible to make unloading dynamic assemblies (AssemblyBuilderAccess.RunAndCollect).  In order for the assembly to be unloaded, no one should refer to instances of the types of this assembly and the types themselves, see <a href="http://msdn.microsoft.com/en-us/library/dd554932.aspx">here</a> for more details. <br>  Next, we define the module in the assembly.  We remember that assemblies consist of modules, most often one assembly - one module, but there may be multi-module assemblies.  A module corresponds to a physical file, so when defining a module, we specify the file name for it. <br>  In the module we define the type - it can be a class or a structure.  A simple call to DefineType ("Test.MapperOne") will create the private class MapperOne in the namespace Test.  Despite the fact that you may not have to refer to the generated classes and methods by name, it is better to give them accurate names and namespaces, because, firstly, they appear on the stack of traces, and secondly, if you analyze the generated structure of the reflector will be clearer and more pleasant.  ‚ÄúStop!‚Äù, The attentive reader will say.  After all, we get a private class, and even in another assembly, can we turn to it?  Well, in fact, we can.  But if you want everything to be strictly correct, write this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dynType = dynModule.DefineType(<span class="hljs-string"><span class="hljs-string">"Test.MapperOne"</span></span>, TypeAttributes.Abstract | TypeAttributes.Sealed | TypeAttributes.Public);</code> </pre><br>  Finally, in the type we define our method by specifying the type of the value returned by it and the types of the input arguments of the method. <br>  Next, we need to fill our generated method with meaning.  We will discuss this process in detail later, so we skip the GenerateMapMethodBody call (dynMethod.GetILGenerator (), prm, mapping) and look further. <br>  After all the methods in the type are generated, we have to create the type by calling the dynType.CreateType () method.  After that, no dynamic manipulations with the type become impossible.  But our type is now ready for use.  Before calling CreateType, the CLR knows nothing about our type and the methods in it.  Unlike the assembly that appears in the domain immediately after the DefineDynamicAssembly call, and the module that appears in the assembly immediately after the DefineDynamicModule call. <br>  One interesting point: when we defined the dynamic type with the DefineType method, it returned to us TypeBuilder.  If you look at TypeBuilder, it is inherited from Type, but not all Type methods can be addressed if your Type is a TypeBuilder.  If you think about it, this is logical, because there is no such thing as such.  Some Type properties are redefined so that they always return NotSupportedException.  Some methods throw an exception before calling CreateType, and then begin to redirect calls to the appropriate RuntimeType.  The situation is similar with the MethodBuilder class, which is inherited from MethodInfo.  Not all properties and methods are also implemented in MethodBuilder.  Another situation is complicated by the fact that, for example, Delegate.CreateDelegate accepts MethodInfo as the second argument, but if you try to pass MethodBuilder there, you will get an exception in reply (even after calling CreateType).  So be careful. <br><br><h5>  Dynamic method </h5><br>  But let's say you don't need an assembly, you don't need your own types, you just want to generate a small method.  Then you are more suitable "economy" proposal - a dynamic method.  Instead of a heap of code from the previous section, we write the following: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> MapMethod </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMapMethod2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDictionary&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; mapping</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dynMethod = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicMethod(<span class="hljs-string"><span class="hljs-string">"callme"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TOut), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type[] { <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TIn) }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prm = dynMethod.DefineParameter(<span class="hljs-number"><span class="hljs-number">1</span></span>, ParameterAttributes.None, <span class="hljs-string"><span class="hljs-string">"source"</span></span>); GenerateMapMethodBody(dynMethod.GetILGenerator(), prm, mapping); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (MapMethod)dynMethod.CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MapMethod)); }</code> </pre> <br>  They created a method, filled it with meaning and returned a delegate for it.  Is done.  Although the documentation states that this method does not need a dynamic assembly, module and type, if you use reflection or ProcessExplorer, you will see that the dynamic assembly is still created (one for all dynamic domain methods).  And even there is a manifest module in it, but I could not find (by reflection) in it our method.  Nevertheless, it is and works.  The dynamic method and all the memory allocated for its generation can be freed after no one has referred to it.  Therefore, this method will be even a little faster and more economical.  In this case, we use anonymous hosting (anonymously hosted) for the method, but there is an option to ‚Äústick‚Äù our method to an already existing module or even a class.  To do this, there are special constructors that accept a module or type, to which we kind of add a dynamic method.  In the case of a module, the type becomes global for the module and has access to all types of module, including internal.  In the case of a class, we will still have access to all the internal fields of the class.  But even if you use ‚Äúanonymous‚Äù hosting, you still have the opportunity to access internal classes and even internal fields of these classes from a dynamic method.  To do this, use the constructor with the skipVisibility parameter and set this parameter to true (this parameter indicates that JIT verification is skipped, not to be confused with CAS verification).  By the way, the ability to use ‚Äúanonymous‚Äù hosting appeared only in .Net 3.0. <br><br><h5>  Body method </h5><br>  And here we come to the most interesting part - how to generate the code?  In our example, the code generates the GenerateMapMethodBody method (dynMethod.GetILGenerator (), prm, mapping).  In this method, we pass the ILGenerator, the parameter and the mapping - the correspondence of the fields of one class to another.  The ILGenerator class allows you to insert CIL commands into the body of the generated method.  He does this with the Emit method.  ILGenerator also allows you to make labels for transitions using the DefineLabel method (for organizing conditional structures), declare local variables using the DefineLocal method, and make blocks for exceptions.  For the latter, a whole set of methods of the form BeginCatchBlock, BeginExceptFilterBlock, etc. is used.  Most of the commands in CIL work with the calculation stack (evaluation stack, then for brevity, just the stack).  The CLR ensures that you do not go beyond the stack, either one way or the other.  If the stack overflows, you will get a StackOverflowException, if you try to take a value from an empty stack or a value that your method did not put there (that is, the method sees only its part of the stack), you will get an InvalidProgramException.  Arguments passed to your method are not on the stack;  to use them you need to use the OpCodes.Ldarg command.  Thus, at the beginning of the method, the stack is empty.  It must also be empty after the method is executed, otherwise InvalidProgramException will again be.  And this is one of the drawbacks of code generation in CIL: those errors that you could catch at the compilation stage of a high-level language here you only get at run time, for example, errors associated with typing or initialization of variables. <br><br>  A convenient technique for generating IL code is to write in a high-level language, an example of what you want to generate, compile it (do not forget to switch to Release before compiling to take an example from the optimal code) and see what the pattern of the necessary code looks like in CIL.  It is convenient to look at such template code with a reflector.  Moreover, there is even a special plugin ReflectionEmitLanguage.  This plugin does not show the code of the method or type being viewed in the reflector, but the code that generates the code being viewed.  If there was no reflector on hand, you can view the template using IL Disassembler (ildasm.exe) from the .Net SDK.  It will show the honest CIL that your method consists of.  Next, we adapt the template to your needs, and everything is ready.  Using the same method, you can find out which modifiers you need to add to a method or its class, for example, to make a sealed class or an internal (internal) virtual method. <br><br>  Suppose we know from somewhere the correspondence of properties between classes, then the template will look like this: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TestTarg </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateTemplate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TestSrc src</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestTarg(); result.SomeOtherID = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)src.SomeID; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  We compile the code, look at it in IL Disassembler and see: <br><pre> <code class="cs hljs">.method <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> hidebysig <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleApplication1</span></span>.<span class="hljs-title"><span class="hljs-title">TestTarg</span></span> <span class="hljs-title"><span class="hljs-title">GenerateTemplate</span></span>(<span class="hljs-title"><span class="hljs-title">class</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleApplication1</span></span>.<span class="hljs-title"><span class="hljs-title">TestSrc</span></span> <span class="hljs-title"><span class="hljs-title">src</span></span>) <span class="hljs-title"><span class="hljs-title">cil</span></span> <span class="hljs-title"><span class="hljs-title">managed</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Code size 21 (0x15) -  ,   .maxstack 2 // -  CLR   //     .locals init ([0] class ConsoleApplication1.TestTarg result) //     (  +  ) //           IL_0000: newobj instance void ConsoleApplication1.TestTarg::.ctor() //        0 IL_0005: stloc.0 //        0 IL_0006: ldloc.0 //        0 IL_0007: ldarg.0 //  (  ),             .     . IL_0008: callvirt instance int32 ConsoleApplication1.TestSrc::get_SomeID() //  int  double IL_000d: conv.r8 //   ,            ( int) IL_000e: callvirt instance void ConsoleApplication1.TestTarg::set_SomeOtherID(float64) //    IL_0013: ldloc.0 //    IL_0014: ret } // end of method Program::GenerateTemplate</span></span></code> </pre><br>  Looking at this template code, we transfer each operation as a call to ILGenerator.Emit (), for example: <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//IL_0000: newobj instance void ConsoleApplication1.TestTarg::.ctor() //  var tTarg = typeof(TOut); var targetCtor = tTarg.GetConstructor(new Type[0]); gen.Emit(OpCodes.Newobj, targetCtor); ... //IL_0006: ldloc.0 gen.Emit(OpCodes.Ldloc, locResult); ... //IL_0008: callvirt instance int32 ConsoleApplication1.TestSrc::get_SomeID() var methodSrc = tSrc.GetProperty(methodMap.Key).GetGetMethod(); gen.Emit(OpCodes.Callvirt, methodSrc); ... //IL_0014: ret gen.Emit(OpCodes.Ret);</span></span></code> </pre><br>  If you use the reflector with the Reflection.Emit plugin, then everything will become even simpler, it will show you exactly what ILGenerator.Emit () calls you need. <br><div class="spoiler">  <b class="spoiler_title">Here is what the plugin will show for our template.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MethodBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildMethodGenerateTemplate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TypeBuilder type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Declaring method builder // Method attributes System.Reflection.MethodAttributes methodAttributes = System.Reflection.MethodAttributes.Private | System.Reflection.MethodAttributes.HideBySig | System.Reflection.MethodAttributes.Static; MethodBuilder method = type.DefineMethod("GenerateTemplate", methodAttributes); // Preparing Reflection instances MethodInfo method1 = typeof(TestSrc).GetMethod(/*  */); MethodInfo method2 = typeof(TestTarg).GetMethod(/**/); // Setting return type method.SetReturnType(typeof(TestTarg)); // Adding parameters method.SetParameters( typeof(TestSrc) ); // Parameter src ParameterBuilder src = method.DefineParameter(1, ParameterAttributes.None, "src"); ILGenerator gen = method.GetILGenerator(); // Preparing locals LocalBuilder result = gen.DeclareLocal(typeof(TestTarg)); // Writing body gen.Emit(OpCodes.Ldloca_S,0); gen.Emit(OpCodes.Initobj,TestTarg); gen.Emit(OpCodes.Ldloca_S,0); gen.Emit(OpCodes.Ldarg_0); gen.Emit(OpCodes.Callvirt,method1); gen.Emit(OpCodes.Conv_R8); gen.Emit(OpCodes.Call,method2); gen.Emit(OpCodes.Ldloc_0); gen.Emit(OpCodes.Ret); // finished return method; }</span></span></code> </pre> </div></div><br>  Help for each operation can be viewed in msdn, the OpCodes class contains definitions for all operations.  Some teams are better not to carry "in the forehead."  For example, such commands as stloc.0, so as not to get confused, it is better to write wrong: <br><pre> <code class="cs hljs">gen.DeclareLocal(yourType); gen.Emit(OpCodes.Ldloc_0);</code> </pre><br>  and so: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> locResult = gen.DeclareLocal(yourType); gen.Emit(OpCodes.Ldloc, localVar);</code> </pre><br>  Similarly, you can do with the parameters of methods. <br>  Notice that some constructs that, say, in C # look the same, will differ in CIL.  For example: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RefType(); <span class="hljs-comment"><span class="hljs-comment">// reference  var a = new RefType[0]; //  var s = new ValType(); // value  // reference  var targetCtor = typeof(RefType).GetConstructor(new Type[0]); gen.Emit(OpCodes.Newobj, targetCtor); //  gen.Emit(OpCodes.Newarr, typeof(RefType)); // value  LocalBuilder loc = gen.DeclareLocal(typeof(ValType)); gen.Emit(OpCodes.Ldloca, loc); gen.Emit(OpCodes.Initobj, typeof(ValType));</span></span></code> </pre><br>  I would also like to draw attention to the ref parameters.  Since  in the case of ref parameters, the parameter is not a value, but a link, then it is necessary to work on the CIL level with it differently.  This is a kind of indirect addressing.  If this is a ref parameter of reference type, then the parameter will contain a link to the link, and a simple ldarg command will put on the stack not the link to the object, but that link to the link (a great chance to get lost in two pines).  To get an object reference on the stack, you must additionally call ldind.ref. <br>  If this is a ref parameter of type value (but not a structure), then the parameter will contain a reference to the value.  And to put a value on the stack, you need to use not the ldarg or starg commands, but ldind or stind. <br>  A similar situation with structures (exactly the opposite).  If you have a parameter or a variable of the structure type, then to access it, you must first put an address onto the structure in the stack.  For this there is a command ldarga. <br><br><h4>  Conclusion </h4><br>  Riddle: what does regexp and CIL generation have in common?  Answer: extremely complex reverse engineering.  Therefore, do not be lazy to weigh the generating code with comments so that it is clear what you are generating.  Well, or, say, in the generating methods comments should be 80% more than usual.  If you usually do not write them at all, then it's time to start. <br><br>  Perhaps there are still many questions that can be discussed on the subject of CIL generation, but it seems to me that the article has already dragged out.  So good luck to all and see you soon. <br><br>  Useful links: <br><ul><li>  Sample code can be found <a href="">here.</a> </li><li>  <a href="http://reflectoraddins.codeplex.com/wikipage%3Ftitle%3DReflectionEmitLanguage%26referringTitle%3DHome">ReflectionEmitLanguage</a> Reflector Plugin </li><li>  MSDN: <a href="http://msdn.microsoft.com/en-us/library/3y322t50.aspx">Using reflection emit</a> </li><li>  MSDN: CIL <a href="http://msdn.microsoft.com/en-us/library/x2ebty98.aspx">OpCodes opcodes</a> </li><li>  MSDN: <a href="http://msdn.microsoft.com/en-us/library/dd554932.aspx">Working with Paged Assemblies</a> </li></ul><br>  <b>UPD:</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Smart people in the comments suggest that they can also help you in the difficult task of generating: </font></font><br><ul><li> <a href="http://msdn.microsoft.com/en-gb/roslyn"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roslyn</font></font></a> </li><li> <a href="http://ccimetadata.codeplex.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Common Compiler Infrastructure</font></font></a> </li><li> <a href="http://www.mono-project.com/Cecil"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mono.Cecil</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I have not worked with them and can not say anything about them. </font></font><br><br>  PS <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each programmer must write a compiler, code generator and PeHaPe shop. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Another option is not the topic, but I liked: Each programmer must build a Linux kernel, grow the database to a terabyte and put in a floating bug).</font></font></div><p>Source: <a href="https://habr.com/ru/post/172487/">https://habr.com/ru/post/172487/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../172473/index.html">Distributed rendering</a></li>
<li><a href="../172475/index.html">Check input parameters or indirect references to BASH</a></li>
<li><a href="../172479/index.html">How I used Google Glass: the future, but with monthly updates (part 1)</a></li>
<li><a href="../172481/index.html">Configuring CCBoot v.3 to work in Active Directory</a></li>
<li><a href="../172485/index.html">The collective mind HabraHabra chose the best games of all times and peoples for 2013</a></li>
<li><a href="../172489/index.html">CRUD matrix technology. Practical experience</a></li>
<li><a href="../172491/index.html">Connecting Android sources to Eclipse</a></li>
<li><a href="../172495/index.html">PayPal received a license of the Central Bank of the Russian Federation?</a></li>
<li><a href="../172497/index.html">How the data center in Kajaani was built and how it can be good</a></li>
<li><a href="../172501/index.html">March Habravstrecha in Kiev</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>