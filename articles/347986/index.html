<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mobile App Auto-Test Tools Guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... despite the fact that it is somewhat incomplete, contains a lot of doubtful or, 
 in any case, blatantly inaccurate, it has two important advantag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mobile App Auto-Test Tools Guide</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/r8/qr/qr/r8qrqrcyweesgj5oycqlry5nccc.png"><br><br><blockquote>  ... despite the fact that it is somewhat incomplete, contains a lot of doubtful or, <br>  in any case, blatantly inaccurate, it has two important advantages: <br>  firstly, it is a bit cheaper, [...], and secondly, on its cover large <br>  and pleasant for the eyes written two words "Do not panic!" <br>  - The Hitchhiker's Guide to the Galaxy </blockquote><br>  Hi, Habr! <br><br>  My name is Arseny Batyrov, I work in the QA Badoo department and mainly do manual testing of web applications.  I also conduct courses on manual and automatic testing of mobile applications. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Before launching a new course, I thought about what tools students should tell.  Prosterstil Runet and the English-speaking Internet in search of comparative articles, but, oddly enough, did not find a suitable source of information.  And then I decided to create it myself. <br><br>  I pursued three goals: <br><br><ol><li>  Classify tools on the auto-test stack so that their hierarchy and compatibility become clear. </li><li>  Show what tools are popular on the market today. </li><li>  Tell about the most popular tools of each type and compare them for several parameters. </li></ol><br>  The result of my work was this guide to the most popular and easy-to-learn tools for auto-testing mobile applications. <br><br>  Use! <br><br><ul><li>  Choose a tool - see the <a href="https://habr.com/ru/company/badoo/blog/347986/">comparison</a> . </li><li>  Want to find out how automation works on mobile devices - look at the <a href="https://habr.com/ru/company/badoo/blog/347986/">classification</a> . </li><li>  Want to achieve a salary increase - learn a <a href="https://habr.com/ru/company/badoo/blog/347986/">popular</a> tool. </li></ul><a name="habracut"></a><br><h2>  Content </h2><br><ul><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Application and Tests</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Tool classification</a> <br><ul><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Driver</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Superstructure</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Framework</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Combine harvester</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Poll</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Tool comparison</a> <br><ul><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Drivers</a> <br><ul><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Uiautomator</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Espresso</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Selendroid and robotium</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Xcuitest</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Add-ons</a> <br><ul><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Appium</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">WebDriverAgent</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Calabash</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Earl gray</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Frameworks</a> <br><ul><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">xUnit and TestNG</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Cucumber</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Combines</a> <br><ul><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Xamarin</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Ranorex</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Squish</a> </li></ul></li></ul></li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Conclusion</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Thanks</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">Cribs</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/347986/">useful links</a> </li></ul><br>  <i><b>Disclaimer:</b> I am not a testing guru, and this article is not an exhaustive list.</i>  <i>If you find a mistake or want to add a guidebook, welcome to the comments - I will definitely bring all the useful information from there with an update.</i> <br><a name="app_tests"></a><br><h2>  Application and Tests </h2><br>  First, let's understand what our tools will work with. <br><br>  There are two important entities for us that are not part of the automation stack: this application and tests.  The application is addressed by all automation tools.  It interacts with the user and other applications through one or several interfaces: GUI, API, network interface, CLI and some others. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/er/-c/db/er-cdbfytswr0xbu01whyrqeule.png" width="500"></div><br><br>  <b>API</b> (application programming interface) - the main interface for interacting with other programs. <br><br>  <b>GUI</b> (graphic user interface) - a graphical interface, used to interact with the user. <br><br>  <b>Net</b> (networking interface) - works through the network and is used by both advanced users and programs. <br><br>  Tests can use all of these interfaces to interact with the application.  In manual testing, the tester is the intermediary between the tests and the application: it converts the text of the test cases into actions with one of the application interfaces. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qk/rx/wn/qkrxwnpzjipxd_iau8z5wousjkg.png" width="350"></div><br><br>  For automation, you need to replace the tester with tools that can interact with one or several interfaces of the application.  Utilities for running and building a test suite will also be required. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ry/xt/9t/ryxt9ta-oyfkeh9dweqauleboze.png" width="350"></div><br><br>  Together, all of these tools are called an auto-test stack.  To understand how they interact in the stack, it is necessary to classify them.  The presented classification is conditional and necessary first of all for understanding the tools and their compatibility. <br><br>  There are four groups of tools: drivers, add-ins, frameworks and combines.  Consider them in more detail. <br><a name="class"></a><br><h2>  Tool classification </h2><a name="cl_driver"></a><br><h3>  Driver </h3><br>  Auto-testing utilities, like other programs, can interact with an application only through a software interface ‚Äî they cannot do otherwise.  To work through other interfaces, there are special programs - drivers. <br><br>  <i><b>Driver</b> - a program that provides an API for one of the application interfaces.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xq/3v/bu/xq3vbud4xxucbdwrbxunruhaewy.png" width="450"></div><br><br>  For each interface, except, in fact, the API, you need your own driver.  For example, when you give the GUI driver the command ‚ÄúPress the Menu Button‚Äù, it takes it through the API and sends it to the application under test, where this command turns into a click on the graphic Menu button.  Drivers are not needed or almost not needed to interact with the API of the application - software interaction.  But when working with other interfaces can not do without them. <br><br>  GUI drivers are usually the most complex, since this interface is very different from the usual communication program code.  At the same time, in automated testing of mobile applications, the GUI is most relevant, since it is most often used in integration testing.  The most popular GUI drivers for mobile testing are <a href="https://habr.com/ru/company/badoo/blog/347986/">UIAutomator</a> and <a href="https://habr.com/ru/company/badoo/blog/347986/">Espresso</a> for Android, <a href="https://habr.com/ru/company/badoo/blog/347986/">XCUITest</a> for iOS. <br><a name="cl_wrapper"></a><br><h3>  Superstructure </h3><br>  When the driver functionality is not enough or it is inconvenient and complicated, another level will appear above it, which I will call the add-in. <br><br>  <i><b>Add-in</b> - a program that interacts with the application through one or more drivers, increasing the usability of their use or expanding their capabilities.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ou/qg/yo/ouqgyourw9lrqz-txxlliyiukqy.png" width="450"></div><br><br>  The add-in can have the following functions: <br><ol><li>  Behavior modification (without changing the API). <br>  For example: <br><ul><li>  additional logging </li><li>  data validation </li><li>  waiting for action to take place within a specified time. </li></ul></li><li>  Improving the convenience and / or level of API abstraction through: <br><ul><li>  the use of syntactic sugar - convenient names of functions, shorter references to them, a unified style of writing tests; </li><li>  implicit control of the driver when, for example, it is initialized automatically, without the need to prescribe each such action manually; </li><li>  simplifying complex commands like selecting an event from a calendar or working with scrolling lists; </li><li>  implementation of alternative programming styles, such as procedural style or fluent. </li></ul></li><li>  Unification API drivers. <br>  Here, the add-in provides a single interface for working with multiple drivers at once.  This allows, for example, to use the same code for tests on iOS and Android, as in the popular <a href="https://habr.com/ru/company/badoo/blog/347986/">Appium</a> add- <a href="https://habr.com/ru/company/badoo/blog/347986/">on</a> . <br></li></ol><a name="cl_framework"></a><br><h3>  Framework </h3><br>  On the other side of the tests is the launch framework.  In this article I will briefly call it ‚Äúframework‚Äù. <br><br>  <i><b>A framework</b> is a program for building, running, and collecting the results of running a test suite.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7r/w9/pq/7rw9pqd0b995a3cbisbcra3kpdq.png" width="450"></div><br><br>  The framework tasks include: <br><ul><li>  forming, grouping and organizing a test suite, </li><li>  set parallelization (optional), </li><li>  making <abbr title="Fixture - a previously known state of the environment">fixtures</abbr> </li><li>  running tests </li><li>  collection of results of their implementation, </li><li>  generation of performance reports (optional). </li></ul><br>  It can be noted that these functions are not related to testing only mobile applications - they can be successfully used in testing desktop and web applications.  The fact is that the framework should not ensure the interaction of tests and applications - it works only with tests, and the type of application does not matter. <br><br>  If drivers and add-ons are between the tests and the application, the framework is above the tests, organizing their launch.  Therefore, it is important not to confuse the concepts of ‚Äúdriver‚Äù and ‚Äúframework‚Äù.  Of course, some frameworks have their own drivers for working with applications, but this is not a prerequisite.  The most notable frameworks in mobile testing are <a href="https://habr.com/ru/company/badoo/blog/347986/">xUnit</a> and <a href="https://habr.com/ru/company/badoo/blog/347986/">Cucumber</a> . <br><a name="cl_combine"></a><br><h3>  Combines </h3><br>  Finally, another group of utilities used to automate the testing of mobile applications is combines that combine both frameworks and drivers (and not only mobile ones), and even development capabilities.  <a href="https://habr.com/ru/company/badoo/blog/347986/">Xamarin.UITest</a> , <a href="https://habr.com/ru/company/badoo/blog/347986/">Squish</a> , <a href="https://habr.com/ru/company/badoo/blog/347986/">Ranorex</a> - they all support the automation of testing iOS, Android, web applications, and the latter two - also desktop applications. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kv/d0/cz/kvd0czcsfmbeaqq5ptqjod6tibi.png" width="450"></div><br><br>  So, we have classified the tools.  It remains to determine the most popular in each category and compare them. <br><a name="quiz"></a><br><h2>  Poll </h2><br>  To identify the most popular and used utilities, I conducted surveys on several sites, communities, and channels for QA engineers, asking three simple questions.  I did not limit the number of answer options so that I did not have to choose between different types of tools.  It was also possible to add your own version - so there was quite a long "tail" of various utilities that do not fit into the classification.  The results do not pretend to statistical accuracy, but they perfectly illustrate trends in the mobile application testing automation industry as of January 2018. <br><br><img src="https://habrastorage.org/webt/qv/f6/8g/qvf68gtmmm2d7-j7io6yzrplbju.png"><br><br><img src="https://habrastorage.org/webt/qn/41/mr/qn41mrinsdcujzphhty2fws-szg.png"><br><br><img src="https://habrastorage.org/webt/wh/sm/qf/whsmqf-nq2sjksp8ce_mx93naba.png"><br><br>  As can be seen from the results, the leading positions are occupied by utilities based on WebDriver: <b>Appium</b> and <b>Selenium</b> .  Of the frameworks, <b>JUnit</b> and <b>Cucumber are the</b> most popular, and the second is more popular - it is surprising, because they still have different ‚Äúweight categories‚Äù.  Official drivers are more popular than unofficial ones for any platforms - apparently, due to high-quality support and more opportunities than third-party developments. <br><br>  The three most used programming languages ‚Äã‚Äãlook like this: <b>Java</b> , <b>Python</b> , <b>Ruby</b> (and Java leads by a wide margin).  Ruby hit the top three I associate with the popularity of Cucumber. <br><br>  Finally, the distribution by platform is quite expected - <b>Android is</b> ahead of <b>iOS</b> by a significant margin, then comes the <b>Mobile Web</b> .  Were perhaps surprised that the answers about desktop applications for Windows in the last survey, but some combines allow testing mobile and desktop applications at the same time. <br><br>  Having dealt with the popularity of tools, we turn to a comparison of the most significant.  For each type, a comparative table of the capabilities of the tools that relate to it is first given.  I tried to collect the most relevant and reliable information about each instrument, but could miss something.  So if you suddenly find an error in the description, be sure to write about it in the comments. <br><a name="compare"></a><br><h2>  Tool comparison </h2><a name="drivers"></a><br><h3>  Drivers </h3><br><img src="https://habrastorage.org/webt/fe/vc/cl/fevccl-zh9foubtvni84jryomto.jpeg"><br><br>  In mobile testing, drivers are few and often they are developed by the same companies as operating systems.  For Android, there are two official drivers: <b>UIAutomator</b> , which <b>currently</b> has version 2.0, and <b>Espresso</b> .  Both are part of the Android Testing Support Library, developed by Google and well documented.  In addition to them, there are projects <b>Robotium</b> and <b>Selendroid</b> , which are developed by third-party companies.  All four products somehow work on the Android Instrumentation Framework - the basic API that Android provides for interacting with the system. <br><br>  First, let's look at the drivers from Google.  Both tools can work with WebView and hybrid applications, both support development in Java and Kotlin and work with emulators as well as with real devices. <br><a name="uiautomator"></a><br><h3>  Uiautomator </h3><br>  UIAutomator supports Android versions starting from API level 18 (Android 4.3).  It does not require the implementation of its code in the project, that is, it can interact with already compiled applications.  Moreover, when working with UIAutomator, you can use the full capabilities of the Android system: for example, turn on geolocation, call the system application, turn the device, click the Home button, or take a screenshot.  Therefore, this tool is often used for functional end-to-end testing, either alone or with add-ins. <br><br>  UIAutomator does not have its own recorder for tests, but there is a utility UI Automator Viewer that allows you to get data about the elements of the application running on the emulator or the real device and shows the locators of these elements.  The hierarchical structure of all elements is displayed here, which is very convenient for using them in tests. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ch/1k/jz/ch1kjzfdqxxki0soppmk805qopc.png" width="450"></div><br><a name="espresso"></a><br><h3>  Espresso </h3><br>  Espresso, in turn, was intended more for white-box testing and was created as a tool for developers.  It supports older APIs starting at API level 10 (Android 2.3.3), but requires access to the source code to run.  Accordingly, Espresso cannot work independently with other applications and the Android system.  But this tool has a recorder with which you can record simple scripts and use them at the initial stage of automation. <br><br>  In general, if you want to test only the application, without taking into account its interaction with the system, and there is a desire and opportunity to work with the sources, it is better to use Espresso.  In addition, it implements useful functions like automatic synchronization of tests with the application's UI, and you can not write various wait-commands. <br><br>  If you need to test the application in conjunction with others or with system functions, and there is only access to .apk, choose UIAutomator. <br><br>  By the way, these tools can be used together, because they are parts of the same library.  Even in one test, you can combine the commands of both instruments. <br><a name="selendroid_robotium"></a><br><h3>  Selendroid and robotium </h3><br>  Both Selendroid and Robotium were released before the official drivers appeared and still exist. <br><br>  Robotium supports Android API versions starting from API level 8 and can work with WebView starting from API level 15. Selendroid works with a limited list of API versions - from 10 to 19. Both tools can access only one application, do not require access to the source code and support work on emulators and real devices.  For Robotium, tests need to be written in Java, and Selendroid supports the WebDriver protocol, which makes it possible to use almost any popular programming language. <br><br>  Selendroid has the Inspector utility, with which you can view a hierarchy of elements and record simple record-and-playback-tests.  And Robotium provides the Robotium Recorder plugin for IntelliJ IDEA and Android Studio with similar functionality. <br><br>  In general, these tools are developing much less actively than the drivers from Google, and their audience is much narrower.  Nevertheless, from the survey results it can be seen that some companies still use them. <br><a name="xcuitest"></a><br><h3>  Xcuitest </h3><br>  In iOS, the UIAutomation driver was used for interaction with the application for a long time (which, among other things, caused confusion due to the similarity with the name of the Android driver), but since iOS 10 Apple stopped supporting this driver, and the XCUITest driver from the XCTest package appeared instead. <br><br>  It supports iOS since version 9.0, and tests for it are written in Objective-C and Swift, like the applications themselves.  To test an application, you do not need access to its code, and starting from Xcode 9, the driver can test several applications, including system ones, at the same time.  ‚ÄúOut of the box‚Äù XCUITest allows you to run tests only on simulators, but with the help of some third-party utilities, you can get it to work with real devices. <br><br>  XCUITest has its own recorder built right into the Xcode interface.  With it, you can record simple UI tests, as well as find UI elements and their properties. <br><br><img src="https://habrastorage.org/webt/mf/da/xz/mfdaxzqitl7pisin9pwafqho5ku.png"><br><a name="wrappers"></a><br><h2>  Add-ons </h2><br><img src="https://habrastorage.org/webt/fu/wm/bq/fuwmbqmgxhjpsgh-fubqsqpv58e.jpeg"><br><a name="appium"></a><br><h3>  Appium </h3><br>  Appium is the most famous add-on today.  It allows you to test applications almost regardless of platform, type and version of the system.  Of course, this approach has several significant advantages and disadvantages. <br><br>  Appium supports many drivers, not only mobile: <br><ul><li>  iOS <br><ul><li>  Xcuitest </li><li>  (deprecated) UIAutomation </li></ul></li><li>  Android <br><ul><li>  (beta) espresso </li><li>  UIAutomator 2.0 </li><li>  (deprecated) UIAutomator </li><li>  (deprecated) Selendroid </li></ul></li><li>  Windows Driver (for desktop Windows applications) </li><li>  Mac Driver (for desktop Mac applications) </li></ul><br>  Support for such a variety of drivers is implemented in a rather interesting way: Appium uses the version of the WebDriver interface, which everyone knows from Selenium WebDriver.  And, in addition to the large number of supported platforms, this approach has other advantages: <br><br><ul><li>  the ability to write tests in any language that supports WebDriver (and this list includes almost all popular programming languages).  Moreover, it allows to ‚Äúuntie‚Äù the tests from using the ‚Äúnative‚Äù languages ‚Äã‚Äãfor the application.  This is most relevant for iOS, because tests for XCUITest can only be written in Xcode.  With Appium, in this case, you can use any language and any convenient development environment; </li><li>  Easy transition to testing of hybrid and web applications: the WebDriver protocol has already (almost) become a standard for web automation; </li><li>  use of any test framework - almost all of them can somehow work with the WebDriver protocol, which means that they will not have problems connecting to Appium; </li><li>  No need to add something to the application code ‚Äî for each platform, drivers are used that do not need access to the code.  In addition to ease of deployment, this means the ability to test exactly the build of the application that users will see, and not a special test build. </li></ul><br>  We are more interested in mobile application support, so let's dwell on the implementations of the UIAutomator 2.0, Selendroid and XCUITest drivers. <br><br>  The simplest of them is UIAutomator 2.0, with which Appium interacts directly, passing the necessary commands to it.  It works with versions of Android 5.0 and higher.  From 4.2 to 5.0, you can use UIAutomator 1, and the interaction with older versions is provided by the Selendroid driver already known to us.  To interact with XCUITest and work around some restrictions, use WebDriverAgent (WDA) from Facebook.  WDA runs in the context of a simulator or a real device and passes commands through the API XCUITest. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0u/no/ra/0unoraemmx92b9h5nddyj3ppme8.png" width="450"></div><br><br>  Appium's disadvantages stem from its merits: <br><ul><li>  tests break more often than those written for native drivers, because of errors in the code of the add-in itself.  This is especially true for iOS, because WDA is added there; </li><li>  Appium does not know how to find and compare pictures in applications and cannot directly work with alerts on Android; </li><li>  limited support for the Android API &lt;17, but this may be fixed by connecting Espresso as a driver. </li><li>  Nevertheless, the Appium add-on is very popular and is actively developing, so many problems can be solved by the community in the future. </li></ul><a name="wda"></a><br><h3>  WebDriverAgent </h3><br>  Go to the WebDriverAgent add-in, which Appium uses to work with iOS.  In fact, this is the implementation of the server side of the WebDriver protocol, which allows you to manage devices on iOS.  Moreover, the functionality available is quite extensive: you can start and stop applications, use gestures and check the visibility of elements on the screen. <br><br>  The add-in works with simulators as well as with real devices.  For the detection of elements there is an inspector interface that opens in the browser.  The add-in itself is supported by the Facebook and Appium teams and is actively developing.  However, it can also be used separately from Appium, if for some reason the latter does not suit you. <br><a name="calabash"></a><br><h3>  Calabash </h3><br>  The next most popular add-on is Calabash for Android and iOS.  The tool was developed by Xamarin, but it stopped supporting it in 2017, and now it is supported only by the community. <br><br>  Each OS has its own add-on - Calabash iOS or Calabash Android.  Both support WebView testing and Ruby / JRuby languages.  Calabash Android does not need access to the application sources, but Calabash iOS will need to be connected to the Calabash framework application code.  Also, to work with the view outside the native iOS-application, an additional tool is used - DeviceAgent, which allows you to detect these views and interact with them.  Theoretically, this means that you can test and WebView, but in practice it is better to limit those views that iOS produces for your application: various overlays for confirmation, sending emails and inserting photos.  Calabash Android supports work with WebView, but on a rather limited scale: tap, text input, alerts. <br><br>  In general, Calabash is a fairly stable and fast tool that has useful functions to bring the application to the desired state (backdoors) and ‚Äúout of the box‚Äù that supports integration with Cucumber.  But due to the lack of official support, there may be problems when using it, and the community cannot guarantee their quick resolution. <br><a name="earlgrey"></a><br><h3>  Earl gray </h3><br>  Earl Gray is a kind of Espresso implementation for iOS, and it was also developed by Google.  Everything here is standard for iOS add-ons: it must be added to the project in Xcode, tests can be written only in Objective-C and Swift, the application can be tested only one thing - it does not see external views.  But testing is supported on real devices.  By itself, the add-in is interesting, maintained more or less regularly, but for some reason it is not popular with testers. <br><a name="frameworks"></a><br><h3>  Frameworks </h3><br><img src="https://habrastorage.org/webt/ez/kk/9n/ezkk9nf8t-fasljr12tkj_nxzxm.jpeg"><br><br>  The frameworks are least connected with testing mobile devices - they work with tests and integrate with any drivers and add-ins.  Therefore, I will not consider them in detail (hundreds of materials on the Internet are devoted to this), but I will only make a superficial comparison. <br><a name="xunit"></a><br><h3>  xUnit and TestNG </h3><br>  The most popular xUnit frameworks.  They were created as unit-testing tools, and the first such service was JUnit.  At the same time, they can work not only with unit tests, but also with any others.  Due to its versatility, xUnit frameworks are used everywhere and dominate web application testing.  JUnit works only with Java, but now there are implementations of such frameworks for almost any popular programming language. <br><br>  The TestNG framework, in which there are more various auxiliary functions, differs from this group somewhat. <br><a name="cucumber"></a><br><h3>  Cucumber </h3><br>  Also popular are BDD frameworks, especially Cucumber.  Unlike xUnit and TestNG, here tests and their steps are formed on the basis of documentation and are written in Gherkin, a language close to natural.  I‚Äôll clarify that Cucumber is still focused on acceptance testing, and it‚Äôs quite difficult to implement functional testing automation. <br><a name="combines"></a><br><h3>  Combines </h3><br><img src="https://habrastorage.org/webt/bq/ti/lo/bqtilortidbllcpw_e0_po1yezo.jpeg"><br><a name="xamarin"></a><br><h3>  Xamarin </h3><br>  Xamarin is a service for mobile application development and testing, which has its own farm with mobile devices and tools for test automation, including on these farms.  Development is conducted mainly in C #, there is a personal recorder. <br><a name="ranorex"></a><br><h3>  Ranorex </h3><br>  Ranorex is a tool for automating almost any application.  Able to integrate with Selenium, test mobile applications on emulators and real devices.  Available only for Windows, using C # and VB.NET as a language for tests.  Also has a recorder for tests. <br><a name="squish"></a><br><h3>  Squish </h3><br>  Squish - also knows how to automate web, mobile and desktop applications, supports BDD, has its own recorder and IDE.  You can use Python, Perl, JavaScript, Tcl, or Ruby to write tests. <br><br>  The main advantage of such solutions is a complete testing cycle;  there is no need to configure separate utilities and their interaction.  However, all these tools are paid, often with closed code and rarely used for testing mobile applications.  Therefore, I definitely cannot recommend them. <br><a name="conclusion"></a><br><h2>  Conclusion </h2><br>  This, of course, is far from a complete list of possible functional testing tools for mobile applications.  KIF, Frank, SilkMobile, TestComplete and many other utilities were left out of this article.  The article was conceived as a guide to the main tools, and I hope that it will help someone to understand the auto-testing stack of mobile applications and not to be mistaken in the choice of services.  If you have something to add on the topic, write to the comments, I will definitely read them and add some interesting things to the article. <br><br>  For your convenience, I placed all the tools in one table and made a list of useful links - these materials can be found in the ‚ÄúCheat sheets‚Äù section below. <br><a name="credits"></a><br><h2>  Thanks </h2><br>  Many thanks to the whole Badoo team for their help in preparing and reviewing the article, you are great!  Special thanks - <a href="https://habrahabr.ru/users/z3us/" class="user_link">z3us</a> , <a href="https://habrahabr.ru/users/nizkopal/" class="user_link">nizkopal</a> and Viktor Karanevich. <br><a name="hints"></a><br><h2>  Cribs </h2><br><br><img src="https://habrastorage.org/webt/ol/q0/ma/olq0mag9u4gp9ctlpb6myyvierk.jpeg"><br><br><img src="https://habrastorage.org/webt/2q/z5/aw/2qz5awyb5mbn8pfwzl3bq_pab5w.jpeg"><br><br><img src="https://habrastorage.org/webt/jd/81/rf/jd81rfaudxsmdsxpf-m_yau0qfm.png"><a name="links"></a><br><br><h2>  useful links </h2><br>  <a href="https://www.youtube.com/watch%3Fv%3Da9U4yzs26HU">Podcast with the exchange of experience in automating mobile application testing</a> <br>  <a href="http://arsbatyrov.ru/courses/apps-automation">Automation course</a> for which everything was started <br>  UIAutomator 2.0: <br>  <a href="">github.com/appium/appium/blob/master/docs/en/drivers/android-uiautomator2.md</a> <br>  <a href="https://bitbar.com/how-to-get-started-with-ui-automator-2-0/">bitbar.com/how-to-get-started-with-ui-automator-2-0</a> <br>  <a href="https://developer.android.com/training/testing/ui-testing/uiautomator-testing.html">developer.android.com/training/testing/ui-testing/uiautomator-testing.html</a> <br>  XCUITest: <br>  <a href="">github.com/appium/appium/blob/master/docs/en/drivers/ios-xcuitest.md</a> <br>  <a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/09-ui_testing.html">developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/09-ui_testing.html</a> <br>  Espresso: <br>  <a href="https://developer.android.com/training/testing/espresso/index.html">developer.android.com/training/testing/espresso/index.html</a> <br>  <a href="https://developer.android.com/training/testing/ui-testing/espresso-testing.html">developer.android.com/training/testing/ui-testing/espresso-testing.html</a> <br>  Robotium: <br>  <a href="https://github.com/RobotiumTech/robotium">github.com/RobotiumTech/robotium</a> <br>  <a href="https://github.com/RobotiumTech/robotium/wiki/Questions-%26-Answers">github.com/RobotiumTech/robotium/wiki/Questions-&amp;-Answers</a> <br>  Selendroid: <br>  <a href="http://selendroid.io/setup.html">selendroid.io/setup.html</a> <br>  <a href="http://selendroid.io/faq.html">selendroid.io/faq.html</a> <br>  Calabash iOS: <br>  <a href="https://github.com/calabash/calabash-ios">github.com/calabash/calabash-ios</a> <br>  <a href="https://github.com/calabash/calabash-ios/wiki/DeviceAgent">github.com/calabash/calabash-ios/wiki/DeviceAgent</a> <br>  Calabash Android: <br>  <a href="https://badoo.com/techblog/blog/2017/01/24/break-limitations-with-calabash-android/">badoo.com/techblog/blog/2017/01/24/break-limitations-with-calabash-android</a> <br>  Earl Gray: <br>  <a href="https://github.com/google/EarlGrey">github.com/google/EarlGrey</a> <br>  <a href="https://bitbar.com/how-to-get-started-with-earlgrey-ios-functional-ui-testing-framework/">bitbar.com/how-to-get-started-with-earlgrey-ios-functional-ui-testing-framework</a> <br>  Appium: <br>  <a href="http://appium.io/introduction.html">appium.io/introduction.html</a> <br>  <a href="https://github.com/appium/appium">github.com/appium/appium</a> <br>  WebDriverAgent <br>  <a href="https://github.com/facebook/webdriveragent">github.com/facebook/webdriveragent</a> <br>  <a href="https://www.mutuallyhuman.com/blog/2017/04/20/webdriveragent-getting-started-with-automated-ios-testing">www.mutuallyhuman.com/blog/2017/04/20/webdriveragent-getting-started-with-automated-ios-testing</a> <br>  Cucumber: <br>  <a href="https://cucumber.io/">cucumber.io</a> <br>  xUnit <br>  <a href="http://junit.org/junit5/">junit.org/junit5</a> <br>  Testng <br>  <a href="http://testng.org/doc/">testng.org/doc</a> <br>  Xamarin.UITest: <br>  <a href="https://developer.xamarin.com/guides/testcloud/uitest/">developer.xamarin.com/guides/testcloud/uitest</a> <br>  <a href="https://developer.xamarin.com/guides/testcloud/uitest/intro-to-uitest/">developer.xamarin.com/guides/testcloud/uitest/intro-to-uitest</a> <br>  <a href="https://developer.xamarin.com/guides/testcloud/introduction-to-test-cloud/">developer.xamarin.com/guides/testcloud/introduction-to-test-cloud/#The_Anatomy_of_the_Test_Cloud_Framework</a> <br>  Squish: <br>  <a href="https://doc.froglogic.com/squish/6.0/tutorials-iphone.html">doc.froglogic.com/squish/6.0/tutorials-iphone.html</a> <br>  <a href="https://doc.froglogic.com/squish/6.0/tutorials-android.html">doc.froglogic.com/squish/6.0/tutorials-android.html</a> <br>  Ranorex: <br>  <a href="https://www.ranorex.com/help/latest/android-testing">www.ranorex.com/help/latest/android-testing</a> <br>  <a href="https://www.ranorex.com/help/latest/android-testing/automation-of-system-apps">www.ranorex.com/help/latest/android-testing/automation-of-system-apps</a> <br>  <a href="https://www.ranorex.com/help/latest/ios-testing">www.ranorex.com/help/latest/ios-testing</a> </div><p>Source: <a href="https://habr.com/ru/post/347986/">https://habr.com/ru/post/347986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347976/index.html">Fire, water and copper pipes: how we created the new ATOL Opol POS-terminal</a></li>
<li><a href="../347978/index.html">HFT company fined $ 5.7 million accused its own traders of violations</a></li>
<li><a href="../347980/index.html">Is it possible to use C ++ instead of C for small projects in microcontrollers?</a></li>
<li><a href="../347982/index.html">Event digest for HR specialists in IT-field for February 2018</a></li>
<li><a href="../347984/index.html">From prototype to production on Kickstarter: $ 100,000 is not enough</a></li>
<li><a href="../347988/index.html">Open lesson on the topic "Areas of knowledge of marketing and TV + Search"</a></li>
<li><a href="../347990/index.html">In a section: the news aggregator on Android with backend. Distributed Message Processing Systems (Spark, Storm)</a></li>
<li><a href="../347992/index.html">False alarms. New technique of catching two birds with one stone</a></li>
<li><a href="../347994/index.html">UX research and evidence strength</a></li>
<li><a href="../347996/index.html">Parsing sites or long-term construction of the Moscow region</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>