<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automata programming. Part 3. State and transition diagram. Continuation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The previous article dealt with the psychological aspects of describing dynamic processes with the help of a state diagram and transitions (that is, i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automata programming. Part 3. State and transition diagram. Continuation</h1><div class="post__text post__text-html js-mediator-article">  <i><a href="https://habrahabr.ru/post/332508/">The previous article</a> dealt with the psychological aspects of describing dynamic processes with the help of a state diagram and transitions (that is, in the automaton style) and that the state diagram and transitions give a better understanding of the dynamic process.</i>  <i>Today I will continue to review the state diagram, which embodies the automaton approach, and the ways of its implementation in the code.</i>  <i>The topic of the previous article organically flows into today's material, so I recommend to get acquainted with it.</i> <br><a name="habracut"></a><br><p>  <a href="https://habrahabr.ru/post/331556/">Table of contents</a> <br><br></p><h2>  State diagram! = Graph diagram. </h2><br>  As already mentioned, the state diagram is an alternative, more convenient form of recording software algorithms.  Moreover, a state diagram is a natural form of recording a dynamic process, while an algorithmic graph-diagram is an artificial construction that already contains implementation features that are obvious and do not require that they be specified separately, or impair understanding in general. although technically correctly describe the sequence of required actions. <br><br>  But the state diagram is not just another graphical notation of a graph diagram entry, it has some excellent features.  Figure 1 (b, c) shows the state diagrams of the same automaton corresponding to the initial graph-scheme of the article fig.  1 (a). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/mm/cr/lr/mmcrlrmp6nlayggzc-uidzxlxzk.png" alt="image"></div><br>  <i>Figure 1 a).</i>  <i>Original graph diagram</i> <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ko/wz/yk/kowzykqn83kdfwgb5kmnt_zwuye.png" alt="image"></div><br>  <i>Figure 1 b), c).</i>  <i>State diagrams of equivalent automata implementing the algorithm</i> <i><br></i>  <i>(but).</i> <br><br><p>  Figure 1 (c) shows an example of incorrect recording of a state diagram and transitions.  The incorrectness is that the transitions highlighted by the red rectangle are determined not only by the input events, but also additionally by the flag with, which for this state corresponds to the flag of the original graph diagram of fig.  1 (a), because of which it is no longer possible to monitor the state of the process, considering only the input symbols, you need to somehow take into account the logic of changing the flag c.  The problem is not even in the flag itself, but in the fact that the logic of changing this flag is not tied to the state s1 alone.  If events connected with the change of this flag would be associated only with s1, such a problem would not exist.  The transitions highlighted in red depend on the <i>way they hit s1</i> , which contradicts the definition of the automaton, according to which the reaction depends only on the input symbol and the current state.  Let's call this the principle of automatism, to refer to it further in the text. <br><br></p><p>  Graph diagram of a pronounced non-automatic implementation of the algorithm in fig.  1 (a) is not so easy to write in the form of a correct state diagram, since states are not clearly defined, and, accordingly, transitions between them are not determined.  To chart the figure  1 (b) according to the algorithm of fig.  1 (a) it took to get an <b>equivalent automaton</b> .  The method of obtaining equivalent automata for any graph-scheme will be the subject of consideration in one of the following articles. Now I will confine myself to stating that this <i>can be done in principle</i> , because any digital device, including any non-automatic program, is a digital automatic machine that <i>has states in the mathematical sense</i> , despite the fact that these states are not explicitly described.  Such states are similar to quantum photons in quantum electrodynamics, they can be simplifiedly described: they are everywhere and nowhere specifically, but they exist and act. <br><br></p><p>  In this example, due to randomness, each branch of the graph scheme corresponds to one state.  In other words, each output symbol is obtained in only one state.  However, if the logic of changing flags is different, it would turn out that one output symbol is obtained in several different states, or, to put it another way, the same branch of the graph scheme corresponds to several different states.  This is an even more difficult case in terms of understanding. <br><br></p><p>  Since we are talking about states, a completely natural question arises: "How many states will you have to deal with?"  In the case of an automaton implementation, we set the number of states to some extent arbitrarily, based on needs. <br><br></p><p>  In the case of a non-automatic approach, the number of potential states of an equivalent automaton is equal to: <br></p><p><math> </math> $$ display $$ 2 ^ \ text {total_size_in all_variables_determining_behavior, bit.  } $$ display $$ </p><br>  That is, adding even one variable defining behavior, such as <b>bool,</b> will double the number of ‚Äústructural‚Äù ones, I will conditionally call them ‚Äúcircuit-specific possible‚Äù states.  Many of these states are unattainable states.  All unreachable states are excluded automatically, by a specially selected logic of actions on variables defining behavior and it is assumed that these actions, superimposing one on the other, will produce the desired result.  From the point of view of psychology, <a href="https://habrahabr.ru/post/332508/">let me remind you</a> , this is a dynamic process as a sequence of multidirectional actions giving as a result the desired result.  As mentioned earlier, a very complex form to understand.  A good analogy of the difference between the automaton description (state diagram) and the algorithmic description (graph diagram) of a dynamic process can be the study instead of the graph of the function graph of its derivative. <br><br><p>  In the case when there are few variables defining behavior, the complexity of the algorithmic description is not so noticeable, but with an increase in the number of such variables, the complexity of perception of the algorithm grows exponentially and depresses the psyche. <br><br></p><p>  The term <b>Variable Defining Behavior</b> should be clarified.  In the case of a manual implementation, this is in fact any variable that creates a branch of the algorithm.  In the case of an automaton implementation, this is the variable <b>Internal state</b> .  As a variable, the <i>Internal state</i> can be an enumeration type variable, where all states are listed (= just int), or even just a bool variable if there are only two states.  Next, I will demonstrate different versions of software implementations of automata. <br><br></p><p>  As already mentioned at the beginning of the article, the graph diagram is not only a form of recording an automaton, but also a form of recording a conventional algorithm.  The fact that the conditional transition operation is depicted by the transition arrow, I think, is not surprising, but how to depict the cycle?  Suppose our machine enumerates a rectangular table, that is, the total number of combinations of variables of the vertical and horizontal cycles is <b>m * n</b> .  Does it mean that the resulting automaton will have as many states, or in other words how to write a cycle in automaton style? <br><br>  Consider the cycle: <br><br></p><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">5</span></span>; i--; ){}</code> </pre> <br>  From the point of view of the <i>condition of this cycle, the</i> value of the counter 5,4,3,2,1 is the same value.  Yes, inside the body of the cycle i is a parameter, the program's behavior is different for different values ‚Äã‚Äãof this parameter, but from the point of view of the mode of the for loop, the variable counter can take two values ‚Äã‚Äã0 and not 0. The variable i is a pseudoflag variable so to speak. <br>  Returning to the table traversal machine, I note that this machine has two states and two pseudoflag variables: <br><br><ul><li>  <i>horizontal cycle counter</i> , determines the state: <br>  {0} - vertical cycle, <br>  {1, ..., 5, ...} - Horizontal cycle, </li><li>  <i>The vertical loop counter</i> determines the end-of-work condition. </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/pd/io/_i/pdio_igtsrq59tckcbrb1nnosp0.png" alt="image"></div><br>  <i>Figure 2. Recording nested loops using a state diagram.</i> <br><br>  The Out_text automaton <a href="https://habrahabr.ru/post/331556/">from the example in the ‚ÄúIntroduction‚Äù</a> shown in fig.  3 is of interest from the point of view of events causing a change in the state of the automaton. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/fi/ht/rp/fihtrptndgnb7uudj9oeld8x1zc.png" alt="image"></div><br>  <i>Figure 3. ‚ÄúAutomatic display of text blocks‚Äù, state diagram.</i> <br><br><p>  The only event that can be considered as external is the end of the line, all other events of this automaton are purely internal, they are generated by the operation of the algorithm itself.  However, this does not violate the principle of automatism, discussed above, because all events affecting the transition from a certain state are generated by the same state itself, that is, the behavior of the automaton does not depend on the way we got into this state. <br><br></p><p>  An automatically implemented program can be represented as a graph diagram, and it will remain automatically realized.  In fig.  4. shows an example of a graph diagram corresponding to the state diagram and transitions given at the beginning of the article <br><br></p><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/4t/cp/fs/4tcpfsxi9tx0lmfkoz2xbg99dv0.png" alt="image"></div><br>  <i>Figure 4. Graphic diagram corresponding to the automaton described by fig.</i>  <i>1 (b)</i> <br><br><p>  As you can see, when recording auto-implemented programs, the graph-diagram noticeably loses to the state diagram in terms of compactness. <br>  Now consider what distinguishes automaton programming from automaton circuitry. <br><br></p><h2>  Artifacts of automatic circuitry. </h2><br><p>  To better understand what is being said, we introduce two categories of software automata - symbolic and functional.  Symbolic automata are automata that accept a sequence of characters at the input and produce a sequence of characters at the output.  This is a complete analog of classic <i>abstract automata</i> , automata which discrete mathematics itself actually considers.  Symbolic automata are used to recognize codes, parse regular expressions, linguistic analysis, as well as to optimize functional automata, and algorithms in general.  We will touch on ways to implement them further in today's article, and discuss in detail in one of the following articles. <br><br>  These automata are opposed to functional software automata, (I will call them in the text programs) - a complete analog of the application and control programs of a computer or microcontroller.  These are the same modules, subroutines that control the microcontroller periphery, or perform some useful work, or implement interactive work with the user, but they are designed and implemented automatically. <br><br>  In automaton circuitry, the next stage after the development of an abstract automaton is structural synthesis, when abstract signals and states are encoded with ‚Äúlive‚Äù bits, coding methods are selected, and a logic circuit is built that works with already coded bits.  Functional software machines is a software analogue of structural machines. <br><br></p><p>  If we consider the functional automata solely from the standpoint of circuit design, and do not see anything more than structural automata in them, then such a narrow view rather hinders.  This approach, which is a tracing paper from the automatic circuitry, provides a template for how the automatically designed module should be arranged. <br><br></p><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/-r/kn/51/-rkn516r31bmdzirdv7tepuygsi.jpeg" alt="image"></div><br>  <i>Figure 5. The generally accepted pattern of implementations of software automata</i> <br><br><p>  This leads to the fact that the design process becomes cumbersome, including not necessary in most cases, the formal steps prescribed by this template. <br>  But not turning real-life processes into a set of formalized signals or using some ‚Äúautomaton‚Äù API gives an advantage to automaton programming.  The advantage is given by the recording of the dynamic process in the categories of the state diagram; this makes programming more predictable.  Proper partitioning of the automaton into the operational and control automata, and as part of this subdivision is the correct, reasonable choice of the operational automaton, this is what makes the solution effective, and in the next article it will be convincingly shown. <br><br></p><p>  Mechanical copying of the behavior of the developer of circuit automatons, that's what I meant by the word artifacts that automaton programming gets rid of when leaving the automaton circuitry cradle, we are dealing with a program.  The program is extremely comfortable and plastic material, and it is the plasticity of this material that made it so popular.  By programming in the usual way, we are free from the routine of designing digital circuits.  When we need to perform an action, we check the condition and execute it, and there is no need to write a special trigger function.  What am I talking about?  You can write this: <br><br><a name="Example_simple_and_tricky"></a><br></p><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IO_latch-&gt;Data_1_received &amp;&amp; IO_latch-&gt;Permission) { State = <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre><br>  and so can <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paTrigger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tLink_Trigger_Action</span></span></span><span class="hljs-class"> {</span></span> paTrigger * Trigger; paAction * Action; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Next_state; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trigger_X</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(IO_latch-&gt;Data_1_received &amp;&amp; IO_latch-&gt;Permission);}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action_X</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{State = <span class="hljs-number"><span class="hljs-number">5</span></span>;}; tLink_Trigger_Transition Table[States_max][ Triggers_max] = { <span class="hljs-comment"><span class="hljs-comment">/*State_0*/</span></span>{}, <span class="hljs-comment"><span class="hljs-comment">/*State_1*/</span></span>{ ‚Ä¶,{ Trigger_X, Action_X }, ‚Ä¶ }, <span class="hljs-comment"><span class="hljs-comment">/*State_2*/</span></span>{}, <span class="hljs-comment"><span class="hljs-comment">/*State_3*/</span></span>{}, <span class="hljs-comment"><span class="hljs-comment">/*State_4*/</span></span>{}}; <span class="hljs-function"><span class="hljs-function">uint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Engine</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint Message)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(State-&gt;Trigger()) { State-&gt;Action(); State = State-&gt;Next_state; } ‚Ä¶ }</code> </pre> <br>  feel the difference? <br><br><p>  The only thing that supporters of superformalism can argue is that with ordinary programming, there is less accounting, with the automatic-engineering method all bits are counted.  To this, I will answer that if there is a problem with taking into account some parameter, it is worthwhile to create a submachine that will do the accounting, and to release the main machine from the routine.  This is a advice on constructive decomposition. <br><br></p><p>  The drama of the situation associated with programmatic programs lies in the fact that the automaton mental template, giving a convenient tool for modeling and analyzing dynamic processes, simultaneously dominates the developers with a heavy hand, depriving them of the simple pleasures of ordinary programming.  This, in my opinion, is one of the most serious reasons why the automatic programming technology cannot rise higher than the exotic wonder. <br><br></p><p>  As it is easy to guess, the natural way to overcome this contradictory situation is to take the best from both paradigms.  In this case, the internal state becomes not so much an indication of how to handle the next incoming event, but it becomes a certain mode of operation.  It is important.  The state of rather should be considered as a subroutine in which the algorithm is located for some time.  At the same time, it can process input signals, broadcast them on weekends, without going anywhere.  It is implied that in one state the programmer performs the same type of work, everything that goes beyond the uniformity is transferred to another state.  The transition from state to state is not made by any signal, but only by events that are significant for this algorithm.  And we choose these events ourselves, based on the states we have chosen.  And accordingly, each state-mode may contain nested programs. <br><br></p><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/p3/2u/av/p32uavjg6g4jpgm_10grybkf5js.png" alt="image"></div><br>  <i>Figure 6. Constructive pattern in which the <i>state</i> is the <i>mode of operation</i> .</i> <i><br></i> <br>  But the programmer is not exclusively in function-mode until it has made the transition.  He performs short iterations during which he controls the situation.  At the same time, the application as a whole looks like: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/sr/ff/wu/srffwucx1il85r_ynv2-ln-qirg.png" alt="image"></div><br>  <i>Figure 7. Programmers community.</i> <br><br><p>  That is, using programs, we come to the concept of <i>corporate multitasking</i> , only in contrast to the classical corporate multitasking algorithms, when a seemingly normal application itself appeals to the OS for some purpose and thus returns control of the system, the programs are initially designed as programs that take control only one step, execute it and transfer control back to the next iteration.  The difference between corporate multitasking and programmers is formally conditional, but the automatic look at the programs implies their iterative nature, so there are no such problems that the programmer ‚Äúforgets‚Äù to transfer control back. <br><br></p><p>  Programs can work without problems and under control of multi-threaded OS, as shown in Fig.  At the same time, of course, their corporate multitasking appears to be kind of not needed, but the automatic device of the module itself retains all the advantages discussed above related to automatic design. <br><br></p><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/aq/xi/0j/aqxi0jfuawmbzrv3yhv7aeklz_k.png" alt="image"></div><br>  <i>Figure 8. Programs in a multithreaded environment.</i> <br><br><p>  Since the programmer can perform one-time actions that occur when a transition is made, and can perform extended activities while in the same state ‚Äî an operation mode ‚Äî its state diagram acquires the features of both Mili‚Äôs automata and Moore‚Äôs automata.  For example, an automatic parking meter, described by a state diagram. <br><br></p><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/hw/f6/bt/hwf6btrspiag8d5gszq5we42294.png" alt="image"></div><br>  <i>Figure 9. The Parking Meter program, the description combines the features of Miles and Moore machines.</i> <br><br><p>  An example of a parking meter has not yet been considered, but looking at the state diagram one can easily understand what is being said.  Please note that the description of this counter by the state diagram is much more informative than the description of the same automaton made with the help of the text. <br><br></p><p>  From the point of view of the theory, I do not make an error, combining in one state diagram the features of Mili‚Äôs automata and Moore‚Äôs automata.  When it will be necessary to perform mathematical operations on such an automaton, it can be considered as a Miles automaton.  For abstract automata, with the same functional, the Mealy automaton can be obtained with a smaller number of states.  There are mathematical methods for converting Mealy automata to Moore‚Äôs automata and vice versa. <br><br></p><p>  Described sheds a little light on what are the programs, we turn to the methods of their implementation. <br><br></p><h2>  Ways to implement functional software machines. </h2><br>  Let's begin with the graph-scheme considered earlier, for convenience shown in fig.  ten. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/4t/cp/fs/4tcpfsxi9tx0lmfkoz2xbg99dv0.png" alt="image"></div><br>  <i>Figure 10. Graphic diagram to be implemented.</i> <br><br><p>  The most obvious solution that comes directly from the graph diagram to the forehead is to use the switch statement to determine the state of the construction of a multiple alternative of the C language.  Upon receipt of the next input symbol, the program determines the current state, and for each state, the input symbol is analyzed, and for each input symbol, not only a transition to a certain state, but also an output symbol is specified. <br><br></p><div class="spoiler">  <b class="spoiler_title">Option 1.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> mStep ((uword) (-2))</span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// .  uint Automaton (uint Input) { static uint State = 3; uint Out; {,     ,   }; switch (State) { //////////////////////////////////////////// case 1: switch (Input) { /////////// case 0: { ,   }; State = 2; Out = 2; break; /////////// case 1: { ,   }; State = 3; Out = 3; break; /////////// case 2: { ,   }; State = 6; Out = 6; break; /////////// case mStep: break; } break; //////////////////////////////////////////// case 2: ... //////////////////////////////////////////// case 3: ... //////////////////////////////////////////// case 4: ... //////////////////////////////////////////// case 5: ... //////////////////////////////////////////// case 6: ... default: // Error }; return(Out); }</span></span></span></span></code> </pre> <br></div></div><br><p>  Similar methods implemented automata in <a href="https://ru.wikipedia.org/wiki/Switch-%25D1%2582%25D0%25B5%25D1%2585%25D0%25BD%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D1%258F">Switch-technology</a> and in <a href="https://www.iar.com/iar-embedded-workbench/add-ons-and-integrations/visualstate">IAR visualState</a> . <br><br>  Since the concept of program states treats them as program modes in which it can function for some time without making transitions, but at the same time continuing its ‚Äúminor activities‚Äù, there must be an input symbol that does not guarantee the programmer to translate into a new state ( unless he goes on himself, for internal reasons), but he activates it every iteration.  Symbol pitch - <b>mStep</b> . <br><br>  The second embodiment, fundamentally different: make the handler for each event, as shown in the listing <br><br></p><div class="spoiler">  <b class="spoiler_title">Option 2.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">uint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Message_i0_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint &amp;State)</span></span></span><span class="hljs-function"> </span></span>{ uint Out; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (State) { <span class="hljs-comment"><span class="hljs-comment">//////////////////////////////////////////// case 1: { ,   }; State = 2; Out = 2; break; //////////////////////////////////////////// case 2: { ,   }; State = 1; Out = 1; break; ... }; return(Out); } uint Message_i1_handler(uint &amp;State) { ... } uint Message_i2_handler(uint &amp;State) { ... } void Message_Step_handler(uint &amp;State) { switch (State) { //////////////////////////////////////////// case 1: {,     ,   }; break; //////////////////////////////////////////// case 2: {,     ,   }; break; //////////////////////////////////////////// case 3: {,     ,   }; break; }; return(mStep); } typedef uint (*paMessage_handler)(uint &amp;State); paMessage_handler Reactions[3] = { Message_i0_handler_for_s1, Message_i1_handler_for_s1, Message_i2_handler_for_s1}; uint Automaton (uint Input) { Reactions [Input]; }</span></span></code> </pre> <br></div></div><br><p>  The above options are basic options that reflect the basic ideas, but they are rather cumbersome and slow.  However, they are modified without any problems in the direction of reducing the bulkiness (relative) and speeding up the work (real). <br><br>  Modify the code shown in the listing of Option 2. We <i>split</i> each <i>Message_ixx_handler</i> event <i>handler</i> into a set of functions corresponding to each state. <br><br></p><div class="spoiler">  <b class="spoiler_title">Option 3.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">uint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Message_i0_handler_for_s1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint &amp;State)</span></span></span><span class="hljs-function"> </span></span>{ { ,   }; State = <span class="hljs-number"><span class="hljs-number">2</span></span>; Out = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(Out); } <span class="hljs-function"><span class="hljs-function">uint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Message_i0_handler_for_s2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint &amp;State)</span></span></span><span class="hljs-function"> </span></span>{ { ,   }; State = <span class="hljs-number"><span class="hljs-number">1</span></span>; Out = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(Out); } ... <span class="hljs-function"><span class="hljs-function">uint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Message_Step_handler_for_s1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint &amp;State)</span></span></span><span class="hljs-function"> </span></span>{ {,     ,   }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(mStep); }</code> </pre> <br>  In total it is meant that <b>States * Messages</b> functions are needed, although a part can be repeated, moreover there can be only a few of them. <br><br>  If we now combine all the methods obtained into an array, the automaton will work from the root engine function, and the engine can be written as. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*paMessage_handler)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint &amp;State)</span></span></span></span>; paMessage_handler Reactions[<span class="hljs-number"><span class="hljs-number">6</span></span>][<span class="hljs-number"><span class="hljs-number">3</span></span>] = { { Message_i0_handler_for_s1, Message_i1_handler_for_s1, Message_i2_handler_for_s1}, ... { Message_i0_handler_for_s6, Message_i1_handler_for_s6, Message_i2_handler_for_s6}, }; paMessage_handler Reactions_for_Step [<span class="hljs-number"><span class="hljs-number">6</span></span>] = { Message_mStep_handler_for_s1, ..., Message_mStep_handler_for_s6 }; <span class="hljs-function"><span class="hljs-function">uint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Engine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint Input = mStep)</span></span></span><span class="hljs-function"> </span></span>{ uint State = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Input == mStep) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(Reactions_for_Step [State] (State)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(Reactions[State][Input] (State)); }</code> </pre> <br></div></div><br><p>  With this option, the scheme of dispatching events in interrupt handlers and their processing from a single engine is well implemented. <br><br>  A similar way underlies the implementation of the template <a href="http://doc.crossplatform.ru/boost/1.36.0/libs/statechart/doc/tutorial.pdf">boost.statechart.</a> <br><br></p><p>  The main disadvantage of the previous two options: they are artifacts of automatic circuitry, that is, programming in this way, it is impossible to preserve the ‚Äúprogramming style‚Äù of programming, you have to use a <a href="https://habr.com/ru/post/332664/">tabular programming style</a> that is excessively bloated. <br><br>  Consider what gives the tabular programming style: <br><br></p><ul><li>  "+" lists reactions to all events for each of the states (for unhandled events there are stubs), i.e.  There is a full description. </li><li>  "-" But at the same time, everything is so unwieldy that it is realized that the total probability of a typo is large, or the stub is not left there.  That is, we are not talking about improving reliability, despite the fact that automatic programming positions itself as a more reliable development method. </li></ul><br><p>  No wonder that IAR went the way of graphic programming of visualState automata, finding that the text-based auto-schematic style of programming is not for people. <br><br></p><p>  Much more beneficial in terms of possibilities for modification is the option shown in the listing of Option 1, if it is expanded with the accepted concept of state-modes of operation. <br><br></p><p>  Let the input handler for each state (external switch) be rendered into a separate function (function-mode). <br><br></p><div class="spoiler">  <b class="spoiler_title">Option 4.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">uint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State_1</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint &amp;State, uint Input)</span></span></span><span class="hljs-function"> </span></span>{ {,     ,   }; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Input) { <span class="hljs-comment"><span class="hljs-comment">/////////// case 0: { ,   }; State = 2; Out = 2; break; /////////// case 1: { ,   }; State = 3; Out = 3; break; /////////// case 2: { ,   }; State = 6; Out = 6; break; /////////// case mStep: //    }; uint State_2 (uint &amp;State, uint Input){...};</span></span></code> </pre> <br><br>  All newly functioned states-states are placed in an array, so that the state function can be specified by its index.  Then the variable Internal state is an index, a value of type <i>uint</i> , and the engine takes the form <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*paState)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint &amp;State, uint Input)</span></span></span></span>; paState States[<span class="hljs-number"><span class="hljs-number">6</span></span>] = { { State_1, ..., State_6}, }; <span class="hljs-function"><span class="hljs-function">uint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Engine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint Input = mStep)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> uint State = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(States [State] (State, Input)); }</code> </pre> <br></div></div><br><p>  With the apparent similarity with option 3, this is more consistent with the concept of the program as a set of alternating modes.  Each function-state is a function-mode, which itself polls all the peripherals it needs, or a synchronized frame of data from the periphery, and performs transitions based on this, and not only on the basis of the Input symbol. <br><br></p><p>  The Input symbol may contain system messages of the same type for all programmers.  This means, in particular, that the state-function itself can be written in the traditional, most familiar way. <br><br></p><p>  This option shows a higher speed compared to <i>option 1</i> , due to the fact that each value of the variable <i>Internal state is</i> uniquely associated with a function that processes this state, and the call of the state function is reduced to get a table cell that contains pointer to the desired function.  At the same time, with the implementation of <i>option 1</i> , the variable <i>Internal state is</i> repeatedly compared with the values ‚Äã‚Äãthat correspond to the state names. <br><br></p><p>  Although this option is faster, the amount of routine is not reduced.  The main disadvantage of this implementation is that you need to have both a state table and parallel accounting of states in the header and in the code file, and not copy / paste, so to speak, the problem of dual description.       .   .    ,       ,     ,       -: <br><br></p><div class="spoiler">  <b class="spoiler_title">Option 5.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*paState)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argState, uint Input)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">uint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State_1</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(paState * State, uint Input)</span></span></span><span class="hljs-function"> </span></span>{ {,     ,   }; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Input) { <span class="hljs-comment"><span class="hljs-comment">/////////// case 0: { ,   }; State = (paState*) State_2; Out = 2; break; /////////// case 1: { ,   }; State = (paState*) State_3; Out = 3; break; /////////// case 2: { ,   }; State = (paState*) State_6; Out = 6; break; /////////// case mStep: //    }; uint State_2 (paState *State, uint Input){...}; uint Engine(uint Input = mStep) { static paState *State = (paState*) State_3; return(State(State, Input)); }</span></span></code> </pre> <br></div></div><br>        ¬´¬ª .    ,  ,    <b>switch</b>         <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IO_latch-&gt;Data_1_received &amp;&amp; IO_latch-&gt;Permission) { State = <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre> <br>  ¬´¬ª      ,   -    . ,     -      <i> </i> .       ,       (  ‚Äî  ),   ,    : <i>   ,  , ,  </i> .  ,     ,       (  ‚Äî  ),          ,             ,   ¬´  ¬ª   . <br><br>   ¬´¬ª,      tDisplay::Out_text,  ¬´¬ª.       . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/s4/y9/9z/s4y99zthbxj1e8pempl3pntfufa.png" alt="image"></div><br> <i> 11.         </i> <br><br><a name="case_6"></a><br><div class="spoiler"> <b class="spoiler_title"> 6.    .</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bv/zk/87/bvzk87ikn08odh8n7usgzxmrmj4.png" alt="image"></div><br></div></div><br>     ,         .        goto,          ‚Äî   .          ‚Äî <b>   </b> .       . <br><br>                 goto __; <br><br>     ,            .       {},        (!).    .     ,      ,           goto.         .       ,         . <br><br><p>     ‚Äì     ,        ,      Stall.     ,           7, ,      .         ,      6.     ,    : <br><br></p><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*paState)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argState, uint Input)</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> mGoto(argState,argOut){\ State = (paState*)argState;\ return(argOut);\ } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> mStall_code ( (uword)(-1) ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> mStall(){\ return(mStall_code);\ } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   uint Engine(paState *State, uint Input = mStep) { return(State(State, Input)); }</span></span></span></span></code> </pre><br>   API      -   . <br><br>      ‚Äì     ,       . <br><br>       . <br><br><div class="spoiler"> <b class="spoiler_title"> 7</b> <div class="spoiler_text"><pre> <code class="cpp hljs">paState *Display_state; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tDisplay::Out_text (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arg_x0, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arg_y0, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arg_x1, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arg_y1, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arg_x_shift, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arg_y_shift, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * argText, TMemo * argDebug) { <span class="hljs-comment"><span class="hljs-comment">//  Display_state = (paState*) state__Inside_text_block; //  while(Engine (Display_state, 0) != mStall_code); return; }//void tDisplay::Out_text (int arg_x0, int arg_y0, //////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////// uint state__Inside_text_block(paState * State, uint Input) { if(Input == mForce_Out_text_block) mGoto(state__Out_text_block, 0); while(1) { switch(*Text_end) { case '\0': case '\n': mGoto(state__Out_text_block, 0); } Text_end++; } }// uint state__Inside_text_block(paState * State, uint Input) //////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////// uint state__Out_text_block(paState * State, uint Input) { if(Text != Text_end) { //    . Out_text_block(); //   Execute_script  Line_width     x_rel += Line_width; } //    Text = Text_end; mGoto(state__Control_processing, 0); }// uint state__Out_text_block(paState * State, uint Input) //////////////////////////////////////////////////////////////////////////// ////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////// uint state__Control_processing(paState * State, uint Input) { if(*Text_begin == 0) { mStall(); } //  esc  mGoto(state__Control_processing, 0); }</span></span></code> </pre><br></div></div><br>                ,   ¬´ ¬ª.       ,  ,       ,          .         .         .     Out_text  ,          ,      . <br><br><p>   API     .       4,      .        4. <br><br></p><div class="spoiler"> <b class="spoiler_title"> 8</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">uint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State_1</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(paState * State, uint Input)</span></span></span><span class="hljs-function"> </span></span>{ {,     ,   }; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Input) { <span class="hljs-comment"><span class="hljs-comment">/////////// case 0: { ,   }; mGoto(State_2,2); /////////// case 1: { ,   }; mGoto(State_3,3); /////////// case 2: { ,   }; mGoto(State_6,6); /////////// case mStep: //   . return (0); };</span></span></code> </pre> <br></div></div><br>  API    ,        . <br><br>      <b>  </b> .   ,         ,   . <br><br>     <i> </i>    -  static,   .      ,     - .            <b> </b> .   ,      ,   .      . <br><br><h2>     . </h2><br>       .    ,    ,       ,     ,       ,    .   ,       a,b,c,    1  ,    ,  0    . <br><br>    bacab.       .  12 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/wa/kb/ov/wakbov5qumwxfkyr1nau5ljm9ha.png" alt="image"></div><br> <i> 12.     bacab.</i> <br><br>            ,   ,      .      <br><br><pre> <code class="cpp hljs">uint FSM[States_amount][Alphabet_size];</code> </pre><br>       ,             .   ,       0  _ ‚Äì 1.   ‚Äì    .     0,    ¬´ ¬ª,      ,   ,   ,      ,  0, 1,2, ‚Ä¶    0xff..ff.        1,     0. <br><br>      ,  . <br><br><pre> <code class="cpp hljs">uint FSM[States_amount][Alphabet_size]; <span class="hljs-function"><span class="hljs-function">uint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Engine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint Input)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> uint State = <span class="hljs-number"><span class="hljs-number">0</span></span>; State = FSM[State][Index_for(Input)]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(State == (uint)(<span class="hljs-number"><span class="hljs-number">-1</span></span>)) { State = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//     while(!terminate) { if(Engine(Stream++)) goto Found; }; Stopped: //   ,    Found: //   }</span></span></code> </pre> <br>      .       <i> </i> .           . <br><br>     .        ‚Äì   ,   . </div><p>Source: <a href="https://habr.com/ru/post/332664/">https://habr.com/ru/post/332664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332654/index.html">Creating chatbot-a using sockeye (MXNet) based on AWS EC2 and AWS DeepLearning AMI</a></li>
<li><a href="../332656/index.html">What did the PR leaders do on the day of the meeting between Putin and Trump on the G20?</a></li>
<li><a href="../332658/index.html">Personal experience: as an IT specialist, move to work in the USA, relying only on himself</a></li>
<li><a href="../332660/index.html">Script for express recovery Excel files after damage</a></li>
<li><a href="../332662/index.html">Interview in SD podCast with Pavel Odintsov, author of FastNetMon, a tool for detecting and repelling DDoS attacks</a></li>
<li><a href="../332668/index.html">How to confuse analytics - 4. Probability and accuracy</a></li>
<li><a href="../332670/index.html">Smart IDReader SDK - add recognition to Android apps</a></li>
<li><a href="../332672/index.html">Google will soon cease to trust all certificates WoSign and StartCom</a></li>
<li><a href="../332674/index.html">Why I switched from React to Cycle.js</a></li>
<li><a href="../332676/index.html">3D mouse integration in Renga</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>