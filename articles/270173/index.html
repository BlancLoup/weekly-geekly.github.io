<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>AST analysis using patterns</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I'm currently working on senjin / gglsl , a library for programming shaders using Groovy, which I recently wrote about . 

 Here I will describe three...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>AST analysis using patterns</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/035/f21/f06/035f21f06a35443daf5c79281e8d3c1d.jpg" width="300" align="left"><br>  I'm currently working <a href="https://github.com/kravchik/senjin">on senjin / gglsl</a> , a library for programming shaders using Groovy, which I <a href="http://habrahabr.ru/post/269591/">recently wrote about</a> . <br><br>  Here I will describe three approaches to the analysis of AST (abstract syntax tree), all with examples of sub-tasks arising from one another and related to a common context: recursive functions, pattern Visitor, and pattern matching. <br>  Pattern matching is implemented in Java and <a href="https://github.com/kravchik/jcommon/wiki/pattern-matching">is available on GitHub</a> . <br><a name="habracut"></a><br><h2>  Recursive functions </h2><br>  <i><font color="grey">90% of the functionality is done in 1% of the time (or something like that)</font></i> <i><font color="grey"><br></font></i> <br>  At the first stage, it was enough for me to simply translate the Groovy code into glsl code.  For this, I used simple tree parsing functions that recursively call each other.  Each takes an AST node of a parsed Groovy as input and returns a line representing the translated code already on glsl.  This is quite enough.  languages ‚Äã‚Äãare very similar, in the process there is no need to accumulate any information, and in each node all necessary information is locally available. <br><br>  An example of the functions of translation of a binary expression and unary minus: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translateExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BinaryExpression e)</span></span></span><span class="hljs-function"> </span></span>{ def opName = e.operation.getText() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opName == <span class="hljs-string"><span class="hljs-string">"["</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> translateExpression(e.leftExpression) + <span class="hljs-string"><span class="hljs-string">"["</span></span> + translateExpression(e.rightExpression) + <span class="hljs-string"><span class="hljs-string">"]"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> + translateExpression(e.leftExpression) + <span class="hljs-string"><span class="hljs-string">" "</span></span> + opName + <span class="hljs-string"><span class="hljs-string">" "</span></span> + translateExpression(e.rightExpression) + <span class="hljs-string"><span class="hljs-string">")"</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translateExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UnaryMinusExpression e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span> + translateExpression(e.expression) }</code> </pre> <br><br><h2>  Visitor pattern </h2><br>  <i><font color="grey">The devil is in the details</font></i> <i><font color="grey"><br></font></i> <br>  It would hardly be convenient to create shaders if functions cannot be created.  So after a couple of working shaders, I decided to implement the broadcast functions.  Here from all the cracks climbed subtleties and details. <br>  In glsl, passing arguments is by value, and in Groovy by value we work only with primitives.  In addition, using the out qualifier in glsl, you can pass a primitive or vector back, and in Groovy this is not possible.  Annotations will not help either, since  I want to have not just the ‚Äúlooking‚Äù code correctly, but both the one being launched and the one being debugged.  This is just a couple of examples, in fact there are many subtleties. <br><br>  After the despair stage, several decisions were made.  For example, to prohibit rewriting non-primitive parameters, prohibiting the return of them if they are method parameters, etc. <br>  I will give the code for checking the presence of a modification of non-primitive parameters using a visitor: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Parameter parameter : methodNode.getParameters()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isPrimitive(translateType(parameter.getText()))) { YList&lt;Boolean&gt; rewritten = al(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); CodeVisitorSupport detectRewrittenVisitor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CodeVisitorSupport() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitBinaryExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BinaryExpression expression)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expression.getOperation().getText().equals(<span class="hljs-string"><span class="hljs-string">"="</span></span>)) { Expression left = expression.getLeftExpression(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> VariableExpression) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((VariableExpression) left).getName().equals(parameter.getName())) { rewritten.set(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.visitBinaryExpression(expression); } }; detectRewrittenVisitor.visitBlockStatement((BlockStatement) methodNode.getCode()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rewritten.get(<span class="hljs-number"><span class="hljs-number">0</span></span>)) System.out.println(parameter.getName() + <span class="hljs-string"><span class="hljs-string">" rewritten!"</span></span>); }</code> </pre><br>  The code is simple, but the task is primitive.  And although the visitor for such tasks and thought - already here the code prohibitively much.  Especially depressing checks of the types of child nodes and extracting additional information from them.  The problem will be aggravated when the task becomes more difficult - when it is necessary, for example, to check for the presence of a field in the code.  When parsing Groovy, you will first have to make sure that we are in the right branch of the assignment (or a number of other nodes), and it is only DEEPER to find, in fact, the node in which reading takes place.  Those.  here, you either have to enter a state into the visitor, or make two visitors, one to search for the ‚Äúright part of assignment‚Äù branch, and the second to search for the ‚Äúread field‚Äù node somewhere in the depth of the expressions of this branch. <br><br><h2>  Pattern matching </h2><br>  <i><font color="grey">When it becomes easier to breathe, and there is no headache from changes in the TK</font></i> <i><font color="grey"><br></font></i> <br>  Unfortunately, the previous options are suitable for simple cases, but make you despond at difficult tasks.  You have to write a lot of code for simple concepts, the existing code begins to interfere with the new, you have to add different drives and intermediate states.  And I want to - just specify a piece of AST tree with variables, and say what to do if one is found ... <br><br>  No sooner said than done!  The final version of the pattern for finding the rewriting of the field in a given variable: <br><br><pre> <code class="java hljs">Object varWritePattern = stairs( deeper(G_BODY_ACCESSORS), p(BinaryExpression.class, <span class="hljs-string"><span class="hljs-string">"operation"</span></span>, p(<span class="hljs-string"><span class="hljs-string">"text"</span></span>, <span class="hljs-string"><span class="hljs-string">"="</span></span>), <span class="hljs-string"><span class="hljs-string">"leftExpression"</span></span>), p(VariableExpression.class, <span class="hljs-string"><span class="hljs-string">"variable"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"VAR_NAME"</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> wasWritten = match(methodNode, varWritePattern).notEmpty();</code> </pre><br>  <i><font color="grey">(DO NOT PANIC, a little further I will describe the details, now you just need to enjoy the spectacle)</font></i> <i><font color="grey"><br></font></i> <br>  There is only one variable (var ("VAR_NAME")), and it points to the name of the variable to be rewritten (in the source code). <br><br>  The most interesting thing here is that the addition of quite complex (for the visitor) conditions - results in the addition of one line for each condition!  Those.  amazing result - now the size of the code linearly depends on the complexity of the TOR (technical assignment) and this complexity does not accumulate!  More complex pattern: <br><br><pre> <code class="java hljs">Object G_FIELD_AS_ARG_PATTERN = stairs( deeper(G_BODY_ACCESSORS), p(MethodCallExpression.class, <span class="hljs-string"><span class="hljs-string">"getMethod"</span></span>, p(<span class="hljs-string"><span class="hljs-string">"getText"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"METHOD_NAME"</span></span>)), <span class="hljs-string"><span class="hljs-string">"getArguments"</span></span>), p(ArgumentListExpression.class, <span class="hljs-string"><span class="hljs-string">"expressions"</span></span>), i(), p(PropertyExpression.class, <span class="hljs-string"><span class="hljs-string">"getObjectExpression"</span></span>, p(VariableExpression.class, <span class="hljs-string"><span class="hljs-string">"variable"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"OBJ_NAME"</span></span>)), <span class="hljs-string"><span class="hljs-string">"getProperty"</span></span>, p(<span class="hljs-string"><span class="hljs-string">"value"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"FIELD_NAME"</span></span>)))); Matcher.match(tree, G_FIELD_AS_ARG_PATTERN)</code> </pre><br>  Here, the place in the tree is calculated, where the field is passed to some variable as an argument to some function.  There are already 3 variables at once - the name of the method (METHOD_NAME), the name of the object (OBJ_NAME), and the name of the field in it (FIELD_NAME).  If desired, you can easily add more variables (for example, var ("ARG_INDEX") - to get or bind the argument number).  The great fact is that you can pass previously bound variables to the match function!  Then, without changing the pattern, we can find a subtree with a specific object name, or with a specific index, individually or all at once.  One can only imagine how much it would be necessary to enter a visitor in different places in order to achieve the same goals. <br><br><h2>  Passage backstage </h2><br>  <i><font color="grey">When magic is explained, it ceases to be magic (but remains a fairly advanced technology)</font></i> <i><font color="grey"><br></font></i> <br>  The pattern is a cast of a piece of wood to find.  Matcher takes this cast and searches in a tree - which piece would fit. <br><br><pre> <code class="java hljs">Matcher.match(tree, pattern)</code> </pre><br>  This function returns a list of all matches.  Each record is a mapping of a variable to that element of the tree that corresponded to it during the match.  If there were no variables in the pattern, then the records will be empty, but by their number one can see if there were matches and how many (which can also be the purpose of the query). <br>  In addition, you can pass pre-connected variables to the match to limit the options: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> wasWritten = match(methodNode, varWritePattern, hm(<span class="hljs-string"><span class="hljs-string">"VAR_NAME"</span></span>, parameterName)).notEmpty();</code> </pre><br>  Here we state in advance that only such a sub-tree is suitable, in which the variable VAR_NAME corresponds to a certain parameterName <br><br>  <i><font color="grey">It should be noted that by a tree here it is meant not some specific data structure (tree), but anything.</font></i>  <i><font color="grey">It may just be an array with numbers or objects.</font></i>  <i><font color="grey">Or just one object of any type.</font></i> <i><font color="grey"><br></font></i> <br>  The pattern itself does not contain an exhaustive 100% matching piece.  It only indicates what matters.  In addition - it consists not of the same classes as the tree, but of special ones.  Next I will give examples of such classes with explanations. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Property(<span class="hljs-string"><span class="hljs-string">"getClass"</span></span>, ReturnStatement.class, <span class="hljs-string"><span class="hljs-string">"getExpression"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"EXPR"</span></span>));</code> </pre><br>  Property is a class containing a set of name-value pairs.  Its meaning is that the node it is looking for must contain a field or method with the specified name, and the value (or result) must match the specified one.  Values ‚Äã‚Äãcan be: <br><ol><li>  other elements of the pattern (maybe again Property, for example), then the search will continue on them </li><li>  ordinary objects (string, number, or any class), then it will just be checked for a match </li></ol><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Var(<span class="hljs-string"><span class="hljs-string">"VAR_NAME"</span></span>, rest);</code> </pre><br>  Var is the same variable that contains the name and the continuation of the pattern.  As a result, it is by this name that the link to the corresponding tree node will be contained. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByIndex(<span class="hljs-number"><span class="hljs-number">3</span></span>, rest);</code> </pre><br>  ByIndex - allows to match List and arrays.  Moreover, the index itself is also considered a ‚Äúnode‚Äù, so you can match, for example, ‚Äúthe same values ‚Äã‚Äãin two arrays located in the same place‚Äù. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Deeper(G_BODY_ACCESSORS, rest);</code> </pre><br>  Deeper is an interesting item.  Lets say that "no matter what we meet next, but in the end we will find ...".  It allows you to go down the data structure to an unspecified depth initially.  A good example is expressions in a language ‚Äî it is not known how many levels of BinaryExpression and other branches are located between the declaration of a method and the specific use of a variable.  Also in it you need to specify a set of mini-patterns, accessors, with which it will work its way. <br><br>  I am not a fan of records like new LongJavaClassName (..., so if something is created more than a few times, I write a static method. So by rewriting new Property to p (), new Variable to var (), etc. ., the pattern takes on such a neat look: <br><br><pre> <code class="java hljs">Object varWritePattern = deeper(G_BODY_ACCESSORS, p( <span class="hljs-string"><span class="hljs-string">"getClass"</span></span>, BinaryExpression.class, <span class="hljs-string"><span class="hljs-string">"operation"</span></span>, p(<span class="hljs-string"><span class="hljs-string">"text"</span></span>, <span class="hljs-string"><span class="hljs-string">"="</span></span>), <span class="hljs-string"><span class="hljs-string">"leftExpression"</span></span>, p( <span class="hljs-string"><span class="hljs-string">"getClass"</span></span>, VariableExpression.class, <span class="hljs-string"><span class="hljs-string">"variable"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"VAR_NAME"</span></span>))));</code> </pre><br>  As you can see, here is a declaratively described template for finding assignments.  You can use it like this: <br><br><pre> <code class="java hljs">YSet&lt;YMap&lt;String, Object&gt;&gt; match1 = match(node, varWritePattern); YSet&lt;YMap&lt;String, Object&gt;&gt; match2 = match(node, varWritePattern, hm(<span class="hljs-string"><span class="hljs-string">"VAR_NAME"</span></span>, varName));</code> </pre><br>  In the first case, we get all the options, and in the second, only those in which the assignment occurs in a variable with the transferred value varName (the binding of the variable). <br><br><h2>  We get rid of steps of indents <br></h2><br>  <i><font color="grey">When the stairs in the house more than floors</font></i> <i><font color="grey"><br></font></i> <br>  I never liked this style in Lisp when you always need to open one more bracket (apparently not only to me, because Clojure has -&gt; and - &gt;&gt;).  It is much more convenient when I ‚Äúcall a method‚Äù on the result of the previous call, as in Scala, Xtend, <a href="https://github.com/kravchik/jcommon">my YCollections</a> , and many more: <br><br><pre> <code class="java hljs"> String names = al(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(<span class="hljs-string"><span class="hljs-string">"/home/user/"</span></span>).listFiles()) .filter(File::isDirectory) <span class="hljs-comment"><span class="hljs-comment">//only dirs .map(File::getName) //get name .filter(n -&gt; n.startsWith(".")) //only invisible .sorted() //sorted .foldLeft("", (r, n) -&gt; r + ", " + n); //to print fine System.out.println(names);</span></span></code> </pre><br>  To achieve the same effect, I added the ‚Äústairs‚Äù function, which (by analogy with ‚Äú- &gt;&gt;‚Äù from Clojure) - simply adds what comes later to the rest field of what comes before (not so easy, but the essence is ).  Now a rather complex pattern begins to look quite acceptable: <br><br><pre> <code class="java hljs">Object G_FIELD_AS_ARG_PATTERN = stairs( deeper(G_BODY_ACCESSORS), p(MethodCallExpression.class, <span class="hljs-string"><span class="hljs-string">"getMethod"</span></span>, p(<span class="hljs-string"><span class="hljs-string">"getText"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"METHOD_NAME"</span></span>)), <span class="hljs-string"><span class="hljs-string">"getArguments"</span></span>), p(ArgumentListExpression.class, <span class="hljs-string"><span class="hljs-string">"expressions"</span></span>), i(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"ARG_INDEX"</span></span>)), p(PropertyExpression.class, <span class="hljs-string"><span class="hljs-string">"getObjectExpression"</span></span>, p(VariableExpression.class, <span class="hljs-string"><span class="hljs-string">"variable"</span></span>, <span class="hljs-string"><span class="hljs-string">"OBJ_NAME"</span></span>), <span class="hljs-string"><span class="hljs-string">"getProperty"</span></span>, p(<span class="hljs-string"><span class="hljs-string">"value"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"FIELD_NAME"</span></span>))));</code> </pre><br>  In this form, it is very convenient to read the pattern - just from the top down, the branches - to the right.  It is easy to save and paste logic from neighboring patterns. <br><br>  Same commentary example <br><br><pre> <code class="java hljs">Object G_FIELD_AS_ARG_PATTERN = stairs( <span class="hljs-comment"><span class="hljs-comment">// -  deeper(G_BODY_ACCESSORS), //    p(MethodCallExpression.class, //   "getMethod", p("getText", var("METHOD_NAME")), //  getArguments ... "getArguments"), //  ,     expressions, ... p(ArgumentListExpression.class, "expressions"), // ,    (  ) ... i(var("ARG_INDEX")), //  p(PropertyExpression.class, // -  "getObjectExpression", p(VariableExpression.class, "variable", var("OBJ_NAME")), //    "getProperty", p("value", var("FIELD_NAME"))));</span></span></code> </pre><br>  Now use this pattern to analyze the following Groovy code: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vec3f vecA, Vec3f vecB</span></span></span><span class="hljs-function">)</span></span> { bar(vecA.x, vecA.y) bar(vecA.x, vecB.x) }</code> </pre><br>  Razpars him: <br><br><pre> <code class="java hljs">String src = IO.readFile(<span class="hljs-string"><span class="hljs-string">"src/main/java/yk/senjin/shaders/gshader/analysis/HabraExample.groovy"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//parse kotlin file Object node = new AstBuilder().buildFromString(CompilePhase.INSTRUCTION_SELECTION, src);</span></span></code> </pre><br>  And finally, we will make several requests: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//select method "foo" for (YMap&lt;String, Object&gt; m : match(node, stairs(deeper(G_METHOD_ACCESSORS), var("method"), p(MethodNode.class, "name"), "foo"))) { //getting methodNode object from select result Object methodNode = m.get("method"); System.out.println("all variables are free:"); System.out.println(match(methodNode, G_FIELD_AS_ARG_PATTERN).toString("\n")); System.out.println("fixed OBJ_NAME:"); System.out.println(match(methodNode, G_FIELD_AS_ARG_PATTERN, hm("OBJ_NAME", "vecB")).toString("\n")); System.out.println("fixed ARG_INDEX:"); System.out.println(match(methodNode, G_FIELD_AS_ARG_PATTERN, hm("ARG_INDEX", 0)).toString("\n")); }</span></span></code> </pre><br>  Output to console: <br><br><pre> <code class="java hljs">all variables are free: {METHOD_NAME=bar, OBJ_NAME=vecA, FIELD_NAME=x, ARG_INDEX=<span class="hljs-number"><span class="hljs-number">0</span></span>} {METHOD_NAME=bar, OBJ_NAME=vecA, FIELD_NAME=y, ARG_INDEX=<span class="hljs-number"><span class="hljs-number">1</span></span>} {METHOD_NAME=bar, OBJ_NAME=vecB, FIELD_NAME=x, ARG_INDEX=<span class="hljs-number"><span class="hljs-number">1</span></span>} fixed OBJ_NAME: {OBJ_NAME=vecB, METHOD_NAME=bar, FIELD_NAME=x, ARG_INDEX=<span class="hljs-number"><span class="hljs-number">1</span></span>} fixed ARG_INDEX: {ARG_INDEX=<span class="hljs-number"><span class="hljs-number">0</span></span>, METHOD_NAME=bar, OBJ_NAME=vecA, FIELD_NAME=x}</code> </pre><br>  Another example, for a very simple data structure - an array of vectors: <br><br><pre> <code class="java hljs">Vec3f[] vv = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vec3f[]{<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)}; System.out.println(match(vv, i(p(<span class="hljs-string"><span class="hljs-string">"x"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"X_VALUE"</span></span>))))); System.out.println(match(vv, i(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"OBJ_INDEX"</span></span>), p(<span class="hljs-string"><span class="hljs-string">"x"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"X_VALUE"</span></span>)))));</code> </pre><br>  The console will appear: <br><br><pre> <code class="java hljs">[{X_VALUE=<span class="hljs-number"><span class="hljs-number">0.0</span></span>}, {X_VALUE=<span class="hljs-number"><span class="hljs-number">1.0</span></span>}] [{OBJ_INDEX=<span class="hljs-number"><span class="hljs-number">0</span></span>, X_VALUE=<span class="hljs-number"><span class="hljs-number">0.0</span></span>}, {OBJ_INDEX=<span class="hljs-number"><span class="hljs-number">1</span></span>, X_VALUE=<span class="hljs-number"><span class="hljs-number">1.0</span></span>}]</code> </pre><br>  For completeness, here is an example of accessory for Deeper: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> YArrayList&lt;Object&gt; G_BODY_ACCESSORS = al( i(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>)), p(<span class="hljs-string"><span class="hljs-string">"methodsList"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>)), p(MethodNode.class, <span class="hljs-string"><span class="hljs-string">"code"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>)), p(MethodCallExpression.class, <span class="hljs-string"><span class="hljs-string">"getReceiver"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>)), p(BlockStatement.class, <span class="hljs-string"><span class="hljs-string">"getStatements"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>)), p(ExpressionStatement.class, <span class="hljs-string"><span class="hljs-string">"expression"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>)), p(BinaryExpression.class, <span class="hljs-string"><span class="hljs-string">"leftExpression"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>)), p(BinaryExpression.class, <span class="hljs-string"><span class="hljs-string">"rightExpression"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>)), p(DeclarationExpression.class, <span class="hljs-string"><span class="hljs-string">"getLeftExpression"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>)), p(DeclarationExpression.class, <span class="hljs-string"><span class="hljs-string">"getRightExpression"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>)), p(UnaryMinusExpression.class, <span class="hljs-string"><span class="hljs-string">"getExpression"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>)), p(UnaryPlusExpression.class, <span class="hljs-string"><span class="hljs-string">"getExpression"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>)), p(ReturnStatement.class, <span class="hljs-string"><span class="hljs-string">"getExpression"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>)), p(ConstructorCallExpression.class, <span class="hljs-string"><span class="hljs-string">"arguments"</span></span>, p(<span class="hljs-string"><span class="hljs-string">"expressions"</span></span>, i(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>)))), p(IfStatement.class, <span class="hljs-string"><span class="hljs-string">"booleanExpression"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>)), p(IfStatement.class, <span class="hljs-string"><span class="hljs-string">"ifBlock"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>)), p(IfStatement.class, <span class="hljs-string"><span class="hljs-string">"elseBlock"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>(<span class="hljs-string"><span class="hljs-string">"access"</span></span>))</code> </pre><br>  We can say that it performs a role similar to the one that the visitor's interface performs, only much simpler and more flexible.  For example, the line i (var ("access")) allows you to descend into any list or array, i.e.  it is not tied specifically to this tree, but is common.  So  It is easy to set rules about where you can and where you cannot go down with the help of Deeper - just by specifying the appropriate set of accessors. <br><br>  <i><font color="grey">Interesting idea.</font></i>  <i><font color="grey">It seems that using the pattern-match, you can analyze not only the AST, but also the <b>control-flow</b> , for this you need to properly describe the accessors in Deeper and ...</font></i> <i><font color="grey"><br></font></i> <br><br><h2>  About optimization </h2><br>  <i><font color="grey">It is time</font></i> <i><font color="grey"><br></font></i> <br>  It may seem that the approach is good, but not suitable for high-loaded areas (for example, parsing millions of lines of code).  This is true, but not true. <br><br>  Firstly, it is very easy to describe the subject area with patterns.  And this allows us to divide the tasks - into ‚Äúthe implementation of the TOR‚Äù, and into ‚Äúcode optimization‚Äù.  Having a ‚Äúslow‚Äù, simple, correct variant, well-adjusted and covered with tests, an optimized variant is much easier and faster to create than to accomplish by solving two problems at the same time - the implementation of the TOR and optimization.  Those.  here it can be divided - the ease of implementation of the TZ and the optimization of the working code. <br><br>  And this is much more important than it may seem.  I had tasks in which the implementation of TZ, and THEN optimization can take a week, and implementation TOGETHER with optimization can take a month.  Yes, the difference may be the order, and on the scale of the project even the orders. <br><br>  Secondly, the very fact of declarativeness in the description of the subject area opens up possibilities.  According to the declarations (theoretically), you can generate an optimized code that stores all the necessary state in variables, traverses the tree once, performing many parallel tasks, etc.  Those.  In theory, you can make an optimized, ‚Äúunpleasant‚Äù code generator.  Unpleasant - because a lot of state, a lot of parallel processes.  As a parser generator. <br><br><h2>  Sum up the pros </h2><br>  <i><font color="grey">You can't praise yourself - how will Google find it?</font></i> <i><font color="grey"><br></font></i> <br><ul><li>  declarativeness (you can draw, you can analyze, ...) </li><li>  easy syntax </li><li>  non-accumulative code complexity </li><li>  variable descent depth </li><li>  no binding to a specific data type </li><li>  two roles of variables (result / link) </li><li>  potential for optimizations </li><li>  easy reuse and copy-paste templates </li><li>  can be used as a normal select </li><li>  separation of tasks </li></ul><br>  Wiki with mavena <a href="https://github.com/kravchik/jcommon/wiki/pattern-matching">github.com/kravchik/jcommon/wiki/pattern-matching</a> <br><br>  PS you can once again admire Lisp, in which pattern matching for AST analysis would be completely natural and not worth a separate article. <br><br>  PPS and how do you disassemble the trees?  What are my industrial bike analogues? <br><br>  Thanks to <a href="https://habrahabr.ru/users/kleshney/" class="user_link">kleshney</a> and <a href="https://habrahabr.ru/users/oshyshko/" class="user_link">oshyshko</a> for reading the draft </div><p>Source: <a href="https://habr.com/ru/post/270173/">https://habr.com/ru/post/270173/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270163/index.html">As we for the first time in Ukraine held a security event on a grand scale</a></li>
<li><a href="../270165/index.html">Isolate the demons with systemd or ‚Äúyou don't need a docker for this!‚Äù</a></li>
<li><a href="../270167/index.html">Overview of the first elastic data warehouse Snowflake Elastic Data Warehouse</a></li>
<li><a href="../270169/index.html">Data ONTAP 8.3 ADP: FlashPool StoragePools</a></li>
<li><a href="../270171/index.html">Product Design Digest October 2015</a></li>
<li><a href="../270175/index.html">Microsoft will refuse to support digital certificates based on SHA-1</a></li>
<li><a href="../270179/index.html">The most important argument against MySQL?</a></li>
<li><a href="../270181/index.html">Android and iOS applications send user data to third parties much more often than is commonly believed.</a></li>
<li><a href="../270185/index.html">CLion 1.2: even more features and benefits</a></li>
<li><a href="../270187/index.html">Build your own failover cloud based on OpenNebula with Ceph, MariaDB Galera Cluster and OpenvSwitch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>