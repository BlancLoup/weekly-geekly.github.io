<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LLVM Overview</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="LLVM (Low Level Virtual Machine) is a universal system for analyzing, transforming and optimizing programs or, as the developers call it, ‚Äúcompiler in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>LLVM Overview</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://llvm.org/">LLVM</a> (Low Level Virtual Machine) is a universal system for analyzing, transforming and optimizing programs or, as the developers call it, ‚Äúcompiler infrastucture‚Äù. <br><br>  LLVM is not just another academic project.  Its history began in 2000 at the University of Illinois, and now LLVM is used by industry giants like Apple and Adobe.  In particular, LLVM is based on the OpenGL subsystem on MacOS X 10.5, and the iPhone SDK uses GCC with a backend on LLVM.  Apple is one of the main sponsors of the project, and LLVM's mastermind, Chris Lattner, now works for Apple. <br><br>  LLVM is based on an intermediate code representation (intermediate representation, IR), on which you can perform transformations during compilation, linking and execution.  From this view, optimized machine code is generated for a number of platforms, both statically and dynamically (JIT compilation).  LLVM supports code generation for x86, x86-64, ARM, PowerPC, SPARC, MIPS, IA-64, Alpha. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      LLVM is written in C ++ and ported to most * nix-systems and Windows.  The system has a modular structure and can be expanded with additional transformation algorithms (compiler passes) and code generators for new hardware platforms.  User frontend usually links to LLVM and uses the C ++ API to generate code and transform it.  However, LLVM includes standalone utilities. <br><br>  For those who, not without reason, thinks C ++ is not the best language for writing compilers, more recently, the OCaml API wrapper is included in LLVM. <br><br>  To understand what can be done with LLVM, and at what level you will have to work, let's see <a name="habracut"></a>  what is LLVM IR.  In one sentence, it can be described as a typed three-address code in SSA-form. <br><br>  Hereinafter, we will use the text form of the entry of the intermediate code, a kind of ‚Äúassembler‚Äù of the LLVM.  In practice, an effective binary representation (bitcode) is used to store the code.  Generating the same code is usually most convenient not in text form, and certainly not in binary, but with the help of a special API.  In this case, the bitcode may not reach: the code is formed in the form of internal structures in memory, on which all operations are performed, up to the generation of the machine code. <br><br><br><h2>  Data types </h2><br>  The following primitive types are supported in LLVM: <br><ul><li>  Integers of arbitrary width: <br><blockquote><code>i1 ;   ‚Äî 0  1&lt;br/&gt; i32 ; 32- &lt;br/&gt; i17 ;  &lt;br/&gt; i256 ; !</code> </blockquote>  The generation of machine code for types of very large bit width is not supported.  For example, for x86 you will have to limit to <code>i64</code> , and for x86-64 and other 64-bit platforms - to 128-bit integers.  But for intermediate representation there are no restrictions. <br>  Numbers are considered to be presented in an additional code.  There is no distinction between signed and unsigned integers at the type level: when it matters, different instructions work with them. <br></li><li>  Floating-point numbers: <code>float</code> , <code>double</code> , and a number of platform-specific types (for example, <code>x86_fp80</code> ). </li><li>  <code>void</code> is an empty value. <br></li></ul>  Derived types: <br><ul><li>  Pointers <br><blockquote> <code><em></em> *&lt;br/&gt; i32* ;   32- &lt;br/&gt;</code> </blockquote> </li><li>  Arrays <br><blockquote> <code>[ <em> </em> x <em></em> ]&lt;br/&gt; [10 x i32]&lt;br/&gt; [8 x double]&lt;br/&gt;</code> </blockquote> </li><li>  Structures <br><blockquote> <code>{ i32, i32, double }</code> </blockquote> </li><li>  A vector is a special type to simplify SIMD operations.  The vector consists of 2 <sup>n</sup> values ‚Äã‚Äãof the primitive type - integer or floating point. <br><blockquote> <code>&lt;   x  &gt;&lt;br/&gt; &lt; 4 x float &gt;&lt;br/&gt;</code> </blockquote> </li><li>  Functions <br><blockquote> <code>i32 (i32, i32)&lt;br/&gt; float ({ float, float }, { float, float })&lt;br/&gt;</code> </blockquote> </li></ul>  The type system is recursive, so multidimensional arrays, arrays of structures, pointers to structures and functions, etc. can be used. <br><br><br><h2>  Operations </h2><br>  Most instructions in LLVM take two arguments (operands) and return a single value (three address code).  Values ‚Äã‚Äãare determined by text identifier.  Local values ‚Äã‚Äãare indicated by the prefix <code>%</code> , and global values ‚Äã‚Äãare <code>@</code> .  Local values ‚Äã‚Äãare also called registers, and LLVM - a virtual machine with an infinite number of registers.  Example: <br><blockquote> <code>%sum = add i32 %n, 5&lt;br/&gt; %diff = sub double %a, %b&lt;br/&gt; %z = add &lt;4 x float&gt; %v1, %v2 ;  &lt;br/&gt; %cond = icmp eq %x, %y ;   .    i1.&lt;br/&gt; %success = call i32 @puts(i8* %str)&lt;br/&gt;</code> </blockquote>  The type of operands is always specified explicitly, and uniquely identifies the type of the result.  The operands of arithmetic instructions must be of the same type, but the instructions themselves are ‚Äúoverloaded‚Äù for any numeric types and vectors. <br><br>  Instead of tedious enumeration of instructions (there are 52 of them altogether), we say that LLVM supports the full set of arithmetic operations, bitwise logical operations and shift operations, as well as special instructions for working with vectors. <br><br>  LLVM IR is strongly typed, so you cannot do without type conversions, which are explicitly encoded with special instructions.  A set of 9 instructions covers all kinds of castings between different numeric types: whole and floating point, with and without a sign, different bit <code>bitcast</code> , etc. In addition, there are conversion instructions between integers and pointers, as well as a <code>bitcast</code> instruction that will lead everything but you are responsible for the result. <br><br>  Now it should be clear how to compile simple expressions in LLVM: each node of the expression tree except leaves (constants and variables) is replaced with an intermediate register value ‚Äî the result of an instruction whose operands are child nodes. <br><blockquote> <code>; x = (a + b) * c - d / e &lt;br/&gt; %tmp1 = add float %a, %b &lt;br/&gt; %tmp2 = mul float %tmp1, %c &lt;br/&gt; %tmp3 = fdiv float %d, %e &lt;br/&gt; %x = sub float %tmp2, %tmp3 &lt;br/&gt;</code> </blockquote>  Looking ahead, beyond the scope of this article, we note that when using the LLVM API to generate code, everything becomes even simpler, because it follows the principle ‚Äúinstruction is the meaning‚Äù.  We will not have to deal with the generation of unique names for intermediate values: the function that generates the instruction returns a value (a C ++ object) that can be passed as an argument to other such functions. <br><br><br><h2>  SSA </h2><br>  SSA ( <a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">static single assignment form</a> ) is a form of intermediate code presentation in which any value is assigned only once.  Thus, it is impossible to write: <br><blockquote> <code>%z = sum i32 %x, %y &lt;br/&gt; %z = sum i32 %z, 5 &lt;br/&gt;</code> </blockquote>  The new value should get a new name: <br><blockquote> <code>%z.1 = sum i32 %z, 5</code> </blockquote>  However, you ask how to be if the same variable should receive different values ‚Äã‚Äãdepending on some condition?  Or how to organize a loop variable? <br><br>  Let's start a little from afar.  It is convenient to consider the code in the SSA form not as a linear sequence of instructions, but as a control flow graph (CFG).  The vertices of this graph are the so-called basic blocks (basic blocks), containing a sequence of instructions, ending with a terminator instruction that explicitly transfers control to another block.  Base blocks in LLVM are labeled, and the terminators are the following instructions: <br><ul><li>  <code>ret <em></em> <em></em></code> - return value from function <br></li><li>  <code>br i1 <em></em> , label <em>_1</em> , label <em>_2</em></code> - conditional transition.  For example: <br><blockquote> <code>define float @max(float %x, float %y) &lt;br/&gt; { &lt;br/&gt;     %cond = fcmp ogt float %x, %y &lt;br/&gt;     br i1 %cond, label %IfTrue, label %IfFalse &lt;br/&gt; IfTrue: &lt;br/&gt;     ret float %x &lt;br/&gt; IfFalse: &lt;br/&gt;     ret float %y &lt;br/&gt; }</code> </blockquote>  (I think the syntax of the function definition is obvious). <br>  There is also a form of unconditional transition: <br><blockquote> <code>br label <em></em></code> </blockquote> </li><li>  <code>switch</code> - generalization <code>br</code> , allows you to organize the transition table: <br><blockquote> <code>switch i32 %n, label %Default, [i32 0, label %IfZero i32 5, label %IfFive]</code> </blockquote> </li><li>  <code>invoke</code> and <code>unwind</code> are used to organize exceptions, in this article we will not dwell on them. <br></li><li>  <code>unreachable</code> is a special instruction showing the compiler that execution will never reach this point.  For example, this instruction may be inserted after calling the system function terminating the process. <br></li></ul>  Let us return to the question of how to make variables changeable.  In the SSA form, a special function œÜ is added to the other instructions, which returns one of the listed values ‚Äã‚Äãdepending on which block transfers control to the current one. <br><br>  In LLVM, this function corresponds to the phi instruction, which has the following form: <br><blockquote> <code>phi , [_1, label _1], ..., [_N, label _N]</code> </blockquote>  As an example, consider the factorial calculation function, which could be written in C as follows: <br><blockquote> <code>int factorial(int n) &lt;br/&gt; { &lt;br/&gt;     int result = n; &lt;br/&gt;     int i; &lt;br/&gt;     for (i = n - 1; i &gt; 1; --i) &lt;br/&gt;         result *= i; &lt;br/&gt;     return result; &lt;br/&gt; } &lt;br/&gt;</code> </blockquote>  Note: a block that starts from entering a function is indicated by <code>%0</code> . <br><blockquote> <code>define i32 @factorial(i32 %n) &lt;br/&gt; { &lt;br/&gt;     %i.start = sub i32 %n, 1 &lt;br/&gt;     br label %LoopEntry &lt;br/&gt; LoopEntry: &lt;br/&gt;     %result = phi i32 [%n, %0], [%result.next, %LoopBody] &lt;br/&gt;     %i = phi i32 [%i.start, %0], [%i.next, %LoopBody] &lt;br/&gt;     %cond = icmp sle i32 %i, 1 &lt;br/&gt;     br i1 %cond, label %Exit, label %LoopBody &lt;br/&gt; LoopBody: &lt;br/&gt;     %result.next = mul i32 %result, %i &lt;br/&gt;     %i.next = sub i32 %i, 1 &lt;br/&gt;     br label %LoopEntry &lt;br/&gt; Exit: &lt;br/&gt;     ret i32 %result &lt;br/&gt; }</code> </blockquote>  Do not be confused by the seemingly meaningless transitions to the label immediately following the transition instruction.  As we have said, the base unit must end with an explicit control transfer.  LLVM also requires that all phi instructions go at the beginning of the block, and there were no other instructions before them. <br>  Here, probably, many will exclaim: but this is terribly inconvenient!  Indeed, although the SSA-form allows you to perform many useful transformations, directly generating it from code in an imperative language is difficult, although there are well-known transformation algorithms in SSA.  Fortunately, when writing a compiler based on LLVM, there is no need to do this, because the system can generate SSA itself.  How and from what, we now find out. <br><br><br><h2>  Memory </h2><br>  In addition to register values, LLVM also has work with memory.  Values ‚Äã‚Äãin memory are addressed by typed pointers, which we discussed above.  You can access the memory only with the help of two instructions whose names speak for themselves: <code>load</code> and <code>store</code> .  For example: <br><blockquote> <code>%x = load i32* %x.ptr        ;    i32   %x.ptr &lt;br/&gt; %tmp = add i32 %x, 5         ;  5 &lt;br/&gt; store i32 %tmp, i32* %x.ptr  ;    &lt;br/&gt;</code> </blockquote>  But to use pointers, you need to somehow allocate memory for the values ‚Äã‚Äãto which they point. <br><br>  The <code>malloc</code> instruction is translated into a call to the system function of the same name and allocates memory on the heap, returning a value - a pointer of a certain type.  Together with her, of course, there is an instruction <code>free</code> . <br><blockquote> <code>%struct.ptr = malloc { double, double } &lt;br/&gt; %string = malloc i8, i32 %length &lt;br/&gt; %array = malloc [16 x i32] &lt;br/&gt; free i8* %string &lt;br/&gt;</code> </blockquote>  There is no official recommendation not to use the <code>malloc</code> instruction, but developers admit that there is not much point in its existence now.  You can call <code>@malloc</code> function <code>@malloc</code> or write your own allocator function that meets some special requirements. <br><br>  But the alloca instruction is irreplaceable and very important.  It has the same format, but allocates memory on the stack. <br><blockquote> <code>%x.ptr = alloca double ; %x.ptr   double* &lt;br/&gt; %array = alloca float, i32 8 ; %array   float*,   [8 x float]! &lt;br/&gt;</code> </blockquote>  The memory allocated by <code>alloca</code> is automatically freed upon exiting the function using the <code>ret</code> or <code>unwind</code> instructions. <br>  With <code>alloca</code> , <code>load</code> and <code>store</code> we can use local variables in the same way as in any imperative language.  For example, our long-suffering factorial function: <br><blockquote> <code>define i32 @factorial(i32 %n) &lt;br/&gt; { &lt;br/&gt;     %result.ptr = alloca i32     ;    result &lt;br/&gt;     %i.ptr = alloca i32          ;   i &lt;br/&gt;     store i32 %n, i32* %result.ptr  ;  result = n &lt;br/&gt;     %tmp1 = sub i32 %n, 1 &lt;br/&gt;     store i32 %tmp1, i32* %i.ptr ; i = n - 1 &lt;br/&gt;     br label %Loop &lt;br/&gt; Loop: &lt;br/&gt;     %i = load i32* %i.ptr        ;   i &lt;br/&gt;     %cond = icmp sle i32 %i, 1   ;    i &lt;= 1&lt;br/&gt;     br i1 %cond, label %Exit, label %LoopBody ;  ,     &lt;br/&gt; LoopBody: &lt;br/&gt;     %tmp2 = load i32* %result.ptr &lt;br/&gt;     %tmp3 = mul i32 %tmp2, %i &lt;br/&gt;     store i32 %tmp3, i32* %result.ptr   ; result *= i &lt;br/&gt;     %i.next = sub i32 %i, 1 &lt;br/&gt;     store i32 %i.next, i32* %i.ptr      ; --i &lt;br/&gt;     br label %Loop &lt;br/&gt; Exit: &lt;br/&gt;     %result = load i32* %result.ptr &lt;br/&gt;     ret i32 %result ; return result &lt;br/&gt; } &lt;br/&gt;</code> </blockquote>  Verbose enough, but tell me, where else besides a similar article will you write the code on LLVM manually?  :-) <br>  The good news is that LLVM can build an SSA form from such a code.  This process is called ‚Äúpromote memory to register‚Äù.  Here is what comes out of the <code>factorial</code> function after passing this algorithm: <br><blockquote> <code>define i32 @factorial(i32 %n) { &lt;br/&gt; ; &lt;label&gt;:0 &lt;br/&gt;     %tmp1 = sub i32 %n, 1 &lt;br/&gt;     br label %Loop &lt;br/&gt; Loop: &lt;br/&gt;     %i.ptr.0 = phi i32 [ %tmp1, %0 ], [ %i.next, %LoopBody ] &lt;br/&gt;     %result.ptr.0 = phi i32 [ %n, %0 ], [ %tmp3, %LoopBody ] &lt;br/&gt;     %cond = icmp sle i32 %i.ptr.0, 1 &lt;br/&gt;     br i1 %cond, label %Exit, label %LoopBody &lt;br/&gt; LoopBody: &lt;br/&gt;     %tmp3 = mul i32 %result.ptr.0, %i.ptr.0 &lt;br/&gt;     %i.next = sub i32 %i.ptr.0, 1 &lt;br/&gt;     br label %Loop &lt;br/&gt; Exit: &lt;br/&gt;     ret i32 %result.ptr.0 &lt;br/&gt; } &lt;br/&gt;</code> </blockquote> <br><h3>  Pointer Operations </h3><br>  The arrays in LLVM are very similar to those in C, but there is no address arithmetic, as in C.  That is, you can not write: <br><blockquote> <code>%ptr = add i32* %array, i32 %index</code> </blockquote>  To calculate the addresses of elements of arrays, structures, etc. with the correct typing, there is a special instruction <code>getelementptr</code> . <br><blockquote> <code>%array = alloca i32, i32 %size &lt;br/&gt; %ptr = getelementptr i32* %array, i32 %index ;   i32* &lt;br/&gt;</code> </blockquote>  <code>getelementptr</code> only calculates the address, but does not access memory.  The instruction takes an arbitrary number of indices and can dereference structures of any nesting.  For example, from the following C code: <br><blockquote> <code>struct s { &lt;br/&gt;     int n; &lt;br/&gt;     char *a[4]; &lt;br/&gt; }; &lt;br/&gt; struct *s = ...; &lt;br/&gt; char c = s-&gt;a[2][5]; &lt;br/&gt;</code> </blockquote>  the following sequence of instructions will be generated: <br><blockquote> <code>%ptr = getelementptr { i32, [4 x i8*] }* %s, i32 1, i32 2, i32 5 &lt;br/&gt; %c = load i8* %ptr &lt;br/&gt;</code> </blockquote>  As you can see, indexes are counted from zero. <br>  There are a couple of <code>extractvalue</code> and <code>insertvalue</code> instructions <code>extractvalue</code> are very similar to <code>insertvalue</code> .  They differ in that they take not a pointer to an aggregate data type (array or structure), but a value of this type itself.  <code>extractvalue</code> returns the corresponding value of the sub-element, not a pointer to it, but <code>insertvalue</code> generates a new value of the aggregate type. <br><blockquote> <code>%n = extractvalue { i32, [4 x i8*] } %s, 0 &lt;br/&gt; %tmp = add i32 %n, 1 &lt;br/&gt; %s.1 = insertvalue { i32, [4 x i8*] } %s, i32 %tmp, 0 &lt;br/&gt;</code> </blockquote> <br><h2>  Built-in functions and annotations </h2><br>  A number of primitives are represented in LLVM not by instructions, but by built-in functions (intrinsic functions).  For example, some mathematical functions: <code>@llvm.sqrt.*</code> , <code>@llvm.sin.*</code> , Etc. There are also primitives for atomic operations and some others. <br><br>  It is interesting that the calls of these functions in the intermediate code are not at all obliged to turn into function calls in machine code, or even into inline substitution of functions.  They can simply carry service information for some kind of compiler subsystem.  For example, the generation of debug information in DWARF format is organized in this way: calls of functions <code>%llvm.dbg.stoppoint</code> are inserted into IR (sets the correspondence between lines of the source code and the generated code), <code>%llvm.dbg.declare</code> (sets the description of a local variable), etc. as arguments to which pointers to special structures are passed. <br><br>  Similarly implemented support garbage collection.  LLVM does not contain any garbage collection algorithm, instead providing an interface for writing your own exact GC.  The primitives <code>@llvm.gcroot</code> , <code>@llvm.gcread</code> and <code>@llvm.gc.write</code> allow you to encode the information needed for the GC to work, and the plug-in interface to the LLVM compiler to generate the necessary data structures from this information and insert calls to runtime. <br><br><br><h2>  What the LLVM optimizer can do </h2><br>  Just list some of the algorithms.  All of them are platform independent and transform IR.  Optimizer passes can be called independently in the correct order. <br><ul><li>  Delete unused code (dead code elimination). <br></li><li>  Selection of identical subexpression elimination. <br></li><li>  Constant distribution (constant propagation, condition propagation). <br></li><li>  Inline function substitution. <br></li><li>  Reversal of tail recursion.  LLVM can also in some cases expand non-tail recursive calls by entering an additional battery variable, as is often done in functional languages.  For example, in this function the recursive call will be successfully replaced by a conditional branch. <br><blockquote> <code>int factorial(int n) &lt;br/&gt; { &lt;br/&gt;     if (n &lt; 2) return 1; &lt;br/&gt;     return n * factorial(n - 1); &lt;br/&gt; } &lt;br/&gt;</code> </blockquote> </li><li>  Promotion and disconnection of cycles, removal of invariants beyond the cycle. <br></li></ul>  Conversion can be not only optimizing, but also used for analysis and instrumentation.  For example, LLVM can generate CFG in Graphviz format. <br><br><h2>  Instead of conclusion </h2><br>  From this brief overview, it is clear that the intermediate representation of LLVM closely matches the code in low-level procedural languages ‚Äã‚Äãlike C.  The LLVM-based C translator will be fairly straightforward and straightforward, but at the same time, the machine-generated code of performance will be able to withstand the latest versions of GCC. <br><br>  When translating high-level languages ‚Äã‚Äã- object-oriented, functional, dynamic - you will have to perform much more intermediate transformations, as well as write a specialized runtime.  But in this case, LLVM removes the problems of code generation for a specific platform from the compiler developer, takes on most language-independent optimizations - and does them qualitatively.  In addition, we have a ready infrastructure for JIT compilation and the possibility of link-time optimization between different languages ‚Äã‚Äãcompiled in LLVM. <br><br>  LLVM tries to achieve a balance between convenience and flexibility without imposing any particular programming paradigm, without restricting the type system. <br><br>  A full-fledged frontend exists today only for C, C ++, Ada and Fortran - this is llvm-gcc.  Work is underway to create a C / C ++ compiler - <a href="http://clang.llvm.org/">clang</a> independent of GCC.  Both projects are supported by the main LLVM team. <br><br>  Other projects compilers known languages ‚Äã‚Äãbased on LLVM has not yet reached the level of practical applicability.  But the prospects are tempting.  Will we see a modern functional or dynamic ( <a href="http://pypy.org/">PyPy</a> ?) Compiler in LLVM - time will tell. <br><br>  <em>to be continued‚Ä¶</em> <br></div><p>Source: <a href="https://habr.com/ru/post/47878/">https://habr.com/ru/post/47878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../47870/index.html">ICQ stated that using QIP is dangerous.</a></li>
<li><a href="../47874/index.html">Nigma-feature collection 2008</a></li>
<li><a href="../47875/index.html">Translate.Google: improved, but better</a></li>
<li><a href="../47876/index.html">Augmented Reality</a></li>
<li><a href="../47877/index.html">nVidia Ion + Intel Atom be</a></li>
<li><a href="../47879/index.html">White IDE - RAD Browser Development Environment</a></li>
<li><a href="../47880/index.html">What does the program feel?</a></li>
<li><a href="../47883/index.html">Multi-window interface: a step into the future</a></li>
<li><a href="../47884/index.html">Bravequest - RPG on Prototype.js</a></li>
<li><a href="../47888/index.html">First BarCamp in Belarus held - ByCamp 2008</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>