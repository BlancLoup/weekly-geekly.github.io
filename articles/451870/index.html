<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Modern C ++ features that all programmers need to be aware of</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The author of the material, the translation of which we are publishing today, says that C ++, in its current form, when compared with what this langua...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Modern C ++ features that all programmers need to be aware of</h1><div class="post__text post__text-html js-mediator-article">  The author of the material, the translation of which we are publishing today, says that C ++, in its current form, when compared with what this language was a few years ago, has changed significantly for the better.  Of course, these changes did not happen immediately.  For example, in the old days, C ++ lacked dynamism.  It was not easy to find a person who could say that he has tender feelings for this language.  Everything changed when those responsible for the standardization of the language decided to launch the innovations.  In 2011, C ++ became a dynamic language, a language that is constantly evolving and causes programmers to have much more positive emotions. <br><br>  Do not think that the language has become easier.  It can still be called one of the most complex widely used programming languages, if not the most difficult.  But modern C ++ has become much friendlier than before. <br><br><img src="https://habrastorage.org/webt/qk/ii/cx/qkiicxclyr6agfsxlcplndrkpd8.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Today we will talk about some new features of the language (starting with C ++ 11, which, by the way, is already 8 years old), which any programmer will know about. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Auto keyword</font> </h2><br>  Since the <code>auto</code> keyword appeared in C ++ 11, the life of programmers has become easier.  Thanks to this keyword, the compiler can output the types of variables at compile time, which saves us from having to always specify the types ourselves.  This turned out to be very convenient, for example, in cases when you have to work with data types like <code>map&lt;string,vector&lt;pair&lt;int,int&gt;&gt;&gt;</code> .  When using the <code>auto</code> keyword you need to take into account some features.  Consider an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> an_int = <span class="hljs-number"><span class="hljs-number">26</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     - int auto a_bool = false; //   bool auto a_float = 26.04; //   float auto ptr = &amp;a_float; //       auto data; // #1     ?    - .</span></span></code> </pre> <br>  Pay attention to the line, the last one in this example, the comment to which is marked as <code>#1</code> (hereinafter, in a similar way, we will mark the lines that we will, after the examples, parse).  There is no initializer in this line, you cannot do this.  The code located in this line does not allow the compiler to know what the type of the corresponding variable should be. <br><br>  Initially, the capabilities of the <code>auto</code> keyword in C ++ were pretty limited.  Then, in more recent versions of the language, <code>auto</code> features were added.  Here is another example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//            auto! {   std::vector&lt;int&gt; c = do_something(a, b);   return c; } std::vector&lt;int&gt; a = { ... }; // #1 -  std::vector&lt;int&gt; b = { ... }; // #2  -  auto c = merge(a,b); //      </span></span></span></span></code> </pre> <br>  In lines <code>#1</code> and <code>#2</code> , the variable is initialized using curly brackets - another new feature of C ++ 11. <br><br>  Remember that when using the <code>auto</code> keyword, the compiler must have some way to infer the type of the variable. <br><br>  Now - an interesting question.  What happens if you use a construct like <code>auto a = {1, 2, 3}</code> ?  What is it?  Vector, or the reason for the compilation error? <br><br>  Actually, in C ++ 11 a structure of the form <code>std::initializer_list&lt;type&gt;</code> .  The list of initialization values ‚Äã‚Äãin parentheses will be treated as a container when using the <code>auto</code> keyword. <br><br>  And finally, as has already been said, type inference by the compiler can be extremely useful if you have to work with complex data structures.  Here is an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">populate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    !   data.insert({"a",{1,4}});   data.insert({"b",{3,1}});   data.insert({"c",{2,3}}); } auto merge(auto data, auto upcoming_data) { //         auto result = data;   for(auto it: upcoming_data) {       result.insert(it);   }   return result; } int main() {   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; data;   populate(data);   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; upcoming_data;   upcoming_data.insert({"d",{5,3}});   auto final_data = merge(data,upcoming_data);   for(auto itr: final_data) {       auto [v1, v2] = itr.second; // #1               std::cout &lt;&lt; itr.first &lt;&lt; " " &lt;&lt; v1 &lt;&lt; " " &lt;&lt; v2 &lt;&lt; std:endl;   }   return 0; }</span></span></code> </pre> <br>  Take a look at line <code>#1</code> .  The expression <code>auto [v1,v2] = itr.second</code> is a new C ++ 17 feature. This is the so-called decomposition when declaring variables.  In previous versions of the language, it was necessary to extract each value separately.  Thanks to this mechanism, it has become much more convenient to perform such operations. <br><br>  Moreover, if you need to work with data using links, it is enough to add just one character to this construct, converting it to the following form: <code>auto &amp;[v1,v2] = itr.second</code> . <br><br><h2>  <font color="#3AC1EF">Lambda expressions</font> </h2><br>  C ++ 11 introduces support for lambda expressions.  They resemble anonymous functions in JavaScript, they can be compared with functional objects without names.  They capture variables in different scopes depending on their description, for which compact syntactic constructs are used.  In addition, they can be assigned to variables. <br><br>  Lambda expressions are a very useful tool for those cases when you need to perform some small operation in the code, but you do not want to write a separate function for this.  Another common example of their use is the creation of functions used when comparing values.  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; data = {{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>}, {<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}}; <span class="hljs-comment"><span class="hljs-comment">//        std::sort(begin(data), end(data), [](auto a, auto b) { //   - auto!   return a.second &lt; b.second; });</span></span></code> </pre> <br>  In this brief example you can find a lot of interesting things. <br><br>  First of all, pay attention to how convenient it is to use variable initialization using curly brackets.  Next, we can see the standard <code>begin()</code> and <code>end()</code> constructs, which also appeared in C ++ 11. Then comes the lambda function used as a mechanism for comparing data.  The parameters of this function are declared using the <code>auto</code> keyword, this feature appeared in C ++ 14. Previously, this keyword could not be used to describe the parameters of functions. <br><br>  Now notice that the lambda expression starts with square brackets - <code>[]</code> .  This is the so-called mask of variables.  It defines the scope of the expression, that is, it allows you to manage the relationship of the lambda expression with local variables and objects. <br><br>  Here is an excerpt from <a href="https://github.com/AnthonyCalandra/modern-cpp-features">this</a> repository on modern C ++ features: <br><br><ul><li>  <code>[]</code> - the expression does not capture anything.  This means that in lambda expressions one cannot use local variables from the external field of view to it.  Only parameters can be used in an expression. </li><li>  <code>[=]</code> - the expression captures the values ‚Äã‚Äãof local objects (that is, local variables, parameters).  This means that they can be used, but not modified. </li><li>  <code>[&amp;]</code> - expression captures references to local objects.  They can be modified, it is shown in the following example. </li><li>  <code>[this]</code> - the expression captures the value of the <code>this</code> pointer. </li><li>  <code>[a, &amp;b]</code> - the expression captures the value of the object <code>a</code> and a reference to the object <code>b</code> . </li></ul><br>  As a result, if you need to convert data into some other format inside the lambda function, you can use the mechanisms described above.  Consider an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; data = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> factor = <span class="hljs-number"><span class="hljs-number">7</span></span>; for_each(begin(data), end(data), [&amp;factor](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;val) { <span class="hljs-comment"><span class="hljs-comment">//    factor     val = val * factor;   factor--; // #1   - ,  -    factor   }); for(int val: data) {   std::cout &lt;&lt; val &lt;&lt; ' '; // 14 24 20 4 3 6 9 }</span></span></code> </pre> <br>  Here, if the <code>factor</code> variable would be accessed by value (then, when describing the lambda expression, the mask of the <code>[factor]</code> variables would be used), then in line <code>#1</code> the <code>factor</code> value could not be changed - simply because we would not have rights to performing such an operation.  In this example, we have the right to such actions.  In such situations, it is important not to abuse the possibilities that access to variables has by reference. <br><br>  In addition, note that access to <code>val</code> also carried out by reference.  This allows you to ensure that data changes occurring in the lambda function affect the <code>vector</code> . <br><br><h2>  <font color="#3AC1EF">Variable initialization expressions inside if and switch constructs</font> </h2><br>  I really liked this new C ++ 17 right after I found out about it.  Consider an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; input = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = input.find(<span class="hljs-number"><span class="hljs-number">7</span></span>); it==input.end()){ <span class="hljs-comment"><span class="hljs-comment">//   - ,  -    std::cout &lt;&lt; 7 &lt;&lt; " not found" &lt;&lt; std:endl; } else {   //    else      it   std::cout &lt;&lt; 7 &lt;&lt; " is there!" &lt;&lt; std::endl; }</span></span></code> </pre> <br>  It turns out that now you can perform initialization of variables and comparisons with their use in a single <code>if</code> or <code>switch</code> block.  This contributes to the writing of neat code.  Here is a schematic description of the considered construction: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( init-statement(x); condition(x)) {   <span class="hljs-comment"><span class="hljs-comment">//    } else {   //     x   //    }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Perform calculations at compile time using constexpr</font> </h2><br>  The <code>constexpr</code> gives us great opportunities.  Suppose we have a certain expression that needs to be calculated, while its value, after it initializes the corresponding variable, will not change.  Such an expression can be calculated in advance and used as a macro.  Or, what has become possible in C ++ 11, use the <code>constexpr</code> . <br><br>  Programmers strive to minimize the amount of computation performed during the execution of programs.  As a result, if certain operations can be performed during the compilation process and thus relieve the load on the system during program execution, this will have a good effect on the program behavior at run time.  Here is an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; constexpr long long fact(long long n) { //       constexpr return n == 1 ? 1 : (fact(n-1) * n); } int main() { const long long bigval = fact(20); std::cout&lt;&lt;bigval&lt;&lt;std::endl; }</span></span></span></span></code> </pre> <br>  This is a very common use of <code>constexpr</code> . <br><br>  Since we declared a function for calculating factorial as <code>constexpr</code> , the compiler can calculate the <code>fact(20)</code> value in advance during the compilation of the program.  As a result, after compilation, the string <code>const long long bigval = fact(20);</code>  can be replaced by <code>const long long bigval = 2432902008176640000;</code>  . <br><br>  Note that the argument passed to the function is represented by a constant.  This is an important feature of using functions declared using the <code>constexpr</code> .  The arguments passed to them must also be declared using the <code>constexpr</code> or using the <code>const</code> keyword.  Otherwise, such functions will behave like normal functions, that is, during compilation, their values ‚Äã‚Äãwill not be calculated in advance. <br><br>  Variables can also be declared using the <code>constexpr</code> .  In such a case, as it is easy to guess, the values ‚Äã‚Äãof these variables must be calculated at compile time.  If this cannot be done, a compilation error message will be displayed. <br><br>  It is interesting to note that later, in C ++ 17, the constructs <a href="https://hackernoon.com/a-tour-of-c-17-if-constexpr-3ea62f62ff65">constexpr-if</a> and <a href="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-constexpr%3Fview%3Dvs-2019">constexpr-lambda appeared</a> . <br><br><h2>  <font color="#3AC1EF">Tuple data structures</font> </h2><br>  Like the <code>pair</code> data structure, the <code>tuple</code> data structure (tuple) is a collection of values ‚Äã‚Äãof different types of fixed size.  Here is an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chowdhury"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  auto     //    std::get&lt;0&gt;(user_info); std::get&lt;1&gt;(user_info); std::get&lt;2&gt;(user_info); //  C++ 11     tie std::string first_name, last_name, age; std::tie(first_name, last_name, age) = user_info; //  C++ 17, ,       auto [first_name, last_name, age] = user_info;</span></span></code> </pre> <br>  Sometimes, instead of a <code>tuple</code> data structure, it is more convenient to use <code>std::array</code> .  This data structure is similar to simple arrays used in the C language, with additional features from the standard C ++ library.  This data structure appeared in C ++ 11. <br><br><h2>  <font color="#3AC1EF">Automatic output of class template argument type</font> </h2><br>  The name of this feature looks rather long and complicated, but in reality there is nothing difficult here.  The basic idea here is that in C ++ 17, the output of template argument types is also performed for standard class templates.  Previously, this was supported only for functional templates.  As a result, it turns out that before they wrote: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br>  With the release of C ++ 17, this construction can be replaced with this one: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br>  Type inference is implicit.  This mechanism is even more convenient to use when it comes to tuples.  Namely, before you had to write the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user (<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chy"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre> <br>  Now the same thing looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">tuple </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"M"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Chy"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br>  It is worth noting here that these features will not seem to be something worthy of attention for those who are not particularly familiar with C ++ templates. <br><br><h2>  <font color="#3AC1EF">Smart pointers</font> </h2><br>  Working with pointers in C ++ can be a real nightmare.  Due to the freedom that the language gives the programmer, it is sometimes very difficult for him, as they say, ‚Äúdo not shoot yourself in the foot.‚Äù  In many cases, it is pointers that push the programmer to such a ‚Äúshot‚Äù. <br><br>  Fortunately, in C ++ 11, smart pointers have appeared that are much more convenient than regular ones.  They help the programmer avoid memory leaks, freeing resources whenever possible.  In addition, they provide a guarantee of security for exceptions. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  <a href="https://github.com/rigtorp/awesome-modern-cpp">Here is a</a> good repository, in which, we believe, it will be interesting to look into those who follow C ++ innovations.  Something new is constantly appearing in this language.  Here we touched on only a few modern features of the language.  In fact, a lot of them.  It is possible that we will talk more about them. <br><br>  <b>Dear readers!</b>  What modern features of C ++ seem to you the most interesting and useful? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/451870/">https://habr.com/ru/post/451870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45186/index.html">Subtlely beautiful user experience</a></li>
<li><a href="../451860/index.html">Mathematicians have discovered the perfect way to multiply numbers.</a></li>
<li><a href="../451862/index.html">Joe Diprima's musical lightning: a self-taught engineer makes Tesla coils for fun and money</a></li>
<li><a href="../451864/index.html">Critical EternalBlue RCE vulnerability detected in Windows</a></li>
<li><a href="../451866/index.html">Choose the closest nodes in the network</a></li>
<li><a href="../451872/index.html">Python - an assistant in finding cheap air tickets for those who love to travel</a></li>
<li><a href="../451874/index.html">Top SEO Trends at Google</a></li>
<li><a href="../451876/index.html">Data Center in Frankfurt: Telehouse data center</a></li>
<li><a href="../451878/index.html">Live streaming stereo video to VR glasses (Oculus Go)</a></li>
<li><a href="../45188/index.html">Oddities with Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>