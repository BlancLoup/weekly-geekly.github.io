<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Distributed control system based on SoC FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Realization of the FPGA firmware bundle, NIOS microcontroller software and Linux management software based on Altera Cyclone V SoC using Avalon Mailbo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Distributed control system based on SoC FPGA</h1><div class="post__text post__text-html js-mediator-article">  Realization of the FPGA firmware bundle, NIOS microcontroller software and Linux management software based on Altera Cyclone V SoC using Avalon Mailbox to create a distributed control system based on them. <br><a name="habracut"></a><br><h1>  Introduction </h1><br>  In a distributed control system, many different tasks have to be solved at different levels. <br><br>  Some tasks should be solved at the level of an embedded PC with a full OS.  A full-fledged OS is good because it has already implemented and debugged many useful tools, such as multithreading, ready-made drivers, libraries, various frameworks and so on.  And all this can be developed in high-level languages, especially without going into implementation details at the lower level. <br><br>  There are tasks that are conveniently solved at the microcontroller level (hereinafter referred to as MK), either without an OS at all (bare-metal), or with minimalistic real-time OSs.  Here, the key role is played by the possibility of debugging software inside the OS via JTAG and tracking what is happening at the periphery of the MC at any break-point. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And there are tasks that should be solved already at the level of the FPGA, since no microcontroller may be enough for competent parallel control of different high-frequency electronics, for example, stepper drive drivers with data processing of encoders and speed controllers.  In such tasks, the processor is simply superfluous. <br><br>  The number of actuators and their various functions in the control system increases dramatically when it comes to device development, for example, with a three-degree manipulator, two-three servomotors, a dozen discrete devices, a lot of peripherals on all popular interfaces (SPI, I2C, UART and etc.) and complex logic with mathematical analysis inside.  And the whole control system is very convenient to arrange on one chip in general, which will actually be done.  As a result, all three levels of PC-MK-FPGA control and their interactions will move inside the crystal. <br><br>  In this case, the task of creating a transport level, which links all this complex logic to each other, inevitably arises.  For the MK-FPGA bundle, this is solved, in fact, by creating the next peripheral device on the MK common bus with its own set of registers.  But the task of creating a PC-MK transport level will be solved a little differently. <br><br>  For experiments, we need a real or virtual machine with Ubuntu 16.04 on board. <br>  The source code for all programs is available on <a href="https://github.com/asmaslov/hps-nios-fpga">GitHub</a> . <br><br><h1>  Management System Architecture </h1><br>  Imagine that all actuators of the control system PK-MK-FPGA are reduced to parallel I / O ports.  For example, as sensors and actuators, we will limit ourselves to a set of buttons and LEDs, and we will manage them from the terminal command line. <br><br><img src="https://habrastorage.org/webt/cz/cg/zv/czcgzvvoiezrwnykysw3899heve.png"><br><br>  All elements of the FPGA, including MK, will be synthesized.  Part of the PC is already integrated into the chip and is based on the Cortex A9, the tires of which are derived in the FPGA and can be used directly.  Therefore, all that has to be done is to connect the modules necessary for communication with the synthesized nodes in the FPGA via standard tools to the OS kernel. <br>  As a hardware platform, we use the <a href="https://rocketboards.org/foswiki/view/Documentation/AtlasSoCDevelopmentPlatform">DE0-Nano-SoC</a> kit. <br><br><h1>  Getting FPGA firmware </h1><br>  Let's take as a basis the base <strong>my_first_hps-fpga_base project</strong> from the <a href="">DE0-Nano-SoC CD-ROM set (rev.B0 / rev.C0 Board)</a> .  The project contains a pre-configured environment with correctly set FPGA ports, a ready-made <em>Cyclone V Hard Processor System</em> unit with configured memory parameters and a set of auxiliary elements in Qsys.  To work with the project, we need <a href="http://dl.altera.com/15.1/%3Fedition%3Dstandard">Quartus Prime 15.1</a> with the Cyclone V Support Package and the <a href="http://dl.altera.com/soceds/15.1/%3Fedition%3Dstandard">SoC Embedded Design Suite</a> . <br><br>  Let's make some changes to the project.  Add the NIOS core, memory for it (16 KB 32-bit width) and JTAG port.  We indicate in the NIOS parameters the addresses of the vectors from the added memory. <br><br><img src="https://habrastorage.org/webt/47/k8/o_/47k8o_gdzu2qkucl8u6rkqklvly.png"><br><br>  Avalon Mailbox is simplex, so we need two modules (like the RX and TX lines of a regular UART).  The interrupt signal of each of the modules must be connected to the processor for which the module is receiving. <br><br>  Add one port (8 bit) of input and output for further testing of the system. <br><br>  After adding all the elements you can make automatic selection of addresses and interrupts. <br><br><img src="https://habrastorage.org/webt/tr/3l/5w/tr3l5wwc_xnoo_v4zyoagdcqwqs.png"><br><br>  Let's create ports for buttons and LEDs in the code of the upper module. <br><br><pre><code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// Ports wire [7:0] port_out; assign LED = port_out; wire [7:0] port_in; assign port_in = {{2{1'b0}}, SW, KEY};</span></span></code> </pre> <br>  Connect the ports to the soc_system. <br><br><pre> <code class="hljs ruby"> /<span class="hljs-regexp"><span class="hljs-regexp">/ FPGA Partion .port_out_export(port_out), /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ port_out.export .port_in_export(port_in), /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ port_in.export</span></span></code> </pre> <br>  We will assemble the project and get the FPGA firmware, on the basis of which we will continue to work. <br><br><h1>  Algorithm </h1><br><h3>  So, create a system that will do the following: </h3><br><ul><li>  When the switch is turned on, the timer is activated; </li><li>  On the timer with a frequency of 1 Hz, one of the LEDs will light up in order; </li><li>  By pressing the button, the direction will change; </li><li>  Upon receipt of the READ command from the PC, the current active LED number will be sent to the standard Linux console; </li><li>  Upon receipt of the WRITE command from the PC, the current active diode will change; </li><li>  When receiving the REVERSE command from the PC, the direction will change, as well as from the button; </li><li>  By pressing another button, the number of LED switches from the time of the last reverse will be sent to the PC console. </li></ul><br><h1>  On the side of MK </h1><br>  In the NIOS II EDS environment, which in essence is Eclipse with all the necessary plug-ins, we will create a new <strong>soc_nios</strong> project from the ‚ÄúNIOS II Application and BSP‚Äù template.  The result will be two projects: direct firmware and BSP. <br><br>  First of all, you need to immediately assemble a BSP, but not in the traditional way.  Instead, in the context menu of the <strong>soc_nios_bsp</strong> project, <strong>you</strong> need to select the <em>BSP Editor</em> item in the <em>NIOS II</em> menu and enable the <em>enable_small_c_library</em> and <em>enable_reduced_device_drivers</em> options so that the firmware does not grow.  Then build by clicking <em>Generate</em> .  Further, since the build parameters are preserved, you can rebuild the BSP simply by selecting the <em>Generate BSP</em> item in the <em>NIOS II</em> menu. <br><br>  In the <strong>system.h</strong> file from the BSP project, you can see all the parameters of the MK peripherals that were previously added to the Qsys scheme. <br><br>  You can read more about NIOS and how to build projects for it <a href="https://marsohod.org/projects/marsohod2/274-nios2">here</a> . <br><br><h3>  To solve the problem at the level of MK, we need: </h3><br><ul><li>  Timer interrupt handler; <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIMER_0_ISR</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* context)</span></span></span><span class="hljs-function"> </span></span>{ IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_0_BASE, <span class="hljs-number"><span class="hljs-number">0</span></span>); IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_0_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK); led += step; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(led &gt; LED_MAX) { led = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(led &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { led = LED_MAX; } IOWR_ALTERA_AVALON_PIO_DATA(PORT_OUT_0_BASE, (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; led)); count++; IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_0_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK); }</code> </pre> </li><li>  Mailbox interrupt handler; <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAILBOX_HPS2NIOS_ISR</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* context)</span></span></span><span class="hljs-function"> </span></span>{ IOWR_ALTERA_AVALON_MAILBOX_INTR(MAILBOX_SIMPLE_HPS2NIOS_BASE, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment"> Order is important! CMD register should be read after PTR register buffer[1] = IORD_ALTERA_AVALON_MAILBOX_PTR(MAILBOX_SIMPLE_HPS2NIOS_BASE); buffer[0] = IORD_ALTERA_AVALON_MAILBOX_CMD(MAILBOX_SIMPLE_HPS2NIOS_BASE); alt_printf("Reading: 0x%x 0x%x\n\r", buffer[0], buffer[1]); newMail = true; IOWR_ALTERA_AVALON_MAILBOX_INTR(MAILBOX_SIMPLE_HPS2NIOS_BASE, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_PEN_MSK); }</span></span></code> </pre> </li><li>  Message parser and write function in Mailbox; </li><li>  The functions of polling buttons and control LEDs. </li></ul><br>  It remains to collect the project.  The NIOS firmware size should be less than 16 Kb. <br>  To test the firmware on the hardware, you need to create a new debugger configuration.  After the FPGA firmware from the Quartus Programmer in the <em>Debug Configurations</em> menu, select the <em>NIOS II Hardware</em> option, update all interfaces and in the <em>Target Connections</em> tab we find <em>jtaguart_1</em> .  This is the same JTAG for NIOS, which we previously added to Qsys. <br><br>  Now you can start debugging from Eclipse.  If everything is done correctly, the message ‚ÄúTurn the switch ON to activate the timer‚Äù should appear in the NIOS II console. <br><br><h1>  PC side </h1><br><h2>  Installing Linux on the board </h2><br>  In detail, the whole process is described <a href="https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide">here</a> in sections 1 through 10. It is recommended to use more recent fresh versions of the <a href="https://releases.linaro.org/components/toolchain/binaries/6.4-2017.11/arm-linux-gnueabihf/">toolchain</a> , <a href="https://github.com/altera-opensource/u-boot-socfpga/releases/tag/rel_socfpga_v2013.01.01_17.12.01_pr">bootloader</a> and <a href="https://github.com/altera-opensource/linux-socfpga/releases/tag/rel_socfpga-4.13_17.12.01_pr">kernel</a> than those that can be found by reference.  Please note that for building this version of the bootloader, the toolchain with the compiler above version 6 will not work. <br><br>  To generate a device tree, instead of the proposed sopc2dts utility, it is better to use the sopc2dts.jar script, and you can specify <em>--type dtb</em> right <em>away</em> . <br><br>  To get the system it is strongly recommended to use the freshest <a href="https://buildroot.org/downloads/">Buildroot</a> .  To build, you must force the CC environment variables as the path to arm-linux-gnueabihf-gcc and CXX as the path to arm-linux-gnueabihf-g ++ from the toolchain.  Next, enter the used versions of the compiler, the kernel and the library (the system itself prompts them during the build process).  In the configuration of the toolchain when configuring Buildroot, you must specify the path to the toolchain, as well as the prefix $ (ARCH) -linux-gnueabihf and enable support for SSP, RPC and C ++. <br>  For convenience, you can add nano, mc, and openssh packages to Buildroot. <br>  Next, we will collect all the top-level software in <a href="http://www.eclipse.org/downloads/packages/eclipse-ide-cc-developers/neon3">Eclipse</a> with the <a href="https://gnu-mcu-eclipse.github.io/">GNU MCU Eclipse plug-in plug-in</a> .  Create a new workspace for ARM projects and in the global Eclipse settings in the <em>Workspace Tools Path</em> section, specify the appropriate path to the installed version of Linaro. <br><br><h2>  Driver </h2><br>  First of all, let's make a driver for Mailboxes.  Create a new <strong>nios_mailbox</strong> project from the Hello World ARM C Project template in Eclipse. <br><br>  In the project settings, turn off the ‚ÄúUse default build command‚Äù and ‚ÄúGenerate Makefiles automatically‚Äù options, since to build the kernel module you will need the command <em>make TARGET = nios_mailbox TARGET_DIR = Default</em> .  Add two new CROSS_COMPILE and KDIR entries to the environment variables, pointing to the full path with the tulchain prefix and the path to the kernel sources, respectively.  Add __GNUC__, __KERNEL__ and MODULE to the list of defines.  Everything.  Now you can write code. <br><br>  The kernel module will respond to an interrupt from hardware and must somehow communicate this to the application world.  For this purpose we need to create our own signal. <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NIOS_MAILBOX_REALTIME_SIGNO 44</span></span></code> </pre> <br>  The driver will be created on the basis of platform_device, each Mailbox will be like a miscdevice, and ultimately the system will be visible as a device file in the / dev directory.  More details about the drivers and generally you can read <a href="http://www.linuxcenter.ru/lib/books/lkmpg.phtml">here</a> .  It is important to understand that we can theoretically have as many Mailboxes as we like, and the driver is one for all, and it should initialize and number them all. <br><br>  If you don‚Äôt specifically go into details, the driver development comes down to the implementation of standard read and write operations to the file, plus a small bonus in the form of a special ioctl () function, which is needed for the id of the process that uses it to pass to the driver.  This is necessary in order to know which process in the system signals the occurrence of a hardware interrupt.  The interrupt handler itself looks pretty simple and is very similar to its counterpart in NIOS. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> irq_handler_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nios_mailbox_isr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> irq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pdev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nios_mailbox_dev</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nios_mailbox_dev</span></span></span><span class="hljs-class">*)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_get_drvdata</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pdev</span></span></span><span class="hljs-class">);</span></span> spin_lock(&amp;dev-&gt;lock); <span class="hljs-comment"><span class="hljs-comment">//</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment"> Order is important! CMD register should be read after PTR register dev-&gt;data[1] = ioread32(dev-&gt;regs + ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST * sizeof(u32)); dev-&gt;data[0] = ioread32(dev-&gt;regs + ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST * sizeof(u32)); spin_unlock(&amp;dev-&gt;lock); if(dev-&gt;task) { send_sig_info(dev-&gt;sinfo.si_signo, &amp;dev-&gt;sinfo, dev-&gt;task); } return (irq_handler_t)IRQ_HANDLED; }</span></span></code> </pre> <br>  It remains to collect the project.  To do this, we need to write a special Makefile.  It will look like this. <br><br><pre> <code class="hljs ruby"> <span class="hljs-symbol"><span class="hljs-symbol">all:</span></span> @echo <span class="hljs-string"><span class="hljs-string">'KDIR=$(KDIR)'</span></span> @echo <span class="hljs-string"><span class="hljs-string">'CROSS_COMPILE=$(CROSS_COMPILE)'</span></span> @if [ ! -d $(CURDIR)/$(TARGET_DIR) ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> mkdir $(CURDIR)/$(TARGET_DIR); fi cp $(TARGET).c $(CURDIR)/$(TARGET_DIR) cp $(TARGET).h $(CURDIR)/$(TARGET_DIR) cp Kbuild $(CURDIR)/$(TARGET_DIR) $(MAKE) -C $(KDIR) ARCH=arm M=$(CURDIR)/$(TARGET_DIR) <span class="hljs-symbol"><span class="hljs-symbol">clean:</span></span> rm -rf main $(CURDIR)/$(TARGET_DIR)</code> </pre> <br>  And we will also need to create a Kbuild file with one line. <br><br><pre> <code class="hljs mel"> obj-m := $(TARGET).o</code> </pre> <br>  Let's collect the project in the traditional way.  As a result, we get the kernel module <strong>nios_mailbox.ko</strong> , which we copy onto the system and install it using insmod.  If everything is done correctly, in a Linux console opened via USB, when you press the corresponding button on the board, a message from the kernel ‚Äú[.........] NIOS Mailbox new mail!‚Äù Should appear. <br><br>  Of course, the driver would need to add a buffer for the received interrupt data, since the reading by the application program may not keep pace with the data stream from the iron.  And the driver itself is better to assemble with the <em>stripped</em> option, to save space in the embedded system.  However, these questions will be left to the reader for independent study. <br><br><h2>  application </h2><br>  So we got to writing a console application.  Create a new project <strong>soc_test</strong> in the Eclipse project from the Hello World ARM C ++ Project template.  In the <em>Settings</em> section of the <em>Target Processor,</em> select the cortex-a9 architecture, in the <em>Cross ARM GNU G ++ Linker,</em> add <em>-pthread</em> .  In the <em>Build Artifact</em> tab, you can remove the file extension.  All other settings can be left as default. <br><br><h3>  To solve the problem at the application level, we need: </h3><br><ul><li>  Signal handler; <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Nios::mailbox_nios2hps_signal_handler(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> signo, <span class="hljs-keyword"><span class="hljs-keyword">siginfo_t</span></span> *info, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *unused) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(info-&gt;si_signo == NIOS_MAILBOX_REALTIME_SIGNO) { sem_post(&amp;mailbox_nios2hps_signal_semaphore); } }</code> </pre> <br>  Message parser from Mailbox; <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *Nios::mailbox_nios2hps_data_reader(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *args) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> mes; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(sem_wait(&amp;mailbox_nios2hps_signal_semaphore)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(lseek(mailbox_nios2hps, <span class="hljs-number"><span class="hljs-number">0</span></span>, SEEK_SET) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Failed to seek mailbox_nios2hps to proper location"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } read(mailbox_nios2hps, &amp;mes, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(mes)); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"[HARDWARE] Reading: 0x%08x 0x%08x\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)mes, (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)(mes &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)mes) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LED_NUMBER: <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Active led %lu\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)(mes &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SWITCH_COUNT: <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Led switched %lu times\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)(mes &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> </li><li>  The function of sending messages to the Mailbox; <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Nios::mailbox_hps2nios_write(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> mes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(lseek(mailbox_hps2nios, <span class="hljs-number"><span class="hljs-number">0</span></span>, SEEK_SET) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Failed to seek mailbox_hps2nios to proper location"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"[HARDWARE] Writing: 0x%08x 0x%08x\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)mes, (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)(mes &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>)); write(mailbox_hps2nios, &amp;mes, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(mes)); } }</code> </pre> </li><li>  The setup procedure with the device files that appeared after installing the driver; <br><br><pre> <code class="cpp hljs">Nios::Nios () { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sigaction</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">backup_action</span></span></span><span class="hljs-class">;</span></span> pid = getpid(); mailbox_nios2hps = open(<span class="hljs-string"><span class="hljs-string">"/dev/nios_mailbox_0"</span></span>, O_RDONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mailbox_nios2hps &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Could not open \"/dev/nios_mailbox_0\"..."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;mailbox_nios2hps_action, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct sigaction)); mailbox_nios2hps_action.sa_sigaction = mailbox_nios2hps_signal_handler; mailbox_nios2hps_action.sa_flags = SA_SIGINFO | SA_NODEFER; sigaction(NIOS_MAILBOX_REALTIME_SIGNO, &amp;mailbox_nios2hps_action, &amp;backup_action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ioctl(mailbox_nios2hps, IOCTL_SET_PID, &amp;pid)) { <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Failed IOCTL_SET_PID"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; close(mailbox_nios2hps); sigaction(NIOS_MAILBOX_REALTIME_SIGNO, &amp;backup_action, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } mailbox_hps2nios = open(<span class="hljs-string"><span class="hljs-string">"/dev/nios_mailbox_1"</span></span>, (O_WRONLY | O_SYNC)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mailbox_hps2nios &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Could not open \"/dev/nios_mailbox_1\"..."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; close(mailbox_nios2hps); sigaction(NIOS_MAILBOX_REALTIME_SIGNO, &amp;backup_action, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } pthread_create(&amp;nios2hps_data_reader_thread, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, mailbox_nios2hps_data_reader, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); }</code> </pre> </li><li>  Parser console commands. </li></ul><br>  It remains to collect the project.  As a result, we obtain an executable file for the ARM-9 architecture, which we copy to the system.  If everything is done correctly, then after launch, the message ‚ÄúEnter command (‚Äù read ‚Äù(‚Äú r ‚Äù),‚Äú write ‚Äù(‚Äú w ‚Äù),‚Äú reverse ‚Äù),‚Äú q ‚Äùto exit" will appear in the console. <br><br><h1>  Run and check the system </h1><br>  Installing the kernel module is added to the autoload for Linux. <br><br>  We will assemble a new version of the NIOS firmware, removing the entire debugging output from the program in JTAG.  Let's convert the firmware to hex format by running the command ‚Äúelf2hex --input = soc_nios.elf --output = soc_nios.hex --width = 32 --base = 0x4000 --end = 0x7fff --record = 4‚Äù in <em>SoC EDS 15.1 Command Shell</em> .  The resulting firmware must be added as an initialization file for NIOS memory in Qsys, then rebuild Qsys, rebuild the FPGA project and write the new firmware to the memory card. <br><br><img src="https://habrastorage.org/webt/s5/uj/go/s5ujgoj3gifrp7lrrilenmd4nwy.png"><br><br>  Download and immediately launch the test application.  And if everything was done correctly, then we get a working system. <br><br><h1>  findings </h1><br>  Do not be afraid to use such complex bundles as FPGA-MK-PC based on SoC in your projects.  This article demonstrated that implementing such a system is not so difficult.  You can even add several microcontrollers and link them together in a similar way. <br><br>  The control system, created on the basis of the principles outlined above, was introduced by the author into one of the electronic devices and proved its efficiency in the real world. <br><br></div><p>Source: <a href="https://habr.com/ru/post/353680/">https://habr.com/ru/post/353680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353668/index.html">Interfaces: how to tell the user if ‚ÄúOops, something went wrong‚Äù</a></li>
<li><a href="../353672/index.html">Distribution of static content - an account for milliseconds</a></li>
<li><a href="../353674/index.html">Divorce as it is (or "confirmation confirmation discord!")</a></li>
<li><a href="../353676/index.html">Attention! S in Ethereum stands for Security. Part 4. Tools</a></li>
<li><a href="../353678/index.html">Reverse engineering "Kazakov 3", part of the network: create a local server</a></li>
<li><a href="../353682/index.html">DevConf: Uber transition from PostgreSQL to MySQL</a></li>
<li><a href="../353684/index.html">One small ventilation</a></li>
<li><a href="../353686/index.html">"Closer to 5G": VMware helps telecom operators deploy new generation networks</a></li>
<li><a href="../353692/index.html">What business and users face the struggle of RKN and Telegram? Expert opinions</a></li>
<li><a href="../353696/index.html">Challenges and challenges in Enterprise E-Commerce. How did the project Virto Commerce?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>