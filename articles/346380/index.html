<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Just about microservices</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Almost every second person who first encounters with MSA (Micro Service Architecture) at first exclaims: ‚ÄúYes, I still have these micro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Just about microservices</h1><div class="post__text post__text-html js-mediator-article"><h3>  Introduction </h3><br>  Almost every second person who first encounters with MSA (Micro Service Architecture) at first exclaims: ‚ÄúYes, I still have these microservices ... more than twenty years ago."  In part, they are right.  And I, too, was from this very half, and did not understand why such noise? <br><br><img src="https://habrastorage.org/webt/ok/j0/ow/okj0owc15yytxtktz5eqwcj7nyu.jpeg"><br><br>  Indeed!  After all, MSA is also about software development.  What kind of revolution can there be?  All techniques are familiar.  In some places one may even wonder: ‚ÄúIs it really different?‚Äù  Fans of Agile and DevOps will also say that this is all ours, dear. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But I ask you to be patient and continue reading further. <br><a name="habracut"></a><br><h3>  What is microservice architecture (MSA) </h3><br>  To paraphrase Wikipedia, the definition of microservice architecture can be as follows: <br><blockquote>  MSA is the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF">principle</a> organization of a distributed <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0">system</a> based on microservices and their interaction with each other and with the environment over the network, as well as the principles that guide the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">design of the</a> architecture, its creation and evolution. </blockquote><br><h3>  What is microservice (MS) </h3><br>  With architecture sorted out quickly.  With microservices let's more in detail. <br><blockquote>  It is easiest to understand the essence of microservice by comparing, or even contrasting it with a large application - a monolith.  Unlike MSA, I will not define microservice, but list its most important characteristics. <br></blockquote><br>  And then we look at each of them in more detail. <br><br><img src="https://habrastorage.org/webt/bj/d9/xb/bjd9xbo0eecxrtpmg4oh83wjdru.png"><br><br>  I highlighted eight properties of microservice: <br><br><ol><li>  He is not big. </li><li>  He is independent. </li><li>  It is built around a business need and uses a limited context <i>(Bounded Context)</i> . </li><li>  It interacts with other microservices over the network based on the pattern of <i>Smart endpoints and dumb pipes.</i> </li><li>  Its distributed essence obliges to use the <i>Design for failure</i> approach. </li><li>  Centralization is bounded above at the minimum. </li><li>  The processes of its development and support require automation. </li><li>  Its development is iterative. </li></ol><br>  Already at this point, those who allegedly created microservices in prehistoric times should think whether everything was really so advanced ... Personally, at this stage I moved into the category of doubters. <br><br><h3>  Small </h3><br>  What is ‚Äúsmall‚Äù?  Such a uninformative wording!  Actually, you can‚Äôt tell otherwise.  Each must independently determine the size.  Best in practice.  As an indicative assessment can be guided by the recommendations of experts.  The size of microservice should be such that one of the following conditions is met: <br><br><ol><li>  One service can be developed by one team of no more than a dozen people. </li><li>  A team of half a dozen people can develop half a dozen services. </li><li>  The context (not only of business, but also of development) of one service is placed in the head of one person. </li><li>  One service can be completely rewritten by one team for one Agile iteration. </li></ol><br><h3>  Independent </h3><br>  Microservice architecture is the epitome of High Cohesion and Low Coupling patterns.  Everything that contradicts this is rejected mercilessly.  Otherwise, the team will face big problems.  So microservice must be an independent component. <br><br>  Here I ask you not to start a holivar about what a ‚Äúcomponent‚Äù is.  In this article, let's get together on the fact that <br><blockquote>  <b>A component</b> is a software unit whose code can be independently replaced or updated. </blockquote><br>  Of course, any more or less serious program is written with a division into components, which, of course, are based on the same principles.  But in a monolith, a common code base opens up possibilities for breaking low connectivity.  And with a weak discipline, sooner or later the code turns into spaghetti. <br><br>  Third-party libraries are also suitable for this component formulation.  Here it is more difficult with violation of boundaries by arbitrary links, but not by a lot. <br><br>  At the same time, the methodology of splitting into separate microservices forces them to adhere to their strict separation, because they must meet more stringent criteria of independence. <br><br>  So, each microservice works in its own process and therefore must explicitly define its own API.  Considering that other components can use only this API, and besides, it is remote, minimization of connections becomes vital. <br><br><img src="https://habrastorage.org/webt/rn/vt/0c/rnvt0c19vxobzqmozokk0m_wa7y.png"><br><br>  This separation gives a clear gain in terms of the independent development of different components.  And with this in mind, various languages ‚Äã‚Äãintroduce constructions that allow the explicit creation of independent components (for example, modules in Java 9), and this is no longer the prerogative of the microservice approach. <br><br>  I don‚Äôt want the impression that the use of libraries is prohibited in the microservice architecture.  Their use is <b>not welcome</b> , because somehow it leads to dependencies between microservices, but it is still <b>allowed</b> .  As a rule, this assumption applies to infrastructure functions such as logging, calling a remote API, error handling, and the like. <br><br>  Independence of microservices allows you to organize an independent development life cycle, create individual assemblies, test and deploy. <br><br>  Since the size of microservices is small, it is obvious that there will be a lot of them in large systems.  Managing them manually will be difficult.  Therefore, the team must have an acceptable level of automation according to <i>Continuous Integration</i> and <i>Continuous Delivery.</i> <br><br><h3>  Where is microservice (business need) </h3><br>  So, you decided to design a new microservice. <br><br>  Defining its boundaries is the most important step.  The whole future life of microservice will depend on this, and this will seriously affect the life of the team responsible for it. <br><br>  The main principle of determining the microservice responsibility area is to form it around a certain business need.  And the smaller it is, the more formalized its relationship with other areas, the easier it is to create a new microservice.  In general, a fairly standard message.  It is based on the creation of any other components.  The only question is to continue to withstand this area of ‚Äã‚Äãresponsibility, which we discussed in the previous paragraph. <br><br>  When the boundaries of microservice are set and it is highlighted in a separate code base, it is easy to protect these boundaries from unwanted influence.  Further, inside the microservice create their own microcosm, based on the pattern of "limited context".  In microservice for any object, for any action there can be its own interpretation, different from other contexts. <br><br><img src="https://habrastorage.org/webt/of/6a/z9/of6az9hfqd4ry1fewqpzwyvsame.png"><br><br>  But what if the borders were wrong?  In this case, a change in functionality in a new microservice leads to a change in functionality in other microservices.  As a result, the interfaces of all dependent microservices will ‚Äúfloat‚Äù, followed by integration tests.  And everything turns into a snowball.  And if these microservices also belong to different teams, then inter-team meetings, coordination and the like begin.  So the correct boundaries of microservice are the basis of a healthy microservice architecture. <br><br>  To minimize errors in determining the boundaries, you must first think them over.  Therefore, the Monolith First approach is justified, when the system is first developed in the traditional paradigm, and when established areas appear, they are distinguished into microservices.  But everything flows and changes.  And the boundaries can also change.  The main thing is that the gain from splitting exceeds the difficulty of revising these boundaries.  Such an approach to the gradual formation of a set of microservices is similar to the iterative development used in Agile, also called ‚ÄúEvolutionary Design‚Äù. <br><br>  There is another interesting consequence of the creation of microservices, corresponding to Conway's law (Conwey Law). <br><br>  If an organization uses a monolithic application, then it violates compliance with the structure and communications within the organization.  And the development teams are built around the architectural layers of the monolith: UI, server logic, database. <br><br>  Microservice architecture brings IT and business in harmony, from the point of view of Conway.  Since microservices are formed around the business needs of specific business units, the enterprise architecture begins to repeat the organizational structure and channels of social and business communication.  And teams become cross-functional and form around these business needs / business units. <br><br><img src="https://habrastorage.org/webt/ca/tl/0s/catl0sdldxdk3aj3tlietvnwkum.png"><br><br>  Since different microservices are independent not only logically but also technologically, and different teams can create them, nothing prevents you from choosing suitable programming languages, frameworks and even operating systems for each case. <br><br><h3>  Integration.  Smart endpoints and dumb pipes </h3><br>  Integration of microservices dispenses with ESB, as a central intermediate.  Probably, the community has already suffered from unsuccessful options for implementing this approach.  What was and successful - not taken into account.  However, the ESB also contradicts such criteria as decentralization and independence.  Thus, the complexity of integration is distributed from the central level in the form of an ESB directly to the components to be integrated: ‚Äúsmart end points‚Äù. <br><br><img src="https://habrastorage.org/webt/ah/vi/ns/ahvins4kzy5nnsijlp6ek2ouqvo.png"><br><br>  As a rule, simple text protocols based on HTTP are used for integration in order to offset possible technological differences between microservices.  REST-like protocols are practically standard.  As an exception, binary protocols like Java RMI or .NET Remoting can be used. <br><br>  There is a dilemma.  Of course, binary protocols are much more efficient.  But, first, there are technological limitations.  Secondly, on binary protocols it is more difficult to implement the Tolerant Reader pattern, while maintaining efficiency.  Thirdly, the dependence of the provider and consumers appears again, since they operate on the same objects and methods, that is, are linked by code base. <br><br>  Another distinctive feature of the interaction of microservices - synchronous calls are not welcome.  It is recommended to use one synchronous call per user request, or refuse from synchronous calls altogether. <br><br>  And a couple of comments. <br><br><ol><li>  The main difficulty of splitting a monolith into microservices is not defining their boundaries.  They should already be formed and settled.  The difficulty is that local calls become remote.  And this affects not only the organization of calls, but also the style of interaction, since frequent calls are no longer suitable.  Most likely, it is necessary to revise the API itself, make it larger, and, as a result, revise the logic of the components. </li><li>  Since asynchronous event interaction is practically a standard in the microservice architecture, it is necessary to understand the creation of event-driven architecture (Event Driven Architecture), and microservices themselves must comply with the requirements of Reactive. </li></ol><br><h3>  <i>Design for failure</i> for a distributed system </h3><br>  One of the most critical places in the microservice architecture is the need to develop code for a distributed system, the constituent elements of which interact through a network. <br><br>  And the network is unreliable in nature.  The network can simply refuse, it can work badly, it can suddenly stop missing some type of messages, because the firewall settings have changed.  Dozens of causes and types of inaccessibility. <br><br><img src="https://habrastorage.org/webt/kg/n1/wi/kgn1wiyd5yekywjygw-6teqpzb8.png"><br><br>  Therefore, microservices may suddenly stop responding, may begin to respond more slowly than usual.  And every remote call must take this into account.  Must properly handle different options for failure, be able to wait, be able to return to normal operation when the counterparty is restored. <br><br>  An additional level of complexity brings event architecture.  And the debugging of such a system is not one microservice, but systems where many streams of multidirectional disordered events are difficult to imagine.  And even if each of the microservices will be flawless in terms of business logic, this is not enough.  By analogy with sports, ‚Äústars‚Äù do not guarantee a star team, because in a team, not the ‚Äústars‚Äù are more important, but the coherence of all its players. <br><br><img src="https://habrastorage.org/webt/tc/wt/rx/tcwtrxanxsgpxur0zecw4xfc9rs.png"><br><br>  And since the complexity of such systems is very high, the problem is solved as follows. <br><br><ul><li>  Do not bring the system to the state "without a hitch without a hitch."  It is very expensive.  Of course, this does not mean that the system falls from the first whiff.  It simply meets the necessary non-functional requirements.  But it may contain errors that slightly affect its stability and performance. </li><li>  On the other hand, they invest in infrastructure, which helps to eliminate abnormal situations more quickly.  There should be full coverage of unit code tests, integration tests and performance tests.  There should be intellectual monitoring, which not only instantly shows non-working places, but also signals the deterioration of the system state with prediction of possible failures.  There should be an advanced distributed logging, allowing for prompt investigations.  And often the results correct hidden errors. </li></ul><br>  All this is useful for any monolith, but for microservices such infrastructure is a matter of life and death. <br><br><h3>  Data decentralization </h3><br>  Another one of the most important elements in the microservice paradigm. <br><blockquote>  Each microservice in its database! </blockquote><br>  Populist slogan on the election. <br><br>  In fact, in the monolith, you can fight for the isolation of components, for example, at the level of server code.  If isolation occasionally leaks, modern tools offer advanced refactoring tools.  Use.  Although, as a rule, there is time for this only when things are already very bad. <br><br>  Now we will lower down, on database level.  For some reason, attention here is much less often paid to isolation.  As a result, after a couple of three years of active development in the monolith database, the entropy of the advanced level is formed if not chaos.  To overcome it, there is not enough one line in backlog.  It takes months of hard and long work. <br><br>  In microservice architecture, this is solved by the guillotine.  There is simply no common database. <br><br>  In addition to isolation, there are side advantages.  For example, it is easier to implement <i>Polyglot Persistence</i> when the base is selected for specific goals.  Nothing prevents you from doing this without microservices, and they often do this.  But nevertheless in one case it is the law, in another - an exception. <br><br><img src="https://habrastorage.org/webt/u7/uc/gw/u7ucgwdqv2mrehtae0p6ycuqb9s.png"><br><br>  This medal has a downside.  Many bases, many contexts, how to harmonize them all?  The old technique of distributed transactions is complex and has low speed.  Perhaps this can sometimes be experienced.  But the need for simultaneous interaction of several microservices can not arrange, and it can not be overcome. <br><br>  The problem is solved unconventionally for the monolith: the rejection of the constant consistency of data.  Welcome to the world of <i>Eventual consistency</i> .  At first, this causes a wave of ‚Äújust‚Äù anger.  But if you figure it out, is immediate data consistency needed at the end of the transaction everywhere?  On closer examination, a significant portion of cases can be dropped.  Where possible, replace a single distributed transaction with a series of local transactions with compensation mechanisms.  Somewhere they put up with a temporary inconsistency.  And possible errors are either processed at the expense of a more complex architecture, or due to monitoring data.  If nothing happens, then in extreme cases, they use distributed transactions.  But this, from my point of view, is a violation of the principles of MSA. <br><br><img src="https://habrastorage.org/webt/uz/fq/5t/uzfq5tekz31dstbu5db37hwfn6k.png"><br><br><h3>  Monolith against microservices </h3><br>  The microservice approach carries quite a lot of problems.  They are not difficult to find and everyone can exercise. <br><br>  For example, organizational issues.  How to keep a hundred microservices in a state-coordinated version that are constantly and unpredictably redefined.  And access to the environments of each engineer of each team?  Which team will write integration tests?  And if someone agrees, then try again to write them for such a confusing configuration.  And if an error occurs, then whose is it?  Only the team that broke?  How not to know on Friday evening that the API version of the Nth service you are using has suddenly become deprecated? <br><br>  Yes, these are really problems.  But teams that practice Agile and DevOps already know the solution.  Therefore, to begin the path to microservice architecture is the introduction of these practices. <br><br>  In addition to organizational and purely architectural.  How to move from a monolith, where everything is synchronous, consistent and uniform, to a distributed event architecture based on many small elements, in which possible inconsistency of data should be taken into account?  This alone is enough to think: is the game worth the candle?  Against this background, for example, a drop in the speed of processing a single request seems trivial.  At least it works! <br><br><img src="https://habrastorage.org/webt/yg/2g/db/yg2gdbssf72cjsbmoxlcjittrfe.jpeg"><br><br>  Then why?  If you have no problems with your "monolith", then do not look for them. <br><br>  But if there is a problem, then look at the advantages of MSA, and maybe it will save you. <br><br>  The division into independent components gives unconditional and incontestable advantages: easy understanding of the context, flexibility of development, management and scaling.  Independence and small size provide unexpected advantages in terms of infrastructure.  You no longer need a monster machine for $ 100,500.  Microservices can be installed on ordinary cheap cars.  And it turns out that even all together they will cost an order of magnitude less, but to work more efficiently than the very super machine that you, for sure, in your organization, pray and blow dust particles off of it. <br><br>  Here another slogan from the populist is appropriate.  Although, like the previous one, it is quite serious. <br><blockquote>  Each microservice on the server! </blockquote><br>  We continue to agitate for microservices.  Look at the leaders of the IT industry: Amazon, Netflix, Google and others show impressive results.  Their flexibility and speed of output of new products are amazing.  Therefore, the game is definitely worth the candle!  It is appropriate to recall here that in the above-mentioned organizations of the ‚Äúlevel of god‚Äù teams there is not one and not two.  The complexity of microservice architecture is in the teeth.  And if you propose to create a monolith, then they will make it so that it will shine a guiding star. <br><br>  And, for example, Amazon worked for itself on a monolith, already being a giant and having billions of dollars in turnover.  The site of the Guardian newspaper is still, and possibly forever, based on microservices around the monolith.  This suggests that a significant part of the tasks successfully, and often easier, is solved without the involvement of microservices. <br><br>  And yet this does not mean that microservices are not for you.  Not gods burn pots.  But rushing headlong into the pool is also not worth it.  For microservice architecture, the team should be quite mature.  One of the main criteria: Does it use Agile and DevOps?  The team must be competent.  It is difficult to formalize, but still try to soberly assess the possibilities.  For example, how advanced is the team in Reactive and Event-Driven Architecture?  In addition, the team must have a prepared infrastructure to support the microservice system. <br><br>  However, enough.  Just try it.  I hope, it will turn out and enjoy. </div><p>Source: <a href="https://habr.com/ru/post/346380/">https://habr.com/ru/post/346380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346368/index.html">3CX server integration with Bitrix24</a></li>
<li><a href="../346370/index.html">How to create an in-game menu in Unity</a></li>
<li><a href="../346372/index.html">Crime and punishment for owners of critical information infrastructure of the Russian Federation</a></li>
<li><a href="../346374/index.html">Why we didn‚Äôt do it perfectly: how the infrastructure of the War Robots servers was changing</a></li>
<li><a href="../346378/index.html">News from the world of OpenStreetMap ‚Ññ 389 (26.12.2017-01.01.2018)</a></li>
<li><a href="../346382/index.html">Suddenly: a new version of ONLYOFFICE with macros</a></li>
<li><a href="../346384/index.html">Event digest for HR specialists in IT-area for January 2018</a></li>
<li><a href="../346386/index.html">About the peculiarities of using VPN Zaborona on routers for bypassing locks in Ukraine</a></li>
<li><a href="../346388/index.html">Lindenmeyer systems</a></li>
<li><a href="../346390/index.html">We invite speakers at PHDays: tell us how you see the digital state</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>