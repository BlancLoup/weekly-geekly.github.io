<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parallel IEnumerable processing in .NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The proposed article discusses the solution of the parallel synchronous processing IEnumerable problem, as well as where the task came from. 

 As in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parallel IEnumerable processing in .NET</h1><div class="post__text post__text-html js-mediator-article"> The proposed article discusses the solution of the parallel synchronous processing <code>IEnumerable</code> problem, as well as where the task came from. <br><a name="habracut"></a><br>  As in many other cases, the solution presented began with very specific needs. <br><br><h1>  Preamble </h1><br>  In one of the internal projects there is a need to build a spreading report for 100+ slices on the data file, which takes more than 12 hours to read.  The data volumes themselves are also rather big.  The combination of continuous reading and huge amounts of data (~ 1.5M tuples, each weighing up to 50 MB) introduces two limitations to the code: the extreme undesirability of multiple readings (unfortunately, nobody is ready to spend 50 days on the weekly report) and the technical impossibility placing the entire sample into RAM.  The development process that preceded me went, obviously, iteratively: the length of the method that aggregates the data for the slices was about 4000 lines.  Before me was tasked to make this code turned into supported. <br><br><h1>  Prerequisites </h1><br>  The thread of Ariadne in the current situation for me was the realization that ‚Äúlicking‚Äù one and the same entity in turn (as well as the chupa chups) is at least ugly: even if I manage to refactor the code to the ‚Äúslice-method‚Äù state, then I will get a sheet of more than a hundred consecutive calls hung with conditions.  I also wanted to get away from this, since the current implementation not only rested against slow reading, but also added a slip on top of processing data in one stream.  The server on which the process is executed has 8 cores and is able to parallelize the data processing to such a state that it will take less time than reading the next tuple from the database. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Idea </h1><br>  So, after weighing the situation, I formulated a straightforward idea: handle the ‚Äúflow of objects‚Äù in parallel threads (threads), where each slice has its own neat method (or even lambda) that runs in a separate thread.  Since we are not aware of the number of objects initially, the <code>IEnumerable&lt;T&gt;</code> interface was perfectly suited for representing the ‚Äúflow of objects‚Äù.  It only remains to make sure that each thread has its own <code>IEnumerable&lt;T&gt;</code> , and that it is the same <code>IEnumerable&lt;T&gt;</code> (just like in the tasks about <a href="http://rcub.ru/zadachki-s-podvoxom/monetki-v-stakane.html">coins and glasses</a> ).  It is obvious that the nickname "clones" immediately stuck to such objects. <br><br>  It was necessary to ensure that on each <code>enumerable.Next()</code> streams, a single object instance was readable.  Such a solution has a peculiarity (this is rather a minus, but not terrible): all threads will wait for the slowest brother, that is, the reading will be synchronous.  To be honest, I really hoped that someone had already written it for me.  For example, Microsoft did something similar in its Parallel.Linq.  However, at that time it was not possible to google anything like that - everything related to parallel processing of collections was related to parallel processing of parts of one collection (for example, <code>Parallel.For()</code> ), but not at all to the problem being solved.  Well, I adore bicycles, a file in hands! <br><br><h1>  Core solution </h1><br>  There was always an understanding in my head that an object was hidden behind any interface.  Therefore, to clone a collection, you probably need to either find or invent an object with the desired interface.  And here it is not necessary.  The C # language has long and successfully been giving its adherents the operators <a href="http://msdn.microsoft.com/en-us/library/vstudio/9k7k7cf0.aspx"><code>yield return</code> and <code>yield break</code></a> .  Their application formed the basis of the decision. <br><br>  I think it makes no sense to explain how each line of code was born.  I will explain the idea.  In order for your data to become large, a factory object is created with the <code>GetClone()</code> method, which returns a call to the method using the <code>yield</code> .  So that the reading was synchronized and no one lost anything, the factory remembers its readers and makes it so that the next object is read from the source <code>IEnumerable</code> only after all readers receive their link to the copy of the previous object.  This is achieved by the fact that each reader is assigned two WaitHandles - ‚ÄúI am ready to read‚Äù and ‚ÄúI have read‚Äù: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;T&gt; _input; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerator&lt;T&gt; _inputEnumerator; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, AutoResetEvent&gt; _imReadyToRead; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, AutoResetEvent&gt; _iVeReadMyValue; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WaitHandle[] _ivAlreadyReadArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T _nextObject; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _hasCurrent; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _hasNext; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_hasCurrent) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ready <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _imReadyToRead) ready.Value.Set(); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { WaitHandle.WaitAll(_ivAlreadyReadArray); <span class="hljs-comment"><span class="hljs-comment">//  ,   _hasNext = _inputEnumerator.MoveNext(); //      _nextObject = _inputEnumerator.Current; lock (_imReadyToRead) { if (!_hasNext) _hasCurrent = false; foreach (var ready in _imReadyToRead) ready.Value.Set(); //     .    } } while (_hasNext); }</span></span></code> </pre><br><br>  The reading itself is done from an <code>IEnumerable</code> , which ( <code>GetCloneInstance</code> ?) Is returned by the <code>GetCloneInstance</code> method. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCurrent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subscriber</span></span></span><span class="hljs-function">)</span></span> { T toReturn; _imReadyToRead[subscriber].WaitOne(); <span class="hljs-comment"><span class="hljs-comment">//   - ! toReturn = _nextObject; _iVeReadMyValue[subscriber].Set(); return toReturn; } private IEnumerable&lt;T&gt; GetCloneInstance(string key) { T res; do { res = GetCurrent(key); yield return res; } while (true); }</span></span></code> </pre><br><br>  So it seemed, the problem of parallelization was solved.  But during pre-flight preparation, one feature of the <code>WaitAll()</code> method <code>WaitAll()</code> : it supports the operation with no more than 64 instances at a time.  But I need 100+ readers!  How to be?  Yes, in general, simple.  And I began to clone clones.  Out of every 64 ‚Äúhonest‚Äù clones, I choose a victim, which I will clone in the future.  For a large number of readers I can have clones in 2, 3, 4, etc.  generation!  As the tests showed, quite viable creatures.  It looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _maxCloneOfOne = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    private IEnumerable&lt;T&gt; _input; //    private Stack&lt;ICloner&lt;T&gt;&gt; cloners; // -,    64  private Dictionary&lt;Guid, IEnumerable&lt;T&gt;&gt; clones; //  private Stack&lt;IEnumerable&lt;T&gt;&gt; missMe; // ,     - ,    public IEnumerable&lt;T&gt; GetClone() { if (cloners.Count == 0) cloners.Push(new Cloner&lt;T&gt;(_input)); //    var isLast = clones.Count &gt; 0 &amp;&amp; clones.Count % (_maxCloneOfOne - 1) == 0; //    -      ICloner&lt;T&gt; cloner; var g = Guid.NewGuid(); IEnumerable&lt;T&gt; result; if (!isLast) { cloner = cloners.Peek(); //     -   } else { //    -    var lastCloneForCloner = cloners.Peek().GetClone(); missMe.Push(lastCloneForCloner); cloners.Push(cloner = new Cloner&lt;T&gt;(lastCloneForCloner)); g = Guid.NewGuid(); } result = cloner.GetClone(); clones.Add(g, result); return result; }</span></span></code> </pre><br><br>  Now everything is exactly.  Added initialization code, checks for any boundary situations, wrapped diligently in thy-catch.  Works. <br><br><br>  If to anyone my decision seems necessary or at least interesting, welcome to the <a href="https://code.google.com/p/dolly-net/">page on google.code</a> .  Those who want to participate in improving and screwing in new features will receive the keys to all the doors. </div><p>Source: <a href="https://habr.com/ru/post/165449/">https://habr.com/ru/post/165449/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../165439/index.html">‚ÄúHow to make a channel‚Äù or recording and mixing: the maximum from the minimum</a></li>
<li><a href="../165441/index.html">Experience of transferring large files using a secure protocol from 1C to the site</a></li>
<li><a href="../165443/index.html">Profession "Leader". Or "Leadership"? Let's see!</a></li>
<li><a href="../165445/index.html">"Valve Steam Box" - the future of the PC in the world of consoles? (great miracle in a small box)</a></li>
<li><a href="../165447/index.html">Aspects of restrictions on the value of accounting balances from the point of view of automation systems</a></li>
<li><a href="../165451/index.html">Howto Installing Redmine2.2.0 Debian + Apache + PostgreSQL + passenger</a></li>
<li><a href="../165455/index.html">Windows Optimization for SSD: Myths and Reality</a></li>
<li><a href="../165457/index.html">Cross Domain Exchange: Anonymizer + Frame</a></li>
<li><a href="../165459/index.html">Generating Random Numbers in .NET</a></li>
<li><a href="../165461/index.html">Google Maps on iPhone without GoogleSDK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>