<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell Quest Tutorial - Forest</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Forest 
 This is a forest with trees in all directions. To the east, there appears to be sunlight. 
 You hear in the distance the chirping of song bir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell Quest Tutorial - Forest</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  Forest <br>  This is a forest with trees in all directions.  To the east, there appears to be sunlight. <br>  You hear in the distance the chirping of song bird. <br></blockquote><br><br>  Content: <br>  <a href="http://habrahabr.ru/blogs/Haskell/120590/">Greeting</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/120759/">Part 1 - The Threshold</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/121189/">Part 2 - Forest</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/122259/">Part 3 - Polyana</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/122788/">Part 4 - View of the canyon</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/123422/">Part 5 - Hall</a> <br><br>  Part 2, <br>  in which we will torture the describeLocation function, and even find out what ADT is. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is time to think better about the game.  What will it be?  A classic adventure game, where you can go somewhere, find and use objects, interact with non-player characters?  Or will it be a rogue-like text game with magic, evil creatures, with lots of weapons, armor, scrolls, swords and bows?  Or, perhaps, we want to create quests a la "Space Rangers-2"?  Well, in terms of game mechanics, we will follow in the footsteps of Zork, and choose another story - the wonderful Lighthouse NF quest.  Just because I like him. <br><a name="habracut"></a><br><blockquote><blockquote>  Erase everything that you have written in the file QuestMain.hs.  If you feel sorry for washing, then leave.  Or use the version control system (git, svn): I assure you, the fear that you accidentally break the code will disappear forever!  Any version of the code can be seen and restored whenever you want.  Refactoring Haskell programs is a pleasure in and of itself, and with a version control system, it's not at all burdensome.  Yes, refactoring can also be enjoyable!  You rule, rule Haskell code so that it finally compiles, and when it compiles, it starts working!  That part of the mistakes that you would make in an imperative language is simply impossible here.  There are, of course, logic errors, but it is not hard to find and fix, but with the version control system it is even easier.  In addition, logs with hundreds of other edits are a good example of how you did a good job, and the visible results from the path traveled motivate you to work further. </blockquote></blockquote><br><br>  Last time, we came up with a function that gives the location description by its number: <br><br><blockquote>  describeLocation locNumber <font color="#66cc66">=</font> <font color="#06c">case</font> locNumber <font color="#06c">of</font> <br>  <font color="red">1</font> <font color="#66cc66">-&gt;</font> <i><font color="#808080">"You are standing in the middle of the wooden table."</font></i> <br>  <font color="red">2</font> <font color="#66cc66">-&gt;</font> <i><font color="#808080">"You are standing behind a small wooden fence."</font></i> <br>  <font><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">otherwise</a></font> <font color="#66cc66">-&gt;</font> <i><font color="#808080">"Unknown location."</font></i> </blockquote><br><br>  What type can this function have?  Let's argue.  It takes an integer (Integer) and returns a string (String), so the type should be like this: <br><br><blockquote>  describeLocation <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Integer</a></font> <font color="#66cc66">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> </blockquote><br><br>  Well, this is practically the case - except for the fact that until we explicitly specify an Integer, the compiler will think that locNumber is a parameter of a more general numeric type, Num, which also includes floating-point numbers.  We can pass such a number - there will be no error. <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> describeLocation <font color="red">2.0</font> <br>  <i><font color="#808080">‚ÄúYou‚Äôre behind the small wooden fence.‚Äù</font></i> <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> describeLocation <font color="red">2.6</font> <br>  <i><font color="#808080">‚ÄúUnknown location.‚Äù</font></i> </blockquote><br><br>  Until we explicitly specify the type, let's see what the compiler thinks about it: <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : <font color="#06c">type</font> describeLocation <br>  describeLocation <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Num</a></font> a <font color="#339933">=&gt;</font> a <font color="#66cc66">-&gt;</font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Char</a></font> <font>]</font> </blockquote><br><br>  Hmm, the ‚ÄúNum a =&gt; a -&gt; [Char]‚Äù post is mysterious and frightening.  Let her  We have no need for these difficulties yet.  Add a function definition in front of the function itself and define explicitly Integer, String: <br><br><blockquote>  describeLocation <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Integer</a></font> <font color="#66cc66">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  describeLocation locNumber <font color="#66cc66">=</font> <font color="#06c">case</font> locNumber <font color="#06c">of</font> <br>  <font color="red">1</font> <font color="#66cc66">-&gt;</font> <i><font color="#808080">"You are standing in the middle of the wooden table."</font></i> <br>  <font color="red">2</font> <font color="#66cc66">-&gt;</font> <i><font color="#808080">"You are standing behind a small wooden fence."</font></i> <br>  <font><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">otherwise</a></font> <font color="#66cc66">-&gt;</font> <i><font color="#808080">"Unknown location."</font></i> </blockquote><br><br>  Check: <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : t describeLocation <br>  describeLocation <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Integer</a></font> <font color="#66cc66">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> </blockquote><br><br>  ABOUT!  That's better.  But, unfortunately, we now cannot pass a floating-point number as an argument: <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> describeLocation <font color="red">2</font> <br>  <i><font color="#808080">‚ÄúYou‚Äôre behind the small wooden fence.‚Äù</font></i> <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> describeLocation <font color="red">2.0</font> <br><br>  <font color="#339933">&lt;</font> interactive <font color="#339933">&gt;</font> : <font color="red">1</font> : <font color="red">18</font> : <br>  No <font color="#06c">instance</font> for <font>(</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Fractional</a></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Integer</a></font> <font>)</font> <br>  arising from the literal ' <font color="red">2.0</font> ' <br>  Possible fix: add an <font color="#06c">instance</font> declaration for <font>(</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Fractional</a></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Integer</a></font> <font>)</font> <br>  <font color="#339933">...</font> </blockquote><br><br>  We have limited the type of the first parameter from more general (Num) to more private (Integer), clarified.  Function definitions are optional, but the code is clearer with them.  In Haskell, one of the good tone rules is to define each function;  sometimes it is enough to understand how the function should work. <br><br>  What happens: we take the first argument (locNumber) and match the type to it in the first position (Integer).  We have no second parameter, so the type at the second position is the type of the return value (String).  Remember the "prod xy" function?  What type would she have?  It could be, for example, like this: <br><br><blockquote>  prod <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">float</a></font> <font color="#66cc66">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">float</a></font> <font color="#66cc66">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">float</a></font> <br>  prod x y <font color="#66cc66">=</font> x <font color="#339933">*</font> y </blockquote><br><br>  Got an idea? .. The first Float is the type for x, the second Float is the type for y, and the last Float is the type of the result.  That is, in fact, all shamanism. <br><br><blockquote><blockquote>  The library documentation primarily provides a definition of the types of functions and a brief description of them.  It may appear that types have no other tasks anymore;  However, it is not.  Types are the main data description objects; this is a higher abstraction over data.  Using types, you can construct data structures of any complexity, create abstract types, set the behavior of code, check its correctness, plan future algorithms, influence their performance and semantics.  If code is a program behavior, then data types are the content and structure of the program.  And the data is the filling of the program.  As we shall see, Haskell has a wonderful type system that is not only deep and expressive, but also supported by a powerful mathematical apparatus.  It is convenient to work with types in Haskell, because they are based on several basic constructs that complement each other well. </blockquote></blockquote><br><br>  Here we should think about how we will distinguish the locations.  The number is not a very clear notation, it would be better if it was something mnemonic.  Maybe a string as a name?  Let's try: <br><br><blockquote>  describeLocation <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font color="#66cc66">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  describeLocation locName <font color="#66cc66">=</font> <font color="#06c">case</font> locName <font color="#06c">of</font> <br>  <i><font color="#808080">"Home"</font></i> <font color="#66cc66">-&gt;</font> <i><font color="#808080">"You are standing in the middle of the wooden table."</font></i> <br>  <i><font color="#808080">"Friend's yard"</font></i> <font color="#66cc66">-&gt;</font> <i><font color="#808080">"You‚Äôre behind the small wooden fence."</font></i> <br>  <font><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">otherwise</a></font> <font color="#66cc66">-&gt;</font> <i><font color="#808080">"Unknown location."</font></i> <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> describeLocation <i><font color="#808080">"Home"</font></i> <br>  <i><font color="#808080">"You are standing in the middle of the room at the wooden table."</font></i> </blockquote><br><br>  ... Do you like Caps Lock?  And if it turns on EXTREMELY, and you notice it, already typing a couple of words?  Just imagine, you have - hysterical Caps Lock.  You wanted to dial "Home", and received "hOmE".  Then the function describeLocation will not understand you, although it will work.  This is a very unpleasant and subtle error if there is a lot of code. <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> describeLocation <i><font color="#808080">"hOmE"</font></i> <br>  <i><font color="#808080">‚ÄúUnknown location.‚Äù</font></i> </blockquote><br><br>  To insure against hysterical Caps Lock, you can think of a function that translates a word into upper case.  Alternatives in the case-design should also be written in capital letters. <br><br><blockquote>  upperCaseString <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font color="#66cc66">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  upperCaseString str <font color="#66cc66">=</font> <font color="#339933">............</font> <font color="#5d478b">- Somehow we make all the letters BIG.</font> <br>  describeLocation <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font color="#66cc66">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  describeLocation locName <font color="#66cc66">=</font> <font color="#06c">case</font> <font>(</font> upperCaseString locName <font>)</font> <font color="#06c">of</font> <br>  <i><font color="#808080">"HOME"</font></i> <font color="#66cc66">-&gt;</font> <i><font color="#808080">"You are standing in the middle of the wooden table."</font></i> <br>  <i><font color="#808080">"FRIEND'S YARD"</font></i> <font color="#66cc66">-&gt;</font> <i><font color="#808080">"You are standing behind a small wooden fence."</font></i> <br>  <font><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">otherwise</a></font> <font color="#66cc66">-&gt;</font> <i><font color="#808080">"Unknown location."</font></i> </blockquote><br><br>  Now hysterical Caps Lock is not terrible: <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> describeLocation <i><font color="#808080">"FRieNd'S yard"</font></i> <br>  <i><font color="#808080">‚ÄúYou‚Äôre behind the small wooden fence.‚Äù</font></i> <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> describeLocation <i><font color="#808080">"hOMe"</font></i> <br>  <i><font color="#808080">"You are standing in the middle of the room at the wooden table."</font></i> </blockquote><br><br><blockquote><blockquote>  Yeah, I see your curious eyes.  Want function upperCaseString?  Isn't it too early?  Okay.  I have nothing to hide.  We need some function, "toUpper", in the standard Prelude module it is not.  It is from the ‚ÄúChar‚Äù module, so it needs to be connected: <br><br><blockquote>  <font color="#06c">import</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Char</a></font> <font color="#5d478b">- At the beginning of QuestMain.hs we connect the Char module</font> <br><br>  upperCaseString <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font color="#66cc66">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  upperCaseString str <font color="#66cc66">=</font> <font>map</font> toUpper str </blockquote><br><br>  I will not explain anything here!  They themselves wanted to climb ahead - do it yourself and sort it out! <br><br>  ... Well, well, well, persuaded.  In outline.  The map function takes two arguments: the toUpper function and our str string.  The map's task is simple: apply the toUpper function to each element of the str string.  What elements does a string consist of?  Correct, from characters.  The toUpper function is applied to all these characters, which takes them to uppercase (well, if these are letters, of course). </blockquote></blockquote><br><br>  Another solution is to add constant functions.  You will not write them wrong, because the program simply will not compile! <br><br><blockquote>  home <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  home <font color="#66cc66">=</font> <i><font color="#808080">"HOME"</font></i> <br><br>  friend'sYard <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font color="#5d478b">- The apostrophe</font> character <font color="#5d478b">(') can be used inside and at the end as a letter.</font> <br>  friend'sYard <font color="#66cc66">=</font> <i><font color="#808080">"FRIEND'S YARD"</font></i> <br><br>  garden <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  garden <font color="#66cc66">=</font> <i><font color="#808080">"GARDEN"</font></i> <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> describeLocation home <br>  <i><font color="#808080">"You are standing in the middle of the room at the wooden table."</font></i> <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> describeLocation friend'sYard <br>  <i><font color="#808080">‚ÄúYou‚Äôre behind the small wooden fence.‚Äù</font></i> <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> describeLocation garden <br>  <i><font color="#808080">‚ÄúUnknown location.‚Äù</font></i> </blockquote><br><br>  But think: how many more functions will there be in which it is necessary to distinguish locations?  The function of traveling from one location to another, the Look command (‚ÄúLook around‚Äù), some actions with objects in this location ... Each time, building letters in upper case is inconvenient, unattractive, costly.  There must be some other way to define locations, to identify them. <br><br>  It is fair to say that when we call locations as strings, we introduce some dynamics into the static code.  At later stages of development, it may suddenly turn out that this was, in general, a good idea, since locations can be added and added without almost changing the code.  But then the describeLocation function would have a different look, and in general there would be a different philosophy of working with locations.  Here's how to add a new location without the describeLocation edit: <br><br><blockquote>  home <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  home <font color="#66cc66">=</font> <i><font color="#808080">"You are standing in the middle of the middle of the wooden table."</font></i> <br><br>  friend'sYard <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  friend'sYard <font color="#66cc66">=</font> <i><font color="#808080">"This is a wooden wooden fence."</font></i> <br><br>  garden <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  garden <font color="#66cc66">=</font> <i><font color="#808080">"You are in the garden.</font></i>  <i><font color="#808080">Garden looks very well: clean, tonsured, cool and wet. "</font></i> <br><br>  describeLocation <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font color="#66cc66">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  describeLocation location <font color="#66cc66">=</font> location <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> describeLocation garden <br>  <i><font color="#808080">‚ÄúYou are in the garden.</font></i>  <i><font color="#808080">Garden looks very well: clean, tonsured, cool and wet. "</font></i> </blockquote><br><br>  That is, we pass a constant function with a location description to describeLocation.  The function describeLocation returns it.  In this case, the case-design is no longer needed, and we can produce at least a thousand constant functions.  By the way, notice that our constant functions are no different from just strings.  Since in Haskell every expression is a function, and the string is an expression, the string is also a function.  We simply assigned a name to the string and got a constant function.  (We can assume that the ‚Äúpi‚Äù function is also a constant function, something like this: pi = 3.1415 ....) <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> friend'sYard <font color="#339933">==</font> <i><font color="#808080">"You‚Äôre behind the small wooden fence."</font></i> <br>  True <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : t friend'sYard <br>  friend'sYard <font color="#339933">::</font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Char</a></font> <font>]</font> <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : t <i><font color="#808080">"You‚Äôre behind the small wooden fence."</font></i> <br>  <i><font color="#808080">‚ÄúYou‚Äôre behind the small wooden fence.‚Äù</font></i> <font color="#339933">::</font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Char</a></font> <font>]</font> </blockquote><br><br><blockquote><blockquote>  Here, [Char] is the same as String.  Literally, [Char] is a list of characters, a synonym for String.  We could replace String with [Char] or even mix both types in one program, there would be no error.  But it is more convenient to write a "string" than a "list of characters."  We ourselves will set synonyms for many of our types.  So, in my adv2game ObjectName is defined, also a string (also a list of characters).  Looking at ObjectName, I understand that this is not just a string, but in it, in theory, should be the name of the object.  Synonyms are defined by the type keyword, which works in the same way as typedef in C ++: <br><br><blockquote>  <font color="#06c">type</font> ObjectName <font color="#66cc66">=</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> </blockquote><br><br>  And this is how the String type is specified in the Prelude module: <br><br><blockquote>  <font color="#06c">type</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font color="#66cc66">=</font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Char</a></font> <font>]</font> </blockquote><br><br>  The square brackets say that this is a list from Char.  Say ‚ÄúSTRING‚Äù is the same as the list of characters: ['S', 'T', 'R', 'I', 'N', 'G'].  It‚Äôs just that no one in their right mind would write a string like this, because in Haskell there is a simplification for the list of characters - ‚Äústrings in quotes‚Äù. <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> <font>[</font> 'S' <font color="#339933">,</font> 'T' <font color="#339933">,</font> 'R' <font color="#339933">,</font> 'I' <font color="#339933">,</font> 'N' <font color="#339933">,</font> 'G' <font>]</font> <br>  <i><font color="#808080">"STRING"</font></i> <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> <i><font color="#808080">‚ÄúI am a‚Äù</font></i> <font color="#339933">++</font> <font>[</font> 'S' <font color="#339933">,</font> 'T' <font color="#339933">,</font> 'R' <font color="#339933">,</font> 'I' <font color="#339933">,</font> 'N' <font color="#339933">,</font> 'G' <font>]</font> <font color="#339933">++</font> <i><font color="#808080">"."</font></i> <br>  <i><font color="#808080">"I am a STRING."</font></i> <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> <font>putStrLn</font> <font>[</font> 'S' <font color="#339933">,</font> 'T' <font color="#339933">,</font> 'R' <font color="#339933">,</font> '\ n' <font color="#339933">,</font> 'I' <font color="#339933">,</font> 'N' <font color="#339933">,</font> 'G' <font>]</font> <br>  STR <br>  Ing <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> <font>[</font> 'S' <font color="#339933">,</font> 'T' <font color="#339933">,</font> 'R' <font color="#339933">,</font> 'I' <font color="#339933">,</font> 'N' <font color="#339933">,</font> 'G' <font>]</font> <font color="#339933">==</font> <i><font color="#808080">"STRING"</font></i> <br>  True </blockquote><br><br>  You can specify lists of anything: a list of integers [Integer], a list of strings [String] (which expands to a list of Char lists), and so on.  Lists are the main structure in the FN, and we will learn a lot about them. </blockquote></blockquote><br><br>  Do we want to somehow distinguish locations or not?  Only not by a string name, it‚Äôs so easy to make a mistake.  I wish there was something permanent instead of a string.  Here is: <br><br><blockquote>  describeLocation <font color="#339933">::</font> <font color="#339933">?????</font>  <font color="#66cc66">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  describeLocation loc <font color="#66cc66">=</font> <font color="#06c">case</font> loc <font color="#06c">of</font> <br>  Home <font color="#66cc66">-&gt;</font> <i><font color="#808080">"You are standing in the middle of the wooden table."</font></i> <br>  Friend'sYard <font color="#66cc66">-&gt;</font> <i><font color="#808080">‚ÄúYou</font></i> ‚Äôve been <i><font color="#808080">behind a small wooden fence.‚Äù</font></i> <br>  Garden <font color="#66cc66">-&gt;</font> <i><font color="#808080">‚ÄúYou are in the garden.</font></i>  <i><font color="#808080">Garden looks very well: clean, tonsured, cool and wet. "</font></i> <br>  <font><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">otherwise</a></font> <font color="#66cc66">-&gt;</font> <i><font color="#808080">"Unknown location."</font></i> </blockquote><br><br>  Obviously, instead of question marks, there should be a <s>PROFIT of</s> some type in which there is Home, Friend'sYard, Garden.  For such cases, Haskell implemented the so-called algebraic data types (ADT).  With their help, you can intuitively describe the data of a completely different structure.  Algebraic data types replace enumerations, unions, objects in OOP-languages ‚Äã‚Äãof any complexity.  Through ATD, ATD (abstract data types, which are also ‚ÄúATD‚Äù) are expressed, and through ADT, ATD itself is expressed (recursively).  In addition, they can make lists, trees, sets, and much more.  Moreover, ADT is not a specific language tool, but an element of the mathematical type theory, thanks to which the compiler itself infers types, and also checks the code for correctness during compilation. <br><br>  At the beginning of the QuestMain.hs file, specify the type for the locations: <br><br><blockquote>  <font color="#06c">data</font> Location <font color="#66cc66">=</font> Home <font color="#339933">|</font>  Friend'sYard <font color="#339933">|</font>  Garden </blockquote><br><br>  Using the data keyword, we create a new algebraic data type.  A location is a type, and all that follows the equal sign is constructors.  We can assume that they are just values, that's all.  All constructors must begin with a capital letter, as is customary in Haskell.  This distinguishes them from functions in which the first letter is necessarily small.  To make it clearer, you can rewrite it differently, the position of the elements and indents do not matter: <br><br><blockquote>  <font color="#06c">data</font> Location <font color="#66cc66">=</font> <br>  Home <br>  <font color="#339933">|</font>  Friend'sYard <br>  <font color="#339933">|</font>  Garden </blockquote><br><br>  The sign "|"  can be read as ‚Äúor.‚Äù  That is, Location type variables can take one value: either Home, or Friend'sYard, or Garden.  Calling Location type constructors, we create a variable of this type.  It is important to understand that by calling any of the constructors, we are still dealing with the Location type, and there are no such types as ‚ÄúHome‚Äù or ‚ÄúGarden‚Äù. <br><br>  Substitute a new type instead of question marks: <br><br><blockquote>  describeLocation <font color="#339933">::</font> Location <font color="#66cc66">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  describeLocation loc <font color="#66cc66">=</font> <font color="#06c">case</font> loc <font color="#06c">of</font> <br>  Home <font color="#66cc66">-&gt;</font> <i><font color="#808080">"You are standing in the middle of the wooden table."</font></i> <br>  Friend'sYard <font color="#66cc66">-&gt;</font> <i><font color="#808080">‚ÄúYou</font></i> ‚Äôve been <i><font color="#808080">behind a small wooden fence.‚Äù</font></i> <br>  Garden <font color="#66cc66">-&gt;</font> <i><font color="#808080">‚ÄúYou are in the garden.</font></i>  <i><font color="#808080">Garden looks very well: clean, tonsured, cool and wet. "</font></i> <br>  <font><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">otherwise</a></font> <font color="#66cc66">-&gt;</font> <i><font color="#808080">"Unknown location."</font></i> <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> describeLocation Home <br>  <i><font color="#808080">"You are standing in the middle of the room at the wooden table."</font></i> <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> describeLocation Friend'sYard <br>  <i><font color="#808080">‚ÄúYou‚Äôre behind the small wooden fence.‚Äù</font></i> </blockquote><br><br>  Errors are now excluded.  It is also not necessary to translate the loc parameter to uppercase, and the constant functions seem to be useless.  You either write the constructor correctly, and the program is compiled, or it is incorrect, and then you get an error.  You can verify this by adding these three functions: <br><br><blockquote>  describeHomeLocation <font color="#66cc66">=</font> describeLocation Home <br>  describeGardenLocation <font color="#66cc66">=</font> describeLocation garDEN <br>  describeGardenLocation ' <font color="#66cc66">=</font> describeLocation GarDEN <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : r <br>  <font>[</font> <font color="red">1</font> <font color="#06c">of</font> <font color="red">1</font> <font>]</font> Compiling Main <font>(</font> H: \ Haskell \ QuestTutorial \ Quest \ QuestMain <font color="#339933">.</font> Hs <font color="#339933">,</font> interpreted <font>)</font> <br><br>  H: \ Haskell \ QuestTutorial \ Quest \ QuestMain <font color="#339933">.</font>  hs: <font color="red">15</font> : <font color="red">43</font> : <br>  Not <font color="#06c">in</font> scope: 'garDEN' <br><br>  H: \ Haskell \ QuestTutorial \ Quest \ QuestMain <font color="#339933">.</font>  hs: <font color="red">16</font> : <font color="red">44</font> : <br>  Not <font color="#06c">in</font> scope: <font color="#06c">data</font> constructor 'GarDEN' <br>  Failed <font color="#339933">,</font> modules loaded: none <font color="#339933">.</font> </blockquote><br><br>  Now erase this erroneous code! .. We do not have any ‚ÄúgarDEN‚Äù or ‚ÄúGarDEN‚Äù!  But you can add a GarDEN constructor if you want.  What it will mean is your business.  And it will be correct: GarDEN and Garden are different designers, because the register matters.  By the way, nobody forbids you to make a constructor with the same name as the type;  it is useful, but not in our case: <br><br><blockquote>  <font color="#06c">data</font> Location <font color="#66cc66">=</font> <br>  Location <font color="#5d478b">- This is correct, although it is not clear why.</font> <br>  <font color="#339933">|</font>  Home <br>  <font color="#339933">|</font>  Friend'sYard <br>  <font color="#339933">|</font>  Garden </blockquote><br><br>  There will be no errors, because the Haskell smart compiler knows where Location should be understood as a type, and where - as a constructor.  And these places do not overlap.  ("Types and their constructors are in different namespaces.") <br><br>  Let's fantasize for the future, what other types we will have. <br><br><blockquote>  <font color="#5d478b">- Where to go with the Walk or Go team.</font> <br>  <font color="#06c">data</font> Direction <font color="#66cc66">=</font> North <font color="#339933">|</font>  South <font color="#339933">|</font>  West <font color="#339933">|</font>  East <br><br>  <font color="#5d478b">- Player's actions.</font> <br>  <font color="#06c">data</font> Action <font color="#66cc66">=</font> Look <font color="#339933">|</font>  Go <font color="#339933">|</font>  Inventory <font color="#339933">|</font>  Take <font color="#339933">|</font>  Drop <font color="#339933">|</font>  Investigate <font color="#339933">|</font>  Quit <font color="#339933">|</font>  Save <font color="#339933">|</font>  Load <font color="#339933">|</font>  New </blockquote><br><br>  What can we do with these types?  Well, not so much yet.  We cannot even compare constructors of the same type: <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> North <font color="#339933">==</font> North <br><br>  <font color="#339933">&lt;</font> interactive <font color="#339933">&gt;</font> : <font color="red">1</font> : <font color="red">7</font> : <br>  No <font color="#06c">instance</font> for <font>(</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Eq</a></font> Direction <font>)</font> <br>  arising from a use <font color="#06c">of</font> ' <font color="#339933">==</font> ' <br>  Possible fix: add an <font color="#06c">instance</font> declaration for <font>(</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Eq</a></font> Direction <font>)</font> <br>  In the expression: North <font color="#339933">==</font> North <br>  In this equation for 'it': it <font color="#66cc66">=</font> North <font color="#339933">==</font> North </blockquote><br><br>  The interpreter complains that it is not written anywhere in our country how to compare constructors of the Direction type.  Like, you want the operation "=="?  Then add your type to the family of compared types! <br><br><blockquote><blockquote>  More specifically, it asks you to add the Direction <i>type to the</i> Eq <i>type</i> class.  Eq is a <i>class of types</i> for which the operations "==" and "/ =" are defined. <br><br>  And now forget what is written in this box.  It‚Äôs too early for us to talk about <i>type classes</i> . </blockquote></blockquote><br><br>  There are several ways to make our designers comparable.  The simplest of these is to add a couple of magic words to the type definition: <br><br><blockquote>  <font color="#06c">data</font> direction <font color="#66cc66">=</font> <br>  North <br>  <font color="#339933">|</font>  South <br>  <font color="#339933">|</font>  West <br>  <font color="#339933">|</font>  East <br>  <font color="#06c">deriving</font> <font>(</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Eq</a></font> <font>)</font> <font color="#5d478b">- There should be indentation from the left edge.</font> </blockquote><br><br>  Magic words you see.  Literally, this means that we borrow (inherit) the comparison operation, which is the default.  It lies in the <i>class of types</i> Eq.  And this operation will work for our designers in a quite expected way: <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> North <font color="#339933">==</font> North <br>  True <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> North <font color="#339933">/ =</font> North <br>  False <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> North <font color="#339933">==</font> South <br>  False </blockquote><br><br>  That's good!  We now have signs "equal" and "not equal."  Do the same with our other types - Action and Direction.  Useful! <br><br>  deriving (Eq) is one of the magic options with which we can compare constructors.  In general, there are a lot of magic options for data, and they make something more out of your type.  But let's leave miracles to the next part.  It's enough for today.  We have already tormented with this describeLocation function.  In the next part we will learn about ADT something else. <br><br><blockquote><blockquote>  Task for fixing: <br><br>  Think of the walk function - the function of travel between locations.  It takes two parameters: the current location (Location) and direction (Direction), and returns a new location located in this direction.  The route map for each location is as follows: <br><br>  Home: <br>  to the north - Garden <br>  South - Friend'sYard <br>  to the east - Home <br>  to the west - Home <br><br>  Garden: <br>  to the north - Friend'sYard <br>  to the south - Home <br>  to the east - Garden <br>  to the west - Garden <br><br>  Friend'sYard: <br>  to the north - Home <br>  to the south - Garden <br>  to the east - Friend'sYard <br>  to the west - Friend'sYard </blockquote></blockquote><br><br>  <a href="https://github.com/graninas/Quest-Tutorial-Code/archives/e59195606846dcf7d1b3c194679042c4ccf89556">Sources to this part</a> . <br><br>  Table of contents, list of references and additional information can be found in the <a href="http://habrahabr.ru/blogs/Haskell/120590/">"Welcome"</a> </div><p>Source: <a href="https://habr.com/ru/post/121189/">https://habr.com/ru/post/121189/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../121183/index.html">CDC Announces Porting Optimum Technology Platform to Android</a></li>
<li><a href="../121185/index.html">Tornado Web Server 2.0 RC Released</a></li>
<li><a href="../121186/index.html">iPhone. Playing audio in the background</a></li>
<li><a href="../121187/index.html">Began accepting orders for Google Chromebook from $ 380</a></li>
<li><a href="../121188/index.html">Youtube removed its logo from the videos</a></li>
<li><a href="../121190/index.html">Transfer of GPS data (NMEA) from Android to Windows</a></li>
<li><a href="../121193/index.html">Creation of another casual game on a Flash platform with physics. Part I</a></li>
<li><a href="../121195/index.html">Release eyeOS 2.5 webOS</a></li>
<li><a href="../121197/index.html">Anti-virus systems with cloud architecture</a></li>
<li><a href="../121199/index.html">Ended the last qualifying round of Google Code Jam 2011</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>