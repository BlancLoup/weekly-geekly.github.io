<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Alternative Embedded Software Design Approach</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I decided to write this topic after reading the article ‚ÄúTwo approaches to software design for embedded‚Äù . While reading, I stumbled upon the phrase: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Alternative Embedded Software Design Approach</h1><div class="post__text post__text-html js-mediator-article">  I decided to write this topic after reading the article <a href="http://habrahabr.ru/post/148805/">‚ÄúTwo approaches to software design for embedded‚Äù</a> .  While reading, I stumbled upon the phrase: ‚ÄúIf the system is going to become big, connecting many different actions and reactions that are also time critical, then there is no alternative to using the real-time OS.‚Äù  ‚ÄúHow is it not?‚Äù I thought.  Of course, if we are talking about large, high-loaded real-time systems that use large processors, then the OS can not do without, but for more modest microcontroller solutions there is an alternative option.  After all, tasks can be performed using the usual switch-case and at the same time provide the necessary reaction time. <br><br><a name="habracut"></a><br><h4>  Why I personally do not use RTOS </h4><br><br>  Comrade <a href="http://geektimes.ru/users/olekl/" class="user_link">olekl</a> told about RTOS, I will not focus on this.  I will note a couple of points that I singled out for myself - why I don‚Äôt use RTOS: <br><ul><li>  The operating system for its work requires the resources of the microcontroller: their memory and system time are so few.  Let them go on puzzles, but will have to give the dispatcher.  Perhaps this is the most basic point for me. </li><li>  Not an easy way for me to organize tasks.  Mutexes, semaphores, priorities, etc.  - you can get lost. </li><li>  Some RTOS cost money.  And not small. </li><li>  There are some doubts about the support of RTOS controllers.  Suddenly I want to transfer the project to the newest controller, but for him there is still no support for this operating system. </li><li>  Doubt: what if there is an error in the core?  Surely the proposed RTOS tested a million times, but who knows: what if something will fly out a million the first time. </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Switch-case approach </h4><br><br>  The terminology is not strong, so let it be such a name. <br>  It is more convenient to look at an example.  It uses pseudocode. <br><br>  The device has two temperature sensors.  The polling time of the first sensor is not critical: ‚Äúinterrogated, yes, okay‚Äù, let it be a periodicity of 0.2 ms.  On exceeding the specified threshold temperature will light the LED.  The readings of the second sensor are very important for us.  It must be interrogated as often as possible and, on exceeding a predetermined threshold, output ‚Äú1‚Äù per pin in order to turn on the cooling fan with a discrete signal.  When the temperature drops to another threshold, turn off the fan.  Somewhere every 100 ms the value from the second sensor must be written to the ROM. <br>  An implementation will require a hardware timer interrupt.  After all, the only way we can guarantee the execution of tasks in the time allotted to them.  In this case, the possibilities for using other interrupts are drastically reduced. <br>  Work with most of the peripherals can be done without interruptions, and very important communication interrupts (for example: UART / SCI) usually have a higher priority than the timer and usually serve to record received / sent bytes, i.e.  a lot of time will not take away. <br>  The approach, when the timer only counts time for tasks, and the tasks themselves are performed in the background (or while super-cycle) without prohibiting interruptions does not guarantee the desired execution response. <br><br>  First, let's make a temperature sensor driver.  Its main function is to read the temperature value by SPI. <br><br>  Structure: <br><pre><code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> SpiCh; <span class="hljs-comment"><span class="hljs-comment">//   SPI (A, B, C) unsigned int SpiBrr; //  SPI- unsigned int Value; //    void (*ChipSelect) (unsigned char level_); // Callback    ‚Ä¶ // -  }TSensor;</span></span></code> </pre> <br>  Temperature sensor polling function: <br><br><pre> <code class="hljs erlang-repl">void SensorDriver(TSensor *p) { p-&gt;ChipSelect(<span class="hljs-number"><span class="hljs-number">0</span></span>); //   p-&gt;Value = SpiRead(p-&gt;SpiCh, p-&gt;SpiBrr); //    SPI p-&gt;ChipSelect(<span class="hljs-number"><span class="hljs-number">1</span></span>); //    }</code> </pre><br>  Our driver is ready.  To use it need initialization.  The structure can be initialized as a whole using #define, or each field can be used separately.  We have two temperature sensors.  We create two structures. <br><pre> <code class="hljs cs">TSensor Sensor1; TSensor Sensor2; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { Sensor1.ChipSelect = &amp;ChipSelectFunc1; <span class="hljs-comment"><span class="hljs-comment">//      Sensor1.SpiCh = 0; //  SPI Sensor1.SpiBrr = 1000; //  SPI Sensor2.ChipSelect = &amp;ChipSelectFunc2; Sensor2.SpiCh = 0; Sensor2.SpiBrr = 1000; }</span></span></code> </pre><br><br>  The main function of the driver is to read the temperature.  What to do with this data we will decide outside the driver. <br><br>  Light up the LED: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> SensorLed(<span class="hljs-type"><span class="hljs-type">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Sensor1.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> &gt;= SENSOR_LED_LIMIT) LedPin = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> (Sensor1.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> &lt; SENSOR_LED_LIMIT) LedPin = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Turn on / off the fan discrete leg: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> SensorCooler(<span class="hljs-type"><span class="hljs-type">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Sensor2.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> &gt;= SENSOR_LED_LIMIT) CoolerPin = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Sensor1.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> &lt; SENSOR_LED_LIMIT) CoolerPin = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Strange, but the functions turned out surprisingly similar :) <br>  Write to ROM will be as follows: <br>  the function of the ROM driver will be cyclically performed at a frequency of 1 kHz, while waiting for the data to be written, the instruction ‚Äúwhat to do with them‚Äù and at what address in memory.  Those.  it's enough for us to check the readiness of the memory and send it data with instructions from anywhere in the program. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> SensorValueRecord() { unsigned <span class="hljs-type"><span class="hljs-type">int</span></span> Data = Sensor2.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; //     unsigned <span class="hljs-type"><span class="hljs-type">int</span></span> Address = <span class="hljs-number"><span class="hljs-number">0</span></span>; //    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EepromReady()) //    { //  ,   ,     EepromFunction(Address, Data, <span class="hljs-keyword"><span class="hljs-keyword">WRITE</span></span>); } }</code> </pre><br>  We sent the data and when the memory driver comes into operation (and it does it 100 times faster than the SensorValueRecord function), it will already know what to do. <br>  Our functions are ready.  Now they need to properly organize. <br>  To do this, we start the interrupt timer with a frequency of 10 kHz (100 Œºs).  This will be our maximum guaranteed task call frequency.  Let it be enough.  We create functions of the task scheduler, in which we will determine when to start which task. <br><br><pre> <code class="hljs dos">#define MAIN_HZ <span class="hljs-number"><span class="hljs-number">10000</span></span> #define TASK0_FREQ <span class="hljs-number"><span class="hljs-number">1000</span></span> #define TASK1_FREQ <span class="hljs-number"><span class="hljs-number">50</span></span> #define TASK2_FREQ <span class="hljs-number"><span class="hljs-number">10</span></span> //    void AlternativeTaskManager(void) { SensorDriver(&amp;Sensor2); //      SensorCooler(); //     Task0_Execute(); //     } //  <span class="hljs-number"><span class="hljs-number">1</span></span> void Task0_Execute(void) { switch (TaskIndex0) { case <span class="hljs-number"><span class="hljs-number">0</span></span>: EepromDriver(&amp;Eeprom); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case <span class="hljs-number"><span class="hljs-number">1</span></span>: Task1_Execute(); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case <span class="hljs-number"><span class="hljs-number">2</span></span>: Task2_Execute(); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; } //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++TaskIndex0 &gt;= MAIN_HZ / TASK0_FREQ) TaskIndex0 = <span class="hljs-number"><span class="hljs-number">0</span></span>; } //    <span class="hljs-number"><span class="hljs-number">50</span></span>  void Task1_Execute(void) { switch (TaskIndex1) { case <span class="hljs-number"><span class="hljs-number">0</span></span>: SensorDriver(&amp;Sensor1); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case <span class="hljs-number"><span class="hljs-number">1</span></span>: SensorLed(); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++TaskIndex1 &gt;= TASK0_FREQ / TASK1_FREQ) TaskIndex1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; } //    <span class="hljs-number"><span class="hljs-number">10</span></span>  void Task2_Execute(void) { switch (TaskIndex2) { case <span class="hljs-number"><span class="hljs-number">0</span></span>: SensorValueRecord(); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++TaskIndex2 &gt;= TASK0_FREQ / TASK2_FREQ) TaskIndex2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  Now it remains to run the scheduler in the interrupt timer and ready. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">interrupt </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer1_Handler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { AlternativeTaskManager(); }</code> </pre><br>  This system looks like a kind of mechanism with gears: the most important gear directly on the motor shaft and it turns the rest gears. <br>  Puzzles are performed "on the ring."  The frequency of their execution depends on the location of the call.  The Task0_Execute function will be executed with a frequency of 10kHz, since we call it directly in the timer interrupt (our main gear).  It is the frequency division and using the switch-case with TaskIndex0 is determined for what task the time has come.  The frequency of calling tasks should be less than 10 kHz. <br>  We set the frequency of tasks for the Task0_Execute cycle equal to 1 kHz, so 10 tasks with a frequency of 1 kHz can be performed in it: <br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_HZ 10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK0_FREQ 1000 </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (++TaskIndex0 &gt;= MAIN_HZ / TASK0_FREQ)</span></span></code> </pre><br><br>  The structure of the switch-case system <br><img src="http://habrastorage.org/storage2/5d4/4d3/da9/5d44d3da9cc2251f783c1c1b308475a9.png"><br><br>  Similarly for Task1_Execute and Task2_Execute.  Call them with a frequency of 1 kHz.  In the first cycle, tasks should be performed with a frequency of 50 Hz, and in the second - 10 Hz.  We get a total of 20 and 100 tasks, respectively. <br>  After completing the dispatcher's tasks, the program returns to the background (super cycle background). <br>  Any non-critical reaction time, they can be placed there. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { Init(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { DoSomething(); } }</code> </pre><br>  A DAC is added to the device, and together with the ignition of the LED you need to generate a 4-20 signal?  No problem.  Create a DAC driver and run it.  We add two lines to the SensorLed function that will tell the driver what value to output to it and the dispatcher calls the driver function. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> SensorLed(<span class="hljs-type"><span class="hljs-type">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Sensor1.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> &gt;= SENSOR_LED_LIMIT) { LedPin = <span class="hljs-number"><span class="hljs-number">1</span></span>; Dac.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = <span class="hljs-number"><span class="hljs-number">20</span></span>; //     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> (Sensor1.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> &lt; SENSOR_LED_LIMIT) { LedPin = <span class="hljs-number"><span class="hljs-number">0</span></span>; Dac.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span>; //     } }</code> </pre><br><pre> <code class="hljs bash">//    50  void Task1_Execute(void) { switch (TaskIndex1) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> 0: SensorDriver(&amp;Sensor1); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> 1: SensorLed(); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> 2: DacDriver(&amp;Dac) <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; //    } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++TaskIndex1 &gt;= TASK0_FREQ / TASK1_FREQ) TaskIndex1 = 0; }</code> </pre><br><br>  Added a two-line indicator?  Not a problem either.  We launch its driver at a frequency of 1 kHz, since  characters need to be transmitted quickly, and in other slower functions we indicate to the driver exactly which characters and lines will need to be displayed. <br><br><h4>  Load rating </h4><br><br>  In order to estimate the load, you must enable the second hardware timer, which operates at the same frequency as the first timer.  On good to make so that the period of timers was not end-to-end. <br>  Before launching the task manager, the timer counter was reset, and after work, its value was calculated.  Evaluation of loading is carried out on the period of the timer.  For example, the period of the first timer is 100. That is, the counter will count to 100 and an interrupt will occur.  If the counter of the second timer (CpuTime) counted less than 100, then - well.  If it is too close or more, it‚Äôs bad: the reaction time of the tasks will float. <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CpuTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CpuTimeMax = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-function">interrupt </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer1_Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Timer2.TimerValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   AlternativeTaskManager(); //  switch-case   CpuTime = Timer2.Value; //    =  if (CpuTime &gt; CpuTimeMax ) //    CpuTime = CpuTimeMax; }</span></span></code> </pre><br><br><h4>  What's the result </h4><br><br>  What kind of benefits did I personally get compared to RTOS: <br>  - Resource consumption when working dispatcher scanty. <br>  - Organization of tasks, though not simple, but it comes down to the definition: where to start which function.  There are no semaphores, mutexes, etc.  No need to read multipage manuals for RTOS.  Not to say that an advantage, but I'm so used to it. <br>  - The code can be easily transferred from one controller to another.  The main thing is not to forget about the types that are used. <br><br>  Disadvantage: <br>  - Complication of software.  If, in the case of RTOS, you can write a function and immediately start it, if there are enough resources, then in the case of a switch-case, you will have to approach the optimization more closely.  You have to think about how this or that effect will affect the performance of the entire system.  An extra set of actions can lead to a violation of the "movement of gears."  The larger the system, the more complex the software.  If the function can be performed for an operating system in one run, then it may be necessary to break down the steps in more detail (state machine).  For example, the indicator driver does not immediately send all the characters, but in lines: <br>  1) set the gate, forwarded the top line, went out; <br>  2) forwarded the bottom line, removed the strobe so that the characters were displayed, went out. <br>  If there is little progress, this approach will affect the speed of development. <br>  I use this approach is not the first year.  There are many developments, libraries.  But for beginners will be difficult. <br><br>  In this article, I tried to reveal an alternative approach to designing software for embedded systems without using RTOS.  I hope someone learned something useful. <br><br>  <b>Upd.</b>  I do not reject the idea of ‚Äã‚Äãusing RTOS.  I am not saying that RTOS is bad and should be immediately abandoned by everyone.  I personally described my attitude on this matter and do not impose it on anyone.  This article originated from the topic about software design for Embedded, where the author indicated that there is no alternative.  I, on the contrary, showed that an alternative does exist, and exists in commercial projects. </div><p>Source: <a href="https://habr.com/ru/post/148992/">https://habr.com/ru/post/148992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148985/index.html">Making the compiler distinguish between cows and galoshes</a></li>
<li><a href="../148986/index.html">Examples of working with the Google Map API using Java</a></li>
<li><a href="../148989/index.html">The first open source powder 3D printer</a></li>
<li><a href="../148990/index.html">What happens with Oracle?</a></li>
<li><a href="../148991/index.html">"Hola, apple gadgets!"</a></li>
<li><a href="../148993/index.html">In court for "Like"</a></li>
<li><a href="../148995/index.html">How much do applications cost?</a></li>
<li><a href="../148996/index.html">Creating a plugin for Intellij Platform (IntelliJ IDEA, RubyMine, WebStorm, PhpStorm, PyCharm and AppCode)</a></li>
<li><a href="../148999/index.html">Does your site also allow you to upload everything?</a></li>
<li><a href="../149/index.html">Virtual things have the right to life?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>