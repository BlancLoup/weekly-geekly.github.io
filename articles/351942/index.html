<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why putting the most selective columns in the composite index prefix is ‚Äã‚Äãnot always good</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="tl; dr In this article, we will consider the case when it is better to move the most selective attribute from the prefix of the composite index to the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why putting the most selective columns in the composite index prefix is ‚Äã‚Äãnot always good</h1><div class="post__text post__text-html js-mediator-article"><p>  tl; dr In this article, we will consider the case when it is better to move the most selective attribute from the prefix of the composite index to the suffix. </p><br><p> And also consider what a <code>pipeline</code> and how to use it to <code>select</code> data that is already sorted. </p><br><p><img src="https://habrastorage.org/webt/cy/ef/wt/cyefwtvitdg-8jd7glimtbggam4.jpeg"></p><a name="habracut"></a><br><h1 id="opisanie-predmetnoy-oblasti">  Domain Description </h1><br><p>  There is an event logger in system X. You need to make an application to view these logs from this system. </p><br><p>  It is assumed that the system has its own error codes and corresponding messages.  About 10k of them are unique. </p><br><p>  There are three types of messages: </p><br><ul><li>  <strong>notice</strong> - notification </li><li>  <strong>warning</strong> - warning </li><li>  <strong>error</strong> - cranes. </li></ul><br><p>  Log table: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">`log`</span></span> ( <span class="hljs-string"><span class="hljs-string">`message`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">`datetime`</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">`type`</span></span> enum(<span class="hljs-string"><span class="hljs-string">'notice'</span></span>, <span class="hljs-string"><span class="hljs-string">'warning'</span></span>, <span class="hljs-string"><span class="hljs-string">'error'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'notice'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-string"><span class="hljs-string">`datetime_message`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-string"><span class="hljs-string">`log`</span></span>(<span class="hljs-string"><span class="hljs-string">`datetime`</span></span>, <span class="hljs-string"><span class="hljs-string">`message`</span></span>(<span class="hljs-number"><span class="hljs-number">150</span></span>));</code> </pre> <br><p>  There are 10 million entries in the table.  <strong>datetime</strong> is always unique, but the <strong>message</strong> field has only 10k unique fields. </p><br><p>  To generate records, I made a procedure that generates a random log.  <strong>datetime</strong> changes as if logs are written once a second. </p><br><div class="spoiler">  <b class="spoiler_title">The procedure itself</b> <div class="spoiler_text"><pre> <code class="sql hljs">delimiter // <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> <span class="hljs-string"><span class="hljs-string">`generate_logs`</span></span>(<span class="hljs-string"><span class="hljs-string">`amount`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, <span class="hljs-string"><span class="hljs-string">`amountOfUniqueMessages`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">deterministic</span></span> modifies <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> <span class="hljs-keyword"><span class="hljs-keyword">security</span></span> invoker <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> i <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> @datetime = <span class="hljs-keyword"><span class="hljs-keyword">cast</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">current_date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> datetime) - <span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span>; <span class="hljs-comment"><span class="hljs-comment">--    input_params: begin if (amount &lt;= 0 or amountOfUniqueMessages &lt;= 0) then leave input_params; --   end if; end; start transaction; --  [amountOfUniqueMessages]     datetime --        , --   datetime  interval- while i &lt; amount DO set @message = concat('message ', i % amountOfUniqueMessages); insert into `log`(`message`, `datetime`) values (@message, @datetime + interval i second); end while; commit; end; // delimiter ;</span></span></code> </pre> </div></div><br><h1 id="realizaciya">  Implementation </h1><br><p>  We assume that the most frequent user operation of the application will be the output of the entire log for a <em>specific date</em> . <br>  This is best done through a type query. </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">`message`</span></span>, <span class="hljs-string"><span class="hljs-string">`datetime`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`log`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-string"><span class="hljs-string">`datetime`</span></span> &gt;= <span class="hljs-string"><span class="hljs-string">'2017-04-01 00:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">`datetime`</span></span> &lt; <span class="hljs-string"><span class="hljs-string">'2017-04-02 00:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-string"><span class="hljs-string">`datetime`</span></span>;</code> </pre> <br><blockquote>  <strong>upd</strong> : thanks <a href="https://habrahabr.ru/users/volch/" class="user_link">VolCh</a> for advice with dates, fixed <code>&lt;= '2017-04-01 23:59:59'</code> on <code>&lt; '2017-04-02 00:00:00'</code> .  Read more in the comments to the post. </blockquote><p>  Those.  select all records for a certain date, sorted by it.  And if the date comes first in the composite index, then it is not even necessary to sort it, it is returned in a sorted form. </p><br><p>  Explain of this query shows good results: </p><br><pre> <code class="sql hljs"> id: 1 select_type: SIMPLE table: log partitions: NULL type: range possible_keys: datetime_message key: datetime_message key_len: 5 ref: NULL rows: 172242 filtered: 100.00 Extra: Using index condition</code> </pre> <br><p>  Affected 172k fields.  This is quite an expected result, provided that the data was generated as if the logger was writing something to the database every second. </p><br><h1 id="order-by-ascdesc">  Order by asc / desc </h1><br><p>  I note that even if the sorting is <code>descending</code> , all the same, the data is fetch already sorted, and they should not be sorted by <code>filesort</code> : th: </p><br><ul><li>  Request with <code>order by ... descending</code> : <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">`message`</span></span>, <span class="hljs-string"><span class="hljs-string">`datetime`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`log`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-string"><span class="hljs-string">`datetime`</span></span> &gt;= <span class="hljs-string"><span class="hljs-string">'2009-03-24 00:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">`datetime`</span></span> &lt; <span class="hljs-string"><span class="hljs-string">'2009-03-25 00:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-string"><span class="hljs-string">`datetime`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre> </li><li>  His explain: <br><pre> <code class="sql hljs"> id: 1 select_type: SIMPLE table: log partitions: NULL type: range possible_keys: datetime_message key: datetime_message key_len: 5 ref: NULL rows: 172242 filtered: 100.00 Extra: Using index condition</code> </pre> </li></ul><br><p>  Without <code>filesort</code> - and without <code>temporary</code> .  Everything is exactly the same as in the first case. <br>  This phenomenon is called the <em>pipeline</em> , for the fact that the data is stored as if chained, one after another.  And you can pull all the values, starting with the initial link ( <code>order by asc</code> ), and from the final link ( <code>desc</code> ). </p><br><p>  To understand how <strong>message is</strong> sorted in a composite index, you can imagine school classes.  Pupils in each class are sorted from <em>a</em> to <em>z</em> : </p><br><table><thead><tr><th>  1 "a" </th><th>  1 b </th></tr></thead><tbody><tr><td>  Ivanov </td><td>  Kuznetsov </td></tr><tr><td>  Petrov </td><td>  Popov </td></tr><tr><td>  Sidorov </td><td>  Novikov </td></tr></tbody></table><br><p>  If <code>select</code> -it all students from 1 "a", then they will return already sorted without using <code>filesort</code> or <code>temporary</code> ;  no matter what was used, <code>ascending</code> or <code>descending</code> : </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">`surname`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`schoolkids`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-string"><span class="hljs-string">`class`</span></span> = <span class="hljs-string"><span class="hljs-string">'1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">`liter`</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>;</code> </pre> <br><p>  will return </p><br><table><thead><tr><th>  surname </th></tr></thead><tbody><tr><td>  Ivanov </td></tr><tr><td>  Petrov </td></tr><tr><td>  Sidorov </td></tr></tbody></table><br><p>  However, all we have to do is to take all students from both classes and sort them out, as <code>explain</code> immediately issue an ominous <code>Using filesort</code> or <code>Using temporary</code> : </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">`surname`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`schoolkids`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-string"><span class="hljs-string">`class`</span></span> = <span class="hljs-string"><span class="hljs-string">'1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">`liter`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-string"><span class="hljs-string">`surname`</span></span></code> </pre> <br><table><thead><tr><th>  surname </th></tr></thead><tbody><tr><td>  Ivanov </td></tr><tr><td>  Kuznetsov </td></tr><tr><td>  Novikov </td></tr><tr><td>  Petrov </td></tr><tr><td>  Popov </td></tr><tr><td>  Sidorov </td></tr></tbody></table><br><p>  This happened obviously because the values ‚Äã‚Äãcan no longer be taken along the <em>pipeline</em> , so the DBMS needs to sort them by itself. </p><br><p>  Let's look at another example: you need to sort the previous request by <strong>message</strong> .  In this case, the attribute is already sorted, but relative to the index prefix, i.e.  relatively <strong>datetime</strong> . </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">`message`</span></span>, <span class="hljs-string"><span class="hljs-string">`datetime`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`log`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-string"><span class="hljs-string">`datetime`</span></span> &gt;= <span class="hljs-string"><span class="hljs-string">'2009-03-24 00:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">`datetime`</span></span> &lt; <span class="hljs-string"><span class="hljs-string">'2009-03-25 00:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-string"><span class="hljs-string">`message`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre> <br><p>  Explain: </p><br><pre> <code class="sql hljs"> id: 1 select_type: SIMPLE table: log partitions: NULL type: range possible_keys: datetime_message key: datetime_message key_len: 5 ref: NULL rows: 172242 filtered: 100.00 Extra: Using index condition; Using filesort</code> </pre> <br><p>  Why did <code>filesort</code> ?  Let us recall an example with schoolchildren: if thirty schoolchildren (index suffix) study in the same class (index prefix), then they are sorted by <em>pipeline</em> ‚Äìy;  however, when selecting several classes, you need to sort by hand (pick up a journal and create a new sorted list with all students of the 1st grade on a new sheet of paper).  Here is the same principle, but with the amendment that the <strong>datetime</strong> attribute is completely unique (equivalent to the fact that only one schoolchild learns in each class).  This means that the DBMS needs to do the sorting itself.  Therefore, in this query, <code>filesort</code> is the norm from which you cannot get anywhere. </p><br><h1 id="vsyo-rabotaet-no-vnezapno">  Everything works, but suddenly ... </h1><br><p>  However, after analyzing the most frequent sql ‚Äì queries made on the <code>log</code> table, it turned out that the most frequent operation performed in the application is to search for logs with specific <strong>message</strong> and type, without specific time intervals. <br>  For example, search for all errors with the message " <em>message 183</em> ". <br>  Such a request will not be optimal and will be executed in about 30 seconds: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">`datetime`</span></span>, <span class="hljs-string"><span class="hljs-string">`message`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`log`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-string"><span class="hljs-string">`message`</span></span> = <span class="hljs-string"><span class="hljs-string">'message 183'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">`type`</span></span> = <span class="hljs-string"><span class="hljs-string">'error'</span></span>;</code> </pre> <br><p>  Explain of this request gave the following picture: </p><br><pre> <code class="sql hljs"> id: 1 select_type: SIMPLE table: log partitions: NULL type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 10010745 filtered: 3.33 Extra: Using where</code> </pre> <br><p>  Now it is clear that the index is not used at all.  This is understandable: it is too expensive to search for information on the index suffix. </p><br><p>  We conclude that we need to change the structure of the index so that the <strong>message comes</strong> first: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-string"><span class="hljs-string">`datetime_message`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-string"><span class="hljs-string">`log`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-string"><span class="hljs-string">`message_datetime`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-string"><span class="hljs-string">`log`</span></span>(<span class="hljs-string"><span class="hljs-string">`message`</span></span>(<span class="hljs-number"><span class="hljs-number">150</span></span>), <span class="hljs-string"><span class="hljs-string">`datetime`</span></span>);</code> </pre> <br><p>  Now the query that would have dropped the database when the index was past, looks quite optimal: </p><br><pre> <code class="sql hljs"> id: 1 select_type: SIMPLE table: log partitions: NULL type: ref possible_keys: message_datetime key: message_datetime key_len: 452 ref: const rows: 1000 filtered: 100.00 Extra: Using where</code> </pre> <br><p>  However, the old request for receiving messages for a specific date is now non-optimal. <br>  But <em><em>if it is rarely executed, then it can be left non-optimal</em></em> , since the main optimization task is completed: all <em>frequent</em> queries to the database are optimized. </p><br><h1 id="podvedyom-itogi">  Let's sum up </h1><br><p>  Not always the most selective column should be in the prefix of the composite index. <br>  There are situations when the attribute that has a bunch of repetitions in the table is the most frequently selected.  And there is no sense to put it to the right, because the search operations on it will lead to a complete search of the index tree. </p><br><p>  There are people who consider it a <em>myth</em> to put the most selective column to the left. <br>  It is difficult to call it a myth, because in practice the most selective column gives more advantage in the search over the others. </p><br><p>  In addition to selectivity, it is necessary to pay attention to the subject area itself, and, first of all, to make a start from its requirements, and not just from dry data. </p><br><h2>  useful links </h2><br><ul><li>  <a href="https://www.sqlinthewild.co.za/index.php/2009/01/19/index-columns-selectivity-and-equality-predicates/">Why putting the most selective column to the left is a myth</a> </li><li>  <a href="https://use-the-index-luke.com/">Use the index, Luke!</a>  This is probably the must have of any database development.  The optimal use of indexes, a large number of examples with queries and chips for various DBMS are very well explained. </li><li>  <a href="https://use-the-index-luke.com/sql/myth-directory/most-selective-first">Once again on the topic of why the most selective column on the left is a myth</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/351942/">https://habr.com/ru/post/351942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351930/index.html">How to stay in the TOP when changing search algorithms (a guide for novice SEOs)</a></li>
<li><a href="../351932/index.html">Installing Debian with a root on an encrypted ZFS mirror</a></li>
<li><a href="../351936/index.html">New life for XMPP. Making an instant messenger that fails to block</a></li>
<li><a href="../351938/index.html">Video Streaming with Azure and .NET</a></li>
<li><a href="../351940/index.html">Marvin Minsky "The Emotion Machine": Chapter 2 "Conscience, Values ‚Äã‚Äãand Own Ideals"</a></li>
<li><a href="../351944/index.html">Creating a chatbot using Q & A Maker and Microsoft Graph</a></li>
<li><a href="../351946/index.html">Arduino controller with temperature sensor and Python interface for dynamic identification of control objects</a></li>
<li><a href="../351948/index.html">Analysis of data in sports: the interaction of scientists, clubs and federations. Lecture in Yandex</a></li>
<li><a href="../351950/index.html">The artist encrypted the keys to the cryptocross in Lego-installations, and we will try to get them from there</a></li>
<li><a href="../351952/index.html">Data collection terminal for USAIS, or the illusion of deception</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>