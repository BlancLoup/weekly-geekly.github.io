<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Jinja2 Extensions Guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jinja2 - Python-library for rendering templates, which is the de facto standard when writing web applications on Flask and a fairly popular alternativ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Jinja2 Extensions Guide</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/e08/d18/3c4/e08d183c4ba545cb95fc71ac220b7083.png" align="right">  <a href="http://jinja.pocoo.org/">Jinja2</a> - Python-library for rendering templates, which is the de facto standard when writing web applications on Flask and a fairly popular alternative to the built-in Django template system.  Although being strongly tied to the language, Jinja2 positions itself as a tool for designers and layout designers, simplifying the layout and separating it from development, and trying to isolate non-developers from Python as far as possible.  Layout, however, is not the only possible application;  For example, in my work I use Jinja2 templates to generate SQL queries. <br><br>  Jinja2 is <a href="http://jinja.pocoo.org/docs/2.9/extensions/">extensible</a> , and many features (for example, internationalization and loop management) are implemented as extensions.  However, the documentation on writing extensions, it seems to me, is somewhat incomplete;  from the example of a simple (but carefully commented) extension, it jumps immediately to the description of the API of <em>some</em> Jinja2 classes, which is rather difficult to read in a row.  In this article, I will try to correct this omission and create in the reader‚Äôs head a complete and clear picture of how Jinja2 works, how its extensions are arranged and how to use extensions to modify different stages of pattern processing. <br><a name="habracut"></a><br><h2><img src="https://habrastorage.org/webt/59/e6/2d/59e62d97e317d706694879.png" align="right" width="49" height="47"><img src="https://habrastorage.org/webt/59/e6/30/59e6302793b0a374026895.png" width="265" height="57" alt="How does Jinja2 work"></h2><br>  Globally, Jinja2 compiles each pattern in Python executable, which accepts a context for input and returns a string - a rendered pattern.  The whole process looks like this. <br><br><ol><li>  <b>Loading</b>  You can store templates in the file system, in a folder with your Python package, in memory, or simply generate on the fly ‚Äî first of all, Jinja2 determines which method is relevant and loads the template's sources into memory. </li><li> <b>Tokenization</b> .  The lexer analyzer (lexer) beats the template source code for the simplest entities - tokens.  An example of a token is the opening tag <code>{%</code> . </li><li>  <b>Parsing</b>  The parser parses the stream of tokens, isolating the syntax constructs.  An example of a syntactic construct is the <code>{{ variable }}</code> construct that substitutes the value of a variable (it consists of three tokens ‚Äî the opening <code>{{</code> , <code>variable</code> name and closing <code>}}</code> ). </li><li>  <b>Optimization</b> .  At this stage, all constant expressions are evaluated.  For example, the <code>{{ 1 + 2 }}</code> construct will be turned into <code>{{ 3 }}</code> . </li><li>  <b>Generation</b>  Syntax constructs that are still stored as an abstract syntax tree (AST) are converted into Python code. </li><li>  <b>Compilation</b>  The resulting Python code is compiled by the built-in <code>compile</code> functions.  The resulting object can be run using the built-in <code>exec</code> function, which is what templates do when rendering. </li></ol><br><h2><img src="https://habrastorage.org/webt/59/e6/2d/59e62d97e317d706694879.png" align="right" width="49" height="47"><img src="https://habrastorage.org/webt/59/e6/2f/59e62fb1cefcf949400152.png" width="471" height="57" alt="How are the extensions in Jinja2"></h2><br>  To create an extension in Jinja2, you need to define a class that inherits from <code>jinja2.ext.Extension</code> .  To activate an extension, it is enough to list it in the list of extensions when creating an environment (environment) or add it after creation by the <code>add_extension</code> method. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A brief illustration instead of a thousand words: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> jinja2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Environment <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> jinja2.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Extension <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFirstExtension</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Extension)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MySecondExtension</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Extension)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> environment = Environment(extensions=[MyFirstExtension]) environment.add_extension(MySecondExtension) print(environment.extensions) <span class="hljs-comment"><span class="hljs-comment">#  -  # {'__main__.MySecondExtension': &lt;__main__.MySecondExtension object at 0x0000000002FF1780&gt;, '__main__.MyFirstExtension': &lt;__main__.MyFirstExtension object at 0x0000000002FE9BA8&gt;}</span></span></code> </pre> <br>  It remains to teach them to do something!  To do this, we have, by and large, only three methods that can be overridden: <br><br><ul><li>  <code>preprocess</code> ; </li><li>  <code>filter_stream</code> (whatever that means); </li><li>  <code>parse</code> . </li></ul><br>  Well, let's start in order. <br><br><h2><img src="https://habrastorage.org/webt/59/e6/2d/59e62d97e317d706694879.png" align="right" width="49" height="47"><img src="https://habrastorage.org/webt/59/e7/ac/59e7ace5800da675423865.png" width="471" height="57" alt="We manage source loading"></h2><br>  The simplest way to manage directly downloading source templates is to implement your own loader.  Make it elementary: inherit from <code>jinja2.loaders.BaseLoader</code> , override the <code>get_source(environment, template_name)</code> method <code>get_source(environment, template_name)</code> - done.  Sometimes it is even meaningful.  So, if one day you were able to replace the whole template folder with one elegant function generating them, for backward compatibility with other parts of the program, you may want to write a bootloader pretending that these templates are still there (and make a sweet <code>git rm</code> ) . <br><br>  However, this is offtopic: where are the extensions?  It is clear that I can at any moment inherit from what I want and change there that I see fit!  Surprisingly, the API extensions, too, just in case, there is a way to directly manage the source code of the templates. <br><br>  Thus, the <code>Extension</code> class contains the <code>preprocess</code> method, which is called for each template after loading and before tokenization.  The signature looks like this: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">preprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, source, name, filename=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" : source (String) -    name (String) -   filename (String  None) -   ( ) : String -     """</span></span></code> </pre> <br>  In this method, you can do anything.  Technically, somewhere here you can implement the compilation of your own template language into Jinja2 templates.  But why?  Probably, the ability to modify the source directly may be useful to you as an auxiliary when writing non-trivial extensions.  However, knowledge of the Jinja2 API or features of its implementation is not required here, so we will no longer go into the details of this stage and move on to the tokenization. <br><br><h2><img src="https://habrastorage.org/webt/59/e6/2d/59e62d97e317d706694879.png" align="right" width="49" height="47"><img src="https://habrastorage.org/webt/59/e7/ad/59e7ad873b1aa161737721.png" width="476" height="57" alt="Manage token splitting"></h2><br>  The <code>filter_stream</code> method is of much more interest to us. It attracts us with rich possibilities for customization, which it opens and with its mysterious name.  The signature looks like this: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter_stream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, stream)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" : stream (jinja2.lexer.TokenStream) -      : jinja2.lexer.TokenStream -      """</span></span></code> </pre> <br>  In general, the interaction of lexical and syntactic analyzers in Jinja2 is arranged as follows.  The lexical analyzer ( <code>jinja2.lexer.Lexer</code> ) produces a generator that <code>jinja2.lexer.Token</code> all tokens one after the other ( <code>jinja2.lexer.Token</code> ) and wraps this generator into a <code>jinja2.lexer.TokenStream</code> object, which buffers the stream and provides a number of convenient methods for parsing (for example, the ability to view the current token without pulling it out of the stream).  Extensions, in turn, can influence this stream, and not only filter (as the name of the method suggests), but also enrich. <br><br>  Tokens in Jinja2 are very simple objects.  In essence, these are tuples of three named fields: <br><br><ul><li>  <code>lineno</code> - line number with token; </li><li>  <code>type</code> - token type; </li><li>  <code>value</code> is the string value of the token. </li></ul><br>  The various constants for the <code>type</code> field are defined in <code>jinja2/lexer.py</code> : <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">TOKEN_ADD</span></span> TOKEN_NE TOKEN_VARIABLE_BEGIN TOKEN_ASSIGN TOKEN_PIPE TOKEN_VARIABLE_END TOKEN_COLON TOKEN_POW TOKEN_RAW_BEGIN TOKEN_COMMA TOKEN_RBRACE TOKEN_RAW_END TOKEN_DIV TOKEN_RBRACKET TOKEN_COMMENT_BEGIN TOKEN_DOT TOKEN_RPAREN TOKEN_COMMENT_END TOKEN_EQ TOKEN_SEMICOLON TOKEN_COMMENT TOKEN_FLOORDIV TOKEN_SUB TOKEN_LINESTATEMENT_BEGIN TOKEN_GT TOKEN_TILDE TOKEN_LINESTATEMENT_END TOKEN_GTEQ TOKEN_WHITESPACE TOKEN_LINECOMMENT_BEGIN TOKEN_LBRACE TOKEN_FLOAT TOKEN_LINECOMMENT_END TOKEN_LBRACKET TOKEN_INTEGER TOKEN_LINECOMMENT TOKEN_LPAREN TOKEN_NAME TOKEN_DATA TOKEN_LT TOKEN_STRING TOKEN_INITIAL TOKEN_LTEQ TOKEN_OPERATOR TOKEN_EOF TOKEN_MOD TOKEN_BLOCK_BEGIN TOKEN_MUL TOKEN_BLOCK_END</code> </pre> <br>  A typical extension manipulating tokens should look something like this: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> jinja2.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Extension <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> jinja2.lexer <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TokenStream <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TokensModifyingExtension</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Extension)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter_stream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, stream)</span></span></span><span class="hljs-function">:</span></span> generator = self._generator(stream) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lexer.TokenStream(generator, stream.name, stream.filename) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_generator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, stream)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> token <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> stream: <span class="hljs-comment"><span class="hljs-comment">#        .  . #   -    yield token #   .</span></span></code> </pre> <br>  As an example, let's write an extension that changes the logic for rendering variables.  Suppose you want some of your objects to behave differently when they are converted to a string by the <code>str</code> function when rendering in Jinja2.  Let our objects have an option to define the <code>__jinja__(self)</code> method to be used in the templates.  The easiest way to do this is by adding a custom filter that calls the <code>__jinja__</code> method, and automatically substitute its call into each construct of the form <code>{{ &lt;expression&gt; }}</code> .  All extension code will look like this: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> jinja2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Environment <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> jinja2.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Extension <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> jinja2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lexer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VariablesCustomRenderingExtension</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Extension)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    .         # ,       . @staticmethod def _jinja_or_str(obj): try: return obj.__jinja__() except AttributeError: return obj def __init__(self, environment): super(VariablesCustomRenderingExtension, self).__init__(environment) #    .     #      ,   . self._filter_name = "jinja_or_str" environment.filters.setdefault(self._filter_name, self._jinja_or_str) def filter_stream(self, stream): generator = self._generator(stream) return lexer.TokenStream(generator, stream.name, stream.filename) def _generator(self, stream): #     ,     # {{ &lt;expression&gt; }}   {{ (&lt;expression&gt;)|jinja_or_str }} for token in stream: if token.type == lexer.TOKEN_VARIABLE_END: #     {{ &lt;expression&gt; }} -  #   `)|jinja_or_str`. yield lexer.Token(token.lineno, lexer.TOKEN_RPAREN, ")") yield lexer.Token(token.lineno, lexer.TOKEN_PIPE, "|") yield lexer.Token( token.lineno, lexer.TOKEN_NAME, self._filter_name) yield token if token.type == lexer.TOKEN_VARIABLE_BEGIN: #     {{ &lt;expression&gt; }} -  #   `(`. yield lexer.Token(token.lineno, lexer.TOKEN_LPAREN, "(")</span></span></code> </pre> <br>  Usage example: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kohai</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__jinja__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"senpai rendered me!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: env = Environment(extensions=[VariablesCustomRenderingExtension]) template = env.from_string(<span class="hljs-string"><span class="hljs-string">"""Kohai says: {{ kohai }}"""</span></span>) print(template.render(kohai=Kohai())) <span class="hljs-comment"><span class="hljs-comment">#  "Kohai says: senpai rendered me!".</span></span></code> </pre> <br>  Can be viewed entirely <a href="https://github.com/Saluev/habrahabr-jinja-demo/blob/master/variables_custom_rendering.py">on Github</a> . <br><br><h2><img src="https://habrastorage.org/webt/59/e6/2d/59e62d97e317d706694879.png" align="right" width="49" height="47"><img src="https://habrastorage.org/webt/59/e7/b0/59e7b046b714a665686647.png" width="416" height="57" alt="Manage AST compilation"></h2><br>  The last and most interesting method of the <code>Extension</code> class available for overriding is <code>parse</code> . <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parser)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" : parse (jinja2.parser.Parser) -    : jinja2.nodes.Stmt  List[jinja2.nodes.Stmt] -  AST,     """</span></span></code> </pre> <br>  It works in conjunction with the <code>tags</code> attribute, which can be defined in the extension class.  This attribute must contain multiple tags, the processing of which will be entrusted to your extension, for example: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatNTimesExtension</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Extension)</span></span></span><span class="hljs-class">:</span></span> tags = {<span class="hljs-string"><span class="hljs-string">"repeat"</span></span>}</code> </pre> <br>  Accordingly, the <code>parse</code> method will be called when the syntax analysis reaches the construction with the beginning of the corresponding tag: <br><br><pre> <code class="html hljs xml">some text and then {% repeat ... ^</code> </pre> <br>  At the same time, the <code>parser.stream.current</code> attribute indicating the token currently being processed will contain <code>Token(lineno, TOKEN_NAME, "repeat")</code> . <br><br>  Next, inside the <code>parse</code> method, we need to <code>parse</code> our custom tag and return the result of the parsing ‚Äî one or more nodes of the syntax tree.  Jinja2 does not allow you to start your own node types, so you have to be content with built-in ones;  Fortunately, there is a (almost) universal <code>CallBlock</code> node, which I will <code>CallBlock</code> below. <br><br>  In the meantime, the logic of existing types of nodes like <code>For</code> us suits us, here is a set of recipes that you may want to use inside the <code>parse</code> method. <br><br><ul><li> <code>lineno = next(parser.stream).lineno</code> <br>  Usually the first line in the <code>parse</code> code.  The call <code>next</code> shifts the parser to the next token after the tag name and returns the current one.  We only remember the line number from it;  we will need to specify it when creating nodes, so that in case of errors in the traceback, their source is correctly indicated - our custom tag.  (Details on the creation of nodes will be slightly lower.) </li><li> <code>parser.stream.expect(token_description)</code> <br>  Return the current token and move to the next, if the current fits the description, or fall with an error.  Here the description is either a <code>type</code> token, or a string of the form <code>"type:value"</code> .  So, <code>parser.stream.expect("integer")</code> will try to read the number and return it, or it falls;  <code>parser.stream.expect("name:in")</code> used when parsing the for tag to make sure that the in keyword goes further in the code and skip it. </li><li> <code>parser.stream.skip_if(token_description)</code> <br>  Returns <code>True</code> and returns to the next token if the current token fits the description;  otherwise, it returns <code>False</code> .  A typical use is the parsing of optional constructs.  For example, everything is in the same parsing code for: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> parser.stream.skip_if(<span class="hljs-string"><span class="hljs-string">'name:if'</span></span>): test = self.parse_expression()</code> </pre> <br>  (Yes, in Jinja2, the for loop has an optional if suffix.) </li><li> <code>expr_node = parser.parse_expression()</code> <br>  Attempts to parse the expression and return the corresponding node to AST or falls.  It should be used for parsing tag parameters.  In the example above, for uses this call to parse the filter condition;  he also uses it after <code>expect("name:in")</code> to figure out what iteration the loop will be on. </li><li> <code>target_node = parser.parse_assign_target(extra_end_rules=[])</code> <br>  Attempts to parse an lvalue, that is, an expression that can be assigned, or falls.  Typical examples are a variable name, several variable names separated by commas, an expression with an index.  Because Python allows free commas at the end of tuples (for example, <code>for a, b, c, in []: pass</code> ), this method can accept additional break conditions (for example, when parsing a list of loop variables, it calls it with <code>extra_end_rules=["name:in"]</code> , so that <code>in</code> random is not recognized as another variable). <br></li><li> <code>body_nodes = parser.parse_statements(end_tokens=[], drop_needle=True)</code> <br>  Parsit tag internals.  Assumes that <code>parser.stream.current</code> already points to <code>%}</code> (otherwise it drops), and the template parses until it hits the end of the file or the token that <code>end_tokens</code> one of the descriptions in <code>end_tokens</code> .  So, the if tag calls this method with <code>end_tokens=["name:elif", "name:else", "name:endif"]</code> .  Parameter <code>drop_needle=True</code> indicates that this last token should be thrown away after parsing;  conveniently, if the body of your tag can end in only one way. <br></li></ul><br>  Parse everything you need, you may want to create one or more tree nodes in order to return them as a result of parsing.  What you need to know about creating Jinja2 nodes: <br><br><ul><li>  All node classes are defined in <code>jinja2.nodes</code> and are inherited from <code>jinja2.nodes.Node</code> .  Their list cannot be expanded. </li><li>  Only nodes inheriting from <code>jinja2.nodes.Stmt</code> can be directly returned from <code>parse</code> .  The rest can sometimes work, but they can break everything.  So you can choose from the following classes: <br><br><pre> <code class="html hljs xml">Assign ExprStmt Include AssignBlock Extends Macro Block FilterBlock Output Break For Scope CallBlock FromImport ScopedEvalContextModifier Continue If EvalContextModifier Import</code> </pre> </li><li>  In each class inheriting from <code>Node</code> , a field is defined with a list of fields.  You can create a node either by specifying all the fields, or by not specifying any fields (they will be initialized <code>None</code> and their values ‚Äã‚Äãcan be specified later).  Also, when creating all nodes with a key argument, you can specify <code>lineno</code> ;  use this to get adequate tracebacks in case of errors. <br>  Examples: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> jinja2.nodes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-comment"><span class="hljs-comment">#    #  () : template_name = Const("lib/stuff.j2") #     (     None): inc_node = Include(template_name, False, False, lineno=0) #      : inc_node = Include(lineno=0) inc_node.template = template_name inc_node.with_context = False inc_node.ignore_missing = False # ,    .  Jinja2   #      (    If  - # )    ;       #   None,  ,  , . # lineno     : inc_node = Include() inc_node.lineno = 0</span></span></code> </pre> <br>  Please note that the fields cannot be specified with key arguments: construction <br><br><pre> <code class="python hljs">Include(template=template_name, with_context=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, ignore_missing=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>)</code> </pre>  will not work. </li><li>  Many node fields are also nodes.  So, <code>Include</code> will not agree to accept the string <code>"lib/stuff.j2"</code> as a template field - only <code>nodes.Const("lib/stuff.j2")</code> .  If you are not sure what type this or that field is, find the code parsing the corresponding node in <code>jinja2/parser.py</code> - it‚Äôs easy to figure out (at least after reading this article ... it should be). </li></ul><br>  As an example of applying all of this knowledge, let's consider a simple extension that adds the <code>{% repeat N times %}...{% endrepeat %}</code> construct as syntactic sugar for the <code>{% for _ in range(N) %}...{% endfor %}</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> jinja2.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Extension <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> jinja2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> nodes <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatNTimesExtension</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Extension)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#  ,          repeat. #      -  endrepeat,  . tags = {"repeat"} def parse(self, parser): lineno = next(parser.stream).lineno #     . "store" -   ( #   "load",       ). index = nodes.Name("_", "store", lineno=lineno) #    N.       . how_many_times = parser.parse_expression() #   - ,  Jinja2   #  `range(N)`. iterable = nodes.Call( nodes.Name("range", "load"), [how_many_times], [], None, None) #      times. #     ,   . parser.stream.expect("name:times") #      {% endrepeat %}. body = parser.parse_statements(["name:endrepeat"], drop_needle=True) #   for.       #  . return nodes.For(index, iterable, body, [], None, False, lineno=lineno)</span></span></code> </pre> <br>  Usage example: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: env = Environment(extensions=[RepeatNTimesExtension]) template = env.from_string(<span class="hljs-string"><span class="hljs-string">u""" {%- repeat 3 times -%} {% if not loop.first and not loop.last %}, {% endif -%} {% if loop.last %}    {% endif -%}  {%- endrepeat -%} """</span></span>) print(template.render()) <span class="hljs-comment"><span class="hljs-comment">#  ",     ".</span></span></code> </pre> <br>  Can be viewed entirely <a href="https://github.com/Saluev/habrahabr-jinja-demo/blob/master/repeat_n_times.py">on Github</a> . <br><br><h2><img src="https://habrastorage.org/webt/59/e6/2d/59e62d97e317d706694879.png" align="right" width="49" height="47"><img src="https://habrastorage.org/webt/59/e7/b0/59e7b0ed10ea8771782679.png" width="295" height="57" alt="Using CallBlock"></h2><br>  Since, due to the intricacies of the Jinja2 architecture, it is impossible to add new classes of nodes of the syntactical tree, we need some kind of universal node in which we could do any processing that we like.  There is such a node, and this is <code>CallBlock</code> . <br><br>  Let's first recall how the <code>{% call %}</code> tag works on its own.  Example from <a href="http://jinja.pocoo.org/docs/2.9/templates/">official documentation</a> : <br><br><pre> <code class="html hljs xml">{% macro dump_users(users) -%} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> {%- for user in users %} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>{{ user.username|e }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>{{ caller(user) }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> {%- endfor %} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> {%- endmacro %} {% call(user) dump_users(list_of_user) %} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dl</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dl</span></span></span><span class="hljs-tag">&gt;</span></span>Realname<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dl</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dd</span></span></span><span class="hljs-tag">&gt;</span></span>{{ user.realname|e }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dd</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dl</span></span></span><span class="hljs-tag">&gt;</span></span>Description<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dl</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dd</span></span></span><span class="hljs-tag">&gt;</span></span>{{ user.description }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dd</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dl</span></span></span><span class="hljs-tag">&gt;</span></span> {% endcall %}</code> </pre> <br>  The following happens: <br><br><ol><li>  A temporary macro called <code>caller</code> .  Macro body - contents between <code>{% call... %}</code> and <code>{% endcall %}</code> .  A macro can either have arguments (in the example above it is one <code>user</code> argument) or not (if the simplified construct <code>{% call something(...) %}</code> ). </li><li>  The macro specified after the <code>call(...)</code> construction is <code>call(...)</code> .  He has access to the <code>caller</code> macro and may use it (or perhaps not). </li></ol><br>  However, a macro in Jinja2 is nothing more than a function that returns a string.  Therefore, the <code>CallBlock</code> node can as well be fed the functions defined by us somewhere in the depths of our extensions. <br><br>  A typical extension that uses <code>CallBlock</code> for word processing looks something like this: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> jinja2.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Extension <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> jinja2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> nodes <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReplaceTabsWithSpacesExtension</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Extension)</span></span></span><span class="hljs-class">:</span></span> tags = {<span class="hljs-string"><span class="hljs-string">"replacetabs"</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parser)</span></span></span><span class="hljs-function">:</span></span> lineno = next(parser.stream).lineno <span class="hljs-comment"><span class="hljs-comment">#  ,  : body = parser.parse_statements( ["name:endreplacetabs"], drop_needle=True) # ! return nodes.CallBlock( self.call_method("_process", [nodes.Const(" ")]), [], [], body, lineno=lineno) def _process(self, replacement, caller): text = caller() return text.replace("\t", replacement)</span></span></code> </pre> <br>  How it works? <br><br><ul><li>  <code>call_method</code> is a special class method called <code>Extension</code> , which wraps the call to a class method on a Jinja2 node.  The result can be passed as a parameter to where Jinja2 expects any expression, and in particular to where it expects exactly the function call ‚Äî to <code>CallBlock</code> . </li><li>  When the time returned from our <code>parse</code> <code>CodeBlock</code> 's method is rendered, it will call the <code>ReplaceTabsWithSpacesExtension._process</code> method.  First, the arguments specified when calling <code>call_method</code> will be passed (in our case, one argument is a string of four spaces), then the same <code>caller</code> , which is just a Jinja2 macro and which can be simply called to get a string. </li><li>  If the <code>caller</code> macro should be called with arguments, they should be listed in the fields of the <code>CodeBlock</code> node (where, in our example, there are empty lists). </li></ul><br>  See the usage example <a href="https://github.com/Saluev/habrahabr-jinja-demo/blob/master/replace_tabs_with_spaces.py">on Github</a> . <br><br>  And finally, a slightly more complicated example of an extension that uses <code>CallBlock</code> and one more thing that we went through today is an indenting fixer.  It is known that it is almost impossible to write at least some non-trivial templates on Jinja2 so that both the source code of the template and the result look good in terms of indents.  Let's try to add a tag that corrects this misunderstanding. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> jinja2.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Extension <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> jinja2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lexer, nodes <span class="hljs-comment"><span class="hljs-comment">#       ,  - #   __slots__ = ()   .  , Jinja2 #    - lexer.Token. class RichToken(lexer.Token): pass class AutoindentExtension(Extension): tags = {"autoindent"} #       - #    ? _indent_regex = re.compile(r"^ *") _whitespace_regex = re.compile(r"^\s*$") def _generator(self, stream): #        ,    #    .       (  #  Jinja2). last_line = "" last_indent = 0 for token in stream: if token.type == lexer.TOKEN_DATA: #   - . last_line += token.value if "\n" in last_line: _, last_line = last_line.rsplit("\n", 1) last_indent = self._indent(last_line) #  ^W  . token = RichToken(*token) token.last_indent = last_indent yield token def filter_stream(self, stream): return lexer.TokenStream( self._generator(stream), stream.name, stream.filename) def parse(self, parser): #     autoindent,     , , #   . ,      . last_indent = nodes.Const(parser.stream.current.last_indent) lineno = next(parser.stream).lineno body = parser.parse_statements(["name:endautoindent"], drop_needle=True) #      :) return nodes.CallBlock( self.call_method("_autoindent", [last_indent]), [], [], body, lineno=lineno) def _autoindent(self, last_indent, caller): text = caller() #     ,       #  last_indent.     (, ,  #       ,   ), #       . lines = text.split("\n") if len(lines) &lt; 2: return text first_line, tail_lines = lines[0], lines[1:] min_indent = min( self._indent(line) for line in tail_lines if not self._whitespace_regex.match(line) ) if min_indent &lt;= last_indent: return text dindent = min_indent - last_indent tail = "\n".join(line[dindent:] for line in tail_lines) return "\n".join((first_line, tail)) def _indent(self, string): return len(self._indent_regex.match(string).group())</span></span></code> </pre><br>  Usage example: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: env = Environment(extensions=[AutoindentExtension]) template = env.from_string(<span class="hljs-string"><span class="hljs-string">u""" {%- autoindent %} {% if True %} What is true, is true. {% endif %} {% if not False %} But what is false, is not true. {% endif %} {% endautoindent -%} """</span></span>) print(template.render()) <span class="hljs-comment"><span class="hljs-comment">#     .</span></span></code> </pre> <br>    <a href="https://github.com/Saluev/habrahabr-jinja-demo/blob/master/autoindent.py"> Github</a> . <br><br>         ! <br><br> <i>   Jinja   ,   ,   Jinja ( <a href="https://github.com/pallets/jinja/blob/master/LICENSE"></a> ).</i> </div><p>Source: <a href="https://habr.com/ru/post/340254/">https://habr.com/ru/post/340254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340242/index.html">Search and fix bugs in PHP source</a></li>
<li><a href="../340246/index.html">PHP page navigation</a></li>
<li><a href="../340248/index.html">Creating distributions for different operating systems in Java 9 and 10</a></li>
<li><a href="../340250/index.html">In simple words: smart contracts, Ethereum, ICO</a></li>
<li><a href="../340252/index.html">China is a digital power. Impressions of Huawei Connect 2017</a></li>
<li><a href="../340256/index.html">BlackOasis APT: a new campaign with a new zerodem</a></li>
<li><a href="../340258/index.html">Hacking visual system: 11 optical illusions in graphic design</a></li>
<li><a href="../340262/index.html">Recommender system on the knee as a means against existential crisis</a></li>
<li><a href="../340264/index.html">8 key decisions in development on React</a></li>
<li><a href="../340266/index.html">What you need to know the head of the IT department?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>