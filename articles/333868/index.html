<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cooking cache correctly</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many believe that the cache, and even distributed, is such an easy way to make everything faster and better. But, as practice shows, incorrect use of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cooking cache correctly</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/-v/wp/ex/-vwpexz84vay0dn31k6fnc7i4pu.png"></div><br><p>  Many believe that the cache, and even distributed, is such an easy way to make everything faster and better.  But, as practice shows, incorrect use of the cache often, if not always, makes everything worse. </p><br><p>  Under the cut, a couple of stories await you about how an improperly bolted cache killed a performance. </p><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Unconventional disclaimer</b> <div class="spoiler_text"><ul><li>  All the events described in the article are fictitious, any coincidences with real deployments are random. </li><li>  The <a href="https://ignite.apache.org/">Apache Ignite</a> logic described in the article is intentionally simplified, important details are omitted. </li><li>  Do not try to repeat this in production without reading the <a href="https://apacheignite.readme.io/docs">official documentation</a> thoughtfully! </li><li>  Some of the design patterns described are anti-patterns, remember this before implementation :) </li></ul></div></div><br><h3 id="moya-baza-tormozit-a-s-vashem-keshem-tormozit-esche-bolshe-">  My base slows down, and with your cache it slows down even more: ( </h3><br><p>  What does an average web service look like? </p><br><pre><code class="hljs"> ‚ü∑  </code> </pre> <br><p>  When the database stops cope need to do what? <br>  Right!  Buy a new iron! <br>  And when will not help? <br>  Right!  Configure the cache, preferably distributed! </p><br><pre> <code class="hljs"> ‚ü∑  ‚ü∑  </code> </pre> <br><p>  Will it be faster?  Is not a fact! </p><br><p>  Why?  Suppose you have achieved incredible concurrency and can accept thousands of requests at the same time.  But, all of them will come in one key - a hot offer from the first page. <br>  Further, all threads will follow the same logic: ‚Äúthere are no values ‚Äã‚Äãin the cache, I will follow it to the base‚Äù. </p><br><p>  What will happen in the end?  Each thread comes down to the database and updates the value in the cache.  As a result, the system will spend more time than if the cache was not in principle. </p><br><p>  And the solution to the problem is very simple - synchronization of requests for the same keys. </p><br><p>  <a href="https://ignite.apache.org/">Apache Ignite</a> offers simple caching via <a href="https://spring.io/guides/gs/caching/">Spring Caching</a> with synchronization support. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Cacheable</span></span>(<span class="hljs-string"><span class="hljs-string">"dynamicCache"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cacheable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       :( return longOp(key); } @Cacheable(value = "dynamicCache", sync = true) public String cacheableSync(Integer key) { // ,   ,     //   ,    , //    ,    longOp(key) return longOp(key); }</span></span></code> </pre> <br><p>  Synchronization functionality was added to <a href="https://ignite.apache.org/">Apache Ignite</a> <a href="https://issues.apache.org/jira/browse/IGNITE-5030">in version 2.1</a> . </p><br><h3 id="teper-bystro-no-vsyo-eschyo-medlenno-">  Now fast!  But still slowly: ( </h3><br><p>  This story is a direct continuation of the previous one and is intended to show that the developers of caches also do not always use them correctly. </p><br><p>  So, the fix adding cache synchronization turned out to be in production and ... did not help. </p><br><p>  No one broke for the hot product from the first page, and all 1000 threads went to different keys at the same time, and synchronization mechanisms became a bottleneck. </p><br><p>  In the <a href="https://habrahabr.ru/company/gridgain/blog/328368/">previous article,</a> I talked about how the <a href="https://ignite.apache.org/">Apache Ignite</a> synchronization tools worked <strong>before</strong> . </p><br><p>  Information about all synchronization tools was previously stored in the <code>ignite-sys-cache</code> , using the <code>DATA_STRUCTURES_KEY</code> key in the form of <code>Map&lt;String, DataStructureInfo&gt;</code> and each synchronizer addition looked like: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      lock(cache, DATA_STRUCTURES_KEY); //    Map&lt;String, DataStructureInfo&gt; map = cache.get(DATA_STRUCTURES_KEY); map.put("Lock785", dsInfo); cache.put(DATA_STRUCTURES_KEY, map); //   unlock(cache, DATA_STRUCTURES_KEY)</span></span></code> </pre> <br><p>  In summary, when creating the necessary synchronizers, all threads sought to change the value with <strong>the same</strong> key. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qx/qy/rr/qxqyrriksbhwsnm8jhhcikje06o.jpeg"></div><br><h3 id="snova-bystro-no-nadezhno-li">  Fast again!  But is it safe? </h3><br><p>  <a href="https://ignite.apache.org/">Apache Ignite</a> got rid of the ‚Äúmost important‚Äù key <a href="https://issues.apache.org/jira/browse/IGNITE-5364">in version 2.1</a> , starting to save information about synchronizers separately.  Users received an increase of more than 9000% in the real scenario. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/web/61f/8c5/4f6/61f8c54f60e645069a5b9de02320a5b3.jpg"></div><br><p>  And everything was fine until the light blinked, the bespereboiniki failed, and the users lost their warmed cache. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5m/i7/4y/5mi74yvks6el6rtf0bu_al70kaw.jpeg"></div><br><p>  In <a href="https://ignite.apache.org/">Apache Ignite</a> , starting from version 2.1, there appeared its own <a href="https://apacheignite.readme.io/docs/distributed-persistent-store">persistence</a> implementation. </p><br><p>  But, by itself, Persistence does not give guarantees of obtaining a consistent state during restart, since  data is synchronized (flushed to disk) periodically, rather than in real time.  The main objective of Persistence is the ability to store and efficiently process more data on one computer than it enters into its memory. </p><br><p>  Consistency guarantee is achieved using the <a href="https://en.wikipedia.org/wiki/Write-ahead_logging">Write-ahead logging</a> approach.  Simply put, data is first written to disk as a logical operation, and then stored in a distributed cache. </p><br><p>  When the server is restarted on disk, we will have a status that is relevant at some point in time.  Enough for this state to roll WAL, and the system is again operational and consistent (full ACID).  Recovery takes seconds, at worst minutes, but not hours or days required to warm up the cache with actual requests. </p><br><h3 id="teper-nadezhno-bystro-li">  Now reliable!  Is it fast? </h3><br><p>  Persistence slows down the system (for writing, not for reading).  The included WAL slows down the system even more, it is a payment for reliability. </p><br><p>  There are several levels of logging that give different guarantees: </p><br><p>  - DEFAULT - full guarantees for saving data at any load level <br>  - LOG_ONLY - full guarantees, except for the case of failure of the operating system <br>  - BACKGROUND - there are no guarantees, but Apache Ignite will try :) <br>  - NONE - the log of operations is not kept. </p><br><p>  The difference in speed DEFAULT and NONE on the weighted average system reaches 10 times. </p><br><p>  Let's return to our situation.  Suppose we chose the BACKGROUND mode, which is 3 times slower than NONE and now we are not afraid to lose the warmed cache (we may lose operations from the last few minutes before the crash, but no more). </p><br><p>  In this mode, we worked for several months, anything happened and we easily restored the system after crashes.  All around happy and happy. </p><br><p>  If it were not for one ‚Äúbut‚Äù, today, on December 20, at the peak of sales, we realized that the servers are 80% loaded and are about to crash under load. </p><br><p>  Turning off WAL (transfer to NONE) would give us a 3 times reduction in load, but for this you need to restart the entire Apache Ignite cluster and lose the opportunity to recover on such a cluster in case of anything - go back to the ‚Äú <strong>fast and unreliable</strong> ‚Äù point? </p><br><p>  In <a href="https://ignite.apache.org/">Apache Ignite</a> , starting with <a href="https://issues.apache.org/jira/browse/IGNITE-7003">version 2.4</a> , it became possible to disable WAL without restarting the cluster, and then enable it with the restoration of all guarantees. </p><br><p>  SQL </p><br><pre> <code class="sql hljs">//  <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tableName NOLOGGING //  <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tableName <span class="hljs-keyword"><span class="hljs-keyword">LOGGING</span></span></code> </pre> <br><p>  Java </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   ignite.cluster().isWalEnabled(cacheName); //  ignite.cluster().disableWal(cacheName); //  ignite.cluster().enableWal(cacheName);</span></span></code> </pre> <br><h3 id="teper-i-bystro-i-nadezhno-no-esli-chto--est-varianty-">  Now and quickly and reliably, but if that - there are options ... </h3><br><p>  Now, if we need to disable logging (to hell with the guarantee, the main thing is to relive the load!) We can temporarily disable WAL and enable it at any convenient time. </p><br><div class="spoiler">  <b class="spoiler_title">It should be noted nevertheless that the feature was created absolutely not for this ...</b> <div class="spoiler_text"><p>  And to quickly download a huge set of historical data at the start of the system. <br>  It is also worth mentioning that disconnection is possible within only certain caches, and not the entire system, i.e.  in which case the data in the caches for which the disconnection was not conducted, will not be affected. </p></div></div><br><p>  At the same time, after WAL is turned on, the system guarantees the behavior according to the selected WAL mode. </p><br><h3 id="kesh-dazhe-raspredelennyy-ne-panaceya">  Kesh, even distributed, is not a panacea! </h3><br><p>  Not a single technology, no matter how sophisticated and advanced it is, can solve all your problems.  Incorrectly used technology is likely to make it worse, and used correctly, it is unlikely to close all the gaps. </p><br><p>  The cache, including the distributed one, is a mechanism that gives acceleration only with proper use and thoughtful tuning.  Keep this in mind before introducing it into your project, make measurements before and after in all the cases connected with it ... and let the performance be with you! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/333868/">https://habr.com/ru/post/333868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333856/index.html">MVC on pure javascript</a></li>
<li><a href="../333858/index.html">Results of the first round of CTFzone</a></li>
<li><a href="../333862/index.html">What to read about neural networks</a></li>
<li><a href="../333864/index.html">Bitfury Group conducted the 1st transaction in the Lightning Network using the bitcoin protocol</a></li>
<li><a href="../333866/index.html">Developer Life in Cyprus</a></li>
<li><a href="../333870/index.html">Red Architecture - red help button for complex and confusing systems</a></li>
<li><a href="../333872/index.html">Openstack. Detective story or where the connection is lost? Part three</a></li>
<li><a href="../333874/index.html">Inside Docker Networks: How Docker Uses iptables and Linux Interfaces</a></li>
<li><a href="../333878/index.html">PostgreSQL Indexes - 5</a></li>
<li><a href="../333880/index.html">RubyMine 2017.2: Docker Compose, RuboCop auto-correction in the editor, improved VCS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>