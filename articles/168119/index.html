<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Network Ring on Microcontrollers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear habrasoobschestvu! 
 Not so long ago, I had to deal with the network topology in the form of a ‚Äúredundant ring‚Äù, the principles of which I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Network Ring on Microcontrollers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/eb0/1c8/c52/eb01c8c5245f9d0fdf2ed81456c3ac5c.png" align="left"><br>  Hello, dear habrasoobschestvu! <br>  Not so long ago, I had to deal with the network topology in the form of a ‚Äúredundant ring‚Äù, the principles of which I would like to talk about. <br>  In order to avoid misunderstandings, I should say right away that only devices on microcontrollers are connected to the ring - there are no switches on the line and so on.  Only microcontrollers with a physical Ethernet layer in the form of a three-port hardware switch Micrel (about it - below).  Well, since Ethernet was used, I will allow myself the liberty to continue using the expression ‚Äúnetwork ring‚Äù. <br><br>  Initially, the post was planned as a translation of ways to organize a ring from <a href="http://www.micrel.com/_Products/LanSolutions/UnmanagedRedundantRingWP.pdf">this document</a> with <s>jokes and tricks with</s> comments and additions.  In the development process, the proposed options were tested, but they did not suit for some reason.  What this article was born from.  I hope that the ways of organizing the work of the network ring described here can be useful not only for me. <br>  Who cares - welcome under cat. <br>  <u><i>Under the cat a lot of letters and traffic</i></u> <br><a name="habracut"></a><br><br><h4>  A little bit of the simplest theory. </h4><br>  Whoever is familiar with the topic, can safely move on to the next section (‚ÄúThe Essence of the Task‚Äù). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's start from afar.  If it is necessary to combine more than two devices into one network, then the problem of network configuration arises.  After all, interconnected devices can be in several different ways (in a different order, so to speak).  The layout and connection of network devices is called <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2582%25D0%25B5%25D0%25B2%25D0%25B0%25D1%258F_%25D1%2582%25D0%25BE%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D1%258F">network topology</a> .  There are three basic topologies: Star, Tire and Ring.  In this article we will consider the topology in the form of a ring. <br><br>  So, imagine <s>spherical devices in vacuum,</s> several devices, networked as follows: <br><br><img src="https://habrastorage.org/storage2/b92/879/24c/b9287924c0bb2ebbdbf1e0baa698544d.png" align="left">  This is a typical network ring.  Typically, in such a ring, data is transmitted strictly in one direction (for example, clockwise).  In this case, the breakage of at least one communication line can lead to the inoperability of the entire system.  But depending on the method of communication between devices, the ring may become ‚Äúredundant‚Äù.  This means that even if we deliberately (or not deliberately) break one of the connections, data transfer between devices will still be possible in full.  But this requires the proper organization of the exchange in the network ring.  What we will do next. <br>  It is worth mentioning that in a ring topology, redundancy can also be achieved through the use of a double ring, in which data is duplicated and transmitted in different directions, but we will only talk about the topology with one ring. <br><br>  So, redundancy makes it possible to ensure operability in the case of a single break.  This is undoubtedly a plus, but on the other hand it creates some problems.  For example, if one of the devices sends broadcast packets (Broadcast), then each subsequent device in the ring will broadcast them to its neighbor and so in a circle to infinity, which ultimately can lead to a complete network failure (the so-called <a href="http://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B8%25D1%2580%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25B2%25D0%25B5%25D1%2589%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2588%25D1%2582%25D0%25BE%25D1%2580%25D0%25BC">Broadcast storm</a> ).  To prevent this, special protocols were developed to avoid ‚Äúlooping‚Äù, as well as to find the shortest paths in the network topology.  Such protocols, for example, are STP, RSTP, MSTP and STB.  Basically, these protocols are designed for complex topologies, in which configurations can be used both in the form of a star, and in the form of a ring, and in more complex combinations of the three basic topologies.  More information can be found <a href="http://habrahabr.ru/post/156695/">here</a> , <a href="http://habrahabr.ru/post/143768/">here</a> , and <a href="http://habrahabr.ru/post/129559/">here</a> . <br><br><h4>  The essence of the task </h4><br>  To organize the exchange between devices in such a way that a storm does not occur, and in the event of a single break, the network must remain operational.  In addition, it should be possible to accurately determine the location of the ring break. <br><br><h4>  What we have </h4><br><ul><li>  14 devices on microcontrollers (STM32F207) installed in an electric train </li><li>  Devices connected in one ring </li><li>  Micrel KSZ8863 / RLL hardware switch is used as the Ethernet physical layer. </li><li>  The load on the processor from the use of the network should be <b>minimal</b> .  In fact, this is one of the most ‚Äúmain-priority‚Äù requirements, since the real-time processor deals with quite resource-intensive tasks and every millisecond counts </li><li>  It so happened that the connection point-to-point was not needed.  Only Broadcast is used.  But the final solution allows you to implement this as well (with certain completion) </li></ul><br><br>  Since all further algorithms will be directly connected with the KSZ8863 / RLL switch, then a little more about it: <br>  <a href="http://www.micrel.com/_PDF/Ethernet/datasheets/KSZ8863MLL_FLL_RLL_DS.pdf">Datasheet here</a> <br>  In short: <br><ul><li>  a three-port switch (two Ethernet ports are ‚Äúout‚Äù and one is ‚Äúinward‚Äù per processor, hereinafter referred to as ports No. 1, 2 and 3, respectively) </li><li>  Separate MAC addresses for ports 1 and 2 </li><li>  Interfaces to the processor: MII and RMII plus interfaces for control - I2C and SPI </li><li>  8 static routes (oh, how late I saw this footnote in the datasheet, but more on that later) </li><li>  Filtering "their" packets when routing (such a protection against looping) </li><li>  Dynamic routes (he learns on the basis of MAC addresses and the port number on which packets arrive) </li><li>  Support for VLAN ID, speed 10/100 megabits, autonegotiation, he himself is able to determine the "overlap" of the cable, the distance in meters to the point of cable break and a few more buns </li></ul><br><br><h4>  Finding a solution </h4><br>  At the initial stage of development, it was immediately decided to abandon the existing network control protocols (STP, RSTP, etc.) for the following reasons: <br><ul><li>  Too much extra for our simple topology. </li><li>  None of these protocols is hardware supported by the physical layer.  And, accordingly, the load falls on the processor, which is already not sweet.  Although there is a line ‚ÄúIEEE 802.1d rapid spanning tree protocol support‚Äù in the datasheet of the switch, in fact this means that the datasheet provides an approximate algorithm that can be implemented by means of a processor, which is not quite suitable for us. </li></ul><br><br>  And also, since our system only needed broadcasts, to reduce the load, it was decided to abandon the transport layer protocols, that is, to do everything on ‚Äúbare‚Äù Ethernet packets. <br><br>  But first, let's see how the manufacturer of switches offers us to build a ring. <br><br><h4>  Option number 1 (an attempt to solve the problem only by means of the physical layer - unmanaged ring) </h4><br><br>  <i>Next comes a free retelling of the document <a href="http://www.micrel.com/_Products/LanSolutions/UnmanagedRedundantRingWP.pdf">by reference</a> from the article title.</i> <i><br></i> <br><br><h5>  Filtering by MAC address of the device sending the packet (MAC Source Address Filtering) </h5><br>  The switch implements a hardware mechanism for ‚ÄúLearning‚Äù and ‚ÄúForwarding‚Äù packets.  After receiving the packet, the switch ‚Äúlearns‚Äù - saves the sender's address and the corresponding port number from which the packet was received in the MAC dynamic routing table.  A packet forwarding decision is made based on this table and the MAC address of the destination device (Destination MAC).  If a match is found in the table (the MAC address is already known to the switch), then the packet is redirected to the corresponding port.  If the address is unknown, then the packet is broadcasted to all ports, except for the one from which it was received (this is the default behavior and it is configured). <br><br>  Thus, when a packet is received, the sender‚Äôs address is only memorized and not used when making a routing decision.  This is fraught with the appearance of "looped" packages.  However, if the switch is able to filter (and KSZ8863 can) incoming packets based on the sender's address, then the implementation of an unmanaged ring is possible.  As soon as the switch receives a packet, the address of the sender in which coincides with the local MAC address of one of the ports, the packet is dropped (drop).  That is, the package is removed from the ring after passing a full circle. <br><br>  Schematically, this can be represented as: <br><img src="https://habrastorage.org/storage2/9cf/208/96b/9cf20896b16cb4d3f2f5d04b4537fc21.png"><br><br><h6>  Approximate algorithm: </h6><br><ol><li>  The switch receives a packet from the processor (from port 3) </li><li>  Sends it to one of the ports (for example, always to port number 2) </li><li>  The packet runs through the full ring and is dropped by the sender (in the picture, the 1st switch sent the packet and, after the full circle, it dropped it) </li></ol><br><br>  Pros: <br><ul><li>  Everything is done by the switch, there is no load on the processor </li></ul><br><br>  Minuses: <br><ul><li>  If you break one of the links, the network will stop working </li></ul><br><br>  It does not suit us.  We look further. <br><br><h4>  Option # 2 - Redundancy based on option # 1 </h4><br>  The easiest way to organize redundancy by filtering at the sender's address is to send packets received from the processor to two external ports at once (on both sides of the ring).  In this case, with a single break, the package will still receive all the devices.  The most important problem is that if there is no break in the ring, all devices will receive this package twice (duplicate).  On the other hand, by the absence of duplicates, it is possible to determine between which devices the break occurred.  Everything works like this: <br><br><img src="https://habrastorage.org/storage2/41c/f32/f4c/41cf32f4c8a0690170c013223cc30f4b.png"><br>  Here, as in the previous version, the packet runs in a circle and is dropped by the sender. <br><br>  As already mentioned, the disadvantage is duplicate packets that increase the load on the processor and reduce the efficiency of the network.  In addition, obtaining duplicates will lead to a problem with the learning mechanism of the switch.  First, the dynamical table will constantly change (a packet comes from one port, then another one, and the MAC address is the same) and the <b>worst</b> variant of the path will always be the last (the packet that went the longest will write the ‚Äúworst‚Äù port to the table) .  Secondly, it can lead to the fact that one of the packages will be dropped as a ‚Äúlocal package‚Äù.  Local is a packet that arrives <b>from a</b> port to which it must be redirected during routing.  It turns out something like this: <br><br><img src="https://habrastorage.org/storage2/01b/9e3/1f1/01b9e31f12d4e5837d2405359de15f70.png"><br>  Explanation of the figure: <br><ol><li>  Processor 4 sends the packet to device 1 </li><li>  Switch number 4 sends it to both external ports </li><li>  On switch # 1, the first packet arrives at port 1 (because the distance is shorter) and the port is set to 1 in the routing table for MAC 4. </li><li>  Then on switch No. 1 a duplicate of the packet will come to port 2 (the distance is longer and we need to go through two devices) and the port will be set to 2 in the routing table for MAC 4. </li></ol><br><br>  Then the following happens: <br><br><img src="https://habrastorage.org/storage2/70b/c5d/c75/70bc5dc751148b1b33cc722c98fc6f93.png"><br><ol><li>  Processor 2 sends the packet to device 4 </li><li>  Switch 2 sends it to both external ports </li><li>  The packet arrives in switch # 1 on port 2 and is dropped because in the routing table it is determined that for MAC 4 packets need to be redirected to the same port. </li><li>  Device number 4 in the end will receive only one package without a duplicate. </li></ol><br>  As a result, we have the fact that we can not accurately determine why there was no duplicate.  And what exactly was the reason for the disappearance of a duplicate - a break or an accidental drop. <br>  In order to make sure that both duplicates come when there is no break, you need to disable training in a switch.  Disabling training leads to the fact that the routing table always remains empty and local packets are never dropped.  The main disadvantage of this solution is, again, shifting the load of digging deductions on the processor.  In this case, all incoming packets are sent to port 3, regardless of whether they are addressed to the processor or not.  This problem can be solved by prohibiting the redirection of packets with unknown addresses to the third port (so that all packets pass ‚Äúby‚Äù except those addresses that are in static routes). <br><br>  Pros: <br><ul><li>  At break the network will continue to work </li></ul><br><br>  Minuses: <br><ul><li>  Additional processor load </li></ul><br><br>  <i>Note: After all the frills, I did come to this version with some changes and my own protocol.</i>  <i>But so far we do not know this, so let's continue to try the options ...</i> <br><br><h4>  Option number 3 - Improved version of the previous one (now - managed ring) </h4><br>  As already mentioned, the main disadvantage of the previous method are duplicate packets, increasing the load on the processor.  In this version we will fix it by doing this: <br><ul><li>  Each device in the ring should turn off one of the external ports on reception ( <b>note: all devices must turn off the port with the same number</b> !).  Due to this we get: <br><ul><li>  Packages in the ring will only move in one direction. </li><li>  The receiver will eventually receive only one packet without a duplicate. </li><li>  Disabled port will be used in case of ring break. </li></ul></li></ul><br>  Also here we will use a special switch interrupt, which signals a <i>link status</i> change ( <i>Link Status Interrupt</i> ). <br><br>  This solution already requires constant monitoring and (in the event of a break) control from the processor.  That is, in fact, the ring is already becoming managed (managed), but instead we get fast fault detection and fast ring reconfiguration even in large networks. <br><br><h6>  Switch initialization: </h6><br><br><img src="https://habrastorage.org/storage2/f4f/36f/6a8/f4f36f6a803e89da43f1baf6ae2f741c.png"><br><ol><li>  We disable training on ports 1 and 2 in each device. </li><li>  We configure a static route by which all packets with the recipient's address equal to our local one are sent to port 3 (per processor). </li><li>  We enable routing for unknown addresses (all packets with unknown addresses of recipients will roam to both external ports). </li><li>  Disable reception on the 2nd port in <b>all</b> devices. </li><li>  Enable interrupt by changing the status of the line. </li></ol><br>  As a result, all traffic comes to the first port and leaves the second (packets run clockwise). <br><br>  If the connection between the devices is broken, then the Interrupt (Link Status Interrupt) comes to these devices and we must proceed to reconfigure the ring. <br><br><h6>  Reconfigure Ring: </h6><br><img src="https://habrastorage.org/storage2/d8f/705/6bc/d8f7056bc68fb49919b76d93291b9de2.png"><br>  The procedure is very simple and takes place with minimal delays. <br><ol><li>  After receiving, we check which port is open. </li><li>  If first, then <br><ul><li>  We send a broadcast message to all devices that port 2 must be enabled for reception </li><li>  We include receiving packets from the 2nd port in </li></ul></li><li>  If on the second port, then <br><ul><li>  Ignore the Broadcast message that you need to enable the 2nd port to receive </li><li>  Making diagnostics, if necessary. </li></ul></li></ol><br>  KSZ8863 has a built-in mechanism for determining the location of the break (from the internal registers, you can read the approximate distance in meters to the point of cable damage). <br><br><h6>  Ring restoration: </h6><br>  When the cable is fixed, we will again receive a Link Status Interrupt <br><ol><li>  Checking which port the interrupt came on </li><li>  If on the first, then we send a broadcasted message to all devices that it is necessary to disable reception from port 2 </li></ol><br><br>  Packages start running clockwise again.  Profit! <br><br>  The document also contains the following figures: <br><br>  Delay in rebuilding the ring: <br>  <b>Latency</b> = <b>T <sub>interrupt</sub></b> + <b>T <sub>read interrupt</sub></b> + <b>T <sub>broadcast message</sub></b> + <b>T <sub>enable P2 Receive</sub></b> <br><br>  <b>T <sub>interrupt</sub></b> = approximately 100us <br>  <b>T <sub>read / write</sub></b> = 4.8us for an SPI interface with a frequency of 5Mhz (in order to write one register, you need to transfer three bytes) <br>  <b>T <sub>message</sub></b> = (n - 1) x 7.7us (where n is the number of devices in the ring) is the time it takes a broadcast to reach the last device.  Implied packet is 64 bytes long and 7.7us delay per device <br><br>  We get: <br>  <b>Latency</b> = 100us + 4.8us + (n - 1) x 7.7us + 4.8us <br><br>  For example, for a ring of 16 devices we get: <br>  <b>Latency</b> = 225us (approximately) <br><br>  Based on the above formula, you can calculate the maximum number of devices in the network with the maximum allowable delay: <br>  For example, if the maximum allowed delay is 1ms, we get: <br>  1ms = 100us + 4.8us + (n - 1) x 7.7us + 4.8us <br>  n &lt;(890.4 / 7.7) +1 <br>  Maximum number of devices in the ring: <b>n = 116</b> <br><br>  <i>This official document from the developers KSZ8863 ends.</i> <br><br>  Everyone is happy, thank you all, curtain ... <br><br>  And after the curtain, as usual, the most interesting begins: <br><br>  Option number 3, in principle, arranged for everyone.  Naturally, with minor corrections, because as presented now, it is not entirely reliable.  Let me explain with an example: if a Broadcast package sent after detecting a break doesn‚Äôt receive all the devices (you never know how it will turn out, the power may disappear), then the connection will completely fall apart. <br>  But I didn‚Äôt have to dig deeper because another global problem had appeared. <br><br>  So, we have a schematically depicted ring: <br><br><img src="https://habrastorage.org/storage2/c97/fcf/2f3/c97fcf2f3bfbb9b381c554b78985f82c.png"><br><br>  Unfortunately, the cars in the train are not so linked. <br><br>  We unplug our train, install the devices in the cars as they should stand and get this: <br><br><img src="https://habrastorage.org/storage2/d1f/60c/4ea/d1f60c4eaeb01f43385e8573c99fec3e.png"><br><br>  The first mistake is immediately noticeable - in the figure, the cable that goes ‚Äúalong the bottom‚Äù of the cars is too long.  Now I don‚Äôt remember exactly the length of the whole train, but this is about 250 meters. That is, for ethernet, a cable of such length is deadly. <br><br>  In fact, this is not a problem, and the main developer came up with the best option - like this: <br><br><img src="https://habrastorage.org/storage2/97b/f36/70d/97bf3670d3354eafe8ab4df47db09c49.png"><br><br>  As you can see - now the cars are connected through one.  Here are the port numbers on the devices.  And you can see that they very well fit into the previously proposed version of the construction of the ring. <br><br>  Profit?  - As if not so. <br><br>  Unexpectedly <s>(aha, as always)</s> , an additional condition appeared that in the process of operation any car (except the head ones) could be deployed.  And the system, naturally, should work.  And it turns out that's the trouble: <br><br><img src="https://habrastorage.org/storage2/da6/cca/caa/da6ccacaaf5196e52524306baa6905b1.png"><br><br>  As you can see, the connection around the ring is broken.  If it is not clear why - I will explain.  In the previous picture, you can completely go around the ring, assuming, for example, that port 2 works only on transmission.  That is, you can go through the chain: port 2 -&gt; port 1, port 2 -&gt; port 1. And so on.  After the turn of the car, this principle is violated. <br><br>  Therefore, from the seemingly ideal option, we had to give up and look for a new one. <br>  Well, let's get down to the invention of bicycles ... <br><br><h4>  Bicycle ‚Ññ1 - Managed Redundant Ring Control Protocol (MRRCP) v1.0 </h4><br><br>  Then the understanding came that the processor would have to be loaded anyway, and you will not get off with one physical layer with minimal control.  You must be able to dynamically rebuild the ring for any configuration of compounds. <br>  Like it or not, I had to invent my own protocol for controlling the ring.  Actually, its <s>epic</s> name is given above. <br><br>  Let me remind you once again that it was critical to load the processor as little as possible with the network.  Therefore, from the point of view of the ‚Äúcorrectness‚Äù of using Ethernet, everything that is further written in this variant is horror, flying on the wings of the night ... <br><br><h6>  Initialization: </h6><br><ol><li>  Disable learning addresses in the switch </li><li>  Local addresses for ports 1 and 2 are NOT set, we do not need them </li><li>  We prohibit reception and transmission on all ports (static routes can ‚Äúinterrupt‚Äù these prohibitions - we use them) </li><li>  We clear static routes in our switch. </li><li>  We write the zero route here: <br><ul><li>  All that goes with the recipient's address <b>44: 44: 00: 00: 00: 07</b> (this is the type of Broadcast address for the MRRCP) is redirected only to the processor. </li></ul></li></ol><br>  The meaning of initialization is that nothing at all without our permission to the processor does not fall and does not go into the network. <br><br><h6>  Directly algorithm: </h6><br>  Each device has a route table (in fact, it is an array of structures).  Each such structure refers to a specific device in the ring.  The structure is approximately as follows: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//     ... unsigned char DestinationDevice; //       ,     unsigned char SendToPort; //  ""   -    + 1. unsigned char MinDistance; //       unsigned char NotUpdatedTimes; } Route;</span></span></code> </pre> <br><br>  That is, each device knows how to get to any other (which port to send packets to and how far the device is located).  The whole algorithm revolves around this route table. <br>  After power-up, the entire route table is clogged with obviously incorrect values ‚Äã‚Äãso that the ring is built, so to speak, from zero. <br><br>  At intervals of <i>N</i> milliseconds, each device sends its MRRCP packet to port 1 and port 2. <i>N</i> can be taken from the ceiling.  For example, 200. It all depends on how critical the speed of ring reconfiguration after a break is.  Reliability was more important for us (so that it would be precisely rebuilt, and not rebuilt somehow, but quickly). <br><br>  The package is sent as follows: <br><ul><li>  Destination MAC - <b>44: 44: 00: 00: 00: 07</b> </li><li>  Source MAC - <b>22: 22: 00: 00: 00: XX</b> , where <b>XX</b> is the device number </li><li>  EtherType - 0x7701 (selected so that it does not intersect with conventional) </li><li>  Package Body: <br><ul><li>  YY - the number of devices in the chain </li><li>  XX - the number of the device that started the chain </li><li>  ZZ..ZZ - Chain of devices - numbers of devices through which this package passed.  That is, each device leaves its mark here and sends the packet further (with some reservations - see below). </li></ul></li><li>  In the last four bytes of the Ethernet packet, a hardware-calculated checksum is transmitted (CRC32) </li></ul><br><br><h6>  Processing MRRCP packet: </h6><br><ol><li>  A variety of checks on the validity of the data in the package (checking the device number of the sender, checksum, etc.) </li><li>  We pass a chain of devices in a loop, <b>starting from the end</b> : <br><ul><li>  The latest device in the chain is the number of the neighbor nearest us, the last but one is the number of the neighbor through one device, etc.  This determines the ‚Äúdistance‚Äù to the chained device. </li><li>  If the distance to the device is <u><b>less than</b></u> the one that is stored in the route table, then we update the route in the processor‚Äôs memory and also update the static route No. <b>X</b> in the switch (where <b>X</b> is the device number from the chain).  Please note that you need to update exactly if the value is <u><b>less</b></u> .  Because with an even number of devices in the ring, the opposite devices will have the same distance both on one side of the ring and on the other.  For an example, look at devices # 1 and # 8 below. </li><li>  In addition, it is necessary to enclose routes if the <b>NotUpdatedTimes</b> field exceeds a certain limit (this is the timeout of the validity of the route).  That is, if the route has not been updated for a long time and suddenly a packet from this device has arrived, then it will be updated, even if the distance is greater than what is stored in the route table.  This is necessary to rebuild the ring when the cliff.  The <b>NotUpdatedTimes</b> field <b>is</b> incremented by a timer and <b>reset</b> when we receive a packet from the device, and the correct values ‚Äã‚Äãare already recorded in the route table for it. </li></ul></li><li>  If the packet was not sent by our device (and if our device is not found in the chain), then we add our number to the end of the chain and send it to the port ‚Äúopposite‚Äù to where the MRRCP packet was received (for example, from the 1st, then 2nd and vice versa, that is, we kind of let the package pass through us, adding the mark that the package passed us).  Checking for the presence of our device in the chain is needed for the drop of packages that have already run in a circle. </li></ol><br>  Here is a small example in the figure: <br><br><img src="https://habrastorage.org/storage2/0f1/7d5/bb9/0f17d5bb93ac9459c28c65a6564c7749.png"><br>  For the device number 8 (it is opposite to the first one), the routes will be built depending on which side of the ring the first package will ‚Äúrun faster‚Äù. <br>  Note that the figure shows the routes that are stored in the processor's memory, and not the static routes of the switch. <br><br>  <u><b>About writing static routes to a switch:</b></u> <br>  Routes need to be written this way: <br>  Dest.MAC - <b>55: 55: 00: 00: 00: XX</b> , where ( <b>XX</b> is the device number from the chain) <br>  Forwarding Port - port number, <u><b>opposite</b></u> to the one from where the packet + port 3 came from (processor).  That is, if the packet came from port 1, then you need to write down port 2 and vice versa.  Why this is the case - see the explanation below. <br><br>  In general, the algorithm works as follows: <br><ul><li>  Initially, there is no exchange other than MRRCP packets. </li><li>  After the MRRCP packets from each device run through the entire ring once, in all devices the overall picture of the network topology appears (to which port to send to) </li><li>  Data exchange between devices starts. </li></ul><br>  Thanks to static routes (with ports ‚Äúvice versa‚Äù) we can broadcast broadcasts, but there will be no point-to-point communication. <br><br>  For broadcasting by Broadcast, you need to send a packet to <b>both</b> ports (1 and 2) with Dest.MAC <b>55: 55: 00: 00: 00: XX</b> , where <b>XX</b> is the number of <u><b>your</b></u> (yes, yes, your own) device.  Due to the reversal of port numbers in static routes, a broadcast will pass through all devices around the ring and drop on the device, ‚Äúon the back of the ring from the sender. There will be no duplicates because they will be dropped based on static routes <br><br>  Explanation: <br><br><img src="https://habrastorage.org/storage2/cec/2c8/149/cec2c81491621d5f98c5ed54261db159.png"><br><br>  The break point is determined on those devices whose maximum distance to the most distant device is <b>N - 1</b> (where <b>N</b> is the number of devices in the network).  See picture: <br><br><img src="https://habrastorage.org/storage2/e99/cf0/579/e99cf0579305ffd32e4f3271bd3ea23d.png"><br><br>  It can be seen that devices ‚Ññ1 and ‚Ññ6 will have routes with a distance <b>(6 - 1) = 5</b> , which means a break between them. <br>  For a ring with an odd number of devices, a break is considered a little different - a little easier there. <br>  An alternative option to define a break can be to use the <i>Link Status</i> interrupt, as described above. <br><br>  Pros: <br><ul><li>  The ring is dynamically rebuilt when the network is broken and restored </li></ul><br><br>  Minuses: <br><ul><li>  It seemed that they were not, but I was wrong </li></ul><br><br><h6>  Total: </h6><br>  Everything worked on the debugging stand of 3 devices, but in the invention of bicycles I couldn‚Äôt stop ... <br><br><h4>  Bike number 2 - the final, MRRCP v2.0 </h4><br><br>  When checking, it turned out that devices with numbers higher than seven work in the ring incorrectly.  After killing a day looking for a problem, it turned out that I (I repent and pour ashes on my head) did not notice a footnote in the datasheet of the switch that he has only eight static routes.  That is, the algorithm only works if the devices in the ring are less than 8. It was an epic file.  But there was a good reason to rework the crutch with Dest.MAC for Broadcast from the previous bike. <br><br>  This is how the new and final version was born.  It differs only in the work with the switch.  With MRRCP packets, everything stays the same. <br><br><h6>  Initialization: </h6><br><ol><li>  Set local MAC addresses for ports 1 and 2 in the form of <b>22: 22: 00: 00: 00: XX</b> , where <b>XX</b> is our device number </li><li>  Clear static routes </li><li>  We write the <b>zero</b> route here: <br><ul><li>  All that comes with the recipient's address <b>44: 44: 00: 00: 00: 07</b> (this is the type of Broadcast MRRCP address) is redirected only to the processor in port 3. </li></ul></li><li>  We write the <b>first</b> route like this: <br><ul><li>  All that comes with the recipient's address <b>55: 55: 00: 00: 00: 01</b> (this is a type of Broadcast address for data) is redirected to all ports (the switch itself will pass the port to which the redirected packet was received). </li></ul></li><li>  We disable training, as well as reception and transmission on all ports (so that only static routes are working) </li><li>  Turn on the Source MAC filter on ports 1 and 2 (so that the device that broadcasts broadcasts drops its packets after running through the full circle) </li></ol><br>  MRRCP packets are sent in the same way as in the previous version.  And in the handler, you just need to remove the entry of static routes in the switch. <br><br>  Now Broadcast is done like this: <br><ol><li>  The broadcasting device sends the packet to both ports with Dest.MAC <b>55: 55: 00: 00: 00: 01</b> and Src.MAC <b>22: 22: 00: 00: 00: XX</b> , where <b>XX</b> is the number of its device </li><li>  Packages pass in a circle around the ring and are dropped by the sender. </li></ol><br><br><img src="https://habrastorage.org/storage2/aeb/fc7/8f1/aebfc78f10f16a682a53932f8f9d6120.png"><br><br>  The definition of ring rupture is the same as in the previous version. <br><br>  If you need a point-to-point connection, you can implement it by adding to the initialization a static packet forwarding setting with a Dest.MAC equal to the local MAC to port 3. And also configure packet forwarding with unknown addresses to ports 1 and 2. <br><br>  Pros: <br><ul><li>  It uses only two static routes of the switch and at the same time the number of devices is not limited to the 7th. </li><li>  You can organize a point-to-point relationship. </li><li>  In the ring, routes automatically change after changing the network configuration. </li><li>  There is no constant exchange with the switch on the management interface (I2C).  It turned out to be important, since three more devices ‚Äúhang‚Äù on the same interface.  The switch is configured only once after power on. </li></ul><br>  Minuses: <br><ul><li>  Duplicate packages.  To screen them out, we just need a route table, by which we can filter packets that come from the ‚Äúwrong port‚Äù directly in the Ethernet interrupt without passing them further. </li></ul><br>  The time for rebuilding the ring was not exactly measured.  With very much overestimated values ‚Äã‚Äãof timeout validity of routes and the period of sending MRRCP packets, the ring is reassembled in 1-2 seconds.  In our case, this was enough. <br><br>  The result can be summarized as follows - having driven on different bikes, we returned to option number 2 (from the developers of the switch) with modifications in the form of MRRCP. <br><br>  <b>Constructive criticism is strongly encouraged.</b> <br><br>  I hope that this article will be useful to someone and it will be possible to get around some rakes.  Good luck! <br><br>  <b>UPD2</b> : MAC addresses for devices and for MRRCP packets were randomly selected.  As <a href="http://geektimes.ru/users/dukelion/" class="user_link">dukelion</a> noted, if everything is done according to standards, then MAC addresses have special bits for defining groups and functional MAC addresses.  <a href="http://standards.ieee.org/develop/regauth/tut/macgrp.pdf">Link to IEEE tutorial</a> . <br>  <b>UPD</b> : Thanks for the invite, moved the article to the hub "Programming microcontrollers" <br><br>  ps I can not give the source code.  I hope you understand why. <br>  pps I apologize if the explanations in places seemed too lengthy and the terms are not used quite correctly - I tried to explain in the most accessible language to make it clearer. <br>  ppps It is very interesting to know how would you solve this problem with the foregoing?  Thank. </div><p>Source: <a href="https://habr.com/ru/post/168119/">https://habr.com/ru/post/168119/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../168105/index.html">Redefining method implementation. Inspired by java</a></li>
<li><a href="../168109/index.html">3D printer prints lunar base of regolith</a></li>
<li><a href="../168111/index.html">Anti-GTD or anti-procrastination medication</a></li>
<li><a href="../168115/index.html">Logic - the most interesting news gaming and IT-industry ‚Ññ12</a></li>
<li><a href="../168117/index.html">BonBon - Sweet CSS3 Buttons</a></li>
<li><a href="../168121/index.html">Mobile subscriptions, AdWords, Vkontakte application and phishing</a></li>
<li><a href="../168123/index.html">More FineReader good and different!</a></li>
<li><a href="../168125/index.html">SALT - configuration management software for Python</a></li>
<li><a href="../168129/index.html">DoubleArrayList is a universal implementation of java.util.List</a></li>
<li><a href="../168133/index.html">Finger topology</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>