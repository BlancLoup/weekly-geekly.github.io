<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional F #, which slowly appears in C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For some reason, we often do not use this functionality. Maybe they didn‚Äôt have time to get used to it. And sometimes we use, without having any idea ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional F #, which slowly appears in C #</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d9/d9/59d9d95cc9cc8840165065.jpeg"></div><br>  For some reason, we often do not use this functionality.  Maybe they didn‚Äôt have time to get used to it.  And sometimes we use, without having any idea that this is a functional from F #. <br><a name="habracut"></a><br>  Before proceeding to its consideration, let's quickly run over the <s>jack with a</s> small retrospective of the most interesting features that appeared in different years in different versions of the language.  Please note that each time a new version of the language comes out with a new version of Visual Studio.  For some, this may be obvious, but even for developers who have spent several years working with C # this may turn out to be news (not everyone pays attention to this). <br><br>  <b>Retrospective</b> <br>  C # 1.0 Visual Studio 2002 <br>  C # 1.1 Visual Studio 2003 - #line, pragma, xml doc comments <br>  C # 2.0 Visual Studio 2005 - <b>Generics</b> , Anonymous methods, iterators / yield, static classes <br>  C # 3.0 Visual Studio 2008 - <b>LINQ</b> , Lambda Expressions, Implicit typing, Extension methods <br>  C # 4.0 Visual Studio 2010 - dynamic, Optional parameters and named arguments <br>  C # 5.0 Visual Studio 2012 - <b>async / await</b> , Caller Information, some breaking changes <br>  C # 6.0 Visual Studio 2015 - Null-conditional operators, String Interpolation <br>  C # 7.0 Visual Studio 2017 - <b>Tuples</b> , Pattern matching, Local functions <br><br>  Some functionality is rarely used, but something is used constantly.  Say, even now, quite often you can still find the use of OnPropertyChanged with the indication of the name of the property.  That is, something like OnPropertyChanged ("Price");  Although already from the 5th version of the language it became possible to get the name of the called object using CallerMemberName. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> PropertyChangedEventHandler PropertyChanged; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[CallerMemberName] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> prop = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span></span><span class="hljs-function">)</span></span> { PropertyChanged?.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PropertyChangedEventArgs(prop)); }</code> </pre> <br>  In the same way, you can organize logging.  Get the name of the method from which the call comes all the same attribute CallerMemberName.  In the same way, you can get the file name and line number using [CallerFilePath] and [CallerLineNumber].  By the way, these attributes can be used in F #, but it's not about them. <br><br>  Speaking of new features that have appeared in C #, lately it‚Äôs impossible not to mention the ‚Äúintervention‚Äù of F #, which started from the 6th version of the language.  It all started with the beloved LINQ.  Here is a list of only some of the features that appeared in C #: LINQ, Immunity, Exception filters, Auto-property initializers, Expression-bodied functions, Pattern matching, Tuples <br>  Apparently, even if you do not start learning F # in the near future, you will soon become more familiar with functional programming.  Let's look at some of the "functional" features of C #. <br><br><h3>  Immunity </h3><br>  This is nothing but the immutability of objects.  That is, the value of the object cannot be changed after creation.  In F #, all variables are immutable by default.  How can this be implemented in C #?  Starting with version 6, you can create read-only properties without specifying set.  For example: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;}</code> </pre><br>  In this way, it becomes possible to create your immorable objects in a comfortable way. <br><br><h3>  Exception filters </h3><br>  And this is an opportunity when ‚Äúcatching‚Äù errors to specify the parameter at which the capture will work.  For example: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { SomeMethod(param); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) when (param == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { }</code> </pre><br>  In the first block, the error will be caught only if param == null.  The second will get errors that occurred when the param values ‚Äã‚Äãare non-null. <br><br><h3>  Auto-property initializers </h3><br>  This is an opportunity to initialize the property immediately after access methods (accessors).  For example: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> AppUrl { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } = <span class="hljs-string"><span class="hljs-string">"http://lalala.com"</span></span>;</code> </pre><br>  Or you can even take out the initialization in a separate method that returns a value. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> AppUrl { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } = InitializeProperty(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"http://lalala.com "</span></span>; }</code> </pre><br><br><h3>  Expression-bodied function members </h3><br>  Convenient ability to reduce code using lambda expressions.  Methods that were previously written like this: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x+y; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ServerIP { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"65.23.135.201"</span></span>; } }</code> </pre><br>  Now you can write much shorter: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; x+y; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ServerIP =&gt; <span class="hljs-string"><span class="hljs-string">"65.23.135.201"</span></span>;</code> </pre><br>  All these features just appeared in version 6 of C #. <br>  Now let's analyze a little more detail what came from F # in the 7th version of the language. <br><br><h3>  Tuples or Tuples </h3><br>  This functionality, in the opinion of many, can be compared with LINQ in terms of importance and usability. <br>  What is he giving us?  First of all, it is the ability to return several values ‚Äã‚Äãfrom a method without creating an instance of any class.  Because we can transfer several parameters to the method, but only one thing will be returned.  I repeat that the typical solution for this need so far has been the creation of an instance of the class.  Now we can create a tuple. <br>  A typical example of a tuple: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> unnamed = (<span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-string"><span class="hljs-string">"What is your age?"</span></span>);</code> </pre><br>  As you can see, this is nothing but a variable that contains two values ‚Äã‚Äãin parentheses.  In this case, the tuple is called unnamed and values ‚Äã‚Äãcan be addressed by the name Item with a number.  For example, unnamed.Item1 contains 35, and unnamed.Item2 contains the string ‚ÄúWhat is your age?‚Äù <br><br>  If someone notices that the tuples are similar to anonymous types, it will be right.  But there is a nuance that you should not forget.  Anonymous types can only be used in the scope of a method. <br><br>  There are named tuples. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> named = (Answer: <span class="hljs-number"><span class="hljs-number">35</span></span>, Question: <span class="hljs-string"><span class="hljs-string">"What's your age again?"</span></span>);</code> </pre><br>  Variables from a named tuple can be accessed by name.  In this case, named.Answer stores 35, and named.Question contains a string with the text of the question. <br>  The simplest example.  A method that returns a value in the form of a tuple: <br><br><pre> <code class="cs hljs"> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) GetXY() { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> y = <span class="hljs-string"><span class="hljs-string">"One"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x, y); }</code> </pre><br>  The return value of the method is a tuple whose first value is an integer of type int, and the second is a string. <br>  We get the value in a variable like this: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xy = GetXY();</code> </pre><br>  Now we can refer to the elements of the tuple by xy.Item1 and xy.Item2 <br><br>  Tuples have such an interesting feature as deconstruction / deconstruction.  This is getting the usual variable values ‚Äã‚Äãfrom the tuple.  Well, or you can tell the decomposition of the tuple into separate variables.  For example, there is such a method that returns a list and some kind of ID that belongs to this list: <br><br><pre> <code class="cs hljs"> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;) GetListWithId() { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x, y); }</code> </pre><br>  In order to get the values ‚Äã‚Äãimmediately in the form of variables, and not in the form of a tuple, you can use one of the following two methods: <br><br><pre> <code class="cs hljs"> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; y) = GetListWithId(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> (x, y) = GetXY();</code> </pre><br>  In C # version 7.1, a feature called infer tuple names appeared.  It is possible to translate into Russian approximately as: assumed names of tuples.  This means that it will be possible to refer to an unnamed element of a tuple not only by Item1, Item2, etc., but also by name, which is formed based on the name of the variable that participated in the creation of the tuple.  Example: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tuple = (xa, y);</code> </pre><br>  Elements of this tuple can be accessed by the names tuple.a and tuple.y <br><br>  What is interesting is that this 7.1 change is breaking back compatibility.  That is back incompatible.  But since the gap between the output of C # 7 and C # 7.1 is small, they decided to enter it.  The essence of what.  Some code that worked in a certain way in C # 7 will work differently in C # 7.1. <br>  In this case, the opportunity to meet such a code in a real project is extremely small. <br>  Example.  Suppose you have this code: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x=<span class="hljs-number"><span class="hljs-number">1</span></span>; Action y = () =&gt; SomeMethod(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tuple = (a: x, y); tuple.y();</code> </pre><br>  Notice the last line, which obviously calls a method called SomeMethod (and it does call this method, but only starting from C # 7.1) <br>  So here.  In C # 7.0, not SomeMethod would be called, but an extension method named y.  Suppose this: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExtClass</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">y</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Action</span></span></span><span class="hljs-function">) z)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// some code } }</span></span></code> </pre><br>  Agree that extension methods for tuples are rare. <br><br>  If you are using a project with a version of the .NET Framework lower than 4.7, then you can use tuples only by installing the NuGet System.ValueTuple package.  However, Visual Studio 2017 should prompt you for this if you start using tuple syntax.  Maybe that's why tuples are not used so often yet.  It is necessary not only to work in the latest version of Visual Studio, but also on one of the latest versions of the framework (or install the NuGet package). <br><br><h3>  Pattern Matching </h3><br>  Under this rather ambiguous name contains surprisingly fairly simple functionality. <br>  Let's look at the sample code that was used earlier and, of course, can be used now: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (someObject <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Customer) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = (Customer)someObject; c.Balance = c.Balance + <span class="hljs-number"><span class="hljs-number">1000</span></span>; }</code> </pre><br>  The code is completely normal, typical, often used, and one cannot say that there is something wrong in it.  However, now it is possible to reduce it a bit: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (someObject <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Customer c) c.Balance = c.Balance + <span class="hljs-number"><span class="hljs-number">1000</span></span>;</code> </pre><br>  It turns out that if someObject belongs to the class Customer, then it is converted to a variable with the type Customer.  And you can immediately start working with this variable. <br>  You can add that pattern matching is not only syntactic sugar, but also the opportunity for developers who have dealt with similar constructs in other languages ‚Äã‚Äãto use them in C #. <br>  Pattern matching can be used not only with if, but also with Swith constructs.  Example: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (userRole) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Manager m: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.Salary; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Partner p: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.Income; }</code> </pre><br>  In addition, you can make clarifications using conditions with <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (userRole) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Manager m with Salary&lt;<span class="hljs-number"><span class="hljs-number">1500</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.Salary*<span class="hljs-number"><span class="hljs-number">1.2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Manager m: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.Salary; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Partner p: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.Income; }</code> </pre><br>  In this case, the first case will be executed only if userRole is a manager and its Salary value is less than 1500. That is, m.Salary &lt;1500 <br><br>  In the list of proposed innovations in C # 8 there is a functional that appeared not so long ago in Java.  Namely: default interface methods.  In particular, using this functionality, it will be possible to change the legacy code.  For example, Java developers themselves managed using this functionality to improve the collections API and add support for lambda expressions.  Maybe C # developers also want to change something in C # itself using this functionality? <br><br>  Despite the similarity that has appeared, the interfaces are still quite different from abstract classes.  Multiple inheritance in C # was abandoned for a long time due to the multitude of difficulties encountered.  But in this case, using only one method, the difficulties should be less.  If a class inherits from two or more interfaces and there is a method with the same name in several interfaces, the class must specify the name of the method with the specification of the interface name.  Tracking only one method is easier (in particular, using an IDE). <br><br>  The C # language is used in quite a large number of different types of projects.  Despite the fact that it does not occupy the first line in popularity, it is unique in the breadth of the types of projects.  Web development, desktop, cross-platform, mobile, games ... Including some features of functional programming or other languages ‚Äã‚Äãdeveloping in parallel, C # is becoming more versatile.  Moving to C # from another language is getting easier.  However, it is also easier for experienced C # developers to understand the syntax of other languages. </div><p>Source: <a href="https://habr.com/ru/post/339592/">https://habr.com/ru/post/339592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339580/index.html">Using the event model in Doctrine 2 + Symfony 3</a></li>
<li><a href="../339582/index.html">About design patterns for working with RDBMS</a></li>
<li><a href="../339584/index.html">We make life easier with the conclusion of SLA</a></li>
<li><a href="../339586/index.html">Red arrows of extra reality</a></li>
<li><a href="../339590/index.html">Webpack and addictions</a></li>
<li><a href="../339594/index.html">Expansion of analytical capabilities of the linear programming method with Python tools</a></li>
<li><a href="../339596/index.html">The history of hacking all the games in Telegram</a></li>
<li><a href="../339602/index.html">Service control panel. Part 1: Introduction</a></li>
<li><a href="../339606/index.html">Railway-oriented programming. Functional style error handling</a></li>
<li><a href="../339608/index.html">The digest of interesting materials for the mobile developer # 224 (October 2 - October 8)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>