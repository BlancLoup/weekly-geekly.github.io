<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to collect statistics from the website and not to fill yourself cones</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! My name is Slava Volkov, and I'm a frontend developer at Badoo. Today I would like to tell you a little about collecting statistics from the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to collect statistics from the website and not to fill yourself cones</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/2cd/049/bcb/2cd049bcbe5348aaa2592e1faed7ac25.png" alt="enter image description here"></p><br><p>  Hi, Habr!  My name is Slava Volkov, and I'm a frontend developer at Badoo.  Today I would like to tell you a little about collecting statistics from the frontend. </p><br><p>  We know that analytics allows you to evaluate the effectiveness of any web site, improve its work, and thus increase sales and improve user interaction with the site.  Simply put, analytics is a way to control the processes occurring on a website.  In most cases, for ordinary websites it is enough to install Google Analytics or Yandex.Metrica - their capabilities are enough. </p><br><p>  But what about when standard monitoring tools are not enough?  Or when the collected statistics should be integrated into your own analytics system to display a complete picture of what is happening between different components?  In this case, most likely, you will have to develop your system.  But how best to send statistics from your websites, what problems may arise and how to avoid them, I will tell in this article.  Interested?  Welcome under cat. </p><a name="habracut"></a><br><p>  For such services as Badoo, any statistics is a very important way to assess the current situation on the resource, whether it is the user's clicks, the blocks that he saw, the actions that he committed, or errors while working with the site.  Based on this information, we monitor the operation of the site and make decisions that affect the appearance of new features, changing the position of blocks on the page and other changes.  Therefore, we work with a huge number of diverse statistics.  What difficulties can be encountered with such a flow of messages? </p><br><p>  The first problem that may arise is browser restrictions on the number of simultaneous connections to a single domain.  For example, when loading a page, we perform four Ajax requests to retrieve data (font downloads, SVG graphics), and dynamically load styles.  As a result, we get six requests that the browser performs at the same time ( <a href="https://vexell.ru/files/testpool/">example number 1</a> ) (in all the examples I set a delay of two seconds, and it is better to look at them on my machine to avoid network delays). </p><br><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendAjax</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); req.open(<span class="hljs-string"><span class="hljs-string">'POST'</span></span>, url); req.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req.readyState != <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req.status == <span class="hljs-number"><span class="hljs-number">200</span></span>) { resolve(req.response); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(req.statusText)); } }; req.onerror = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ reject(<span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Network Error"</span></span>)); }; req.send(data); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logIt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">startDate, requestId, $appendContainer</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> endDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text = <span class="hljs-string"><span class="hljs-string">'Request #'</span></span> + requestId + <span class="hljs-string"><span class="hljs-string">'. Execution time: '</span></span> + ((endDate - startDate) / <span class="hljs-number"><span class="hljs-number">1000</span></span>) + <span class="hljs-string"><span class="hljs-string">'s'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $li = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'li'</span></span>); $li.textContent = text; $appendContainer.appendChild($li); } <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.js-ajax-requests'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ e.preventDefault(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $appendContainer = e.currentTarget.nextElementSibling; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> startDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); sendAjax(REQUEST_URL + <span class="hljs-string"><span class="hljs-string">'?t='</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ logIt(startDate, i, $appendContainer); }); })(i); } });</code> </pre> <br><p>  But what will happen if we start sending some more statistics about the logged in user?  We get the following result ( <a href="https://vexell.ru/files/testpool/">example number 2</a> ): </p><br><p><img src="https://habrastorage.org/files/621/e30/f00/621e30f00a9d4cc8a5174cc9b743b9e3.png" alt="Limit on the number of simultaneous requests"></p><br><p>  As you can see, two requests for sending statistics have affected the overall load of the site, and if this data is needed to render the page, the user will face a delay equal to the execution time of the fastest of the previous requests. </p><br><p>  In most cases, waiting for a response from the statistics does not make sense, but these requests still affect the overall flow of execution.  How to avoid such a situation? </p><br><h3 id="otpravka-dannyh">  Sending data </h3><br><p>  If you are already using HTTP / 2 or transferring data via a WebSocket connection, then this problem should not affect you at all.  But if not yet, perhaps you will be helped simply by switching to HTTP / 2 (and you will forget everything like a bad dream).  Fortunately, all modern browsers support this, and support for this protocol has already appeared in the most popular web servers.  The only problem you may encounter is the need to remove all the hacks that you did for HTTP / 1.1, for example, domain sharding (creating an extra TCP connection and preventing prioritization), JS and CSS concatenation and embedded dataURI.  In addition, when switching to HTTP / 2, you have to transfer the entire site to HTTPS, which can be expensive, especially if you have a lot of data from third-party resources downloaded via HTTP. </p><br><p>  When using WebSocket connections, you also get a permanent connection to the server and no limit on the number of requests.  There is nothing wrong with this decision, except that you have to raise your socket server and connect it with your system - additional work for developers.  But in the end, it will be possible to transmit not only statistics through the socket, but also regular requests.  And most importantly - it will allow to receive notifications from the server and save traffic. </p><br><h4 id="sposob-1">  Method number 1 </h4><br><p>  If you are not yet ready to switch to HTTP / 2 or use a WebSocket connection, the simplest solution is to make requests with statistics for a separate domain, in fact, like making all the static data.  Then the problem will disappear ( <a href="https://vexell.ru/files/testpool/">example number 3</a> ): </p><br><p><img src="https://habrastorage.org/files/d07/9a4/f98/d079a4f983404e58bd972c6fa26101de.png" alt="Sending statistics to a separate domain"></p><br><p>  Of course, do not forget about the CORS configuration, otherwise such requests will be blocked by the browser. </p><br><h4 id="sposob-2">  Method number 2 </h4><br><p>  Using the capabilities of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a> , we can make six additional requests without passing a cookie ( <a href="https://vexell.ru/files/testpool/">example number 4</a> ).  But this will only help if the cookie will not be used for authorization when making requests.  By default, Fetch does not transmit them.  It seems that it looks like an implementation bug, but this behavior is observed in both Chrome and Firefox.  Bug feature?  In order for cookies to go away, you need to set an additional parameter: </p><br><pre> <code class="javascript hljs">fetch(REQUEST_URL + <span class="hljs-string"><span class="hljs-string">'?t='</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(), { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-attr"><span class="hljs-attr">credentials</span></span>: <span class="hljs-string"><span class="hljs-string">'include'</span></span> }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... });</span></span></code> </pre> <br><p>  So, we decided how we will transfer data to the server.  But we will not send a request for each user action.  Of course, it is better to buffer the events and then send the group to the server.  But in this case, if the user leaves the page, there is a risk of losing the accumulated buffer.  How to avoid such a situation? </p><br><h3 id="buferizaciya">  Buffering </h3><br><p>  Message buffering can be organized using the <a href="https://gist.github.com/ethyde/d56b12d8dbe2d7a327f2628b6fdd2f9f">debounce</a> function, which will allow us to arrange a delay between sending messages.  A small example of this work can be <a href="https://codepen.io/vexellz/pen/apPyge">found here</a> (if necessary, it can be supplemented taking into account the size of the transmitted data or the maximum lifetime of the queue). </p><br><p>  In addition to using <strong>debounce</strong> delay, there are <a href="https://developers.google.com/web/updates/2015/08/using-requestidlecallback">examples of</a> using the <a href="https://developer.mozilla.org/ru/docs/Web/API/Window/requestIdleCallback">window.requestIdleCallback</a> method, but unfortunately, it is not supported by all browsers.  The <strong>requestIdleCallback</strong> method <strong>queues a</strong> function that will be executed when the browser is idle.  It is not bad to use this opportunity to perform background tasks, for example, sending statistics or loading any lazy load-elements on the page.  My opinion is that it is better suited for the aggregation of synchronous calls.  For example, see this <a href="https://codepen.io/vexellz/pen/xqzrEd">example</a> . </p><br><p>  In addition, it would be nice to determine when your system is ready for use, and then call the <strong>ready ()</strong> method, after which the statistics will be sent to the server without blocking the rest of the work.  And before that, it may just fall into the buffer. </p><br><h3 id="garantiya-dostavki-sobytiy">  Event delivery guarantee </h3><br><p>  Unfortunately, when using buffering, this situation may arise: the user has closed the tab - and the statistics you collected are not sent and lost.  This can be avoided.  The first thing that comes to mind is to create a <strong>force ()</strong> method on your statistics sending object, which will be executed during <a href="https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload">beforeunload</a> .  But if you use XHR requests for sending statistics, then when you close a tab or browser, the request will also not be executed: </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'beforeunload'</span></span>, sendData, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); client.open(<span class="hljs-string"><span class="hljs-string">"POST"</span></span>, <span class="hljs-string"><span class="hljs-string">"/server.php"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); client.send(data); }</code> </pre> <br><p>  This can be corrected by sending a synchronous request, as in the example above (but this will block the user's actions with the browser), or by using the special <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon">sendBeacon</a> method, which allows you to asynchronously send small amounts of data to the server and guarantees their delivery even after the page is closed.  This method works in all modern browsers except Safari and Internet Explorer (there is support in Edge), so they will have to leave the old synchronous XHR for them.  But the main thing is that the method looks quite compact and simple: </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'beforeunload'</span></span>, sendData, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> navigator = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.navigator; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-string"><span class="hljs-string">"/server.php"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!navigator.sendBeacon || !navigator.sendBeacon(url, data)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); t.open(<span class="hljs-string"><span class="hljs-string">'POST'</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); t.setRequestHeader(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>); t.send(data); } }</code> </pre> <br><p>  In order to make sure that your requests go away, just open the Network tab in Chrome DevTools and filter on requests of the Other type.  All your sendBeacon requests will be here. </p><br><p>  Unfortunately, sendBeacon has flaws, due to which it is impossible to transfer all requests sent to it.  First, the method falls under the restriction on the number of connections per domain ( <a href="https://vexell.ru/files/testpool/">example number 5</a> ), so theoretically a situation may arise when a request to send statistics blocks an important request for receiving data (but there is an exception: if you use instead of XHR) requests to the new Fetch API without passing a cookie, then sendBeacon no longer falls under the restriction of connections ( <a href="https://vexell.ru/files/testpool/">example number 9</a> )).  Secondly, sendBeacon may have a size limit for the request.  For example, earlier for Firefox and Edge the maximum request size was 64 Kb, but now there is no limit on the size of the data for Firefox ( <a href="https://vexell.ru/files/testpool/">Example 8</a> ).  When I tried to find the maximum data size for Chrome (currently version 57 is relevant), I found a very <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D701678">interesting bug</a> , due to which the use of sendBeacon becomes problematic and which caused us to fall in sending statistics.  Try running <a href="https://vexell.ru/files/testpool/">example 7</a> , reload the page and see the result of <a href="https://vexell.ru/files/testpool/">example 8</a> : </p><br><p><img src="https://habrastorage.org/files/4be/db4/e7c/4bedb4e7c99a43c18d82e4c394463118.png" alt="Bug with sendBeacon in Google Chrome"></p><br><p>  In Chrome, until the buffer reaches 64 Kb, other requests simply cannot be sent.  Now the bug is already fixed, and I hope that his fix will fall into the next version.  After that, the limit for one query will also be 64 Kb of data. </p><br><p>  So, if through this method you get a lot of statistics from different components, then, most likely, you will encounter a limit.  If you step over this limit, the <code>navigator.sendBeacon()</code> method returns <code>false</code> , and in this case it is better to use the usual XHR request, and leave <code>navigator.sendBeacon()</code> only for those cases when the user leaves the page.  Also, this method does not guarantee the receipt of data by the server if the Internet connection is lost, so when sending data it is better to use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/NavigatorOnLine/onLine">navigator.onLine</a> property, which returns the browser‚Äôs network status before sending requests. </p><br><p>  In principle, the <a href="http://codepen.io/vexellz/pen/OpbxqK">latter solution</a> seems sufficient for most cases.  If we take out sending statistics to a separate domain ( <a href="https://vexell.ru/files/testpool/">example number 6</a> ), then in general the solution is almost universal, especially if we consider desktop web applications.  If we consider the mobile web, in which there are frequent cases of connection loss and cases when it is necessary to guarantee the delivery of messages to the server, then this solution is no longer suitable, and it is better to use the usual XHR request and check the result of its execution. </p><br><p>  But is there a universal solution that will suit both desktop and mobile web?  If you look into the future and turn to new experimental technologies, then this possibility does exist. </p><br><h3 id="service-worker-i-fonovaya-sinhronizaciya">  Service Worker and Background Sync </h3><br><p>  Background synchronization in the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">Service Worker</a> is represented by the <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/sync">Background Sync API</a> or, with another implementation, as <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/periodicSync">periodic synchronization</a> .  Take the already considered example and try to rewrite it using the capabilities of the service worker. </p><br><p>  The finished test case can be <a href="https://vexell.ru/files/testpool/example-sw.html">viewed at this link</a> .  And then - the <a href="https://github.com/VeXell/test-sync">source code</a> . </p><br><pre> <code class="hljs javascript">Statistic.prototype._sendMessageToServiceWorker = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> messageChannel = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageChannel(); messageChannel.port1.onmessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.data.error) { reject(event.data.error); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { resolve(event.data); } }; navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]); }); }; Statistic.prototype._syncData = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> navigator.serviceWorker.ready.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">registration</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> registration.sync.register(<span class="hljs-string"><span class="hljs-string">'oneTimeStatisticSync'</span></span>); }); };</code> </pre> <br><p>  Service Worker: </p><br><pre> <code class="hljs javascript">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'sync'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.info(<span class="hljs-string"><span class="hljs-string">'Sync event executed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.tag == <span class="hljs-string"><span class="hljs-string">"oneTimeStatisticSync"</span></span>) { event.waitUntil(sendStatistic()); } });</code> </pre> <br><p>  As you can see, this time we send the data directly to the service worker, interacting with it via PostMessage, and we only delay the synchronization.  The big plus of a service worker is that if an Internet connection suddenly disappears, it automatically sends data only after it appears.  Watch the video below.  Or try to do it yourself.  Just turn off the Internet and click on the links in the example above.  You will see that requests are sent only after the connection is established. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/210548538" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  In order not to bother with manual synchronization and to simplify the code a little, you can use periodic synchronization, which is available in the service worker.  Unfortunately, even in Chrome Canary it does not work yet and one can only guess how it will function.  But now someone even <a href="https://github.com/AdaLiszk/swPeriodicSync">wrote a polifil</a> for this: </p><br><pre> <code class="hljs lua">navigator.serviceWorker.register(<span class="hljs-string"><span class="hljs-string">'service-worker.js'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> navigator.serviceWorker.ready; }) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(registration)</span></span></span></span> { this.ready(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> registration; }.bind(this)) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(registration)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (registration.periodicSync) { registration.periodicSync.register({ tag: <span class="hljs-string"><span class="hljs-string">'periodicStatisticSync'</span></span>, minPeriod: <span class="hljs-number"><span class="hljs-number">1000</span></span> * <span class="hljs-number"><span class="hljs-number">30</span></span>, // <span class="hljs-number"><span class="hljs-number">30</span></span>sec powerState: <span class="hljs-string"><span class="hljs-string">'auto'</span></span>, networkState: <span class="hljs-string"><span class="hljs-string">'online'</span></span> }); } });</code> </pre> <br><p>  Through the use of periodic synchronization, you can not only send statistics, but also download new data when the application is inactive.  This is very convenient, for example, for news sites - to download new data every hour.  But since at the moment this possibility is not yet available, we have to use the usual synchronization and our own timers. </p><br><p>  The disadvantages of using Service Worker include, probably, the fact that this method is not supported by all browsers.  In addition, its implementation requires the use of only the HTTPS protocol: the Service Worker must be connected via HTTPS and all fetch requests inside it must also be using this protocol (the exception is <code>localhost</code> ). </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  In conclusion, I would like to note that there are more and more opportunities for monitoring and sending data from web applications - the web is developing well in this direction.  Therefore, the use of existing capabilities of browsers allows you to efficiently collect statistics from web resources.  And do not forget that the statistics that you collect, with proper collection and analysis will allow you to better understand the work of your site and the interaction with users. </p><br><p>  I wish you all success in collecting data! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/325062/">https://habr.com/ru/post/325062/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325050/index.html">Digest AI Cup. Five strategies for Code Wizards 2016</a></li>
<li><a href="../325052/index.html">Technocup: results of the final round and task analysis</a></li>
<li><a href="../325054/index.html">25 interesting books for designers in the public domain</a></li>
<li><a href="../325056/index.html">‚ÄúIt is expensive for us‚Äù - retail about acquiring</a></li>
<li><a href="../325058/index.html">User Interface Cards</a></li>
<li><a href="../325064/index.html">Everything you wanted to know about stack traces and hip dumps. Part 2</a></li>
<li><a href="../325066/index.html">Release DataGrip 2017.1</a></li>
<li><a href="../325068/index.html">[Translation of the article] 4 tips that we received while talking to business representatives on 4YFN 2017</a></li>
<li><a href="../325070/index.html">Myths about Spark, or Can a Sparkle Java Developer Use Spark?</a></li>
<li><a href="../325072/index.html">Runtyper - a tool for checking types when executing JavaScript code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>