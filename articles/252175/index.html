<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Resize images in the browser. All very bad</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you have ever encountered the task of resizing images in the browser, then you probably know that it is very simple. In any modern browser there is...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Resize images in the browser. All very bad</h1><div class="post__text post__text-html js-mediator-article"> If you have ever encountered the task of resizing images in the browser, then you probably know that it is very simple.  In any modern browser there is such an element as canvas ( <code>&lt;canvas&gt;</code> ).  It can be applied image of the desired size.  <a href="http://jsbin.com/pajamo/1/watch%3Fjs,output">Five lines of code</a> and the picture is ready: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">img, w, h</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canvas = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'canvas'</span></span>); canvas.width = w; canvas.height = h; canvas.getContext(<span class="hljs-string"><span class="hljs-string">'2d'</span></span>).drawImage(img, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, w, h); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> canvas; }</code> </pre><br>  From the canvas, the picture can be saved in JPEG and, for example, sent to the server.  It was possible to finish this article, but first let's take a look at the result.  If you put such a canvas and the usual <code>&lt;img&gt;</code> element in which the same picture is loaded ( <a href="https://ununsplash.imgix.net/photo-1416339684178-3a239570f315">source</a> , 4 MB), then you will see the difference. <br><br><img src="https://habrastorage.org/files/593/637/2ba/5936372ba6bf4626a3a064b1117ee689.jpg" alt="img"><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For some reason, all modern browsers, both desktop and mobile, use the cheap affine transformation method for drawing on canvas.  I have already described the differences in image resize methods in the <a href="http://habrahabr.ru/post/243285/">corresponding article</a> .  I recall the essence of the method of affine transformations.  In it, 4 points of the original are interpolated to calculate each point of the final image.  This means that when the image is reduced by more than 2 times, holes are formed in the original image - pixels that are completely ignored in the final image.  It is because of these unaccounted pixels that quality suffers. <br><br>  Of course the picture in this form can not be shown to decent people.  And it is not surprising that the question of the quality of resizing with the help of a canvas is often set on stackoverflow.  The most common advice is to reduce the picture in a few steps.  And indeed, if a <em>strong</em> reduction of the image does not capture all the pixels, then why not reduce the image <em>slightly</em> .  And then again and again until we get the desired size.  <a href="http://jsbin.com/pajamo/2/watch%3Fjs,output">As in this example</a> . <br><br>  Undoubtedly, this method gives a much better result, because all points of the original image are counted in the final one.  Another question is how exactly they are counted.  It already depends on the step size, the size of the initial and the size of the final image.  For example, if you take a step size of exactly 2, these decreases will be equivalent to supersampling.  But the last step - how lucky.  If absolutely lucky, then the last step will also be equal to 2. But it may be completely unlucky when, at the last step, the image needs to be reduced by one pixel, and the picture turns out to be soapy.  Compare, the difference in size is only one pixel, and what is the difference ( <a href="">source</a> , 4 MB): <br><br><img src="https://habrastorage.org/files/029/62a/2ce/02962a2cee684ca18d984986cde86ee2.jpg" alt="img"><br><br>  But maybe you should try a completely different way?  We have a canvas from which to get pixels, and there is a super-fast javascript that will easily cope with the task of resizing.  So, we can implement any method of resizing ourselves, not relying on browser support.  For example <a href="http://habrahabr.ru/post/243285/">supersampling</a> or <a href="http://habrahabr.ru/post/243285/">convolutions</a> . <br><br>  All you need now is to load a full-size image into the canvas.  It would look like a perfect case.  I will leave the <code>resizePixels</code> implementation behind the scenes. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resizeImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">image, width, height</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cIn = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'canvas'</span></span>); cIn.width = image.width; cIn.height = image.height; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ctxIn = cIn.getContext(<span class="hljs-string"><span class="hljs-string">'2d'</span></span>); ctxIn.drawImage(image, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataIn = ctxIn.getImageData(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, image.width, image.heigth); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataOut = ctxIn.createImageData(width, heigth); resizePixels(dataIn, dataOut); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cOut = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'canvas'</span></span>); cOut.width = width; cOut.height = height; cOut.getContext(<span class="hljs-string"><span class="hljs-string">'2d'</span></span>).putImageData(dataOut, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cOut; }</code> </pre><br>  That's so trite and boring at first glance.  Glory to the eggs, browser developers will not let us be bored.  No, of course this code works in some cases.  The catch lies in an unexpected place. <br><br>  Let's talk about why you may need to resize at all on the client.  I had the task to reduce the size of selected photos before sending to the server, thus saving user traffic.  This is most relevant on mobile devices with slow connection and paid traffic.  And which photos are most often downloaded on such devices?  Filmed on the camera of these mobile devices.  The resolution of the camera, for example, iPhone is 8 megapixels.  But with it, you can take a panorama of 25 megapixels (even more on the iPhone 6).  On Android and Windows, camera resolutions are even higher.  And here we are faced with the limitations of these mobile devices.  Unfortunately, <a href="https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariWebContent/CreatingContentforSafarioniPhone/CreatingContentforSafarioniPhone.html">in iOS, you cannot</a> create a canvas larger than 5 megapixels. <br><br>  Apple can be understood, they have to monitor the normal operation of their devices with limited resources.  In fact, in the above function, the whole picture will take up memory three times!  Once - the buffer associated with the Image object, where the image is unpacked, the second time - the pixels of the canvas, and the third - a typed array in ImageData.  For a picture of 8 megapixels, you need 8 √ó 3 √ó 4 = 96 megabytes of memory, for 25 megapixels - 300. <br><br>  But in the process of testing, I encountered problems not only in iOS.  Chrome on the Mac with some probability began to draw several small images instead of one large image, and under Winda simply gave out a white sheet. <br><br>  But if you can not get all the pixels at once, can you get them in parts?  You can load a picture into a canvas in pieces, the width of which is equal to the width of the original image, and the height is much smaller.  First, we load the first 5 megapixels, then another, then how many will remain.  Or even 2 megapixels, which will further reduce memory usage.  Fortunately, unlike the two-pass resize by convolutions, the resize method is a single pass supersampling.  Those.  It is possible not only to receive an image in portions, but also to give one portion at a time for processing.  Memory is only needed for the Image element, the canvas (for example, 2 megapixels) and the typed array.  Those.  for a picture of 8 megapixels (8 + 2 + 2) √ó 4 = 48 megabytes, which is 2 times less. <br><br>  I implemented the approach described above and measured the execution time of each part.  You <a href="http://jsbin.com/najiho/2/watch%3Fjs,output">can</a> test <a href="http://jsbin.com/najiho/2/watch%3Fjs,output">it</a> yourself <a href="http://jsbin.com/najiho/2/watch%3Fjs,output">here</a> .  That's what I got for the picture with a resolution of 10800 √ó 2332 pixels (panorama from iPhone). <br><table><tbody><tr><th>  Browser </th><th>  Safari 8 </th><th>  Chrome 40 </th><th>  Firefox 35 </th><th>  IE 11 </th></tr><tr><td>  Image load </td><td>  24 ms </td><td>  27 </td><td>  28 </td><td>  76 </td></tr><tr><td>  Draw to canvas </td><td>  one </td><td>  348 </td><td>  278 </td><td>  387 </td></tr><tr><td>  Get image data </td><td>  304 </td><td>  299 </td><td>  165 </td><td>  320 </td></tr><tr><td>  Js resize </td><td>  233 </td><td>  135 </td><td>  138 </td><td>  414 </td></tr><tr><td>  Put data back </td><td>  one </td><td>  one </td><td>  3 </td><td>  five </td></tr><tr><td>  Get image blob </td><td>  ten </td><td>  sixteen </td><td>  21 </td><td>  nineteen </td></tr><tr><td>  Total </td><td>  576 </td><td>  833 </td><td>  641 </td><td>  1243 </td></tr></tbody></table><br>  This is a very interesting table, let's look at it in detail.  The great news is that the javascript resize itself is not a bottleneck.  Yes, in Safari it is 1.7 times slower than in Chrome and Firefox, and in IE it is 3 times slower, but in all browsers the time to load a picture and get data is still more. <br><br>  The second remarkable moment is that in no browser the picture is decoded to the <code>image.onload</code> event.  Decoding is postponed at the moment when it is really necessary - display on the screen or output to the canvas.  And in Safari, the image is not decoded, even when applied to the canvas, because the canvas is also not displayed on the screen.  A decoded only when the pixels are extracted from the canvas. <br><br>  The table shows the total time of drawing and receiving data, whereas in fact these operations are done for every 2 megapixels, and the script from the link above displays the time of each iteration separately.  And if you look at these indicators, you can see that despite the fact that the total time for obtaining data for Safari, Chrome and IE is about the same, in Safari almost all the time is taken only by the first call, in which the decoding of the picture takes place, whereas in Chrome and IE time is the same for all calls and speaks about the general inhibition of data acquisition.  The same applies to Firefox, but to a lesser extent. <br><br>  So far, this approach looks promising.  Let's test on mobile devices.  I had iPhone 4s (i4s), iPhone 5 (i5), Meizu MX4 Pro (A) on hand and I asked Oleg Korsunsky to test it on Windows Phone, he had HTC 8x (W). <br><table><tbody><tr><th>  Browser </th><th>  Safari i4s </th><th>  Safari i5 </th><th>  Chrome i4s </th><th>  Chrome a </th><th>  Chrome a </th><th>  Firefox a </th><th>  IE W </th></tr><tr><td>  Image load </td><td>  517 ms </td><td>  137 </td><td>  650 </td><td>  267 </td><td>  220 </td><td>  81 </td><td>  437 </td></tr><tr><td>  Draw to canvas </td><td>  2 706 </td><td>  959 </td><td>  2,725 </td><td>  1 108 </td><td>  6 954 </td><td>  1 007 </td><td>  1,019 </td></tr><tr><td>  Get image data </td><td>  678 </td><td>  250 </td><td>  734 </td><td>  373 </td><td>  543 </td><td>  406 </td><td>  1,783 </td></tr><tr><td>  Js resize </td><td>  2,939 </td><td>  1 110 </td><td>  96 320 </td><td>  491 </td><td>  458 </td><td>  418 </td><td>  2,299 </td></tr><tr><td>  Put data back </td><td>  9 </td><td>  five </td><td>  315 </td><td>  6 </td><td>  four </td><td>  14 </td><td>  24 </td></tr><tr><td>  Get image blob </td><td>  98 </td><td>  46 </td><td>  187 </td><td>  37 </td><td>  41 </td><td>  80 </td><td>  33 </td></tr><tr><td>  Total </td><td>  6,985 </td><td>  2,524 </td><td>  101 002 </td><td>  2,314 </td><td>  8,242 </td><td>  2,041 </td><td>  5,700 </td></tr></tbody></table><br>  The first thing that catches your eye is the ‚Äúoutstanding‚Äù Chrome result on iOS.  Indeed, until recently in iOS, all third-party browsers could only work with the engine version without jit compilation.  In iOS 8, it became possible to use jit, but Chrome had not yet had time to adapt it. <br><br>  Another oddity - two results for Chrome on Android, radically different drawing time and almost identical in everything else.  This is not an error in the table, Chrome can really behave differently.  I have already said that browsers download pictures lazily, at the moment when they see fit.  So, nothing prevents the browser from freeing up the memory occupied by the picture when it considers that the picture is no longer needed.  Naturally, when the picture is needed again the next time you draw on the canvas, you will have to decode it again.  In this case, the picture was decoded 7 times.  This is clearly seen in the time of drawing individual chunks (I remind you that only the total time in the table).  In such conditions, the decoding time becomes unpredictable. <br><br>  Alas, this is not all problems.  I have to admit that I powdered your brains with Explorer.  The fact is that it has a limit on the size of each side of the canvas at 4096 pixels.  And the part of the picture beyond these limits becomes just transparent pixels of black color.  If the restriction on the maximum size of the canvas is fairly easy to circumvent, cutting the picture horizontally, and thus saving memory, then to bypass the width restriction, you will either have to rework the resize function quite strongly or glue the adjacent pieces into strips, which will only increase the memory consumption. <br><br>  At this point I decided to spit on this case.  There was absolutely crazy option not only to resize, but also to decode jpeg on the client.  Cons: only jpeg, bad Chrome time under iOS will worsen even more.  Pros: predictability in Chrome under Android, there are no limits on the size, you need less memory (there is no endless copying to the canvas and back).  I did not dare to this option, although there is a jpeg decoder in pure javascript. <br><br><h2>  Part 2. Back to the beginning </h2><br>  Remember how at the very beginning we got a good result with a consecutive decrease of 2 times at best, and soap - at worst?  And what if you try to get rid of the worst option, not too much changing the approach?  Let me remind you that soap turns out, if at the last step you need to reduce the picture by quite a bit.  What if the last step is done first, reducing first an indefinite number of times, and then only strictly 2 times?  At the same time, it is necessary to take into account that the first step was not more than 5 megapixels in area and 4096 pixels in any width.  In this version, the <a href="http://jsbin.com/pajamo/4/watch%3Fjs,output">code is</a> obviously simpler than a manual resize. <br><br><img src="https://habrastorage.org/files/334/500/b13/334500b13ef24027a15a16ebfb22c4e6.jpg" alt="img"><br><br>  On the left, the image reduced in 4 steps, on the right in 5, and there is almost no difference.  Almost win.  Unfortunately, the difference between two and three steps (not to mention the difference between one and two steps) is still quite visible: <br><br><img src="https://habrastorage.org/files/cfe/1b7/5ae/cfe1b75ae6284de492e99d081d945ebe.jpg" alt="img"><br><br>  Although soap and significantly less than it was at the beginning.  I would even say that the image on the right (obtained in 3 steps) looks a little nicer than the left, which is too sharp. <br><br>  One could even try resizing, trying to reduce the number of steps at the same time, and bring the average step ratio to two, the main thing is to stop in time.  Browser restrictions will not allow to do something fundamentally better.  Let's move on to the next topic. <br><br><h2>  Part 3. Many photos in a row </h2><br>  Resize - the operation is relatively long.  If you act on the forehead and resize all the pictures one after another, the browser will freeze for a long time and will not be available to the user.  It is best to do <code>setTimeout</code> after each resize step.  But another problem appears: if all the pictures start resizing at the same time, then the memory for them will be needed at the same time.  This can be avoided by organizing a queue.  For example, you can run the resize of the next image at the end of the resize of the previous one.  But I preferred a more general solution, when a queue is formed inside the resize function, rather than outside.  This ensures that two pictures will not be resized at the same time, even if the resize will be called simultaneously from different places. <br><br>  <a href="http://jsbin.com/pajamo/5/watch%3Fjs,output">Here is a complete example</a> : all that was in the second part, plus the implementation of the queue and timeouts before long operations.  I added a twister to the page, and now it‚Äôs clear that the browser, if it does, stubs for a while.  It's time to test on mobile devices! <br><br><blockquote>  Here I want to make a lyrical digression about mobile Safari 8 (I do not have data on other versions).  In it, the choice of pictures in the input slows down the browser for a couple of seconds.  This is due either to the fact that Safari creates a copy of the photo with the cropped EXIF, or to the fact that it generates a small thumbnail that is displayed directly inside the input.  If for one photo it is tolerable and even, one can say, imperceptibly, then for multiple choice it can turn into hell (depending on the number of selected photos).  And all this time, the page remains unaware that the pictures are selected, as well as not aware that the file selection dialog is open. </blockquote><br>  Having rolled up the sleeves, I opened the page on the iPhone and selected 20 photos.  A little thought, Safari happily reported: A problem.  The second attempt is the same result.  In this place, I envy you, dear readers, because for you the next paragraph will fly in a minute, whereas for me it was a night of pain and suffering. <br><br>  So, Safari takes off.  Debugging it with the help of developer tools is not possible - there is nothing about memory consumption.  I hopefully opened the page in the iOS simulator - does not fall.  I looked at the Activity Monitor - oh, but the memory grows with each picture and is not released.  Well, at least something.  Began to experiment.  So that you understand what an experiment is in a simulator: it is impossible to see a memory leak in one picture.  At 4-5 is difficult.  It is best to take 20 pieces. You cannot drag or select them with the "shifto", you need to click 20 times.  Once selected, you need to look into the task manager and guess: reducing the memory consumption by 50 megabytes is a random fluctuation, or I did something right. <br><br>  In general, after a lot of trial and error, I came to a simple, but very important conclusion: I need to free everything for myself.  As early as possible, by any available means.  And select as late as possible.  Rely on garbage collection can not be completely.  If a canvas is created, at the end you need to zero it (make it 1 √ó 1 pixel in size), if the picture - at the end you need to unload it by assigning <code>src="about:blank"</code> .  Just removing from the DOM is not enough.  If the file is opened via <code>URL.createObjectURL</code> , it must be immediately closed via <code>URL.revokeObjectURL</code> . <br><br>  After a <a href="http://jsbin.com/pajamo/9/watch%3Fjs,output">strong processing of the code, the</a> old iPhone with 512 MB of memory began to digest 50 photos and more.  Chrome and Opera on Android also began to behave much better - an unprecedented 160 20-megapixel photos were given, albeit slowly, but ‚Äúwithout breaks‚Äù.  This also had a beneficial effect on memory consumption and desktop browsers - IE, Chrome and Safari began to eat stably no more than 200 megabytes per tab while working.  Unfortunately, this did not help Firefox - as he ate about a gigabyte for 25 test images, he continued.  About mobile Firefox and Dolphin under Android nothing can be said - it is impossible to select several files in them. <br><br><h2>  Part 4. Something like a conclusion </h2><br>  As you can see, resizing the pictures on the client is pretty damn exciting and painful.  It turns out a kind of Frankenstein: disgusting native resize is repeatedly used to obtain at least some similarity of quality.  At the same time, it is necessary to bypass the non-detectable limits of various platforms.  And still there are many private combinations of the original and final size, when the picture is too soapy or sharp. <br><br>  Browsers devour resources like crazy, nothing is released, magic does not work.  In this sense, everything is worse than when working with compiled languages, where you need to explicitly release resources.  In js, firstly, it‚Äôs not obvious that you need to release, and secondly, this is not always possible.  Nevertheless, appeasing the appetites of at least most browsers is quite real. <br><br>  Behind the scenes remained work with EXIF.  Almost all smartphones and cameras capture an image from a matrix in the same orientation, and record this orientation in EXIF, therefore it is important to transfer this information to the server along with the reduced picture.  Fortunately, the JPEG format is quite simple and in my project I simply transfer the EXIF ‚Äã‚Äãsection from the source file to the final one, without even parsing it. <br><br>  I learned all this and measured it in the process of writing a resize before uploading files for the <a href="https://github.com/uploadcare/uploadcare-widget">Uploadcare widget</a> .  The code that I cited in the article follows the logic of the story more, it misses a lot in terms of error handling and browser support.  Therefore, if you want to use it at home, it is better to watch the <a href="https://github.com/uploadcare/uploadcare-widget/blob/master/app/assets/javascripts/uploadcare/utils/image-processor.coffee">source of the widget</a> . <br><br>  By the way, here are some more numbers: using this technique, 80 photos from iPhone 5, reduced to a resolution of 800 √ó 600, are downloaded over the 3G network in less than 2 minutes.  The same original photos might load in 26 minutes.  So it was worth it. </div><p>Source: <a href="https://habr.com/ru/post/252175/">https://habr.com/ru/post/252175/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../252165/index.html">FREAK - TLS Downgrade attack on Android and iOS</a></li>
<li><a href="../252167/index.html">BitTorrent Sync 2.0 has been released with a paid PRO package</a></li>
<li><a href="../252169/index.html">Trends 2015: Why more and more "non-techies" are learning layout</a></li>
<li><a href="../252171/index.html">3-2-1-Let's go! Microsoft Developer Tour in Russia, Belarus and Kazakhstan</a></li>
<li><a href="../252173/index.html">Transition applications. How do we pick up apps in support</a></li>
<li><a href="../252177/index.html">I hack you in my eyes</a></li>
<li><a href="../252179/index.html">IBM AbilityLab Mobile Accessibility Checker: a tool to automate the checking of the availability of a mobile application interface</a></li>
<li><a href="../252181/index.html">Quantitative CSS selectors</a></li>
<li><a href="../252187/index.html">Evolution of data carriers</a></li>
<li><a href="../252189/index.html">Taming dinosaurs, or as I wrote my own host controller for a 3D printing lab</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>