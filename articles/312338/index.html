<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MapReduce from scrap materials. Part III - Putting It All Together</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first (enough captain) part of this series, we told about the basic concepts of MapReduce why it is bad, why it is inevitable, and how to live ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MapReduce from scrap materials. Part III - Putting It All Together</h1><div class="post__text post__text-html js-mediator-article"><blockquote> <em><a href="http://fineartamerica.com/featured/mosaic-joan-pollak.html"><img src="https://habrastorage.org/files/6ff/2e3/a5d/6ff2e3a5d1404619883c068798441862.jpg" alt="Mosaic by Joan Pollak" align="left" width="288" height="240"></a></em>  <em><a href="https://habrahabr.ru/company/intersystems/blog/310180/">In the first (enough captain) part of this series,</a> we told about the basic concepts of MapReduce why it is bad, why it is inevitable, and how to live with it in other development environments (if you are not talking about C ++ or Java).</em>  <em>In the <a href="https://habrahabr.ru/company/intersystems/blog/310196/">second part,</a> we began to talk about the base classes of the MapReduce implementation in Cach√© ObjectScript, introducing abstract interfaces and their primary implementations.</em> <em><br></em>  <em>Today is our day!</em>  <em>- we will show the first example collected in the MapReduce paradigm, yes, it will be strange and not the most effective, and not at all distributed, but quite MapReduce.</em> <br><a name="habracut"></a><br></blockquote><br><h2 id="wordcount--prostaya-posledovatelnaya-realizaciya">  WordCount - simple, consistent implementation </h2><br><p>  You have probably noticed that MapReduce is about parallelism and scaling.  But let's confess immediately - the algorithm, no matter how elegant and simple it is, is very difficult to debug right away in its parallel incarnation.  Usually, for simplicity, we start with the sequential version (in our case it will be a wordcount algorithm) and then we mix in a bit of parallelism. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/56e/cc4/174/56ecc41743d0499f8f52272190f98af3.png"></div><br><p>  <em>Execution in the environment of MapReduce from the article <a href="http://static.googleusercontent.com/media/research.google.com/ru/archive/mapreduce-osdi04.pdf">"MapReduce: Simplified Data Processing on Large Clusters", OSDI-2004</a></em> </p><br><p>  Recall the essence of the wordcount problem: we have a set of texts (for example, all the volumes of "War and Peace") and you need to count the number of words in the entire array.  This simple example was used in the original Google article about MapReduce, so each following person telling about MapReduce uses the same example.  Consider this "HelloWorld!"  parallel execution. </p><br><p>  So, the sequential implementation of WordCount (but using MapReduce interfaces introduced earlier) will contain all the same parts as the parallel one.  And, for example, the mapper would look something like this: </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> MR.Sample.WordCount.Mapper Extends (%RegisteredObject, MR.Base.Mapper) { /// <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> strings <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> MR.Base.Iterator <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> count words <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span> Map(MapInput <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> MR.Base.Iterator, MapOutput <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> MR.Base.Emitter) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-string"><span class="hljs-string">'MapInput.IsAtEnd() { #dim line As %String = MapInput.GetNext() #dim pattern As %Regex.Matcher = ##class(%Regex.Matcher).%New("[^\s]+") set pattern.Text = line while pattern.Locate() { #dim word As %String = pattern.Group do MapOutput.Emit(word) } } } }</span></span></code> </pre> <br><p>  The Map routine receives the ‚Äúinput stream‚Äù via the MapInput parameter, and emittit data to the output MapOutput.  The algorithm is obvious here - if there is still data in the input stream (ie, <em>NOT</em> <em>MapInput.IsAtEnd ()</em> ), then it will read the following ‚Äústring‚Äù via MapInput.GetNext (), break the string into words using% Regex.Matcher (see A good introductory article about using regular expressions in Cach√© on the <a href="https://community.intersystems.com/post/using-regular-expressions-cach%25C3%25A9">Using Regular Expressions in Cach√©</a> community portal) and each highlighted word is sent to the output emitter. </p><br><blockquote>  <em>In the classic MapReduce interface, we always emit a ‚Äú <code>, </code> ‚Äù in this case, we made a simplification for the ‚Äú <code>, 1</code> ‚Äù case using a form with 1 argument.</em>  <em>The explanation is given <a href="https://habrahabr.ru/company/intersystems/blog/310196/">in the previous part.</a></em> </blockquote><p>  The reducer procedure is even simpler: </p><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Class</span></span> <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">WordCount</span></span>.<span class="hljs-type"><span class="hljs-type">Adder</span></span> <span class="hljs-type"><span class="hljs-type">Extends</span></span> (%<span class="hljs-type"><span class="hljs-type">RegisteredObject</span></span>, <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Base</span></span>.<span class="hljs-type"><span class="hljs-type">Reducer</span></span>) { <span class="hljs-type"><span class="hljs-type">Method</span></span> <span class="hljs-type"><span class="hljs-type">Reduce</span></span>(<span class="hljs-type"><span class="hljs-type">ReduceInput</span></span> <span class="hljs-type"><span class="hljs-type">As</span></span> <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Base</span></span>.<span class="hljs-type"><span class="hljs-type">Iterator</span></span>, <span class="hljs-type"><span class="hljs-type">ReduceOutput</span></span> <span class="hljs-type"><span class="hljs-type">As</span></span> <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Base</span></span>.<span class="hljs-type"><span class="hljs-type">Emitter</span></span>) { #dim result <span class="hljs-type"><span class="hljs-type">As</span></span> %<span class="hljs-type"><span class="hljs-type">Numeric</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> '<span class="hljs-type"><span class="hljs-type">ReduceInput</span></span>.<span class="hljs-type"><span class="hljs-type">IsAtEnd</span></span>() { #dim value <span class="hljs-type"><span class="hljs-type">As</span></span> %<span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-type"><span class="hljs-type">ReduceInput</span></span>.<span class="hljs-type"><span class="hljs-type">GetNext</span></span>() ; <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> &lt;key,value&gt; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $listbuild format #dim word <span class="hljs-type"><span class="hljs-type">As</span></span> %<span class="hljs-type"><span class="hljs-type">String</span></span> = $li(value,<span class="hljs-number"><span class="hljs-number">1</span></span>) #dim <span class="hljs-built_in"><span class="hljs-built_in">count</span></span> <span class="hljs-type"><span class="hljs-type">As</span></span> %<span class="hljs-type"><span class="hljs-type">Integer</span></span> = +$li(value,<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> result = result + <span class="hljs-built_in"><span class="hljs-built_in">count</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-type"><span class="hljs-type">ReduceOutput</span></span>.<span class="hljs-type"><span class="hljs-type">Emit</span></span>(<span class="hljs-string"><span class="hljs-string">"Count"</span></span>, result) } }</code> </pre> <br><p>  Until the end of the stream ( <code>'ReduceInput.IsAtEnd()</code> ) is met, it continues to consume data from the ReduceInput stream, and at each iteration the key-value pair is <code>$listbuild&lt;&gt;</code> from the binary list format <code>$listbuild&lt;&gt;</code> (i.e., in the form <code>$lb(word,count)</code> ). </p><br><p>  This function aggregates the number of words into the result variable and emits its total value and the next stage of the pipeline through the ReduceOutput stream. </p><br><p>  So, we showed the mapper and reducer, the turn has come to show the main, managing part of the program.  Without risking immediately to rest against the complexity of parallelism, we go with the sequential version of the algorithm, albeit using the idiom and interfaces using MapReduce.  Yes, in the sequential mode, all these push-ups with the conveyor do not make much sense, but ... simplification is necessary for pedagogical purposes. </p><br><pre> <code class="hljs smalltalk">/// , -   <span class="hljs-comment"><span class="hljs-comment">"map-reduce"</span></span>. /<span class="hljs-type"><span class="hljs-type">Class</span></span> <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">WordCount</span></span>.<span class="hljs-type"><span class="hljs-type">App</span></span> <span class="hljs-type"><span class="hljs-type">Extends</span></span> %<span class="hljs-type"><span class="hljs-type">RegisteredObject</span></span> { <span class="hljs-type"><span class="hljs-type">ClassMethod</span></span> <span class="hljs-type"><span class="hljs-type">MapReduce</span></span>() [ <span class="hljs-type"><span class="hljs-type">ProcedureBlock</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> ] { new //kill ^mtemp.<span class="hljs-type"><span class="hljs-type">Map</span></span>,^mtemp.<span class="hljs-type"><span class="hljs-type">Reduce</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#dim</span></span> infraPipe <span class="hljs-type"><span class="hljs-type">As</span></span> <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">GlobalPipe</span></span> = #<span class="hljs-symbol"><span class="hljs-symbol">#class</span></span>(<span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">GlobalPipe</span></span>).%<span class="hljs-type"><span class="hljs-type">New</span></span>(<span class="hljs-string"><span class="hljs-string">$n</span></span>ame(^mtemp.<span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-string"><span class="hljs-string">$J</span></span>))) for i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-symbol"><span class="hljs-symbol">#dim</span></span> fileName <span class="hljs-type"><span class="hljs-type">As</span></span> %<span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">$p</span></span>iece(<span class="hljs-string"><span class="hljs-string">$T</span></span>ext(<span class="hljs-type"><span class="hljs-type">DATA</span></span>+i),<span class="hljs-comment"><span class="hljs-comment">";"</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) quit:fileName=<span class="hljs-comment"><span class="hljs-comment">""</span></span> // map <span class="hljs-symbol"><span class="hljs-symbol">#dim</span></span> inputFile <span class="hljs-type"><span class="hljs-type">As</span></span> <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Input</span></span>.<span class="hljs-type"><span class="hljs-type">FileLines</span></span> = #<span class="hljs-symbol"><span class="hljs-symbol">#class</span></span>(<span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Input</span></span>.<span class="hljs-type"><span class="hljs-type">FileLines</span></span>).%<span class="hljs-type"><span class="hljs-type">New</span></span>(<span class="hljs-type"><span class="hljs-type">FileName</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">#dim</span></span> mapper <span class="hljs-type"><span class="hljs-type">As</span></span> <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">WordCount</span></span>.<span class="hljs-type"><span class="hljs-type">Mapper</span></span> = #<span class="hljs-symbol"><span class="hljs-symbol">#class</span></span>(<span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">WordCount</span></span>.<span class="hljs-type"><span class="hljs-type">Mapper</span></span>).%<span class="hljs-type"><span class="hljs-type">New</span></span>() do mapper.<span class="hljs-type"><span class="hljs-type">Map</span></span>(inputFile, infraPipe) // reduce <span class="hljs-symbol"><span class="hljs-symbol">#dim</span></span> outPipe <span class="hljs-type"><span class="hljs-type">As</span></span> <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Base</span></span>.<span class="hljs-type"><span class="hljs-type">Emitter</span></span> = #<span class="hljs-symbol"><span class="hljs-symbol">#class</span></span>(<span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Emitter</span></span>.<span class="hljs-type"><span class="hljs-type">Sorted</span></span>).%<span class="hljs-type"><span class="hljs-type">New</span></span>(<span class="hljs-string"><span class="hljs-string">$n</span></span>ame(^mtemp.<span class="hljs-type"><span class="hljs-type">Reduce</span></span>(<span class="hljs-string"><span class="hljs-string">$J</span></span>))) <span class="hljs-symbol"><span class="hljs-symbol">#dim</span></span> reducer <span class="hljs-type"><span class="hljs-type">As</span></span> <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">WordCount</span></span>.<span class="hljs-type"><span class="hljs-type">Adder</span></span> = #<span class="hljs-symbol"><span class="hljs-symbol">#class</span></span>(<span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">WordCount</span></span>.<span class="hljs-type"><span class="hljs-type">Adder</span></span>).%<span class="hljs-type"><span class="hljs-type">New</span></span>() while <span class="hljs-string"><span class="hljs-string">'infraPipe.IsAtEnd() { do reducer.Reduce(infraPipe, outPipe) } do outPipe.Dump() } quit DATA ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol1.txt ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol2.txt ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol3.txt ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol4.txt ;; } }</span></span></code> </pre> <br><p>  Let's try to explain this code line by line: </p><br><ul><li><p>  In the usual case, we do not recommend this, but in this case it is necessary: ‚Äã‚Äãwe turn off the procedural blocks <a href="">ProcedureBlock = 0</a> and return to the old semantics with manual control of the contents of the symbol table with local variables.  We need this to embed the DATA block containing the input data (in this case, the path to the input files), which we will access via the <code>$TEXT</code> function.  In this case, we are using 4 volumes of ‚ÄúWar and Peace‚Äù by Leo Tolstoy; </p><br></li><li><p>  We will use for the intermediate storage of data between the stages of the pipeline globals of the form <code>^mtemp.Map($J)</code> and <code>^mtemp.Reduce($J)</code> .  By magic, the globals of the form <code>^mtemp*</code> and <code>^CacheTemp*</code> automatically displayed in the <a href="">CACHETEMP</a> time base and will not be logged (as far as possible) in memory.  We will treat them as "in-memory" globals. </p><br></li><li>  The intraPipe intermediate channel is an instance of <code>MR.Sample.GlobalPipe</code> , which in our case is just a synonym for the class <code>MR.EmitterSorted</code> , and as we described in the <a href="https://habrahabr.ru/company/intersystems/blog/310196/">previous section, is</a> automatically cleared at the end of the program. </li></ul><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MR</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Sample</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.GlobalPipe</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Extends</span></span> (%<span class="hljs-selector-tag"><span class="hljs-selector-tag">RegisteredObject</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">MR</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Emitter</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Sorted</span></span>) { }</code> </pre> <br><ul><li><p>  We go through the lines <code>$TEXT(DATA+i)</code> , pull out the third argument of the string, separated by ";".  If the result is non-empty, then we use this value as the name of the input file. </p><br></li><li>  The input mapper iterator (display object) will be an instance of MR.Input.FileLines, which we have not yet shown ... </li></ul><br><pre> <code class="hljs mel">Class MR.Input.FileLines Extends (%RegisteredObject, MR.Base.Iterator) { Property File As %Stream.FileCharacter; Method %OnNew(FileName As %String) As %Status { set ..File = ##class(%Stream.FileCharacter).%New() #dim sc As %Status = ..File.LinkToFile(FileName) <span class="hljs-keyword"><span class="hljs-keyword">quit</span></span> sc } Method GetNext() As %String { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $isobject(..File) &amp;&amp; <span class="hljs-string"><span class="hljs-string">'..File.AtEnd { quit ..File.ReadLine() } quit "" } Method IsAtEnd() As %Boolean { quit '</span></span>$isobject(..File) || ..File.AtEnd } }</code> </pre> <br><p>  Let's go back to the <code>MR.Sample.WordCount.App</code> application: </p><br><ul><li><p>  The mapper object will be an instance of the already known <code>MR.Sample.WordCount.Mapper</code> (see above).  An instance is created separately for each file being processed. </p><br></li><li><p>  In the loop, we sequentially call the MapMapper function, passing an instance of the input stream working with the open file.  In this particular case, the mapping stage is linearized in a sequential loop.  Which is not very typical for MapReduce but is needed as a simplified exercise. </p><br></li><li><p>  At the convolution stage, we get: the emitter output object ( <code>outPipe</code> ) as an instance of <code>MR.Emitter.Sorted</code> , which points to <code>^mtemp.Reduce($J)</code> .  I remind you that the specificity of <code>MR.Emitter.Sorted</code> will be the use of the B * -Tree implementation in the Cach√© engine for various optimizations.  Keys-values ‚Äã‚Äãare stored in persistent storage in a naturally sorted way, and therefore implementations of convolution with autoincrement of output values ‚Äã‚Äãbecome possible. </p><br></li><li><p>  The convolution object is an instance of the <code>MR.Sample.WordCount.Adder</code> described above. </p><br></li><li>  For each open file, and on the same loop iteration, we call <code>reducer.Reduce</code> , passing there both the intermediate stream <code>infraPipe</code> and the output stream. </li></ul><br><p>  It seems to be all the parts in the collection - let's see how it all works. </p><br><pre> <code class="hljs kotlin">DEVLATEST:MAPREDUCE:<span class="hljs-number"><span class="hljs-number">23</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">27</span></span>:.<span class="hljs-number"><span class="hljs-number">000203</span></span>&gt;<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(MR.Sample.WordCount.App).MapReduce() ^mtemp.Reduce(<span class="hljs-number"><span class="hljs-number">3276</span></span>,<span class="hljs-string"><span class="hljs-string">"Count"</span></span>)=<span class="hljs-number"><span class="hljs-number">114830</span></span> ^mtemp.Reduce(<span class="hljs-number"><span class="hljs-number">3276</span></span>,<span class="hljs-string"><span class="hljs-string">"Count"</span></span>)=<span class="hljs-number"><span class="hljs-number">123232</span></span> ^mtemp.Reduce(<span class="hljs-number"><span class="hljs-number">3276</span></span>,<span class="hljs-string"><span class="hljs-string">"Count"</span></span>)=<span class="hljs-number"><span class="hljs-number">130276</span></span> ^mtemp.Reduce(<span class="hljs-number"><span class="hljs-number">3276</span></span>,<span class="hljs-string"><span class="hljs-string">"Count"</span></span>)=<span class="hljs-number"><span class="hljs-number">109344</span></span></code> </pre> <br><p>  Here we see the calculated number of words in each volume of the book, which is displayed at the end of each iteration of the cycle.  This is all good, but there are 2 questions that we have not received an answer: </p><br><ul><li>  What is the total number of words in all volumes? </li><li>  And are we sure that the given numbers are correct?  Which, by the way, is not the initial stage of writing programs is more important. </li></ul><br><p>  Let's start with the answer to the second question, with verifying the result - check it out simply by running the Linux / Unix / Cygwin <code>wc</code> utility on the same data itself: </p><br><pre> <code class="hljs kotlin"><span class="hljs-symbol"><span class="hljs-symbol">Timur@</span></span>TimurYoga2P /cygdrive/c/Users/Timur/Documents/mapreduce/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> $ wc -w war*.txt <span class="hljs-number"><span class="hljs-number">114830</span></span> war_and_peace_vol1.txt <span class="hljs-number"><span class="hljs-number">123232</span></span> war_and_peace_vol2.txt <span class="hljs-number"><span class="hljs-number">130276</span></span> war_and_peace_vol3.txt <span class="hljs-number"><span class="hljs-number">109344</span></span> war_and_peace_vol4.txt <span class="hljs-number"><span class="hljs-number">477682</span></span> total</code> </pre> <br><p>  We see that the calculated number of words for each volume was correct, t.ch.  let's turn to the calculation of the final, aggregate values. </p><br><h3 id="izmenennyy-variant--s-podschetom-obschey-summy">  The modified version - with the calculation of the total amount </h3><br><p>  To calculate the final amount, we need to make 2 simple changes to the program code shown above: </p><br><ul><li><p>  You need to apply the method of refactoring <a href="http://refactoring.com/catalog/extractMethod.html">"Extract Method"</a> on the part of the code mapper.  In the future, we will need this part of the code separately, in the form <em>of a class method,</em> which, as a result, will simplify further modifications with parallelization or even remote code execution. </p><br></li><li>  Also, we need to take out the instantiation of the reducer objects and call its function Reduce from the cycle outside.  The purpose of this modification is not to delete the intermediate channel with data at the end of each iteration, and continue to accumulate data between iterations, to show the total amount after the cycle.  The aggregate amount will be calculated automatically, since  we apply the auto-increment option. </li></ul><br><p>  In all other cases, the two cited examples behave identically - both use temporary globals <code>^mtemp.Map($J)</code> and <code>^mtemp.Reduce($J)</code> as intermediate and final storage at the display and convolution stages. </p><br><pre> <code class="hljs mel">Class MR.Sample.WordCount.AppSum Extends %RegisteredObject { ClassMethod Map(FileName As %String, infraPipe As MR.Sample.GlobalPipe) { #dim inputFile As MR.Input.FileLines = ##class(MR.Input.FileLines).%New(FileName) #dim mapper As MR.Sample.WordCount.Mapper = ##class(MR.Sample.WordCount.Mapper).%New() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> mapper.Map(inputFile, infraPipe) } ClassMethod MapReduce() [ ProcedureBlock = <span class="hljs-number"><span class="hljs-number">0</span></span> ] { new #dim infraPipe As MR.Sample.GlobalPipe = ##class(MR.Sample.GlobalPipe).%New($name(^mtemp.Map($J))) #dim outPipe As MR.Base.Emitter = ##class(MR.Emitter.Sorted).%New($name(^mtemp.Reduce($J))) #dim reducer As MR.Sample.WordCount.Adder = ##class(MR.Sample.WordCount.Adder).%New() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> { #dim fileName As %String = $piece($Text(DATA+i),<span class="hljs-string"><span class="hljs-string">";"</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">quit</span></span>:fileName=<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ..Map(fileName, infraPipe) <span class="hljs-comment"><span class="hljs-comment">//do infraPipe.Dump() } while 'infraPipe.IsAtEnd() { do reducer.Reduce(infraPipe, outPipe) } do outPipe.Dump() quit DATA ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol1.txt ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol2.txt ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol3.txt ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol4.txt ;; } }</span></span></code> </pre> <br><h3 id="parallelnaya-realizaciya">  Parallel implementation </h3><br><p>  Let's immediately admit to ourselves - such push-ups with MapReduce interfaces when creating a simple algorithm for word counting were not the simplest, most obvious and natural approach in developing such a trivial program.  But the potential buns that we can get here still outweigh all the initial problems and the extra pain.  With reasonable concurrency planning and using appropriate algorithms, we can get scaling that is difficult to obtain on sequential algorithms.  For example, in this case, on a simple low-power Haswell ULT laptop on which this article is written, the sequential algorithm worked out in 4.5 seconds, while the parallel version was completed in 2.6 seconds. </p><br><p>  The difference is not so dramatic, but significant enough, especially considering the small input set and only two cores on the laptop. </p><br><p>  Let's return to the code - at the previous stage, at the mapping stage, we separated the function into a separate class method that takes two arguments (the name of the input file and the name of the output global).  We have allocated this code into a separate function with one simple goal - to facilitate the creation of a parallel version.  Such a parallel version will use the worker mechanism in Cach√© ObjectScript <a href="">($ system.WorkMgr).</a> Below, we convert the serial version created in the previous step into parallel by calling the handler programs (workers) launched with the selected class method. </p><br><pre> <code class="hljs smalltalk">///  #<span class="hljs-number"><span class="hljs-number">2</span></span>  ,    <span class="hljs-type"><span class="hljs-type">Class</span></span> <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">WordCount</span></span>.<span class="hljs-type"><span class="hljs-type">AppWorkers</span></span> <span class="hljs-type"><span class="hljs-type">Extends</span></span> %<span class="hljs-type"><span class="hljs-type">RegisteredObject</span></span> { <span class="hljs-type"><span class="hljs-type">ClassMethod</span></span> <span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-type"><span class="hljs-type">FileName</span></span> <span class="hljs-type"><span class="hljs-type">As</span></span> %<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">InfraPipeName</span></span> <span class="hljs-type"><span class="hljs-type">As</span></span> %<span class="hljs-type"><span class="hljs-type">String</span></span>) <span class="hljs-type"><span class="hljs-type">As</span></span> %<span class="hljs-type"><span class="hljs-type">Status</span></span> { <span class="hljs-symbol"><span class="hljs-symbol">#dim</span></span> inputFile <span class="hljs-type"><span class="hljs-type">As</span></span> <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Input</span></span>.<span class="hljs-type"><span class="hljs-type">FileLines</span></span> = #<span class="hljs-symbol"><span class="hljs-symbol">#class</span></span>(<span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Input</span></span>.<span class="hljs-type"><span class="hljs-type">FileLines</span></span>).%<span class="hljs-type"><span class="hljs-type">New</span></span>(<span class="hljs-type"><span class="hljs-type">FileName</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">#dim</span></span> mapper <span class="hljs-type"><span class="hljs-type">As</span></span> <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">WordCount</span></span>.<span class="hljs-type"><span class="hljs-type">Mapper</span></span> = #<span class="hljs-symbol"><span class="hljs-symbol">#class</span></span>(<span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">WordCount</span></span>.<span class="hljs-type"><span class="hljs-type">Mapper</span></span>).%<span class="hljs-type"><span class="hljs-type">New</span></span>() <span class="hljs-symbol"><span class="hljs-symbol">#dim</span></span> infraPipe <span class="hljs-type"><span class="hljs-type">As</span></span> <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">GlobalPipeClone</span></span> = #<span class="hljs-symbol"><span class="hljs-symbol">#class</span></span>(<span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">GlobalPipeClone</span></span>).%<span class="hljs-type"><span class="hljs-type">New</span></span>(<span class="hljs-type"><span class="hljs-type">InfraPipeName</span></span>) do mapper.<span class="hljs-type"><span class="hljs-type">Map</span></span>(inputFile, infraPipe) quit <span class="hljs-string"><span class="hljs-string">$$</span></span><span class="hljs-string"><span class="hljs-string">$O</span></span>K } <span class="hljs-type"><span class="hljs-type">ClassMethod</span></span> <span class="hljs-type"><span class="hljs-type">MapReduce</span></span>() [ <span class="hljs-type"><span class="hljs-type">ProcedureBlock</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> ] { new <span class="hljs-symbol"><span class="hljs-symbol">#dim</span></span> infraPipe <span class="hljs-type"><span class="hljs-type">As</span></span> <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">GlobalPipe</span></span> = #<span class="hljs-symbol"><span class="hljs-symbol">#class</span></span>(<span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">GlobalPipe</span></span>).%<span class="hljs-type"><span class="hljs-type">New</span></span>(<span class="hljs-string"><span class="hljs-string">$n</span></span>ame(^mtemp.<span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-string"><span class="hljs-string">$J</span></span>))) <span class="hljs-symbol"><span class="hljs-symbol">#dim</span></span> outPipe <span class="hljs-type"><span class="hljs-type">As</span></span> <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Base</span></span>.<span class="hljs-type"><span class="hljs-type">Emitter</span></span> = #<span class="hljs-symbol"><span class="hljs-symbol">#class</span></span>(<span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Emitter</span></span>.<span class="hljs-type"><span class="hljs-type">Sorted</span></span>).%<span class="hljs-type"><span class="hljs-type">New</span></span>(<span class="hljs-string"><span class="hljs-string">$n</span></span>ame(^mtemp.<span class="hljs-type"><span class="hljs-type">Reduce</span></span>(<span class="hljs-string"><span class="hljs-string">$J</span></span>))) <span class="hljs-symbol"><span class="hljs-symbol">#dim</span></span> reducer <span class="hljs-type"><span class="hljs-type">As</span></span> <span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">WordCount</span></span>.<span class="hljs-type"><span class="hljs-type">Adder</span></span> = #<span class="hljs-symbol"><span class="hljs-symbol">#class</span></span>(<span class="hljs-type"><span class="hljs-type">MR</span></span>.<span class="hljs-type"><span class="hljs-type">Sample</span></span>.<span class="hljs-type"><span class="hljs-type">WordCount</span></span>.<span class="hljs-type"><span class="hljs-type">Adder</span></span>).%<span class="hljs-type"><span class="hljs-type">New</span></span>() <span class="hljs-symbol"><span class="hljs-symbol">#dim</span></span> sc <span class="hljs-type"><span class="hljs-type">As</span></span> %<span class="hljs-type"><span class="hljs-type">Status</span></span> = <span class="hljs-string"><span class="hljs-string">$$</span></span><span class="hljs-string"><span class="hljs-string">$O</span></span>K // do <span class="hljs-string"><span class="hljs-string">$s</span></span>ystem.<span class="hljs-type"><span class="hljs-type">WorkMgr</span></span>.<span class="hljs-type"><span class="hljs-type">StopWorkers</span></span>() <span class="hljs-symbol"><span class="hljs-symbol">#dim</span></span> queue <span class="hljs-type"><span class="hljs-type">As</span></span> %<span class="hljs-type"><span class="hljs-type">SYSTEM</span></span>.<span class="hljs-type"><span class="hljs-type">WorkMgr</span></span> = <span class="hljs-string"><span class="hljs-string">$s</span></span>ystem.<span class="hljs-type"><span class="hljs-type">WorkMgr</span></span>.<span class="hljs-type"><span class="hljs-type">Initialize</span></span>(<span class="hljs-comment"><span class="hljs-comment">"/multicompile=1"</span></span>, .sc) quit:<span class="hljs-string"><span class="hljs-string">$$</span></span><span class="hljs-string"><span class="hljs-string">$I</span></span>SERR(sc) for i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-symbol"><span class="hljs-symbol">#dim</span></span> fileName <span class="hljs-type"><span class="hljs-type">As</span></span> %<span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">$p</span></span>iece(<span class="hljs-string"><span class="hljs-string">$T</span></span>ext(<span class="hljs-type"><span class="hljs-type">DATA</span></span>+i),<span class="hljs-comment"><span class="hljs-comment">";"</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) quit:fileName=<span class="hljs-comment"><span class="hljs-comment">""</span></span> //do ..<span class="hljs-type"><span class="hljs-type">Map</span></span>(fileName, infraPipe) set sc = queue.<span class="hljs-type"><span class="hljs-type">Queue</span></span>(<span class="hljs-comment"><span class="hljs-comment">"##class(MR.Sample.WordCount.AppWorkers).Map"</span></span>, fileName, infraPipe.<span class="hljs-type"><span class="hljs-type">GlobalName</span></span>) quit:<span class="hljs-string"><span class="hljs-string">$$</span></span><span class="hljs-string"><span class="hljs-string">$I</span></span>SERR(sc) } set sc = queue.<span class="hljs-type"><span class="hljs-type">WaitForComplete</span></span>() quit:<span class="hljs-string"><span class="hljs-string">$$</span></span><span class="hljs-string"><span class="hljs-string">$I</span></span>SERR(sc) while <span class="hljs-string"><span class="hljs-string">'infraPipe.IsAtEnd() { do reducer.Reduce(infraPipe, outPipe) } do outPipe.Dump() quit DATA ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol1.txt ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol2.txt ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol3.txt ;;C:\Users\Timur\Documents\mapreduce\data\war_and_peace_vol4.txt ;; }</span></span></code> </pre> <br><p>  Previously, the example was called AppSum, the New example is called AppWorkers, and the difference between them is very small, but important - we call the display procedure in a separate thread (process) handler using the <code>$system.WorkMgr.Queue</code> API.  This API can call a simple subroutine, or a class method, but (by natural reason) cannot call object methods, since  there is no mechanism for transferring an object to an external process. </p><br><p>  When you call a parallel handler through this API, additional restrictions are imposed on the types of values ‚Äã‚Äãto be passed: </p><br><ul><li>  We cannot pass values ‚Äã‚Äãby reference and, as a result, cannot return the modified values ‚Äã‚Äãof such arguments; </li><li>  Moreover, we can only transmit simple scalar values ‚Äã‚Äã(numbers and strings), but not objects. </li></ul><br><p>  <em>But here, dear Houston, we have a problem</em> .  In the previous example, the <code>MR.Sample.WordCount.AppSum::Map</code> method received as the 2nd argument an instance of the <code>MR.Sample.GlobalPipe</code> class.  But we cannot transfer objects between processes (and a worker is a separate process from the process pool).  And in this case, we need to come up with a simple "serialization" / "deserialization" scheme of the object into literal values, so that this can be passed to the parallel handler via the <code>$system.WorkMgr.Queue</code> API. </p><br><blockquote>  <em>In the case of <code>GlobalPipe</code> ‚Äúsimple serialization method‚Äù is really simple.</em>  <em>If we transfer the name of the intermediate global, then this is enough for an adequate transfer of the state of our object.</em>  <em>That is why the second argument of the <code>MR.SampleWordCount.AppWorkers::Map</code> method is a string with the name of the global, and not an object.</em> </blockquote><p>  We recommend reading the documentation for parallel handlers <a href="">here</a> , but for the future, remember that if you want to use parallel handlers (in the maximum amount that is allowed with your hardware and license), then when initializing handlers you should pass a parameter with a strange name " <code>/multicompile=1</code> " .  [The strange name is explained by the fact that this functionality was added for parallel compilation in the Cach√© ObjectScript class translator.  Since then, this modifier has been used outside the translator code.] </p><br><p>  As soon as we have planned the execution of the method through <a href="">$ system.WorkMgr.Queue</a> , we can run all the planned routines and wait for them to complete through <a href="">$ system.WorkMgr.WaitForComplete</a> . </p><br><p>  All parallel processors will use the same intermediate global <code>infraPipe</code> to transfer data between pipeline stages, but you should not expect collisions with data.  The underlying data engine will handle them correctly.  Recall that the Cach√© architecture is initially <em>multiprocessing</em> , with many scalable synchronization mechanisms between processes working with the same data.  Additionally, we note that our simplified example with calculating the total number of words in all volumes performs a reducer (reducer) in one thread, which also simplifies the code and saves us some headaches. </p><br><blockquote>  <em>Thus, at the moment we managed to talk about the general terms of the MapReduce algorithms, created the basic MapReduce interfaces when implemented in the context of the Cach√© ObjectScript environment, and created a simple word counting example in the same environment.</em>  <em>In the next article, we will show other idioms used in our implementation, using the second classic example from WikiPedia - AgeAverage.</em>  <em>It's only the beginning!</em> </blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/312338/">https://habr.com/ru/post/312338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312324/index.html">What do we hate in job interviews?</a></li>
<li><a href="../312326/index.html">Remote work 2.0. Nadezhda Yurinova, Bookmate Marketing Director</a></li>
<li><a href="../312328/index.html">NooLite + Raspberry Pi + Telegram = smart home</a></li>
<li><a href="../312330/index.html">Network Monitoring with Apple TV</a></li>
<li><a href="../312336/index.html">Content theft in Chinese game dev</a></li>
<li><a href="../312340/index.html">Basics of computer networks. Subject number 4. Network devices and types of cables used</a></li>
<li><a href="../312344/index.html">Pro application backward compatibility and digging out flight attendants</a></li>
<li><a href="../312346/index.html">Cross-VC NSX: Simplicity and Flexibility for Multiple Deployments</a></li>
<li><a href="../312348/index.html">OpenShift xPaaS version 3. "Hello, world"</a></li>
<li><a href="../312352/index.html">TailSampler - parallel GET requests sent to Apache.JMeter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>