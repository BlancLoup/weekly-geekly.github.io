<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sharding - patterns and antipatterns</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Konstantin Osipov ( kostja ), Alexey Rybak ( fisher ) 
 Konstantin Osipov: The report was born from the next conversation. As always, I tried to convi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sharding - patterns and antipatterns</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/718/15e/4da/71815e4da0191c88d7e72db5025306cf.jpg"><br><br><h2>  Konstantin Osipov ( <a href="https://habrahabr.ru/users/kostja/" class="user_link">kostja</a> ), Alexey Rybak ( <a href="https://habrahabr.ru/users/fisher/" class="user_link">fisher</a> ) </h2><br>  <b>Konstantin Osipov: The</b> report was born from the next conversation.  As always, I tried to convince Alexey to use Tarantool more, and he said that there is still no sharding and, generally, is not interesting.  Then we began to talk about why not.  I began to tell that there is no one universal solution, the automation is complete for you, and you only drink coffee at work and all ... <br><br><h3>  Therefore, this report was born - to look at what sharding is, what methods are used in which systems, what are the advantages and disadvantages, why it is impossible to solve everything with a single silver bullet? </h3><a name="habracut"></a><br>  If we talk about sharding as a problem, then, generally speaking, there is no such problem.  There is a problem with distributed systems, i.e.  There are large databases that scale horizontally, they have many tasks, we have listed them: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/688/4dd/bfd/6884ddbfd40beaa7a6c127649652ef18.png"><br><br>  First of all, the more nodes you have, the more acute the problem of their failure.  Imagine that you out of 1000 computers one by one will break, on average, every other day or more.  Therefore, you are faced with the task of data redundancy in order not to lose them.  And this is not sharding.  It is rather a replication. <br><br>  The most difficult problem in a distributed system is the problem of membership, i.e.  who enters it, who does not, because the machines fail, errors occur, and permanent membership in the distributed system changes.  We will not talk about this either. <br><br>  There is a task of distributed execution of complex queries.  MapReduce or distributed SQL.  This is not it either. <br><br>  So, what are we going to talk about? <br><br>  We will take one topic, namely the topic of how a certain amount of data that does not fit on one machine can be distributed horizontally across a horizontal cluster, and how to manage it all afterwards. <br><br>  <b>Alex Rybak:</b> I will add.  The term is already settled, but, nevertheless, what is sharding?  Suddenly, someone does not know.  Sharding is a method, as a rule, of horizontal data separation.  Most often, sharding is spoken not only about distributed databases, but, in general, about distributed storage.  We will primarily focus on databases. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd1/9f2/afd/dd19f2afd5b16fba906e7c048c84be98.png"><br><br>  <b>Konstantin Osipov:</b> In our report we took three things that make up the sharding itself: <br><br><ul><li>  sharding function selection, </li><li>  where your data is located (how you find it), </li><li>  how you redistribute your data. </li></ul><br>  We will try to make this report not theoretical, but how it works in those projects that we know, i.e.  there will be life stories. <br><br>  <b>Alexei Rybak:</b> Despite the fact that we will tell all sorts of stories about what has been done and how, nevertheless, the basis of the report is methodological.  To imagine how everything is usually done (and, in one way or another, everything is done in only a few ways), so that the terms are settled, and the next time, if we go into some topics, we would speak the same language. <br><br>  <b>Konstantin Osipov:</b> We are not faced with the task of convincing you to use one or another product, but with the help of this report, maybe you can better understand how this or that product works ‚Äúunder the hood‚Äù and what are the advantages and disadvantages of the solution chosen by the developers this product. <br><br>  You can manage any system only by understanding how it works. <br><br>  Actually, what is sharding on the surface?  This is the choice of the method.  I will designate this choice like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d9/70c/7ce/2d970c7ce5d44ab278065f667881ff92.png"><br><br>  We have a key, we need to define a shard.  A shard is usually either the IP address or the DNS address of the computer on which it is all located. <br><br>  In fact, the formula is incorrect, because in the general case there should be a function of the key and the number of servers, i.e.  how many machines we have or, in general, from multiple servers.  And it should produce the right server, because it works differently on different numbers of servers. <br><br>  But before we talk about this, we want to talk about something more fun, namely, choosing the right key for which this partitioning is performed.  Here the story, in general, is this: you choose the key, by which you shuffle the data once, and you live with it all your life, well, or for a long time - several years, and you get all the advantages and disadvantages of this business. <br><br>  And much later, when something cannot be done (because the data are already distributed in a certain way, the system is already running, downtime is impossible), what problems can there be, stories? <br><br>  One story - from 2001, the time of SpyLOG's youth - there the sharding was based on users.  What is SpyLOG?  Now it is openstat.  It collects statistics of visits, i.e.  This is such a tracker, a counter, a small button on the page. <br><br>  In general, all sites, both large and small, were at that time distributed over 40 machines.  And, accordingly, larger sites lived together with smaller sites, i.e.  the sharding key was the site ID, for example, anecdot.ru, rambler.ru, yandex.ru ... <br><br>  It so happened that the big sites actually laid our machines, because one traffic generated by one sharding key was more than one machine could accept. <br><br>  Therefore, when you choose what you shuffle the data, you must select a small enough object so that it does not put the system. <br><br>  For example, in the case of Facebook, you have a Justin Bieber page, and you decide to share the data on users too.  Naturally, Justin Bieber has a million of followers, likes, a lot of reposts for his every message, etc.  Therefore, probably, the choice of Justin Bieber as the one for whom you will be sharding is not the best idea. <br><br>  The second point that must be borne in mind when sharding is that sharding is not about normalization, i.e.  if you think that there is some canonical way to look at your data and determine how you will distribute it across your machines, then it is not.  That is, you should look not at the data, but at the use cases, at your application, at your business, and you should think about which use case in your business is the most important and should be the most productive.  Because in sharding there are always compromises.  Some requests work quickly, instantly, some requests you will have to perform on the entire cluster.  And the choice of which key you shuffle determines this. <br><br>  <b>Alexey Rybak:</b> About Justin Bieber.  And I think that in most social networks, in fact, the user's choice as a sharding key is a good choice.  But it must be remembered that if you are packing all the posts, comments, etc., into the same shard, then be prepared that at some point you will have a very non-uniform distribution of data and you may need to use Your project has two types of sharding - one is your original, by users, and the second is some kind of additional - for example, by comments. <br><br>  This will naturally cause the data to be (with some probability) inconsistent, that you will need to make two instead of one request.  It's not scary, because with this you get the opportunity to somehow grow. <br><br>  And if you pack everything on one shard, then you will have everything very unbalanced, and the quality of your software and your service for users can be very low.  Therefore, it is not scary that we will make programming more complicated, but then everything will be quite fast.  That is, it is quite a reasonable trade-off. <br><br>  <b>Konstantin Osipov:</b> Another point that I would like to say.  Not always sharding key you have stored.  For example, storing sessions on mail.ru.  Suppose you have an ID mail.ru, I have it kostea.mail.ru or something.  Session is the object that identifies the device from which I came.  Accordingly, one login has many sessions.  Mail.ru keeps all sessions of one user on one shard, i.e.  sharding key is login.  But the session itself, i.e.  object identifier - the primary key is not the sharding key.  That is, it is not always the case that the object identifier is a sharding key.  And it happens conveniently, since everything is stored on one shard.  We can single user, for example, log off everywhere, if we suspect that his password has been hacked, etc.  We can easily manage it. <br><br>  Here is an example of good and bad shard keys: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46b/ef4/d3e/46bef4d3e1ef8f646877810435d512cd.png"><br><br>  <b>Alexey Rybak:</b> We will return to this example more than once, so we will continue. <br><br>  If you are faced with sharding, then most likely it happened at the moment when you did not hear our report.  You tried to search something on the Internet and found nothing special.  In the past ten years, probably, many teams have gone the same way the invention of bicycles.  Therefore, we will begin to examine our patterns or ways of organizing sharding with some of the most common and not the worst methods. <br><br>  As the first two you can choose the following. <br><br>  As a rule, it all starts with a single server, and there is such a completely simple for, including system administration, method - ‚Äúyogurt of system administrators‚Äù.  "Yogurt" - because it is light and useful. <br><br>  Before we move on to this method, I want to note: when a large system is made, despite the fact that it starts with one or two servers, the most important thing when it grows is the cost of support ‚Äî how many, relatively speaking, problems in operation this whole economy arises.  Therefore, the convenience of the system administrator is a value that should probably be in the first place when such systems are designed. <br><br>  So, you have one server, you picked up a replica, attached data to it, after some time you distributed the load, including by recording, and you think what to do next.  And then you buy two more servers, each of them has its own replica.  Why replica?  Because from the point of view of system administration, this is quite simple - you set up a replica, then for some time there were banned recordings, so you just share as an amoeba, which is shown in this figure: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2dd/36e/4b0/2dd36e4b0ea55842d92e6ea68e4ba40a.png"><br><br>  The problem is that you need to double all the time, and it will be very expensive.  Therefore it is necessary to use something else. <br><br>  There is some combination based on magic numbers.  I wrote 48 here, in fact, this is just an example for an idea.  What is convenient number 48?  It is divided by 12, by 6, by 4, by 3. You can start with the fact that on one server you will hold 48 schemes or 48 tables, initially cut into such a number.  After that, with simple operations for the system administrator, with dumps, you can transfer some of the data to other servers.  In this case, of course, somewhere you should have a coordination logic, which we will talk about later.  This method ‚Äî using some special numbers that are easy to divide ‚Äî will allow you to grow quite easily, for example, up to 48-50 servers. <br><br>  <b>Konstantin Osipov:</b> In general, when you think about sharding, you first need to analyze your subject area, i.e.  what kind of data you have stored. <br><br>  There can not be a lot of data.  Even if we talk about all the people on our planet, it is only 7-8 billion.  It's not that much.  Suppose if we are talking about all advertisements on any avito, then these are also millions, but these are not extraordinary values.  Those.  you have a ceiling.  Any system grows, but its growth slows down as it grows larger.  Therefore, it is not always necessary to take some of the most complex decisions in order to maximize everything.  If you know that you will have a maximum of 10 servers, you may need a simple solution. <br><br>  I also want to note that the choice of sharding formulas (on the slide, this formula ‚Äî we just divide in half) is always associated with resharing. <br><br>  <b>Alexey Rybak:</b> How do we distribute data between keys?  While we spoke from the transfer of some schemes between servers.  Then the question arises: how do we, in general, scatter the data?  Chose the key, scattered data on the servers.  There are two of the largest ways. <br><br>  The first method is something similar to hashing.  It does not have to be consistent, that is, roughly speaking, when adding new servers, your set of keys can be shuffled a lot (this is the next moment we'll talk about).  Anyway, what are you doing?  If this is a numeric key, you can simply divide it by the number of servers, get the remainder of the division - and this will be your server number.  If this is a string key, for example, an e-mail, then you can take a numeric hash from it, then do the same. <br><br>  There are more ‚Äúgarage‚Äù methods - such as choosing the first letter of a login, but since you can‚Äôt determine the distribution of logins by letter, you must initially take into account the distribution of letters in the language, but this is also quite difficult.  Moreover, if you put one letter on one server, and then one letter does not fit into one server, then you will need to change the configuration very strongly in order to scatter this letter.  Very bad idea.  I would say that this is an anti-pattern. <br><br>  We denote only one problem that occurs during hashing.  This is adding new servers.  What happens in case of rewarding from the point of view of support?  You have a node crashes, you need to raise a master node for this part of the replicas and make it as fast as possible.  Secondly, your load has simply increased, you need to purchase new servers and put them into operation as quickly as possible.  Accordingly, resharing is a key issue. <br><br>  If you just take the remainder of the division, then more servers appear, all the hashes are "re-blurred", all keys, all data needs to be moved.  This is a very hard and bad operation.  It works when you keep everything in mind. <br><br>  For example, we have a memcached cluster in Badoo.  We distributed everything according to the remainder of the division, added new servers (this happens not so often), and after maybe 5-10 minutes all the data was re-sorted.  All this happens quite quickly, without any problems, because to move the data over the network and put it in the memory of another machine is garbage. <br><br>  If you have user data on the disk, for example, some kind of correspondence, etc., then this is a much more complicated thing. <br><br>  <b>Konstantin Osipov:</b> There is a sharding ‚Äúfor adults‚Äù.  And this is the second part of our report. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/de9/4e9/d38/de94e9d3840d56f15cc3b02a9c7eb193.png"><br><br>  What it is?  Sooner or later, the idea that we have, in general, everything is a cloud, and we want to make our database resiliently scale up.  Our sharding scheme should be exactly the same so that we don‚Äôt have to think about all these little details.  This is very tempting. <br><br>  We will now try to see if this is possible or not.  We will analyze how this works, and you will draw conclusions. <br><br>  <b>Alexey Rybak:</b> There are two very fundamental points here, two methods.  We will consider one of them - Table functions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/421/875/6c0/4218756c069355898649598e75f66f6a.png"><br><br>  This is just a table function. <br><br>  Let me remind you that one of the important tasks of this report is to reach an agreement, including on terms.  For example, I used to use other words to denote this.  I divided the methods into deterministic, i.e.  when there is a certain mathematical formula, and non-deterministic, when you can freely configure where a particular key is mapped. <br><br>  By and large, this is a table function and consistent hashing. <br><br>  Table functions is when you just have some kind of config.  The use of Table functions to sharding is very closely tied to such a concept as the virtual bucket. <br><br>  Remember, you have the function of displaying the key on the shard.  Imagine that you have some kind of intermediate display in the middle, i.e.  this mapping turns into two.  First you map the key to some virtual bucket, then the virtual bucket to the corresponding coordinate in the space of your cluster. <br><br>  There are not very many methods to do it all.  And we remember that the most important thing is to give freedom and convenience of work to the system administrator. <br><br>  Virtual bucket-s, as a rule, are selected in a sufficiently large number.  Why are they virtual?  Because in reality they do not reflect a real physical server.  And several methods are used to map the key directly to the shard. <br><br>  One method is when the first part of the ‚Äúkey to bucket‚Äù function is just some kind of hash or consistent hash, i.e.  some part that is determined by the formula, and the bucket directly on the shard is displayed through the config. <br><br>  The second thing is more complicated - when you display both through the config.  More complicated, because, relatively speaking, for each key you still need to remember where it lies.  You acquire the ability to move any key anywhere, but on the other hand you lose the ability to quickly and easily, having just a small config in ‚Äúbucket to shard‚Äù, determine the bucket from the key and then quickly go to the right place. <br><br>  <b>Konstantin Osipov:</b> Why do these options, in general, arise?  We will now talk about routing and resharing.  Here everything is, in principle, beautiful, comfortable, fully manageable, but you have a certain condition.  This state you need to store somewhere, it needs to be changed.  You have increased the number of servers, you need to change your tables.  There are two approaches here: first, you are hammering into the fact that you have a state, trying to control this state;  the second approach - you try to mathematize your formula as much as possible, and then you have the most deterministic, without any state you can determine where to go when routing. <br><br>  Here is one of the approaches that allows you to somehow functionally describe the sharding scheme.  This is a consistent hashing approach. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/35a/1b5/6ad/35a1b56adfde480eb23e0db091dd496b.png"><br><br>  First, tell you how it works.  We imagine that the entire range of our hash function is not displayed on a straight line from 0 to 2 <sup>32</sup> (~ 4 billion), but on a ring.  Those.  we have 4 billion is approximately in the same place, where 0, we, like, fasten our straight line. <br><br>  If we just use the hash function, we have to re-cache all this when adding new nodes.  It turns out that we use the remainder of the division by the number of nodes. <br><br>  And here we do not use the remainder of the division by the number of nodes.  We do this ‚Äî we have a hash function, perhaps another, apply it to the server identifier, and also locate the server on this ring.  Thus, it turns out that each server is responsible for a certain range of keys after it on the ring.  Accordingly, when you add a new server, it takes away the ranges that are before it and after it, i.e.  he partially divides the range.  No shuffling is absolutely required. <br><br>  <b>Alexey Rybak:</b> I, when I heard it for the first time a long time, I still did not understand anything.  If you do not understand anything, not scary. <br><br>  The idea here is this: in consistent hashing when you add new nodes, you shuffle only a small part of the keys.  And that's all. <br><br>  How this is done, you can look at the relevant keywords. <br><br>  <b>Konstantin Osipov:</b> Another couple of words about the shortcomings of this hashing story.  This, after all, is about some random variables.  The hash function is a certain randomizer, it takes your natural meaning, gives you a random one in response to this.  All accidentally falls somewhere on the ring.  And it does not provide in the simple case of an ideal distribution, i.e.  you can do this (see the picture) so that server number 3 is near server number 1, and between server number 2 and number 3 is such a large half ring - almost half of the data. <br><br>  In order for consistent hashing to work properly, you also need to add some state in the form of virtual buckets, mapping tables.  And virtual buckets need to be stored somewhere.  Mapping between virtual buckets and servers.  Those.  you have a condition.  This is not pure mathematics. <br><br>  We have another interesting slide with the keyword Guava / Sumbur: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d3/1a6/906/2d31a6906b57a05c65e77a538c9c33ec.png"><br><br>  The idea of ‚Äã‚ÄãGuava - your state disappears altogether.  In principle, this is a function that takes the key and the number of servers, and gives you server_id.     ,  ,     - ‚Äî      ‚Äî       server_id. <br><br>       .  ,   ‚Äî    ,  ,        ,     . <br><br>      ‚Äî  ,                 .   ,   , ..    ,    .     ,    ,   . <br><br>  ,   , ‚Äî , , , .. ,          . <br><br> <b> :</b>       ,      ,     . <br><br>   ,      . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f3/6ee/398/5f36ee398009a1cc8a8b5d9861686dd8.png"><br><br>   ,    ‚Äî : <br><br><ul><li>  ¬´ ¬ª; </li><li> ; </li><li>  coordinator </li></ul><br>    ¬´¬ª. <br><br> ¬´ ¬ª ‚Äî   . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11e/f30/84f/11ef3084f5713c14ea2b800048699bbb.png"><br><br>  ,      ,      bucket.  - , - .      config,        , , 1000 , 1000 , 1000  -.  ,   -    .    ,  ,    ,      . <br><br>  ,  ,     .    ‚Äî  ,     ,    -      - ,   ,   ,       ‚Äî  -. -,     -  ,      maintenance subwindow,     ,     ‚Äî   ,   . -    ,  -   ,  -     ..  ,  ,  . <br><br>    ‚Äî  . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac4/703/776/ac470377678d4a4dc27da97a8899d44a.png"><br><br>  ‚Äî   . <br><br> <b> :</b>  ,   ?    ,    -   ,   : ¬´, !           ¬ª. <br><br> <b> :</b>      ,     highload- (   ),     ,  ¬´ ‚Äî ,     ,  .     ,    .   ,        API,   ,        ,   - ‚Ä¶    ¬ª. <br><br>    ,       .  ,   ,   : ¬´,     ,       ¬ª. <br><br> ,  ,  .       . <br><br>  ,    :   ,     , ,     ,       ,          . <br><br> -    ,  ,    ,  ,  ,      .   ,   ,      ,      ,   ,      -  ,   ,     . <br><br>      ,   . , ,        .   ‚Äî    , ,  .   ‚Äî     . <br><br>         ,      ‚Äî    . <br><br> <b> :</b>  .    .    ,       .  ,        ?       load balancing-,   ,       , ..  ,  failover    .  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proxy allows you to make application logic very simple. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a certain way to simplify all this technology, if you make the proxy work on the same host on which the application itself is running. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another problem with proxies is that you need to propagate the sharding state, i.e. Proxy should know where the key is. And here we come to the following technology, which simplifies precisely this history - the technology of putting this state into one place - into the coordinator. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a2d/d3b/994/a2dd3b994ceae2d50cc46bd1e6da3ed4.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexey Rybak:</font></font></b>  ‚Äî  ,    (.. , - ,   ),   .  ‚Äî     ,        ¬´  ?¬ª.    , ..   ,   ,           -.     ,      . <br><br>       ¬´ ¬ª.    -     ,   .     .   - in-memory . <br><br>   ‚Äî    ,    ‚Äî ,  ,  . <br><br>     .    ,   .    ,  ‚Äî           -,  -. <br><br> <b> :</b> ,     ,    -  ,         ,  , ..    . <br><br> <b> :</b>      ,    ( )   ,      ,       .        . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b8/b26/d30/6b8b26d304efd5e2b4566c5efbbdaca7.png"><br><br> <b> :</b>     . ,   ,     ,  ,          .    ‚Äî     .  Those.   ,   .      ,     .        ,    . <br><br>   ‚Äî       -    ,     ,       ,    .  Those.     ,           , ,      .   ,    ,        .  ,      ,   .      ,      . <br><br>        ,    100    ,            . <br><br>  , , Redis.      ,   . <br><br>     ,   ,     ,  , ..   .        . <br><br>     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/535/326/d5d/535326d5d6739b32ed35aa8f5bf05d0a.png"><br><br>  ? ,      .   ,      .      . <br><br> <b> :</b>   ,   .    <b>-</b>    ,       .    ,     , .    ‚Äî      ‚Äî ,      -  .       . <br><br> <b> :</b>   -.    , ,  ,     .  Those.    -   ,      ,    ,        ,  ,  .       ,    ,   .    ‚Äî  -  ,      ,     ‚Äî    ,   ¬´ ¬ª. <br><br> <b> :</b>      ,   ,  , ,   , ..     ,     . <br><br> <b> :</b>      .     , ,  ,    ,      , ,   , .       ,     .    ,  , . <br><br>   ,   -  ,  , ,        ,   ,       ,   ,   . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0d/085/3d4/a0d0853d45c9efa12e4dbd04f0dc873e.png"><br><br> <b> :</b> ,    ,    ‚Äî .         ,     ? <br><br> <b> :</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most successful implementations are implementations, which somehow manage without automatic or manual resarding, i.e. admins generally do not think about it. Only the developer thinks about it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One approach is ‚Äúupdate is a move‚Äù. The idea that follows is that whenever you change a key, you move it implicitly. Suppose you have a sharding key - this is actually the sharding key and the timestamp. When you change data, you change the timestamp, and you naturally find yourself on another shard. At some point you can close the updates to a certain shard and sooner or later just disable it.</font></font> Those.    ,      . <br><br>           .,     ,     e-mail-.  ,  e-mail ( ),    -.      , ..         ,      timestamp. <br><br>     ,     , ,   .        .  ,    . <br><br>      ,  ,  ,       . <br><br> <b> :</b>   ,   ,       ,   ,       -   ‚Ä¶   - . <br><br> <b> :</b>   ‚Äî ¬´data expiration¬ª. <br><br>     memcached  Badoo.      ,   ,     ‚Äî    . <br><br>       ,       .           -  .      . <br><br> <b> :</b>      ‚Äî   .         ,   ,      -   ,      ,   ,       ,     (,    twitter   )‚Ä¶ <br><br> <b> :</b>   ,   twitter       .      ,       ,      ,      ‚Ä¶  -      ,      ,        ‚Äî  .               . <br><br> <b> :</b>     ,      ,     ,   . <br><br>     .    Badoo, ,  ,     .              . <br><br>        ‚Äî       , ..     Badoo    -  ‚Äî - , - . ,    10 ,        ¬´¬ª.  What are we doing?    ¬´¬ª,   ,        ( )  .      ,    -   ,   - .        ,       ( ,  ,   ,   )   . <br><br>     ¬´    ¬ª.   ,       ,      . <br><br> <b> :</b> ,       ‚Äî        . -   schema-less,       ,      . <br><br> <b> :</b>       ‚Äî    ,    ?      ,         .. <br><br>     ,      .  ‚Äî       ,          .      ,     ,   ,         .   ,      . <br><br> ,  , . <br><br> <b><i>  :</i></b>     timestamp-   .  ‚Äî ?  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I'm looking for some word in my mail, how do I know when she came to me? How to go to the node? </font></font><br><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstantin Osipov:</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Timestamp is used simply to make it automatically moved. This is used in the sharding key, but not in the search. When searching for another index, i.e. when a search query is made, this part is not used. It is used, relatively speaking, with the update. </font></font><br><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Question from the audience:</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But I need an index to look for later. Back. </font></font><br><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexey Rybak:</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Everything is fine with the index. Question: where does all this lie? The problem is that there is no coordination on any particular node. There is a query in parallel from the entire cluster. In fact, this is a choice between two large distributed search architectures. This is a separate topic.</font></font><br><br>   ‚Äî            .      . <br><br>   ‚Äî    ¬´¬ª,   ,    ,    . <br><br> <b><i>  :</i></b> Timestamp    ? <br><br> <b><i> :</i></b> ,  . <br><br> <b><i>  :</i></b> Newdata ‚Äî   .      sharding function? <br><br> <b><i> :</i></b>    sharding function  .    Badoo.     .     ,         .     ,       -,    ,      ,       Badoo ,    ,   y. <br><br>  sharding function  ,         .  ,     ,    ,   ,           . <br><br>   ,     Badoo.   ,        -.         bucket,  bucket     config-.    config     ,   - bucket-  .     ,      bucket-,    ,      .  -     . <br><br>       - , ,     -, .     . <br><br> <b><i>  :</i></b>       , ..     ,   ,  ‚Ä¶  -     ,     ? <br><br> <b><i> :</i></b>  . <br><br> -,    -         ,     .       , ..   ¬´ ¬ª,  -    ‚Äî     ,        ‚Äî  Redis,  Mongo ‚Äî ,   ,      .   ,    .  It works.    Cassandra, Hadoop, Mongo, Redis Cluster.  Tarantool-  . <br><br>     ,    ‚Äî      .   , , ,   ,     ‚Äî    .  - ,    ,        .  Those.   ,    ,     . <br><br> ,  ,   ,        ‚Äî      . <br><br> <b><i> :</i></b> ,  , .      ,    ,        .  ,  -   - ,  -   .    : ¬´   ?      ¬ª.   ,    ,     ¬´ ¬ª,   ,    ‚Äî    ,       - . <br><br>  ,       .  ,   ,    ,     . <br><br><h3>  Contacts </h3><br> <a href="https://habrahabr.ru/users/kostja/" class="user_link">kostja</a> <br> <a href="https://habrahabr.ru/users/fisher/" class="user_link">fisher</a> <br> <a href="https://habrahabr.ru/company/mailru/">  Mail.ru</a> <br> <a href="https://habrahabr.ru/company/badoo/">  Badoo</a> <br><br><blockquote> <font color="gray">  ‚Äî           <a href="http://highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad++</a> .      2016  ‚Äî    HighLoad++   , 7  8 . <br><br>    ‚Äî            HighLoad++.  , <a href="http://www.highload.ru/2016/abstracts"> </a> ‚Äî    :) <br><br></font>  <font color="gray">Also, some of these materials are used by us in an online training course on the development of high-load systems <a href="http://highload.guide/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad.Guide</a> is a chain of specially selected letters, articles, materials, videos.</font>  <font color="gray">Already, in our textbook more than 30 unique materials.</font>  <font color="gray">Get connected!</font> </blockquote></div><p>Source: <a href="https://habr.com/ru/post/313366/">https://habr.com/ru/post/313366/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313344/index.html">How to order and promote a mobile application: digest of useful materials</a></li>
<li><a href="../313346/index.html">Diary of a bug: how I repaired pictures in e-mail</a></li>
<li><a href="../313350/index.html">Lambda and anonymous classes: who eats more</a></li>
<li><a href="../313356/index.html">Add disk space for a Linux ‚Äì server in the Azure Pack Infrastructure cloud, and at the same time, we are working with LVM</a></li>
<li><a href="../313364/index.html">Experience in building and operating large file storage</a></li>
<li><a href="../313370/index.html">Elements of functional programming in C ++: partial application</a></li>
<li><a href="../313372/index.html">Elections 2016. Part 2 is amazing nearby and it is allowed</a></li>
<li><a href="../313374/index.html">JavaScript: includes vs indexOf</a></li>
<li><a href="../313376/index.html">Soviet "Elbrus" - an overview of the architecture</a></li>
<li><a href="../313380/index.html">learnopengl. Lesson 1.5 - Shaders</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>