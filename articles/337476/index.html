<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview of one Russian RTOS, part 4. Useful theory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello colleagues! The next publication from the informal ‚ÄúBook of Knowledge‚Äù of the MAKS RTOS is ready. 

 A request to regular readers to treat me lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overview of one Russian RTOS, part 4. Useful theory</h1><div class="post__text post__text-html js-mediator-article">  Hello colleagues!  The next publication from the informal ‚ÄúBook of Knowledge‚Äù of the MAKS RTOS is ready. <br><br>  A request to regular readers to treat me loyally and not minus for a small repetition of part of the material from the previous article (about stack protection) - here it turned out to be more logical.  And there I have already deleted. <br><br>  General content (published and unpublished articles): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://habrahabr.ru/post/336308/">Part 1. General information</a> <br>  <a href="https://habrahabr.ru/post/336696/">Part 2. Core MAX MAX</a> <br>  <a href="https://habrahabr.ru/post/336944/">Part 3. The structure of the simplest program</a> <br>  Part 4. Useful theory (this article) <br>  <a href="https://habrahabr.ru/post/337974/">Part 5. The first application</a> <br>  <a href="https://habrahabr.ru/post/338682/">Part 6. Thread synchronization tools</a> <br>  <a href="https://habrahabr.ru/post/339498/">Part 7. Means of data exchange between tasks</a> <br>  <a href="https://habrahabr.ru/post/340032/">Part 8. Work with interruptions</a> <br><br><h2>  Some unobvious data details </h2><br><h3>  Some facts about the heap </h3><br>  Many programmers for some reason believe that the new and delete operations are fairly lightweight and simple.  Therefore, the code is often replete with the allocation and release of dynamic memory.  This is more or less acceptable on powerful systems (gigabytes of RAM and gigahertz clock frequency), but with limited resources it can create some problems, especially for programs running 24/7. <br><br><ul><li>  The most obvious problem is <a name="habracut"></a>  address space fragmentation.  In the modern .NET environment, arrays stand out on the heap by reference.  Therefore, at any time, the system can stop the program and do garbage collection.  At the same time, the arrays may well be shifted inside the memory, because they will be accessed by reference, and the reference table will be adjusted.  The C ++ language, which is most often written for microcontrollers (as, in fact, pure C, and assembler) works with arrays through pointers.  How many pointers are in memory - no one knows (the user program has the right to copy them, pass them as arguments, even add and subtract).  So the data can not be moved.  Where an array or structure has been allocated, there they will be fixed until they are deleted.  Well, and then the classic case arises, when, as a result of selections and exemptions, the heap will take, say, this form: <br><br><img src="https://habrastorage.org/web/260/4fe/f6f/2604fef6ff284801bcb8e26cef58bc2f.png" alt="Illustration of a classic case of problems arising from fragmented address space"><br><br>  <b>Fig.</b>  <b>1. Illustration of a classic case of problems arising from the fragmentation of the address space.</b> <br><br>  In this case, the total amount of free memory is more than required for allocation, but it is impossible to allocate it - there is no fragment of the required size.  And defragmentation is impossible; </li><li>  However, there is a more serious problem.  In fact, in order to allocate memory, you should look at a sufficiently large number of tables (we will call it tables, although of course, the implementation of the memory manager can also be on lists) to find a fragment of suitable length (of course, this is a case when the system has been working for a long time, and allocations and deletions often occur - the more fragments, the more table elements should be iterated).  That is, the operation of memory allocation is not so cheap either in speed or resource consumption - the memory allocation table should be stored somewhere; </li><li>  Moreover, the memory allocation operation cannot be attributed to real-time operations.  Its performance is impossible to predict.  It is possible that it will be executed quite quickly (the required record will be found quickly), but it can be - and quite slowly, and real-time systems imply guaranteed speed.  Needless to say, this is not an operating system problem, it is a problem of a poorly designed application program, since its author did not take into account this third-party effect; </li><li>  Finally, stream switching is blocked during memory allocation to ensure thread-safe operation. </li></ul><br>  From all this it follows that memory should be allocated on the heap with extreme caution.  Ideally, this should be done during the initialization phase of the program.  If you want to allocate memory in the course of work, it is best to do it as rarely as possible.  Do not get involved in the constant allocation and release.  It is also worth fearing operations that allocate memory implicitly, within themselves.  It distorts me from a code of this type, especially when you consider that it is executed in a system where 50 kilobytes of RAM are allocated to everything about everything: <br><br><pre><code class="cpp hljs">String output; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cnt &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) output = <span class="hljs-string"><span class="hljs-string">','</span></span>; output += <span class="hljs-string"><span class="hljs-string">"{\"type\":\""</span></span>; output += (entry.isDirectory()) ? <span class="hljs-string"><span class="hljs-string">"dir"</span></span> : <span class="hljs-string"><span class="hljs-string">"file"</span></span>; output += <span class="hljs-string"><span class="hljs-string">"\",\"name\":\""</span></span>; output += entry.name(); output += <span class="hljs-string"><span class="hljs-string">"\""</span></span>; output += <span class="hljs-string"><span class="hljs-string">"}"</span></span>;</code> </pre> <br>  From my point of view, it is much calmer if the code has a similar look (although it is a little less beautiful, but it doesn‚Äôt mind the memory allocation and freeing functions): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> xml [<span class="hljs-number"><span class="hljs-number">768</span></span>]; ... xml[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cnt &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">strcat</span></span> (xml,<span class="hljs-string"><span class="hljs-string">","</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">strcat</span></span> (xml,<span class="hljs-string"><span class="hljs-string">"{\"type\":\""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entry.isSubDir()) { <span class="hljs-built_in"><span class="hljs-built_in">strcat</span></span> (xml,<span class="hljs-string"><span class="hljs-string">"dir"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">strcat</span></span> (xml,<span class="hljs-string"><span class="hljs-string">"file"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">strcat</span></span> (xml,<span class="hljs-string"><span class="hljs-string">"\",\"name\":\""</span></span>); entry.getName(xml+<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(xml),<span class="hljs-number"><span class="hljs-number">255</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">strcat</span></span> (xml,<span class="hljs-string"><span class="hljs-string">"\"}"</span></span>);</code> </pre><br><br>  This code is specially made ‚Äúin the forehead‚Äù in order to clearly show that after its addition, there was no danger of fragmentation of the address space, and it would also be clearly seen what had been replaced.  But to perfection he is still far away.  To begin with, for the sake of clarity, the principles of OOP are violated in it, and we continue with the fact that the strcat function each time iterates over the receiver string from the beginning, which negatively affects the speed.  Theoretically, the receiver string may also overflow (although in this particular example, overflow protection is in the entry.getName function). <br><br>  We give the option proposed by <a href="https://habrahabr.ru/users/comdiv/" class="user_link">comdiv</a> , devoid of these shortcomings. <br><br>  We describe a class for working with a static string, containing, among other things, an indication of the current length, which will allow us not to start inspecting the string every time from the beginning.  For simplicity, we implement only the "+ =" operator in this class.  It is on this class that the semantic load of the example will fall. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticString</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* m_buf; <span class="hljs-comment"><span class="hljs-comment">//    int m_size; //    int m_len; //    public: StaticString (char* buf,int size) { _ASSERT(NULL != buf); _ASSERT(size &gt; 0); m_buf = buf; //     buf[0] = '\0'; //  m_size = size; //   m_len = 0; //    -  } StaticString&amp; operator+=(const char *str) { int i = 0; //  ,         while ((m_len &lt; m_size - 1) &amp;&amp; (str[i] != '\0')) { //    m_buf[m_len++] = str[i++]; } // ,    -   m_buf[m_len] = '\0'; return *this; } };</span></span></code> </pre> <br><br>  And the main code will again take on a familiar form, differing only in the declaration of the output variable, which "wraps" the xml line: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> xml [<span class="hljs-number"><span class="hljs-number">768</span></span>]; ... <span class="hljs-function"><span class="hljs-function">StaticString </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xml,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(xml))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cnt &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) output += <span class="hljs-string"><span class="hljs-string">','</span></span>; output += <span class="hljs-string"><span class="hljs-string">"{\"type\":\""</span></span>; output += (entry.isDirectory()) ? <span class="hljs-string"><span class="hljs-string">"dir"</span></span> : <span class="hljs-string"><span class="hljs-string">"file"</span></span>; output += <span class="hljs-string"><span class="hljs-string">"\",\"name\":\""</span></span>;</code> </pre><br><br>  But due to the use of another class, the danger of fatal fragmentation of the address space has passed.  And unlike the ‚Äúfrontal‚Äù solution, the speed has been optimized and the danger of a buffer overflow has been eliminated. <br><br>  It is possible to improve the class for a long time (now only one version of the operator "+ =" is covered in it), but this is more likely related to programming guidelines in general rather than to the manual for the RTOS MAKS.  In the meantime, I‚Äôll just note that whichever of the replacement options (‚Äúin a hurry, but visual‚Äù or ‚Äúcorrect, but more complex‚Äù) is chosen, they illustrate the same idea: <br><br>  <font color="#cc0000"><b>If you can refuse the constant call to new / delete, then it is better to do it.</b></font> <br><br><h3>  Short about stack variables </h3><br>  I have often met programmers who do not know exactly how local variables are implemented in C and C ++ languages.  At the same time, those programmers are well aware of what the stack is, as well as how the contents of the registers (which will be corrupted) and the return addresses from the subroutines are saved (though in the ARM architecture, the return address falls into the LR register).  Perhaps this is due to the fact that all these programmers graduated from the same university (which is no secret, I finished it myself, and 10 years ago I also didn‚Äôt fully imagine what a stack frame is.)  Nevertheless, it will be useful to briefly describe how these mysterious local variables are stored.  At the end of the section, intrigue will be revealed on how this applies to the MAX RTOS. <br><br>  So.  It turns out that the stack is not only used to store return addresses (though not from ARM) and temporarily save the contents of the processor registers.  The stack is also used to store local variables. <br><br>  Let's see what a typical preamble of a function looks like, which has so many of these local variables that they do not fit in registers. <br><br> <code>;;;723 static void _CopyRect(int LayerIndex, int x0, int y0, int x1, int y1, int xSize, int ySize) { <br> 000000 e92d4ff0 PUSH {r4-r11,lr} <br> 000004 b087 SUB sp,sp,#0x1c <br></code> <br>  The first instruction is PUSH - everything is clear with it.  It just keeps the registers on the stack so that they can be restored before exiting.  And what is this subtraction of the constant 0x1C from SP?  And this is just the allocation of the stack frame.  It is known from the computer science course that a stack is such a thing that is not addressed directly, but relative to the pointer to the top of the stack.  Consider graphically what these two lines will do. <br><br><img src="https://habrastorage.org/web/45b/c30/0da/45bc300da88a437c9c8fab0a954b323d.png" alt="Fig. 2. Effect of function preamble on stack"><br><br>  <b>Fig.</b>  <b>2. Effect of function preamble on stack</b> <br><br>  What is this stack frame?  It's simple.  Its size is such that all local variables of functions fit in it (except those that the optimizer puts in registers).  The size of the stack frame is calculated by the compiler.  Each variable gets its offset relative to the beginning of the frame, and the call to them goes something like this: <br><br> <code>;;;728 <font color="#cc0000">BufferSize = _GetBufferSize(LayerIndex);</font> <br> 000016 4620 MOV r0,r4 <br> 000018 f7fffffe BL _GetBufferSize <br> 00001c 9006 STR r0,[sp,#0x18] <br></code> <br>  Obviously, the BufferSize variable is offset from the beginning of the frame by 0x18 bytes. <br><br> <code>;;;730 <font color="#cc0000">SrcAddr = Offset + (y0 * _xSize[LayerIndex] + x0) * _BytesPerPixel[LayerIndex];</font> <br> 000030 4816 LDR r0,|L8.140| <br> 000032 f8500024 LDR r0,[r0,r4,LSL #2] <br> 000036 fb076000 MLA r0,r7,r0,r6 <br> 00003a 4915 LDR r1,|L8.144| <br> 00003c 5d09 LDRB r1,[r1,r4] <br> 00003e fb005001 MLA r0,r0,r1,r5 <br> 000042 9005 STR r0,[sp,#0x14] <br></code> <br>  And the variable SrcAddr - offset 0x14 <br><br>  Well, and so on.  The variable LayerIndex is explicitly placed not in the stack frame, but in the R4 register. <br><br>  Of course, at the end of its work, the compiler quickly restores everything (and also puts the former contents of LR in the PC, thereby moving to the return address) <br><br> <code>00007e b007 ADD sp,sp,#0x1c <br> 000080 e8bd8ff0 POP {r4-r11,pc} <br></code> <br>  From all this, some things become clear: <br><br><ul><li>  It is clear why local variables are visible only inside the function.  They are addressed relative to the SP register, and in nested functions (as well as in functions of a higher level) SP will be different. </li><li>  It is clear why the KEIL development environment debugger does not display some variables - for some reason, developers are not able to display the contents of variables placed in registers. </li><li>  It is clear why going beyond the bounds of an array placed in local variables can lead to a complete inoperability of the program - the return address from the function is stored in the same stack and may well be corrupted. </li><li>  It is clear that recursive functions spend a stack not only on return addresses, but also on stack frames.  The more local variables, the more stack is spent on recursive calls.  This is best avoided when working in conditions of limited memory. </li></ul><br>  <font color="#cc0000"><b>The most important conclusion is that after some workouts, the programmer can begin to figure out how much stack the task will need (based on the estimates of the deepest nesting of the mutual function call and the set of their local variables).</b></font>  <font color="#cc0000"><b>Windows defaults to allocating a megabyte of stack to each thread.</b></font>  <font color="#cc0000"><b>When working with microcontrollers, we are talking about kilobytes.</b></font>  <font color="#cc0000"><b>Moreover, these kilobytes are allocated on the heap, so they reduce the amount of free dynamic memory and global variables, so knowledge of physics is not just useful, but often vital.</b></font> <br><br><h4>  Protection of task stack from overflow </h4><br>  When creating a task, the stack size for it is determined.  After this, the size cannot be dynamically changed.  If it was chosen unsuccessfully (in the course of the work a large call nesting occurred, or the number of local variables turned out to be high, which could have happened while accompanying the program), the data can jump out of the selected limits, damaging the data in other tasks stacks, on the heap, or other data and doing other unpredictable actions.  Such a situation is desirable to identify and inform the developer that it requires elimination. <br><br>  The ideal way to prevent such a situation would be to check at the compiler level, without the participation of the OS, but unfortunately, such a mechanism at least creates a large overhead.  The main task for controllers is not to check the programmer, but to make control.  With a clock frequency of around one hundred and two hundred megahertz (and sometimes dozens of megahertz), this method of control is already unacceptable. <br><br>  At the OS level, you can also monitor the stack for overflow.  The MAX RTOS uses the following protection methods: <br><br><ul><li>  Checking the current position of the stack pointer when switching tasks.  Almost no effect on performance, but has low reliability.  First, the destruction of the stack has already happened, and secondly - during the system clock, the program could not only enter the function that caused the overflow, but also exit it, which means that the pointer could have time to return to the allowed range. </li><li>  If the stack size is set to be larger than the minimum, then one word is automatically added to it at the top, where the magic number is written - 32-bit number of a random type, which is unlikely to occur when the program is running.  If the stack overflows, this number will be overwritten by the application data, which will almost certainly make it possible to fix the fact of stack overflow even after the pointer returns to the workspace. </li><li>  In the case when the processor contains an MPU (Memory Protection Unit), immediately beyond the stack boundary is placed the minimum size of the memory area with access protection.  This is the most advanced method of control, as with any access to a protected area, a hardware interrupt will occur.  It should, however, be remembered that in some cases, the protection zone may not be touched.  For example, if a part of local variables that fall into this particular zone is reserved but not used.  Protection is made for self-control and should not go to the detriment of the main tasks. </li></ul><br>  Details for working with stack protection can be found among the constants specified in the Task class (in the MaksTask.h file).  Studying the comments to these constants, one can understand the specific values ‚Äã‚Äãof the parameters ‚Äúminimum stack‚Äù, ‚Äúprotected area‚Äù, etc.  If desired, these parameters can be changed.  It should only be remembered that the size of the protected area must be a power of two. <br><br>  Everything, finally the necessary minimum of the theory, without which it is impossible to begin practical experiments, is over. <br><br>  In general, the authors usually first describe everything about the subject area, and already in the last chapter (or in general, in the appendix) they give information about the practical work.  Apparently, they believe that readers will first remember everything, and only then will begin experiments.  It would be naive to assume that the average person will remember the whole mass of knowledge thrown at him.  It is more convenient to try all the knowledge gradually. <br><br>  Therefore, before you start stuffing the reader with further theory, it is worth a little practice.  But for this you need to consider how to get started with the MAKS RTOS.  Let's assume that the reader is familiar with how to compile and run the program under the microcontroller he has, otherwise the text will be heavily overloaded. <br><br>  If this is not the case, then I highly recommend that you familiarize yourself with the wonderful guides from the Keil development environment for working with ST debugging boards (unfortunately, in English, but much is also clear from the figures): <br><br>  <a href="http://www.keil.com/appnotes/files/apnt_253.pdf">http://www.keil.com/appnotes/files/apnt_253.pdf</a> <br><br>  <a href="http://www.keil.com/appnotes/files/apnt_261.pdf">http://www.keil.com/appnotes/files/apnt_261.pdf</a> <br><br>  And in the <a href="https://habrahabr.ru/post/337974/">next article</a> we will begin the first practical experience. </div><p>Source: <a href="https://habr.com/ru/post/337476/">https://habr.com/ru/post/337476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337466/index.html">Data Science Week 2017: The market is becoming more mature</a></li>
<li><a href="../337468/index.html">Creating an IT self-service portal using the example of MS SCCM and ServiceNow integration. Part 2</a></li>
<li><a href="../337470/index.html">Don't growl at a freelancer</a></li>
<li><a href="../337472/index.html">Bug hunters: ASCON testers pass the test with tricky questions</a></li>
<li><a href="../337474/index.html">How do you call a virus?</a></li>
<li><a href="../337480/index.html">MBLTdev 2017: first speakers, latest tickets at a bargain price</a></li>
<li><a href="../337482/index.html">Monetization of applications in iOS 11: we target embedded purchases in the new App Store</a></li>
<li><a href="../337484/index.html">How does the video processor</a></li>
<li><a href="../337488/index.html">Hibernate Inheritance: Choosing a Strategy</a></li>
<li><a href="../337490/index.html">On the culture of development in groups of programmers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>