<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Go load test, version 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Do not reach the hands to rewrite the go-meter . Increase productivity, gain more control over the process and bring it closer to wrk . Ideally, you w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Go load test, version 2</h1><div class="post__text post__text-html js-mediator-article">  Do not reach the hands to rewrite the <a href="http://habrahabr.ru/post/187212/">go-meter</a> .  Increase productivity, gain more control over the process and bring it closer to <a href="https://github.com/wg/wrk">wrk</a> .  Ideally, you want to see an easily and conveniently expandable alternative.  Yes, <a href="https://github.com/wg/wrk">wrk</a> recently introduced support for <a href="https://github.com/wg/wrk/commit/c6679dc58a72dd468667d5e43e55aad4b585d621">Lua scripts</a> that solve many inconveniences, but there are also some unpleasant nuances, for example, it will not be possible to collect advanced statistics, because the statistics output methods work only on the first stream and on the collected data on other access streams no, so it comes back again to the fact that to understand the source code and do it for yourself, but this is not a trivial task.  And so, we are preparing a load test for Go, with buns.  Who cares, I ask under the cat. <br><a name="habracut"></a><br><h5>  What is and what is needed </h5><br>  From the beginning we will understand what we need: <br>  - sending GET / POST / PUT / DELETE requests <br>  - brute force URL and POST body <br>  - control over open connections <br>  - flow control <br>  - indication of test duration <br>  - restrictions on the maximum number of requests per second <br>  - the ability to exclude the first few seconds from the statistics to avoid distortion when the HTTP server is warming up <br><br><h5>  Plan </h5><br>  - connection pool <br>  - simple Request / Response <br>  - statistics <br>  - profit <br><div class="spoiler">  <b class="spoiler_title">thinking out loud</b> <div class="spoiler_text">  If you need to control connections, the standard http.Client does not suit us (and it‚Äôs a big one for this task), it knows too much because of what performance suffers.  Since we have several worker threads meant for sending requests, we need a pool of connections that they will share with each other.  It does not make sense for a walker to wait for a response from the server, we just lose precious time on it.  How to evaluate passing traffic?  Standard http.Request, http.Respose do not allow such information, it will not work, it means you need to implement a simple Request / Response, which will give us everything we need.  Collect raw data and at the end of their aggregate fail, because the memory is not rubber.  We collect the statue on the fly. <br></div></div><br><br><h4>  Go </h4><br>  The pool of connections is written on the basis of a limited channel.  It will look like a simple pool of objects, took an object from the channel, worked, put it back. <br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Connection <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { conn net.Conn manager *ConnectionManager } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ConnectionManager <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { conns <span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> *Connection config *Config } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewConnectionManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result *ConnectionManager)</span></span></span></span> { result = &amp;ConnectionManager{config: config, conns: <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> *Connection, config.Connections)} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; config.Connections; i++ { connection := &amp;Connection{manager: result} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> connection.Dial() != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { ConnectionErrors++ } result.conns &lt;- connection } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *ConnectionManager)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Connection</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;-this.conns } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Connection)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> this.IsConnected() { this.Disconnect() } conn, err := net.Dial(<span class="hljs-string"><span class="hljs-string">"tcp4"</span></span>, this.manager.config.Url.Host) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { this.conn = conn } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Connection)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Disconnect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { this.conn.Close() this.conn = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Connection)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsConnected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.conn != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Connection)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Return</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { this.manager.conns &lt;- this }</code> </pre> <br>  Request / Response here you can read the source Go, see how it is implemented there, and make a simplified analogy, the main difference will be the ability to get the traffic volume of each request / response and save valuable time. <br><div class="spoiler">  <b class="spoiler_title">Request</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Request <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Method <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> URL *url.URL Header <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>][]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Body io.Reader ContentLength <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> Host <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> BufferSize <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req *Request)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { bw := &amp;bytes.Buffer{} fmt.Fprintf(bw, <span class="hljs-string"><span class="hljs-string">"%s %s HTTP/1.1\r\n"</span></span>, valueOrDefault(req.Method, <span class="hljs-string"><span class="hljs-string">"GET"</span></span>), req.URL.RequestURI()) fmt.Fprintf(bw, <span class="hljs-string"><span class="hljs-string">"Host: %s\r\n"</span></span>, req.Host) userAgent := <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> req.Header != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ua := req.Header[<span class="hljs-string"><span class="hljs-string">"User-Agent"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(ua) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { userAgent = ua[<span class="hljs-number"><span class="hljs-number">0</span></span>] } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> userAgent != <span class="hljs-string"><span class="hljs-string">""</span></span> { fmt.Fprintf(bw, <span class="hljs-string"><span class="hljs-string">"User-Agent: %s\r\n"</span></span>, userAgent) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> req.Method == <span class="hljs-string"><span class="hljs-string">"POST"</span></span> || req.Method == <span class="hljs-string"><span class="hljs-string">"PUT"</span></span> { fmt.Fprintf(bw, <span class="hljs-string"><span class="hljs-string">"Content-Length: %d\r\n"</span></span>, req.ContentLength) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> req.Header != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key, values := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> req.Header { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key == <span class="hljs-string"><span class="hljs-string">"User-Agent"</span></span> || key == <span class="hljs-string"><span class="hljs-string">"Content-Length"</span></span> || key == <span class="hljs-string"><span class="hljs-string">"Host"</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, value := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> values { fmt.Fprintf(bw, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, key, value) } } } io.WriteString(bw, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> req.Method == <span class="hljs-string"><span class="hljs-string">"POST"</span></span> || req.Method == <span class="hljs-string"><span class="hljs-string">"PUT"</span></span> { bodyReader := bufio.NewReader(req.Body) _, err := bodyReader.WriteTo(bw) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } } req.BufferSize = <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(bw.Len()) _, err := bw.WriteTo(w) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Response</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Response <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Status <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> StatusCode <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Header <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>][]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ContentLength <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> BufferSize <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *bufio.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*Response, error)</span></span></span></span> { tp := textproto.NewReader(r) resp := &amp;Response{} line, err := tp.ReadLine() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } f := strings.SplitN(line, <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) resp.BufferSize += <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(f) + <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(f) &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"Response Header ERROR"</span></span>) } reasonPhrase := <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(f) &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> { reasonPhrase = f[<span class="hljs-number"><span class="hljs-number">2</span></span>] } resp.Status = f[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-string"><span class="hljs-string">" "</span></span> + reasonPhrase resp.StatusCode, err = strconv.Atoi(f[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"malformed HTTP status code"</span></span>) } resp.Header = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>][]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { line, err := tp.ReadLine() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"Response Header ERROR"</span></span>) } resp.BufferSize += <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(line) + <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(line) == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { f := strings.SplitN(line, <span class="hljs-string"><span class="hljs-string">":"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) resp.Header[f[<span class="hljs-number"><span class="hljs-number">0</span></span>]] = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(resp.Header[strings.TrimSpace(f[<span class="hljs-number"><span class="hljs-number">0</span></span>])], strings.TrimSpace(f[<span class="hljs-number"><span class="hljs-number">1</span></span>])) } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cl := resp.Header[<span class="hljs-string"><span class="hljs-string">"Content-Length"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(cl) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { i, err := strconv.ParseInt(cl[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { resp.ContentLength = i } } buff := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, resp.ContentLength) r.Read(buff) resp.BufferSize += <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(resp.ContentLength) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resp, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br></div></div><br>  In order for our threads to turn off when the testing time is over, let's make a channel for shutting down threads and a channel through which each thread will report that it has completed its work correctly. <br><pre> <code class="go hljs">WorkerQuit := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, *_threads) WorkerQuited := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, *_threads)</code> </pre><br>  check the time, and also wait for Ctr + C (SIGTERM) so that our application can complete the testing at any time <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//Start Ctr+C listen signalChan := make(chan os.Signal, 1) signal.Notify(signalChan, os.Interrupt, syscall.SIGTERM) //Wait timers or SIGTERM select { case &lt;-time.After(config.Duration): case &lt;-signalChan: } for i := 0; i &lt; config.Threads; i++ { config.WorkerQuit &lt;- true } //Wait for threads complete for i := 0; i &lt; config.Threads; i++ { &lt;-config.WorkerQuited }</span></span></code> </pre><br>  Now let's take a look at the worker itself: to limit the number of requests per second, we take for each its share of the total number, 4 times per second, we will increment the counter and wait for either the connection to be released or shutdown <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewThread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config *Config)</span></span></span></span> { timerAllow := time.NewTicker(time.Duration(<span class="hljs-number"><span class="hljs-number">250</span></span>) * time.Millisecond) allow := <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span>(config.MRQ / <span class="hljs-number"><span class="hljs-number">4</span></span> / config.Threads) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> config.MRQ == <span class="hljs-number"><span class="hljs-number">-1</span></span> { allow = <span class="hljs-number"><span class="hljs-number">2147483647</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> allow &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> { allow = <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionErrors <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> currentAllow := allow <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-comment"><span class="hljs-comment">//        case &lt;-timerAllow.C: currentAllow = allow //   case connection := &lt;-config.ConnectionManager.conns: currentAllow-- //    -     if currentAllow &lt; 0 { connection.Return() } else { //  req := getRequest(config.Method, config.Url, config.Source.GetNext()) //      if config.Reconnect &amp;&amp; connection.IsConnected() { connection.Disconnect() } //  ,     if !connection.IsConnected() { if connection.Dial() != nil { connectionErrors++ } } //    ,    if connection.IsConnected() { go writeSocket(connection, req, config.RequestStats) } else { connection.Return() } } //  case &lt;-config.WorkerQuit: //    atomic.AddInt32(&amp;ConnectionErrors, connectionErrors) //  config.WorkerQuited &lt;- true return } } }</span></span></code> </pre><br>  As soon as the connection is released, we form the next request and start sending it asynchronously, so in a circle until the time runs out.  After the request is sent and the response is read, the connection is returned to the pool, and the thread picks it up again. <br><div class="spoiler">  <b class="spoiler_title">Submit request</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(connection *Connection, req *http.Request, read </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *RequestStats)</span></span></span></span> { result := &amp;RequestStats{} <span class="hljs-comment"><span class="hljs-comment">//          defer func() { connection.Return() read &lt;- result }() now := time.Now() conn := connection.conn bw := bufio.NewWriter(conn) //  err := req.Write(bw) if err != nil { result.WriteError = err return } err = bw.Flush() if err != nil { result.WriteError = err return } //  res, err := http.ReadResponse(bufio.NewReader(conn)) if err != nil { result.ReadError = err return } //   result.Duration = time.Now().Sub(now) result.NetOut = req.BufferSize result.NetIn = res.BufferSize result.ResponseCode = res.StatusCode req.Body = nil }</span></span></code> </pre><br></div></div><br>  It remains the case for small, to collect statistics from the objects of RequestStats and arrange it <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//  type StatsSource struct { Readed int64 Writed int64 Requests int Skiped int Min time.Duration Max time.Duration Sum int64 Codes map[int]int DurationPercent map[time.Duration]int ReadErrors int WriteErrors int Work time.Duration } //    type StatsSourcePerSecond struct { Readed int64 Writed int64 Requests int Skiped int Sum int64 } //  func StartStatsAggregator(config *Config) { allowStore := true allowStoreTime := time.After(config.ExcludeSeconds) if config.ExcludeSeconds.Seconds() &gt; 0 { allowStore = false } verboseTimer := time.NewTicker(time.Duration(1) * time.Second) if config.Verbose { fmt.Printf("%s %s %s %s %s %s\n", newSpancesFormatRightf("Second", 10, "%s"), newSpancesFormatRightf("Total", 10, "%s"), newSpancesFormatRightf("Req/sec", 10, "%s"), newSpancesFormatRightf("Avg/sec", 10, "%s"), newSpancesFormatRightf("In/sec", 10, "%s"), newSpancesFormatRightf("Out/sec", 10, "%s"), ) } else { verboseTimer.Stop() } source = StatsSource{ Codes: make(map[int]int), DurationPercent: make(map[time.Duration]int), } perSecond := StatsSourcePerSecond{} start := time.Now() for { select { //    case &lt;-verboseTimer.C: if perSecond.Requests-perSecond.Skiped &gt; 0 &amp;&amp; config.Verbose { //    avgMilliseconds := perSecond.Sum / int64(perSecond.Requests-perSecond.Skiped) avg := time.Duration(avgMilliseconds) * time.Millisecond //  fmt.Printf("%s %s %s %s %s %s\n", newSpancesFormatRightf(roundToSecondDuration(time.Now().Sub(start)), 10, "%v"), newSpancesFormatRightf(source.Requests, 10, "%d"), newSpancesFormatRightf(perSecond.Requests, 10, "%d"), newSpancesFormatRightf(avg, 10, "%v"), newSpancesFormatRightf(Bites(perSecond.Readed), 10, "%s"), newSpancesFormatRightf(Bites(perSecond.Writed), 10, "%s"), ) } //  perSecond = StatsSourcePerSecond{} //          case &lt;-allowStoreTime: allowStore = true //    case res := &lt;-config.RequestStats: //   -   ,      if res.ReadError != nil { source.ReadErrors++ continue } else if res.WriteError != nil { source.WriteErrors++ continue } //  source.Requests++ perSecond.Requests++ perSecond.Readed += res.NetIn perSecond.Writed += res.NetOut source.Readed += res.NetIn source.Writed += res.NetOut //      HTTP  source.Codes[res.ResponseCode]++ if !allowStore { perSecond.Skiped++ source.Skiped++ continue } //    sum := int64(res.Duration.Seconds() * 1000) source.Sum += sum perSecond.Sum += sum //     if source.Min &gt; res.Duration { source.Min = roundDuration(res.Duration) } if source.Max &lt; res.Duration { source.Max = roundDuration(res.Duration) } //        10  duration := time.Duration(res.Duration.Nanoseconds()/10000000) * time.Millisecond * 10 source.DurationPercent[duration]++ //   case &lt;-config.StatsQuit: //    source.Work = time.Duration(time.Now().Sub(start).Seconds()*1000) * time.Millisecond if config.Verbose { s := "" for { if len(s) &gt;= 61 { break } s += "-" } fmt.Println(s) } //  config.StatsQuit &lt;- true return } } }</span></span></code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Summing up </h5><br>  I will omit how to parse the launch arguments and format the statistics output, since this is not interesting.  And now let's check what we got.  For the sample, set the wrk on the Node.js cluster <br><pre> <code class="bash hljs">% ./wrk -c 21 -t 7 -d 30s -L http://localhost:3001/index.html Running 30s <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> @ http://localhost:3001/index.html 7 threads and 21 connections Thread Stats Avg Stdev Max +/- Stdev Latency 1.09ms 6.55ms 152.07ms 99.63% Req/Sec 5.20k 3.08k 14.33k 58.75% Latency Distribution 50% 490.00us 75% 0.89ms 90% 1.83ms 99% 5.04ms 1031636 requests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 30.00s, 153.48MB <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> Requests/sec: 34388.25 Transfer/sec: 5.12MB</code> </pre><br>  and the same on go with GOMAXPROCS = 1 <br><pre> <code class="bash hljs">% ./go-meter -t 7 -c 21 -d 30s -u http://localhost:3001/index.html Running <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> threads: 7, connections: 21 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 30s GET http://localhost:3001/index.html Stats: Min Avg Max Latency 0 0 83ms 843183 requests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 30s, net: <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 103MB, out 62MB HTTP Codes: 200 100.00% Latency: 0 99.99% 10ms - 80ms 0.01% Requests: 28106.10/sec Net In: 27MBit/sec Net Out: 17MBit/sec Transfer: 5.5MB/sec</code> </pre><br>  We get 28106 against 34388 requests per second - this is about 20% less compared to pure C + event loop + nio.  Pretty good, when changing GOMAXPROCS, there is almost no difference, since Node.js selects most of the CPU time. <br>  Minuses: <br>  - loss of 20% performance, you can try to simplify Request / Response, can give a little performance <br>  - not yet support HTTPS <br>  - it is still impossible to specify custom HTTP headers and timeout <br><br>  All source code here - <a href="https://github.com/a696385/go-meter">Github</a> <br><br>  How to use <br><pre> <code class="bash hljs">% go get github.com/a696385/go-meter % <span class="hljs-variable"><span class="hljs-variable">$GOPATH</span></span>/bin/go-meter -h</code> </pre><br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/203328/">https://habr.com/ru/post/203328/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../203318/index.html">Spring Security Overview</a></li>
<li><a href="../203320/index.html">Query optimization. Basics of EXPLAIN in PostgreSQL</a></li>
<li><a href="../203322/index.html">Development of cross-platform modular applications in C ++ with the library wxWidgets</a></li>
<li><a href="../203324/index.html">Competition for the creation of an instant messenger for Windows Phone</a></li>
<li><a href="../203326/index.html">John Carmack leaves id Software</a></li>
<li><a href="../203334/index.html">Learning to write in the information style</a></li>
<li><a href="../203338/index.html">Stealing a password from your Gmail account</a></li>
<li><a href="../203340/index.html">What do you think of StarlingJS?</a></li>
<li><a href="../203344/index.html">Python-digest # 3. News, interesting projects, articles and interviews [November 16, 2013 - November 23, 2013]</a></li>
<li><a href="../203346/index.html">We create the first application on the NancyFX part five. Application Testing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>