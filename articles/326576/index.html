<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Test Data Generator for C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When unit-testing the code, sooner or later the question of test data arises. And if in one case it is enough just a few hard-wired variables, in othe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Test Data Generator for C ++</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/761/14f/453/76114f45323147bc9cec24372b1ddd55.jpeg" alt="image"></p><br><p>  When unit-testing the code, sooner or later the question of test data arises.  And if in one case it is enough just a few hard-wired variables, in other cases some large and random data are needed.  In a managed world, there are no problems with generating custom types (take the same Autofixture), but the C ++ world often causes pain and suffering (correct me if this is not the case).  Not so long ago, I became acquainted with the remarkable library boost :: di, and under its influence, I began to ripen the idea of ​​a library that would allow C ++ programmers to generate custom data types clogged with random values, and this would not require their prior description.  It turned out something like: </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dummy_member</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dummy</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dummy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dummy_member val, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">val_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: dummy_member val_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> c_; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> d = datagen::random&lt;dummy&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  → <a href="https://github.com/ukhegg/datagen">Link to the code</a> .  Header-only library, C ++ 14.  I ask all interested under the cat. </p><a name="habracut"></a><br><h2 id="osnovnye-vozmozhnosti-biblioteki">  Main features of the library </h2><br><ul><li>  Generating built-in types </li><li>  Generating custom types (== not built-in) </li><li>  Limiters on multiple generated values </li></ul><br><h3 id="generaciya-vstroennyh-tipov">  Generating built-in types </h3><br><p>  The generation of built-in types (char, wchar_t, etc.) is naturally supported.  In this case, integer types are generated simply as a set of bits, and float and double - as the sum of a random integer (int32_t and int64_t, respectively) and random values ​​in the range from -1 to 1. To generate a bool value, a comparison of two random integers is used. </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"The answer to the question of everything is:"</span></span> &lt;&lt; datagen::random&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><h3 id="generaciya-polzovatelskih-tipov">  Generate custom types. </h3><br><p>  To generate custom types, the same idea was used as the basis for boost :: di (thanks to its author), namely the possibility of writing the universal type any_type, which is implicitly convertible into any other type (with rare exceptions).  Adding a LITTLE template, it turned out a piece that generates custom types using the following tools: </p><br><ol><li>  User defined generation algorithm. </li><li>  Generation based on a public constructor with the maximum number of parameters.  Everything is as in the example at the beginning of the article ( <code>struct dymmy</code> ). </li><li>  Generation based on {} initialization.  Everything is the same as in the first example ( <code>struct dummy_member</code> ). </li></ol><br><p>  To generate objects based on a user-defined procedure, the pattern must be partially or fully specialized. </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">datagen</span></span></span><span class="hljs-class">:</span></span>:value_generation_algorithm&lt;TType&gt; { <span class="hljs-function"><span class="hljs-function">TType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_random</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(random_source_base&amp;)</span></span></span></span>; };</code> </pre> <br><p>  This adds the ability to take out some type generation parameters as members of this class, which in turn allows us to influence the type generation.  For example, the algorithm for generating std std looks like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> datagen{ <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Traits</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Allocator</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value_generation_algorithm</span></span></span><span class="hljs-class">&lt;std::basic_string&lt;CharType, Traits, Allocator&gt;&gt;{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::basic_string&lt;CharType, Traits, Allocator&gt;; <span class="hljs-keyword"><span class="hljs-keyword">string_t</span></span> get_random(random_source_base&amp; r_source){...}; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> min_size{<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_size{<span class="hljs-number"><span class="hljs-number">30</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::basic_string&lt;CharType&gt; alphabet{<span class="hljs-string"><span class="hljs-string">"abcd...6789"</span></span>}; }; }</code> </pre> <br><h3 id="ogranichiteli-na-mnozhestvo-generiruemyh-znacheniy">  Limiters on multiple generated values </h3><br><p>  The library supports limiters on generated values, for example: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"The answer to the question of everything is:"</span></span> &lt;&lt; random&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(between(<span class="hljs-number"><span class="hljs-number">42</span></span>,<span class="hljs-number"><span class="hljs-number">42</span></span>)) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  There are <em>2 types of</em> limiters: </p><br><ol><li>  Limiters on the generation algorithm.  With their help, you can change the values ​​of parameters in the class <code>value_generation_algorithm&lt;T&gt;</code> . </li><li>  Limiters (rather, correctors) on the already generated value. </li></ol><br><p>  With this, they can be used in <em>2 ways</em> : </p><br><ol><li>  Passing them as a parameter to the random function, as in the example above.  In this case, they will be applied only to the current algorithm / value. </li><li>  Creating <code>scoped_limit</code> based on <code>scoped_limit</code> and applying it to a set of types.  Then the limiter is applied to all of the specified types for the entire depth of the generated type tree throughout the life of the scoped_limit. </li></ol><br><p>  To create custom constraints, you must declare a delimiter structure / class and implement one or both of the functions: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dummy_algorithm_limit</span></span></span><span class="hljs-class">{</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dummy_value_limit</span></span></span><span class="hljs-class">{</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> datagen{ <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> limits { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adjust_algorithm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(random_source_base&amp;, dummy_algorithm_limit </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; l, value_generation_algorithm&lt;dummy&gt;&amp; a)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      dummy } void adjust_value(random_source_base&amp;, dummy_value_limit const&amp; l, dummy&amp; a){ //     dummy } } }</span></span></code> </pre> <br><p>  Restrictions apply in the following order: </p><br><ol><li>  scoped_limit for algorithms </li><li>  parametric algorithm limiters <br>  <em>here is the generation of the object tree</em> </li><li>  scoped_limit for values </li><li>  parametric value limiters </li></ol><br><h3 id="obschaya-informaciya">  general information </h3><br><p>  The source of entropy in the library is the class random_source_impl, using <code>&lt;random&gt;</code> .  But it is possible to override this by providing a specialization of the structure <code>random_source_instance&lt;int&gt;</code> at the compilation stage. <br>  For today, the generation of the following containers from stl has been implemented (actually what I need in my work): </p><br><ul><li>  std :: array </li><li>  std :: map </li><li>  std :: set </li><li>  std :: string </li><li>  std :: vector </li></ul><br><p>  pairs of types from boost: </p><br><ul><li>  boost :: asio :: ip :: address (v4, v6) </li><li>  boost :: optional </li><li>  boost :: posix_time :: ptime </li><li>  boost :: posix_time :: time_duration </li></ul><br><p>  Limiters for them: </p><br><ul><li>  between for built-in types and not only </li><li>  greater_than, less_than, odd, even </li><li>  container_size :: between, container_size :: less_than, etc. </li><li>  alphabet :: consists_of, alphabet :: does_not_contain </li></ul><br><p>  Tested on the msvc-14.0 compiler, requires c ++ 14.  Unfortunately, gcc behaves a little differently, as a result of which the library code did not gather under mingw (gcc-6.3.0), but I think those who have constant contact with him can quickly fix it. <br>  The library is in the <a href="https://github.com/ukhegg/datagen">public domain</a> .  Ideas and implementations of new types are welcome. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/326576/">https://habr.com/ru/post/326576/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326566/index.html">Interesting prioritization of voice traffic in Telegram</a></li>
<li><a href="../326568/index.html">Autonumber in four languages. Part 1</a></li>
<li><a href="../326570/index.html">How to talk with artificial intelligence?</a></li>
<li><a href="../326572/index.html">Creating a single-player game: from idea to prototype</a></li>
<li><a href="../326574/index.html">TCP / IP basics for future dilettantes</a></li>
<li><a href="../326578/index.html">My C ++ I / O streams using std :: streambuf</a></li>
<li><a href="../326580/index.html">Switch from bash to zsh</a></li>
<li><a href="../326582/index.html">The story of how the parser turned into a full-fledged IRCO bot for Telegrams</a></li>
<li><a href="../326584/index.html">Notes on Cisco Catalyst: VLAN setup, password reset, IOS operating system flashing</a></li>
<li><a href="../326588/index.html">How to make your IDEA IDE level</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>