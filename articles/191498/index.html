<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Everything you wanted to know about dynamic programming, but were afraid to ask</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I was extremely surprised to find few articles about dynamic programming (hereinafter just dynamics) on Habr√©. It always seemed to me that this paradi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Everything you wanted to know about dynamic programming, but were afraid to ask</h1><div class="post__text post__text-html js-mediator-article">  I was extremely surprised to find few articles about dynamic programming (hereinafter just dynamics) on Habr√©.  It always seemed to me that this paradigm is quite widespread, including outside of programming contests.  Therefore, I will try to close this gap with my article. <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#        Python</span></span></code> </pre> <br><h4>  The basics </h4><br>  Perhaps the best description of the dynamics in one sentence that I have ever heard: <br><br><blockquote>  Dynamic programming is when we have a task that is not clear how to solve, and we break it down into smaller tasks that are also not clear how to solve.  (c) A. Kumok. </blockquote><a name="habracut"></a><br>  To successfully solve the problem of dynamics you need: <br>  1) The state of the dynamics: the parameter (s) that uniquely set the subtask. <br>  2) The values ‚Äã‚Äãof the initial states. <br>  3) State transitions: recalculation formula. <br>  4) The procedure for recalculation. <br>  5) The position of the answer to the problem: sometimes it is the sum or, for example, the maximum of the values ‚Äã‚Äãof several states. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Recalculation procedure </h4><br>  There are three recalculation procedures: <br>  1) Direct order: <br>  The states are sequentially recalculated based on those already counted. <br><br><img src="https://habrastorage.org/storage3/f1f/36c/875/f1f36c87585e05a9beb692324fa6b72e.png"><br><br>  2) Reverse order: <br>  All states that depend on the current state are updated. <br><br><img src="https://habrastorage.org/storage3/0ae/3a1/bf4/0ae3a1bf4aed4161e8375305693cbf69.png"><br><br>  3) Lazy dynamics: <br>  Recursive <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25BC%25D0%25BE%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">memoized</a> dynamic conversion function.  This is something like <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D0%25B2_%25D0%25B3%25D0%25BB%25D1%2583%25D0%25B1%25D0%25B8%25D0%25BD%25D1%2583">a depth search in an</a> acyclic state graph, where the edges are dependencies between them. <br><br><img src="https://habrastorage.org/storage3/045/d67/fbe/045d67fbe78f0d724d75dd89a352cfe2.png"><br><br>  An elementary example: <a href="http://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B0_%25D0%25A4%25D0%25B8%25D0%25B1%25D0%25BE%25D0%25BD%25D0%25B0%25D1%2587%25D1%2587%25D0%25B8">Fibonacci numbers</a> .  Status - the number number. <br><br>  Direct order: <br><pre> <code class="python hljs">fib[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">#   fib[2] = 1 #   for i in range(3, n + 1): fib[i] = fib[i - 1] + fib[i - 2] #   i</span></span></code> </pre><br>  Reverse order: <br><pre> <code class="python hljs">fib[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">#   for i in range(1, n): fib[i + 1] += fib[i] #   i + 1 fib[i + 2] += fib[i] #   i + 2</span></span></code> </pre><br>  Lazy dynamics: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-comment"><span class="hljs-comment">#   return 1 if (fib[i] != -1): #  return fib[i] fib[i] = get_fib(i - 1) + get_fib(i - 2) #  return fib[i]</span></span></code> </pre><br>  All three options have the right to life.  Each of them has its own scope, although it often intersects with others. <br><br><h4>  Multidimensional dynamics </h4><br>  An example of one-dimensional dynamics is given above, in ‚Äúrecalculation order‚Äù, so I will immediately begin with multidimensional.  It differs from the one-dimensional, as you may have guessed, the number of measurements, that is, the number of parameters in the state.  Classification on this basis is usually based on the scheme ‚Äúone-two-many‚Äù and is not very important, in fact. <br><br>  The multidimensional dynamics are not very different from the one-dimensional, as you can see by looking at a couple of examples: <br><br><h5>  Example # 1: Number of SMS </h5><br>  Previously, when the phones had buttons, their keyboards looked like this: <br><br><img src="http://habrastorage.org/storage3/489/b28/2c5/489b282c5fccaebf68a4f9fd1a3d9796.png"><br><br>  It is required to calculate how many different text messages to write multiplely using no more than <code>k</code> clicks on such a keyboard. <br><br><div class="spoiler">  <b class="spoiler_title">Decision</b> <div class="spoiler_text">  1) The state of the dynamics: <code>dp[n][m]</code> - the number of different messages of length <code>n</code> , using <code>m</code> clicks. <br>  2) Initial state: there is one message of length zero, using zero presses - empty. <br>  3) Conversion formulas: there are eight letters each, for which you need to write one, two and three clicks, as well as two letters that require 4 clicks. <br><br>  Direct conversion: <br><pre> <code class="python hljs">dp[n][m] = (dp[n - <span class="hljs-number"><span class="hljs-number">1</span></span>][m - <span class="hljs-number"><span class="hljs-number">1</span></span>] + dp[n - <span class="hljs-number"><span class="hljs-number">1</span></span>][m - <span class="hljs-number"><span class="hljs-number">2</span></span>] + dp[n - <span class="hljs-number"><span class="hljs-number">1</span></span>][m - <span class="hljs-number"><span class="hljs-number">3</span></span>]) * <span class="hljs-number"><span class="hljs-number">8</span></span> + dp[n - <span class="hljs-number"><span class="hljs-number">1</span></span>][m - <span class="hljs-number"><span class="hljs-number">4</span></span>] * <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre>  Reverse conversion: <br><pre> <code class="python hljs">dp[n + <span class="hljs-number"><span class="hljs-number">1</span></span>][m + <span class="hljs-number"><span class="hljs-number">1</span></span>] += dp[n][m] * <span class="hljs-number"><span class="hljs-number">8</span></span> dp[n + <span class="hljs-number"><span class="hljs-number">1</span></span>][m + <span class="hljs-number"><span class="hljs-number">2</span></span>] += dp[n][m] * <span class="hljs-number"><span class="hljs-number">8</span></span> dp[n + <span class="hljs-number"><span class="hljs-number">1</span></span>][m + <span class="hljs-number"><span class="hljs-number">3</span></span>] += dp[n][m] * <span class="hljs-number"><span class="hljs-number">8</span></span> dp[n + <span class="hljs-number"><span class="hljs-number">1</span></span>][m + <span class="hljs-number"><span class="hljs-number">4</span></span>] += dp[n][m] * <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  4) The procedure for recalculation: <br>  If we write using the direct method, then we need to think separately about going beyond the dynamics, for example, when we refer to <code>dp[n - 1][m - 4]</code> , which may not exist for small <code>m</code> .  To circumvent this, you can either put checks in terms of recalculation or write neutral elements there (which do not change the answer). <br><br>  When using the reverse recalculation, everything is simpler: we always turn forward, so we will not leave the negative elements. <br><br>  5) The answer is the sum of all states. <br><br>  <b>UPD:</b> <br>  Unfortunately, I made a mistake - the problem can be solved one-dimensional, simply by removing the length of the message <code>n</code> from the state. <br>  1) State: <code>dp[m]</code> - the number of different posts that can be typed in <code>m</code> taps. <br>  2) Initial state: <code>dp[0] = 1</code> . <br>  3) Conversion formula: <br><pre> <code class="python hljs">dp[m] = (dp[m - <span class="hljs-number"><span class="hljs-number">1</span></span>] + dp[m - <span class="hljs-number"><span class="hljs-number">2</span></span>] + dp[m - <span class="hljs-number"><span class="hljs-number">3</span></span>]) * <span class="hljs-number"><span class="hljs-number">8</span></span> + dp[m - <span class="hljs-number"><span class="hljs-number">4</span></span>] * <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre>  4) Order: all three options can be used. <br>  5) The answer is the sum of all states. <br></div></div><br><h5>  Example 2: Horse </h5><br>  A chess knight stands in a cage <code>(1, 1)</code> on an <code>N</code> x <code>M</code> size board.  It is required to count the number of ways to get to the cell <code>(N, M)</code> moving in four types of steps: <br><br><img src="http://habrastorage.org/storage3/ccf/f17/81c/ccff1781c0bcf3febfb5533bfd200406.png"><br><br><div class="spoiler">  <b class="spoiler_title">Decision</b> <div class="spoiler_text">  1) The state of the dynamics: <code>dp[i][j]</code> - the number of ways to get to <code>(i, j)</code> . <br>  2) Initial value: In the cell <code>(1, 1)</code> can be reached in one way - do nothing. <br>  3) Conversion formula: <br>  For direct order: <br><pre> <code class="python hljs">dp[i][j] = dp[i - <span class="hljs-number"><span class="hljs-number">2</span></span>][j - <span class="hljs-number"><span class="hljs-number">1</span></span>] + dp[i - <span class="hljs-number"><span class="hljs-number">2</span></span>][j + <span class="hljs-number"><span class="hljs-number">1</span></span>] + dp[i - <span class="hljs-number"><span class="hljs-number">1</span></span>][j - <span class="hljs-number"><span class="hljs-number">2</span></span>] + dp[i + <span class="hljs-number"><span class="hljs-number">1</span></span>][j - <span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre>  For reverse order: <br><pre> <code class="python hljs">dp[i + <span class="hljs-number"><span class="hljs-number">1</span></span>][j + <span class="hljs-number"><span class="hljs-number">2</span></span>] += dp[i][j] dp[i + <span class="hljs-number"><span class="hljs-number">2</span></span>][j + <span class="hljs-number"><span class="hljs-number">1</span></span>] += dp[i][j] dp[i - <span class="hljs-number"><span class="hljs-number">1</span></span>][j + <span class="hljs-number"><span class="hljs-number">2</span></span>] += dp[i][j] dp[i + <span class="hljs-number"><span class="hljs-number">2</span></span>][j - <span class="hljs-number"><span class="hljs-number">1</span></span>] += dp[i][j]</code> </pre><br>  4) And now the most interesting thing in this problem: order.  Here you can not just go and walk through the rows or columns.  Because otherwise, we will refer to the not yet recalculated states in the direct order, and we will take more unfinished states in the opposite approach. <br><br>  There are two ways: <br>  1) Come up with a good detour. <br>  2) Launch lazy dynamics, let them figure it out. <br><br>  If you are too lazy to think, we are launching lazy dynamics, she will do an excellent job with the task. <br>  If not laziness, then you can think of a detour like this: <br><br><img src="http://habrastorage.org/storage3/6fa/e85/ac9/6fae85ac9b81eea10e2d6793ff089b0a.png"><br><br>  This procedure ensures that all the cells required at each step are processed during the direct walk, and the current state is processed at the reverse. <br><br>  5) The answer simply lies in <code>dp[n][m]</code> . <br></div></div><br><h4>  Dynamics and transition matrix </h4><br>  If you have never multiplied the matrices, but you want to understand this title, then you should read at least a <a href="http://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BC%25D0%25B0%25D1%2582%25D1%2580%25D0%25B8%25D1%2586">wiki</a> . <br><br>  Suppose there is a task that we have already solved by dynamic programming, for example, the eternal Fibonacci numbers. <br>  Let's reformulate it a bit.  Suppose we have a vector <img src="http://1450828021635878017810">  from which we want to get a vector <img src="http://habrastorage.org/storage3/5de/b1b/422/5deb1b4227d61a317e050e51ef60f303.gif">  .  Slightly open the formula: <img src="http://habrastorage.org/storage3/540/9ad/eff/5409adeff2e19312963e353808ee2e09.gif">  .  You may notice that from the vector <img src="http://1450828021635878017810">  can get a vector <img src="http://habrastorage.org/storage3/0e2/10e/b3c/0e210eb3ce4f462437cb3ab20dd89ade.gif">  by multiplying by some matrix, because in the final vector only folded variables from the first vector appear.  This matrix is ‚Äã‚Äãeasy to derive, here it is: <img src="http://habrastorage.org/storage3/240/abf/7a9/240abf7a9e66291d30859e40d66375f3.gif">  .  Let's call it the transition matrix. <br><br>  This means that if you take a vector <img src="http://habrastorage.org/storage3/4a9/895/f37/4a9895f374b573bda1d027278cb9f355.gif">  and multiply it by the transition matrix <code>n - 1</code> times, then we get the vector <img src="http://habrastorage.org/storage3/d4d/8b0/5a9/d4d8b05a922d937b8f69cc282e8e71d9.gif">  in which <code>fib[n]</code> lies - the answer to the problem. <br><br>  And now, why all this is necessary.  Matrix multiplication has the property of associativity, that is, <img src="http://habrastorage.org/storage3/5ac/694/221/5ac69422145338e99b253c21b0f45e3a.gif">  (but it does not have commutativity, which is surprising to me).  This property gives us the right to do so: <img src="http://habrastorage.org/storage3/451/825/0a4/4518250a4d12721a42f92e009f949332.gif">  . <br><br>  This is good because you can now apply <a href="http://en.wikipedia.org/wiki/Exponentiation_by_squaring">the quick exponentiation method</a> that works for <img src="http://habrastorage.org/storage3/12c/d32/3bb/12cd323bb4fae5b97733f336d0ad488a.gif">  .  Total we were able to calculate the <code>N</code> th Fibonacci number for the logarithm of arithmetic operations. <br><br>  And now an example is more serious: <br><br><h5>  Example 3: sawtooth sequence </h5><br>  We denote a sawtooth sequence of length <code>N</code> as a sequence in which the condition is satisfied for each non-extreme element: it is either less than or both of its neighbors or more.  It is required to count the number of sawtooth sequences from digits of length <code>N</code>  It looks something like this: <br><img src="http://habrastorage.org/storage3/2d4/589/2d1/2d45892d1bd62878abaaa15f8d50c63d.png"><br><br><div class="spoiler">  <b class="spoiler_title">Decision</b> <div class="spoiler_text">  To begin with, a solution without a transition matrix: <br><br>  1) The state of the dynamics: <code>dp[n][last][less]</code> - the number of sawtooth sequences of length <code>n</code> , ending in the digit <code>last</code> .  And if <code>less == 0</code> , then the last digit is less than the last but one, and if <code>less == 1</code> , it means more. <br>  2) Initial values: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> last <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>): dp[<span class="hljs-number"><span class="hljs-number">2</span></span>][last][<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">9</span></span> - last dp[<span class="hljs-number"><span class="hljs-number">2</span></span>][last][<span class="hljs-number"><span class="hljs-number">1</span></span>] = last</code> </pre>  3) Recalculation of the dynamics: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> prev <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> prev &gt; last: dp[n][last][<span class="hljs-number"><span class="hljs-number">0</span></span>] += dp[n - <span class="hljs-number"><span class="hljs-number">1</span></span>][prev][<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> prev &lt; last: dp[n][last][<span class="hljs-number"><span class="hljs-number">1</span></span>] += dp[n - <span class="hljs-number"><span class="hljs-number">1</span></span>][pref][<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre>  4) Recalculation order: we always refer to the previous length, so just a pair of nested <code>for</code> 's. <br>  5) The answer is the sum of <code>dp[N][0..9][0..1]</code> . <br><br>  Now we need to come up with an initial vector and a transition matrix.  The vector seems to be invented quickly: all the states that indicate the length of the sequence <code>N</code>  Well, the transition matrix is ‚Äã‚Äãdisplayed, looking at the recalculation formulas. <br><br><div class="spoiler">  <b class="spoiler_title">Vector and transition matrix</b> <div class="spoiler_text"><img src="http://habrastorage.org/storage3/a38/5a5/445/a385a54455092b0a38b5429892308173.gif"></div></div></div></div><br><h4>  Dynamics by subseries </h4><br>  This is a class of dynamics in which the state is the subsection boundaries of an array.  The point is to calculate the answers for subtasks based on all possible sub-segments of our array.  Usually they are sorted in order of increasing length, and the recalculation is based, respectively, on shorter segments. <br><br><h5>  Example 4: Packing a string </h5><br>  Here is the <a href="http://acm.timus.ru/problem.aspx%3Fspace%3D1%26num%3D1238">expanded condition</a> .  I will briefly retell it: <br><br>  Define a compressed string: <br>  1) A letter-only string is a concise string.  Unclench it in itself. <br>  2) A string that is the concatenation of two compressed strings <code>A</code> and <code>B</code>  It expands into the concatenation of the expanded <code>A</code> and <code>B</code> lines. <br>  3) Line <code>D(X)</code> , where <code>D</code> is an integer greater than <code>1</code> , and <code>X</code> is a compressed string.  It expands to the concatenation of <code>D</code> strings expanded from <code>X</code> <br>  Example: <code>‚Äú3(2(A)2(B))C‚Äù</code> expanded in <code>‚ÄúAABBAABBAABBC‚Äù</code> . <br><br>  It is necessary to find the length of the shortest compressed string unfolded into it by line <code>s</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Decision</b> <div class="spoiler_text">  This problem is being solved, as you probably already guessed, by sub-cutting dynamics. <br><br>  1) The state of the dynamics: <code>d[l][r]</code> - compressed string of minimum length, unclamping into a string <code>s[l:r]</code> <br>  2) Initial states: all substrings of length one can be compressed only in themselves. <br>  3) Recalculation of the dynamics: <br>  The best answer has some sort of final compression operation: either it is just a string of capital letters, or it is a concatenation of two lines, or compression itself.  So let's go through all the options and choose the best. <br><br><pre> <code class="python hljs">dp_len = r - l dp[l][r] = dp_len <span class="hljs-comment"><span class="hljs-comment">#    -  . for i in range(l + 1, r): dp[l][r] = min(dp[l][r], dp[l][i] + dp[i][r]) #       for cnt in range(2, dp_len): if (dp_len % cnt == 0): #   ,      good = True for j in range(1, (dp_len / cnt) + 1): #   ,   cnt   good &amp;= s[l:l + dp_len / cnt] == s[l + (dp_len / cnt) * j:l + (dp_len / cnt) * (j + 1)] if good: #    cnt     dp[l][r] = min(dp[l][r], len(str(cnt)) + 1 + dp[l][l + dp_len / cnt] + 1)</span></span></code> </pre>  4) The order of conversion: direct ascending the length of the substring or lazy dynamics. <br>  5) The answer lies in <code>d[0][len(s)]</code> . <br></div></div><br><h5>  Example 5: <a href="http://habrahabr.ru/post/112386">Oaks</a> </h5><br><h4>  Subtree dynamics </h4><br>  The state of dynamics parameter for subtrees is usually a vertex denoting a subtree in which this vertex is the root.  To obtain the value of the current state, you usually need to know the results of all your children.  Most often they implement it lazily - they just write a depth-first search from the root of the tree. <br><br><h5>  Example 6: Logical tree </h5><br>  Given a hanging tree, in the leaves of which one-bit numbers are written - <code>0</code> or <code>1</code> .  All internal vertices also contain numbers, but according to the following rule: for each vertex one of the logical operations is chosen: ‚ÄúAND‚Äù or ‚ÄúOR‚Äù.  If it is ‚ÄúAND‚Äù, then the value of the vertex is the logical ‚ÄúAND‚Äù of the values ‚Äã‚Äãof all its children.  If "OR", then the value of the vertex is the logical "OR" of the values ‚Äã‚Äãof all its children. <br><br><img src="http://habrastorage.org/storage3/ff3/525/f54/ff3525f54dad986bd4832040240ec08b.png"><br><br>  It is required to find the minimum number of changes of logical operations in the internal vertices, such that the value in the root changes or report that this is impossible. <br><br><div class="spoiler">  <b class="spoiler_title">Decision</b> <div class="spoiler_text">  1) The state of the dynamics: <code>d[v][x]</code> - the number of operations required to obtain the value of <code>x</code> at the vertex <code>v</code> .  If this is not possible, then the state value is <code>+inf</code> . <br>  2) Initial values: for leaves, it is obvious that its value can be obtained for zero changes, but it is impossible to change the value, that is, it is possible, but only for <code>+inf</code> operations. <br>  3) Conversion formula: <br>  If at this vertex is already the value of <code>x</code> , then zero.  If not, then there are two options: change the operation in the current vertex or not.  For both you need to find the best option and choose the best. <br><br>  If the operation "And" and you need to get "0", then the answer is the minimum of the values ‚Äã‚Äãof <code>d[i][0]</code> , where <code>i</code> is the son of <code>v</code> . <br>  If the operation "And" and you need to get "1", then the answer is the sum of all values ‚Äã‚Äãof <code>d[i][1]</code> , where <code>i</code> is the son of <code>v</code> . <br>  If the operation is "OR" and you need to get "0", then the answer is the sum of all <code>d[i][0]</code> values, where <code>i</code> is the son of <code>v</code> . <br>  If the operation is "OR" and you need to get "1", then the answer is the minimum of the values <code>d[i][1]</code> , where <code>i</code> is the son of <code>v</code> . <br><br>  4) The order of conversion: the easiest to implement is lazy - in the form of a search into the depth of the root. <br>  5) The answer is <code>d[root][value[root] xor 1]</code> . <br></div></div><br><h4>  The dynamics of the subsets </h4><br>  In dynamics over subsets, a mask of a given set usually enters the state.  They are most often moved in the order of increasing the number of units in this mask and are recalculated, respectively, from the states that are smaller in inclusion.  Usually used lazy dynamics, so as not to specifically think about the traversal order, which sometimes is not quite trivial. <br><br><h5>  Example # 7: Hamiltonian cycle of minimum weight, or the traveling salesman problem </h5><br>  A weighted (non-negative, edge weight) graph <code>G</code> size <code>N</code> .  Find the <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B0%25D0%25BC%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B2_%25D1%2586%25D0%25B8%25D0%25BA%25D0%25BB">Hamiltonian cycle</a> (the cycle passing through all vertices without self-intersections) of the minimum weight. <br><br><div class="spoiler">  <b class="spoiler_title">Decision</b> <div class="spoiler_text">  Since we are looking for a cycle passing through all the vertices, we can choose any one as the ‚Äúinitial‚Äù vertex.  Let it be the vertex with the number <code>0</code> . <br><br>  1) The state of the dynamics: <code>dp[mask][v]</code> - the path of the minimum weight from the vertex <code>0</code> to the vertex <code>v</code> , passing through all the vertices lying in the <code>mask</code> and only along them. <br>  2) Initial values: <code>dp[1][0] = 0</code> , all other states initially - <code>+inf</code> . <br>  3) The recalculation formula: If the <code>i</code> -th bit in <code>mask</code> is <code>1</code> and there is an edge from <code>i</code> to <code>v</code> , then: <br><pre> <code class="python hljs">dp[mask][v] = min(dp[mask][v], dp[mask - (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i)][i] + w[i][v])</code> </pre>  Where <code>w[i][v]</code> is the weight of the edge from <code>i</code> to <code>v</code> . <br>  4) Recalculation order: the easiest and most convenient way is to write lazy dynamics, but you can turn around and write through the masks in order of increasing the number of single bits in it. <br>  5) The answer lies in <code>d[(1 &lt;&lt; N) - 1][0]</code> . <br></div></div><br><h4>  Profile Dynamics </h4><br>  Classical problems that are solved by the dynamics of the profile, are the tasks on the paving of the field by some kind of figures.  Moreover, different things may be asked, for example, the number of ways of paving or paving with a minimum number of pieces. <br><br>  These tasks can be solved by exhaustive search. <img src="http://habrastorage.org/storage3/ec7/5c6/348/ec75c6348d46e6b40d2df800c45c6c9c.gif">  where <code>a</code> is the number of options for tiling a single cell.  The dynamics of the profile optimizes the time for one of the dimensions to linear, leaving only the coefficient in the exponent.  It turns out something like this: <img src="http://1450828021412452287725">  . <br><br>  A profile is <code>k</code> (often single) columns, which are the boundary between the already tiled part and the not yet tiled part.  This border is only partially filled.  It is often part of the state of the dynamics. <br><br><img src="http://habrastorage.org/storage3/7c7/a66/c59/7c7a66c598b1c45a46499d319295eccf.png"><br><br>  Almost always the state is the profile and where the profile is.  A transition increases this location by one.  It is possible to find out whether it is possible to go from one profile to another within a linear time of the profile size.  This can be checked each time during the recalculation, but it can also be assumed.  We will presuppose a two-dimensional array of <code>can[mask][next_mask]</code> - can we move from one mask to another by putting several figures, increasing the position of the profile by one.  If it is presumed, then it takes less time to complete, and more memory. <br><br><h5>  Example 8: Dominoing </h5><br>  Find the number of ways to tile an <code>N</code> x <code>M</code> table using dominoes with dimensions of <code>1</code> x <code>2</code> and <code>2</code> x <code>1</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Decision</b> <div class="spoiler_text">  Here the profile is one column.  It is convenient to store it in the form of a binary mask: <code>0</code> - not tiled column cell, <code>1</code> - tiled.  That is, the total profiles <img src="http://habrastorage.org/storage3/cb8/2ca/131/cb82ca131a8a06bf66ca387fe59a3b32.gif">  . <br><br>  0) Pre-submission (optional): enumerate all pairs of profiles and check that one can go from one to another.  In this problem, it is verified as follows: <br><br>  If in the first profile in the next place is <code>1</code> , then in the second one must necessarily be <code>0</code> , since we will not be able to tile this cell with any figurine. <br><br>  If in the first profile in the next place is <code>0</code> , then there are two options - or in the second <code>0</code> or <code>1</code> . <br>  If <code>0</code> , it means that we are obliged to put a vertical domino, which means the next cell can be considered as <code>1</code> .  If <code>1</code> , then we put a vertical domino and go to the next cell. <br><br>  Examples of transitions (from the top profile you can go to the bottom and only to them): <br><br><img src="http://habrastorage.org/storage3/aba/614/08a/aba61408a4070deb2246748bc02b3ed1.png"><br><br>  After that, save everything to the array <code>can[mask][next_mask]</code> - <code>1</code> , if you can go, <code>0</code> - if you can not. <br>  1) The state of the dynamics: <code>dp[pos][mask]</code> - the number of complete tilings of the first <code>pos - 1</code> columns with the <code>mask</code> profile. <br>  2) Initial state: <code>dp[0][0] = 1</code> - the left field boundary is a straight wall. <br>  3) Conversion formula: <br><pre> <code class="python hljs">dp[pos][mask] += dp[pos - <span class="hljs-number"><span class="hljs-number">1</span></span>][next_mask] * can[mask][next_mask]</code> </pre><br>  4) Bypass order - in order of increasing <code>pos</code> . <br>  5) The answer lies in dp [pos] [0]. <br><br>  The resulting asymptotics is <img src="http://habrastorage.org/storage3/0a6/dce/744/0a6dce744ba9036e5e66f66ff1f7981d.gif">  . <br></div></div><br><h4>  The dynamics of the broken profile </h4><br>  This is a very strong optimization of the dynamics of the profile.  Here the profile is not only a mask, but also a place of a break.  It looks like this: <br><br><img src="http://habrastorage.org/storage3/fdb/327/d9a/fdb327d9ae859be6d79c92e2ab532c80.png"><br><br>  Now, after adding a break in the profile, you can move to the next state by adding just one figure covering the left break cell.  That is, by increasing the number of states <code>N</code> times (remember, where the break is) we reduced the number of transitions from one state to another with <img src="http://habrastorage.org/storage3/91d/eda/33f/91deda33f447a6dc20829bb608519b5c.gif">  before <img src="http://habrastorage.org/storage3/372/ece/b1f/372eceb1f455d4e334661ef79efa1c0c.gif">  .  Asymptotics improved with <img src="http://1450828021412452287725">  before <img src="http://habrastorage.org/storage3/1a5/a5e/46d/1a5a5e46d7908f2378be7256fd9d4331.gif">  . <br><br>  Transitions in dynamics along a broken profile using the example of a task about tiling with dominoes (Example No. 8): <br><br><img src="http://habrastorage.org/storage3/f27/4d4/ea1/f274d4ea17f93b543fd57f4a2326be73.png"><br><br><h4>  Recovery response </h4><br>  Sometimes it happens that simply knowing some characteristic of a better answer is not enough.  For example, in the ‚ÄúPacking a string‚Äù task (example No. 4), we end up with only the length of the shortest compressed string, but, most likely, we need not its length, but the string itself.  In this case, you need to restore the answer. <br><br>  Each task has its own way of recovering the answer, but the most common ones are: <br><br><ul><li>  Next to the value of the state of the dynamics store the full response to the subtask.  If the answer is something big, then you may need too much memory, so if you can use another method, they usually do it. </li><li>  Restore the answer, knowing the ancestor (s) of this state.  Often, you can restore the answer, knowing only how it was received.  In the very "Packing line" you can save the answer to store only the last action view and the state from which it was obtained. </li><li>  There is a way that does not use additional memory at all - after recalculating the dynamics, go from the end to the best way and form an answer along the way. </li></ul><br><h4>  Small optimizations </h4><br><h5>  Memory </h5><br>  Often, in dynamics, one can encounter a task in which a state requires not a very large number of other states to be counted.  For example, when calculating Fibonacci numbers, we use only the last two, and we will never turn to the previous ones.  So, you can forget about them, that is, do not store in memory.  Sometimes this improves the asymptotic memory estimate.  This technique can be used in examples No. 1, No. 2, No. 3 (in the solution without a transition matrix), No. 7 and No. 8.  True, this can not be used in any way, if the bypass order is a lazy speaker. <br><br><h5>  Time </h5><br>  Sometimes it happens that you can improve the asymptotic time using some kind of data structure.  For example, in <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2594%25D0%25B5%25D0%25B9%25D0%25BA%25D1%2581%25D1%2582%25D1%2580%25D1%258B">the Dijkstra algorithm,</a> you can use the <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D1%2587%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B4%25D1%258C_%25D1%2581_%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25B5%25D1%2582%25D0%25BE%25D0%25BC_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">priority queue</a> to change the asymptotic time. <br><br><h4>  State replacement </h4><br>  In solutions, dynamics necessarily include a state ‚Äî parameters that uniquely define a subtask, but this state is not necessarily the only one.                 . <br><br><h5>  ‚Ññ9:   </h5><br>      <code>N</code>   . ,  <code>N = 7</code> ,    <code>5</code> : <br><ul><li>  7 </li><li> 3 + 4 </li><li> 2 + 5 </li><li> 1 + 7 </li><li> 1 + 2 + 4 </li></ul><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><h6>  ‚Ññ1: </h6><br> 1)  : <code>dp[n][k]</code> ‚Äî    <code>n</code>  ,    <code>k</code> .  <code>k</code> ,      ,   . <br> 2)  : <code>dp[1][1] = 1</code> , <code>dp[1][i] = 0</code> . <br> 3)  : <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> last_summand <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, k + <span class="hljs-number"><span class="hljs-number">1</span></span>): dp[n][k] += dp[n - last_summand][last_summand]</code> </pre><br> 4) : ,    <code>n</code> . <br> 5)  ‚Äî  <code>dp[N][1..N]</code> . <br><br> : <img src="http://1450828021916937179328"> , : <img src="http://habrastorage.org/storage3/7fe/3ea/0d5/7fe3ea0d559ce8965e344875fa57c1bf.gif">  . : <img src="http://habrastorage.org/storage3/364/0ef/bbd/3640efbbdedc4d7f0b3aed73a2056c45.gif">  . <br><br><h6>  ‚Ññ2: </h6><br> 1)  .  dp[n][k] ‚Äî     <code>n</code>  <code>k</code>  .   ,    . <br> 2)  : <code>dp[1][1] = 1</code> , <code>dp[1][i] = 0</code> . <br> 3)  : <br><pre> <code class="python hljs">dp[n][k] = dp[n - k][k] + dp[n - k][k - <span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre><br>   ,    .     (  )    : <br><ul><li>       <code>1</code> . </li><li>       <code>1</code> .   <code>1</code>  . </li></ul><br>  ,       <a href="http://en.wikipedia.org/wiki/Young_tableau"> </a> : <br><br><img src="http://habrastorage.org/storage3/4d1/12d/daf/4d112ddaf011379276c32f69d4bc60ce.png"><br>    . <br><br>         ,   ‚Äî     .      ‚Äî ,     ,   ‚Äî  :        . <br><br> 4)  : ,    <code>n</code> . <br><br>   ,      <img src="http://1450828021916937179328"> ,        <img src="http://habrastorage.org/storage3/d0e/93c/084/d0e93c084652895c79aa8cd2977ec0b3.gif"> .    ,    ‚Äî <code>k</code>     <code>N</code> ,   <img src="http://habrastorage.org/storage3/d40/361/25b/d4036125b49f13024636d2d87ad4f3f8.gif"> (   <code>1</code>  <code>k</code>     ).    ,    <img src="http://1450828021872984415255">  . <br><br> 5)  ‚Äî   <code>dp[N][1..k_max]</code> . <br><br> : <img src="http://1450828021872984415255">  . <br></div></div><br><h4>  Conclusion </h4><br>    ,        <a href="http://lksh.ru/">  </a> ( ),          ( <a href="https://habr.com/users/darnley/" class="user_link">darnley</a> ). <br><br>   ,    - !     ‚Äî ,       . </div><p>Source: <a href="https://habr.com/ru/post/191498/">https://habr.com/ru/post/191498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../191482/index.html">Servers in the USA, Data Center COPT DC-6-EvoSwitch / LeaseWeb (Manassas)</a></li>
<li><a href="../191486/index.html">10 fastest supercomputers in pictures</a></li>
<li><a href="../191488/index.html">Interactive testing - is it worth it?</a></li>
<li><a href="../191490/index.html">Opera 16 Final</a></li>
<li><a href="../191494/index.html">Survey: how many of our sites with you?</a></li>
<li><a href="../191502/index.html">Apple will review its sales strategy in Russia</a></li>
<li><a href="../191508/index.html">The Chinese Internet has become a victim of the strongest DDoS attacks.</a></li>
<li><a href="../191510/index.html">Hardware is less hard with accelerator</a></li>
<li><a href="../191522/index.html">Roskomnadzor VS TitanPoker</a></li>
<li><a href="../191528/index.html">News360 personalization system: ranking information clusters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>