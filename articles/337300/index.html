<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>V8 internal mechanisms and fast work with object properties</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This material focuses on how V8 internal mechanisms work with the properties of JavaScript objects. If we consider the properties from the point of vi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>V8 internal mechanisms and fast work with object properties</h1><div class="post__text post__text-html js-mediator-article">  This material focuses on how V8 internal mechanisms work with the properties of JavaScript objects.  If we consider the properties from the point of view of JavaScript, their different types are not so different from each other.  Say, JS objects usually behave like dictionaries with string keys and arbitrary objects as values.  However, if you read the language specification, you can find out, for example, that the properties of different types <a href="https://tc39.github.io/ecma262/">behave differently</a> when they are searched.  In other cases, the behavior of the properties of different species, basically, looks the same. <br><br>  It would seem that the implementation of the mechanism of working with properties, given their similarity, is not such a large-scale task, however, in the depths of the V8 several different ways of representing properties are used.  This was done, firstly, to ensure high performance, and secondly, in order to save memory. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/337300/"><img src="https://habrastorage.org/web/9d0/428/ac7/9d0428ac72994aee8f097aa77e89cce1.jpg" alt="image"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article we want to talk about how V8 achieves high performance when processing dynamically added properties of objects.  Knowledge of the features of the mechanism of working with properties is necessary to understand the essence of how to optimize the execution of JavaScript in V8, such as <a href="http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html">embedded caches</a> . <br><a name="habracut"></a><br>  Here we‚Äôll talk about how V8 differs in handling named properties and properties indexed by integers.  After that, we will consider the features of the functioning of hidden classes when new named properties are added to an object, which allows you to quickly identify the shape of an object.  Then we continue the story about the internal mechanisms of the V8, show the optimization, aimed, depending on the characteristics of the use of hidden properties, for quick access to them, or for their quick modification.  After reviewing the last section, you will learn how V8 handles properties indexed by integers, or array elements that are assigned indices. <br><br><h2>  <font color="#3AC1EF">Comparing Named Properties and Array Elements</font> </h2><br>  Let's start with the analysis of a very simple object.  For example, let it be something like <code>{a: "foo", b: "bar"}</code> .  This object has two named properties: <code>a</code> and <code>b</code> .  There are no integer indices for property names for this object.  Indexed properties, more commonly known as elements, are characteristic of arrays.  For example, the array <code>["foo", "bar"]</code> has two indexed properties: <code>0</code> with the value <code>foo</code> , and <code>1</code> with the value <code>bar</code> .  We have just described the first major difference in the implementation of the representation of named and indexed properties in V8. <br><br>  The following image shows how a regular JavaScript object looks in memory. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28e/4ae/c7f/28e4aec7fb06f25a66b843c64792b9bc.png"></div><br>  <i><font color="#999999">Named and Indexed Properties</font></i> <br><br>  Elements and properties are stored in various data structures.  This increases the efficiency of operations on adding new properties and elements and on access to them for various patterns of working with them. <br><br>  Elements are mainly used for various <a href="https://tc39.github.io/ecma262/">Array.prototype methods</a> , such as <code>pop</code> or <code>slice</code> .  Considering that these functions work with properties that follow each other, their internal representation in V8, in most cases, looks like a simple array. <br><br>  Later we will talk about the situations in which we switch to using the dictionary mechanism for storing indexed properties to save memory.  In particular, we are talking about replacing sparse arrays with dictionaries. <br><br>  Named properties are stored similarly in separate arrays.  However, unlike the elements, we cannot use keys to find out their positions in the property storage.  We need additional metadata.  In V8, every JavaScript object has a hidden class associated with it (HiddenClass).  The hidden class stores information about the form of the object, and, among other things, information about the correspondence of property names to indexes in the property storage.  For complex scripts, we sometimes use dictionaries for storing properties, rather than simple arrays.  In the appropriate section, we will focus on this in more detail. <br><br><h3>  <font color="#3AC1EF">‚ñç Conclusions</font> </h3><br><ul><li>  Indexed properties are stored in a separate item repository. <br></li><li>  Named properties are stored in their own property repository. <br></li><li>  The storage of elements and properties can be either arrays or dictionaries. <br></li><li>  Each JS object has a hidden class associated with it that stores information about the shape of the object. <br></li></ul><br><h2>  <font color="#3AC1EF">Hidden classes and descriptor arrays</font> </h2><br>  After we figured out what the main difference between elements and named properties are, we need to take a look at how hidden classes work in V8. <br><br>  Hidden classes store meta information about objects, including the number of properties of an object and a link to its prototype.  Hidden classes are conceptually similar to classes in a typical object-oriented programming language.  However, in a prototype language, such as JavaScript, it is usually not possible to know in advance about object classes.  As a result, in this case in V8, hidden classes are created, as they say, on the fly, and are dynamically updated when the object is updated. <br><br>  Hidden classes serve as identifiers for the shape of an object; as a result, they are a very important part of the V8 optimizing compiler and the mechanism of the embedded caches.  An optimizing compiler, for example, can embed property values ‚Äã‚Äãin the appropriate data structure if it can guarantee the compatibility of the hidden class with the structure of objects. <br><br>  Take a look at the important parts of the hidden classes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34f/763/483/34f7634832c1336eeefa8470ea0099a9.png"></div><br>  <i><font color="#999999">JS object, hidden class, and handles that contain information about named properties</font></i> <br><br>  In V8, the first field of the JS object indicates the hidden class.  (Actually, this is the case for any object that is on the V8 heap and is managed by the garbage collector).  From the point of view of working with properties, the most important is the field, indicated in the figure as <code>bit field 3</code> , which stores the number of properties and a pointer to an array of descriptors.  An array of descriptors contains information about named properties, in particular, the name of the property and the position where the value is stored.  Please note that we do not work here with properties indexed by integers, so there is no corresponding record in the array of descriptors. <br><br>  By assigning hidden classes to objects, V8 assumes that objects with the same structure, that is, with the same named properties, arranged in the same order, will have the same hidden class.  In order to achieve this, when a new property is added to the object, a new hidden class is assigned to it.  In the following example, we start with an empty object and add three named properties to it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c31/fb1/3e3/c31fb13e3d438a008c1a89a6c3a7e093.png"></div><br>  <i><font color="#999999">Creating intermediate hidden classes when adding named properties to an object</font></i> <br><br>  Each time a new property is added, the hidden object class changes.  V8 creates a transition tree that connects hidden classes.  V8 knows which hidden class to take when you add, for example, property <code>a</code> to an empty object.  This transition tree allows you to ensure that when objects are arranged in the same way, they will get the same hidden class. <br><br>  The following example shows that even if simple indexable properties are added to an object, the transition tree will be one and the same. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44f/130/c98/44f130c98f2906e19a5494adcb5e8942.png"></div><br>  <i><font color="#999999">Adding named and indexed properties to an object</font></i> <br><br>  However, if you create a new object in which some other named property will be added, in this case <code>d</code> , V8 will create a separate branch for new hidden classes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e84/acc/0fc/e84acc0fc46bb244c733bb36c1570854.png"></div><br>  <i><font color="#999999">Building various transition trees for objects with a different set of properties</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç Conclusions</font> </h3><br><ul><li>  Objects with the same structure (that is, with the same properties arranged in the same order) will have the same hidden class. <br></li><li>  By default, every new named property added to an object results in the creation of a new hidden class. <br></li><li>  When adding indexable properties, the creation of new hidden classes does not occur. <br></li></ul><br><h2>  <font color="#3AC1EF">Three kinds of named properties</font> </h2><br>  After we describe how V8 uses hidden classes to support information about the shape of objects, let's talk about how, in fact, the named properties are stored.  As shown above, there are two fundamental types of properties: named and indexed.  Here we will talk more about named properties. <br><br>  A simple object, such as <code>{a: 1, b: 2}</code> , can have different internal representations in V8.  Although it may seem that the behavior of JS objects is more or less similar to the behavior of simple dictionaries, V8 tries to avoid presenting them as dictionaries, as this makes it difficult to perform certain optimizations, such as <a href="https://en.wikipedia.org/wiki/Inline_caching">embedded caching</a> , that are worthy of a separate conversation. <br><br><h3>  <font color="#3AC1EF">‚ñçComparison of internal and ordinary properties of objects</font> </h3><br>  V8 supports the so-called internal properties of objects that are stored directly in the objects themselves.  These are the fastest properties used in the V8, since they can be accessed without performing additional actions.  The number of internal properties of an object is determined by the initial size of the object.  If more properties are added than the space allows in the object, they will be placed in the property store.  The property store adds an extra layer of abstraction, but its size can grow independently of the object. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1be/bc6/447/1bebc64476d65386c180398ff01164ca.png"></div><br>  <i><font color="#999999">The number of properties that are handled most quickly is predetermined by the initial size of the object.</font></i>  <i><font color="#999999">Values ‚Äã‚Äãof properties, work with which is also carried out quickly enough, are stored in a simple array of properties</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñçComparison of fast and slow properties</font> </h3><br>  The next thing to notice is the difference between ‚Äúfast‚Äù and ‚Äúslow‚Äù properties.  Usually we call ‚Äúfast‚Äù properties that are stored in the linear property repository.  These properties are accessed by index in the repository.  In order to go from the name of the property to its position in the repository, it is necessary, as shown above, to access the array of descriptors. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/f20/25c/8e1f2025c8188171500bc0cb02b53a96.png"></div><br>  <i><font color="#999999">The dictionary of properties is self-sufficient; when working with it, additional meta-information from the arrays of descriptors is not needed.</font></i> <br><br>  However, if many operations are performed to add and remove object properties, supporting an array of descriptors and hidden classes may require too much extra time and memory.  Therefore, V8, in addition, supports the so-called slow properties.  An object with slow properties uses a self-contained dictionary as a property repository.  All meta-information of properties is no longer stored in an array of descriptors in a hidden class; instead, it is placed directly in the property dictionary.  As a result, properties can be added and removed without updating the hidden class.  Since embedded caches do not work with properties that are stored in the dictionary, working with such properties is usually slower than working with ‚Äúfast‚Äù properties. <br><br><h3>  <font color="#3AC1EF">‚ñç Conclusions</font> </h3><br><ul><li>  There are three types of named properties: internal properties of an object, fast properties, and slow (vocabulary) properties. <br></li></ul><br><ol><li>  The internal properties of the object are stored directly in the object, working with them is carried out most quickly. <br></li><li>  Fast properties are placed in the property repository, their meta information is stored in an array of descriptors in a hidden class. <br></li><li>  Slow properties are stored in a self-contained dictionary of properties, their meta-information is no longer stored in other structures of the hidden class. <br></li></ol><br><ul><li>  Slow properties allow efficient operations to add and remove properties, but they are not accessed as quickly as other properties. <br></li></ul><br><h2>  <font color="#3AC1EF">Items or indexed properties</font> </h2><br>  So far, we have been talking about named properties, now it's time to figure out the properties that are indexed by integers, which are usually used when working with arrays.  Support for such properties is no less complicated than support for named properties.  Indexed properties are always placed in a separate storage of items; however, this complicates the fact that there are <a href="">20</a> different item types! <br><br><h3>  <font color="#3AC1EF">‚ñçCombus and sparse arrays of elements</font> </h3><br>  The first major difference in how to work with array elements is whether they use solid or sparse arrays as their storage.  Empty spaces, or ‚Äúholes‚Äù in the repository, will appear when removing indexed items, or, for example, if there are items that have not been defined.  A simple example of an array with a "hole" - <code>[1,,3]</code> .  In this case, there is no second element in the array.  This problem is illustrated by the following example: <br><br><pre> <code class="hljs ruby">const o = [<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>]; console.log(o[<span class="hljs-number"><span class="hljs-number">1</span></span>]);          <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-string"><span class="hljs-string">"b"</span></span>. delete o[<span class="hljs-number"><span class="hljs-number">1</span></span>];                <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ¬´¬ª. console.log(o[<span class="hljs-number"><span class="hljs-number">1</span></span>]);          <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>;  <span class="hljs-number"><span class="hljs-number">1</span></span>  . o.__proto_<span class="hljs-number"><span class="hljs-number">_</span></span> = {<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-string"><span class="hljs-string">"B"</span></span>};     <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">1</span></span>  . console.log(o[<span class="hljs-number"><span class="hljs-number">0</span></span>]);          <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-string"><span class="hljs-string">"a"</span></span>. console.log(o[<span class="hljs-number"><span class="hljs-number">1</span></span>]);          <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-string"><span class="hljs-string">"B"</span></span>. console.log(o[<span class="hljs-number"><span class="hljs-number">2</span></span>]);          <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-string"><span class="hljs-string">"c"</span></span>. console.log(o[<span class="hljs-number"><span class="hljs-number">3</span></span>]);          <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  undefined</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f8/152/a3f/4f8152a3fda16729e6cfae9149e2df08.png"></div><br>  <i><font color="#999999">Problems when using a sparse array to store items</font></i> <br><br>  If we describe it in a nutshell, then it turns out that if the properties are not in the object to which we are referring, we need to go through a chain of prototypes.  Given that the array elements are self-sufficient, that is, we do not store information about existing indexed properties in a hidden class, we need a special value, called <code>the_hole</code> , that marks non-existent values.  This is very bad for the performance of the functions of the <code>Array</code> object.  If we know that there are no ‚Äúholes‚Äù in the repository, that is, the element repository does not contain information about the missing values ‚Äã‚Äãin the array, we can perform local operations without the need for slow search in the prototype chain. <br><br><h3>  <font color="#3AC1EF">‚ñçQuick and Vocabulary Items</font> </h3><br>  The next sign by which the elements of the arrays can be separated is the speed of working with them, depending on their internal representation.  "Slow" items are stored in the dictionary.  Work with the "fast" elements is carried out using conventional internal arrays of the virtual machine.  Here the index of the item is mapped to the index in the item store.  However, such a simple representation of arrays is too uneconomical for very large sparse arrays, in which only a relatively small number of cells are occupied.  In such cases, we use a dictionary-based representation of arrays.  This saves memory at the cost of slowing down access to the elements: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sparseArray = []; sparseArray[<span class="hljs-number"><span class="hljs-number">9999</span></span>] = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,     </span></span></code> </pre> <br>  In this example, allocating memory for an array with 10,000 entries would be quite wasteful in terms of memory usage.  Instead, V8 creates an array where triplets of the <code>--</code> type are stored.  The key in this case will be <code>9999</code> , the value is <code>foo</code> and the standard descriptor.  In addition, it should be noted that given the fact that we have no way to store the details of the descriptor in a hidden class, V8 switches to using the slow way of storing items every time we set the indexed properties with its own descriptor: <br><br><pre> <code class="hljs pgsql">const <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> = []; <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: "fixed", configurable: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>}); console.log(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]);      //  "fixed". <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] = "other value";   //      <span class="hljs-number"><span class="hljs-number">0.</span></span> console.log(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]);      //   "fixed".</code> </pre> <br>  In this example, we added an unconfigurable item to the array.  This information is stored in that part of the triplet of a slow vocabulary element that is related to the descriptor.  It is important to note that the functions of the <code>Array</code> object work much slower with arrays whose elements are stored in dictionaries. <br><br><h3>  <font color="#3AC1EF">‚ñçSmi and Double Elements</font> </h3><br>  In the V8, fast elements are differentiated by one more attribute.  For example, if you store only integers in an <code>Array</code> object, and this happens often, the garbage collector does not need to analyze the array, since integers are directly encoded into so-called small integers (small integer, smi).  Another special case is arrays that contain only double precision numbers (double).  Unlike small integers, floating point numbers are usually represented as an integer object, taking up a few words.  However, V8 stores the usual double precision numbers in the form of double arrays in order to avoid unnecessary load on the memory and not to occupy the computer with unnecessary calculations.  The following example shows four variants of arrays with Smi and Double elements: <br><br><pre> <code class="hljs ruby">const a1 = [<span class="hljs-number"><span class="hljs-number">1</span></span>,   <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Smi,   const a2 = [<span class="hljs-number"><span class="hljs-number">1</span></span>,    , <span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Smi,  ,     a2[<span class="hljs-number"><span class="hljs-number">1</span></span>]   const b1 = [<span class="hljs-number"><span class="hljs-number">1.1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Double,   const b2 = [<span class="hljs-number"><span class="hljs-number">1.1</span></span>,  , <span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Double,  ,     b2[<span class="hljs-number"><span class="hljs-number">1</span></span>]  </code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçSome other types of items</font> </h3><br>  What we talked about above allowed us to describe 7 of the 20 different types of array elements.  We, in order not to complicate the narration, did not describe 9 types of elements for typed arrays and two more for wrapping strings.  In addition, we did not talk about two special kinds of elements for argument objects.  They, although we mentioned them last, are no less important than other types of elements. <br><br><h3>  <font color="#3AC1EF">‚ñçElementAccessor</font> </h3><br>  We think it is quite understandable that we do not really strive to rewrite all functions for an <code>Array</code> object 20 times in C ++ - according to the number of kinds of elements.  This is where some of the special features of C ++ appear.  Instead of creating a lot of functions for an <code>Array</code> object, we created <code>ElementAccessor</code> , where we mostly need to implement only simple functions that access elements from the repository. <br><br>  <code>ElementAccessor</code> uses the <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a> technique to create specialized versions of functions for an <code>Array</code> object.  Therefore, if you call something like the <code>slice</code> method for an array, the built-in mechanism written in C ++ is activated in V8 and a transition is made, via <code>ElementAccessor</code> , to a specialized version of the function: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa5/6c7/136/aa56c7136de2b0d1aed8dca1945b8a90.png"></div><br>  <i><font color="#999999">Call Forwarding based on item view and custom implementation optimized for a specific item type</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç Conclusions</font> </h3><br><ul><li>  There are fast, array-based, and slower, dictionary-based, indexed properties. <br></li><li>  Fast properties can be represented by continuous arrays, or, when deleting elements, sparse arrays. <br></li><li>  Elements are specialized in content to speed up the functions of an <code>Array</code> object and reduce the load on the system that the garbage collector creates. <br></li></ul><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Understanding how properties work in V8 is the key to many optimizations.  JS developers do not interact directly with the mechanisms described here.  However, knowing how work with properties in V8 is organized helps to understand why some design patterns produce faster code than others.  For example, changing the type of a property of an object or an element of an array usually leads to the fact that V8 creates a new hidden class, which can lead to type clogging and prevent V8 from generating optimized code. <br><br>  Dear readers!  Tell me, have you encountered an incomprehensible decrease in JS code performance, which can be explained and corrected using this material? </div><p>Source: <a href="https://habr.com/ru/post/337300/">https://habr.com/ru/post/337300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337288/index.html">Using the KOMPAS-3D API ‚Üí Lesson 4 ‚Üí Title bar</a></li>
<li><a href="../337290/index.html">Fedora Linux is banned for distribution in the Crimea (and temporarily broken DNS)</a></li>
<li><a href="../337292/index.html">Custom properties</a></li>
<li><a href="../337294/index.html">About distinguishing objects by color</a></li>
<li><a href="../337298/index.html">In the wake of highloadcup: php vs node.js vs go, swoole vs workerman, splfixedarray vs array and more</a></li>
<li><a href="../337302/index.html">git rebase for beginners</a></li>
<li><a href="../337304/index.html">Ransomware hackers hacked more than 26,000 MongoDB servers</a></li>
<li><a href="../337306/index.html">Docker Basics in X hours and Y days</a></li>
<li><a href="../337308/index.html">Lannisters always pay their debts! (and technical too)</a></li>
<li><a href="../337310/index.html">Mathematical modeling of traffic flows</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>