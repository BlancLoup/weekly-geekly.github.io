<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Checking a Microsoft Orleans project with PVS-Studio</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Good day to all. 

 Initially, a small Disclaimer for doubters: yes, for this post, I might get a license for PVS-Studio to check the o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Checking a Microsoft Orleans project with PVS-Studio</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  Good day to all. <br><br>  Initially, a small Disclaimer for doubters: yes, for this post, I might get a license for PVS-Studio to check the open-source Microsoft Orleans project.  And maybe I will not get it, as the chip will fall, sir.  No, I was not directly connected with the company "Program Verification Company" in any way and wrote this post on my own initiative. <br><br>  And now let's get to the bottom line. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio 6.0</a> , as stated by the official website of the company, is a static code analyzer focused on ease of use and searching for errors at the stage of writing code. <br><br>  And relatively recently, the company has released a version that supports checking for C # projects.  Than we actually will check the Microsoft Orleans project. <br><br>  By the way, the PVS-Studio team also checked the Orleans project for detected errors, but I was a little ahead of them and they kindly provided me with their KDPV ("picture to attract attention") with the invariably pleasing unicorn. <br><br><img src="http://centur.github.io/article_images/PVS-Orleans/OrleansAndPVS.png" alt="PVS-Unicorn-In-Clouds"><br><br><a name="habracut"></a><br><hr><br><h2>  What is the project Orleans, Virtual actors and what is their profit. </h2><br><img src="https://raw.githubusercontent.com/dotnet/orleans/gh-pages/Icons/Orleans/OrleansSDK_128x.png" alt="Microsoft Orleans logo" title="Logo Title Text 2"><br><br>  <a href="https://github.com/dotnet/orleans">Microsoft Orleans</a> is a framework that is built on the concept of virtual actors.  The Orleans terminology is slightly different from other similar frameworks (Akka.Net, Service Fabric, Erlang Actors): The actors are called <strong>Grains</strong> (aka grain), and the servers participating in the cluster are <strong>Silo</strong> . <br><br>  The advantage of virtual actors is that at any moment your code can get a proxy from Orleans Runtime to access a specific Grain via its interface and Id.  When calling a proxy method, a message is sent to a cluster of several servers, where it will be delivered to the Grain with the specified Id.  Runtime guarantees that such a Grain will be created in a single copy on one of the servers and subsequent calls will be delivered to it.  Runtime also automatically deletes from the memory (deactivates) Grains that did not receive calls for a specified time, thus constantly collecting garbage.  If the server on which your grain was previously, went offline - Runtime will quickly raise an instance on another one and you will not notice anything, except for a small delay.  If the call should come on the same server - Runtime optimizes this and the call will be local. <br><br>  Actually, the profit of virtual actors is that it all scales very easily in the clouds: <br>  Silo ping each other and determine when someone is not available, redistribute the grains of the "fallen comrade" among themselves and all that.  The cluster happily lives and is available, as long as there is at least one active Silo, and when new members are connected, they will receive their range of "grains" and begin actively processing requests.  And you write your code using the usual OOP approach.  It turns out this, as it were, "Distributed C # /. NET". <br><br>  Even the runtime itself guarantees that when the method is performed on grain, no other call will come to the same grain, i.e.  Runtime guarantees single-threaded execution of your code, which allows you to think less about all non-thread-safe situations and focus more on writing useful business logic. <br><br>  In general, there are still many other interesting things, such as replaceable storage providers, messaging, pub-sub and other useful things for developing applications for cloud (or distributed on-prem) platforms. <br>  More information about the project can be found here - <a href="http://dotnet.github.io/orleans/">Microsoft Orleans @ GitHub</a> .  Microsoft Orleans has been well tested in large-scale projects - this framework is used on the back end of the games Halo 4 and Halo 5 - it collects information about all the games, aggregates statistics, etc. <br><br><hr><br><h2>  Why did you want to check out the Orleans </h2><br>  Well, first of all, we ourselves use Orleans to create our cloud platform in Drawboard and want to rely on a convenient and reliable framework. <br><br>  Secondly, the concepts and guarantees embodied in Orleans are rather non-trivial and the quality of the cluster depends on their implementation. <br><br>  Thirdly - it was just interesting to try PVS-Studio with C # - the product team writes excellent articles about checking C ++ projects, but C # was somehow deprived of attention until recently. <br><br><hr><br><h2>  Test results </h2><br>  The Microsoft Orleans project is developing very dynamically and, obviously, a one-time check will help to find questionable places - in the long run the overall quality will not be affected much. <br><br>  So, as of the time of merge PR # 1288 <code>4/02/2016 2:43:26 PM, Commit hash: 7c1e35466fde08fcf1c2caf64fa304d25e60e045</code> PVS-Studio (version 6.01.15638.1) issued: <br><br><ul><li>  18 High-severity alerts </li><li>  7 Medium-severity warnings </li><li>  58 Low-severity alerts </li></ul><br>  It is hard to say whether this is good or bad, because it cannot be compared with other projects tested by PVS-Studio - different complexity, amount of code, competence of developers and many other factors. <br>  But in general - it does not look the worst result, the number of suspicious places is not expressed by a three or four-digit number - everything can be viewed and processed in a day. <br><br>  Let's see whether PVS-Studio will find something serious. <br><br>  And yet - here is a table that shows the separation of errors between the main code (Runtime and auxiliary projects) and the code in the tests: <br><br><table><thead><tr><th>  Severity </th><th>  Total </th><th>  Runtime </th><th>  Tests </th></tr></thead><tbody><tr><td>  High </td><td>  18 </td><td>  12 <code>*</code> </td><td>  6 </td></tr><tr><td>  Medium </td><td>  7 </td><td>  four </td><td>  3 </td></tr><tr><td>  Low </td><td>  58 </td><td>  13 </td><td>  45 </td></tr></tbody></table><br>  <code>*</code> - 4 warnings for improper use of Replace in one method, 3 warnings in less-used code.  Total ~ 5 which should be noted. <br><br>  I will walk, basically, on errors in Runtime, since  test errors are usually less critical.  Although they can create the illusion that everything is OK, but in reality in reality everything will not be so rosy ... <br><br><h3>  Critical warnings found in the project </h3><br>  Let's start with the most interesting and quite serious.  The developers of the project, it turns out, also encountered a problem that goes back to this bug. <br><br><blockquote>  (this is from a gitter-chat project about a problem found): <br>  ... an embarrassing bug in SanitizeTableProperty that IIRC puzzled us recently. <br>  ... were sure the sanitization worked. </blockquote><br>  PVS-Studio issued the following warning: <br><br><blockquote>  <strong>V3010 The return value of the function 'Replace' is required to be utilized.</strong>  <strong>AzureStorageUtils.cs 278,279,280,281</strong> </blockquote><br>  And at the specified address was <em>(the bug has already been fixed)</em> method: <br><br><pre> <code class="hljs coffeescript">public static string SanitizeTableProperty(string key) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Remove any characters that can<span class="hljs-string"><span class="hljs-string">'t be used in Azure PartitionKey or RowKey values key.Replace('</span></span><span class="hljs-regexp"><span class="hljs-regexp">/', '_'); /</span></span>/ Forward slash key.Replace(<span class="hljs-string"><span class="hljs-string">'\\'</span></span>, <span class="hljs-string"><span class="hljs-string">'_'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Backslash key.Replace(<span class="hljs-string"><span class="hljs-string">'#'</span></span>, <span class="hljs-string"><span class="hljs-string">'_'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Pound sign key.Replace(<span class="hljs-string"><span class="hljs-string">'?'</span></span>, <span class="hljs-string"><span class="hljs-string">'_'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Question mark <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key.Length &gt;= <span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(string.Format(<span class="hljs-string"><span class="hljs-string">"Key length {0} is too long to be an Azure table key. Key={1}"</span></span>, key.Length, key)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> key; }</code> </pre> <br>  Quite a cool bug, straight snake oil <em>(... and here it was slowly an epiphany that this bug probably got out in our code a couple of times ....)</em> . <br>  The key parameter of type string is also passed to the method.  Strings in .NET are immutable, so no matter how many times we call the <code>key.Replace</code> , the value will not change. <br><br>  Next good find - <br><br><blockquote>  <strong>V3006 The object was not used.</strong>  <strong>The 'throw' keyword could be missing: throw new InconsistentStateException (FOO).</strong>  <strong>MemoryStorageGrain.cs 129</strong> </blockquote><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentETag != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">error</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"Etag mismatch during {0} for grain {1}: Expected = {2} Received = null"</span></span>, operation, grainStoreKey, currentETag.ToString()); logger.Warn(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InconsistentStateException(<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>); }</code> </pre> <br>  A new exception is created, but not thrown.  Those.  if during the recording Etag = null is sent and this is the first record, no error occurs  Slightly lower in the same method, another exception is still thrown ‚Äî that is,  we have a missed problem here. <br><br>  Another warning: <br><br><blockquote>  <strong>V3005 The 'jsonSettings' variable is assigned to itself.</strong>  <strong>AzureTableStorage.cs 104</strong> </blockquote><br>  When reading the configuration, the serialization settings in the jsonSettings variable are initialized 2 times: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (useJsonFormat) { <span class="hljs-attribute"><span class="hljs-attribute">jsonSettings</span></span> = jsonSettings = OrleansJsonSerializer.SerializerSettings; }</code> </pre> <br>  Not very critical problem, for me it looks like the result of refactoring - in the "past life" one of these variables was most likely called differently.  Then a separate variable for default settings was removed, and the assignment remained. <br><br>  The following (false alarm in our case): <br><br><blockquote>  ** V3022 Expression 'USE_DEBUG_CONTEXT_PARAMS &amp;&amp; arguments! = Null &amp;&amp; arguments.Length&gt; 0' is always false.  GrainReference.cs 480 *** </blockquote><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">NonSerialized</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> USE_DEBUG_CONTEXT_PARAMS = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (USE_DEBUG_CONTEXT_PARAMS &amp;&amp; arguments != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; arguments.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ... }</code> </pre> <br>  Debug flag, compiler optimizes this branch if.  Not very critical, from the context it is clear what will happen.  But to check such places is still useful - to make sure that the important and necessary code will not be "c-optimized". <br><br>  This warning was found in little-used code, so this site did not cause any special problems, but it could: <br><br><blockquote>  <strong>V3025 Incorrect format.</strong>  <strong>A different number of formatted items is expected while calling 'Format' function.</strong>  <strong>Expected: 3. Present: 2. Program.cs 169,183</strong> </blockquote><br><pre> <code class="hljs cs">WriteStatus(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"**Calling DeleteGrain({0}, {1}, {2})"</span></span>, silo, grainId)); WriteStatus(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"**Calling LookupGrain({0}, {1}, {2})"</span></span>, silo, grainId));</code> </pre> <br>  It may seem that this is not such a significant error, well, logger, well, something does not write.  But no.  In fact, there will fly - <br><br> <code>FormatException: Index (zero based) must be greater than or equal to zero and less than the size of the argument list.</code> <br> <br>  And the next warning can signal real problems in the logic of the code, in Orleans this, fortunately, is only logging - <br><br><blockquote>  <strong>V3033 It is possible that this "else" branch must apply.</strong>  <strong>Interner.cs 251</strong> </blockquote><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InternCacheCleanupTimerCallback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> numRemoved = numEntries - internCache.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numRemoved&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logger.IsVerbose) logger.Verbose(ErrorCode.Runtime_Error_100296, <span class="hljs-string"><span class="hljs-string">"Removed {0} / {1} unused {2} entries in {3}"</span></span>, numRemoved, numEntries, internCacheName, clock.Elapsed); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logger.IsVerbose2) logger.Verbose2(ErrorCode.Runtime_Error_100296, <span class="hljs-string"><span class="hljs-string">"Removed {0} / {1} unused {2} entries in {3}"</span></span>, numRemoved, numEntries, internCacheName, clock.Elapsed); }</code> </pre> <br>  This is a stylistically complex code - it is not very clear what they wanted to do.  Of course, you can figure it out, but this style not only breaks the eyes of the reader, but also opens up possibilities for all sorts of unpleasant bugs like Apple's surprise. <br><br><blockquote>  Apple certificate check bug: <br>  if ((err = SSLHashSHA1.update (&amp; hashCtx, &amp; serverRandom))! = 0) <br>  goto fail; <br>  if ((err = SSLHashSHA1.update (&amp; hashCtx, &amp; signedParams))! = 0) <br>  goto fail; <br>  goto fail; </blockquote><br>  In order that such things do not appear - there is StyleCop and many other methods of "forcing the right style."  And they are also useful to use. <br><br>  Another warning, also minor in this case, is simply a redundant check.  But if the check is computationally "expensive" - ‚Äã‚Äãit is worth getting rid of it. <br><br><blockquote>  <strong>V3053 An excessive expression.</strong>  <strong>Examine the substrings '/ bootstrap' and '/ boot'.</strong>  <strong>ClientGenerator.cs 310</strong> </blockquote><br><pre> <code class="hljs lua"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arg</span></span>.StartsWith(<span class="hljs-string"><span class="hljs-string">"/bootstrap"</span></span>) || <span class="hljs-built_in"><span class="hljs-built_in">arg</span></span>.StartsWith(<span class="hljs-string"><span class="hljs-string">"/boot"</span></span>)){...}</code> </pre> <br>  On this critical errors that are worthy of attention, end and ahead a little more <code>Medium</code> and more <code>Low</code> . <br><br><h3>  Found errors of moderate severity </h3><br>  The first is an example of a warning, which can be either a signal of a problem or a reason for a holivar. <br><br><blockquote>  <strong>V3054 Potentially unsafe double-checked locking.</strong>  <strong>Use volatile variable (s) or synchronization primitives to avoid this.</strong>  <strong>StreamImpl.cs 142, 144</strong> </blockquote><br>  Sample code is a bit cut, only the main sections are left with some comments. <br><br><pre> <code class="hljs coffeescript">private readonly object initLock; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> need the lock since the same code runs <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the provider <span class="hljs-literal"><span class="hljs-literal">on</span></span> the ... internal IAsyncBatchObserver&lt;T&gt; GetProducerInterface() { -&gt;&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> so anonical double-checked locking, effectively doing the same, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (producerInterface != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> producerInterface; lock (initLock) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (producerInterface != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> producerInterface; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (provider == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) provider = GetStreamProvider(); producerInterface = provider.GetProducerInterface&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> producerInterface; } internal IInternalAsyncObservable&lt;T&gt; GetConsumerInterface() { -&gt;&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Canonical double-checked locking <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (consumerInterface == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { lock (initLock) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (consumerInterface == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (provider == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) provider = GetStreamProvider(); consumerInterface = provider.GetConsumerInterface&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> consumerInterface; }</code> </pre> <br>  Here we have two examples of applying the <a href="https://en.wikipedia.org/wiki/Double-checked_locking">Double-checked locking</a> pattern.  <em>Chuck Norris of the .NET world</em> (aka Jon Skeet) in the article <a href="http://csharpindepth.com/Articles/General/Singleton.aspx">Implementing the Singleton Pattern in C #</a> provides a more elegant and reliable implementation if you need a singleton. <br><br>  I also wanted to write that: <br><br><blockquote>  But personally, this code gives me one more doubt: in all articles and examples, this pattern always uses <code>lock</code> on a <code>static</code> object, and here I am not very sure that it can be used on non- <code>static</code> locks with guaranteed reliable results ... </blockquote><br>  But, after talking with the developers and reading this article of <a href="http://joeduffyblog.com/2010/12/04/sayonara-volatile/">Sayonara volatile by Joe Duffy</a> , I agree that since  In our case, this is not a singleton, it is acceptable to use a non-static field.  And without volatile. <br><br>  In general, studying this error, I discovered such a "can of worms" that I don‚Äôt even know if it‚Äôs a problem in the code or specifically with this diagnostics in PVS-Studio. <br><br>  But the fact that the tool can catch such patterns in general is, imho, great.  And I hope that in the future we will see more sophisticated warnings, good and different. <br><br>  Let's move on to another good example, a bug that is very badly caught by a person, but it is easy with an analyzer: <br><br><blockquote>  <strong>V3022 Expression 'n1 == 0 &amp;&amp; n1! = 0' is always false.</strong>  <strong>Unsigned type value is always&gt; = 0. Probably the '||'</strong>  <strong>operator should be used here.</strong>  <strong>UniqueKey.cs 113</strong> </blockquote><br><pre> <code class="hljs pgsql">private static UniqueKey NewKey(ulong n0, ulong n1, Category category, long typeData, string keyExt) { // <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the string representation <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> a key, we grab the least significant half <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> n1. // therefore, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n0 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> non-zero <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> n1 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> the string representation will <span class="hljs-keyword"><span class="hljs-keyword">always</span></span> be // <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> useful <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> identification <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the grain. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n1 == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; n1 != <span class="hljs-number"><span class="hljs-number">0</span></span>) throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArgumentException("n0 cannot be zero unless n1 is non-zero.", "n0");</code> </pre> <br>  Here it was necessary to check n0! = 0, as written in the comments to this code, and in the current implementation, the check is always false.  Again, a good Coding-style could help in this case - if the variables were not called <code>n0</code> and <code>n1</code> , and for example <code>firstHalf</code> and <code>secondhHalf</code> , the error would be more pronounced.  Compare: <br><br><pre> <code class="hljs lisp">if (<span class="hljs-name"><span class="hljs-name">firstHalf</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;&amp;</span></span> secondHalf != <span class="hljs-number"><span class="hljs-number">0</span></span>) vs if (<span class="hljs-name"><span class="hljs-name">secondHalf</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;&amp;</span></span> secondHalf != <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Warning about the same code in two different methods - <br><br><blockquote>  <strong>V3013 It is odd that the body of the 'IncrementMetric' function is fully equivalent to the body of the 'DecrementMetric' function (1079, line 1095).</strong>  <strong>TraceLogger.cs 1079</strong> </blockquote><br>  Spaced Copy-Paste, between these 2 methods there is also the correct implementation <br>  decrement, which reduces the metric. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncrementMetric</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tc <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> TelemetryConsumers.OfType&lt;IMetricTelemetryConsumer&gt;()) { -&gt;&gt; tc.IncrementMetric(name, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecrementMetric</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tc <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> TelemetryConsumers.OfType&lt;IMetricTelemetryConsumer&gt;()) { -&gt;&gt; tc.IncrementMetric(name, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } }</code> </pre> <br>  The same, but in tests: <br><br><blockquote>  <strong>V3013 It is odd that the body of the StartTimer function is fully equivalent to the body of the StopTimer function (183, line 188).</strong>  <strong>TimerOrleansTest.cs 183</strong> </blockquote><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartTimer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timerName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (persistant) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> persistantGrain.StartTimer(timerName); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grain.StartTimer(timerName); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StopTimer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timerName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (persistant) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> persistantGrain.StartTimer(timerName); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grain.StartTimer(timerName); }</code> </pre> <br>  This hello from Ctrl + C, Ctrl + V in tests can have worse consequences - the tests will be false-positive. <br><br>  Difficult code in tests can produce one error per 10 or 100 launches, then such a test also causes irritation: <br><br><blockquote>  <strong>V3032 Waiting for Compiler may be optimized for some of the variables.</strong>  <strong>Use volatile variable (s) or synchronization primitives to avoid this.</strong>  <strong>LoggerTest.cs 468</strong> </blockquote><br><pre> <code class="hljs pgsql">// Wait <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> the BulkMessageInterval <span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-type"><span class="hljs-type">interval</span></span> expires <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> wring the final <span class="hljs-keyword"><span class="hljs-keyword">log</span></span> message - should cause bulk message flush <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (stopwatch.Elapsed &lt;= TraceLogger.BulkMessageInterval) { Thread.Sleep(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre> <br>  Honestly, I myself do not very well understand how and why the cycle here can turn into an infinite, but an example in the description of this warning on the PVS-Studio website is more understandable <a href="http://www.viva64.com/en/d/0419/print/">V3032</a> . <br>  Not a big problem, because  the code in the tests, but even in theory, arbitrarily falling tests or hanging for a long time is not the most pleasant thing. <br><br>  And again the strange code in the tests - <br><br><blockquote>  <strong>V3051 An excessive type check.</strong>  <strong>The object is already of the 'Exception' type.</strong>  <strong>PersistenceGrainTests.cs 178</strong> </blockquote><br><pre> <code class="hljs pgsql">catch (AggregateException ae) { exceptionThrown = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> e = ae.GetBaseException(); -&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>) { // Expected error } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { throw e; } }</code> </pre> <br>  The exception will never be thrown again, because the code will never fall into the <code>else</code> branch.  Criticality depends on the context, in tests it may not be so scary, and in another code it is pure bug water. <br><br><h3>  Low-severity errors </h3><br>  PVS-Studio found quite a few comments in the tests, but after reviewing most of them, it can be concluded that there are no critical or high-impact problems among them.  It is quite difficult to comprehensively test such a product, and often you have to go for different tricks to cause a certain system behavior. <br><br>  For example, here: <br><br><blockquote>  <strong>V3008 The 'promise' variable is assigned values ‚Äã‚Äãtwice successively.</strong>  <strong>Perhaps this is a mistake.</strong>  <strong>Check lines: 91, 84. TestInternalGrains ErrorGrain.cs 91</strong> </blockquote><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> the grain method returns OK, but leaves some unobserved promise --&gt;&gt;Task&lt;long&gt; promise = Task&lt;long&gt;.Factory.StartNew(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!doThrow) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; logger.Info(<span class="hljs-string"><span class="hljs-string">"About to throw 1."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">"ErrorGrain left Immideate Unobserved Error 1."</span></span>); }); --&gt;&gt;promise = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; GC.Collect(); GC.WaitForPendingFinalizers(); GC.Collect(); GC.WaitForPendingFinalizers(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(<span class="hljs-number"><span class="hljs-number">11</span></span>);</code> </pre> <br>  The behavior of the code with the task that is compiled by the GC is checked. <br><br>  From what else some attention should be paid to (these errors can lead to incorrect expectations during tests): <br><br><blockquote>  <strong>V3013 It is the odd that the body of the ProduceSequentialSeries' function is fully equivalent to the body of the 'ProduceParallelSeries' function (618, line 625).</strong>  <strong>StreamingGrain.cs 618</strong> </blockquote><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProduceSequentialSeries</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.ProduceParallelSeries(count); State.Producers = _producers; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> WriteStateAsync(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProduceParallelSeries</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.ProduceParallelSeries(count); State.Producers = _producers; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> WriteStateAsync(); }</code> </pre> <br>  In a special test class, methods designed to generate sequential and parallel series of events always generate parallel ones.  Maybe this is OK, but then the semantics inside the test is misleading. <br><br><blockquote>  <strong>V3013 It is an odd that the body of the TestInitialize function is fully equivalent to the body of the TestClean function (44, line 52).</strong>  <strong>ConfigTests.cs 44</strong> </blockquote><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">TestInitialize</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestInitialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { TraceLogger.UnInitialize(); GrainClient.Uninitialize(); GrainClient.TestOnlyNoConnect = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } [TestCleanup] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestCleanup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { TraceLogger.UnInitialize(); GrainClient.Uninitialize(); GrainClient.TestOnlyNoConnect = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  In the configuration tests, the initialization and primitives are carried out for some reason at initialization and at completion. <br><br><blockquote>  <strong>V3043 The code's operational logic does not correspond with its formatting.</strong>  <strong>The statement is indented.</strong>  <strong>It is possible that curly brackets are missing.</strong>  <strong>RequestContextTest.cs 87,97,111,155,181</strong> </blockquote><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(msg.RequestContextData != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var kvp <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> msg.RequestContextData) { headers.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(kvp.Key, kvp.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); };</code> </pre> <br>  And nevertheless, I am a big supporter of strict coding-style rules.  Well, or at least automatic coercion to style, by StyleCop, Resharper or CodeFormatter.  It costs nothing, but it allows you not to break your eyes. <br><br>  <strong>V3052 The original exception object 'ae' was swallowed.</strong>  <strong>Stack of original exception could be lost.</strong>  <strong>GrainReferenceCastTests.cs 212</strong> <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-type"><span class="hljs-type">AggregateException</span></span> ae) { <span class="hljs-type"><span class="hljs-type">Exception</span></span> ex = ae.<span class="hljs-type"><span class="hljs-type">InnerException</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">AggregateException</span></span>) ex = ex.<span class="hljs-type"><span class="hljs-type">InnerException</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ex; }</code> </pre> <br>  Losing the stack AggregatedException.  I understand that for cases with other exceptions it is bad, but we in our project just "unwind" AggregatedException.  I would write it in false-positive if the catch section is AggregatedException. <br><br><h3>  Evaluation of the criticality of found bugs by the project developers. </h3><br>  Of all the error reports sent, after 3 hours 5 marked as bug, 1 critical with <code>Replace</code> fixed.  Pretty good catch for 20 minutes of static analysis in automatic mode. <br><br><h2>  Why Code analysis is not just another favor of the month. </h2><br><hr><br>  The Orleans project is developing very intensively, the frequency of commits is very high, Gihub confirms this - <a href="https://github.com/dotnet/orleans/graphs/contributors">Orleans-contributors</a> .  During the writing of the article, I checked the project several times, keeping the analysis logs.  Including different versions of PVS Studio (6.0 and 6.01). <br><br>  Here is a comparison of different logs: <br><br><table><thead><tr><th>  Priority </th><th>  28 Jan </th><th>  Feb 2 </th><th>  4 Feb v6.01 </th><th>  Comments </th></tr></thead><tbody><tr><td>  High </td><td>  nineteen </td><td>  21 </td><td>  18 </td><td>  Two days -3 critical errors - which is good.  But, for example, 2 of them were analogs of V3025 described above.  One could not even check such code. </td></tr><tr><td>  Medium </td><td>  four </td><td>  four </td><td>  7 </td><td>  For the same 2 days, 3 warnings of moderate severity. </td></tr><tr><td>  Low </td><td>  52 </td><td>  46 </td><td>  58 </td><td>  And +12 new sloppy code areas. </td></tr></tbody></table><br>  As can be seen from the table, critical errors appear and disappear in a very short time.  Where it is more convenient to catch them as a result of the analysis immediately after the build, and not after hours of debugging or the fall of production, it saves time and nerves of the programmer.  This is, of course, a commonplace thing in the series <em>‚ÄúIt‚Äôs better to be rich and healthy than poor and sick‚Äù</em> , but if there are still programmers who don‚Äôt use at least some available static code analyzer - ‚ÄúYou're doing it wrong‚Äù ... <br><br>  In terms of ease of use, integration with PVS-Studio with Visual Studio 2015 is quite simple - there is an <code>Analyze with PVS-Studio</code> item with a clearly visible green icon in the context menu of the Solution Explorer on the C # file, project, or root solution.  Pretty easy to find.  If only in this context menu there are no 100,500 items from other extensions.  It would be interesting to see some auxiliary nuget package that could easily run the analysis from the command line so that you can open the Package Manger Console or build.cmd and say <code>PVS-Solution</code> or <code>PVS-Project Orleans</code> , well, in the future it's all like built into the xproj mechanisms of the new CoreCLR. <br><br>  However, <code>Ctrl+Q, PVS ... Down, Down, Down, Down, Enter</code> enough for a quick start :). <br><br><h2>  Conclusion </h2><br><hr><br>  Modern realities of development set a very high level in the speed of development - everyone is trying to run forward very quickly to at least remain at the level of competitors in the industry.  Naturally, with such a speed of development, you can miss something or write carelessly.  An extensive set of tests helps in identifying problem areas and regressions, but this is also not a panacea - there are errors in tests, and the creation of such a set, as well as keeping it up to date, takes time and effort. <br><br>  Any statistical analyzer, be it Visual Studio warnings, Resharper analyzers or PVS-Studio, is another tool in the developer‚Äôs collection and assistant in detecting potential problems with code.  Use at least what is available for free.  For example, on all our projects, the default mode is Enable Warnings as Errors, which helps to write code a little more disciplined.  It costs the programmer nothing, but can save him from shots in his leg.  Modern analyzers are very easy to use, in most cases everything works fine out of the box and the only thing that can somehow justify the non-use of analyzers is a matter of price. <br><br>  NB: <em>The author thanks the PVS-Studio team for providing a temporary license for testing.</em> <br><br>  All read - Happy and bug-free programming! <br></div><p>Source: <a href="https://habr.com/ru/post/276727/">https://habr.com/ru/post/276727/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276711/index.html">SQLite Query Profiling for Qt Applications</a></li>
<li><a href="../276715/index.html">3CX SBC - now with encryption and resiliency</a></li>
<li><a href="../276719/index.html">java.net.URL or the old horse will not spoil the furrow</a></li>
<li><a href="../276723/index.html">View the source (almost) total</a></li>
<li><a href="../276725/index.html">Monitoring Task Execution in IPython Notebook</a></li>
<li><a href="../276729/index.html">How to get a Spring logger</a></li>
<li><a href="../276731/index.html">Full-featured REST API for perfectionists in 5 minutes</a></li>
<li><a href="../276737/index.html">The digest of interesting materials for the mobile # 139 developer (February 1-7)</a></li>
<li><a href="../276739/index.html">Why Yandex refused to confirm sites txt file</a></li>
<li><a href="../276741/index.html">‚ÄúDevilish‚Äù ACL - my version of rights verification</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>