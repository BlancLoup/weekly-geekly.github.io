<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing API Call Interception</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Monitor. Excellent word, however, combines a whole bunch of concepts. Well, for example, for the first time this word was applied in 1861 to the battl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing API Call Interception</h1><div class="post__text post__text-html js-mediator-article">  Monitor.  Excellent word, however, combines a whole bunch of concepts.  Well, for example, for the first time this word was applied in 1861 to the battleship USS Monitor.  A little later, this word began to be called displays.  After some more, things that were more familiar to us, like performance counters, entered the glorious cohort of monitors, and with them a whole bunch of various software whose main task is monitoring ‚Äî that is, monitoring. <br><br>  The task of the monitor is simple - in fact it is an observer, although it can also act as a manager, by the way one of the translation options for ‚ÄúMonitor‚Äù is a mentor.  Its objectives are also obvious, to give a set of data on the basis of which it is possible to analyze the situation and draw the appropriate conclusions. <br><br>  In modern software, monitors are found almost everywhere, well, for example, the same Punto Switcher is a classic example of a legal monitor.  Almost all antiviruses are monitors, profilers, well, I'm not talking about our main toolkit - the debugger, which is also a monitor. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      On the reverse side of the barricades, whole heaps of malicious software appear, some of which also prefer to use monitoring to achieve their main goals.  But not about them now ... <br><br>  On the Internet at the moment there is simply an incredible number of examples of software function monitors, although in most cases it is considered interception by editing the import table, or installing an interceptor at the beginning of the intercepted function (so-called splicing).  But despite the availability of these materials, sometimes they do not help developers, because they are written too (let's say) abstruse language, or even represent a piece of code torn out of context, incomprehensible to a non-savvy developer. <br><br>  So it happened with me, over the last month several people addressed me with the question of how to implement the interceptor correctly and the references to the examples practically did not help them, I had to chew everything from scratch.  But now I am aware of the basic mistakes encountered by people just starting to deal with interception techniques. <br><br>  As a result, in order not to explain everything next time again, I decided to make an overview article where I would try to tell everything in as simple a language as possible, ‚Äúhow it works.‚Äù <br><a name="habracut"></a><br><br><h4>  1. The essence of the monitor </h4><br>  The main task of the monitor in any way available to him to learn about the transfer of control to the function he controls. <br><br>  For this, various variants of intercepting calls to the original function are used, with the help of which control is transferred to the ‚Äúinterception handler‚Äù (or ‚Äúinterceptor‚Äù, to whom it is more convenient). <br><br>  What to do with the intercepted function further depends on the implementation of the interceptor.  You can display in the log the parameters of its call, well, if desired, other parameters, such as its results, the state of the call stack, etc.  The main thing is to take control over yourself. <br><br>  I can say that you almost guaranteed to have previously written function interceptors yourself.  The concept of OOP greatly contributes to this.  Any class in which you overlap virtual or dynamic methods can already be called monitored by your monitor.  After all, in reality, override methods that are overlapped are directly final handlers of intercepted functions, and we don‚Äôt even have to think about how it actually works inside there and the challenge of the original method will not even cause difficulties for us, there is a regular inherited call for this.  The compiler has already done everything for us. <br><br>  But we have to dig a little deeper.  For example, with static methods such a focus will not pass and if there is a need for such an overlap, you will have to do everything yourself.  However, before proceeding directly to monitoring, it is necessary to deal with the implementation of the interception handler. <br><br><h4>  2. Correct interception handler declaration </h4><br>  Before proceeding to the interception of any function, it is necessary to know the parameters of its call and the calling convention.  That is, if we want to intercept for example MessageBoxA, then the interceptor, which will work instead of the original function, should have the following form: <br><br><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterceptedMessageBoxA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hWnd: HWND; lpText, lpCaption: PAnsiChar; uType: UINT)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// TODO... end;</span></span></code> </pre> <br>  That is, the parameters of the interception handler and the calling convention (stdcall / cdecl, etc.) must exactly match the original function.  If this is not done, there will almost certainly be an error after calling the handler. <br><br>  The correct handler declaration is needed primarily for ease of operation.  You can, of course, write such a handler: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterceptedFunc</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// TODO... end;</span></span></code> </pre><br>  But in this case, it will be necessary to get the call parameters and make the correct call finalization taking into account agreements and the number of parameters using assembler inserts. <br><br>  A small nuance will be with the implementation of the function / procedure interceptor implemented in the form of class methods. <br><br>  Suppose we intercept a TApplication.MessageBox. <br>  If the interception handler is implemented as a class method, then its declaration will look like the original function: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTestClas</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterceptedApplicationMessageBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Text, Caption: PChar; Flags: Longint)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// TODO... end;</span></span></code> </pre><br>  If the interceptor is an independent function, then its implementation will look a little different: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterceptedApplicationMessageBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Self: TObject; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Text, Caption: PChar; Flags: Longint)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// TODO... end;</span></span></code> </pre><br>  Such differences in the handler's declaration are due to the fact that the class parameter of the class methods is not the explicitly declared Self variable. <br><br>  By the way, if you try in the first interceptor to get the class name of this variable, for example like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTestClas</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterceptedApplicationMessageBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Text, Caption: PChar; Flags: Longint)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(Self.ClassName); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  ... then the text TApplication will be displayed, not TTestClass, since  Self parameter will contain data about the original class, and not about the class in which the interceptor is implemented. <br><br>  In principle, this is all you need to know about the interception handler declaration, you can now start to consider various ways to intercept functions. <br><br><h4>  3. Subclassing window procedure </h4><br>  For a long time I chose where to start the technical part and eventually decided to dwell on documented methods.  Indeed, why reinvent the next bike - it's easier to bend the one that is. <br><br>  I do not think that it will be a secret to you that the VCL is essentially just a wrapper over the API.  Most of the visual elements on the form, and the form itself is a window, which, among other parameters, has a window procedure.  If a programmer has a task that requires changing the standard behavior of the window, he applies subclassing, replacing the window procedure handler with his own, where he implements the functionality he needs. <br><br>  The technique is quite common, and when implementing your own controls in Delphi, you almost always encounter the result of overlapping the window procedure of all your windows with the global handler TWinControl.MainWndProc.  This is really quite a convenient solution that allows us to override certain messages in the code by specifying message + message constant, working with the virtual WndProc and DefaultHandler, and so on ... <br><br>  A general description of this method can be found at this link: <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms633570(v%3Dvs.85).aspx">Subclassing a Window</a> <br><br>  The implementation algorithm can be presented in the form of five points: <br><ol><li>  getting the address of the original window procedure </li><li>  storing it in any place accessible to the processor </li><li>  assigning a new window procedure handler </li><li>  processing the interceptor call (logging / changing call parameters, etc.) </li><li>  if necessary, obtain the address of the old handler and call it. </li></ol><br>  In the form of code, everything looks quite simple. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> uSubClass; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows, Messages, Classes, Controls, Forms, StdCtrls; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TForm1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TForm) Button1: TButton; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Form1: TForm1; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R *.dfm}</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainFormSubclassProc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hwnd: THandle; uMsg: UINT; wParam: WPARAM; lParam: WPARAM)</span></span></span><span class="hljs-function">:</span></span> LRESULT; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> OldWndProc: Pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> uMsg = WM_WINDOWPOSCHANGING <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PWindowPos(lParam)^.flags := PWindowPos(lParam)^.flags <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> SWP_NOSIZE <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> SWP_NOMOVE; OldWndProc := Pointer(GetWindowLong(hwnd, GWL_USERDATA)); Result := CallWindowProc(OldWndProc, hwnd, uMsg, wParam, lParam); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> OldWndProc: THandle; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> OldWndProc := GetWindowLong(Handle, GWL_WNDPROC); SetWindowLong(Handle, GWL_USERDATA, OldWndProc); SetWindowLong(Handle, GWL_WNDPROC, Integer(@MainFormSubclassProc)); MessageBox(Handle, <span class="hljs-string"><span class="hljs-string">'      '</span></span>, PChar(Application.Title), MB_ICONINFORMATION); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br>  In this example, the window procedure of the main form of the application is replaced. <br>  The address of the old procedure is stored in the user buffer of the window, which is accessed through the constant GWL_USERDATA. <br>  When you call the new MainFormSubclassProc handler, the message code is checked.  If this message is about resizing or coordinates of a window, then this feature is blocked by setting the SWP_NOSIZE and SWP_NOMOVE flags. <br>  Try to run this application and click on the button and then try to resize the main form.  You will not succeed. <br><br>  <b>Small nuance</b> : in this code there is no double overlap check.  If you hit the button a second time, you will get an error about stack overflow.  This is caused by the fact that the second overlapping of the window procedure, when you receive the address of the old one, returns the same address of the MainFormSubclassProc handler and, accordingly, when you first call CallWindowProc, you will enter an infinite loop, since  we will call ourselves, the exit from which will occur overflow. <br><br>  <b>Application</b> : This interception option can only be used for windows.  For conversations, you must use the constant DWL_DLGPROC. <br><br>  <b>As a result</b> : within the framework of the monitor concept, the old window procedure acts as a monitored function here, the new MainFormSubclassProc handler is used as a monitor in which we monitor all data coming to the monitored function.  In it, we can log all parameters, as well as control the behavior of the old handler by replacing the data before calling it, or not calling it at all, and implement our own behavior. <br><br>  Unfortunately, this code will only work for windows of our application.  Well, more precisely, we can of course get the window handle from someone else's application and assign it a new interceptor in the same way as shown above, but this will not lead to anything good, because  in this case, we will specify the address of the new handler, which is located in our address space, and in another address there will be a completely different code (well, or in general this section of memory may not be allocated), which may lead to the sudden death of someone else's process. <br><br>  To prevent this from happening, you need to somehow place the interceptor code in another process and only after that do the substitution.  This is done in several ways, but we will dwell on them a little later ... <br><br><h4>  4. Interception by editing VMT tables. </h4><br>  In principle, this is a very rare variant of interception, but since I decided to tell about all possible methods, I will also have to consider it. <br><br>  Probably, you have encountered situations when the behavior of a particular control completely suits you, but a little something is missing.  To solve a problem, you usually have to write an inheritor of the problem class, in which you override the corresponding virtual methods, where you write the desired behavior of the control.  But if it‚Äôs too lazy, this can be achieved without implementing an heir, simply by overriding the required method from the outside. <br><br>  In the following example, I will show how to override the TForm.CanResize method that is called when resizing a form.  The task of the code is to prevent resizing the form to a width greater than 500 pixels. <br><br>  Of course, in this example, a whole bunch of minuses, firstly, to achieve the goal, it was possible to block the OnResize handler, and secondly, since TForm's CanResize overlaps, this modification will affect all forms in the project, but he and an example - his task is simply show this opportunity. <br><br>  <b>Application</b> : This interception option can be used only for virtual methods of classes, and only within its own PE file.  If you put this code into the library and try to intercept the method from the main application in this way, it will not work, since the TForm applications and the TForm libraries are different classes. <br><br>  The code looks like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> uVMT; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows, Classes, Controls, Forms, StdCtrls; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TForm1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TForm) Button1: TButton; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Form1: TForm1; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R *.dfm}</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewCanResizeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Self: TObject; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> NewWidth, NewHeight: Integer)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := True; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NewWidth &gt; <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> NewWidth := <span class="hljs-number"><span class="hljs-number">500</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> VMTAddr: PPointer; OldProtect: Cardinal; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> mov eax, Self mov eax, [eax] <span class="hljs-comment"><span class="hljs-comment">//    VMT  add eax, VMTOFFSET TForm.CanResize //     TForm.CanResize mov VMTAddr, eax end; //     VirtualProtect(VMTAddr, 4, PAGE_EXECUTE_READWRITE, OldProtect); try //    VMTAddr^ := @NewCanResizeHandler; finally //    VirtualProtect(Pointer(VMTAddr), 4, OldProtect, OldProtect); FlushInstructionCache(GetCurrentProcess, VMTAddr, 4); end; if Width &gt; 500 then Width := 500; MessageBox(Handle, '     500 ', PChar(Application.Title), MB_ICONINFORMATION); end; end.</span></span></code> </pre><br>  <b>Now in more detail:</b> <br><br>  1. The declaration of the interception handler is made taking into account the nuances described in the second section of this article (the Self parameter has appeared). <br><br>  2. To intercept, the documented VMTOFFSET directive is used, described in the Delphi help. <br><br>  Here is a piece with its description: <br><blockquote>  Two additional directives and VMTFFSET and DMTINDEX. <br>  It‚Äôs a way to get a virtual guideline.  For example, TExample.VirtualMethod. </blockquote><br>  As is clear from the description, its task is to return the offset to the address of the virtual method relative to the beginning of the virtual method table (VMT).  At the beginning of the VMT table directly indicates the parameter Self.  That is, if you portray it as a code, you get the following: <br><br><pre> <code class="delphi hljs">VMT := Pointer(Self)^;</code> </pre><br>  3. After using the assembler insert to get the pointer to the address of the method, it is replaced by the address of the new virtual method handler. <br><br>  4. Since the substitution is made in the application code, which is usually located in the memory page, which does not have write permissions (usually these are read and execute rights), before assigning a new handler, write permissions are set. <br><br>  Now, run the example and test it. <br><br>  As you can see, in fact, we have performed almost all the same steps as in the first example, i.e.  received the address of the monitored function, and replaced it with the address of the new handler, in which the parameters of the original method are managed.  I will not give the code to call the original handler (analogue of <b>inherited</b> ), since  Yet this method of interception is shown only for broadening horizons and is highly undesirable for implementation in a combat application. <br><br>  If you have trouble understanding the VMT editing principle, I can recommend this article to be read, by <a href="http://hallvards.blogspot.ru/">Hallvard Vassbotn</a> : <a href="http://hallvards.blogspot.ru/2006/03/method-calls-compiler-implementation.html">Method calls compiler implementation.</a> <br><br>  Or its translation, kindly provided by <a href="http://www.transl-gunsmoker.ru/">Alexander Alekseev</a> : <a href="http://www.transl-gunsmoker.ru/2011/07/method-calls-compiler-implementation.html">Implementation of method calls by the compiler</a> . <br><br>  I will not consider the variant with the interception of dynamic class methods - but the principle is approximately the same. <br><br><h4>  5. Interception by editing the import table </h4><br>  What is an import table.  When you write an application and call API functions, the application must somehow calculate the address of this function in order to transfer control to it.  Most of the functions are declared statically, well, for example: <br><br><pre> <code class="delphi hljs"><span class="hljs-meta"><span class="hljs-meta">{$EXTERNALSYM MessageBox}</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hWnd: HWND; lpText, lpCaption: PChar; uType: UINT)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageBox</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> user32 <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'MessageBoxA'</span></span>;</code> </pre><br>  This clearly indicates the complete declaration of calling the MessageBox function and the calling convention.  This information is required by the compiler to properly align the stack when the function is called.  It also indicates the name of the library in which the function is implemented and the name under which it is exported. <br><br>  As you can see, the function addresses are not here, and it cannot be, because the library, the export function can be loaded at any address and in most cases the address of the same function will be different for each process.  The truth is there is a small nuance, the user32.dll, kernel32.dll and ntdll.dll libraries are loaded for all processes at a fixed address (at least in 32-bit systems), but you still should not rely on a certain static address. <br><br>  When compiling an application, information about statically declared functions is placed in the body of the import table.  At the moment of application launch, the loader analyzes this table, loads the libraries specified in it, on the basis of the library's export table, finds out the real address of the function, which it places in the corresponding field of the application's import table. <br><br>  A general description of the principle of the import table can be found in Matt Pitrek's article <a href="http://msdn.microsoft.com/en-us/magazine/ms809762.aspx">: A Tour of the Win32 Portable Executable File Format</a> . <br>  Its translation is available on the RSDN: <a href="">PE and COFF formats of object files</a> . <br>  If you need more detailed information, you can study the following article: <a href="http://www.wasm.ru/print.php%3Farticle%3D1002006">PE.</a>  <a href="http://www.wasm.ru/print.php%3Farticle%3D1002006">Lesson 6. Import table</a> for Iczelion authorship. <br><br>  Now what can be done with this information?  Everything is simple, to assign an interception handler, you just need to change the address calculated by the loader to the address of the handler, after which the interception can be considered valid. <br><br>  <b>Application</b> : This interception option applies only to API functions with static linking. <br><br>  To search for the address of the original function and replace it with the address of the interceptor, we write the following function: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceIATEntry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OldProc, NewProc: FARPROC)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ImportEntry: PImageImportDescriptor; Thunk: PImageThunkData; Protect: DWORD; ImageBase: Cardinal; DOSHeader: PImageDosHeader; NTHeader: PImageNtHeaders; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := False; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> OldProc = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NewProc = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; ImageBase := GetModuleHandle(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     DOSHeader := PImageDosHeader(ImageBase); NTHeader := PImageNtHeaders(DWORD(DOSHeader) + DWORD(DOSHeader^._lfanew)); ImportEntry := PImageImportDescriptor(DWORD(ImageBase) + DWORD(NTHeader^.OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress)); //     ... while ImportEntry^.Name &lt;&gt; 0 do begin Thunk := PImageThunkData(DWORD(ImageBase) + DWORD(ImportEntry^.FirstThunk)); // ...     ... while Pointer(Thunk^._function) &lt;&gt; nil do begin // ...      . if Pointer(Thunk^._function) = OldProc then begin //   if VirtualProtect(@Thunk^._function, SizeOf(DWORD), PAGE_EXECUTE_READWRITE, Protect) then try //   ... //Thunk^._function := DWORD(NewProc); // ...   . InterlockedExchange(Integer(Thunk^._function), Integer(NewProc)); Result := True; finally VirtualProtect(@Thunk^._function, SizeOf(DWORD), Protect, Protect); FlushInstructionCache(GetCurrentProcess, @Thunk^._function, SizeOf(DWORD)); end; end else Inc(PAnsiChar(Thunk), SizeOf(TImageThunkData32)); end; ImportEntry := Pointer(Integer(ImportEntry) + SizeOf(TImageImportDescriptor)); end; end;</span></span></code> </pre><br>  It edits the import table in the body of the current executable file, as indicated by the code for obtaining the image base GetModuleHandle (nil).  Directly setting the address of the interceptor is done atomically, by calling InterlockedExchange.  This is a rather subtle point, however, I‚Äôm going to dwell on the reasons for just this way of changing the address of the interceptor. <br><br>  Now it remains to write an example of calling this function. <br><br>  Create a new project, place a button on the main form, record the implementation of the ReplaceIATEntry function, and then add the following code: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> OrigAddr: Pointer = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterceptedMessageBoxA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Wnd: HWND; lpText, lpCaption: PAnsiChar; uType: UINT)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TOrigMessageBoxA = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Wnd: HWND; lpText, lpCaption: PAnsiChar; uType: UINT)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> S: AnsiString; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> S := AnsiString(<span class="hljs-string"><span class="hljs-string">'Function interepted. Original message: '</span></span> + lpText); Result := TOrigMessageBoxA(OrigAddr)(Wnd, PAnsiChar(S), lpCaption, uType); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> OrigAddr := GetProcAddress(GetModuleHandle(user32), <span class="hljs-string"><span class="hljs-string">'MessageBoxA'</span></span>); ReplaceIATEntry(OrigAddr, @InterceptedMessageBoxA); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> MessageBoxA(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'Test Message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Here, the form designer sets the interception of the MessageBoxA function, and in the button handler, MessageBoxA is called to demonstrate how the interception works. <br><br>  The interception handler itself is very simple.  Since only the entry in the import table was changed and the body of the original function did not correct, to transfer control to the original function, it is enough to make a call to the previously stored address of the function, which is stored in the variable OrigAddr. <br><br>  <b>There is a small nuance</b> : <br>  The static function can be located in the deferred import section.  Such a declaration is made quite simply, let's change the sample code a bit like this: <br><br><pre> <code class="delphi hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DelayedMessageBoxA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hWnd: HWND; lpText, lpCaption: PAnsiChar; uType: UINT)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> user32 <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'MessageBoxA'</span></span> delayed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> DelayedMessageBoxA(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'Test Message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  The DelayedMessageBoxA function is actually the same MessageBoxA. <br>  But the " <b>delayed</b> " parameter registers the call to this function in the deferred import section. <br><br>  <b>Nuance</b> : the " <b>delayed</b> " parameter is not available in earlier versions of Delphi, so you will not find this piece of code in the example examples for the article. <br><br>  Since the interceptor implemented above makes changes only in the import table, the function call declared in this way will not be controlled by it.  To do this, you need to make edits in IMAGE DIRECTORY_ENTRY DELAYED IMPORT. <br><br>  The option of editing the deferred import table is not considered in the article, in principle there is nothing interesting in it, the principle is the same as with regular import, only slightly different structures are used.  (If you are interested, we will consider the implementation of this interceptor as your homework :). <br><br><h4>  6. Interception by editing the export table. </h4><br>  Editing the import and deferred import tables is great for statically declared functions, but will not work against dynamic declaration and function calls. <br><br>  If in simple terms, try adding another button to the previous example and write the following code in its handler: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TOrigMessageBoxA = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Wnd: HWND; lpText, lpCaption: PAnsiChar; uType: UINT)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> OrigMessageBoxA: TOrigMessageBoxA; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> @OrigMessageBoxA := GetProcAddress(GetModuleHandle(user32), <span class="hljs-string"><span class="hljs-string">'MessageBoxA'</span></span>); OrigMessageBoxA(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'Test Message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Click the button and you will see that the interceptor did not work.  The fact is that the function is GetProcAddress, which receives the address of the function bypassing the import table, focusing on the library export table. <br><br>  In order to force the interception handler to respond to the functions called in the above shown way, you need to make changes directly to the export table of the required library. <br><br>  In brief, the export table contains information about the functions exported by PE file, their name, index (Ordinal) and address of the function.  Some functions are exported only by index and do not have a name; in such cases, access to them is made only by means of an index. <br><br>              . <br>     ,    : <br> <a href="http://wasm.ru/article.php%3Farticle%3D1002007">PE.  7.  </a>   Iczelion-. <br><br> <b></b> :       API   . <br><br>        ,         .   : <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> uEAT; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows, Classes, Controls, Forms, StdCtrls; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TForm1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TForm) Button1: TButton; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Form1: TForm1; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R *.dfm}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> DeclaredTypes; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceEATEntry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DllName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; OldProc, NewProc: FARPROC)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ImageBase: Cardinal; DOSHeader: PImageDosHeader; NTHeader: PImageNtHeaders; ExportDirectory: PImageExportDirectory; pFuntionAddr: PDWORD; OrdinalCursor: PWORD; Ordinal, Protect: DWORD; FuntionAddr: FARPROC; I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := False; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> OldProc = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NewProc = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; ImageBase := GetModuleHandle(PChar(DllName)); <span class="hljs-comment"><span class="hljs-comment">//     DOSHeader := PImageDosHeader(ImageBase); NTHeader := PImageNtHeaders(DWORD(DOSHeader) + DWORD(DOSHeader^._lfanew)); ExportDirectory := PImageExportDirectory(DWORD(ImageBase) + DWORD(NTHeader^.OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress)); I := 1; //     OrdinalCursor := Pointer(ImageBase + DWORD(ExportDirectory^.AddressOfNameOrdinals)); while I &lt; Integer(ExportDirectory^.NumberOfNames) do begin //       Ordinal := OrdinalCursor^; //       FuntionAddr := Pointer(ImageBase + DWORD(ExportDirectory^.AddressOfFunctions)); FuntionAddr := Pointer(ImageBase + PDWORD(DWORD(FuntionAddr) + Ordinal * 4)^); // ,    ? if FuntionAddr = OldProc then begin //  ,  ,      pFuntionAddr := PDWORD(ImageBase + DWORD(ExportDirectory^.AddressOfFunctions) + Ordinal * 4); //        hInstance  NewProc := Pointer(DWORD(NewProc) - ImageBase); //    if VirtualProtect(pFuntionAddr, SizeOf(DWORD), PAGE_EXECUTE_READWRITE, Protect) then try //   ... //pFuntionAddr^ := Integer(NewProc); // ...   . InterlockedExchange(Integer(PImageThunkData(pFuntionAddr)^._function), Integer(NewProc)); Result := True; finally VirtualProtect(pFuntionAddr, SizeOf(DWORD), Protect, Protect); FlushInstructionCache(GetCurrentProcess, pFuntionAddr, SizeOf(DWORD)); end; Break; end; Inc(I); Inc(OrdinalCursor); end; end; var OrigAddr: Pointer = nil; function InterceptedMessageBoxA(Wnd: HWND; lpText, lpCaption: PAnsiChar; uType: UINT): Integer; stdcall; type TOrigMessageBoxA = function(Wnd: HWND; lpText, lpCaption: PAnsiChar; uType: UINT): Integer; stdcall; var S: AnsiString; begin S := AnsiString('Function interepted. Original message: ' + lpText); Result := TOrigMessageBoxA(OrigAddr)(Wnd, PAnsiChar(S), lpCaption, uType); end; procedure TForm1.FormCreate(Sender: TObject); begin OrigAddr := GetProcAddress(GetModuleHandle(user32), 'MessageBoxA'); ReplaceEATEntry(user32, OrigAddr, @InterceptedMessageBoxA); end; procedure TForm1.Button1Click(Sender: TObject); type TOrigMessageBoxA = function(Wnd: HWND; lpText, lpCaption: PAnsiChar; uType: UINT): Integer; stdcall; var OrigMessageBoxA: TOrigMessageBoxA; begin @OrigMessageBoxA := GetProcAddress(GetModuleHandle(user32), 'MessageBoxA'); OrigMessageBoxA(0, 'Test Message', nil, 0); end; end.</span></span></code> </pre><br>            ,              . <br><br><h4> 7.     . </h4><br>       .    ,       -       - ( ) .       ,       .    ,     , API ,        :) <br><br>         API ,     ‚Äî   ,               . <br><br>      ,   . <br><br>                      ,      -   . <br><br>  ,   ,  -  ,              . <br><br>         ‚Äî            ,          .          ,              .  ,        ,     , ..   -    . <br>        ,    . <br><br>     - ,     ? <br>  -             ¬´JMP 100¬ª  .      ,      .             ,         ,       . <br>  ,      ,    .                    .    ,       -         . <br><br>    ,         . <br><br> 1. JMP NEAR OFFSET <br>  ,    $E9,    JMP NEAR rel32,  4   OFFSET. <br> OFFSET    : OFFSET = DestinationAddr ‚Äî CurrentAddr ‚Äî    <br>  DestinationAddr ‚Äî    <br> CurrentAddr ‚Äî      JMP NEAR OFFSET <br><br>      : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SliceNearJmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OldProc, NewProc: FARPROC)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> SpliceRec: <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> JmpOpcode: Byte; Offset: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Tmp: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SpliceRec.JmpOpcode := $E9; SpliceRec.Offset := DWORD(NewProc) - DWORD(OldProc) - SizeOf(SpliceRec); VirtualProtect(OldProc, SizeOf(SpliceRec), PAGE_EXECUTE_READWRITE, OldProtect); Move(SpliceRec, OldProc^, SizeOf(SpliceRec)); VirtualProtect(OldProc, SizeOf(SpliceRec), OldProtect, OldProtect); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br> 2. PUSH ADDR + RET <br>  ,    $68,    PUSH imm32,  4    ADDR,  ,           $C3,    RET. <br>      .   PUSH      ADDR   RET        . <br><br>       : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SlicePushRet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OldProc, NewProc: FARPROC)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> SpliceRec: <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> PushOpcode: Byte; Offset: FARPROC; RetOpcode: Byte; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SpliceRec.PushOpcode := $<span class="hljs-number"><span class="hljs-number">68</span></span>; SpliceRec.Offset := NewProc; SpliceRec.RetOpcode := $C3; VirtualProtect(OldProc, SizeOf(SpliceRec), PAGE_EXECUTE_READWRITE, OldProtect); Move(SpliceRec, OldProc^, SizeOf(SpliceRec)); VirtualProtect(OldProc, SizeOf(SpliceRec), OldProtect, OldProtect); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>            .     . <br><br>         : MOV EAX, ADDR + JMP EAX.        ,           FASTCALL.   ,      Delphi       ,         EAX, ECX  EDX.    ,     EAX  .       . <br><br>       .          ,     ,        HotPatch-. <br><br>   ,         ,       .  -,   ¬´HotPatch¬ª :) <br><br> ,      MS  ,       API     NOP,          MOV EDI, EDI (  PUSH xxx) <br><br><img src="http://3.bp.blogspot.com/-QAKoO8BhMHw/UQRRBOQL0DI/AAAAAAAAATI/hhGxPdvgTig/s1600/nop.png" alt="image"><br><br>              JMP NEAR OFFSET.           .            ,       JMP SHORT -7     $EB  $F9. <br><br>   HotPach-    : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SliceHotPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OldProc, NewProc: FARPROC)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> SpliceRec: <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> JmpOpcode: Byte; Offset: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; NopAddr: Pointer; OldProtect: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SpliceRec.JmpOpcode := $E9; NopAddr := PAnsiChar(OldProc) - SizeOf(SpliceRec); SpliceRec.Offset := DWORD(NewProc) - DWORD(NopAddr) - SizeOf(SpliceRec); VirtualProtect(NopAddr, <span class="hljs-number"><span class="hljs-number">7</span></span>, PAGE_EXECUTE_READWRITE, OldProtect); Move(SpliceRec, NopAddr^, SizeOf(SpliceRec)); <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> mov ax, $F9EB mov ecx, OldProc lock xchg word ptr [ecx], ax <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; VirtualProtect(NopAddr, <span class="hljs-number"><span class="hljs-number">7</span></span>, OldProtect, OldProtect); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>                   ,        . <br><br>          HotPach-  ,          .    -      . <br><br> ,            HotPatch-      : <a href="http://msdn.microsoft.com/en-us/library/ms173507(VS.80).aspx">Create Hotpatchable Image</a>     MS VC. <br><br>       .        .          ,      - . <br><br>      .       ,          : <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> uNearJmpSplice; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows, Classes, Controls, Forms, StdCtrls; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TForm1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TForm) Button1: TButton; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Form1: TForm1; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R *.dfm}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">//      JMP NEAR OFFSET TNearJmpSpliceRec = packed record JmpOpcode: Byte; Offset: DWORD; end; //         JMP NEAR OFFSET TNearJmpSpliceData = packed record FuncAddr: FARPROC; OldData: TNearJmpSpliceRec; NewData: TNearJmpSpliceRec; end; var NearJmpSpliceRec: TNearJmpSpliceData; //         procedure SpliceNearJmp(FuncAddr: Pointer; NewData: TNearJmpSpliceRec); var OldProtect: DWORD; begin VirtualProtect(FuncAddr, SizeOf(TNearJmpSpliceRec), PAGE_EXECUTE_READWRITE, OldProtect); try //   !!! Move(NewData, FuncAddr^, SizeOf(TNearJmpSpliceRec)); finally VirtualProtect(FuncAddr, SizeOf(TNearJmpSpliceRec), OldProtect, OldProtect); FlushInstructionCache(GetCurrentProcess, FuncAddr, SizeOf(TNearJmpSpliceRec)); end; end; //    MessageBoxA function InterceptedMessageBoxA(Wnd: HWND; lpText, lpCaption: PAnsiChar; uType: UINT): Integer; stdcall; var S: AnsiString; begin //   SpliceNearJmp(NearJmpSpliceRec.FuncAddr, NearJmpSpliceRec.OldData); try //    S := AnsiString('Function interepted. Original message: ' + lpText); Result := MessageBoxA(Wnd, PAnsiChar(S), lpCaption, uType); finally //   SpliceNearJmp(NearJmpSpliceRec.FuncAddr, NearJmpSpliceRec.NewData); end; end; procedure InitNearJmpSpliceRec; begin //      NearJmpSpliceRec.FuncAddr := GetProcAddress(GetModuleHandle(user32), 'MessageBoxA'); //      ,     Move(NearJmpSpliceRec.FuncAddr^, NearJmpSpliceRec.OldData, SizeOf(TNearJmpSpliceRec)); //   JMP NEAR NearJmpSpliceRec.NewData.JmpOpcode := $E9; //    NearJmpSpliceRec.NewData.Offset := PAnsiChar(@InterceptedMessageBoxA) - PAnsiChar(NearJmpSpliceRec.FuncAddr) - SizeOf(TNearJmpSpliceRec); end; procedure TForm1.FormCreate(Sender: TObject); begin //     InitNearJmpSpliceRec; //  MessageBoxA SpliceNearJmp(NearJmpSpliceRec.FuncAddr, NearJmpSpliceRec.NewData); end; procedure TForm1.Button1Click(Sender: TObject); begin MessageBoxA(0, 'Test MessageBoxA Message', nil, 0); end; end.</span></span></code> </pre><br>           TNearJmpSpliceRec.         . <br>         TNearJmpSpliceData,               . <br><br>    InitNearJmpSpliceRec   ,      SpliceNearJmp   . <br><br>         InterceptedMessageBoxA               . <br><br>     ,   PUSH ADDR + RET       TNearJmpSpliceRec     InitNearJmpSpliceRec,    . <br><br>           ( HotPatch). <br>        ,    ,     . <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> CommonHotPatch; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LOCK_JMP_OPKODE: Word = $F9EB; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">//      JMP NEAR OFFSET TNearJmpSpliceRec = packed record JmpOpcode: Byte; Offset: DWORD; end; THotPachSpliceData = packed record FuncAddr: FARPROC; SpliceRec: TNearJmpSpliceRec; LockJmp: Word; end; var HotPathSpliceRec: THotPachSpliceData; procedure InitHotPatchSpliceRec; procedure SpliceNearJmp(FuncAddr: Pointer; NewData: TNearJmpSpliceRec); procedure SpliceLockJmp(FuncAddr: Pointer; NewData: Word); implementation //         procedure SpliceNearJmp(FuncAddr: Pointer; NewData: TNearJmpSpliceRec); var OldProtect: DWORD; begin VirtualProtect(FuncAddr, SizeOf(TNearJmpSpliceRec), PAGE_EXECUTE_READWRITE, OldProtect); try Move(NewData, FuncAddr^, SizeOf(TNearJmpSpliceRec)); finally VirtualProtect(FuncAddr, SizeOf(TNearJmpSpliceRec), OldProtect, OldProtect); FlushInstructionCache(GetCurrentProcess, FuncAddr, SizeOf(TNearJmpSpliceRec)); end; end; //         procedure SpliceLockJmp(FuncAddr: Pointer; NewData: Word); var OldProtect: DWORD; begin VirtualProtect(FuncAddr, 2, PAGE_EXECUTE_READWRITE, OldProtect); try asm mov ax, NewData mov ecx, FuncAddr lock xchg word ptr [ecx], ax end; finally VirtualProtect(FuncAddr, 2, OldProtect, OldProtect); FlushInstructionCache(GetCurrentProcess, FuncAddr, 2); end; end; function InterceptedMessageBoxA(Wnd: HWND; lpText, lpCaption: PAnsiChar; uType: UINT): Integer; stdcall; var S: AnsiString; begin //   SpliceLockJmp(HotPathSpliceRec.FuncAddr, HotPathSpliceRec.LockJmp); try //    S := AnsiString('Function interepted. Original message: ' + lpText); Result := MessageBoxA(Wnd, PAnsiChar(S), lpCaption, uType); finally //   SpliceLockJmp(HotPathSpliceRec.FuncAddr, LOCK_JMP_OPKODE); end; end; procedure InitHotPatchSpliceRec; begin //      HotPathSpliceRec.FuncAddr := GetProcAddress(GetModuleHandle(user32), 'MessageBoxA'); //      ,     Move(HotPathSpliceRec.FuncAddr^, HotPathSpliceRec.LockJmp, 2); //   JMP NEAR HotPathSpliceRec.SpliceRec.JmpOpcode := $E9; //    HotPathSpliceRec.SpliceRec.Offset := PAnsiChar(@InterceptedMessageBoxA) + 5 - PAnsiChar(HotPathSpliceRec.FuncAddr) - SizeOf(TNearJmpSpliceRec); end; end.</span></span></code> </pre><br>       : <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> uHotPachSplice; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows, Classes, Controls, Forms, StdCtrls; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TForm1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TForm) Button1: TButton; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Form1: TForm1; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> CommonHotPatch; <span class="hljs-meta"><span class="hljs-meta">{$R *.dfm}</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//     InitHotPatchSpliceRec; //     NOP- SpliceNearJmp(PAnsiChar(HotPathSpliceRec.FuncAddr) - 5, HotPathSpliceRec.SpliceRec); //  MessageBoxW SpliceLockJmp(HotPathSpliceRec.FuncAddr, LOCK_JMP_OPKODE); end; procedure TForm1.Button1Click(Sender: TObject); const TestStr: AnsiString = 'Test MessageBoxA Message'; begin MessageBoxA(0, PAnsiChar(TestStr), nil, 0); end; end.</span></span></code> </pre><br>     , ..      . <br><br><h4> 8.     . </h4><br>           ,          . <br><br>         ,    ‚Äî      VirtualAllocEx       (    ),    ,   . <br><br>     ,       ,        . <br><br>     : <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">program</span></span> hook_loader; <span class="hljs-meta"><span class="hljs-meta">{$APPTYPE CONSOLE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hLib: THandle; HookProcAddr: Pointer; HookHandle: HHOOK; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> hLib := LoadLibrary(<span class="hljs-string"><span class="hljs-string">'hook_splice_lib.dll'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> HookProcAddr := GetProcAddress(hLib, <span class="hljs-string"><span class="hljs-string">'HookProc'</span></span>); Writeln(<span class="hljs-string"><span class="hljs-string">'MessageBoxA intercepted, press ENTER to resume...'</span></span>); HookHandle := SetWindowsHookEx(WH_GETMESSAGE, HookProcAddr, hLib, <span class="hljs-number"><span class="hljs-number">0</span></span>); Readln; UnhookWindowsHookEx(HookHandle); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> FreeLibrary(hLib); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br>     SetWindowsHookEx    ,      hook_splice_lib.dll.                GetMessage  PeekMessage. <br><br>             : <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">library</span></span> hook_splice_lib; <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows, CommonHotPatch <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'..\common\CommonHotPatch.pas'</span></span>; <span class="hljs-meta"><span class="hljs-meta">{$R *.res}</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DLLEntryPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dwReason: DWORD)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> dwReason <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DLL_PROCESS_ATTACH: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//     InitHotPatchSpliceRec; //     NOP- SpliceNearJmp(PAnsiChar(HotPathSpliceRec.FuncAddr) - 5, HotPathSpliceRec.SpliceRec); //  MessageBoxW SpliceLockJmp(HotPathSpliceRec.FuncAddr, LOCK_JMP_OPKODE); end; DLL_PROCESS_DETACH: begin //      SpliceLockJmp(HotPathSpliceRec.FuncAddr, HotPathSpliceRec.LockJmp); end; end; end; function HookProc(Code: Integer; WParam: WPARAM; LParam: LPARAM): LRESULT; stdcall; begin Result := CallNextHookEx(0, Code, WParam, LParam); end; exports HookProc; begin DLLProc := @DLLEntryPoint; DLLEntryPoint(DLL_PROCESS_ATTACH); end.</span></span></code> </pre><br>  .   ,         HookProc,          .        WH_GETMESSAGE. <br><br>     DLLEntryPoint      DLL_PROCESS_ATTACH,      DLL_PROCESS_DETACH  . <br><br>      DLLProc.         ,    DLL_PROCESS_DETACH.   ,      ,  DLL_PROCESS_ATTACH         DLLProc.  DLLEntryPoint(DLL_PROCESS_ATTACH)       .      , DLLProc      DLLEntryPoint        ,         . <br><br><h4> 9.        . </h4><br>         .         ,      .     ,     ,        ,             .         : <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">program</span></span> test_console8; <span class="hljs-meta"><span class="hljs-meta">{$APPTYPE CONSOLE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Writeln(<span class="hljs-string"><span class="hljs-string">'Press enter to show message...'</span></span>); Readln; MessageBoxA(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'First message'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); Writeln(<span class="hljs-string"><span class="hljs-string">'Press enter to show message...'</span></span>); Readln; MessageBoxA(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'Second message'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br>                GetMessage  PeekMessage,         . <br><br> ,    ,  ,      .         MessageBox (    )      (      )        ,       MessageBox. <br><br>     (    MessageBox  ),    ,    (PID). <br><br>          ,      ,     HookProc         : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelfUnload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lpParametr: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FreeLibraryAndExitThread(HInstance, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> SelfUnload;</code> </pre><br>     : <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DllName = <span class="hljs-string"><span class="hljs-string">'thread_splice_lib.dll'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InjectLib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProcessID: Integer)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Process: HWND; ThreadRtn: FARPROC; DllPath: AnsiString; RemoteDll: Pointer; BytesWriten: DWORD; Thread: DWORD; ThreadId: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := False; <span class="hljs-comment"><span class="hljs-comment">//   Process := OpenProcess(PROCESS_CREATE_THREAD or PROCESS_VM_OPERATION or PROCESS_VM_WRITE, True, ProcessID); if Process = 0 then Exit; try //       DllPath := AnsiString(ExtractFilePath(ParamStr(0)) + DLLName) + #0; RemoteDll := VirtualAllocEx(Process, nil, Length(DllPath), MEM_COMMIT or MEM_TOP_DOWN, PAGE_READWRITE); if RemoteDll = nil then Exit; try //         if not WriteProcessMemory(Process, RemoteDll, PChar(DllPath), Length(DllPath), BytesWriten) then Exit; if BytesWriten &lt;&gt; DWORD(Length(DllPath)) then Exit; //     Kernel32.dll ThreadRtn := GetProcAddress(GetModuleHandle('Kernel32.dll'), 'LoadLibraryA'); if ThreadRtn = nil then Exit; //    Thread := CreateRemoteThread(Process, nil, 0, ThreadRtn, RemoteDll, 0, ThreadId); if Thread = 0 then Exit; try //     ... Result := WaitForSingleObject(Thread, INFINITE) = WAIT_OBJECT_0; finally CloseHandle(Thread); end; finally VirtualFreeEx(Process, RemoteDll, 0, MEM_RELEASE); end; finally CloseHandle(Process); end; end;</span></span></code> </pre><br>        ,      . <br>       : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResumeLib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProcessID: Integer)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hLibHandle: THandle; hModuleSnap: THandle; ModuleEntry: TModuleEntry32; OpCodeData: Word; Process: HWND; BytesWriten: DWORD; Thread: DWORD; ThreadId: DWORD; ExitCode: DWORD; PLibHandle: PDWORD; OpCode: PWORD; CurrUnloadAddrOffset: DWORD; UnloadAddrOffset: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := False; <span class="hljs-comment"><span class="hljs-comment">//          hLibHandle := LoadLibrary(PChar(DLLName)); try UnloadAddrOffset := DWORD(GetProcAddress(hLibHandle, 'SelfUnload')) - hLibHandle; if UnloadAddrOffset = -hLibHandle then Exit; finally FreeLibrary(hLibHandle); end; //        hModuleSnap := CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, ProcessID); if hModuleSnap &lt;&gt; INVALID_HANDLE_VALUE then try FillChar(ModuleEntry, SizeOf(TModuleEntry32), #0); ModuleEntry.dwSize := SizeOf(TModuleEntry32); if not Module32First(hModuleSnap, ModuleEntry) then Exit; repeat if AnsiUpperCase(ModuleEntry.szModule) = AnsiUpperCase(DLLName) then begin //     CurrUnloadAddrOffset := ModuleEntry.hModule + UnloadAddrOffset; Break; end; until not Module32Next(hModuleSnap, ModuleEntry); finally CloseHandle(hModuleSnap); end; //   Process := OpenProcess(PROCESS_CREATE_THREAD or PROCESS_VM_OPERATION or PROCESS_VM_WRITE, True, ProcessID); if Process = 0 then Exit; try //   jmp [ebx] OpCode := VirtualAllocEx(Process, nil, 2, MEM_COMMIT or MEM_TOP_DOWN, PAGE_READWRITE); if OpCode = nil then Exit; try OpCodeData := $23FF; if not WriteProcessMemory(Process, OpCode, @OpCodeData, 2, BytesWriten) then Exit; //     (    EBX   ) PLibHandle := VirtualAllocEx(Process, nil, 4, MEM_COMMIT or MEM_TOP_DOWN, PAGE_READWRITE); if PLibHandle = nil then Exit; try if not WriteProcessMemory(Process, PLibHandle, @CurrUnloadAddrOffset, 4, BytesWriten) then Exit; //   Thread := CreateRemoteThread(Process, nil, 0, OpCode, PLibHandle, 0, ThreadId); if Thread = 0 then Exit; try //     ... if (WaitForSingleObject(Thread, INFINITE) = WAIT_OBJECT_0) then if GetExitCodeThread(Thread, ExitCode) then Result := ExitCode = 0; finally CloseHandle(Thread); end; finally VirtualFreeEx(Process, PLibHandle, 0, MEM_RELEASE); end; finally VirtualFreeEx(Process, OpCode, 0, MEM_RELEASE); end; finally CloseHandle(Process); end; end;</span></span></code> </pre><br>  c   ,     Windows 2000  Windows 7 (   ,         ).     ,    lpParameter  CreateRemoteThread     EBX      .         JMP [EBX]      .   EBX     SelfUnload,     ,              . <br><br>          SelfUnload,       ,     :) <br><br><h4> 10.  </h4><br>      ,   . <br>           ,   ,    . <br><br>      ,            . <br><br><ul><li>          . </li><li>         . </li><li>     IN/OUT ‚Äî   . </li></ul><br>   ,    ¬´¬ª      ,     ,     ReadFile      . <br><br>        ‚Äî         ,     ,  ,   WriteFile    ,   . <br><br><h4> 11.  </h4><br>         .       .          ‚Äî ..        Delphi,            , ..         ¬´ ¬ª. <br><br>          HotPatch,  :     ,      . <br> ,  ,      ,    ,        ,       <a href="http://habrahabr.ru/post/181157/">  .</a> <br><br>          ,       . ,              ,           .          ,   ,   .      ,    ,        ? <br><br>       <a href=""> </a> <br><br>  . <br><br>  Alexander (Rouse_) Bagel <br> , 2013 </div><p>Source: <a href="https://habr.com/ru/post/178393/">https://habr.com/ru/post/178393/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../178379/index.html">How to become a real analyst? Part 2. Identify the requirements</a></li>
<li><a href="../178381/index.html">System Center 2012 Operations Manager + SP1 from Microsoft Architect!</a></li>
<li><a href="../178385/index.html">Last days of discounts for the conference # MBLT13</a></li>
<li><a href="../178387/index.html">Another game abstraction from Notch - Drop</a></li>
<li><a href="../178389/index.html">Employee Opera Software on trial for transferring production secrets in favor of Mozilla</a></li>
<li><a href="../178401/index.html">Processing and classification of requests. Part Three: Correcting Typos</a></li>
<li><a href="../178403/index.html">Add Web API for a C ++ program using the POCO library</a></li>
<li><a href="../178405/index.html">Correctly free up resources in java</a></li>
<li><a href="../178407/index.html">Automate Web Application Testing</a></li>
<li><a href="../178409/index.html">Java String Internal Representation Changes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>