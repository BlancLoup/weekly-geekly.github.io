<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learning Linux Processes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I would like to talk about the life course of the processes in the Linux family. In theory and examples, I will look at how processes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learning Linux Processes</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/w9/tj/yz/w9tjyz5nyynb4zwy2kiikc0ckec.png"><br>  In this article, I would like to talk about the life course of the processes in the Linux family.  In theory and examples, I will look at how processes are born and die, talk a little about the mechanics of system calls and signals. <br><br>  This article is more designed for newcomers to system programming and those who just want to learn a little more about how Linux processes work. <br><a name="habracut"></a><br>  Everything written below is valid for Debian Linux with kernel 4.15.0. <br><br><h2>  Content </h2><br><ol><li>  <a href="https://habr.com/ru/post/423049/">Introduction</a> </li><li>  <a href="https://habr.com/ru/post/423049/">Process Attributes</a> </li><li>  <a href="https://habr.com/ru/post/423049/">Process life cycle</a> <br><ol><li>  <a href="https://habr.com/ru/post/423049/">Birth process</a> </li><li>  <a href="https://habr.com/ru/post/423049/">Ready state</a> </li><li>  <a href="https://habr.com/ru/post/423049/">Status "in progress"</a> </li><li>  <a href="https://habr.com/ru/post/423049/">Rebirth into another program</a> </li><li>  <a href="https://habr.com/ru/post/423049/">State "waiting"</a> </li><li>  <a href="https://habr.com/ru/post/423049/">‚ÄúStopped‚Äù status</a> </li><li>  <a href="https://habr.com/ru/post/423049/">Process completion</a> </li><li>  <a href="https://habr.com/ru/post/423049/">Zombie condition</a> </li><li>  <a href="https://habr.com/ru/post/423049/">Forgetting</a> </li></ol></li><li>  <a href="https://habr.com/ru/post/423049/">Thanks</a> </li></ol><br><a name="intro"></a><h2>  Introduction </h2><br>  System software interacts with the system kernel through special functions - system calls.  In rare cases, there is an alternative API, for example, procfs or sysfs, implemented as virtual file systems. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="definition"></a><h2>  Process Attributes </h2><br>  The process in the kernel is simply represented as a structure with many fields (the definition of the structure can be read <a href="">here</a> ). <br>  But since the article is devoted to system programming, and not to the development of the kernel, we abstract a little and just focus on the important for us fields of the process: <br><br><ul><li>  Process ID (pid) </li><li>  Open File Descriptors (fd) </li><li>  Signal handlers </li><li>  Current working directory (cwd) </li><li>  Environmental variables (environ) </li><li>  Return code </li></ul><br><a name="lifecycle"></a><h2>  Process life cycle </h2><br><img src="https://habrastorage.org/webt/dw/ru/5n/dwru5nbeoag7imroc_ki1qa9gba.png"><br><br><a name="fork"></a><h3>  Birth process </h3><br>  Only one process in the system is born in a special way - <code>init</code> - it is generated directly by the kernel.  All other processes appear by duplicating the current process using the <code>fork(2)</code> system call.  After the execution of <code>fork(2)</code> we obtain two almost identical processes with the exception of the following points: <br><br><ol><li>  <code>fork(2)</code> returns the child's PID to the parent, 0 is returned to the child; </li><li>  The child has the PPID (Parent Process Id) change to the PID of the parent. </li></ol><br>  After <code>fork(2)</code> all the resources of the child process are a copy of the parent's resources.  Copying the process with all allocated memory pages is expensive, so the Linux kernel uses Copy-On-Write technology. <br>  All pages in the memory of the parent are marked as read-only and become accessible to both the parent and the child.  As soon as one of the processes changes the data on a particular page, this page does not change, but a copy is copied and changed.  The original is ‚Äúuntied‚Äù from this process.  As soon as the read-only original remains ‚Äútied‚Äù to one process, the page is again assigned the status of read-write. <br><br><div class="spoiler">  <b class="spoiler_title">An example of a simple useless program with a fork (2)</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/types.h&gt; int main() { int pid = fork(); switch(pid) { case -1: perror("fork"); return -1; case 0: // Child printf("my pid = %i, returned pid = %i\n", getpid(), pid); break; default: // Parent printf("my pid = %i, returned pid = %i\n", getpid(), pid); break; } return 0; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ gcc test.c &amp;&amp; ./a.out my pid = 15594, returned pid = 15595 my pid = 15595, returned pid = 0</code> </pre><br></div></div><br><a name="ready"></a><h3>  Ready state </h3><br>  Immediately after execution, <code>fork(2)</code> enters the ‚Äúready‚Äù state. <br>  In fact, the process is in the queue and waiting for the scheduler in the kernel to let the process run on the processor. <br><br><a name="running"></a><h3>  Status "in progress" </h3><br>  As soon as the scheduler put the process to execution, the ‚Äúrunning‚Äù state began.  The process can be performed all the proposed period (quantum) of time, and can give way to other processes, using the <code>sched_yield</code> system export. <br><br><a name="exec"></a><h3>  Rebirth into another program </h3><br>  In some programs, logic is implemented in which the parent process creates a child process for solving a task.  The child in this case solves some specific problem, and the parent only delegates tasks to his children.  For example, a web server on an incoming connection creates a child and transfers connection processing to it. <br>  However, if you need to run another program, you must resort to the <code>execve(2)</code> system call: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argv[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> envp[])</span></span></span></span>;</code> </pre><br>  or library calls <code>execl(3), execlp(3), execle(3), execv(3), execvp(3), execvpe(3)</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, ... </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* (char *) NULL */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execlp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, ... </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* (char *) NULL */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, ... </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*, (char *) NULL, char * const envp[] */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argv[])</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execvp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argv[])</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execvpe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argv[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> envp[])</span></span></span></span>;</code> </pre><br>  All of the listed calls execute the program, the path to which is indicated in the first argument.  If successful, the control is transferred to the loaded program and is not returned to the original one.  In this case, the loaded program will have all the fields of the process structure, except for file descriptors marked as <code>O_CLOEXEC</code> , they will close. <br><br>  How not to be confused in all these calls and choose the right one?  Enough to understand the logic of naming: <br><br><ul><li>  All calls start with <code>exec</code> </li><li>  The fifth letter defines the type of argument passing: <br><ul><li>  <b>l</b> denotes a <b>list</b> , all parameters are passed as <code>arg1, arg2, ..., NULL</code> </li><li>  <b>v</b> stands for <b>vector</b> , all parameters are passed in a null-terminated array; </li></ul></li><li>  Next can follow the letter <b>p</b> , which stands for <b>path</b> .  If the <code>file</code> argument starts with a character other than "/", then the specified <code>file</code> is searched in the directories listed in the PATH environment variable </li><li>  The latter may be the letter <b>e</b> , meaning <b>environ</b> .  In such calls, the last argument is a null-terminated array of null-terminated strings of the form <code>key=value</code> ‚Äî environment variables that will be passed to the new program. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Call example / bin / cat --help via execve</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _GNU_SOURCE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unistd.h&gt; int main() { char* args[] = { "/bin/cat", "--help", NULL }; execve("/bin/cat", args, environ); // Unreachable return 1; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ gcc test.c &amp;&amp; ./a.out Usage: /bin/cat [OPTION]... [FILE]... Concatenate FILE(s) to standard output. * *</code> </pre><br></div></div><br>  The <code>exec*</code> call family allows you to run scripts with execute permissions and starting with a shebang sequence (#!). <br><br><div class="spoiler">  <b class="spoiler_title">An example of running a script with a spoofed PATH using execle</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _GNU_SOURCE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unistd.h&gt; int main() { char* e[] = {"PATH=/habr:/rulez", NULL}; execle("/tmp/test.sh", "test.sh", NULL, e); // Unreachable return 1; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ cat test.sh <span class="hljs-comment"><span class="hljs-comment">#!/bin/bash echo $0 echo $PATH $ gcc test.c &amp;&amp; ./a.out /tmp/test.sh /habr:/rulez</span></span></code> </pre><br></div></div><br>  There is a convention that implies that argv [0] matches zero arguments for exec * family functions.  However, this can be broken. <br><br><div class="spoiler">  <b class="spoiler_title">Example of when cat becomes a dog using execlp</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _GNU_SOURCE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unistd.h&gt; int main() { execlp("cat", "dog", "--help", NULL); // Unreachable return 1; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ gcc test.c &amp;&amp; ./a.out Usage: dog [OPTION]... [FILE]... * *</code> </pre><br></div></div><br>  A curious reader may notice that the signature of the function <code>int main(int argc, char* argv[])</code> has a number - the number of arguments, but nothing in the family of <code>exec*</code> functions.  Why?  Because when you start the program, control is not transferred immediately to main.  Before this, some actions defined by glibc are performed, including the calculation of argc. <br><br><a name="waiting"></a><h3>  State "waiting" </h3><br>  Some system calls can take a long time, such as I / O.  In such cases, the process goes into the "waiting" state.  As soon as the system call is completed, the kernel will transfer the process to the ‚Äúready‚Äù state. <br>  In Linux, there is also a ‚Äúwaiting‚Äù state in which the process does not respond to interrupt signals.  In this state, the process becomes ‚Äúunkillable‚Äù, and all incoming signals are queued until the process leaves this state. <br>  The kernel itself chooses which of the states to transfer the process to.  Most often, processes that request I / O get into the "waiting (without interrupts)" state.  This is especially noticeable when using a remote disk (NFS) with not very fast internet. <br><br><a name="stopped"></a><h3>  ‚ÄúStopped‚Äù status </h3><br>  You can pause the process at any time by sending a SIGSTOP signal to it.  The process will go to the ‚Äústopped‚Äù state and remain there until it receives a signal to continue working (SIGCONT) or die (SIGKILL).  The remaining signals will be queued. <br><br><a name="exit"></a><h3>  Process completion </h3><br>  No program can complete itself.  They can only ask the system for this using the <code>_exit</code> system call or be terminated by the system due to an error.  Even when returning a number from <code>main()</code> , <code>_exit</code> is still implicitly called. <br>  Although the system call argument takes an int, only the low byte of the number is taken as the return code. <br><br><a name="zombie"></a><h3>  Zombie condition </h3><br>  Immediately after the process is completed (whether it is correct or not), the kernel writes information about how the process ended and translates its zombie state.  In other words, zombies are a completed process, but its memory is still stored in the core. <br>  Moreover, this is the second state in which the process can safely ignore the SIGKILL signal, because dead cannot die again. <br><br><a name="wait"></a><h3>  Forgetting </h3><br>  The return code and the reason for completing the process are still stored in the kernel and need to be retrieved from there.  To do this, you can use the appropriate system calls: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> wait(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *wstatus); <span class="hljs-comment"><span class="hljs-comment">/*  waitpid(-1, wstatus, 0) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> waitpid(<span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> pid, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *wstatus, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> options);</code> </pre><br>  All information about the completion of the process fits into the data type int.  The macros described in the <code>waitpid(2)</code> man page are used to get the return code and the reason for the program termination. <br><br><div class="spoiler">  <b class="spoiler_title">An example of correct completion and receipt of a return code</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/types.h&gt; int main() { int pid = fork(); switch(pid) { case -1: perror("fork"); return -1; case 0: // Child return 13; default: { // Parent int status; waitpid(pid, &amp;status, 0); printf("exit normally? %s\n", (WIFEXITED(status) ? "true" : "false")); printf("child exitcode = %i\n", WEXITSTATUS(status)); break; } } return 0; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ gcc test.c &amp;&amp; ./a.out <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> normally? <span class="hljs-literal"><span class="hljs-literal">true</span></span> child exitcode = 13</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Example of incorrect termination</b> <div class="spoiler_text"><br>  Passing argv [0] as NULL causes a drop. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/types.h&gt; int main() { int pid = fork(); switch(pid) { case -1: perror("fork"); return -1; case 0: // Child execl("/bin/cat", NULL); return 13; default: { // Parent int status; waitpid(pid, &amp;status, 0); if(WIFEXITED(status)) { printf("Exit normally with code %i\n", WEXITSTATUS(status)); } if(WIFSIGNALED(status)) { printf("killed with signal %i\n", WTERMSIG(status)); } break; } } return 0; }</span></span></span></span></code> </pre><br><br><pre> <code class="bash hljs">$ gcc test.c &amp;&amp; ./a.out killed with signal 6</code> </pre><br></div></div><br>  There are cases in which the parent ends earlier than the child.  In such cases, the child's parent will be <code>init</code> and he will apply the <code>wait(2)</code> call when the time comes. <br><br>  After the parent has taken away the information about the child‚Äôs death, the kernel erases all the information about the child, so that another process soon comes to replace it. <br><br><a name="thanks"></a><h2>  Thanks </h2><br>  Thanks to Sasha ‚ÄúAl‚Äù for editing and design assistance; <br><br>  Thanks to Sasha ‚ÄúReisse‚Äù for clear answers to difficult questions. <br><br>  They bravely endured the inspiration that attacked me and the flurry of my questions that attacked them. </div><p>Source: <a href="https://habr.com/ru/post/423049/">https://habr.com/ru/post/423049/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423039/index.html">We do web-authentication via blockchain</a></li>
<li><a href="../423041/index.html">The fancy story of the Super NES CD-ROM</a></li>
<li><a href="../423043/index.html">Due to the vulnerability in the Tesla electric vehicle protection system, you can hijack a car in a few seconds</a></li>
<li><a href="../423045/index.html">Which 3D printer to choose? Video Review from 3Dtool</a></li>
<li><a href="../423047/index.html">We reserve IT systems for reasonable money</a></li>
<li><a href="../423051/index.html">Fight for resources, part 1: Basics of Cgroups</a></li>
<li><a href="../423053/index.html">Struct and readonly: how to avoid performance degradation</a></li>
<li><a href="../423055/index.html">Wall Street analysts: "Apple made us eat our hats"</a></li>
<li><a href="../423057/index.html">Python also partially rejects the terms master / slave</a></li>
<li><a href="../423059/index.html">Better than they say: three things you need to make the next MacBook one of the best Apple laptops</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>