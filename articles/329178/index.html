<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL Diagnostic Techniques - Vladimir Borodin and Ildus Kurbangaliev</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the most popular reports of the PG Day conference in 2015 was the story of Vladimir Borodin and Ildus Kurbangaliev about situations when the st...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL Diagnostic Techniques - Vladimir Borodin and Ildus Kurbangaliev</h1><div class="post__text post__text-html js-mediator-article"> <i>One of the most popular reports of the PG Day conference in 2015 was the story of <b>Vladimir Borodin</b> and <b>Ildus Kurbangaliev</b> about situations when the state of the base becomes bad, you need to diagnose them and look for bottlenecks.</i>  <i>All examples in the report are taken from the real practice of Yandex, accompanied by illustrations and a detailed story about the search for ‚Äúbottleneck‚Äù.</i>  <i>Despite the fact that the problems were considered in the context of 9.4 and 9.5 versions of the database, the overall value and practical applicability of the councils of Vladimir and Ildus remains unchanged.</i>  <i>We are glad to offer you a transcript of <a href="http://pgday.ru/ru/2015/papers/21%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dboodin">this report</a> .</i> <br><br>  <b>The introduction of Ilya Kosmodemyansky</b> : now we will have a story about how to live, if you really want to have an Oracle, but it is not.  In fact, this is a useful report, because one of the problems we now have is the problem of diagnostic tools.  Diagnostic tools are sometimes lacking, sometimes instead of the usual diagnostic tools, you need to use rather complex tools, which are generally intended for Linux developers, and not for DBA.  DBA teeth start to hurt when they look at these scripts.  And now the guys from Yandex and PG Pro will talk about Postgres diagnostic methods that they use, how to use them, and tell you a little about how they are going to improve this world. <br><br><img src="https://habrastorage.org/web/f7b/287/2bc/f7b2872bc7544c5d91a953ab65196233.jpg"><br><a name="habracut"></a><br>  <b>Vladimir Borodin</b> : Hello everyone.  My name is Vova, and I am admin Yandex mail.  The report is joint with Ildus, he is developing PostgreSQL at Postgres Pro. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The Postgres Diagnostics Report and an important moment in it are pictures.  The first part of the report is about what to do, what to do if you have failed monitoring. <br><br><img src="https://habrastorage.org/web/0a9/0ab/426/0a90ab426e704380bd16a07e0ea6dab5.jpg"><br><br>  Where to run in this case?  Monitoring exploded - this is such an abstract thing, meaning that monitoring connected to the database exploded. <br><br><img src="https://habrastorage.org/web/728/6be/977/7286be9778654133bf24e6df156f90d7.jpg"><br><br>  We think Postgres is a good database.  A good database, when it is all bad, then it comes up against something, as a rule.  In most cases, this is some kind of system resource.  It lacks the processor.  It lacks disks or even a network.  She may well rest on heavy-weight locks, locks on the lines, signs, something else.  But there are cases when the base rests on something else. <br><br><img src="https://habrastorage.org/web/0a1/a01/4e5/0a1a014e5a79497d8ff33e2d6b6cc381.jpg"><br><br>  Some pictures from the same production.  Here, for example, htop from one Postgres of base which rested against the processor.  Load Average 200, a lot of sessions and a processor in userspace, it happens. <br><br><img src="https://habrastorage.org/web/bd0/551/4ba/bd05514ba9494a9d90d081f0f3edcf67.jpg"><br><br>  The base can also be rested against the disks.  Posgres quite popular thing.  Disposal on a pair of disks is close to 100%.  await a huge amount of disk reads. <br><br><img src="https://habrastorage.org/web/cd6/e8c/8a3/cd6e8c8a354941cdb3ad687107058053.jpg"><br><br>  The disk can end not only according to iops or throughput, it can also end in place, unfortunately.  This is a picture with a base where it ended on a section with xlog. <br><br><img src="https://habrastorage.org/web/73d/a6f/d9d/73da6fd9dc1b47d0bf57bbbc0bd33291.jpg"><br><br>  We have situations when the base rests on the network to transfer ixlogs to replicas, to the archive or elsewhere on ‚Äúthick‚Äù responses to clients. <br><br><img src="https://habrastorage.org/web/bb1/14b/da1/bb114bda1b6140ffad918e4eebd262d8.jpg"><br><br>  In the case of memory, everything is more complicated.  As a rule, you will not see that you have a problem with memory.  Depending on how your operating system is configured, or you will start to get into SWAP and see this as a problem with disk activity, or OOM will come, kill the backend, and as a result, the whole Postgres will be formed. <br><br><img src="https://habrastorage.org/web/a31/f7f/ad3/a31f7fad3e5743f0886a9777a98293c3.jpg"><br><br><img src="https://habrastorage.org/web/1e4/09f/f03/1e409ff0369d4f17a6e079c8ab1feced.jpg"><br><br>  This is all well diagnosed by tools external to Postgres.  That is favorite top-like utility, dstat, iostat, etc.  I am talking mainly about Linux.  If the base rests on heavyweight locks, this information is quite possible to look through PG locks, and there are some number of requests that facilitate the parsing of the output from there with your eyes.  But they are compiled on the Postgres wiki.  Actually, the example above shows everything beautifully. <br><br><img src="https://habrastorage.org/web/ab5/bbe/9fa/ab5bbe9faabe44228076c7b6a7ef2f89.jpg"><br><br>  The explosion occurred, you have rested against something.  Because of what they rested, the devil knows.  In most cases, something has changed, something rolled out, you have increased the load on the base, as in this picture, or the plan of some query went and it did not work as expected. <br><br><img src="https://habrastorage.org/web/fee/65d/ecb/fee65decb819402e8436ef3c02b916fb.jpg"><br><br>  Before version 9.4, there was a good tool pg_stat_statements.  You can look up to the query, which of them consumes the most time.  That is, for which requests the base spends the most time.  Well, after that it‚Äôs already standard, explain analyze to see where they spend their time, what they do and so on.  But the time that the database spends on the execution of requests is not the best indicator.  This time can be spent on a variety of resources.  You can read from disk, you can "rape" the processor, you can sort something, you can expect some kind of blocking and so on. <br><br><img src="https://habrastorage.org/web/ed5/f89/7e6/ed5f897e6f9f4ffdb361264cf795747c.jpg"><br><br>  Starting from 9.4, a great thing appeared, which is called pg_stat_kcache, which allows you to look up to the request, including CPU consumption in user time, CPU consumption in system time.  And the very cool thing that she can do is to separate the physical reads from the disk and retrieve page cache data from the operating system. <br><br><img src="https://habrastorage.org/web/2f6/a55/ed2/2f6a55ed2e88405fbd6da9b5bb4a885c.jpg"><br><br>  A few examples.  For example, a query that also accurately displays information on top queries.  Again, sorted by time.  But it also shows how much they ate the processor in system time, user time, how much they wrote / read from the disk, how many they got from memory, and so on.  You can see the texts of these requests. <br><br><img src="https://habrastorage.org/web/7c3/bbc/53b/7c3bbc53b40847cdbb0e5191d8c2e90a.jpg"><br><br><img src="https://habrastorage.org/web/2b8/8f3/87a/2b88f387abdc4d47b802683f8b915610.jpg"><br><br>  The request itself looks like this.  This text can be copied.  He really is not so complicated.  It's simple.  We take data from pg_stat_statements, pg_stat_kcache and sort it, in this particular case, also by the time it spent on this request. <br><br><img src="https://habrastorage.org/web/7d2/b02/14a/7d2b0214ab4540a081cb25ca59a4ed4a.jpg"><br><br>  But this is not the biggest advantage of pg_stat_kcache.  You can sort by read from disk, write to disk, etc.  For example, the same pg_stat_statements can split shared_hit and shared_read.  This means reading from shared memory (shared buffers) and everything else.  And all this can be from the page cache of the operating system, and can be physically from the disk.  pg_stat_kcache can divide them.  It does this with the help of the getrusage () system call, which is pulled after each request. <br><br><img src="https://habrastorage.org/web/5a9/193/0a3/5a91930a386649518271141138a350fc.jpg"><br><br>  For example, we had a base that rested on a disk with readings, and we built such a thing: a request that sorts by physical reading from the disk.  And these are already relative values.  Here we see that we have requests that are in the top.  They have a few percent to reach the disk and read something from the disk.  Everything else is given either from shared memory or from the operating system cache.  That is, caching in this database worked quite efficiently.  If you are using 9.4, be sure to use pg_stat_kcache, great stuff. <br><br><img src="https://habrastorage.org/web/c76/208/078/c762080787974cad93fe2233cf5afa33.jpg"><br><br>  There are more complicated problems that are not determined at all by specific requests.  For example, such a problem.  We take and on the first arrow we increase disk IO.  Description of the fields in the middle of the picture.  These two columns are iops.  We increase iops from 10 thousand to 100 thousand.  And after some time, our base starts the whole processor to kill in the system time.  At this point in time, everything becomes bad and in general it is not clear what it does.  And if we look in pg_stat_statements or pg_stats_kcache, we will see that in systemtime, the system performs almost all requests.  This is not a problem with any particular request. <br><br><img src="https://habrastorage.org/web/e13/278/2e6/e132782e66c645ffb3259a941de6ec1a.jpg"><br><br>  To diagnose what a processor is being spent on, there is a wonderful perf utility, it is useful not for DBA and more for kernel developers, but it works by sampling, it does not hurt the combat processes.  Generally not "rape" the system.  And here it is clear that most of the processor time is spent in the spinlock.  At the same time, it can be seen that, most likely, we are spinning on getting lightweight locks.  And, most likely, in the area of ‚Äã‚Äãthe buffer cache.  Called PinBuffer, UnpinBuffer, ReadBuffer and so on.  Looking at this perf top output, you can understand where the process is wasting in system time or assume where it is spent inside the database. <br><br><img src="https://habrastorage.org/web/d39/17d/a72/d3917da72fab4a2eb5574410cad5b1fc.jpg"><br><br>  There are worse situations when we see the same spinlock, but at the same time there is nothing at all clear where this spinlock comes from and what to do next. <br><br><img src="https://habrastorage.org/web/3bd/ca9/91e/3bdca991e6cb4134a1257f5375ab761a.jpg"><br><br>  There should be a meme picture.  We can climb deeper, to see what is happening there and what we rested. <br><br><img src="https://habrastorage.org/web/06c/5ab/6fb/06c5ab6fb7cc48e7aba4ceb0ce4710e5.jpg"><br><br>  There are a number of tools for this.  One of them is dtrace and systemtap (in the case of Linux).  Its advantage is that you can literally see everything.  But for this you need to write some code.  This is the first.  Second, you need to rebuild Postgres so that the systemtap can climb into it.  And the biggest problem is that the systemtap is not applicable under any conditions.  It can be used on stands for load testing.  Because it does not always work stably and can add up to ‚Äúproduction‚Äù.  We have this happened several times.  As an advertisement, I wrote about the debugging of the situation with the help of systemtap in ‚Äúblozhik‚Äù <br><br><img src="https://habrastorage.org/web/6d1/9d6/ee4/6d19d6ee4cbf4fbcb7472bc32d06dcf3.jpg"><br><br>  Another tool is the classic GDB debugger, and we use it.  Very simply, it clings to the process, removes backtracks from threads, in the case of Postgres - one process, one thread.  Therefore, just remove the bektreys.  And uncoupled from the processor. <br><br><img src="https://habrastorage.org/web/c6f/5b6/8ee/c6f5b68ee23a40349f8a9b92668762e2.jpg"><br><br>  The output is as follows.  It shows that we hang on waiting for a lightweight weight (light-weight lock) in the area of ‚Äã‚Äãwork with the buffer cache and it is not easy somewhere there, but on a specific line of sources.  We can go to the source code for the 591 line bufmgr.c and see what happens there.  Even if you do not know C, there are quite good comments and you can understand where and what is happening. <br><br><img src="https://habrastorage.org/web/4f0/fe8/d32/4f0fe8d328cc4c8c988d576d15d539cb.jpg"><br><br>  The only thing that GDB has is an unpleasant drawback.  If you cling to the process and tell <b>ctrl + C</b> , the process will not be reached by <b>SIGTERM</b> or <b>SIGQUIT</b> , but by <b>SIGKILL</b> , and Postgres will add it to you.  Therefore, we wrote a very stupid binding.  It simply does not send all those signals that you send to this strapping before GDB.  Accordingly, it also does not reach to the back-end backends. <br><br>  Patching allows us to remove spectra from the back end, and continue to stare at them with our eyes and understand what is happening there.  One of the advantages is that it works stably and does not hurt the ‚Äúfight‚Äù.  In order for this to work, you do not need to rebuild anything.  You just need to put the debuginfo packages: postgresql-debuginfo, libc-debuginfo, kernel-debuginfo, and you will be happy.  It is important, it gives an accuracy to the line of code understanding where exactly backends spend time. <br><br><img src="https://habrastorage.org/web/e42/3c2/28c/e423c228cfa943b38001079a5c4b56b0.jpg"><br><br>  The second part of the presentation is devoted to what to do when you do not come up with some kind of performance problem, it is reproduced with confidence.  You do not know how to treat it further.  And you are prompted to write to the list and ask what to do.  But before you write to the newsletter, you can collect more diagnostics. <br><br><img src="https://habrastorage.org/web/275/244/8bc/2752448bc3914ca894d1ab165cb3b8a0.jpg"><br><br>  A few examples.  For example, we had this situation.  We shot at the base, which rested against the processor.  Here on the second picture you can see that the yellow one is a processor in userspace, it is all, almost, eaten.  At the same time, at such a profile load, we had time intervals up to two minutes, when the base did not process the load at all.  Everything was a stake.  Bursts from the operating system was not visible. <br><br><img src="https://habrastorage.org/web/cc7/d39/511/cc7d39511ffe4edcbbd31106958ff2fe.jpg"><br><br>  At the conclusion of the perftop, too, nothing that would have struck the eye was not there either.  The only thing we paid attention to at that point in time is that when this failure appears in the output, then there are calls to work with gin.  Given that there is a very small amount of time spent on it.  But as soon as failure, they appear.  As soon as everything becomes good, they disappear.  We had one gin-index in this database.  First of all, we turned it off and turned off the request that this gin-index used, and saw that everything was fine. <br><br><img src="https://habrastorage.org/web/1c1/fd8/8b9/1c1fd88b9ec34656a8900efe5fcb8592.jpg"><br><br>  Further began to understand.  It turned out that we did not read the documentation, as usual.  At 9.4 a fastupdate for gin appeared.  In most cases, it speeds up the insertion time, but at times it can lead to nondeterministic insertion time itself.  For us, the stability of time is more important than the interval of this very time, conditionally speaking.  We turned off fastupdate, everything became good.  Therefore, the first recommendation is that before you write to some kind of newsletter, you should read the documentation.  Most likely, you will find the answer there. <br><br><img src="https://habrastorage.org/web/eb8/31c/e78/eb831ce784b1484d91d5707394e7c209.jpg"><br><br>  The second example.  Again, during the shooting, we observed scans of bursts of responses to insane units of seconds.  And they did not correlate in time with any avtovakums, nor with checkpoints, nor with any system processes. <br><br><img src="https://habrastorage.org/web/0cd/94f/e36/0cd94fe36de848b9af2c3a84baf31d4d.jpg"><br><br>  From the side of the perf it looked like this.  Compaction_alloc is at the top, and then nothing quite unusual.  The classic picture of processor consumption. <br><br><img src="https://habrastorage.org/web/41f/e3d/afb/41fe3dafb7f84961884250388c0a2d7d.jpg"><br><br>  In GDB, it looked like a shared memory problem, but again, in the buffer cache area.  It is important, it began to climb out after the upgrade to 9.4.  At 9.3 this was not.  They started catching this because huge pages appeared in 9.4, and transparent hat pages are turned on by default in red hat-based operating systems and they are disgusting.  Actually, we are not the first who have encountered this problem. <br><br><img src="https://habrastorage.org/web/93e/cac/c3b/93ecacc3b8d04af48cc8cacc7fc604db.jpg"><br><br>  Here is a link to the ‚Äúthread‚Äù with a discussion of this problem.  Turned off transparent huge pages, everything began to fly.  This is the second recommendation, the field of how reading the documentation did not help.  Although in 95% of cases it will help.  It makes sense to search the Internet, most likely, this problem besides you already someone faced. <br><br><img src="https://habrastorage.org/web/5d4/8fd/d00/5d48fdd00d67479c8f2bd92a9a5c7ebc.jpg"><br><br>  The third example.  The same problem when after some time after increasing the disk IO base all the time starts to spend in the system.  The whole processor. <br><br><img src="https://habrastorage.org/web/bf4/9de/5b4/bf49de5b4d234c369738cfd3562ca26a.jpg"><br><br>  And in the perf output, it looks like a spinlock. <br><br><img src="https://habrastorage.org/web/d64/62e/659/d6462e659e474f6d9eda0bd4ca2ca6b0.jpg"><br><br>  We took a certain number of backtraces and then analyzed them and found that almost everything around working with the buffer cache.  Even the source is not necessary to go. <br><br><img src="https://habrastorage.org/web/722/595/201/7225952014ad4532b5e67aaeb9fc6720.jpg"><br><br>  The classic recommendation in this case is to reduce shared buffers.  Usually, those who start working with Postgres will cut off all available RAM under the shared buffers.  As a rule, it ends badly.  The classic recommendation is <b>25% of all memory</b> , but not more than 8 GB.  Actually <b>reducing to 8 GB</b> you will remove this problem.  But we really wanted to cut off a lot under shared buffers, for some reason. <br><br>  We went to the source and looked at where these lines occur.  They saw that they were around locks on the buffer cache partition.  At 9.5, the value 128 will be the default.  At 9.4 still 16. We took and increased.  This reduced the number of locks.  In addition, there are a couple of patches in 9.5, which have already been discussed.  This is an improved performance on many types of loads.  The only thing that these patches, mainly about reading load.  If you have a database in which there are a lot of readings, you can cut off almost all the memory under <b>shared buffers</b> and most likely you will not experience problems. <br><br>  If you have a lot of records there, sooner or later you will still face this problem.  On the wiki "postgresnoy" gather ideas how to improve this situation in the future.  As a matter of fact, if suddenly reading the documentation and searching the Internet did not give you an answer to the solution to your problem, it makes sense to smoke the source code and, possibly, tweak one variable, and it will solve your problem.  But it seems that this is quite rare. <br><br><img src="https://habrastorage.org/web/0fb/72c/ec7/0fb72cec725044cab3e736f1b49042b4.jpg"><br><br>  Fourth example.  Description of the problem is available here.  The essence is approximately the following: a large table about a billion lines in size, a large B-tree index (200 GB in size).  You say VACUUM on this tablet, and you have a rollback of changes on the replicas for 15 minutes.  Speech about stream replication. <br><br><img src="https://habrastorage.org/web/e61/3f8/88a/e613f888ab49404a8927cf04381b974a.jpg"><br><br>  And while it is clear that the replicas begin to read a lot from the disk, from the partition where the data itself lies.  It can be seen that the startup process is the one that rolls up xlog, and eats a lot of disk reading. <br><br><img src="https://habrastorage.org/web/518/17f/639/51817f6390cf475c8371078fb32d37cc.jpg"><br><br>  In this case it is useless to see the output of the top stamp, since we are all doing it in the IO, and not in the processor.  In GDB, it can be seen that we really hang on reading from the disk.  This is a libc's call.  And up to the line of the code you can see where we are doing this.  If you go to the source and see what happens there, it is written there right in <b>non-Russian</b> and white that what was done is not optimal.  Can be improved. <br><br><img src="https://habrastorage.org/web/b31/0b7/8d4/b310b78d45cc4d9398b5aaf982bf56f4.jpg"><br><br>  Link to the discussion of this problem, about how to solve it.  All this ended with a patch to Postgres, which allows the replica lag to be reduced.  Do not remove at all, and cut.  Here in the picture just two replicas.  The green one is a replica without a patch.  The one that is blue is a replica with a patch.  The graph shows the lag.  And this is on the chart reading from the disk [approx.  Ed .: right].  The reading volume does not increase.  This I mean, if reading the documentation, searching the Internet and stupid contemplation of the source did not give you the answer to your question, then it would be good to correct them.  But, if you do not know C, for example, I, then for this particular situation, when we have a large table, a large <b>B-Tree</b> index and you have few changes there, mainly <b>insert-only</b> load, it makes sense to partition it and you will not have such a problem. <br><br><img src="https://habrastorage.org/web/e04/67b/3d4/e0467b3d40d84c8f93a5e273a2d384a4.jpg"><br><br>  By this point in time, you should have the following thought in your head: yes, they have been sticking out, GDB in battle, the Postgres source code will not be patched, not a normal DBA will be doing this.  And this thought is correct.  We thought so too.  Therefore, I invite here Ildus, who will tell us about the bright future that awaits us. <br><br><img src="https://habrastorage.org/web/535/122/aa8/535122aa8f694960836192aa8d3ed6bc.jpg"><br><br>  <b>Ildus Kurbangaliev</b> : Hello everyone.  My name is Ildus.  I‚Äôm a Postgres Professional developer.  At the moment I am doing monitoring.  That is, I make a patch for monitoring, which will allow to monitor these expectations in Postgres.  Waiting is exactly what Postgres rests on.  These are, for example, a disk, a network, ‚Äúlatches‚Äù, lightweight ‚Äúlocks‚Äù that occur inside, or the heavy-weight loks themselves.  These expectations are subdivided into many subtypes.  Lightweight locks can be 50 pieces. Lokov 9 pieces.  Network - can be read or write.  Storage is the same. <br><br><img src="https://habrastorage.org/web/ee3/8e1/065/ee38e1065981460bbeb3b8c3f24840fd.jpg"><br><br>  Why do you need a separate monitoring tool?  Often, the second point is actually the first.  Because there are so many of them, and we must deal with each separately.  It is desirable to have a tool that unites them.  I had just such a task.  For example, systemtap is a good tool, but it cannot be used in production. <br><br><img src="https://habrastorage.org/web/af3/a71/7cb/af3a717cb9b94b9da7d321e3e1c4a94b.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, I developed pg_stat_wait, which can do profiling, tracing to a file and waiting history. There is a special parameter, you can write and save them, then read them separately. Profiling reads the number and waiting time for each wait. For individual processes, you can enable tracing. There it turns out the PID of the process, the file name, and all the expectations for this process are written there. The minus tracing is that a large overhead is obtained and cannot be used online. I did the profiling so that it could be used in production.</font></font><br><br><img src="https://habrastorage.org/web/3fd/79b/476/3fd79b476eea4519b2b80ff87b7c5d7c.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here I wrote the requirements that were set. That is, the patch should work online. Do not heavily load the database itself. According to all expectations, it is desirable to obtain accurate data. Namely, the time in milliseconds, the number and the main goal that we combine a bunch of tools into one. In the way it looks. </font></font><br><br><img src="https://habrastorage.org/web/72b/3cc/d77/72b3ccd77546439fa2db7d725f956ad8.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the profiler, there is a feature that calls a separate function that just returns this data. That is, for each expectation, you can just see how long it took, the amount. You can, for example, make some beautiful graphics, you can make a reserve, request again and build a graph, where everything will be visible. Here you can see that the main amount of time here is just on the ‚Äúlatches‚Äù and is spent on working with the network. And here one LWLock hit.</font></font><br><br><img src="https://habrastorage.org/web/d74/30e/432/d7430e4325e040d0a858a0eee0c47f9d.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The story looks that way. If the parameter is 5 thousand, we get the last 5 thousand expectations, they must also be quickly requested, because they are quickly erased. And we see just the parameters of each waiting. On </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">storage,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you can see which particular block is being written. And calculate the table itself, which we upload. </font></font><br><br><img src="https://habrastorage.org/web/4dd/fb0/e32/4ddfb0e3279748c5b43c3e3225a20e6b.jpg"><br><br><img src="https://habrastorage.org/web/74c/c9c/336/74cc9c3362a745939eff1dd178136e5c.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the start of the trace: call the function ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pid, file</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) and see this result. It says here when it was a start, and when it was all over, you can count the time and see where this record is being made.</font></font><br><br><img src="https://habrastorage.org/web/fbc/5fb/dc6/fbc5fbdc6b1a46d38cf1e3119e5f4c62.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A little bit about implementation. Initially, there was only one parameter in monitoring. These are the five types, and they were going to be sampled, and the profile was made on them. This turned out to be not very useful, because the sampling, firstly, puts a block on the process list. And, secondly, when the search goes, other processes can put locks, and they are skipped. Now done a little differently. That is, each backend collects an aggregation within itself and from time to time throws it into shared memoery. From there, just the profile and is given. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The story is collected by the yellow collector: it </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">goes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> through </font><b><font style="vertical-align: inherit;">ProcArray</font></b><font style="vertical-align: inherit;"> and records what is happening there now. There is a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">current view</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separate, which can be seen on what hangs a specific process at the moment. Everything is implemented on block free algorithms to try to avoid the overhead. </font></font><br><br><img src="https://habrastorage.org/web/121/c8e/aef/121c8eaefa2440f8b577b231b4700457.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is an example of how this </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">block free</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algorithm is made on history. We hold two blocks for each waiting. And when the backend writes to one, we read another. And thus avoid blocking. </font></font><br><br><img src="https://habrastorage.org/web/dcc/229/382/dcc229382f1743ed91e68442e05e457f.jpg"><br><br><img src="https://habrastorage.org/web/ab1/10f/df3/ab110fdf33b340f1afd162da7c7ae205.jpg"><br><br><img src="https://habrastorage.org/web/8fb/328/a92/8fb328a925ba48bcabb90c703d7d177c.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And I did a lot of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">overhead</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> measurement </font><font style="vertical-align: inherit;">. These tests showed that our overhead projector is less than, in this case, 0.5%. But I‚Äôll clarify that I tested it on </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SELECT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> queries, and therefore the result is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_bench</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. There even with monitoring and without it is impossible to evaluate the overhead projector. And if someone comes up with how to do it, I will be very grateful. Because it is very difficult to get a stable result when writing. </font></font><br><br><img src="https://habrastorage.org/web/10d/c95/63a/10dc9563af8d441a902ad5b6e0dd48ed.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here the code is open in open source, gitgub has this project, you can create an issue there, if you are missing something, test it, check it in your database, and search for bugs too. It is very useful. There are two more links where you can see the correspondence on these issues, too, to participate there. </font></font><br><br><img src="https://habrastorage.org/web/812/b72/69b/812b7269b26d44a38dc13b94cceb3d4e.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are examples of using this monitoring. Vova will tell about it. </font></font><br><br><img src="https://habrastorage.org/web/3b6/fdc/372/3b6fdc372bf64121ac28c28dfb89f023.jpg"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vladimir Borodin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: A little about examples. Ildus said that you can download, try, test, search for bugs. We downloaded, tried, searched, tested. We are already in production on all machines 9.4. The patch is for 9.4 and there is a patch for the current master, who is now jostling </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">upstream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How was it before? We have a base that does not seem to rest on anything, but doesn‚Äôt give out further. 20 thousand transactions per second and period. No longer possible. In GDB, we saw that it hangs with us right here: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcArrayEndTransaction</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and getting a lightweight lock. Again, with the accuracy of a line of code, we could find out that it is hanging on a ProcArrayLock. This GDB can connect, catch on a particular backend and see it. </font></font><br><br><img src="https://habrastorage.org/web/38a/2a3/539/38a2a35398524882a809b87945ad8745.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now this is one SELECT query in</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_stat_wait_current</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_stat_wait_history</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , depending on whether you are watching the situation now or the history of what was once. And here it is clear that they all hang on </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcArrayLock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and how much time they spent waiting for this very ProcArrayLock. </font></font><br><br><img src="https://habrastorage.org/web/941/be1/63f/941be163f9b94b24af35bfc6a93584a7.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This can be visualized. This is a graph of how much time the base spends in each class waiting. Red is a disk, green is a lightweight lock, blue is a heavy-wait lock. The network and the ‚Äúlatches‚Äù are turned off here, because they usually take a lot of time. As long as your backend is hanging and doing nothing, it has a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">network</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wait class </font><font style="vertical-align: inherit;">, there the wait time is very long. When a checkpoint hangs and does nothing, it has a </font><b><font style="vertical-align: inherit;">latch</font></b><font style="vertical-align: inherit;"> waiting class.</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the waiting time is infinite. Well, not infinitely, but very large. And here it is obvious that most of the time the base, when waiting for something, it waits for disk IO, but sometimes it hangs on light-weight lokas. On the Y axis - the time we are waiting, and on the X axis - the calendar time. </font></font><br><br><img src="https://habrastorage.org/web/b3b/5d5/20e/b3b5d520e8484f96b6eaaf2b32aad203.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can build the same schedule regarding what happens inside the light-weight lock. You will see that the most yellow color is here and the yellow color is BufferPartitionLock. Those same locks and buffer cache partitions, and not just like that, we increased them from 16 to 128. Not just like that, in 9.5 they were highly optimized.</font></font><br><br><img src="https://habrastorage.org/web/2cf/623/8bf/2cf6238bfb084be09e02858236a59435.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, this is how the picture of waiting classes looks like at the moment when everything became bad in the database. It can be seen that they first exploded, and we hung on waiting for lightweight locks, and after some time we were locked at the level of the lines of the plates, on heavy-weight locks. </font></font><br><br><img src="https://habrastorage.org/web/007/4cf/0e9/0074cf0e9b384afc85d6c209ceaf1a09.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you look at which </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">light-weight of</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> locks is to blame, then in theory, there should be ProcArrayLock and BuffFreelistLock. They hung on </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuffFreelistLock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 'e, and on </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcArrayLock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ' there were a lot, because at the moment of time a large number of backends were created, new connections were opened, and this is the load on </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcArray</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main source of the problem is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuffFreelistLock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is no longer at 9.5, it was sawed in one of the optimizations.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's time to sum up. </font><font style="vertical-align: inherit;">It seems that this is a long-awaited feature that exists in many other databases and makes life much easier for DBA. </font></font><br><br><img src="https://habrastorage.org/files/a61/060/56f/a6106056fcce49a29cd997efd8bc97b9.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next summer at PG Day'17, Yandex specialists are preparing for you several cool presentations. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vladimir Krasilshchik will </font></font></b> <a href="http://pgday.ru/ru/2017/papers/179%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dboodin"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">talk with the audience about Big Data</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vasily Sozykin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will tell the epic </font></font><a href="http://pgday.ru/ru/2017/papers/154%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dboodin"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">migration story on PostgreSQL to Yandex.Money</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexey Milovidov</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lead developer of the popular analytic DBMS ClickHouse, </font><font style="vertical-align: inherit;">will tell </font></font><a href="http://pgday.ru/ru/2017/papers/217%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dboodin"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">about the internal structure of his invention</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font> Join now! </div><p>Source: <a href="https://habr.com/ru/post/329178/">https://habr.com/ru/post/329178/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329166/index.html">Bug in NTFS, or how to hang the whole system</a></li>
<li><a href="../329168/index.html">Pygest # 9. Releases, articles, interesting projects from the world of Python [May 8, 2017 - May 22, 2017]</a></li>
<li><a href="../329170/index.html">Domestic processor from the company ELVIS</a></li>
<li><a href="../329174/index.html">Load testing: where to start and where to look</a></li>
<li><a href="../329176/index.html">From dependent types to homotopic type theory on Scala + Shapeless + ProvingGround</a></li>
<li><a href="../329180/index.html">We write an analogue of Paint on Objective-C</a></li>
<li><a href="../329182/index.html">Seminar "Modernization of engineering systems in the existing data center", May 31, Moscow</a></li>
<li><a href="../329184/index.html">Bitdefender Hypervisor Introspection: a new means of dealing with hidden cyber threats</a></li>
<li><a href="../329188/index.html">Confronting Positive Hack Days: Hackers won't be bored</a></li>
<li><a href="../329190/index.html">Google I / O Site Tour</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>