<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple FDTD implementation in Java</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="FDTD ( Finite Difference Time Domain ) - the method of finite differences in the time domain - the most "honest" method for solving the problem of ele...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple FDTD implementation in Java</h1><div class="post__text post__text-html js-mediator-article">  <b>FDTD</b> ( <i>Finite Difference Time Domain</i> ) - the method of finite differences in the time domain - the most "honest" method for solving the problem of electrodynamics from low frequencies to the visible range.  The essence is the solution of Maxwell's equations "head on."  <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25BA%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D1%2585_%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B5%25D0%25B9_%25D0%25B2%25D0%25BE_%25D0%25B2%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">It is</a> well painted.  Especially look at the grid. <br><br>  The problem was solved in the two-dimensional case by a simple explicit difference scheme.  I don't like implicit schemes, and they require a lot of memory.  Calculation with normal accuracy requires small pitch grids, as compared with simpler methods, a lot of time is required.  Therefore, maximum emphasis was placed on performance. <br><br>  Presents the implementation of the algorithm in Java and C ++. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/93b/dbf/61c/93bdbf61cb454db3ba6246c3484331b5.png" alt="image"><br><a name="habracut"></a><br><h2>  Foreword </h2><br>  About six years, my main language for calculations and trifles was Matlab.  The reason is the simplicity of writing and visualizing the result.  And since I switched from Borland C ++ 3.1, the progress of the possibilities was obvious.  (In Python, I never fumbled, but in C ++ then weakly). <br><br>  I needed FDTD for calculations as a reliable and reliable method.  Began to study the issue in 2010-11.  Available packages or it was not clear how to use, or did not know what I needed.  I decided to write my own program for precise control over everything.  After reading the classic article ‚Äú <i>Numerical solution of Maxwell‚Äôs equations in isotropic media</i> ‚Äù, he wrote a three-dimensional case, but then simplified it to a two-dimensional one.  Why 3D is difficult, I will explain later. <br><br>  Then he optimized and simplified the Matlab code as much as possible.  After all the improvements, it turned out that the 2000x2000 grid runs in 107 minutes.  At i5-3.8 GHz.  Then this speed was enough.  The useful thing was that the calculation of complex fields immediately took place in Matlab, and it was easy to show pictures of the spread.  Also, everything was considered to be in doubles, because the Matlab's speed practically had no effect.  Yes, my standard calculation is one pass of light through a photonic crystal. <br><br>  There were two problems.  It was necessary to calculate the spectra with high accuracy, and to do this, use a large grid width.  A physical increase in the area in both coordinates by 2 times increases the calculation time by 8 times (crystal size * time of passage). <br><br>  I continued to use Matlab, but became a Java programmer.  And, comparing the performance of different algorithms, he <b>began to suspect something</b> .  For example, bubble sorting - only loops, arrays and comparisons - in Matlab is <b>6 times slower</b> than in C ++ or Java.  And this is still good for him.  The five-dimensional cycle for the Euler conjecture in Matlab is 400 times longer. <br><br>  First I started writing FDTD in C ++.  There was an embedded std :: complex.  But then I abandoned this idea.  (In Matlab, not such brackets, copy-paste did not work, I had to spend a drop of time).  Now I checked C ++ - <b>complex mathematics gives speed loss 5 times</b> .  It's too much.  As a result, wrote in Java. <br><br>  A little about the question "Why Java?".  I will describe the performance details later.  In short, in simple non-OOP code, only arithmetic and cycles are C ++ with O3 optimization or the same speed, or up to + 30% faster.  I just know better now how to understand Java, interface and work with graphics. <br><br><h2>  FDTD - more details </h2><br>  We now turn to the code.  I will try to show everything, with explanations of the problem and the algorithm.  In the two-dimensional case, the Maxwell system of equations splits into two independent subsystems - TE and TM waves.  The code is shown for TE.  There are 3 components - electric field Ez and magnetic Hx, Hy.  To simplify the time has the dimension of meters. <br><br>  Initially, I thought that there was no point in float, since all calculations are reduced to double.  Therefore, I will give the code for double - it is less than the excess.  All arrays have dimensions of +1, so that the indices coincide with the Matlab matrices (from 1, not from 0). <br><br>  Somewhere in the start code: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nx = <span class="hljs-number"><span class="hljs-number">4096</span></span>;<span class="hljs-comment"><span class="hljs-comment">//  .  2  . public static int ny = 500;//  </span></span></code> </pre> <br>  The main method: <br><br><div class="spoiler">  <b class="spoiler_title">Initialization of initial variables</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] callFDTD(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nx, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ny, String method) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j;<span class="hljs-comment"><span class="hljs-comment">//    double x; //  final double lambd = 1064e-9; //     final double dx = lambd / 15; //   .  Œª/10.  ,   . final double dy = dx; //    .   final double period = 2e-6; //      final double Q = 1.0;//   final double n = 1;//     final double prodol = 2 * n * period * period / lambd / Q; //  final double omega = 2 * PI / lambd; //     final double dt = dx / 2; //   .  ,    final double tau = 2e-5 * 999;//    .     .  ,  . final double s = dt / dx; //      final double k3 = (1 - s) / (1 + s);//    final double w = 19e-7;//    final double alpha = sin(0.0 / 180 * PI);//     .  . double[][] Ez = new double[nx + 1][ny + 1]; double[][] Hx = new double[nx][ny]; //    double[][] Hy = new double[nx][ny];</span></span></code> </pre> <br></div></div><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> begin = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,    .     . final double mod = 0.008 * 2;//     = 2*Œîn; final double ds = dt * dt / dx / dx;//     </span></span></code> </pre> <br>  Initialization of the dielectric constant (crystal lattice).  More precisely, the return value with constants.  A discrete function is used (0 or 1).  It seems to me closer to real samples.  Of course, you can write anything here: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[nx + <span class="hljs-number"><span class="hljs-number">1</span></span>][ny + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; nx + <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; ny + <span class="hljs-number"><span class="hljs-number">1</span></span>; j++) { e[i][j] = ds / (n + ((j &lt; begin) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : (mod / <span class="hljs-number"><span class="hljs-number">2</span></span>) * (<span class="hljs-number"><span class="hljs-number">1</span></span> + signum(-<span class="hljs-number"><span class="hljs-number">0.1</span></span> + cos(<span class="hljs-number"><span class="hljs-number">2</span></span> * PI * (i - nx / <span class="hljs-number"><span class="hljs-number">2.0</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * dx / period) * sin(<span class="hljs-number"><span class="hljs-number">2</span></span> * PI * (j - begin) * dy / prodol))))); } }</code> </pre> <br>  The crystal lattice looks like this: <br><br><img src="https://habrastorage.org/files/f49/e7d/9cf/f49e7d9cf2934312a5adc761c6866f49.png" alt="image"><br><br>  Arrays used for boundary conditions: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] end = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>][nx + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] top = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>][ny + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] bottom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>][ny + <span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre> <br>  Count limit on time.  Since we have a step dt = dx / 2, the standard coefficient is 2. If the medium is dense, or you need to go at an angle - more. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tMax = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (ny * <span class="hljs-number"><span class="hljs-number">2.2</span></span>);</code> </pre> <br>  We start the main loop: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = <span class="hljs-number"><span class="hljs-number">1</span></span>; t &lt;= tMax; t++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> tt = Math.min(t * s + <span class="hljs-number"><span class="hljs-number">10</span></span>, ny - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  The variable tt here takes into account the speed limit of light, with a small margin.  We will consider only the area where the light could reach. <br><br>  Instead of complex numbers, I consider two components separately - sine and cosine.  I thought that for speed it's better to copy a piece than to make a choice inside the loop.  Perhaps replace the function call or lambda. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (method) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"cos"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= nx - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { x = dx * (i - (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) nx / <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     Ez[i][1] = exp(-pow(x, 2) / w / w - (t - 1) * dt / tau) * cos((x * alpha + (t - 1) * dt) * omega); } break;</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">sin</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"sin"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= nx - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { x = dx * (i - (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) nx / <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>); Ez[i][<span class="hljs-number"><span class="hljs-number">1</span></span>] = exp(-pow(x, <span class="hljs-number"><span class="hljs-number">2</span></span>) / w / w - (t - <span class="hljs-number"><span class="hljs-number">1</span></span>) * dt / tau) * sin((x * alpha + (t - <span class="hljs-number"><span class="hljs-number">1</span></span>) * dt) * omega); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br></div></div><br>  Here, at our entrance to the region (to the leftmost coordinate), a Gaussian beam of half-width w enters, at an angle Œ±, oscillating in time.  This is exactly how the ‚Äúlaser‚Äù radiation of the required frequency / wavelength appears. <br><br>  Then we copy the temporary arrays under <a href="http://ieeexplore.ieee.org/document/4091495/">Moore‚Äôs</a> absorbing boundary <a href="http://ieeexplore.ieee.org/document/4091495/">conditions</a> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= nx; i++) { end[<span class="hljs-number"><span class="hljs-number">0</span></span>][i] = Ez[i][ny - <span class="hljs-number"><span class="hljs-number">1</span></span>]; end[<span class="hljs-number"><span class="hljs-number">1</span></span>][i] = Ez[i][ny]; } System.arraycopy(Ez[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>, top[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>, ny + <span class="hljs-number"><span class="hljs-number">1</span></span>); System.arraycopy(Ez[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>, top[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>, ny + <span class="hljs-number"><span class="hljs-number">1</span></span>); System.arraycopy(Ez[nx - <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>, bottom[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>, ny + <span class="hljs-number"><span class="hljs-number">1</span></span>); System.arraycopy(Ez[nx], <span class="hljs-number"><span class="hljs-number">0</span></span>, bottom[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>, ny + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Now we go to the main calculation - the next step across the field.  The peculiarity of Maxwell's equations is that the time variation of the magnetic field depends only on the electric one and vice versa.  This allows you to write a simple difference scheme.  The initial formulas were as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e4a/b8e/f94/e4ab8ef946bf4facb572e7444b6249d1.png" alt="image"></div><br>  I recalculated all the extra constants in advance, replaced the dimension H, introduced and took into account the dielectric constant.  Since the original formulas for the grid shifted by 0.5, you need not make a mistake with the indices of the arrays E and N. They are of different lengths - E is 1 more. <br><br>  Cycle area for E: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt;= nx - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">2</span></span>; j &lt;= tt; j++) {<span class="hljs-comment"><span class="hljs-comment">//       ? Ez[i][j] += e[i][j] * ((Hx[i][j - 1] - Hx[i][j] + Hy[i][j] - Hy[i - 1][j])); } }</span></span></code> </pre> <br>  And now finally apply the boundary conditions.  They are needed because the difference scheme does not consider extreme cells - there are no formulas for them.  If you do nothing, the light will be reflected from the walls.  Therefore, we use the method that minimizes reflection in a normal fall.  We process three sides - top, bottom and right.  The loss of productivity on the boundary conditions is about 1% (the smaller, the larger the task). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= nx; i++) { Ez[i][ny] = end[<span class="hljs-number"><span class="hljs-number">0</span></span>][i] + k3 * (end[<span class="hljs-number"><span class="hljs-number">1</span></span>][i] - Ez[i][ny - <span class="hljs-number"><span class="hljs-number">1</span></span>]);<span class="hljs-comment"><span class="hljs-comment">//end } for (i = 1; i &lt;= ny; i++) { Ez[1][i] = top[1][i] + k3 * (top[0][i] - Ez[2][i]);//verh kray Ez[nx][i] = bottom[0][i] + k3 * (bottom[1][i] - Ez[nx - 1][i]); }</span></span></code> </pre> <br>  On the left is a special border - a ray is generated in it.  Just like last time.  Just 1 step further in time. <br><br><div class="spoiler">  <b class="spoiler_title">Laser</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (method) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"cos"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= nx - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { x = dx * (i - (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) nx / <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>); Ez[i][<span class="hljs-number"><span class="hljs-number">1</span></span>] = exp(-pow(x, <span class="hljs-number"><span class="hljs-number">2</span></span>) / w / w - (t - <span class="hljs-number"><span class="hljs-number">1</span></span>) * dt / tau) * cos((x * alpha + t * dt) * omega); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"sin"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= nx - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { x = dx * (i - (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) nx / <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>); Ez[i][<span class="hljs-number"><span class="hljs-number">1</span></span>] = exp(-pow(x, <span class="hljs-number"><span class="hljs-number">2</span></span>) / w / w - (t - <span class="hljs-number"><span class="hljs-number">1</span></span>) * dt / tau) * sin((x * alpha + t * dt) * omega); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br></div></div><br>  It remains only to calculate the magnetic field: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= nx - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { <span class="hljs-comment"><span class="hljs-comment">// main Hx Hy for (j = 1; j &lt;= tt; j++) { Hx[i][j] += Ez[i][j] - Ez[i][j + 1]; Hy[i][j] += Ez[i + 1][j] - Ez[i][j]; } } } //  3- .</span></span></code> </pre> <br>  And little things: pass the final segment to calculate the Fourier transform - finding the picture in the far zone (direction space): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos = method.equals(<span class="hljs-string"><span class="hljs-string">"cos"</span></span>) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    BasicEx.forFurier[pos] = new double[nx]; //      int endF = (int) (ny * 0.95);//     for (i = 1; i &lt;= nx; i++) { BasicEx.forFurier[pos][i - 1] = Ez[i][endF]; for (j = 1; j &lt;= ny; j++) { Ez[i][j] = abs(Ez[i][j]);// ABS } //   ,      -     } Hx = null; // ,     Hy = null; e = null; return Ez; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Then we put the squares of the two components, and display the intensity image.</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nx + <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; ny + <span class="hljs-number"><span class="hljs-number">1</span></span>; j++) { co.E[i][j] = co.E[i][j] * co.E[i][j] + si.E[i][j] * si.E[i][j]; } }</code> </pre> <br></div></div><br>  Separately, we take the Fourier transform: <br><br><pre> <code class="java hljs">fft.fft(forFurier[<span class="hljs-number"><span class="hljs-number">0</span></span>], forFurier[<span class="hljs-number"><span class="hljs-number">1</span></span>]);</code> </pre> <br>  Since I do not understand fast Fourier, I took the <a href="https://www.ee.columbia.edu/~ronw/code/MEAPsoft/doc/html/FFT_8java-source.html">first one I got</a> .  Minus - width is only a power of two. <br><br><h2>  About performance </h2><br>  We turn to the most interesting for me - what good we have received by moving from Matlab to Java.  In Matlab I once optimized everything I could.  In Java, it is mostly an internal loop (complexity n ^ 3).  Matlab has already taken into account that he considers two components at once.  Speed ‚Äã‚Äãin the first stage (more is better): <br><table><tbody><tr><td>  Matlab </td><td>  one </td></tr><tr><td>  Matlab matrix </td><td>  3.4 / <b>5.1</b> (float) </td></tr><tr><td>  Java double </td><td>  50 </td></tr><tr><td>  C ++ gcc double </td><td>  48 </td></tr><tr><td>  C ++ MSVS double </td><td>  55 </td></tr><tr><td>  C ++ gcc float </td><td>  73 </td></tr><tr><td>  C ++ MSVS float </td><td>  79 </td></tr></tbody></table><br>  <b>UPD.</b>  Added the result of Matlab, in which he replaced the double cycles with the subtraction of matrices. <br>  We describe the main participants of the competition. <br><br><ul><li>  Matlab - 2011b and 2014. The transition to 32-bit numbers gives a very small increase in speed. </li><li>  Java is at first 7u79, but mostly 8u102.  It seemed to me that 8 was slightly better, but did not compare in detail. </li><li>  Microsoft VisualStudio 2015 release configuration </li><li>  MinGW, gcc 4.9.2 32 bit, December 2014, always O3 optimization.  march = core i7, without AVX.  AVX on my laptop is not there, where there is a growth did not give. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Test machines:</b> <div class="spoiler_text"><ul><li>  Pentium 2020m 2.4 GHz, ddr3-1600 1 channel </li><li>  Core i5-4670 3.6‚Äì3.8 GHz, ddr3-1600 2 channels </li><li>  Core i7-4771 3.7‚Äì3.9 GHz, ddr3-1333 2 channels </li><li>  Athlon x3 3.1 GHz, ddr3-1333, very slow memory controller. </li></ul><br></div></div><br><h2>  2-core stage </h2><br>  At first, I considered the TE and TM components sequentially.  By the way, this is the only option with a lack of memory.  Then he wrote two threads - simple Runnable.  Here are just a little progress.  Only 20-22% faster than 1-flow.  Started looking for reasons.  Threads worked fine.  2 cores were stably loaded at 100%, not allowing the laptop to live. <br><br>  Then I counted the performance.  It turned out that it rests on the speed of RAM.  The code was already working at the limit of reading.  "I had to" switch to <b>float</b> .  An accuracy check showed that there were no deadly errors.  There is definitely no visual difference.  The total energy differed in the 8th sign.  After the integral transformation, the maximum of the spectrum is at 0.7e-6.  <i>Perhaps, the fact is that Java considers everything in 64-bit precision, and only then it converts to 32.</i> <br><br>  But the main thing - got a performance spurt.  The total effect of 2 cores and the transition to float + 87‚Äì102%.  (The faster the memory and the more cores, the better the gain).  Athlon x3 gave little gain. <br>  The implementation in C ++ is similar - through std :: thread (see the end). <br><br>  Current speeds (2 threads): <br><table><tbody><tr><td>  Java double </td><td>  61 </td></tr><tr><td>  Java float </td><td>  64-101 </td></tr><tr><td>  C ++ gcc float </td><td>  87-110 </td></tr><tr><td>  C ++ gcc 6.2 64 native </td><td>  99-122 </td></tr><tr><td>  Visual studio </td><td>  112- <b>149</b> </td></tr></tbody></table><br>  (new compilers provide very high performance, compared to Java, on 16384. Java and GCC-4.9 32 fail in this case). <br>  All evaluations were performed for a single run calculation.  Because, if you re-run from the GUI, without closing the program, the speed further increases.  IMHO, jit-optimization taxis. <br><br><h2>  4-core stage </h2><br>  It seemed to me that there was still much to accelerate.  I started on the 4-way version.  Essence - the region is divided in half and counted in 2 streams, first along E, then along N. <br><br>  I first wrote it on Runnable.  It turned out terribly - acceleration was only for a very large width of the area.  Excessive costs of spawning new streams.  Then I mastered java.util.concurrent.  Now I had a fixed pool of threads that were given tasks: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">//‚Ä¶‚Ä¶ cdl = new CountDownLatch(2); NewThreadE first = new NewThreadE(Ez, Hx, Hy, e, 2, nx / 2, tt, cdl); NewThreadE second = new NewThreadE(Ez, Hx, Hy, e, nx / 2 + 1, nx - 1, tt, cdl); service.execute(first); service.execute(second); try { cdl.await(); } catch (InterruptedException ex) { }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">And for H:</b> <div class="spoiler_text"><pre> <code class="java hljs"> cdl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountDownLatch(<span class="hljs-number"><span class="hljs-number">2</span></span>); NewThreadH firstH = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NewThreadH(Ez, Hx, Hy, <span class="hljs-number"><span class="hljs-number">1</span></span>, nx / <span class="hljs-number"><span class="hljs-number">2</span></span>, tt, cdl); NewThreadH secondH = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NewThreadH(Ez, Hx, Hy, nx/<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>, nx-<span class="hljs-number"><span class="hljs-number">1</span></span>, tt, cdl); service.execute(firstH); service.execute(secondH); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { cdl.await(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { }</code> </pre> <br></div></div><br>  Inside the thread, the loop is executed. <br><br><div class="spoiler">  <b class="spoiler_title">class NewThreadE</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewThreadE</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[][] Ez; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[][] Hx; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[][] Hy; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[][] e; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iBegin; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iEnd; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tt; CountDownLatch cdl; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewThreadE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] E, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] H, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] H2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] eps, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iBegi, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iEn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ttt, CountDownLatch cdl)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cdl = cdl; Ez = E; Hx = H; Hy = H2; e = eps; iBegin = iBegi; iEnd = iEn; tt = ttt; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = iBegin; i &lt;= iEnd; i++) { <span class="hljs-comment"><span class="hljs-comment">// main Ez for (int j = 2; j &lt;= tt; j++) { Ez[i][j] += e[i][j] * ((Hx[i][j - 1] - Hx[i][j] + Hy[i][j] - Hy[i - 1][j])); } } cdl.countDown(); } }</span></span></code> </pre> <br></div></div><br>  A similar class for H is just different boundaries and its own cycle. <br><br>  Now there is always a gain from 4 streams - from 23 to 49% (.jar).  The smaller the width, the better - judging by the speed, we get into the cache memory.  The greatest benefit will be if we consider the long narrow tasks. <br><table><tbody><tr><td>  Java float 4 threads </td><td>  86‚Äì151 </td></tr><tr><td>  C ++ gcc float 4flow </td><td>  122‚Äì162 (closer to 128) </td></tr><tr><td>  C ++ gcc 6.2 64 native </td><td>  124‚Äì173 </td></tr><tr><td>  Visual studio </td><td>  139‚Äì183 </td></tr></tbody></table><br>  The C ++ implementation so far contains only simple std :: thread.  Therefore, for her, the wider, the better.  Acceleration of C ++ from 5% with a width of 1024 to 47% at 16384. <br>  <b><u>UPD.</u></b>  <b>Added results of GCC 6.2-64 and VisualStudio.</b>  VS is faster than old GCC by 13‚Äì43%, new by 3‚Äì11%.  The main features of 64-bit compilers are faster work on wide tasks.  Also, since Java is better parallelized on small tasks (cache), and C ++ on broad tasks - on broad tasks Visual Studio is 61% faster than Java. <br><br>  As we can see, in the best case, Java growth by 49% is like almost 3 cores.  Therefore, we have a funny fact - for small tasks it is best to set newFixedThreadPool (3); <br><br>  For large - by the number of threads in the processor - 4 or 6-8.  I will point out another funny fact.  On Athlone x3 there was very little progress from the transition to float and 2 streams - 32% of both optimizations.  The gain from the "4" -nuclear code in C ++ is also small - 67% between 1 and 4 cores (both float).  You can write off on a slow memory controller and 32-bit Windu. <br><br>  But the 4-core Java code worked fine.  With 3 Executor threads + 50.2% of the 2-core version for large tasks.  For some reason, the worst 2-core implementation has intensified as much as possible multi-core. <br><br>  Last note on 4-core code in Java.  Current time spent: <br><table><tbody><tr><td>  Basic 2-D E and H Cycles </td><td>  83% </td></tr><tr><td>  Other, considering the initial initialization of all </td><td>  sixteen% </td></tr><tr><td>  Spawning (4) threads </td><td>  About 1% (0.86 by profiler) </td></tr></tbody></table><br>  I tried to optimize the main cycles as much as possible, thinking that the rest is spending little time. <br><br>  I also post the full code of the 4-core case in C ++: <br><br><div class="spoiler">  <b class="spoiler_title">.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;complex&gt; #include &lt;stdio.h&gt; #include &lt;sys/time.h&gt; #include &lt;thread&gt; using namespace std; void thE (float** &amp;Ez, float** &amp;Hx, float** &amp;Hy, float** &amp;e, int iBegin, int iEnd, int tt) { for (int i = iBegin; i &lt;= iEnd; i++) // main Ez { for (int j = 2; j &lt;= tt; j++) { Ez[i][j] += e[i][j] * ((Hx[i][j - 1] - Hx[i][j] + Hy[i][j] - Hy[i - 1][j])); } } } void thH (float** &amp;Ez, float** &amp;Hx, float** &amp;Hy, int iBegin, int iEnd, int tt) { for (int i = iBegin; i &lt;= iEnd; i++) { for (int j = 1; j &lt;= tt; j++) { Hx[i][j] += Ez[i][j] - Ez[i][j + 1]; Hy[i][j] += Ez[i + 1][j] - Ez[i][j]; } } } void FDTDmainFunction (char m) { //m=c: cos, else sin int i,j; float x; const float dx=0.5*1e-7/1.4; const float dy=dx; const float period=1.2e-6; const float Q=1.5; const float n=1;//ne      =1 const float lambd=1064e-9; const float prodol=2*n*period*period/lambd/Q; const int nx=1024; const int ny=700; float **Ez = new float *[nx+1]; for (i = 0; i &lt; nx+1; i++) { Ez[i] = new float [ny+1]; for (j=0; j&lt;ny+1; j++) { Ez[i][j]=0; } } float **Hx = new float *[nx]; for (i = 0; i &lt; nx; i++) { Hx[i] = new float [ny]; for (j=0; j&lt;ny; j++) { Hx[i][j]=0; } } float **Hy = new float *[nx]; for (i = 0; i &lt; nx; i++) { Hy[i] = new float [ny]; for (j=0; j&lt;ny; j++) { Hy[i][j]=0; } } const float omega=2*3.14159265359/lambd; const float dt=dx/2; const float s=dt/dx;//for MUR const float w=40e-7; const float alpha =tan(15.0/180*3.1416); float** e = new float *[nx+1]; for (i = 0; i &lt; nx+1; i++) { e[i] = new float [ny+1]; for (j=0; j&lt;ny+1; j++) { e[i][j]=dt*dt / dx/dx/1; } } const int tmax= (int) ny*1.9; for (int t=1; t&lt;=tmax; t++) { int tt=min( (int) (t*s+10), (ny-1)); if (m == 'c') { for (i=1; i&lt;=nx-1; i++) { x = dx*(i-(float)nx/2+0.5); Ez[i][1]=exp(-pow(x,2)/w/w)*cos((x*alpha+(t-1)*dt)*omega); } } else { for (i=1; i&lt;=nx-1; i++) { x = dx*(i-(float)nx/2+0.5); Ez[i][1]=exp(-pow(x,2)/w/w)*sin((x*alpha+(t-1)*dt)*omega); } } std::thread thr01(thE, std::ref(Ez), std::ref(Hx), std::ref(Hy), std::ref(e), 2, nx / 2, tt); std::thread thr02(thE, std::ref(Ez), std::ref(Hx), std::ref(Hy), std::ref(e), nx / 2 + 1, nx - 1, tt); thr01.join(); thr02.join(); // H for (i=1; i&lt;=nx-1; i++) { x = dx*(i-(float)nx/2+0.5); Ez[i][1]=exp(-pow(x,2)/w/w)*cos((x*alpha+t*dt)*omega); } std::thread thr03(thH, std::ref(Ez), std::ref(Hx), std::ref(Hy), 1, nx / 2, tt); std::thread thr04(thH, std::ref(Ez), std::ref(Hx), std::ref(Hy), nx / 2 + 1, nx - 1, tt); thr03.join(); thr04.join(); } } int main() { struct timeval tp; gettimeofday(&amp;tp, NULL); double ms = tp.tv_sec * 1000 + (double)tp.tv_usec / 1000; std::thread thr1(FDTDmainFunction, 'c'); std::thread thr2(FDTDmainFunction, 's'); thr1.join(); thr2.join(); gettimeofday(&amp;tp, NULL); double ms2 = tp.tv_sec * 1000 + (double)tp.tv_usec / 1000; cout &lt;&lt; ms2-ms &lt;&lt; endl; return 0; }</span></span></span></span></code> </pre> <br>  delete [] not yet, because you need to use the result somewhere :) </div></div><br>  This is the simplest code, without a normal lattice and boundary conditions.  It is interesting, is <b>it possible in C ++ to more effectively declare 2-dimensional arrays and call threads?</b> <br><br><h3>  8 cores </h3><br>  And I have no more cores.  If my tasks did not rest on the memory, I would divide further.  It seems, ThreadPool gives small expenses.  Or go to the Fork-Join Framework. <br><br>  I could check - abandon the first two streams, and divide one task into 4-8 pieces on i7.  But it only makes sense if someone tests on a machine with fast memory - DDR-4 or 4 channels. <br><br>  The best way to get rid of the lack of memory speed is with a video card.  My brother, who forbids updating the video driver (ignorance of C and Cuda), prevents me from switching to Cuda. <br><br><h2>  Outcome and afterwords </h2><br>  I can quickly solve any 2-dimensional task I need with good accuracy.  The grid 4096x2000 is passed on a 4-core in 106 seconds.  It will be 300 microns x 40 layers - we have the maximum samples. <br><br>  In 2D, with 32-bit precision, some memory is required - 4 bytes * 4 arrays * 2 complex components = 32 bytes / pixel in the worst case. <br><br>  <b>In 3D, everything is much worse.</b>  Component already six.  You can opt out of two threads - read the components sequentially and write on the screw.  You can not store an array of dielectric constant, and count in a cycle or get along with a very small periodic area.  Then in 16 GB of operatives (the maximum is on my work) the area 895x895x895 will fit.  It will be fine "to see."  But it will be considered ‚Äúonly‚Äù 6‚Äì7 hours one pass.  If the task is well divided into 4 parallel threads.  And if we neglect the calculation of Œµ. <br><br>  Only for the spectrum is not enough for me.  With a width of 1024, I do not see the necessary details.  You need 2048. And this is 200+ GB of memory.  Therefore, the three-dimensional case is difficult.  If you do not develop a code with caching SSD. <br><br>  <b>PS</b> Speed ‚Äã‚Äãestimates were rather approximate.  I checked Matlab only on small problems.  Now I checked Java - task 2048 * 1976 (analog 2000 * 2000) on 4 cores.  Calculation time is 45.5 seconds.  Acceleration from Matlab <b>141 times</b> (exactly). <br><br><h4>  Possible future plans: </h4><br>  *) Check the speed of pure C (not ++).  By benchmarksgame he is always faster. <br>  1) Check out complex classes in C and Java.  Maybe in C they are implemented fairly quickly.  True, I'm afraid they will all be more than 8 bytes. <br>  2) Throw all 2- and 4-core versions in MSVS, find the optimization settings. <br>  3) Check if lyabmdy / stream can speed up the main loop or additional. <br>  4) Make a normal GUI for selecting everything and visualizing the results. <br>  99) Write a Cuda version. <br>  If anyone is interested, I will describe FDTD and other calculation methods, photonic crystals. <br><br>  I posted 2 versions on Github: <br><br>  1) <a href="https://github.com/VolodymyrKoliadenko/FDTD-2threads">2-way with the rudiments of the</a> parameter selection <a href="https://github.com/VolodymyrKoliadenko/FDTD-2threads">interface</a> <br>  2) <a href="https://github.com/VolodymyrKoliadenko/FDTD_4_threads">4-way</a> <br><br>  Both draw a picture and spectrum.  Just until a pixel is in a pixel - do not take the width above 2048. They also know how to take the size of the area from the console. </div><p>Source: <a href="https://habr.com/ru/post/319216/">https://habr.com/ru/post/319216/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319204/index.html">VulnHub: Parse the shortest quest DC416 Fortress</a></li>
<li><a href="../319208/index.html">Learn ActionBlock: or a short story about otherwise deadlock</a></li>
<li><a href="../319210/index.html">Bitrix Start Performance on Proxmox and Virtuozzo 7 & Virtuozzo Storage</a></li>
<li><a href="../319212/index.html">"IT infrastructure": Where we go with the "cloud" in 2017</a></li>
<li><a href="../319214/index.html">Cheap Ways to Heat Up Storage with an SSD</a></li>
<li><a href="../319218/index.html">Detection in the code of the defect "null pointer dereferencing"</a></li>
<li><a href="../319222/index.html">Reducing the amount of PostgreSQL data on disk</a></li>
<li><a href="../319226/index.html">Simple and fast terrain generation algorithm</a></li>
<li><a href="../319228/index.html">Saving and loading the game in the Unreal Engine</a></li>
<li><a href="../319230/index.html">A little bit about programming trends in 2016: a series of conferences #ITsubbotnik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>