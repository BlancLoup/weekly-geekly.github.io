<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kotlin, bytecode compilation and performance (part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A lot has been said about Kotlin lately (especially in conjunction with the latest news from Google IO 17), but at the same time there is not a lot of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kotlin, bytecode compilation and performance (part 1)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/3af/e51/f5a/3afe51f5a54a4ce583d5665dfb4d06c3.png"><br><br>  A lot has been said about Kotlin lately (especially in conjunction with the latest news from Google IO 17), but at the same time there is not a lot of such necessary information in which Kotlin is compiled. <br>  Let's take a closer look at the example of compiling to JVM bytecode. <br><br>  This is the first part of the publication.  The second can be found <a href="https://habrahabr.ru/company/inforion/blog/330064/">here.</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The compilation process is quite an extensive topic and in order to better reveal all its nuances, I took most of the compilation examples from Dmitry Zhemerov‚Äôs speech: <a href="https://www.youtube.com/watch%3Fv%3D35GACInsZsk">Caught in the Act: Kotlin Bytecode Generation and Runtime Performance</a> .  All the benchmarks are taken from the same speech.  In addition to reading the publication, I strongly recommend that you also watch his presentation.  Some things there are told in more detail.  I focus more on the compilation of the language. <br><br><h2>  Content: </h2><br>  <a href="https://habrahabr.ru/company/inforion/blog/330060/">File Level Functions</a> <br>  <a href="https://habrahabr.ru/company/inforion/blog/330060/">Primary constructors</a> <br>  <a href="https://habrahabr.ru/company/inforion/blog/330060/">data classes</a> <br>  <a href="https://habrahabr.ru/company/inforion/blog/330060/">Properties in the class body</a> <br>  <a href="https://habrahabr.ru/company/inforion/blog/330060/">Not-null types in public and private methods</a> <br>  <a href="https://habrahabr.ru/company/inforion/blog/330060/">Extension functions (extension functions)</a> <br>  <a href="https://habrahabr.ru/company/inforion/blog/330060/">Bodies of methods in interfaces</a> <br>  <a href="https://habrahabr.ru/company/inforion/blog/330060/">Default arguments</a> <br>  <a href="https://habrahabr.ru/company/inforion/blog/330060/">Lambda</a> <br><br>  But before we consider the basic language constructs and the bytecode they compile, we need to mention how the language itself is directly compiled: <br><a name="habracut"></a><br><br><img src="https://habrastorage.org/web/df0/1eb/758/df01eb758bec4716bf6c0c017d8e5faf.png"><br><br>  The source files come to the input of the kotlinc compiler, not only the kotlin files, but also the java files.  This is necessary so that you can freely reference Java from Kotlin, and vice versa.  The compiler itself understands the Java source well, but does not compile them, at this stage only the Kotlin files are compiled.  After the received * .class files are transferred to the java compiler along with the source files * .java.  At this stage, all java files are compiled, after which it becomes possible to put all the files together in a jar (or in some other way). <br><br>  In order to see which Kotlin is generated bytecode, you can open a special window in Intellij IDEA from Tools -&gt; Kotlin -&gt; Show Kotlin Bytecode.  And after, when opening any * .kt file, its bytecode will be visible in this window.  If there is nothing in it that cannot be represented in Java, then the opportunity to decompile it into Java code with the Decompile button will also be available. <br><br><img src="https://habrastorage.org/web/7da/bab/8fb/7dabab8fb6b24ad6995e5e0d05fded9e.png"><br><br>  If you look at any kotlin * .class file, then there you can see a large @Metadata annotation: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Metadata</span></span>( mv = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>}, bv = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, k = <span class="hljs-number"><span class="hljs-number">1</span></span>, d1 = {<span class="hljs-string"><span class="hljs-string">"\u0000\u0014\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\b\u0002\n\u0002\u0010\b\n\u0002\b\u0003\u0018\u00002\u00020\u0001B\u0005¬¢\u0006\u0002\u0010\u0002R\u0014\u0010\u0003\u001a\u00020\u0004X\u0086D¬¢\u0006\b\n\u0000\u001a\u0004\b\u0005\u0010\u0006¬®\u0006\u0007"</span></span>}, d2 = {<span class="hljs-string"><span class="hljs-string">"LSimpleKotlinClass;"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"()V"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"getTest"</span></span>, <span class="hljs-string"><span class="hljs-string">"()I"</span></span>, <span class="hljs-string"><span class="hljs-string">"production sources for module KotlinTest_main"</span></span>} )</code> </pre> <br><br><blockquote>  It contains all the information that exists in the Kotlin language and which cannot be represented at the Java bytecode level.  For example, information about properties, nullable types, etc.  This information does not need to work directly, but the compiler works with it, and it can be accessed using the Reflection API.  The metadata format is actually Protobuf with its own declarations. <br>  Dmitry Zhemerov </blockquote><br><br>  Let us now turn to examples in which we consider the basic constructions and how they are represented in bytecode.  But in order not to understand the cumbersome bytecode entries in most cases, consider the decompiled version in Java: <br><br><h2>  File Level Functions </h2><a name="P1"></a><br><br>  Let's start with the simplest example: a function at the file level. <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//Kotlin,  Example1.kt fun foo() { }</span></span></code> </pre><br>  Java does not have a similar construction.  In bytecode, it is implemented by creating an additional class. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public final class Example1Kt { public static final void foo() { } }</span></span></code> </pre><br><br>  The name of the source file with the * Kt suffix (in this case, Example1Kt) is used as the name for this class.  It is also possible to change the class name using the annotation <a href="https://habrahabr.ru/users/file/" class="user_link">file</a> : JvmName: <br><br><pre> <code class="hljs perl">//Kotlin @file:JvmName(<span class="hljs-string"><span class="hljs-string">"Utils"</span></span>) fun foo() { }</code> </pre><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public final class Utils { public static final void foo() { } }</span></span></code> </pre><br><br><h2>  Primary constructors </h2><a name="P2"></a><br><br>  In Kotlin, it is possible to declare properties directly in the header of the constructor. <br><br><pre> <code class="hljs pgsql">//Kotlin <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> A(val x: <span class="hljs-type"><span class="hljs-type">Int</span></span>, val y: Long) {}</code> </pre><br>  They will be the parameters of the constructor, fields will be generated for them and, accordingly, the values ‚Äã‚Äãpassed to the constructor will be written into these fields.  A getter will also be created to allow these fields to be read.  The decompiled version of the example above will look like this: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public final class A { private final int x; private final long y; public final int getX() { return this.x; } public final long getY() { return this.y; } public A(int x, long y) { this.x = x; this.y = y; } }</span></span></code> </pre><br>  If in the declaration of class A of variable x change val to var, then setter will be generated.  It is also worth noting that class A will be declared with the modifier final and public.  This is due to the fact that all classes in Kotlin are by default final and have a public scope. <br><br><h2>  data classes </h2><a name="P3"></a><br><br>  Kotlin has a special modifier for the data class. <br><br><pre> <code class="hljs haskell">//<span class="hljs-type"><span class="hljs-type">Kotlin</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Long</span></span></span><span class="hljs-class">) { }</span></span></code> </pre><br>  This keyword tells the compiler to generate the equals, hashCode, toString, copy, and componentN functions for the class.  The latter are needed so that the class can be used in destructing declarations.  Let's look at the decompiled code: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public final class B { // ---   2 public final int component1() { return this.x; } public final long component2() { return this.y; } @NotNull public final B copy(int x, long y) { return new B(x, y); } public String toString() { return "B(x=" + this.x + ", y=" + this.y + ")"; } public int hashCode() { return this.x * 31 + (int)(this.y ^ this.y &gt;&gt;&gt; 32); } public boolean equals(Object var1) { if(this != var1) { if(var1 instanceof B) { B var2 = (B)var1; if(this.x == var2.x &amp;&amp; this.y == var2.y) { return true; } } return false; } else { return true; } }</span></span></code> </pre><br>  In practice, the data modifier is very often used, especially for classes that participate in the interaction between components or are stored in collections.  Also, data classes allow you to quickly create an immotable data container. <br><br><h2>  Properties in the class body </h2><a name="P4"></a><br><br>  Properties can also be declared in the class body. <br><br><pre> <code class="hljs pgsql">//Kotlin <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> C { var x: String? = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }</code> </pre><br>  In this example, in class C, we declared a property x of type String, which may also be null.  In this case, additional @Nullable annotations appear in the code: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java import org.jetbrains.annotations.Nullable; public final class C { @Nullable private String x; @Nullable public final String getX() { return this.x; } public final void setX(@Nullable String var1) { this.x = var1; } }</span></span></code> </pre><br><br>  In this case, in the decompiled version, we will see getter, setter (since the variable is declared with the var modifier). The @Nullable annotation is necessary so that those static analyzers who understand this annotation can check the code using them and report any possible mistakes. <br><br>  If we do not need getter and setter, but just need a public field, then we can add the @JvmField annotation: <br><br><pre> <code class="hljs pgsql">//Kotlin <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> C { @JvmField var x: String? = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }</code> </pre><br>  Then the resulting Java code will be as follows: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public final class C { @JvmField @Nullable public String x; }</span></span></code> </pre><br><br><h2>  Not-null types in public and private methods </h2><a name="P5"></a><br><br>  In Kotlin, there is a slight difference between what kind of bytecode is generated for public and private methods.  Let's look at an example of two methods in which not-null variables are passed. <br><br><pre> <code class="hljs erlang">//Kotlin class E { <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> x(s: String) { println(s) } private <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> y(s: String) { println(s) } }</code> </pre><br>  In both methods, the parameter s of type String is passed, and in both cases this parameter cannot be null. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java import kotlin.jvm.internal.Intrinsics; public final class E { public final void x(@NotNull String s) { Intrinsics.checkParameterIsNotNull(s, "s"); System.out.println(s); } private final void y(String s) { System.out.println(s); } }</span></span></code> </pre><br>  In this case, an additional type check is generated for the public method (Intrinsics.checkParameterIsNotNull), which checks that the passed parameter is really not null.  This is done so that public methods can be called from Java.  And if null is suddenly passed to them, then this method should fall in the same place, without passing the variable further along the code.  This is necessary for early diagnosis of errors.  There is no such verification in private methods.  From Java it cannot be called just like that, only if through reflection.  But with the help of reflection, you can generally break a lot of things if you wish.  From Kotlin, the compiler itself monitors calls and will not allow to pass null to such a method. <br><br>  Such checks, of course, can not affect the performance at all.  It is rather interesting to try on how much they worsen it, but it‚Äôs hard to do with simple benchmarks.  Therefore, we will look at the data that Dmitry Zhemerov managed to get: <br><br><h4>  Checking parameters for null </h4><br><img src="https://habrastorage.org/web/077/ee9/cf4/077ee9cf4b784ee5b35e0cdfcdafffa3.png"><br><br>  For one parameter, the cost of such a check for NotNull is generally negligible.  For a method with eight parameters, which does nothing more than to check for null, it already turns out that there is some appreciable value.  But in any case, in ordinary life, this cost (approximately 3 nanoseconds) can be ignored.  A more likely situation is that this is the last thing that will have to be optimized in the code.  But if you still need to remove unnecessary checks, then at the moment it is possible using the additional options of the kotlinc compiler: -Xno-param-assertions and -Xno-call-assertions (it‚Äôs important !: before you turn off the checks, really think the cause of your troubles, and will it not be such that it will do more harm than good) <br><br><h2>  Extension functions (extension functions) </h2><a name="P6"></a><br><br>  Kotlin allows you to extend the API of existing classes written not only in Kotlin, but also in Java.  For any class, you can write a function declaration, and further in the code, you can use it with this class as if this function was at its declaration. <br><br><pre> <code class="hljs python">//Kotlin ( Example6.kt) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(val i: Int)</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fun</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> Int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i } fun useFoo() { T(<span class="hljs-number"><span class="hljs-number">1</span></span>).foo() }</code> </pre><br>  In Java, a class is generated in which there will simply be a static method with a name, like the extension function.  An instance of the extensible class is passed to this method.  Thus, when we call the extension function, we actually transfer to the static function the element itself, on which we call the method. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public final class Example6Kt { public static final int foo(@NotNull T $receiver) { Intrinsics.checkParameterIsNotNull($receiver, "$receiver"); return $receiver.getI(); } public static final void useFoo() { foo(new T(1)); } }</span></span></code> </pre><br>  Almost the entire Kotlin standard library consists of extension functions for the JDK classes.  Kotlin has a very small standard library and there is no declaration of its own collection classes.  All collections declared via listOf, setOf, mapOf, which in Kotlin look at first glance as their own, are actually ordinary Java collections of ArrayList, HashSet, HashMap.  And if you need to transfer such a collection to the library (or from the library), then there is no overhead for converting to its internal classes (as opposed to Scala &lt;-&gt; Java) or copying. <br><br><h2>  Bodies of methods in interfaces </h2><a name="P7"></a><br><br>  In Kotlin there is an opportunity to add implementation for methods in interfaces. <br><br><pre> <code class="hljs pgsql">//Kotlin interface I { fun foo(): <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> D : I { }</code> </pre><br>  In Java 8, this feature also appeared, but due to the fact that Kotlin should work on Java 6, the resulting code in Java looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultImpls</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I $</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> I.DefaultImpls.foo(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre><br>  In Java, a standard interface is created, with a method declaration, and the declaration of the DefaultImpls class appears with a default implementation for the desired methods.  In the places where methods are used, the call for implementations appears from the class declared in the interface, to the methods of which the object of the call is passed. <br><br>  The Kotlin team has plans to transition to the implementation of this functionality using the default methods from the Java 8 method, but at the moment there are difficulties with maintaining binary compatibility with already compiled libraries.  You can see a discussion of this problem on <a href="https://youtrack.jetbrains.com/issue/KT-4779">youtrack</a> .  Of course, this does not create a big problem, but if the project is going to create an api for Java, then this feature should be taken into account. <br><br><h2>  Default arguments </h2><a name="P8"></a><br><br>  Unlike Java, Kotlin has default arguments.  But their implementation is made quite interesting. <br><br><pre> <code class="hljs erlang">//Kotlin ( Example8.kt) <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> first(x: Int = <span class="hljs-number"><span class="hljs-number">11</span></span>, y: Long = <span class="hljs-number"><span class="hljs-number">22</span></span>) { println(x) println(y) } <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> second() { first() }</code> </pre><br>  To implement the default arguments in Java bytecode, a synthetic method is used that passes the mask mask with information about which arguments are missing in the call. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public final class Example8Kt { public static final void first(int x, long y) { System.out.println(x); System.out.println(y); } public static void first$default(int var0, long var1, int mask, Object var4) { if((mask &amp; 1) != 0) { var0 = 11; } if((mask &amp; 2) != 0) { var1 = 22L; } first(var0, var1); } public static final void second() { first$default(0, 0L, 3, (Object)null); } }</span></span></code> </pre><br>  The only interesting point is why the var4 argument is generated?  It itself is not used anywhere, and null is passed in places of use.  I did not find the information on the purpose of this argument, maybe <a href="https://habrahabr.ru/users/yole/" class="user_link">yole</a> can clarify the situation. <br><br>  The following are estimates of the cost of such manipulations: <br><br><h4>  Default arguments </h4><br><img src="https://habrastorage.org/web/cea/90d/f37/cea90df376d245508580d456504c0d07.png"><br><br>  The cost of the default arguments is already becoming slightly noticeable.  But still, losses are measured in nanoseconds and during normal operation such losses can be neglected.  There is also a way to force the Kotlin compiler to generate default arguments in bytecode.  To do this, add the @JvmOverloads annotation: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//Kotlin @JvmOverloads fun first(x: Int = 11, y: Long = 22) { println(x) println(y) }</span></span></code> </pre><br>  In this case, in addition to the methods from the previous example, the first method overloads will be generated for various options for passing arguments. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public final class Example8Kt { //--  first, second, first$default    @JvmOverloads public static final void first(int x) { first$default(x, 0L, 2, (Object)null); } @JvmOverloads public static final void first() { first$default(0, 0L, 3, (Object)null); } }</span></span></code> </pre><br><br><h2>  Lambda </h2><a name="P9"></a><br><br>  Lambda in Kotlin are presented almost as well as in Java (except that they are first class objects) <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>Kotlin ( Lambda1.kt) fun &lt;T&gt; runLambda(x: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">-&gt;</span></span> T): T = x()</code> </pre><br>  In this case, the runLambda function takes an instance of the Function0 interface (whose declaration is in the Kotlin standard library), which has the invoke () function.  And accordingly, this is all compatible with the way it works in Java 8, and, of course, SAM conversion from Java works.  The resulting bytecode will look like this: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public final class Lambda1Kt { public static final Object runLambda(@NotNull Function0 x) { Intrinsics.checkParameterIsNotNull(x, "x"); return x.invoke(); } }</span></span></code> </pre><br>  Compiling to bytecode strongly depends on whether the value is captured from the surrounding context or not.  Consider an example when there is a global variable value and lambda, which simply returns its value. <br><br><pre> <code class="hljs pgsql">//Kotlin ( Lambda2.kt) var <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> fun noncapLambda(): <span class="hljs-type"><span class="hljs-type">Int</span></span> = runLambda { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> }</code> </pre><br>  In Java, in this case, in essence, a singleton is created.  Lambda itself does not use anything from the context and, accordingly, it is not necessary to create different instances for all calls.  Therefore, a class that implements the Function0 interface is simply compiled, and, as a result, the call to the lambda occurs without allocation and is very cheap. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java final class Lambda2Kt$noncapLambda$1 extends Lambda implements Function0 { public static final Lambda2Kt$noncapLambda$1 INSTANCE = new Lambda2Kt$noncapLambda$1() public final int invoke() { return Lambda2Kt.getValue(); } } public final class Lambda2Kt { private static int value; public static final int getValue() { return value; } public static final void setValue(int var0) { value = var0; } public static final int noncapLambda() { return ((Number)Lambda1Kt.runLambda(Lambda2Kt$noncapLambda$1.INSTANCE)).intValue(); } }</span></span></code> </pre><br>  Consider another example using local variables with contexts. <br><br><pre> <code class="hljs pgsql">//Kotlin ( Lambda3.kt) fun capturingLambda(v: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = runLambda { v }</code> </pre><br>  In this case, singleton is not enough, since each specific lambda instance must have its own parameter value. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public static final int capturingLambda(int v) { return ((Number)Lambda1Kt.runLambda((Function0)(new Function0() { public Object invoke() { return Integer.valueOf(this.invoke()); } public final int invoke() { return v; } }))).intValue(); }</span></span></code> </pre><br>  Lambda in Kotlin are also able to change the value of non-local variables (unlike Java lambda). <br><br><pre> <code class="hljs pgsql">//Kotlin ( Lambda4.kt) fun mutatingLambda(): <span class="hljs-type"><span class="hljs-type">Int</span></span> { var x = <span class="hljs-number"><span class="hljs-number">0</span></span> runLambda { x++ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x }</code> </pre><br>  In this case, a wrapper is created for the variable being changed.  The wrapper itself, similarly to the previous example, is transferred to the newly created lambda, inside of which the change of the initial variable takes place through the call to the wrapper. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lambda4Kt</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutatingLambda</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IntRef x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntRef(); x.element = <span class="hljs-number"><span class="hljs-number">0</span></span>; Lambda1Kt.runLambda((Function0)(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Function0() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Integer.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.invoke()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var1 = x.element++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> var1; } })); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.element; } }</code> </pre><br>  Let's try to compare the performance of solutions on Kotlin, with counterparts in Java: <br><br><h4>  Lambda </h4><br><img src="https://habrastorage.org/web/695/b26/7e0/695b267e026f42c18bd963a8355d6005.png"><br><br>  As you can see, the fussing with wrappers (the last example) takes considerable time, but, on the other hand, in Java this is not supported out of the box, and if you make such an implementation with your hands, then the costs will be similar.  The rest of the difference is not so noticeable. <br><br>  Also in Kotlin there is an opportunity to transfer references to methods (method reference) in lambdas, and they, unlike lambdas, store information about what the methods indicate.  References to methods are compiled in a similar way to what lambdas look like without capturing context.  It creates a singleton, which in addition to the value still knows what this lambda refers to. <br><br>  Lambda in Kotlin has another interesting feature: they can be declared with the inline modifier.  In this case, the compiler will find all the places where the function is used in the code and replace them with the function body.  JIT also knows how to inline some things on its own, but you can never be sure that it will inline and what it will miss.  Therefore, to have your own controlled inline mechanism never hurts. <br><br><pre> <code class="hljs pgsql">//Kotin ( Lambda5.kt) fun inlineLambda(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = run { x } //run     : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> fun &lt;R&gt; run(block: () -&gt; R): R = block()</code> </pre><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public final class Lambda5Kt { public static final int inlineLambda(int x) { return x; } }</span></span></code> </pre><br>  In the example above, no allocation takes place, no calls.  In essence, the function code simply ‚Äúcollapses‚Äù.  This allows you to very effectively implement all sorts of filter, map, etc.  The same synchronized statement is also inline. <br><br>  Continued in <a href="https://habrahabr.ru/company/inforion/blog/330064/">part 2</a> <br><br>  Thanks for attention! <br>  I hope you enjoyed the article.  I ask all those who have noticed any errors or inaccuracies to write about it to me in a personal message. </div><p>Source: <a href="https://habr.com/ru/post/330060/">https://habr.com/ru/post/330060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330044/index.html">Chat with your own hands</a></li>
<li><a href="../330046/index.html">1 more non-recursive algorithm for generating all partitions of an integer</a></li>
<li><a href="../330048/index.html">Understanding the event architecture of Node.js</a></li>
<li><a href="../330052/index.html">Software Defined Radio by the hands of a sixteen year old</a></li>
<li><a href="../330056/index.html">The history of the creation of the Virtual File System Git (GVFS, Git Virtual File System)</a></li>
<li><a href="../330062/index.html">Own scripting engine for games using C ++ and Lua (part 1)</a></li>
<li><a href="../330064/index.html">Kotlin, bytecode compilation and performance (part 2)</a></li>
<li><a href="../330066/index.html">Issue # 3: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../330068/index.html">Must-Have: 20 game assets for the designer and artist</a></li>
<li><a href="../330070/index.html">Load optimization in the ‚ÄúRemains in warehouses‚Äù task using partitioning in SQL Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>