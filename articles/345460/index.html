<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We comprehend C deeper using assembler. Part 2 (conditions)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Here is the second part of the cycle. In it, we will deal with the conditions. This time, let's try other levels of optimization, and see how this may...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We comprehend C deeper using assembler. Part 2 (conditions)</h1><div class="post__text post__text-html js-mediator-article">  Here is the second part of the cycle.  In it, we will deal with the conditions.  This time, let's try other levels of optimization, and see how this may affect the code. <br><a name="habracut"></a><br>  It is necessary to indicate the purpose of these articles, so that there is no misunderstanding.  I will not parse each C compiler separately.  It is long and tedious.  Instead, I want to captivate readers with an analysis of interesting interpretations of the C code, so that people understand how their code can be changed and executed by the processor.  And also dispel some myths that run among novice programmers.  For example, there are, however, those who believe that if you add numbers in a cycle, it will be faster than just multiplying one number by another.  The article does not specifically consider gcc with -m32 -O0, some did not quite understand the idea.  If there is real meaning, then I will change both the compiler and the keys. <br><br>  T. e. What I want to say?  Consider two old examples: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    1 return a; //     }</span></span></code> </pre> <br>  and 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = a * <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Indeed, the clang in the first case determines the variable to the stack, but how interesting or essential is it for us?  Those familiar with the register specifier read / know that this is merely a recommendation.  Therefore, the compiler can simply ignore the specifier.  In addition, the purpose of the example was to acquaint the reader with the registers, taking the simplest example.  Perfect for this gcc.  The second example is even simpler, in it the clang immediately makes a shift, and it surrenders when multiplied by 3, yielding imul.  Honestly, I don‚Äôt really understand what is curious in this example, so I also cited the code for gcc, which is perverted to the number 22. We all know that the standard of the language does not state how to implement this or that thing.  And compiler developers are free to make their own implementations, so long as they do not violate the standard.  Therefore, we have a different interpretation of the code depending on the compiler.  But, forgive me, disassemble each?  What is the practicality of this material?  Confuse everyone's head?  As was correctly noted, if you are interested in a specific compiler, then you can just sit with the debugger.  And it will not be so scary for those who read these articles. <br><br>  So let's continue. <br><br><h2>  The simplest condition </h2><br>  First, let's compare the variable and the number: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  AFM (gcc 7.2): <br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 4 <span class="hljs-selector-tag"><span class="hljs-selector-tag">jg</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 1 <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 0 <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">leave</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span></code> </pre><br>  In the first line, the compiler adds the value of the variable "a" to the stack.  In the second we have a new <b>cmp</b> instruction.  It is not difficult to guess that this instruction compares two values.  In our case: the value from the stack and 4. <br><br>  But how does it work?  It just takes the second operand from the first operand.  The <b>sub</b> instruction works in a similar way, but in the case of <b>cmp, the</b> result is not saved.  However, the flags in the EFLAGS / RFLAGS register are set according to this result.  Without going into details, we can find out if there was a positive result, negative or zero.  The following conditional jump <b>command jg is</b> triggered if the result was positive ( <b>j</b> ump if <b>g</b> reater). <br><br>  If you interpreted this, then a fair question could arise: why more if the sign was less?  Indeed, we wrote <i>if a &lt;5</i> , but it turned into doing something, if a&gt; 4. But the logic of the program did not break.  After all, if a&gt; 4, then return 0 occurs. Here another fair question may arise, and if you write a condition: if (a&gt; 4) return 0, how will the code change? <br><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 4 <span class="hljs-selector-tag"><span class="hljs-selector-tag">jle</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 1 <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">leave</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span></code> </pre><br>  And we again get the reversal of the condition: <b>jle</b> , you guessed it, is less than or equal to ( <b>j</b> ump if <b>l</b> ess or <b>e</b> qual) <br><br>  The whole point is that return completes the program, so you need to follow the last two instructions, which is why the line <b>jmp .L3</b> does not change in both examples.  This is an unconditional branch instruction.  In our case: it skips the line following the condition where a completely different number should be entered in the eax register. <br><br>  That is, the compiler checks the opposite condition so that with the original false it is sent to the code down, but if the original condition is true, then the code that goes immediately after cmp and the conditional transition is executed.  Let us note, for clarity, the numbers in the condition branch: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//#0 return 1; } //#1 return 0;</span></span></code> </pre><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 4 <span class="hljs-selector-tag"><span class="hljs-selector-tag">jle</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span> ;<span class="hljs-selector-id"><span class="hljs-selector-id">#0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 1 ;<span class="hljs-selector-id"><span class="hljs-selector-id">#1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">leave</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span></code> </pre><br>  As you can see, the structure of the program is not violated, but if we replace the conditional transition, then: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 5 <span class="hljs-selector-tag"><span class="hljs-selector-tag">jg</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span> ;<span class="hljs-selector-id"><span class="hljs-selector-id">#1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 1 <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 0 ;<span class="hljs-selector-id"><span class="hljs-selector-id">#0</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">leave</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span></code> </pre><br>  That is, the inner part of the condition falls down the program, which is not very good: for example, after the condition (in section # 1) there are a lot of lines, then to see section # 0, we will twist the listing very far down.  (I forgot to clarify that then I will have to return to continue the execution of the code after if. That is, one more label and one more transition.) <br><br><h2>  unsigned </h2><br>  We have just considered comparing numbers with a signed sign (signed), but what if we compare unsigned numbers? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 5 <span class="hljs-selector-tag"><span class="hljs-selector-tag">jbe</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 1 <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 0 <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">leave</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span></code> </pre><br>  Nothing has changed except the conditional instruction: instead of jle, now jbe ( <b>j</b> ump <b>b</b> elow or <b>e</b> qual).  Why two different instructions for comparing signed and unsigned numbers? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span> ‚Äì <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//-1 unsigned int a = 0 ‚Äì 1; //4294967295</span></span></code> </pre><br>  Although in fact, in memory, all the same, will be 4294967295. This is just a display method, you can write in C: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i"</span></span>, a); <span class="hljs-comment"><span class="hljs-comment">//-1</span></span></code> </pre><br>  But with the cmp instruction, not one flag is set, but several.  The jbe instruction checks the overflow flag during subtraction, and jle checks the flag that is equal to the value of the most significant bit of the result (i.e., if there is a negative result, there is 1).  In reality, everything is a bit more complicated: JBE (CF = 1 or ZF = 1), JLE (ZF = 1 or SF &lt;&gt; OF), but we can not dwell on it.  Let's move on to more interesting things: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  will be converted to: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">mov</span></span> DWORD PTR [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span> leave ret</code> </pre><br>  Great, right?  According to the logic of our code, the variable ‚Äúa‚Äù will never be less than zero, so the condition can simply be thrown out. <br><br>  And what about this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  AFM: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">je</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 1 <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 0 <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">leave</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span></code> </pre><br>  The <b>je</b> instruction performs the transition if the result of the comparison is zero ( <b>j</b> ump if <b>e</b> qual). <br><br><h2>  ‚Äù&lt;‚Äù Faster than ‚Äù&lt;=‚Äù?  Or than ‚Äù&lt;||  = ‚Äù? </h2><br>  We have already reviewed several conditional branch instructions: jle, jbe, jg, and je.  There are few more such instructions for all cases, there are also reverse ones: for example, jne is not zero or not equal or jnbe is not lower and not equal.  That is, for any comparison of numbers, we will receive two instructions cmp (or test) and jcc (conditional jump).  Thus, it can be concluded that, for example, there is no difference in the number of instructions for &lt;and &lt;=. <br><br>  But for <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || a == <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br>  the difference will be, but only at -O0. <br><br>  Let's take a look at the following program: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main() { int a = 0; scanf("%d", &amp;a); if (a &lt; 0 || a == 0) {    return 10; } return 20; }</span></span></span></span></code> </pre><br>  This time I use clang 5.0.0 -O3 -m32, since less asm code is generated, and using this example it will be easier to explain what is happening: <br><br><pre> <code class="hljs perl"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">esp</span></span></span><span class="hljs-function">, 12 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dword</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptr</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">esp</span></span></span><span class="hljs-function"> + 8], 0 </span></span>;scanf <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">esp</span></span></span><span class="hljs-function">, 8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lea</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">esp</span></span></span><span class="hljs-function"> + 16] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">str</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scanf</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">esp</span></span></span><span class="hljs-function">, 16 </span></span>;end scanf ;   cmp dword ptr [esp + <span class="hljs-number"><span class="hljs-number">8</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> ;<span class="hljs-comment"><span class="hljs-comment">#1 mov ecx, 10 ;#2 mov eax, 20 ;#3 cmovle eax, ecx ;#4 ;  add esp, 12 ret .L.str: .asciz "%d"</span></span></code> </pre><br>  # 1: comparing variable a to zero <br>  # 2: ecx is now 10 <br>  # 3: in eax register now 20 <br>  # 4: cmovle is similar to jle, only it moves the value provided.  Thus, if a &lt;= 0, then the value from ecx (10) falls into eax, otherwise, just 20 will remain. <br><br>  You already understand that if in the C code it is replaced with a &lt;= 0, then nothing will change, but you can check if there is a desire. <br><br><h2>  When conditions cease to be conditions </h2><br>  Imagine the situation: there is a condition in your code, but when debugging you cannot find conditional instructions.  Interesting? <br><br>  Take a look at the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">scanf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, &amp;x); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  You might expect cmp and tags, you could expect even more non-trivial things, like setx, but got the following (clang 5.0.0 -O3 -m32): <br><br><pre> <code class="hljs pgsql"> mov eax, dword ptr [esp + <span class="hljs-number"><span class="hljs-number">8</span></span>] shr eax, <span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> eax, <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> esp, <span class="hljs-number"><span class="hljs-number">12</span></span> ret</code> </pre><br>  Well and what is it?  Let's see.  Everything is clear with the first line: the value of the variable x was transferred to eax. <br><br>  The next line you should remember in the last article.  This is a right shift of 31 bits.  That is, in fact, we are left with only the first bit of the whole number. <br><br>  Next comes the bitwise "or" operation.  That is, we end up with either 10 or 11 (in binary number system).  That's all, the following lines refer to the epilogue of the function. <br><br>  What is interesting, to guess to write such a code, is not particularly difficult.  We simply add the sign of the number in the variable x to the two. <br><br>  By the same logic, but a bit different, for example, gcc 4.8.5: <br><br><pre> <code class="hljs pgsql"> sar eax, <span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> eax, <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Sar is also a shift to the right, but it works a little differently, the most significant bit, i.e. a sign, it does not shift. <br><br>  [1000] shr [0100] shr [0010] shr [0001] <br><br>  [1000] sar [1100] sar [1110] sar [1111] <br><br>  That is, if we have all the units, then the number was negative, we invert all the bits, get zero, add 3, exactly what we wanted.  And if the number is positive, then all the zeros will be, after inverting they will become ones.  In fact, this is -1, adding 3 to it, we get 2. <br><br>  MSVC-O2 at the same time comes more than expected: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">cmp</span></span> DWORD PTR _x$[ebp], eax ; <span class="hljs-attribute"><span class="hljs-attribute">x</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> setl al ; <span class="hljs-attribute"><span class="hljs-attribute">less</span></span> ? mov al, <span class="hljs-number"><span class="hljs-number">1</span></span> add eax, <span class="hljs-number"><span class="hljs-number">2</span></span> ; <span class="hljs-attribute"><span class="hljs-attribute">eax</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Very briefly: the low byte of the eax register is set to one, provided that the comparison result is negative, then 2. is added. This is a classic.  The compilers are very fond of this technique, I hope we will meet it again. <br><br><h2>  Else operator </h2><br>  I think everyone understands that for else the opposite condition is not checked.  In the code, just another label appears, that's all the features.  Let's make sure of this and consider the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { c = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { c = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c;</code> </pre><br>  AFM: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-8]</span></span>, 10 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-8]</span></span>, 3 <span class="hljs-selector-tag"><span class="hljs-selector-tag">jg</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 3 <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 2 <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span></code> </pre><br>  As you can see, the only difference is that after executing the code inside the if, we skip over the insides of the else block (the .L2 label).  I hope that a detailed analysis is not needed, everything seems to be obvious. <br><br><h2>  Logical operations in if </h2><br>  Let's look at a slightly non-standard example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a++ &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || a++ &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { a++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { a+=<span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  First try to answer: what value will be in the variable "a"?  If for you it was not difficult, then you already have some idea what the asm code will look like. <br><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">-1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span> ;<span class="hljs-selector-id"><span class="hljs-selector-id">#1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lea</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edx</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[eax+1]</span></span> ;<span class="hljs-selector-id"><span class="hljs-selector-id">#1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">edx</span></span> ;<span class="hljs-selector-id"><span class="hljs-selector-id">#1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">test</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span> ;<span class="hljs-selector-id"><span class="hljs-selector-id">#1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">js</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span> ;<span class="hljs-selector-id"><span class="hljs-selector-id">#1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span> ;<span class="hljs-selector-id"><span class="hljs-selector-id">#2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lea</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edx</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[eax+1]</span></span> ;<span class="hljs-selector-id"><span class="hljs-selector-id">#2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">edx</span></span> ;<span class="hljs-selector-id"><span class="hljs-selector-id">#2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 5 ;<span class="hljs-selector-id"><span class="hljs-selector-id">#2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jle</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span> ;<span class="hljs-selector-id"><span class="hljs-selector-id">#2</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 1 ;<span class="hljs-selector-id"><span class="hljs-selector-id">#3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L4</span></span> ;<span class="hljs-selector-id"><span class="hljs-selector-id">#3</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 0 ;<span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L4</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">test</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">al</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">al</span></span> ;<span class="hljs-selector-id"><span class="hljs-selector-id">#5</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">je</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L5</span></span> ;<span class="hljs-selector-id"><span class="hljs-selector-id">#5</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 1 ;<span class="hljs-selector-id"><span class="hljs-selector-id">#6</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L6</span></span> ;<span class="hljs-selector-id"><span class="hljs-selector-id">#6</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L5</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 2 ;<span class="hljs-selector-id"><span class="hljs-selector-id">#7</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L6</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 0 ;<span class="hljs-selector-id"><span class="hljs-selector-id">#8</span></span></code> </pre><br>  So, try to figure it out.  I singled out operations by numbers, so that it would be easier to distinguish what relates to what. <br><br>  # 1: a ++ &lt;0. At the same time, the value before the increment is recorded in eax, and that is exactly what should be compared with zero.  The <b>test</b> instruction works on the principle of <b>and</b> , but does not change the operands themselves, only the flags.  In our case, after <b>test,</b> we check the sign of the number, if it is 1, then we make the transition.  Also the value incremented by one is returned to the stack.  The increase is done by the instruction <b>lea edx, [eax + 1]</b> .  The lea instruction is used to load an effective address.  In our case, it replaces two instructions at once: <b>mov edx, eax</b> and <b>add edx, 1</b> . <br>  # 2: a ++&gt; 5. In fact, the same thing happens, only the transition to the .L3 label if a &lt;= 5. That is, we get to the .L2 label if the first condition or the second condition is satisfied.  In this case, note that the second condition will not be calculated if the first condition is fulfilled.  But you should have known that already. <br>  # 3: In the eax register it turns out 1 <br>  # 4: Eax turns 0 <br>  # 5: We check the low byte of the eax register to zero, if it is equal, then go to the label .L5 <br>  # 6: Otherwise, add to the variable "a" 1. Go to the end of the program. <br>  # 7: If the low byte in eax was equal to zero, then add the variable "a" 2 <br><br>  That is, # 3 is responsible for the fact that both conditions are met and the ‚Äúflag‚Äù is set, then the check is performed in # 5, if the ‚Äúflag‚Äù is set, then 1 is added, otherwise 2. <br><br>  It is also worth noting that <b>if (a &lt;0 &amp;&amp; a &lt;-5)</b> , if the first condition is not met, then the second will not be calculated either. <br><br><h2>  Conclusion </h2><br>  We briefly reviewed the conditions in C.  You saw that the compiler can either slightly modify the code or change it beyond recognition during optimization. <br><br>  Unfortunately, the article came out so long that it was not possible to consider the switch statement, so if you want, you can do this in the next article.  At the same time, you can also consider optimized programs with else. <br><br>  <a href="https://habrahabr.ru/post/344896/">Previous article</a> <br>  <a href="https://habrahabr.ru/post/347132/">Next article</a> </div><p>Source: <a href="https://habr.com/ru/post/345460/">https://habr.com/ru/post/345460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345448/index.html">Common examples of using advanced JQL queries</a></li>
<li><a href="../345450/index.html">Technoporn with WebAssembly</a></li>
<li><a href="../345452/index.html">Machine learning and chocolates</a></li>
<li><a href="../345454/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ294 (December 18 - 24, 2017)</a></li>
<li><a href="../345458/index.html">The story of the victory at the annual competition Russian AI Cup 2017</a></li>
<li><a href="../345462/index.html">PHP Digest number 122 (December 11 - 25, 2017)</a></li>
<li><a href="../345464/index.html">DevDay on functional. Record of reports</a></li>
<li><a href="../345468/index.html">PCI DSS: what it is and how to get certified for it + our experience</a></li>
<li><a href="../345472/index.html">The future of Internet protocols</a></li>
<li><a href="../345474/index.html">Security in modern corporations</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>