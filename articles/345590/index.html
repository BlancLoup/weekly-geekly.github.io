<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write Twitter-bot, which predicts the course Bitcoin</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The programmer Oggen Gatalo, the author of the article whose translation we are publishing today, has been interested in cryptocurrency for some time....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write Twitter-bot, which predicts the course Bitcoin</h1><div class="post__text post__text-html js-mediator-article">  The programmer Oggen Gatalo, the author of the article whose translation we are publishing today, has been interested in cryptocurrency for some time.  Especially it takes the forecasting course for the next few days.  He says that he tried some algorithms, but in the end he had the feeling that none of the approaches would allow us to make short-term forecasts with confidence.  Then he, focusing on the market leader Bitcoin, decided to work on his own method of predicting courses.  The proposed algorithm, as well as its implementation in the form of a twitter bot, of course, with some changes, are also suitable for working with other digital currencies. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df2/088/c8d/df2088c8d0c6086d80ecc7eee82a7e4d.png" alt="image"></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">General overview of the algorithm and its implementation</font> </h2><br>  Twitter seems to me a convenient platform for the implementation of projects in the field of cryptocurrency, similar to mine.  Here you can, in particular, organize convenient interaction between users and programs for which your own accounts are open.  That is why I decided to make my development in the form of a bot for Twitter.  In particular, my bot should, every 2 hours, tweet a bitcoin cost forecast for the next N days.  N is the period in days, the forecast for which interests most of all the people who have requested relevant information from the bot.  For example, if 3 people made a request for a 5-day forecast, and 7 people are interested in the forecast for 2 days, the bot tweets the forecast for 2 days. <br><br>  The bot is implemented on Node.js, I developed it pretty quickly.  It took some time to search for sources of historical and current price data and to select ways to work with them.  The main question was the algorithm.  In the end, I decided that they would use the K-nearest-neighbor method in combination with some more things. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The considered method of price forecasting includes the following sequence of actions: <br><br><ol><li>  Collect user requests for the next forecast. <br></li><li>  Finding the duration of the forecast, which is most often applied for. <br></li><li>  Getting the current value of bitcoin. <br></li><li> Finding <code>K(10)</code> nearest dates in the last 2 months, in which the price of Bitcoin was most similar to its current price. <br></li><li>  For the price of each of the dates found ( <code>PAST_DATE</code> ), finding the BTC price <code>N</code> days after it ( <code>N_DAYS_AFTER_PAST_DATE</code> ). <br></li><li>  For each date, the calculation of the difference between the price values <code>N_DAYS_AFTER_PAST_DATE</code> and <code>PAST_DATE</code> . <br></li><li>  Adding all the differences found and dividing what happened by <code>K</code> <br></li><li>  Getting the result in the video of the average rate change bitcoin between all groups of values <code>PAST_DATE</code> and <code>N_DAYS_AFTER_PAST_DATE</code> .  This result is used when forming a tweet. <br></li></ol><br>  Consider the basic steps of this process in more detail. <br><br><h2>  <font color="#3AC1EF">Step 1. Collect user requests</font> </h2><br>  In this step, using the <code>twit</code> module and the Twitter API, you search for tweets that contain the following construct: <code>@coin_instinct Predict for &lt;number&gt; days</code> .  Then, from the found tweets, the numbers symbolizing the number of days for which users want to get a forecast are extracted, and an array of numbers is created. <br><br><h2>  <font color="#3AC1EF">Step 2. Finding the duration of the forecast that interests the most users</font> </h2><br>  When the bot, once every 2 hours, tweets the forecast, the number of days that was used in this forecast is stored in the black list, represented by an array.  This array contains the duration of the predictions for the last 4 tweets.  This approach allows you to avoid the frequent appearance of similar tweets and the issuance of the same predictions that have already been tweeted in the last 8 hours. <br><br><pre> <code class="hljs pgsql">async <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> findMostFrequent(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, blackListArr) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.length == <span class="hljs-number"><span class="hljs-number">0</span></span>)       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;   var modeMap = {};   var maxEl = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>], maxCount = <span class="hljs-number"><span class="hljs-number">1</span></span>;   //     blackList    maxEl  ,    .         ,  generateRandom   var containsValidNumbers = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.length; i++) {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!blackListArr.includes(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[i])) {       maxEl = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[i];       containsValidNumbers = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;       break;     }   }   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!containsValidNumbers) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> await generateRandom(blackListArr);   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.length; i++)   {       var el = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[i];       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(blackListArr.includes(el)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(modeMap[el] == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)           modeMap[el] = <span class="hljs-number"><span class="hljs-number">1</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>           modeMap[el]++;        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(modeMap[el] &gt; maxCount)       {           maxEl = el;           maxCount = modeMap[el];       }   }   await addToBlackList(maxEl);   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> maxEl;  }</code> </pre> <br>  The function presented here is very simple.  She selects the most frequently requested duration of the predictions from an array of numbers.  If the number found is already in <code>blackListArr</code> , the function returns the second most requested forecast, and so on.  If all the requested forecast durations are already on the black list, then the bot issues a prediction for a randomly selected period. <br><br><h2>  <font color="#3AC1EF">Step 3. Getting the current value of Bitcoin</font> </h2><br>  You can find out the current value of Bitcoin using the API blockchain.info.  The resulting value is stored in a variable. <br><br><pre> <code class="hljs coffeescript">function refreshBitcoinPrices() { const request = async () =&gt; {   var results = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(<span class="hljs-string"><span class="hljs-string">"https://blockchain.info/ticker"</span></span>);   results = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> results.json();   bitcoinData.results = results;   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bitcoinData.results) {<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Blockchain API works!'</span></span>);}   <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Blockchain API is down at the moment.'</span></span>);   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.todayDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date();   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.todayDate = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.todayDate.toISOString().split(<span class="hljs-string"><span class="hljs-string">'T'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>];   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.todayDate);   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'New prices fetched.'</span></span>);   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Most recent bitcoin price: '</span></span>+bitcoinData.results.USD.last);   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Time: '</span></span>+<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date().getHours()+<span class="hljs-string"><span class="hljs-string">':'</span></span>+<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date().getMinutes()); }   request();   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {     request();   },COIN_FETCH_TIMEOUT); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">118</span></span> }</code> </pre> <br>  This function starts 2 minutes after the start of the algorithm. <br><br><h2>  <font color="#3AC1EF">Step 4. Find K closest neighbors</font> </h2><br>  Here I do not provide a description of all the functions used in this step, such as querying the Coindesk API to load the data required for the <code>PAST_DATE</code> and <code>N_DAYS_AFTER_PAST_DATE</code> .  The search for nearest neighbors is shown here, based on how similar they are to the current price value.  The complete project code can be found in my <a href="https://github.com/ognjengt/coin-instinct-bot">GitHub repository</a> . <br><br><pre> <code class="hljs lua">async <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNearestNeighbours</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(similarities)</span></span></span></span> { //      k(<span class="hljs-number"><span class="hljs-number">10</span></span>),     <span class="hljs-number"><span class="hljs-number">0</span></span> var absSimilarities = []; similarities.forEach( (similarity) =&gt; {   absSimilarities.push({     <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>: similarity.<span class="hljs-built_in"><span class="hljs-built_in">date</span></span>,     similarityScore: Math.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(similarity.similarityScore)   }) }) absSimilarities = absSimilarities.<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a.similarityScore &gt; b.similarityScore) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : ((b.similarityScore &gt; a.similarityScore) ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); }); var kNearest = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; K; i++) {   kNearest.push(absSimilarities[i].<span class="hljs-built_in"><span class="hljs-built_in">date</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> kNearest; }</code> </pre> <br>  Since we calculated the difference between all bitcoin prices in the last 2 months and its current value, we need to find the dates in which these values ‚Äã‚Äãare closest to 0. Therefore, we first call <code>Math.abs</code> for all <code>similatityScore</code> properties of objects that are in array, and then sort the array in descending order, based on these properties. <br><br>  At this stage, you can find the first 10 dates in which the Bitcoin price was closest to its current price. <br><br><h2>  <font color="#3AC1EF">Step 5. Formation of an array of results</font> </h2><br>  At this step, we will get an array of objects, each of which contains the properties <code>start</code> and <code>end</code> .  The <code>start</code> property represents the Bitcoin price for some of the previous dates, the <code>end</code> property is used to store the price <code>N</code> days after that day.  Based on these data, we can form a forecast, make a conclusion about whether the price will rise or fall. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFinalResults</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">kNearest,nDays</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalResults = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalResult = {}; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> forEach(kNearest, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>(date) =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dateTime = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(date);   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pastDate = dateTime.toISOString().split(<span class="hljs-string"><span class="hljs-string">'T'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>];   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> futureDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(date);   futureDate.setDate(futureDate.getDate() + nDays);   futureDate = futureDate.toISOString().split(<span class="hljs-string"><span class="hljs-string">'T'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>];     <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> valueForThatDay = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.coinDeskApiResults.bpi[pastDate];   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> valueForFutureDay = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.coinDeskApiResults.bpi[futureDate];   finalResult = {     <span class="hljs-attr"><span class="hljs-attr">start</span></span>: valueForThatDay,     <span class="hljs-attr"><span class="hljs-attr">end</span></span>: valueForFutureDay   }   finalResults.push(finalResult); }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> finalResults; }</code> </pre> <br>  Here we go through all the elements from <code>kNearest</code> and get data for specific dates, after which we save the results in the <code>finalResults</code> array and return it. <br><br><h2>  <font color="#3AC1EF">Step 6. Prediction</font> </h2><br>  Now it remains only to form a forecast.  This is done using the following function. <br><br><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-comment">/** *    *  ,     * @param {*Array} data  ,      start  end * @param {*Float} currentBitcoinValue    */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculatePrediction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data,currentBitcoinValue</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPredictionData = {   raw: <span class="hljs-number"><span class="hljs-number">0</span></span>,   percentage: <span class="hljs-number"><span class="hljs-number">0</span></span>,   positive: <span class="hljs-string"><span class="hljs-string">''</span></span>,   finalValue: <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> forEach(data, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) =&gt; {   sum += <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.end - <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.start; }) sum = sum / K; finalPredictionData.raw = sum; finalPredictionData.finalValue = currentBitcoinValue + sum; finalPredictionData.positive = sum &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-string"><span class="hljs-string">'true'</span></span> : <span class="hljs-string"><span class="hljs-string">'false'</span></span>; finalPredictionData.percentage = ((finalPredictionData.finalValue - currentBitcoinValue) / currentBitcoinValue) * <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> finalPredictionData; }</code> </pre> <br>  That's all, the forecast has been formed, it remains only to tweet it, having issued it accordingly. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  If you want to get acquainted with my bot more closely - I suggest to look into the above <a href="https://github.com/ognjengt/coin-instinct-bot">repository</a> , which stores the full code of the project.  In addition, I would like to note that this material describes my approach to predicting the Bitcoin price for the next few days, it is still in development, so if you have something to say about the proposed algorithm, <a href="https://twitter.com/ognjengt">let me know</a> .  The forecasts that the bot makes are not always accurate, but I noticed that in most cases the predicted value differs from the real only by $ 100-200.  So, apparently, we can say that the bot usually makes mistakes not so much, especially considering how crazy the rates of cryptocurrency behave. <br><br>  The main problem of the described algorithm is that it analyzes only historical data on Bitcoin and makes predictions based on them.  There is no prediction mechanism here, for example, sharp price drops.  I am working to take into account in the forecast, let's say, the "human factor".  It is planned to implement this by collecting, for example, articles from websites, by analyzing which you can find a hint of the possibility of sudden changes in the course and add this data to the equation. <br><br>  By the way, all this time I was talking about the bot, but I never presented it to you.  A special account has been opened for him, <a href="https://twitter.com/coin_instinct">coin_instinct</a> .  You can tvitnut him a request for a forecast. <br><br>  <b>Dear readers!</b>  Do you develop bots for twitter or predict cryptocurrency rates?  If yes, please share your experience. </div><p>Source: <a href="https://habr.com/ru/post/345590/">https://habr.com/ru/post/345590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345578/index.html">Bitcoin will not become new digital money: limited emission and money functions</a></li>
<li><a href="../345580/index.html">Build and heat applications in Kubernetes using dapp and GitLab CI</a></li>
<li><a href="../345584/index.html">Computer response time: 1977‚àí2017</a></li>
<li><a href="../345586/index.html">Top 10 examples and anti-examples of developer-audience interaction: Part Two</a></li>
<li><a href="../345588/index.html">From the domination of dwarf Spitz to where a homebody wants to go for a walk (1.5 months in Spain)</a></li>
<li><a href="../345592/index.html">Club of creators of domestic design systems</a></li>
<li><a href="../345594/index.html">Small study: IT in SMB - USA vs Russia</a></li>
<li><a href="../345596/index.html">The next ethical hacking contest ‚ÄúDefense in Defense 2017‚Äù</a></li>
<li><a href="../345598/index.html">Russian AI Cup 2017 - History 11 places</a></li>
<li><a href="../345600/index.html">ONLYOFFICE 2017: Results</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>