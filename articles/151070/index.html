<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"It is difficult about the simple." Constructor functions as objects, (prototype). Objects, (__ proto__). constructor, = {}, as a constructor function new Object ()</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last time we tried to deal with the following things: 



- 1. Despite the conventional wisdom, ‚Äúeverything in JS is an object‚Äù is not so, we found ou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"It is difficult about the simple." Constructor functions as objects, (prototype). Objects, (__ proto__). constructor, = {}, as a constructor function new Object ()</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/post/150730/">Last time</a> we tried to deal with the following things: <br><br><ul><li>  1. Despite the conventional wisdom, ‚Äúeverything in JS is an object‚Äù is not so, we found out that out of 6 data types available to the programmer, as many as 5 are primitives and only one represents the type of objects. </li><li>  2. About objects, we learned that this is a data structure that contains key-value pairs.  The value can be any of the data types (and it will be a property of the object) or a function (and it will be a method of the object). </li><li>  3. But the primitives are not objects.  Although it is possible to work with them as with an object (and this causes a delusion that the primitive is an object), but ... </li><li>  4. Variables can be declared both by simple (literally) (var a = 'str'), and through the constructor function (wrapper) (var a = new String ('str')).  In the second case, we get no longer a primitive, but an object created by the String () constructor.  (what kind of magic operator is new and what is a constructor function we will find out further). </li><li>  5. We learned that it is through the creation of a wrapper on a primitive (new String ('str')) that you can work with as an object.  It is this wrapper that the interpreter creates around the primitive when we try to work with it as an object, but after performing the operation it collapses (therefore, the primitive can never remember the property that we assign to it a.test = 'test'- the test property will disappear with the wrapper ). </li><li>  6. We learned that objects have a toString () method that returns a string representation of the object (for the type number, valueOf () will return a numeric value). </li><li>  7. They understood that when performing concatenation operations or mathematical operations, primitives can redefine their type into the necessary one.  To do this, they use the wrapper function of their types, but without the operator new (str = String (str)). (What is the difference and how it works, let's talk further) </li><li>  8. And finally, we learned that typeof takes values ‚Äã‚Äãfrom a hard-coded table (this is where another misconception comes from, based on typeof null // object). </li></ul><br><a name="habracut"></a>  Today I would like to talk about working with constructor functions and the prototype property, as well as about working with the objects generated by them and their __proto__ property.  This is often necessary when trying to organize inheritance in JS and for understanding some of the processes occurring in it.  It will also provide insight into some part of the prototype inheritance.  As an example for parsing (as long as it may not be clear to everyone), let's take the following code: <br><br>  Example1: <br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} A.prototype.x = <span class="hljs-number"><span class="hljs-number">10</span></span>; a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ax); <span class="hljs-comment"><span class="hljs-comment">//10 console.log(ay); //undefined A.prototype.y = 20; console.log(ay); //20 /*     A.prototype.&lt;&gt;           */ 2: function B() {} B.prototype.x = 10; b = new B(); console.log(bx); //10 console.log(by); //undefined B.prototype = {constructor:B, x:10, y:20}; console.log(bx); //10 console.log(by); //undefined /*    B.prototype = {constructor:B, x:10, y:20};         */ b1 = new B(); console.log(b1.x); //10 console.log(b1.y); //20 /*       */ b instanceof B; //false b1 instanceof B //true /*          */</span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Constructor functions, like prototype objects. </h5><br>  Let's start in order.  Consider a seemingly simple line of code. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}</code> </pre><br>  The very first thing you can say: "We declared a function named A".  Exactly.  But there are nuances. <br>  1. Do not forget that in JS - almost everything is an Object.  The function, as it turned out, is no exception (it is even two objects related by reference). <br>  2. It can be used as a constructor function. <br>  In JavaScript, there is no what is called classes.  The work of classes in JavaScript is performed by constructor functions that create objects with certain specified properties. <br>  In general, any function object in JS can be a constructor (I'm talking about user-defined functions).  They can be conditionally divided into three (DF (Function Declaration), FE (Function expression), functions created by the Function () constructor).  All these functions have their own characteristics (for this reason they are divided into different groups), but I will not talk about them here, if anyone is interested, I will answer personally or write separately about them another time.  However, they have one common feature that allows them to be constructors - the presence of the internal [[Construct]] and [[Call]] properties, as well as the explicit prototype property (about it below). <br>  It is the internal [[Construct]] method that is responsible for allocating memory for a new object and initializing it.  However, this does not mean that a function call will lead to the creation of an object, of course not.  To do this, before calling the function you need to put the operator new.  It is new that runs the [[Construct]] method and its associated processes. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} A(); <span class="hljs-comment"><span class="hljs-comment">//   var a = new A(); // -.  (a)  - (A)</span></span></code> </pre><br>  3. You can also say that this is a declaration function (DF) and so on, but the rest is not important yet. <br><br>  So Function "A" (from the first line of the first example) is a constructor function and partly an object.  Once it is an object, it can have properties.  The way it is.  And since this is a constructor function, it has a prototype property.  The prototype property is a reference to an object that stores properties and methods that will go to the instances created by this constructor function.  Let's try to display all this graphically. <br><br><img src="https://habrastorage.org/storage2/c33/bc5/a11/c33bc5a11887b62421a70f7a8b253144.jpg"><br><br>  By default, the prototype object is ‚Äúempty‚Äù (well, almost empty, but more on that below).  Above, I said that everything that lies in this object will go to the instance, and will also be available to descendants.  That is, by default (if nothing is added to prototype), then the instance ‚Äúnothing‚Äù will not be transferred from the constructor function ‚ÄúA‚Äù.  That is, when executing the code: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A();</code> </pre><br>  we get the "normal" (as far as possible in JS) object "a". <br>  JS has already built many constructor functions.  This is for example Number (), String (), etc. Let's digress for a while from the example and talk about the built-in constructor functions and Objects in general. <br><br><h5>  Objects (__ proto__). </h5><br>  From the previous article, we know that when creating (explicitly or not explicitly) objects by one of the built-in constructors Number (), String () or Boolean (), an instance gets access to some methods characteristic of this type.  For example, for Number () there is a toPrecision () method.  If you look at the object created by the constructor new Number (2) in the console, you will not find this method there (you will not find any methods there at all).  Where does he come from?  Just he and similar methods (to which the descendant must have access) are contained in the prototype object of the parent.  But how does the copy gain access to them?  The instance has the property __proto__ - this is a link to the prototype object of the parent.  If, when the method is called, the method is not in the instance itself, the link follows __proto__ to the prototype object of the parent and the search continues there.  In fact, this goes on and on until null is met. <br>  Let's try drawing it all: <br><br><img src="https://habrastorage.org/storage2/9b0/07b/69a/9b007b69a22e739364bc4a79bf90f132.jpg"><br><br>  Summing up, we can say that so far everything is not difficult: There is a parent (constructor function), which has a reference in the prototype property to a certain object where all methods and properties to which the descendant should have access are stored.  And there is, in fact, a descendant to which, when created through a call to new from the parent, a link is passed to the __proto__ property to that very object with common properties and methods. <br><br>  To fix, try to consider an example: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} <span class="hljs-comment"><span class="hljs-comment">//  - (  ¬´¬ª prototype) A.prototype.x = 10;//    prototype(    )  (x)  10 a = new A(); //     __proto__     prototype  (x==10) console.log(ax); // (x)       (a),     __proto__      prototype. console.log(ay); //   (y)     . A.prototype.y = 20; //   (y)  prototype(     ) console.log(ay); //20 //        __proto__ </span></span></code> </pre><br><br><h5>  constructor. </h5><br>  I always took the word (empty) in quotes when I said (‚Äúempty‚Äù prototype).  Like, when we create a function constructor function A () {}, the prototype property is created with reference to an ‚Äúempty‚Äù prototype object.  Not really.  The prototype still has something.  Firstly, since, as I already said, prototype is a ‚Äúsimple‚Äù Object, then there is the __proto__ property with a reference to the prototype of the Object () constructor function (it creates all the ‚Äúsimple‚Äù, the most elementary objects), and secondly there the constructor property lies.  The constructor property is added there by the interpreter when it realizes that a constructor function is being created and not just an object. First, let's add our first drawing taking into account these two facts. <br><br><img src="https://habrastorage.org/storage2/535/8bd/4f8/5358bd4f822532cad13fc9acbf1f9fd9.jpg"><br><br>  All that is painted in gray, we now do not particularly need - this is for a more complete picture.  Focus on the constructor property.  As seen from the figure, the constructor points to the constructor function for which this ‚Äústorage‚Äù was originally created, this object.  That is, there is a cyclicity between the prototype property of the constructor function and the constructor property of the prototype object ‚Äî they point to each other's objects. <br>  Through the constructor property (if it still points to the constructor, and the prototype property of the constructor, in turn, still points to the original prototype), you can indirectly get a reference to the object's prototype: a.constructor.prototype.x.  And you can put a link to the constructor function itself and its properties that were assigned not to the prototype object, but specifically to it.  For example: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} A.own = <span class="hljs-string"><span class="hljs-string">'I am A!'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     ‚Äî        a = new A(); a.own //undefined a.constructor.own // 'I am A!';</span></span></code> </pre><br><h5>  = {} - as a constructor function (new Object ()). </h5><br>  Great, sort of like everything fell into place.  There is a ‚Äúshared storage‚Äù, the parent and the descendant have links to this storage, if the property is not in the instance itself, then the interpreter will click on the link to look for it in the ‚Äúshared storage‚Äù.  What is the catch ??  Let's see Example2: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} B.prototype.x = <span class="hljs-number"><span class="hljs-number">10</span></span>; b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(bx); <span class="hljs-comment"><span class="hljs-comment">//10 console.log(by); //undefined B.prototype = {constructor:B, x:10, y:20}; console.log(bx); //10 console.log(by); //undefined</span></span></code> </pre><br>  It seems like everything should work.  We created a constructor function, set a ‚Äúshared storage‚Äù (prototype (via link)) property (x), created an instance, it has property (x) - everything is fine.  Then we generally redefined the prototype parent property by adding properties (x) and (y) and specifying the correct constructor.  Everything should work in the ‚Äúshared storage is‚Äù both of these properties, but no, (y) the interpreter does not find it.  WTF?!? <br><br>  What is the magic going on here?  Why we do not see these changes from the descendant of this constructor?  Why doesn't the descendant see y?  Well, firstly, we override the prototype property of the constructor function (B) and it starts to refer to the new object (the connection with the original prototype object is broken).  Secondly, the usual assignment of a variable to an object, of the type: var a = {}, by the interpreter is actually performed as var a = new Object ().  And this means that the prototype property of the constructor function now contains a completely new object whose constructor reference is missing and in order not to lose the parent, we independently add the constructor property there and assign it to the parent itself. <br>  And the instance made earlier contains the link __proto__ to the old prototype object where there are no properties (y).  That is, unlike Example 1, here we did not ‚Äúadd a property to the repository‚Äù and did not even ‚Äúrewrite the repository‚Äù, we just created a new one, breaking the link with the old one, and the instance knows nothing about it, it still uses the old one link __proto__.  It looks like this: <br><br><img src="https://habrastorage.org/storage2/d53/229/020/d532290208b7dcc1595a20ed20dd117e.jpg"><br><br>  In black, this is something that has not changed even after B.prototype = {constructor: B, x: 10, y: 20}; <br>  In red, what was removed <br>  Green - what was added <br><br>  You can also add a little bit about instanceof.  Oddly enough, but in this example, b1 will belong to the constructor function B, but b will not.  Everything is very simple.  The fact is that instanceof is looking for the fulfillment of the following condition - so that the object specified by the link __proto __ (at any level of the chain) (circle with number 1) is equal to the object referred to by the prototype property of the desired parent (circle with number 2) (compare black in the figure color and green).  In black, this condition is no longer fulfilled, and in green it is fulfilled. <br>  In our case, for instance (b) this link is broken, since the new prototype property of the desired parent (B) refers to a new object, and not as before.  But in the instance (b1) with this as we see everything is in order. <br><br><h5>  Chasing after </h5><br>  As for this in the body of the constructor function, I will not go deep at all - this will be discussed in the next article.  The only thing I will say is that this when calling a function as a constructor (via new) will indicate the created instance, and when called as a function, it will point to a global object. <br>  Let's take an example: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.val = str; } a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A(<span class="hljs-string"><span class="hljs-string">'test'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  val   ,        this       A('test'); //  this ‚Äî   .       val console.log(val) //'test'</span></span></code> </pre><br><br>  How to learn as caused function?  Through new or not?  This is done very simply: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> A) <span class="hljs-comment"><span class="hljs-comment">// this   A(    new) this.val = str; //   val else retur str; //(     new)   }</span></span></code> </pre><br>  Approximately in such a way the type conversion mechanism is implemented.  When executing, for example, 1 + '1', the interpreter perceives + as a string concatenation and tries to bring the number 1 into a string.  This is done using the implicit call to String (1) (without new).  And in the String constructor, we have about the same construction as above.  That is, if the call occurred without new, simply return the string (an implicit call to the toString () method).  Thus, without creating any objects, type conversion takes place. <br>  I also want to add the following, in order to add a property to a function (namely, to a function and not to a prototype) I need to refer to it as an object.  for example <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} A.val = <span class="hljs-string"><span class="hljs-string">'str'</span></span>;</code> </pre><br>  This property will not be available to the descendant, since it does not lie in the prototype, and the descendant has access only there.  But as they say "if you really want something you can."  This is where the prototype object constructor comes in handy.  As we remember, it refers to the function itself (unless of course this was specifically changed).  Then to get the val variable, you need to call it like this: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} A.val = <span class="hljs-string"><span class="hljs-string">'str'</span></span>; a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A(); a.constructor.val; <span class="hljs-comment"><span class="hljs-comment">//'str'</span></span></code> </pre><br><br>  Sources: <br>  <a href="https://developer.mozilla.org/">https://developer.mozilla.org</a> <br>  <a href="http://dmitrysoshnikov.com/">http://dmitrysoshnikov.com/</a> <br>  <a href="http://javascript.ru/">http://javascript.ru</a> </div><p>Source: <a href="https://habr.com/ru/post/151070/">https://habr.com/ru/post/151070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../151062/index.html">Should I pay for Apache Hadoop?</a></li>
<li><a href="../151064/index.html">Unix as IDE: Files</a></li>
<li><a href="../151065/index.html">Accident history: as one data center stood 8 hours</a></li>
<li><a href="../151066/index.html">Do you remember the conditions and prices of your tariff plan?</a></li>
<li><a href="../151069/index.html">Asus G55VW laptop video review</a></li>
<li><a href="../151075/index.html">Interview with Nikolai Gorkavym</a></li>
<li><a href="../151077/index.html">Refusal of the SRT (Part 2: "The Return of D'artanyan" or "The Last Argument of the King")</a></li>
<li><a href="../151078/index.html">Early career and first project. From a potential economist to a programmer</a></li>
<li><a href="../151079/index.html">Interactive games with augmented reality. Part 1. Introductory. Close to topic</a></li>
<li><a href="../151080/index.html">Ways to send SMS to the Android emulator in Windows</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>