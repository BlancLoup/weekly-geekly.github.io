<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Collection of examples of 64-bit errors in real programs - part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I dedicate this article to the user f0b0s , which constantly monitors our activity, accompanying it with a subtle humor that keeps us in good shape. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Collection of examples of 64-bit errors in real programs - part 1</h1><div class="post__text post__text-html js-mediator-article">  <i>I dedicate this article to the user <b><a href="https://habrahabr.ru/users/f0b0s/" class="user_link">f0b0s</a></b> , which constantly monitors our activity, accompanying it with a subtle humor that keeps us in good shape.</i> <br><br>  Readers of our articles on the development of 64-bit applications often reproach us for the lack of validity of the problems described.  Namely, that we do not give examples of errors in real applications. <br><br>  I decided to collect examples of various types of errors that we found ourselves in real programs that were read on the Internet or reported to us by PVS-Studio users.  So, I bring to your attention the article, which is a collection of 30 examples of 64-bit errors in C and C ++. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://habrahabr.ru/blogs/cpp/97810/">Continuation of the article &gt;&gt;</a> <br><br><a name="habracut"></a><br><br><h2>  Introduction </h2><br>  Our company OOO ‚ÄúProgram Verification Systems‚Äù develops a specialized static analyzer Viva64 that detects <a href="http://www.viva64.com/terminology/64-bit_error_rus.html">64-bit errors</a> in the code of C / C ++ applications.  In the course of this work, our collection of examples of 64-bit defects is constantly updated, and we decided to collect the most interesting errors in our article in this article.  The article provides examples both taken directly from the code of real applications, and compiled synthetically based on the real code, since they are too ‚Äústretched‚Äù in it. <br><br>  The article only demonstrates various types of 64-bit errors and does not describe methods for their detection and prevention.  You can get acquainted with the methods of diagnosing and fixing defects in 64-bit programs by referring to the following resources: <br><ol><li>  <a href="http://www.viva64.com/ru/articles/x64-lessons/">Course on developing 64-bit C / C ++ applications</a> [1]; </li><li>  <a href="http://www.viva64.com/art-1-1-72510946.html">What is size_t and ptrdiff_t</a> [2]; </li><li>  <a href="http://www.viva64.com/art-1-1-1958348565.html">20 issues of porting C ++ code on a 64-bit platform</a> [3]; </li><li>  <a href="http://www.viva64.com/art-4-1-1796251700.html">Tutorial on PVS-Studio</a> [4]; </li><li>  <a href="http://www.viva64.com/art-1-1-1064884779.html">64-bit horse that can count</a> [5]. </li></ol>  You can also get acquainted with the demo version of the <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> tool, which includes the static code analyzer Viva64, which reveals almost all the errors described in the article.  The demo version is available for download at: <a href="http://www.viva64.com/ru/pvs-studio/download/">http://www.viva64.com/en/pvs-studio/download/</a> . <br><br><h2>  Example 1. Buffer overflow </h2><br><pre>  struct STRUCT_1
 {
   int * a;
 };<font></font>
<font></font>
 struct STRUCT_2
 {
   int x;
 };
 ...
 STRUCT_1 Abcd;
 STRUCT_2 Qwer;
 memset (&amp; Abcd, 0, sizeof (Abcd));
 memset (&amp; Qwer, 0, sizeof (Abcd)); </pre><br>  The program declared two objects of the type STRUCT_1 and STRUCT_2, which must be cleared before use (initialize all fields with zeros).  Implementing initialization, the programmer decided to copy a similar line and replaced it with "&amp; Abcd" with "&amp; Qwer".  But he forgot to replace ‚Äúsizeof (Abcd)‚Äù with ‚Äúsizeof (Qwer).‚Äù By luck, the size of STRUCT_1 and STRUCT_2 structures coincided in a 32-bit system and the code worked correctly for a long time. <br><br>  When transferring code to a 64-bit system, the size of the Abcd structure increased and, as a consequence, a buffer overflow error occurred (see Figure 1). <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f8d/45b/c7a/f8d45bc7af68c50e571aa74ec9c35e4a.png" alt="Picture 1"><br></a> <br>  Figure 1 - Schematic explanation of an example buffer overflow <br><br>  Such an error can be difficult to identify, if this corrupts data used much later. <br><br><h2>  Example 2. Unnecessary type conversions </h2><br><pre>  char * buffer;
 char * curr_pos;
 int length;
 ...
 while ((* (curr_pos ++)! = 0x0a) &amp;&amp; 
        ((UINT) curr_pos - (UINT) buffer &lt;(UINT) length)); </pre><br>  The code is bad, but it is a real code.  Its task is to find the end of the line indicated by the symbol 0x0A.  The code will not work with strings longer than INT_MAX characters, since the variable length is of type int.  However, we are interested in another error, so we will assume that the program works with a small buffer and the use of the int type is correct. <br><br>  The problem is that in a 64-bit system, the buffer and curr_pos pointers may lie outside the first 4 gigabytes of address space.  In this case, explicitly casting pointers to the UINT type will discard significant bits, and the algorithm will fail (see Figure 2). <br><br> <a href=""><br><img src="https://habrastorage.org/getpro/habr/post_images/57e/d0d/ab4/57ed0dab49b2350b4f8c9804429ac872.png" alt="Picture 2"><br><br></a> <br>  Figure 2 - Incorrect calculations when searching for a terminal symbol <br><br>  The error is unpleasant because the code can work correctly for a long time while the memory for the buffer is allocated in the lower four gigabytes of the address space.  The correction of the error is to remove completely unnecessary explicit type conversions: <br><br><pre>  while (curr_pos - buffer &lt;length &amp;&amp; * curr_pos! = '\ r')
   curr_pos ++; </pre><br><h2>  Example 3. Incorrect #ifdef </h2><br>  Often in programs with a long history, you can find code sections wrapped in the #ifdef - - # else - #endif construction.  When migrating programs to a new architecture, incorrectly written conditions can lead to the compilation of the wrong code fragments, as planned by developers in the past (see Figure 3).  Example: <br><pre>  #ifdef _WIN32 // Win32 code
   cout &lt;&lt; "This is Win32" &lt;&lt; endl;
 #else // Win16 code
   cout &lt;&lt; "This is Win16" &lt;&lt; endl;
 #endif<font></font>
<font></font>
 // Alternative incorrect option:
 #ifdef _WIN16 // Win16 code
   cout &lt;&lt; "This is Win16" &lt;&lt; endl;
 #else // Win32 code
   cout &lt;&lt; "This is Win32" &lt;&lt; endl;
 #endif </pre><br> <a href=""><br><img src="https://habrastorage.org/getpro/habr/post_images/95c/fac/40f/95cfac40f26e23cd0cb68fc14057278c.png" alt="Picture 3"><br><br></a> <br>  Figure 3 - Two options are too few <br><br>  Relying on the #else option in such situations is dangerous.  It is better to explicitly consider the behavior for each case (see Figure 4), and in the #else branch put a compilation error message: <br><br><pre>  #if defined _M_X64 // Win64 code (Intel 64)
   cout &lt;&lt; "This is Win64" &lt;&lt; endl;
 #elif defined _WIN32 // Win32 code
   cout &lt;&lt; "This is Win32" &lt;&lt; endl;
 #elif defined _WIN16 // Win16 code
   cout &lt;&lt; "This is Win16" &lt;&lt; endl;
 #else
   static_assert (false, "Unknown platform");
 #endif </pre><br> <a href=""><br><img src="https://habrastorage.org/getpro/habr/post_images/309/764/706/3097647065b031b3e5564b17f54a3673.png" alt="Picture 4"><br><br></a> <br>  Figure 4 - All possible compilation paths are checked. <br><br><h2>  Example 4. Confusion with int and int * </h2><br>  In old programs, especially in C, code fragments are not rare, where the pointer is stored in the int type.  However, sometimes this is not done intentionally, but rather out of carelessness.  Consider an example containing confusion caused by the use of the int type and a pointer to the int type: <br><br><pre>  int GlobalInt = 1;<font></font>
<font></font>
 void GetValue (int ** x)
 {
   * x = &amp; GlobalInt;
 }<font></font>
<font></font>
 void SetValue (int * x)
 {
   GlobalInt = * x;
 }<font></font>
<font></font>
 ...
 int XX;
 GetValue ((int **) &amp; XX);
 SetValue ((int *) XX); </pre><br>  In this example, the variable XX is used as a buffer for storing the pointer.  This code will work correctly in those 32-bit systems where the pointer size coincides with the size of the int type.  In a 64-bit system, this code is incorrect and the call <br><br><pre>  GetValue ((int **) &amp; XX); </pre><br>  will result in corruption of 4 bytes of memory next to the variable XX (see Figure 5). <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/69c/dc4/24b/69cdc424bc089756a5292d54345b41b7.png" alt="Picture 5"><br></a> <br>  Figure 5 - Memory corruption near variable XX <br><br>  The code above was written either by a novice or in a hurry.  Moreover, explicit type conversions show that the compiler resisted to the last, hinting to the developer that a pointer and an int are different entities.  However, brute force won. <br><br>  Error correction is elementary and consists in choosing the right type for variable XX.  At the same time, an explicit type conversion is no longer necessary: <br><br><pre>  int * XX;
 GetValue (&amp; XX);
 SetValue (XX); </pre><br><h2>  Example 5. Using obsolete features </h2><br>  A number of API functions, although left for compatibility, is a danger when developing 64-bit applications.  A classic example is the use of functions such as SetWindowLong and GetWindowLong.  In programs you can find code similar to the following: <br><br><pre>  SetWindowLong (window, 0, (LONG) this);
 ...
 Win32Window * this_window = (Win32Window *) GetWindowLong (window, 0); </pre><br>  The programmer who once wrote this code has nothing to reproach.  In the course of development, 5-10 years ago, the programmer, drawing on his experience and MSDN, composed the code completely correct from the point of view of the 32-bit Windows system.  The prototype of these functions is as follows: <br><br><pre>  LONG WINAPI SetWindowLong (HWND hWnd, int nIndex, LONG dwNewLong);
 LONG WINAPI GetWindowLong (HWND hWnd, int nIndex); </pre><br>  The fact that the pointer is explicitly cast to the LONG type is also justified, since the size of the pointer and the LONG type match on <a href="http://www.viva64.com/terminology/Win32_rus.html">Win32</a> systems.  But I think it is clear that when a program is recompiled in the 64-bit version, these type conversions can cause a crash or incorrect application operation. <br><br>  The trouble of an error lies in its irregular or even extremely rare manifestation.  An error will occur whether or not it depends on the area of ‚Äã‚Äãmemory in which the object is created, pointed to by the ‚Äúthis‚Äù pointer.  If an object is created in the lower 4 gigabytes of the address space, then a 64-bit program can function correctly.  The error can unexpectedly manifest itself through a large period of time, when, due to memory allocation, objects will begin to be created beyond the first four gigabytes. <br><br>  In a 64-bit system, the SetWindowLong / GetWindowLong functions can be used only if the program actually saves certain values ‚Äã‚Äãsuch as LONG, int, bool, and the like.  If you need to work with pointers, then you should use advanced options: <b>SetWindowLongPtr /</b> GetWindowLongPtr.  Although, perhaps, it should be recommended to use new functions in any case in order not to provoke future errors in the future. <br><br>  Examples with the SetWindowLong and GetWindowLong functions are classic and are given in almost all articles devoted to the development of 64-bit applications.  However, it should be noted that business is not limited to these functions.  Pay attention to: SetClassLong, GetClassLong, GetFileSize, EnumProcessModules, GlobalMemoryStatus (see Figure 6). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4e/697/b8d/f4e697b8dd0398181cb390cad3f085fd.png" alt="Picture 6"><br>  Figure 6 - Table with the names of some obsolete and modern features <br><br><h2>  Example 6. Clipping of values ‚Äã‚Äãwith implicit type casting </h2><br>  Implicit conversions of type <a href="http://www.viva64.com/terminology/size_t_rus.html">size_t</a> to unsigned types and similar ones are well diagnosed by compiler warnings.  However, in large programs, such warnings can easily get lost.  Consider an example similar to real code where the warning was ignored, since it seemed that nothing bad could happen with short lines. <br><br><pre>  bool Find (const ArrayOfStrings &amp; arrStr)
 {
   ArrayOfStrings :: const_iterator it;
   for (it = arrStr.begin (); it! = arrStr.end (); ++ it)
   {
     unsigned n = it-&gt; find ("ABC");  // Truncation
     if (n! = string :: npos)
       return true;
   }
   return false;
 }; </pre><br>  The above function searches for the text ‚ÄúABC‚Äù in the array of strings and returns true if at least one line contains the sequence ‚ÄúABC‚Äù.  When compiling the 64-bit version of the code, this function will always return true. <br><br>  The constant "string :: npos" in a 64-bit system is set to 0xFFFFFFFFFFFFFFFF of type size_t.  When placing this value in the variable ‚Äún‚Äù of the unsigned type, it is trimmed to 0xFFFFFFFF.  As a result, the condition "n! = String :: npos" is always true, since 0xFFFFFFFFFFFFFFFF is not equal to 0xFFFFFFFF (see Figure 7). <br><br> <a href=""><br><img src="https://habrastorage.org/getpro/habr/post_images/468/8d4/12f/4688d412fa0514fbee012b008ee481ab.png" alt="Picture 7"><br><br></a> <br>  Figure 7 - A schematic explanation of the circumcision error <br><br>  The fix is ‚Äã‚Äãelementary, just listen to the compiler warnings: <br><br><pre>  for (auto it = arrStr.begin (); it! = arrStr.end (); ++ it)
 {
   auto n = it-&gt; find ("ABC");
   if (n! = string :: npos)
     return true;
 }
 return false; </pre><br><h2>  Example 7. Undeclared functions in C </h2><br>  Despite the years, programs or parts of programs written in the C language remain alive.  The code of these programs is much more prone to 64-bit errors due to less strict type control rules in the C language. <br><br>  In C, functions can be used without prior declaration.  Let's analyze the related interesting example of a 64-bit error.  To begin, consider the correct version of the code in which the allocation and use of three arrays of the size of each gigabyte takes place: <br><pre>  #include &lt;stdlib.h&gt;<font></font>
<font></font>
 void test ()
 {
   const size_t Gbyte = 1024 * 1024 * 1024;
   size_t i;
   char * pointers [3];<font></font>
<font></font>
   // Allocate
   for (i = 0; i! = 3; ++ i)
     Pointers [i] = (char *) malloc (Gbyte);<font></font>
<font></font>
   // Use
   for (i = 0; i! = 3; ++ i)
     Pointers [i] [0] = 1;<font></font>
<font></font>
   // Free
   for (i = 0; i! = 3; ++ i)
     free (pointers [i]);
 } </pre><br>  This code will correctly allocate memory, write one in the first element of each array, and free the occupied memory.  The code works perfectly on a 64-bit system. <br><br>  Now remove or comment out the line "#include &lt;stdlib.h&gt;".  The code will still be collected, but when the program starts it will crash.  If the header file ‚Äústdlib.h‚Äù is not connected, the C compiler assumes that the malloc function will return the type int.  The first two allocations are likely to be successful.  On the third call, the malloc function returns the address of the array outside of the first 2 gigabytes.  Since the compiler believes that the result of the function is of type int, it interprets the result incorrectly and stores in the Pointers array the incorrect pointer value. <br><br>  Consider the assembler code generated by the Visual C ++ compiler for the 64-bit Debug version.  The first is the correct code that will be generated when the declaration of the malloc function is present (the file ‚Äústdlib.h‚Äù is included): <br><br><pre>  Pointers [i] = (char *) malloc (Gbyte);
 mov rcx, qword ptr [Gbyte]
 call qword ptr [__imp_malloc (14000A518h)]
 mov rcx, qword ptr [i]
 mov qword ptr Pointers [rcx * 8], rax </pre><br><br>  Now consider the variant of incorrect code when the malloc function declaration is missing: <br><br><pre>  Pointers [i] = (char *) malloc (Gbyte);
 mov rcx, qword ptr [Gbyte]
 call malloc (1400011A6h)
 cdqe
 mov rcx, qword ptr [i]
 mov qword ptr Pointers [rcx * 8], rax </pre><br>  Note the presence of a CDQE (Convert doubleword to quadword) instruction.  The compiler considered that the result is contained in the eax register and expanded it to a 64-bit value in order to write to the Pointers array.  Accordingly, the high bits of the rax register will be lost.  Even if the address of the allocated memory lies within the first four gigabytes, in the case when the high bit of the eax register is 1, we still get an incorrect result.  For example, the address 0x81000000 will turn into 0xFFFFFFFF81000000. <br><br><h2>  Example 8. Dinosaur remains in large and old programs </h2><br>  Large old software systems that have been developing for decades, are replete with a variety of atavisms and simply sections of code written using popular paradigms and styles of various years.  In such systems, you can observe the evolution of the development of programming languages, when the oldest parts are written in the style of the C language, and in the most recent ones you can find complex patterns in the style of Alexandrescu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c16/419/60d/c1641960d77512972039b41521f84619.png" alt="Picture 1"><br>  Figure 8 - Dinosaur Excavations <br><br>  There are atavisms associated with 64 bits.  Rather, atavisms that impede the work of modern 64-bit code.  Consider an example: <br><br><pre>  // beyond this, assume a programming error
 #define MAX_ALLOCATION 0xc0000000 <font></font>
<font></font>
 void * malloc_zone_calloc (malloc_zone_t * zone,
   size_t num_items, size_t size)
 {
   void * ptr;
   ...<font></font>
<font></font>
   if (((unsigned) num_items&gt; = MAX_ALLOCATION) ||
       ((unsigned) size&gt; = MAX_ALLOCATION) ||
       ((long long) size * num_items&gt; =
        (long long) MAX_ALLOCATION))
   {  
     fprintf (stderr,
       "*** malloc_zone_calloc [% d]: arguments too large:% d,% d \ n",
       getpid (), (unsigned) num_items, (unsigned) size);
     return NULL;
   }
   ptr = zone-&gt; calloc (zone, num_items, size);
   ...
   return ptr;
 } </pre><br>  First, the function code contains a check for the allowable size of the allocated memory, which is strange for a 64-bit system.  And secondly, the diagnostic message issued will be incorrect, because if we ask to allocate memory for 4,400,000,000 elements, due to the explicit type conversion to unsigned, we will get a strange message about the impossibility of allocating memory for only 105,032,704 elements. <br><br><h2>  Example 9. Virtual Functions </h2><br>  One of the beautiful examples of 64-bit errors is the use of incorrect argument types in virtual function declarations.  And usually it is not someone's carelessness, but simply an ‚Äúaccident‚Äù where there are no guilty ones, but there is an error.  Consider the following situation. <br><br>  From time immemorial, the MFC library has a class CWinApp, in which there is a WinHelp function: <br><br><pre>  class CWinApp {
   ...
   virtual void WinHelp (DWORD dwData, UINT nCmd);
 }; </pre><br>  To show your own help in a user application, you had to override this function: <br><br><pre>  class CSampleApp: public CWinApp {
   ...
   virtual void WinHelp (DWORD dwData, UINT nCmd);
 }; </pre><br>  And everything was fine until 64-bit systems appeared.  MFC developers had to change the interface of the WinHelp function (and some other functions) as follows: <br><br><pre>  class CWinApp {
   ...
   virtual void WinHelp (DWORD_PTR dwData, UINT nCmd);
 }; </pre><br>  In the 32-bit mode, the DWORD_PTR and DWORD types coincided, but in the 64-bit mode they are not.  Naturally, the developers of a user application must also change the type to DWORD_PTR, but in order to do this, you need to know about it at the beginning.  As a result, an error occurs in the 64-bit program, since the WinHelp function in the user class is not called (see Figure 9). <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/2a6/7be/0f8/2a67be0f8f7338f69e9e9837952f0b30.png" alt="Picture 9"><br></a> <br>  Figure 9 - Error related to virtual functions <br><br><h2>  Example 10. Magic numbers as parameters </h2><br>  The magic numbers contained in the body of the programs are bad style and provoke errors.  As an example of magic numbers, 1024 and 768 can be given, which strictly indicate the size of the screen resolution.  In the framework of this article, we are interested in those magic numbers that can lead to problems in a 64-bit application.  The most common numbers dangerous for 64-bit programs are shown in the table in Figure 10. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e16/edc/e70/e16edce70aabb28ce4e73d08c0204a2a.png" alt="Picture 10"><br>  Figure 10 - Magic numbers dangerous for 64-bit programs <br><br>  Let us demonstrate an example of working with the CreateFileMapping function, encountered in one of the CAD systems: <br><pre> HANDLE hFileMapping = CreateFileMapping (
   (HANDLE) 0xFFFFFFFF,
   Null
   PAGE_READWRITE,
   dwMaximumSizeHigh,
   dwMaximumSizeLow,
   name); </pre><br>  Instead of the correct reserved constant INVALID_HANDLE_VALUE, the number 0xFFFFFFFF is used.  This is incorrect in the <a href="http://www.viva64.com/terminology/Win64_rus.html">Win64</a> program, where the constant INVALID_HANDLE_VALUE is 0xFFFFFFFFFFFFFFFF.  The correct way to call a function is: <br><br><pre>  HANDLE hFileMapping = CreateFileMapping (
   INVALID_HANDLE_VALUE,
   Null
   PAGE_READWRITE,
   dwMaximumSizeHigh,
   dwMaximumSizeLow,
   name); </pre><br>  Note.  Some believe that the value 0xFFFFFFFF when expanding to a pointer turns into 0xFFFFFFFFFFFFFFFF.  This is not true.  According to the rules of the C / C ++ language, the value 0xFFFFFFFF has the type ‚Äúunsigned int‚Äù, since it cannot be represented by the type ‚Äúint‚Äù.  Accordingly, expanding to the 64-bit type, the value 0xFFFFFFFFu turns into 0x00000000FFFFFFFFu.  But if we write (size_t) (- 1) like this, we will get the expected 0xFFFFFFFFFFFFFFFF.  Here ‚Äúint‚Äù first expands to ‚Äúptrdiff_t‚Äù and then turns into ‚Äúsize_t‚Äù. <br><br><h2>  Example 11. Magic constants denoting size </h2><br>  Another common mistake is to use magic numbers to set the size of an object.  Consider an example of buffer allocation and zeroing: <br><br><pre>  size_t count = 500;
 size_t * values ‚Äã‚Äã= new size_t [count];
 // Only part of the buffer will be filled
 memset (values, 0, count * 4); </pre><br>  In this case, in a 64-bit system, more memory is allocated than it is then filled with zero values ‚Äã‚Äã(see Figure 11).  The error is in the assumption that the size of the size_t type is always four bytes. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/09b/cf2/186/09bcf21862a18201f52c4fcd501f506c.png" alt="Picture 11"><br></a> <br>  Figure 11 - Filling only part of the array <br><br>  The correct option is: <br><pre>  size_t count = 500;
 size_t * values ‚Äã‚Äã= new size_t [count];
 memset (values, 0, count * sizeof (values ‚Äã‚Äã[0])); </pre><br>  Similar errors can be found when calculating the size of allocated memory or data serialization. <br><br><h2>  Example 12. Stack Overflow </h2><br>  In many cases, a 64-bit program consumes more memory and stack.  Allocating more memory in a heap is not dangerous, since this type of 64-bit memory is available many times more than 32-bit one.  But an increase in the used stack memory can lead to its unexpected overflow (stack overflow). <br><br>  The mechanism for using the stack is different in different operating systems and compilers.  We will consider the peculiarity of using the stack in the code of Win64 applications built by the Visual C ++ compiler. <br><br>  When developing <a href="http://www.viva64.com/go.php%3Furl%3D328">calling</a> conventions ( <a href="http://www.viva64.com/go.php%3Furl%3D328">calling</a> conventions) in Win64 systems, they decided to put an end to the existence of various function call options.  In Win32, there were a number of calling conventions: stdcall, cdecl, fastcall, thiscall, and so on.  In Win64, there is only one native calling convention.  Modifiers like __cdecl are ignored by the compiler. <br><br>  The x86-64 calling convention is similar to the fastcall agreement in x86.  In the x64 agreement, the first four integer arguments (from left to right) are transmitted in 64-bit registers chosen specifically for this purpose: <br><br>  RCX: 1st integer argument <br>  RDX: 2nd integer argument <br>  R8: 3rd integer argument <br>  R9: 4th integer argument <br><br>  The remaining integer arguments are passed through the stack.  The ‚Äúthis‚Äù pointer is considered an integer argument, so it is always placed in the RCX register.  If floating-point values ‚Äã‚Äãare transmitted, the first four of them are transmitted in the XMM0-XMM3 registers, and the subsequent ones via the stack. <br><br>  Although the arguments can be passed in registers, the compiler still reserves space for them in the stack, reducing the value of the RSP register (stack pointer).  At a minimum, each function must reserve 32 bytes in the stack (four 64-bit values ‚Äã‚Äãcorresponding to the registers RCX, RDX, R8, R9).  This space in the stack makes it easy to save the contents of the registers passed to the function in the stack.  The called function is not required to drop the input parameters passed through the registers to the stack, but reserving a place in the stack, if necessary, allows this.  If more than four integer parameters are passed, the corresponding additional space is reserved in the stack. <br><br>  The described feature leads to a significant increase in the rate of absorption of the stack.  Even if the function has no parameters, 32 bytes will still be ‚Äúbit off‚Äù from the stack, which are then not used at all.  The meaning of using such an uneconomical mechanism is related to the unification and simplification of debugging. <br><br>  Let's pay attention to one more moment.  The RSP stack pointer must be aligned to 16 bytes before another function call.  Thus, the total size of the used stack when calling a function <b>without parameters</b> in the 64-bit code <b>is 48 bytes:</b> 8 (return address) + 8 (alignment) + 32 (reserve for arguments). <br><br>  is it so bad?  Not.  We should not forget that a larger number of registers available in the 64-bit compiler allow us to build a more efficient code and not to reserve memory in the stack for some local function variables.  Thus, in some cases, the 64-bit version of the function uses a smaller stack than the 32-bit version.  This issue and various examples are discussed in more detail in the article " <a href="http://www.viva64.com/blog/ru/2010/06/07/926/">Reasons why 64-bit programs require more stack memory</a> ." <br><br>  It is impossible to predict whether a 64-bit program will consume more stack or less.  Due to the fact that the Win64-program can use 2-3 times more stack memory, it is necessary to make secure and change the project setting, which is responsible for the size of the reserved stack.  Select the Stack Reserve Size parameter in the project settings (/ STACK: reserve key) and increase the size of the reserved stack three times.  The default size is 1 megabyte. <br><br><h2>  Example 13. Variable Argument Function and Buffer Overflow </h2><br>  Although using functions with a variable number of arguments, such as printf, scanf is considered a bad style in C ++, they are still widely used.  These functions create many problems when transferring applications to other systems, including 64-bit systems.  Consider an example: <br><br><pre>  int x;
 char buf [9]; </pre><br>  sprintf (buf, "% p", &amp; x); <br>  The code author did not take into account that the size of the pointer in the future may be more than 32 bits.  As a result, on the 64-bit architecture, this code will cause a buffer overflow (see Figure 12).  This error may well be attributed to the use of the magic number '9', but in a real application, a buffer overflow can occur without magic numbers. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/829/ace/33c/829ace33c74f3b7961a5042766c74e89.png" alt="Picture 12"><br></a> <br>  Figure 12 - Buffer overflow when working with the sprintf function <br><br>  Options for correcting this code are different.  It is more rational to refactor code in order to get rid of the use of dangerous functions.  For example, you can replace printf with cout, and sprintf with boost :: format or std :: stringstream. <br><br>  <i>Note.</i>  <i>This recommendation is often criticized by developers under Linux, arguing that gcc checks that the format string matches the actual parameters passed, for example, to the printf function.</i>  <i>And, therefore, using printf is safe.</i>  <i>However, they forget that the format string can be transferred from another part of the program, loaded from resources.</i>  <i>In other words, in a real program, the formatting string is rarely present explicitly in the code, and, accordingly, the compiler cannot check it.</i>  <i>If the developer uses Visual Studio 2005/2008/2010, then he will not be able to receive a warning on the code of the form void * p = 0;</i>  <i>printf ("% x", p);</i>  <i>even using the / W4 and / Wall keys.</i> <br><br><h2>  Example 14. Function with a variable number of arguments and incorrect format </h2><br>  Often in programs you can find incorrect formatting lines when working with the printf function and other similar functions.  Because of this, incorrect values ‚Äã‚Äãwill be displayed, which, although it will not lead to a program crash, is, of course, an error: <br><br><pre>  const char * invalidFormat = "% u";
 size_t value = SIZE_MAX;<font></font>
<font></font>
 // The wrong value will be printed.
 printf (invalidFormat, value); </pre><br>  In other cases, an error in the format string will be critical.  Consider an example based on the implementation of the UNDO / REDO subsystem in one of the programs: <br><pre>  // Here, the pointers were saved as a string
 int * p1, * p2;
 ....
 char str [128];
 sprintf (str, "% X% X", p1, p2);<font></font>
<font></font>
 // In another function, this string
 // processed as follows:
 void foo (char * str)
 {
   int * p1, * p2;
   sscanf (str, "% X% X", &amp; p1, &amp; p2);
   // The result is an incorrect value of the p1 and p2 pointers.
   ...
 } </pre><br>  The "% X" format is not intended for working with pointers, and as a result, such a code is incorrect from the point of view of 64-bit systems.  In 32-bit systems, it is quite efficient, although not beautiful. <br><br><h2>  Example 15. Storing integer values ‚Äã‚Äãin double </h2><br>  We did not have to meet such a mistake ourselves.  This error is probably rare, but very real. <br>  The double type is 64-bit in size and is compatible with the IEEE-754 standard on 32-bit and 64-bit systems.  Some programmers use the double type to store and work with integer types: <br><pre>  size_t a = size_t (-1);
 double b = a;
 --a;
 --b;
 size_t c = b;  // x86: a == c
               // x64: a! = c </pre><br>  This example can still be tried to justify on a 32-bit system, since the double type has 52 significant bits and is capable of storing a 32-bit integer value without loss.  But if you try to save a 64-bit integer to double, the exact value may be lost (see Figure 13). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bef/495/0b0/bef4950b0fd1c6aab66694061a1213c5.png" alt="Picture 13"><br>  Figure 13 - Number of significant bits in size_t and double types <br><br>  <b><a href="http://habrahabr.ru/blogs/cpp/97810/">The second part of the article.</a></b> </div><p>Source: <a href="https://habr.com/ru/post/97751/">https://habr.com/ru/post/97751/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../97742/index.html">MyJamRing = traffic informer + alarm clock for Iphone</a></li>
<li><a href="../97743/index.html">Droider Chart. Release 7</a></li>
<li><a href="../97748/index.html">We remove advertising in Opera Mobile</a></li>
<li><a href="../97749/index.html">Earth Gravitational Map</a></li>
<li><a href="../97750/index.html">Reproduction of Tutankhamen's mummy using 3D printing</a></li>
<li><a href="../97752/index.html">A prototype programmable fiberglass cloth fabricated</a></li>
<li><a href="../97753/index.html">Official opening BitByBit</a></li>
<li><a href="../97754/index.html">Samsung again makes us happy and fascinates</a></li>
<li><a href="../97755/index.html">Samsung Xcover: $ 100, shockproof, 67 days of battery life</a></li>
<li><a href="../97756/index.html">3D projections on the buildings of the world</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>