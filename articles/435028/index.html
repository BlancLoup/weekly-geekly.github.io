<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tests on C without SMS and registration</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, zerocost has written an interesting article ‚ÄúTests in C ++ without macros and dynamic memory‚Äù , which deals with a minimalist framework for ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tests on C without SMS and registration</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/lg/12/b3/lg12b3c-s5uuok0_nialgfngc9e.png" alt="Screenshot Cutter" align="right">  Recently, <a href="https://habr.com/users/zerocost/" class="user_link">zerocost has</a> written an interesting article <a href="https://habr.com/post/434906/">‚ÄúTests in C ++ without macros and dynamic memory‚Äù</a> , which deals with a minimalist framework for testing C ++ code.  The author (almost) managed to avoid using macros for registering tests, however, instead of them, ‚Äúmagic‚Äù patterns appeared in the code, which personally seem to me, excuse me, inconceivably ugly.  After reading the article, I still had a vague feeling of dissatisfaction, since I <em>knew</em> that I could do better.  I could not immediately remember where, but I <em>definitely saw</em> the test code, which does not contain a single extra symbol for their registration: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ensure_equals(<span class="hljs-string"><span class="hljs-string">"2 + 2 = ?"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre> <br><p>  Finally, I remembered that this framework is called <a href="http://cutter.sourceforge.net/"><strong>Cutter</strong></a> and it uses in its own way a brilliant way to identify test functions. </p><a name="habracut"></a><br><p>  (The KDPV is taken from the Cutter website under CC BY-SA.) </p><br><h2 id="v-chyom-zhe-tryuk">  What is the trick? </h2><br><p>  The test code is collected in a separate shared library.  Test functions are extracted from exported library symbols and are identified by name.  Tests are performed by a special external utility.  Sapienti sat. </p><br><pre> <code class="cpp hljs">$ cat test_addition.c <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cutter.h&gt; void test_addition() { cut_assert_equal_int(2 + 2, 5); }</span></span></span></span></code> </pre> <br><pre> <code class="plaintext hljs">$ cc -shared -o test_addition.so \ -I/usr/include/cutter -lcutter \ test_addition.c</code> </pre> <br><pre> <code class="plaintext hljs">$ cutter . F ========================================================================= Failure: test_addition &lt;2 + 2 == 5&gt; expected: &lt;4&gt; actual: &lt;5&gt; test_addition.c:5: void test_addition(): cut_assert_equal_int(2 + 2, 5, ) ========================================================================= Finished in 0.000943 seconds (total: 0.000615 seconds) 1 test(s), 0 assertion(s), 1 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s) 0% passed</code> </pre> <br><p>  Here is <a href="http://cutter.sourceforge.net/reference/tutorial.html">an example from the Cutter documentation</a> .  You can safely skip everything related to Autotools, and look only at the code.  The framework is a bit strange, yes, like everything Japanese. </p><br><p>  I will not analyze the implementation features in too much detail.  I also do not have a full-fledged (and even at least draft) code, since for me personally I don‚Äôt really need it (everything in Rust is out of the box).  However, for interested people this can be a good exercise. </p><br><h2 id="detali-i-vozmozhnosti-realizacii">  Details and possibilities of implementation </h2><br><p>  Consider some of the tasks that need to be solved when writing a framework for testing using the Cutter approach. </p><br><h3 id="poluchenie-eksportiruemyh-funkciy">  Getting exported functions </h3><br><p>  To begin with, it is necessary to somehow get to the test functions.  Standard C ++, of course, does not describe shared libraries at all.  Windows has recently acquired a Linux subsystem, which allows all three major operating systems to be reduced to POSIX.  As you know, POSIX-systems provide functions <code>dlopen()</code> , <code>dlsym()</code> , <code>dlclose()</code> , with which you can get the address of a function, knowing the name of its symbol, and ... in general, everything.  POSIX does not disclose the list of functions contained in the loaded library. </p><br><p>  Unfortunately (although, rather, fortunately), there is no standard, portable way to detect all the functions exported from a library.  Perhaps, the fact that not on all platforms (read: embedded) in general exists the concept of a <em>library</em> .  But that's not the point.  The main thing that you have <em>to</em> use platform-specific features. </p><br><p>  As an initial approximation, you can simply call the utility <strong>nm</strong> : </p><br><pre> <code class="cpp hljs">$ cat test.<span class="hljs-function"><span class="hljs-function">cpp </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br><pre> <code class="plaintext hljs">$ clang -shared test.cpp</code> </pre> <br><pre> <code class="plaintext hljs">$ nm -gj ./a.out __Z20test_object_additionv dyld_stub_binder</code> </pre> <br><p>  parse its output and use <code>dlsym()</code> . </p><br><p>  For deeper introspection, libraries like <a href="https://sourceware.org/elfutils/">libelf</a> , <a href="https://github.com/DeVaukz/MachO-Kit">libMachO</a> , <a href="https://github.com/trailofbits/pe-parse">pe-parse</a> will be useful, allowing you to programmatically parse executable files and libraries of platforms you are interested in.  In fact, <strong>nm</strong> and the company just use them. </p><br><h3 id="filtraciya-testovyh-funkciy">  Filtering Test Functions </h3><br><p>  As you can see, the libraries contain some strange symbols: </p><br><pre> <code class="plaintext hljs">__Z20test_object_additionv dyld_stub_binder</code> </pre> <br><p>  What is the <code>__Z20test_object_additionv</code> , when we called the function just <code>test_object_addition</code> ?  And what is this left <code>dyld_stub_binder</code> ? </p><br><p>  The " <code>__Z20...</code> " symbols <code>__Z20...</code> are the so-called <em>name decoration</em> (name mangling).  Feature compilation C + +, nothing can be done, live with it.  This is how functions are called from the point of view of the system (and <code>dlsym()</code> ).  In order to show them to a person in a normal way, you can use libraries like <a href="https://github.com/radare/libdemangle">libdemangle</a> .  Of course, the library you need depends on the compiler you are using, but the decorating format is usually the same within the platform. </p><br><p>  As for strange functions like <code>dyld_stub_binder</code> , these are also features of the platform that will have to be taken into account.  You do not need to call some functions when running tests, since there is no fish there. </p><br><p>  A logical continuation of this idea will be the filtering function by name.  For example, you can run only functions with <code>test</code> in the name.  Or just functions from the <code>tests</code> namespace.  And also use nested namespaces to group tests.  There is no limit to your imagination. </p><br><h3 id="peredacha-konteksta-ispolnyaemogo-testa">  Passing the context of the executable test </h3><br><p>  Object files with tests are collected in a shared library, the execution of the code of which is fully controlled by an external utility driver - <code>cutter</code> for Cutter.  Accordingly, internal test functions can use this. </p><br><p>  For example, the context of an executable test ( <code>IRuntime</code> in the source article) can be easily passed through a global (thread-local) variable.  The driver is responsible for managing and passing context. </p><br><p>  In this case, test functions do not require arguments, but retain all advanced features, such as the arbitrary naming of the tested cases: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_vector_add_element</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ testing::description(<span class="hljs-string"><span class="hljs-string">"vector size grows after push_back()"</span></span>); }</code> </pre> <br><p>  The <code>description()</code> function accesses a conditional <code>IRuntime</code> via a global variable and thus can pass a human comment to the framework.  The security of using global context is guaranteed by the framework and is not the responsibility of the test writer. </p><br><p>  With this approach, the code will have less noise with passing the context to the comparison statements and internal test functions that may need to be called from the main one. </p><br><h3 id="konstruktory-i-destruktory">  Constructors and destructors </h3><br><p>  Since the execution of tests is fully controlled by the driver, it can execute additional code <em>around the</em> tests. </p><br><p>  The Cutter library uses the following functions for this: </p><br><ul><li>  <code>cut_setup()</code> - before each individual test </li><li>  <code>cut_teardown()</code> - after each individual test </li><li>  <code>cut_startup()</code> - before running all tests </li><li>  <code>cut_shutdown()</code> - after the completion of all tests </li></ul><br><p>  These functions are called only if defined in the test file.  They can be placed in the preparation and cleaning of the test environment (fixture): the creation of the necessary temporary files, the complex configuration of the test objects, and other testing antipatterns. </p><br><p>  For C ++ it is possible to come up with a more idiomatic interface: </p><br><ul><li>  more object oriented and type safe </li><li>  with better support for the RAII concept </li><li>  using lambda for deferred performance </li><li>  enabling test execution context </li></ul><br><p>  But I still think again about this all in detail now. </p><br><h3 id="samodostatochnye-ispolnimye-fayly-s-testami">  Self-contained executable test files </h3><br><p>  Cutter for convenience uses approach with shared libraries.  Various tests are compiled into a set of libraries that a separate test utility finds and executes.  Naturally, if you wish, you can embed the entire test driver code directly into an executable file, getting familiar separate files.  However, this will require collaboration with the build system in order to arrange the layout of these executable files in the right way: without cutting out ‚Äúunused‚Äù functions, with the right dependencies, etc. </p><br><h3 id="prochee">  Other </h3><br><p>  Cutter and other frameworks also have many other useful tools that can make life easier when writing tests: </p><br><ul><li>  flexible and <em>expandable</em> test statements </li><li>  build and retrieve test data from files </li><li>  study of stektraisov, handling exceptions and falls </li><li>  customizable ‚Äúbreakage levels‚Äù of tests </li><li>  running tests in multiple processes </li></ul><br><p>  It is worth looking back at existing frameworks while writing your bike.  UX is a much deeper topic. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  The approach used by the Cutter framework allows for the identification of test functions with minimal cognitive load on the programmer: just write test functions and that's it.  The code does not require the use of any special templates and macros, which increases its readability. </p><br><p>  The features of building and running tests can be hidden in reusable modules for build systems like Makefile, CMake, etc. The questions of a separate test build will still have to be asked one way or another. </p><br><p>  Among the shortcomings of this approach, we can note the difficulty of placing the tests in the same file (the same translation unit) as the main code.  Unfortunately, in this case, without additional hints, it is no longer possible to figure out which functions need to be run and which ones are not.  Fortunately, in C ++ it is customary to spread tests and implementation into different files. </p><br><p>  As for the final deliverance from macros, it seems to me that <em>it is</em> not worth giving up on them in <em>principle</em> .  Macros allow, for example, to more briefly write comparison statements, avoiding code duplication: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ensure_equals(<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); }</code> </pre> <br><p>  but at the same time maintaining the same information content of the issue in case of errors: </p><br><pre> <code class="plaintext hljs">Failure: test_object_addition &lt;ensure_equals(2 + 2, 5)&gt; expected: &lt;5&gt; actual: &lt;4&gt; test.c:5: test_object_addition()</code> </pre> <br><p>  The name of the function being tested, the file name and the line number of the beginning of the function can in theory be extracted from the debug information contained in the library being assembled.  The expected and actual value of the compared expressions are known functions <code>ensure_equals()</code> .  The macro allows you to "restore" the original writing of the test statement, from which it is more clear why the value <code>4</code> is expected. </p><br><p>  However, this is an amateur.  Does the advantage of macros for test code end there?  I have not really thought about this moment yet, which can be a good field for further <del>  perversions </del>  research.  A much more interesting question: is it possible to somehow make a <em>mock framework</em> for C ++ without macros? </p><br><p>  The attentive reader also noted that there are no SMS and asbestos in the implementation, which is a definite plus for the ecology and the economy of the Earth. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/435028/">https://habr.com/ru/post/435028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435014/index.html">Dart vs Node.js: compare performance on HTTP server implementations</a></li>
<li><a href="../435016/index.html">What Larry Ellison will bring to Tesla</a></li>
<li><a href="../435018/index.html">In 2018, we finally began to take seriously the time spent at the smartphone</a></li>
<li><a href="../435020/index.html">Hall of Fame Consumer Electronics: Stories of the Best Gadgets of the Last 50 Years, Part 2</a></li>
<li><a href="../435026/index.html">Making an instant messenger * that even works in an elevator</a></li>
<li><a href="../435032/index.html">The spacecraft "Chang'e-4" made a successful landing on the far side of the moon and sent the first photo</a></li>
<li><a href="../435036/index.html">Thoughts on modern C ++ and game development</a></li>
<li><a href="../435038/index.html">World nuclear power in 2018</a></li>
<li><a href="../435040/index.html">Bitcoin 10 years ago</a></li>
<li><a href="../435044/index.html">Antiquities: Minidisk in its natural habitat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>