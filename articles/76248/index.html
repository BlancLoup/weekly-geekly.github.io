<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is a Pimpl version of Qt, and with what it is eaten!</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction. 

 The term Pimpl is often used in Qt documentation. In addition, those who dug a little bit in Qt source code often saw such macros as:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is a Pimpl version of Qt, and with what it is eaten!</h1><div class="post__text post__text-html js-mediator-article"><h1>  Introduction. </h1><br><br>  The term Pimpl is often used in Qt documentation.  In addition, those who dug a little bit in Qt source code often saw such macros as: Q_DECLARE_PRIVATE, Q_D.  And also met the so-called private header files, whose name ends with "_p.h". <br>  In this article I will try to open the screen behind all this structure. <br><br><h1>  Pimpl, what is it? </h1><br>  Pimpl - Pointer to private implementation.  This is one of the names of the programming pattern.  He is also called the Cheshire cat - ‚ÄúCheshire Cat‚Äù (I like this name more).  What is the essence of this pattern?  The main idea of ‚Äã‚Äãthis pattern is to remove all private members of a class and, in some cases, the functionality to a private class. <br>  Hence the name "Cheshire Cat" - you can only see a smile, and everything else remains invisible, but it certainly is :-) Who does not remember this wonderful cat, may turn to the original source, to the book by Lewis Carroll "Alice in Wonderland".  Very interesting book, especially if read in the original. <br>  What does this give? <br><a name="habracut"></a><br><ol><li>  If the class hierarchy ‚Äúwide‚Äù or ‚Äúdeep‚Äù turns out to be a more complex class structure and thereby increases the convenience of ‚Äúreuse - reuse‚Äù code. </li><li>  It also makes it possible to hide the platform-dependent implementation from the end user. </li><li>  One of the main purposes of this pattern is to provide a mechanism for implementing the binary compatibility of a library when its implementation changes (achieved due to the fact that the entire implementation is in a private class).  More details about binary compatibility and binary application interface (ABI) can be found <a href="http://www.codesourcery.com/public/cxx-abi/abi.html">here (Itanium C ++ ABI)</a> and <a href="http://www.agner.org/optimize/calling_conventions.pdf">here (an article about calling conversion)</a> .  And the basic rules about binary compatibility from KDE developers are <a href="http://techbase.kde.org/Policies/Binary_Compatibility_Issues_With_C%252B%252B">Binary Compatibility Issues With C ++</a> with a brief collection of what you need and cannot do to preserve binary compatibility. </li><li>  The next advantage is that the number of exported characters in the class becomes smaller and the library loading speed increases, well, plus a smaller size of course. </li><li>  Increases the application build speed (which is very important). </li><li>  All unnecessary implementation is hidden from the client, in contrast to private methods, pimpl declaration and implementation are not visible at all. </li><li>  This pattern greatly facilitates the implementation of the implicit-sharing mechanism (I will not translate, so as not to produce unnecessary terminology).  The mechanism by which when copying classes does not copy data, and copying occurs only when a copy of the class will need to change this data.  Implicit-sharing is implemented in all Qt container classes.  To implement it, a Pimpl implementation called ‚Äúshared D-pointers‚Äù is used.  In general, this is a capacious topic and requires a separate article. </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But there must be cons, I will not hide them, I‚Äôll post it as it is: <br><ol><li>  Each constructor, destructor cause the allocation and release of memory, which increase the time to create a class. </li><li>  Each method that contains access to the private implementation adds plus one extra instruction. </li></ol><br><br>  Given these shortcomings, according to the author, the use of this pattern for classes that will be contained in the code in large numbers and created / deleted in the course of the life of the program is impractical.  Suppose an example of such an implementation could be loading and storing some data; here are the classes that implement this data and make it as easy as possible.  And any change in such classes assumes that the protocol of the transfer of this data changes.  But there may be other examples of such classes.  Therefore, the basic rule when using any pattern also applies to this one: it is necessary to use it optimally, where it is really necessary. <br>  That is, this pattern should be used in the event that you are writing a library or are planning to bring this functionality into a separate library in the future.  In other cases, in the personal opinion of the author, the use of such an approach is excessive. <br><br><h1>  How this is implemented in the Qt libraries. </h1><br>  In Qt code, the d-pointer approach is used.  The point is that the class XXXPrivate and the public class variable in the protected section are declared.  The implementation of a private class is already written in a separate header file or in a .cpp file (I will explain the difference later). <br>  The class hierarchy goes both in public and in private classes.  For this, the declaration of a private class is usually done in a separate .h file, which is also called public, but the prefix _p is added: qclassname_p.h.  And these classes are not installed along with the library, but serve only to build the library.  Therefore, you will not find them in the path where the QT libraries (Prefix-PATH) are installed. <br><br><h1>  What are the advantages of the d-pointers approach from Qt? </h1><br>  At first glance, this approach may seem a bit confusing, but I assure you that it is in fact very simple and intuitive, and even facilitates readability of the code (I refer to this as a subjective property, therefore it is debatable, everything depends on the perception of a particular person). <br>  Advantages: <br><ol><li>  Simple and visual. </li><li>  Direct access to the entire hierarchy of private classes (in fact, they are not private :-), but protected). </li><li>  The ability to access public class from private. </li><li>  The ability to implement a system of signals and slots for a private class and hide them from external use with the help of the Q_PRIVATE_SLOT macro (topic for a separate article). </li></ol><br><h1>  I want the same, but with pearl buttons!  (c) C / f "Diamond Arm" </h1><br>  If I convinced you that Pimpl is good, and you want to try and see how it works, then let me dedicate you to the implementation of Pimpl according to Qt. <br>  What should be done: <br>  1. Make forward - declare your private class before declaring a public class: <br><blockquote><code><font color="black"><font color="#0000ff">class</font> MyClassPrivate; <br> <font color="#0000ff">class</font> MyClass: <font color="#0000ff">public</font> QObject <br> { ..............</font> <br></code> </blockquote><br>  2. Further, in the first class of the hierarchy in the protected section, you must declare a variable that refers to a private class: <br><blockquote> <code><font color="black"><font color="#0000ff">protected</font> : <br> MyClassPrivate * <font color="#0000ff">const</font> d_ptr;</font> <br></code> </blockquote><br>  Note that the pointer is constant, in order to avoid all sorts of random absurdities there. <br>  3. Also in the protected section (as the first class of the hierarchy and all its heirs) it is necessary to declare a constructor that takes a private member of the class as a parameter.  This is necessary in order to ensure the possibility of creating heirs of a private class and using them as private classes in the entire hierarchy: <br><blockquote> <code><font color="black"><font color="#0000ff">protected</font> : <br> MyClass(MyClassPrivate &amp;&amp;d, QObject *parent);</font> <br></code> </blockquote><br>  4. In the private section, we declare a d-pointer access macro: <br><blockquote> <code><font color="black">Q_DECLARE_PRIVATE(MyClass);</font> <br></code> </blockquote><br>  Now we understand what he is: <br><blockquote> <code><font color="black"><font color="#0000ff">#define</font> Q_DECLARE_PRIVATE(Class) \ <br> inline Class##Private* d_func() { <font color="#0000ff">return</font> reinterpret_cast&lt;Class##Private *&gt;(d_ptr); } \ <br> inline <font color="#0000ff">const</font> Class##Private* d_func() <font color="#0000ff">const</font> { <font color="#0000ff">return</font> reinterpret_cast&lt; <font color="#0000ff">const</font> Class##Private *&gt;(d_ptr); } \ <br> friend <font color="#0000ff">class</font> Class##Private;</font> <br></code> </blockquote><br>  As we see here, the function d_func () and d_func () const are declared, with the help of which we get a pointer to a private class and a constant private class, respectively.  And we get it already reduced to the type of the private class of this object.  Well, we declare our private class a friend to the public. <br>  There is also a Q_DECLARE_PRIVATE_D macro.  The difference is that you specify a d-pointer variable as the second parameter, so instead of d_ptr, a variable with any name can be used as a D-pointer.  But the name of the function d_func remains unchanged. <br>  The macro implementation looks like this: <br><blockquote> <code><font color="black"><font color="#0000ff">#define</font> Q_DECLARE_PRIVATE_D(Dptr, Class) \ <br> inline Class##Private* d_func() { <font color="#0000ff">return</font> reinterpret_cast&lt;Class##Private *&gt;(Dptr); } \ <br> inline <font color="#0000ff">const</font> Class##Private* d_func() <font color="#0000ff">const</font> { <font color="#0000ff">return</font> reinterpret_cast&lt; <font color="#0000ff">const</font> Class##Private *&gt;(Dptr); } \ <br> friend <font color="#0000ff">class</font> Class##Private;</font> <br></code> </blockquote><br>  5. Now you need to declare our private class in the .cpp or _p.h file.  If you intend to further inherit from your class or are going to use private slots, then you need to put everything into a separate _p.h file.  If not, then it is enough to declare a private file in a .cpp file.  Also keep in mind that in the .pro file, the .h file must go to the _p.h file and to all the files that will include it.  This can be generally taken as a rule, as it makes the work easier for the compiler. <br><blockquote> <code><font color="black"><font color="#0000ff">class</font> MyClassPrivate <br> { <br> MyClassPrivate(); <br> <font color="#0000ff">virtual</font> ~MyClassPrivate(); <br> <br> <font color="#0000ff">int</font> i; <br> }</font> <br></code> </blockquote><br>  I also recommend making the destructor virtual if you plan to build a hierarchy of private classes.  Why?  This is a topic for a separate article and there are already enough such articles written, and of course if you don‚Äôt believe or trust the Internet, then refer to Straustrup, this topic is described in detail. <br>  7. The implementation of the constructor from the protected section will look something like this: <br><blockquote> <code><font color="black">MyClass::MyClass(MyClassPrivate &amp;dd, QObject* parent) <br> :QObject(parent) <br> ,d_ptr(&amp;dd) <br> { .....</font> <br></code> </blockquote><br>  Well, the usual constructor with this declaration (pay attention to the keyword explicit, if you do not know what it is and why, ask - this is useful): <br><blockquote> <code><font color="black"><font color="#0000ff">explicit</font> MyClass(QObject * parent);</font> <br></code> </blockquote><br>  It will look like this: <br><blockquote> <code><font color="black">MyClass::MyClass(QObject * parent) <br> :QObject(parent) <br> ,d_ptr( <font color="#0000ff">new</font> MyClassPrivate()) <br> {........</font> <br></code> </blockquote><br>  In the heir, the implementation of such a constructor will look like this: <br><blockquote> <code><font color="black">MyClassDerived::MyClassDerived(QObject * parent) <br> :MyClass(* <font color="#0000ff">new</font> MyClassDerivedPrivate(),parent) <br> {........</font> <br></code> </blockquote><br>  As you can see, the corresponding constructor of the inheritor passes an instance of its private class to all base classes along the inheritance hierarchy chain (the class hierarchy is the same in Qt; the very first class in the private class hierarchy is QObjectData, which contains the parent, object state and other basic properties). <br>  8. To access an instance of a private class from a public class method, there is a Q_D () macro. This is what it is: <br>  #define Q_D (Class) Class ## Private * const d = d_func () <br>  As you can see, we get a constant pointer to our private class in the form of a variable ‚Äúd‚Äù (here it is a D-pointer: -) !!!  ). <br><blockquote> <code><font color="black"><font color="#0000ff">int</font> MyClass::foo() <font color="#0000ff">const</font> <br> { <br> Q_D( <font color="#0000ff">const</font> MyClass); <br> <font color="#0000ff">return</font> d-&gt;i; <br> }</font> <br></code> </blockquote><br>  Please note that in constant methods you need to write const before the class name in a Q_D macro to get a constant pointer to a constant instance of a private class (if this wording scares you or is not completely clear, refer to the documentation on "const", believe me - this is very important ). <br>  9. Now dive deeper.  Let me introduce another beast ;-): Q-pointer.  A Q-pointer (aka Q-pointer) is the same D-pointer (aka D-pointer), only with the exact opposite.  It serves for access from the methods of a private class to a public instance (usually used in those cases if the logic is also moved to a private class, or it is planned to do this further along the chain of hierarchy). <br>  To implement it, in the very first class of the private hierarchy it is necessary to declare a pointer variable to the base class: <br><blockquote> <code><font color="black"><font color="#0000ff">class</font> MyClassPrivate <br> { <br> <font color="#0000ff">public</font> : <br> MyClassPrivate(); <br> <font color="#0000ff">virtual</font> ~MyClassPrivate(); <br> <br> <font color="#0000ff">int</font> i; <br> MyClass *q_ptr; <br> }</font> <br></code> </blockquote><br>  And in all hierarchy classes, declare the macro Q_DECLARE_PUBLIC, in which you plan to use a Q-pointer. <br><blockquote> <code><font color="black"><font color="#0000ff">class</font> MyClassPrivate <br> { <br> Q_DECLARE_PUBLIC(MyClass); <br> <font color="#0000ff">public</font> : <br> MyClassPrivate(); <br> <font color="#0000ff">virtual</font> ~MyClassPrivate(); <br> <br> <font color="#0000ff">int</font> i; <br> MyClass *q_ptr; <br> }</font> <br></code> </blockquote><br>  This is what the Q_DECLARE_PUBLIC macro is: <br><blockquote> <code><font color="black"><font color="#0000ff">#define</font> Q_DECLARE_PUBLIC(Class)                  \ <br> inline Class* q_func() { <font color="#0000ff">return</font> static_cast&lt;Class *&gt;(q_ptr); } \ <br> inline <font color="#0000ff">const</font> Class* q_func() <font color="#0000ff">const</font> { <font color="#0000ff">return</font> static_cast&lt; <font color="#0000ff">const</font> Class *&gt;(q_ptr); } \ <br> friend <font color="#0000ff">class</font> Class;</font> <br></code> </blockquote><br>  As you can see, everything is the same, as in Q_DECLARE_PRIVATE, except for the names.  Well, there is no macro for the alternative name q_ptr, like Q_DECLARE_PRIVATE_D. <br>  Important: do not forget to take care in all the constructors of the first class of the public hierarchy about the initialization of the variable q_ptr: <br><blockquote> <code><font color="black">MyClass::MyClass(QObject * parent) <br> :QObject(parent) <br> ,d_ptr( <font color="#0000ff">new</font> MyClassPrivate()) <br> { <br> Q_D(MyClass); <br> d-&gt;q_ptr = <font color="#0000ff">this</font> ; <br> ....... <br> }</font> <br></code> </blockquote><br><br>  10. To access from a private class method to a public class (for example, to make a call to a public class signal), there is a Q_Q macro, here‚Äôs how it looks: <br><blockquote> <code><font color="black"><font color="#0000ff">#define</font> Q_Q(Class) Class * <font color="#0000ff">const</font> q = q_func() <br></font> <br></code> </blockquote><br>  The logic is the same as for D-pointers, and the same rules.  Well, in the code it will look like this: <br><br><blockquote> <code><font color="black"><font color="#0000ff">void</font> MyClassPrivate::foo() <br> { <br> Q_Q(MyClass); <br> q-&gt;foo(); <br> emit(q-&gt;signal(i)); <br> }</font> <br></code> </blockquote><br><br><h1>  Conclusion </h1><br><br>  Note that all of these macros are not part of the public API, and can be changed at any time.  But I can calm you down.  Firstly, all this is such a basic foundation that at least this will change to the new major version, but in this case you will still have to port the application.  And secondly, many large projects use these macros: for example, KDE.  Well, if you are a convinced paranoid and do not trust anyone, you can declare similar macros in your global file, change their name and use them in the code, then you‚Äôre definitely afraid of nothing (except for changing the behavior of compilers with respect to macros :-), because paranoid there is always something to fear :-)). <br>  Also keep in mind that in my example, I inherit from QObject, which uses the same macros to build its hierarchy of both public and private classes.  But my private class hierarchy has nothing to do with the Qt private class hierarchy.  They stand aside and do not interfere with each other.  Since I have overlapped the d_ptr variable in my class, and for all heirs from my class, d_ptr will be a pointer to my hierarchy, but not for QObject.  For it, d_ptr will be a Qt hierarchy of private classes (more precisely, a pointer to a QObjectPrivate). <br>  A reasonable question may arise: why not inherit our private class from QObjectPrivate.  Answer: it is possible, but first of all, binary compatibility with the Qt library will be lost (we will need to have our library for each version of the private implementation in Qt (it also changes, QWidget is accurate)). And the second argument against is that you will need private for building our library Qt library header files that are located in the src folder of the sources, and not include the installed Qt libraries.  And it's hard to imagine why this is necessary (maybe someone will present counter-arguments, I will be glad). <br><br>  In the future, I will tell you some more interesting things: <br>  What is QFlag, what is its advantage and what to eat with it. <br>  Code execution rules in Qt-style. <br>  How to implement Implicit Sharing and what is Shared D-pointer. <br>  Useful macros in QT. <br>  Qt Creator inside and out. <br>  How to write an application for 7 platforms with minimal effort. <br>  And many other interesting things. <br><br>  PS: I am going to post new and interesting articles on my <a href="http://erudenko.com/">erudenko.com site</a> , though in bourgeois language.  If possible, I will translate it into Russian and post it here. <br><br>  PPS: I apologize for my Russian language, possible incorrect speech circulation and errors (both spelling and syntax) are not my native language :-) <br><br>  Fuuuuuuh, well, that's all.  As a supplement, a simple example of implementation, otherwise I wrote a lot of letters, but with an example it is always clearer: <br><br>  .pro file: <br><blockquote><ol><li>  TEMPLATE = lib </li><li>  HEADERS + = myclass.h \ </li><li>  myclass_p.h \ </li><li>  myclassderived.h \ </li><li>  myclassderived_p.h </li><li>  SOURCES + = myclass.cpp \ </li><li>  myclassderived.cpp </li></ol></blockquote><br><br>  myclass.h file: <br><br><blockquote><ol><li>  #ifndef MYCLASS_H </li><li>  <font color="#0000ff">#define</font> MYCLASS_H </li><li></li><li>  #include &lt;QObject&gt; </li><li></li><li>  <font color="#0000ff">class</font> MyClassPrivate; </li><li>  <font color="#0000ff">class</font> MyClass: <font color="#0000ff">public</font> QObject </li><li>  { </li><li>  Q_OBJECT </li><li>  <font color="#0000ff">public</font> : </li><li>  <font color="#0000ff">explicit</font> MyClass (QObject * parent = 0); </li><li>  <font color="#0000ff">int</font> foo () <font color="#0000ff">const</font> ; </li><li>  signals: </li><li>  <font color="#0000ff">void</font> signal ( <font color="#0000ff">int</font> ); </li><li>  <font color="#0000ff">protected</font> : </li><li>  MyClassPrivate * <font color="#0000ff">const</font> d_ptr; </li><li>  MyClass (MyClassPrivate &amp; dd, QObject * parent); </li><li>  <font color="#0000ff">private</font> : </li><li>  Q_DECLARE_PRIVATE (MyClass); </li><li>  }; </li><li></li><li>  <font color="#0000ff">#endif</font> // MYCLASS_H </li></ol></blockquote><br><br>  file myclass_p.h <br><blockquote><ol><li>  #ifndef MYCLASS_P_H </li><li>  <font color="#0000ff">#define</font> MYCLASS_P_H </li><li>  #include <font color="#A31515">"myclass.h"</font> </li><li></li><li>  <font color="#0000ff">class</font> MyClassPrivate </li><li>  { </li><li>  Q_DECLARE_PUBLIC (MyClass); </li><li>  <font color="#0000ff">public</font> : </li><li>  MyClassPrivate (); </li><li>  <font color="#0000ff">virtual</font> ~ MyClassPrivate (); </li><li></li><li>  <font color="#0000ff">void</font> foo (); </li><li></li><li>  <font color="#0000ff">int</font> i; </li><li>  MyClass * q_ptr; </li><li>  }; </li><li></li><li>  <font color="#0000ff">#endif</font> // MYCLASS_P_H </li></ol></blockquote><br><br>  myclass.cpp file <br><blockquote><ol><li>  #include <font color="#A31515">"myclass.h"</font> </li><li>  #include <font color="#A31515">"myclass_p.h"</font> </li><li></li><li></li><li>  MyClassPrivate :: MyClassPrivate () </li><li>  { </li><li>  i = 5; </li><li>  } </li><li></li><li>  MyClassPrivate :: ~ MyClassPrivate () </li><li>  { </li><li>  <font color="#008000">// nothing to do</font> </li><li>  } </li><li></li><li>  <font color="#0000ff">void</font> MyClassPrivate :: foo () </li><li>  { </li><li>  Q_Q (MyClass); </li><li>  emit (q-&gt; signal (i)); </li><li>  } </li><li></li><li></li><li></li><li>  MyClass :: MyClass (QObject * parent) </li><li>  : QObject (parent) </li><li>  , d_ptr ( <font color="#0000ff">new</font> MyClassPrivate ()) </li><li>  { </li><li>  Q_D (MyClass); </li><li>  d-&gt; q_ptr = <font color="#0000ff">this</font> ; </li><li>  } </li><li></li><li>  MyClass :: MyClass (MyClassPrivate &amp; dd, QObject * parent) </li><li>  : QObject (parent) </li><li>  , d_ptr (&amp; dd) </li><li>  { </li><li>  Q_D (MyClass); </li><li>  d-&gt; q_ptr = <font color="#0000ff">this</font> ; </li><li>  } </li><li></li><li></li><li>  <font color="#0000ff">int</font> MyClass :: foo () <font color="#0000ff">const</font> </li><li>  { </li><li>  Q_D ( <font color="#0000ff">const</font> MyClass); </li><li>  <font color="#0000ff">return</font> d-&gt; i; </li><li>  } </li></ol></blockquote><br><br>  file myclassderived.h <br><blockquote><ol><li>  #ifndef MYCLASSDERIVED_H </li><li>  <font color="#0000ff">#define</font> MYCLASSDERIVED_H </li><li>  #include <font color="#A31515">"myclass.h"</font> </li><li></li><li>  <font color="#0000ff">class</font> MyClassDerivedPrivate; </li><li>  <font color="#0000ff">class</font> MyClassDerived: <font color="#0000ff">public</font> MyClass </li><li>  { </li><li>  Q_OBJECT </li><li>  <font color="#0000ff">public</font> : </li><li>  <font color="#0000ff">explicit</font> MyClassDerived (QObject * parent = 0); </li><li>  signals: </li><li>  <font color="#0000ff">void</font> signal2 ( <font color="#0000ff">int</font> ); </li><li>  <font color="#0000ff">protected</font> : </li><li>  MyClassDerived (MyClassDerivedPrivate &amp; dd, QObject * parent); </li><li>  <font color="#0000ff">private</font> : </li><li>  Q_DECLARE_PRIVATE (MyClassDerived); </li><li>  }; </li><li></li><li>  <font color="#0000ff">#endif</font> // MYCLASSDERIVED_H </li></ol></blockquote><br><br>  file myclassderived_p.h <br><blockquote><ol><li>  #ifndef MYCLASSDERIVED_P_H </li><li>  <font color="#0000ff">#define</font> MYCLASSDERIVED_P_H </li><li></li><li>  #include <font color="#A31515">"myclassderived.h"</font> </li><li>  #include <font color="#A31515">"myclass_p.h"</font> </li><li></li><li>  <font color="#0000ff">class</font> MyClassDerivedPrivate: <font color="#0000ff">public</font> MyClassPrivate </li><li>  { </li><li>  Q_DECLARE_PUBLIC (MyClassDerived); </li><li>  <font color="#0000ff">public</font> : </li><li>  MyClassDerivedPrivate (); </li><li>  <font color="#0000ff">virtual</font> ~ MyClassDerivedPrivate (); </li><li></li><li>  <font color="#0000ff">void</font> foo2 (); </li><li>  <font color="#0000ff">int</font> j; </li><li>  }; </li><li></li><li>  <font color="#0000ff">#endif</font> // MYCLASSDERIVED_P_H </li></ol></blockquote><br><br>  myclassderived.cpp file <br><blockquote><ol><li>  #include <font color="#A31515">"myclassderived.h"</font> </li><li>  #include <font color="#A31515">"myclassderived_p.h"</font> </li><li></li><li></li><li></li><li>  MyClassDerivedPrivate :: MyClassDerivedPrivate () </li><li>  { </li><li>  j = 6; </li><li>  i = 7; </li><li>  } </li><li></li><li>  MyClassDerivedPrivate :: ~ MyClassDerivedPrivate () </li><li>  { </li><li></li><li>  } </li><li></li><li>  <font color="#0000ff">void</font> MyClassDerivedPrivate :: foo2 () </li><li>  { </li><li>  Q_Q (MyClassDerived); </li><li>  emit (q-&gt; signal2 (j)); </li><li>  emit (q-&gt; signal (j)); </li><li>  } </li><li></li><li>  MyClassDerived :: MyClassDerived (QObject * parent) </li><li>  : MyClass (* <font color="#0000ff">new</font> MyClassDerivedPrivate (), parent) </li><li>  { </li><li>  <font color="#008000">// Empty</font> </li><li>  } </li><li></li><li>  MyClassDerived :: MyClassDerived (MyClassDerivedPrivate &amp; dd, QObject * parent) </li><li>  : MyClass (dd, parent) </li><li>  { </li><li>  <font color="#008000">// Empty</font> </li><li>  } </li></ol></blockquote></div><p>Source: <a href="https://habr.com/ru/post/76248/">https://habr.com/ru/post/76248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../76237/index.html">VNC - remote access to the computer over the network</a></li>
<li><a href="../76238/index.html">Estartup</a></li>
<li><a href="../76240/index.html">New Google acquisition</a></li>
<li><a href="../76246/index.html">Jquery tooltip widget</a></li>
<li><a href="../76247/index.html">App Store continues to fail</a></li>
<li><a href="../76249/index.html">We saw patriotism</a></li>
<li><a href="../76250/index.html">Using Microsoft Ajax Library 3.5 with Microsoft CDN</a></li>
<li><a href="../76251/index.html">Skype switches to SIP?</a></li>
<li><a href="../76253/index.html">Site Shantsev fell to 1.4 million rubles</a></li>
<li><a href="../76254/index.html">10 inexpensive ways to increase employee loyalty in a startup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>