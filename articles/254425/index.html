<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JSONB requests in PostgreSQL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Earlier, I wrote how to enable jsonb support in postgres / psycopg2 . Today I experimented with how to request data in JSON type columns. 
 There is d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JSONB requests in PostgreSQL</h1><div class="post__text post__text-html js-mediator-article">  Earlier, I wrote how to enable jsonb support in <a href="http://schinckel.net/2014/05/24/python%252C-postgres-and-jsonb/">postgres / psycopg2</a> .  Today I experimented with how to request data in JSON type columns. <br>  There is <a href="http://www.postgresql.org/docs/9.4/static/functions-json.html">documentation</a> on this subject, but it was not quite clear to me how the various operations work: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> json_test ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">serial</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> jsonb ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> json_test (<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'{}'</span></span>), (<span class="hljs-string"><span class="hljs-string">'{"a": 1}'</span></span>), (<span class="hljs-string"><span class="hljs-string">'{"a": 2, "b": ["c", "d"]}'</span></span>), (<span class="hljs-string"><span class="hljs-string">'{"a": 1, "b": {"c": "d", "e": true}}'</span></span>), (<span class="hljs-string"><span class="hljs-string">'{"b": 2}'</span></span>);</code> </pre> <br><a name="habracut"></a><br>  The request has worked, let's display all the data to check: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test; id | data <span class="hljs-comment"><span class="hljs-comment">----+-------------------------------------- 1 | {} 2 | {"a": 1} 3 | {"a": 2, "b": ["c", "d"]} 4 | {"a": 1, "b": {"c": "d", "e": true}} 5 | {"b": 2} (5 rows)</span></span></code> </pre><br>  Now let's filter the results.  There are several operators that we can use, and we will see later why jsonb was chosen as the type. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Equality</b> <br>  In jsonb, we can verify that two JSON objects are identical: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span>; id | data <span class="hljs-comment"><span class="hljs-comment">----+------ 1 | {"a": 1} (1 row)</span></span></code> </pre><br><br>  <b>Restrictions</b> <br>  We can also get a json object containing another, i.e.  "Being a subset": <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> @&gt; <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span>;</code> </pre><br>  Says: - Give us all the objects starting with key a and value 1: <br><br><pre> <code class="sql hljs"> id | data <span class="hljs-comment"><span class="hljs-comment">----+-------------------------------------- 2 | {"a": 1} 4 | {"a": 1, "b": {"c": "d", "e": true}} (2 rows)</span></span></code> </pre><br>  Restrictions in both directions: <br>  In this case, the query will display an empty object and an exact match for the second: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> &lt;@ <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span>; id | data <span class="hljs-comment"><span class="hljs-comment">----+---------- 1 | {} 2 | {"a": 1} (2 rows)</span></span></code> </pre><br><br>  <b>Existence key / element</b> <br>  The last batch of statements will check for the existence of a key (or a string element in the array). <br><br><pre> <code class="sql hljs"> id | data <span class="hljs-comment"><span class="hljs-comment">----+-------------------------------------- 2 | {"a": 1} 3 | {"a": 2, "b": ["c", "d"]} 4 | {"a": 1, "b": {"c": "d", "e": true}} (3 rows)</span></span></code> </pre><br>  Get the objects that have any keys from the list: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> ?| <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]; id | data <span class="hljs-comment"><span class="hljs-comment">----+-------------------------------------- 2 | {"a": 1} 3 | {"a": 2, "b": ["c", "d"]} 4 | {"a": 1, "b": {"c": "d", "e": true}} 5 | {"b": 2} (4 rows)</span></span></code> </pre><br>  And all the values ‚Äã‚Äãof objects having an exact match of the keys from the list: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> ?&amp; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]; id | data <span class="hljs-comment"><span class="hljs-comment">----+-------------------------------------- 3 | {"a": 2, "b": ["c", "d"]} 4 | {"a": 1, "b": {"c": "d", "e": true}} (2 rows)</span></span></code> </pre><br>  <b>Keys to bypass</b> <br>  You can also filter entries matching key-&gt; path.  In simple cases, the use of restriction operators may be simpler, but not complex, they can not do.  We can use these operations in SELECT, but it is still more interesting to apply them in the WHERE clause. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> -&gt;&gt; <span class="hljs-string"><span class="hljs-string">'a'</span></span> &gt; <span class="hljs-string"><span class="hljs-string">'1'</span></span>;</code> </pre><br>  We get all the records of the values ‚Äã‚Äãof the associative element with the key a equal to 1. <br>  Note the need to use a text value, not a number: <br><br><pre> <code class="sql hljs"> id | data <span class="hljs-comment"><span class="hljs-comment">----+--------------------------- 3 | {"a": 2, "b": ["c", "d"]} (1 row)</span></span></code> </pre><br>  We can make a comparison between the primitives of objects and arrays: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">'b'</span></span> &gt; <span class="hljs-string"><span class="hljs-string">'1'</span></span>; id | data <span class="hljs-comment"><span class="hljs-comment">----+-------------------------------------- 3 | {"a": 2, "b": ["c", "d"]} 4 | {"a": 1, "b": {"c": "d", "e": true}} 5 | {"b": 2} (3 rows)</span></span></code> </pre><br>  It turns out that arrays and objects are larger than numbers. <br>  We can also look at a deeper path: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-comment"><span class="hljs-comment">#&gt; '{b,c}' = '"d"';</span></span></code> </pre><br>  We obtain an object where the element b has a child object c, and c is equal to the string ‚Äúd‚Äù: <br><br><pre> <code class="sql hljs">id | data <span class="hljs-comment"><span class="hljs-comment">----+-------------------------------------- 4 | {"a": 1, "b": {"c": "d", "e": true}}</span></span></code> </pre><br>  There are also versions of these operators that return text, not a JSON object.  In the case of the last request, this means that we do not need to compare with the JSON object (in the version where we really want to get the string): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-comment"><span class="hljs-comment">#&gt;&gt; '{b,c}' = 'd'; id | data ----+-------------------------------------- 4 | {"a": 1, "b": {"c": "d", "e": true}} (1 row)</span></span></code> </pre><br>  So, up to this point, everything is fine.  We can work with different data, and the same data can be used in jsonb indexes too.  However, a more attentive reader may have noticed that we are dealing with JSON data, which have an object path from the root.  It doesn‚Äôt have to be this way: arrays are also valid JSON, any of the valid examples are really like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'null'</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>, <span class="hljs-string"><span class="hljs-string">'true'</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>, <span class="hljs-string"><span class="hljs-string">'false'</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>, <span class="hljs-string"><span class="hljs-string">'1.0001'</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>, <span class="hljs-string"><span class="hljs-string">'"abc"'</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>, <span class="hljs-string"><span class="hljs-string">'1E7'</span></span>::jsonb;</code> </pre><br>  Note the last entry, which is a jsonb type and is converted to canonical form: <br><br><pre> <code class="sql hljs"> json | json | json | json | json | json | jsonb <span class="hljs-comment"><span class="hljs-comment">------+------+-------+------+---------+-------+---------- null | true | false | 2 | 1.00001 | "abc" | 10000000 (1 row)</span></span></code> </pre><br>  JSON is also null different from SQL NULL. <br>  So, what happens when we store objects of mixed ‚Äútype‚Äù in a JSON column? <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> json_test (<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'[]'</span></span>), (<span class="hljs-string"><span class="hljs-string">'[1,2,"a"]'</span></span>), (<span class="hljs-string"><span class="hljs-string">'null'</span></span>), (<span class="hljs-string"><span class="hljs-string">'1E7'</span></span>), (<span class="hljs-string"><span class="hljs-string">'"abc"'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test; id | data <span class="hljs-comment"><span class="hljs-comment">----+-------------------------------------- 1 | {} 2 | {"a": 1} 3 | {"a": 2, "b": ["c", "d"]} 4 | {"a": 1, "b": {"c": "d", "e": true}} 5 | {"b": 2} 6 | [] 7 | [1, 2, "a"] 8 | null 9 | 10000000 10 | "abc" (10 rows)</span></span></code> </pre><br>  The whole structure was derived without problems.  Let's see if we can work with these objects and queries? <br>  The equality check works great: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = <span class="hljs-string"><span class="hljs-string">'null'</span></span>;</code> </pre><br>  Constraints also work as expected: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> @&gt; <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> &lt;@ <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span>;</code> </pre><br>  Keys and existing items also work.  Not surprisingly, one request will match the elements in the array, as well as the keys in the object: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> ? <span class="hljs-string"><span class="hljs-string">'a'</span></span>; id | data <span class="hljs-comment"><span class="hljs-comment">----+-------------------------------------- 2 | {"a": 1} 3 | {"a": 2, "b": ["c", "d"]} 4 | {"a": 1, "b": {"c": "d", "e": true}} 7 | [1, 2, "a"] (4 rows)</span></span></code> </pre><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> ?| <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]; id | data <span class="hljs-comment"><span class="hljs-comment">----+-------------------------------------- 2 | {"a": 1} 3 | {"a": 2, "b": ["c", "d"]} 4 | {"a": 1, "b": {"c": "d", "e": true}} 5 | {"b": 2} 7 | [1, 2, "a"] (5 rows)</span></span></code> </pre><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> ?&amp; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]; id | data <span class="hljs-comment"><span class="hljs-comment">----+-------------------------------------- 3 | {"a": 2, "b": ["c", "d"]} 4 | {"a": 1, "b": {"c": "d", "e": true}} (2 rows)</span></span></code> </pre><br>  But as soon as we start making keys or 'get' elements, we get problems; <br><br>  (Apparently, the author of the article at the time of writing was installed PotgreSQL 9.4 betta version, so some of the requests were filled with errors, checked on 9.4.1 all requests are being processed): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> -&gt;&gt; <span class="hljs-string"><span class="hljs-string">'a'</span></span> &gt; <span class="hljs-string"><span class="hljs-string">'1'</span></span>; ERROR: cannot <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> jsonb_object_field_text (jsonb -&gt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> an <span class="hljs-built_in"><span class="hljs-built_in">array</span></span></code> </pre><br>  You can still use key-path traversal if you have non-scalar values: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-comment"><span class="hljs-comment">#&gt; '{b,c}' = '"d"'; ERROR: cannot call extract path from a scalar SELECT * FROM json_test WHERE data #&gt; '{b,c}' = '"d"' AND id &lt; 8; id | data ----+-------------------------------------- 4 | {"a": 1, "b": {"c": "d", "e": true}} (1 row)</span></span></code> </pre><br>  Pay attention to the syntax for key path, for strings (must be json keys) or integer (in array indices). <br>  This imposes very strict restrictions.  I do not know how such things work in MondgoDB. <br><br>  But in perspective, if you store data in arrays and json objects in one column, then there may be some problems in the future.  But all is not lost.  You can get strings based on basic objects: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> @&gt; <span class="hljs-string"><span class="hljs-string">'{}'</span></span>; id | data <span class="hljs-comment"><span class="hljs-comment">----+-------------------------------------- 1 | {} 2 | {"a": 1} 3 | {"a": 2, "b": ["c", "d"]} 4 | {"a": 1, "b": {"c": "d", "e": true}} 5 | {"b": 2} (5 rows)</span></span></code> </pre><br>  Then you can combine this query with the query above: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> @&gt; <span class="hljs-string"><span class="hljs-string">'{}'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> -&gt;&gt; <span class="hljs-string"><span class="hljs-string">'a'</span></span> &gt; <span class="hljs-string"><span class="hljs-string">'1'</span></span>; id | data <span class="hljs-comment"><span class="hljs-comment">----+--------------------------- 3 | {"a": 2, "b": ["c", "d"]} (1 row)</span></span></code> </pre><br>  Indeed, in Postgres, you don‚Äôt even need to be sure that data @&gt; '{} comes first. <br>  But what if we only need the array data types?  It turns out you can use the same trick: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> @&gt; <span class="hljs-string"><span class="hljs-string">'[]'</span></span>; id | data <span class="hljs-comment"><span class="hljs-comment">----+------------- 6 | [] 7 | [1, 2, "a"] (2 rows)</span></span></code> </pre><br>  And it can still be combined with other operators: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> json_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> @&gt; <span class="hljs-string"><span class="hljs-string">'[]'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> -&gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-string"><span class="hljs-string">'2'</span></span>; id | data <span class="hljs-comment"><span class="hljs-comment">----+------------- 7 | [1, 2, "a"] (1 row)</span></span></code> </pre><br>  Well, the @&gt; operator entry is only available for jsonb columns, so you cannot query mixed data for regular json columns. <br><br>  What's next? <br><br>  Considering jsonb in Postgres was a third-party project, now I'm working on json (b) queries in ORM django.  With Django 1.7 in the search functions you can write something like: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Exact MyModel.objects.filter(data={'a': 1}) MyModel.objects.exclude(data={}) # Key/element existence MyModel.objects.filter(data__has='a') MyModel.objects.filter(data__has_any=['a', 'b']) MyModel.objects.filter(data__has_all=['a', 'b']) # Sub/superset of key/value pair testing MyModel.objects.filter(data__contains={'a': 1}) MyModel.objects.filter(data__in={'a': 1, 'b': 2}) # Get element/field (compare with json) MyModel.objects.filter(data__get=(2, {'a': 1})) # Get element/field (compare with scalar, including gt/lt comparisons) MyModel.objects.filter(data__get=(2, 'a')) MyModel.objects.filter(data__get__gt=('a', 1)) # key path traversal, compare with json or scalar. MyModel.objects.filter(data__get=('{a,2}', {'foo': 'bar'})) MyModel.objects.filter(data__get=('{a,2}', 2)) MyModel.objects.filter(data__get__lte=('{a,2}', 2))</span></span></code> </pre><br>  But I'm not sure that the names from the last set will work.  The name ‚Äúget‚Äù seems a bit universal, and maybe we could use different names for the input type substitution, although only integer and string are valid. </div><p>Source: <a href="https://habr.com/ru/post/254425/">https://habr.com/ru/post/254425/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254413/index.html">Grid, Data Grouping and OData</a></li>
<li><a href="../254415/index.html">Become the master of loading Linux</a></li>
<li><a href="../254417/index.html">How to get a neighbor or Karaoke on GStreamer</a></li>
<li><a href="../254419/index.html">Assembler for simulation tasks. Part 1: guest assembler</a></li>
<li><a href="../254423/index.html">How to create and earn SaaS | Part 17 | Personal data and medical secrets in the cloud</a></li>
<li><a href="../254429/index.html">Driver packs and their indices</a></li>
<li><a href="../254431/index.html">Quite simple about minimal perfect graph-based hashing</a></li>
<li><a href="../254433/index.html">Polite invitation to develop</a></li>
<li><a href="../254435/index.html">Notes iOS programmer about his hammers, sledgehammers and micrometers</a></li>
<li><a href="../254437/index.html">Why does Kaspersky detect the HEUR: Trojan.Script.Generic Trojan on the site? (and possible remedy)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>