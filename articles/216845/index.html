<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Search for solutions for games with words. Boron application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 There are many games where the player needs to search for words from a specific set of letters. Here are the two most popular ones. 
 1...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Search for solutions for games with words. Boron application</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  There are many games where the player needs to search for words from a specific set of letters.  Here are the two most popular ones. <br>  1. 4 pics 1 words (4 Pics 1 Word) <a href="https://itunes.apple.com/ru/app/id598949838">AppStore</a> , <a href="https://play.google.com/store/apps/details%3Fid%3Dde.lotum.whatsinthefoto.ru">Google Play</a> <br>  This game has quite a few implementations, but the idea is the same for everyone. <br>  2. Slovomaniya (Wordsmania) <a href="https://itunes.apple.com/ru/app/id450116479">AppStore</a> , <a href="https://play.google.com/store/apps/details%3Fid%3Dtr.com.fugo.kelimeavi2.ru%26hl%3Dru">Google Play</a> <br><a name="habracut"></a><br><br>  The essence of the first game: 4 pictures are given, the length of the guessable word and a set of letters, you can choose the letters in any order. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee0/27c/0cc/ee027c0cc6020ac801a0fadd50ef63f7.jpg" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The essence of the second is that in the 4x4 field, filled with letters, it is necessary to find as many words as possible, from each cell you can move to the next one vertically, horizontally, and diagonals. <br><br><img src="http://habrastorage.org/files/802/a72/b90/802a72b903eb4a129160132801dfea9b.jpg" alt="image"><br><br>  I was interested in the idea of ‚Äã‚Äãsoftware problem solving, which put these games.  I do not set goals to make the game dishonest, it is rather a purely sporting interest in the task set to itself.  The peak of the popularity of these games has already passed, so it's not so scary if someone plays a little dishonestly. <br><br><h4>  Formulation of the problem </h4><br>  If we consider the problem more formally, it is necessary to implement a search of possible combinations, based on the rules of the game.  Two brute force algorithms will be implemented for each game.  Next, you need to check the presence of these combinations in the dictionary, for this you need to implement a structure that can effectively respond to the query about the presence of a word in the dictionary.  <a href="http://neerc.ifmo.ru/wiki/index.php%3Ftitle%3D%25D0%2591%25D0%25BE%25D1%2580">Bor</a> will be used. <br><br><h5>  Why bor </h5><br>  In the standard C ++ libraries, structures that can quickly respond to single requests are already implemented, these are map and unordered_map (hash map).  But the implementation of the problem with the help of these structures will be inferior in the asymptotic behavior of boron, since it will take into account the peculiarities of the task.  The enumeration of values ‚Äã‚Äãwill be a tree, because recursively from each letter will try to find the next one.  Bor is also a tree, so the search for words will take place in the worst case for the total length of all found words, plus the number of iterations, until the algorithm reaches a non-existent transition in the dictionary, in practice such a transition is achieved rather quickly.  More efficiently, the algorithm will work when there is an S string containing the string P belonging to the dictionary as a prefix, in which case the search will take place beyond the length of S, and all the other P will be added to the answer during the search S. <br><br>  Next, you need to display the resulting words in sorted form. <br><br><h4>  Implementation </h4><br>  Consider the implementation of the solution of the problem in parts. <br><br><h5>  Inclusions </h5><br>  It is necessary to provide console and file input-output, iostream, fstream.  We need standard STL templates: vector - to build boron, string and set - to store the results and cut off the same words found, the algorithm to sort. <br><br><div class="spoiler">  <b class="spoiler_title">Inclusions</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;algorithm&gt;</span></span></span></span></code> </pre> <br></div></div><br><br><h5>  ads </h5><br>  In order to use Russian characters, without including localization, so that such code could be easily adapted to other encodings, it was decided to use a simple string pattern for input and output.  This is a sample obtained by typing the ConsoleSample into the console of the Russian alphabet and a sample obtained by reading from the FstreamSample file. <br>  Next, there is a description of the structure for each vertex of boron, it will store transitions for each letter, or 0 if there is no transition, also using the isLeaf variable in the structure indicates that any word ends at this vertex. <br>  We declare containers for storing boron, a buffer for results and formatted output. <br><br><div class="spoiler">  <b class="spoiler_title">ads</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ALPHABET_SIZE 33 const char ConsoleSample[ALPHABET_SIZE] = { -96, -95, -94, -93, -92, -91, -15, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -20, -21, -22, -19, -18, -17 }; const char FstreamSample[ALPHABET_SIZE] = { -32, -31, -30, -29, -28, -27, -72, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -4, -5, -6, -3, -2, -1 }; typedef struct { unsigned child[ALPHABET_SIZE]; bool isLeaf; } node; node NullNode = {NULL}; vector</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;node&gt; Trie; set&lt;string&gt; Res; vector&lt;string&gt; Output;</span></span></span></span></code> </pre><br></div></div><br><br><h5>  Adding words to bor </h5><br>  The function receives a string at the input, traverses it, simultaneously advances along the forest, if there is no transition from the vertex, a new vertex is added to the boron, and a transition to the added vertex is written to the current vertex using an index.  After adding the last transition, the value of the isLeaf variable at the last vertex changes to true, here the word ends. <br><br><div class="spoiler">  <b class="spoiler_title">Adding words</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrieAddWord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;S)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i(S.begin()); i != S.end(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Trie[CurrentNode].child[*i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Trie.push_back(NullNode); Trie[CurrentNode].child[*i] = Trie.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>; CurrentNode = Trie.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CurrentNode = Trie[CurrentNode].child[*i]; } } Trie[CurrentNode].isLeaf = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br></div></div><br><br><h5>  Dictionary Download </h5><br>  For convenience, all words will have their characters shifted by the time they process the request, that is, the character 'a' will match the value 0, and the character 'I' will have a value of 32. The Encode function will do this using a trivial search for a character in the sample and replace it .  Such an implementation is simple, but it takes extra time to load the dictionary, but this is not so important, the dictionary is loaded one time, and then you can submit requests to the program many times. <br><br><div class="spoiler">  <b class="spoiler_title">String coding</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncodeString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;S, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sample[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i(S.begin()); i != S.end(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> j(<span class="hljs-number"><span class="hljs-number">0</span></span>); j != ALPHABET_SIZE; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*i == Sample[j]) { *i = j; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } }</code> </pre><br></div></div><br><br>  The dictionary loading function retrieves the file name and reads all the words from it, encoding the lines and then adds them to the bor.  The function can load several dictionaries at once if run for all files. <br><br><div class="spoiler">  <b class="spoiler_title">Dictionary Download</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadDictonary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Filename)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">ifstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Filename)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Buff; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!in.eof()) { in &gt;&gt; Buff; EncodeString(Buff, FstreamSample); TrieAddWord(Buff); } in.close(); }</code> </pre><br></div></div><br><br><h5>  Sort output </h5><br>  To get the longest words in the game Slovomaniya first of all, you need to sort the lines by length in the reverse order, since when outputting to the console, the text is scrolled upwards, so the longest words should be output at the end.  In the game, the bigger the word, the more points are obviously given for it.  To do this, write the simplest comparator function to transfer it to the sort from the algorithm. <br><br><div class="spoiler">  <b class="spoiler_title">Comparator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> B)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A.size() &gt;= B.size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br></div></div><br><br><h5>  The implementation of the solution for the game "guess the word" </h5><br>  Since there are a lot of implementations and names for this game, we‚Äôll just call it ‚Äúguess the word‚Äù. <br>  For starters, the bypass function is boron.  Here we use the usual recursive DFS algorithm, just from each letter, we move to any unused previously from the given string, at the same time, we check for such a transition in boron, if the transition exists, then continue further, if not, stop further progress on this thread.  It is important to note that in the game it is necessary to guess a word of a certain length, therefore we descend only to a depth equal to the length of the line, there is no sense to go further.  We do not forget to check the isLeaf variable at each iteration, if it is equal to true and the length of the found word is equal to the specified value, then we add the word to set Res. <br><br><div class="spoiler">  <b class="spoiler_title">Bypass</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GuessWordBypass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> N, __int8 X, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Used[], </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;S, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> W, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;L)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (W.size() &gt; L) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (__int8 i(<span class="hljs-number"><span class="hljs-number">0</span></span>); i != S.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == X) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Used[i]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Trie[N].child[S[i]] != <span class="hljs-number"><span class="hljs-number">0</span></span>) { Used[i] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; GuessWordBypass(Trie[N].child[S[i]], i, Used, S, W + S[i], L); Used[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Trie[N].isLeaf &amp;&amp; W.size() == L) { Res.insert(W); } } }</code> </pre><br></div></div><br><br>  And then the function that implements the initial launch of the tour from all the letters of the word. <br><br><div class="spoiler">  <b class="spoiler_title">Launch</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GuessWord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;S, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;L)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> *Used = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> [S.size()]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(Used, <span class="hljs-number"><span class="hljs-number">0</span></span>, S.size()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (__int8 i(<span class="hljs-number"><span class="hljs-number">0</span></span>); i != S.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Trie[<span class="hljs-number"><span class="hljs-number">0</span></span>].child[S[i]] != <span class="hljs-number"><span class="hljs-number">0</span></span>) { Used[i] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; GuessWordBypass(Trie[<span class="hljs-number"><span class="hljs-number">0</span></span>].child[S[i]], i, Used, S, S.substr(i, <span class="hljs-number"><span class="hljs-number">1</span></span>), L); Used[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] Used; }</code> </pre><br></div></div><br><br><h5>  Implementation of the solution for the game Slovomaniya </h5><br>  In general, the detour itself will not be anything different, but the differences will be that here it is possible to move only to neighboring cells, and not to any, also the search should find words of any length.  Since a 4x4 field is represented by a one-dimensional array, it is not obvious how to move to neighboring cells, consider how to implement it. <br>  If the cell is not on the field borders, then by adding numbers from -5 to 5, excluding from them -2, 0 and 2. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/80b/8c9/edb/80b8c9edb191218c0ad24a5734c34472.png" alt="image"><br><br>  If the cell is on the border, then it is also necessary to prohibit transitions to other cells that go abroad. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd5/227/43b/bd522743b6843fe28cd7439620c33829.png" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">Bypass</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WordsmaniaCheatBypass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> N, __int8 X, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Used[], </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;S, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> W)</span></span></span><span class="hljs-function"> </span></span>{ __int8 TransitDenied[<span class="hljs-number"><span class="hljs-number">11</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (__int8 i(<span class="hljs-number"><span class="hljs-number">-2</span></span>); i &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span>; i += <span class="hljs-number"><span class="hljs-number">2</span></span>) TransitDenied[i + <span class="hljs-number"><span class="hljs-number">5</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X % <span class="hljs-number"><span class="hljs-number">4</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (__int8 i(<span class="hljs-number"><span class="hljs-number">-5</span></span>); i &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>; i += <span class="hljs-number"><span class="hljs-number">4</span></span>) TransitDenied[i + <span class="hljs-number"><span class="hljs-number">5</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (__int8 i(<span class="hljs-number"><span class="hljs-number">-5</span></span>); i &lt;= <span class="hljs-number"><span class="hljs-number">-3</span></span>; ++i) TransitDenied[i + <span class="hljs-number"><span class="hljs-number">5</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X % <span class="hljs-number"><span class="hljs-number">4</span></span> == <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (__int8 i(<span class="hljs-number"><span class="hljs-number">-3</span></span>); i &lt;= <span class="hljs-number"><span class="hljs-number">5</span></span>; i += <span class="hljs-number"><span class="hljs-number">4</span></span>) TransitDenied[i + <span class="hljs-number"><span class="hljs-number">5</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X &gt;= <span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (__int8 i(<span class="hljs-number"><span class="hljs-number">3</span></span>); i &lt;= <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) TransitDenied[i + <span class="hljs-number"><span class="hljs-number">5</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (__int8 i(<span class="hljs-number"><span class="hljs-number">-5</span></span>); i &lt;= <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TransitDenied[i + <span class="hljs-number"><span class="hljs-number">5</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; __int8 tmp = X + i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Used[tmp]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Trie[N].child[S[tmp]] != <span class="hljs-number"><span class="hljs-number">0</span></span>) { Used[tmp] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; WordsmaniaCheatBypass(Trie[N].child[S[tmp]], tmp, Used, S, W + S[tmp]); Used[tmp] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Trie[N].isLeaf) { Res.insert(W); } } }</code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Launch</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WordsmaniaCheat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;S)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Used[<span class="hljs-number"><span class="hljs-number">16</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (__int8 i(<span class="hljs-number"><span class="hljs-number">0</span></span>); i != <span class="hljs-number"><span class="hljs-number">16</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Trie[<span class="hljs-number"><span class="hljs-number">0</span></span>].child[S[i]] != <span class="hljs-number"><span class="hljs-number">0</span></span>) { Used[i] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; WordsmaniaCheatBypass(Trie[<span class="hljs-number"><span class="hljs-number">0</span></span>].child[S[i]], i, Used, S, S.substr(i, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Used[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } }</code> </pre><br></div></div><br><br><h5>  Main function </h5><br>  In the main function, bor is initialized and the main loop is executed in which requests are processed.  '1' or '2' as the first argument, depending on which algorithm to use, then the parameters for the algorithm.  After processing, sorting and displaying results.  For the first algorithm, you must enter a sequence of characters and then the length of the word, for the second, only the sequence, it is written along the lines of the field, that is, for such a field, you must enter the string "set the string" (without quotes). <br><br><img src="http://habrastorage.org/files/802/a72/b90/802a72b903eb4a129160132801dfea9b.jpg" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">Main</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Trie.push_back(NullNode); LoadDictonary(<span class="hljs-string"><span class="hljs-string">"Dictonary.txt"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Word; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> mode; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; mode; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (mode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'1'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> L; <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; Word &gt;&gt; L; EncodeString(Word, ConsoleSample); GuessWord(Word, L); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'2'</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; Word; EncodeString(Word, ConsoleSample); WordsmaniaCheat(Word); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"=================="</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i(Res.begin()); i != Res.end(); ++i) { Output.push_back(*i); } Res.clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mode == <span class="hljs-string"><span class="hljs-string">'2'</span></span>) sort(Output.begin(), Output.end(), cmp); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i(Output.begin()); i != Output.end(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> j((*i).begin()); j != (*i).end(); ++j) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; ConsoleSample[*j]; } <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"=================="</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; Output.clear(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br></div></div><br><br><h4>  What's next </h4><br>  Here is the full <a href="http://pastebin.com/FGihNErX">code</a> , it is tested under Windows, for other platforms, you may have to replace input and output samples. <br>  But the <a href="https://yadi.sk/i/HZoczhTzfTruR">dictionary is small</a> and <a href="http://yadi.sk/d/FilwsIUuL8jF4">large dictionary</a> (do not forget to remove the number 2 at the end of the name if you will use a large dictionary).  The large dictionary contains not only the initial forms, it is suitable for the game Wordament from Microsoft, but there is not always on the field is one letter in a cell.  In most cases, a small dictionary is enough for the two games described to be at the top of the standings. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/83f/4ea/c8e/83f4eac8eedc52643433ecabaaf80f93.png" alt="image"><br><br>  I hope no one will play a lot this way, yet most of the players continue to play fair. </div><p>Source: <a href="https://habr.com/ru/post/216845/">https://habr.com/ru/post/216845/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../216831/index.html">VK Friendly Link Analysis with Wolfram Mathematica</a></li>
<li><a href="../216833/index.html">Where "soap" in WPF comes from and how to deal with it</a></li>
<li><a href="../216837/index.html">Devise: login and registration in modal windows</a></li>
<li><a href="../216839/index.html">The colors and the difference between them in LESS / Sass</a></li>
<li><a href="../216843/index.html">We start to study Cortex-M on the example of STM32</a></li>
<li><a href="../216849/index.html">Setting up the development environment for OpenStack</a></li>
<li><a href="../216851/index.html">We control the machine via Bluetooth from a tablet or phone for Android</a></li>
<li><a href="../216853/index.html">Gateway between IRC and Google Hangouts</a></li>
<li><a href="../216857/index.html">Synchronization in Android applications. Part two</a></li>
<li><a href="../216865/index.html">Use a hash search, not an array search</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>