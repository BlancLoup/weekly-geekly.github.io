<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Julia. Web services</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue to consider Julia technology. And today we will talk about packages designed to build web services. It's no secret that the main niche of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Julia. Web services</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/ez/8k/mw/ez8kmwwtsavwdve31oj9__-kj6e.png"></p><br><p>  We continue to consider Julia technology.  And today we will talk about packages designed to build web services.  It's no secret that the main niche of the Julia language is high-performance computing.  Therefore, a rather logical step is the direct creation of web services capable of performing these calculations on demand.  Of course, web services are not the only way to communicate in a networked environment.  But, since they are the most widely used in distributed systems now, we will consider the creation of services serving HTTP requests. </p><br><p>  Note that due to Julia‚Äôs youth, there is a set of competing packages.  Therefore, we will try to figure out how and why to use them.  Along the way, let's compare the implementation of the same JSON web service with their help. </p><a name="habracut"></a><br><p>  Infrastructure Julia is actively developing in the last year or two.  And, in this case, it is not just a duty phrase, inscribed for a beautiful beginning of the text, but an emphasis on the fact that everything is changing rapidly, but what was relevant a couple of years ago is now outdated.  However, we will try to isolate stable packages and give recommendations on how to implement web services with their help.  For definiteness, we will create a web service that receives a POST request with JSON data of the following format: </p><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"something"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: <span class="hljs-string"><span class="hljs-string">"something"</span></span> }</code> </pre> <br><p>  We assume that the service we create is not RESTful.  Our main task is to look at how to describe routes and request handlers. </p><br><h2 id="paket-httpjl">  HTTP.jl package </h2><br><p>  This package is the main implementation of the HTTP protocol in Julia and gradually acquires new features.  In addition to implementing typical structures and functions for performing client HTTP requests, this package implements functions for creating HTTP servers.  At the same time, as it develops, the package received functions that make it quite comfortable for the programmer to register handlers and, thus, build typical services.  Also, in the latest versions, there is built-in support for the WebSocket protocol, the implementation of which was previously done as part of a separate package WebSocket.jl.  That is, HTTP.jl, currently, can satisfy most of the needs of the programmer.  Consider a couple of examples in more detail. </p><br><h3 id="klient-http">  HTTP client </h3><br><p>  We start the implementation with the client code, which we will use to test the performance. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. import HTTP import JSON.json const PORT = "8080" const HOST = "127.0.0.1" const NAME = "Jemand" #    struct Document title::String body::String end #         Base.show(r::HTTP.Messages.Response) = println(r.status == 200 ? String(r.body) : "Error: " * r.status) #    r = HTTP.get("http://$(HOST):$(PORT)") show(r) #   /user/:name r = HTTP.get("http://$(HOST):$(PORT)/user/$(NAME)"; verbose=1) show(r) #  JSON- POST- doc = Document("Some document", "Test document with some content.") r = HTTP.post( "http://$(HOST):$(PORT)/resource/process", [("Content-Type" =&gt; "application/json")], json(doc); verbose=3) show(r)</span></span></code> </pre> <br><p>  The HTTP package provides methods that correspond to the names of the HTTP protocol commands.  In this case, use <code>get</code> and <code>post</code> .  The optional named argument <code>verbose</code> allows you to set the amount of debugging output.  So, for example, <code>verbose=1</code> returns: </p><br><pre> <code class="plaintext hljs">GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1)</code> </pre> <br><p>  And in the case of <code>verbose=3</code> we already get the full set of transmitted and received data: </p><br><pre> <code class="plaintext hljs">DEBUG: 2019-04-21T22:40:40.961 eb4f Ô∏è-&gt; "POST /resource/process HTTP/1.1\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 eb4f Ô∏è-&gt; "Content-Type: application/json\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 eb4f Ô∏è-&gt; "Host: 127.0.0.1\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 eb4f Ô∏è-&gt; "Content-Length: 67\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 eb4f Ô∏è-&gt; "\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 e1c6 Ô∏è-&gt; "{\"title\":\"Some document\",\"body\":\"Test document with some content.\"}" (unsafe_write) DEBUG: 2019-04-21T22:40:40.963 eb4f Ô∏è&lt;- "HTTP/1.1 200 OK\r\n" (readuntil) DEBUG: "Content-Type: application/json\r\n" DEBUG: "Transfer-Encoding: chunked\r\n" DEBUG: "\r\n" DEBUG: 2019-04-21T22:40:40.963 eb4f Ô∏è&lt;- "5d\r\n" (readuntil) DEBUG: 2019-04-21T22:40:40.963 eb4f Ô∏è&lt;- "{\"body\":\"Test document with some content.\",\"server_mark\":\"confirmed\",\"title\":\"Some document\"}" (unsafe_read) DEBUG: 2019-04-21T22:40:40.968 eb4f Ô∏è&lt;- "\r\n" (readuntil) DEBUG: "0\r\n" DEBUG: 2019-04-21T22:40:40.968 eb4f Ô∏è&lt;- "\r\n" (readuntil)</code> </pre> <br><p>  In the future, we will use only <code>verbose=1</code> in order to see only minimal information about what is happening. </p><br><p>  A few comments on the code. </p><br><pre> <code class="julia hljs">doc = Document(<span class="hljs-string"><span class="hljs-string">"Some document"</span></span>, <span class="hljs-string"><span class="hljs-string">"Test document with some content."</span></span>)</code> </pre> <br><p>  Since we previously declared the Document structure (and, immutable), a constructor is available for it by default, whose arguments correspond to the declared fields of the structure.  In order to convert it to JSON, we use the <code>JSON.jl</code> package and its <code>json(doc)</code> method. <br>  Pay attention to the fragment: </p><br><pre> <code class="julia hljs">r = HTTP.post( <span class="hljs-string"><span class="hljs-string">"http://</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(HOST)</span></span></span><span class="hljs-string">:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(PORT)</span></span></span><span class="hljs-string">/resource/process"</span></span>, [(<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>)], json(doc); verbose=<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><p>  Since we are transmitting JSON, you must explicitly specify the type <code>application/json</code> in the <code>Content-Type</code> header.  Headers are transferred to the <code>HTTP.post</code> method (as well as to all others) using an array (of the Vector type, but not Dict) containing the name of the title-value pairs. </p><br><p>  For the performance test, we will perform three queries: </p><br><ul><li>  GET request to root path; </li><li>  GET request in the format / user / name, where name is the transmitted name; </li><li>  POST request / resource / process with transfer of JSON object.  We expect to receive the same document, but with the added <code>server_mark</code> field. </li></ul><br><p>  We will use this client code to test all server implementation options. </p><br><h3 id="server-http">  HTTP server </h3><br><p>  After you have dealt with the client, it's time to start implementing the server.  To begin with, we will make the service only with the help of <code>HTTP.jl</code> , in order to keep it as a basic variant, which does not require installation of other packages.  We remind you that all other packages use <code>HTTP.jl</code> </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. import Sockets import HTTP import JSON #    #    index(req::HTTP.Request) = HTTP.Response(200, "Hello World") #     function welcome_user(req::HTTP.Request) # dump(req) user = "" if (m = match( r".*/user/([[:alpha:]]+)", req.target)) != nothing user = m[1] end return HTTP.Response(200, "Hello " * user) end #  JSON function process_resource(req::HTTP.Request) # dump(req) message = JSON.parse(String(req.body)) @info message message["server_mark"] = "confirmed" return HTTP.Response(200, JSON.json(message)) end #      const ROUTER = HTTP.Router() HTTP.@register(ROUTER, "GET", "/", index) HTTP.@register(ROUTER, "GET", "/user/*", welcome_user) HTTP.@register(ROUTER, "POST", "/resource/process", process_resource) HTTP.serve(ROUTER, Sockets.localhost, 8080)</span></span></code> </pre> <br><p>  In the example, pay attention to the following code: </p><br><pre> <code class="julia hljs">dump(req)</code> </pre> <br><p>  print to the console all that is known for the object.  Includes data types, values, and all nested fields and their values.  This method is useful for both library research and debugging. </p><br><p>  Line </p><br><pre> <code class="julia hljs">(m = match( <span class="hljs-string"><span class="hljs-string">r".*/user/([[:alpha:]]+)"</span></span>, req.target))</code> </pre> <br><p>  is a regular expression that parses the route to which the handler is registered.  <code>HTTP.jl</code> does not provide automatic ways to detect patterns in the route. </p><br><p>  Inside the <code>process_resource</code> handler, we are parsing JSON, which is accepted by the service. </p><br><pre> <code class="julia hljs">message = JSON.parse(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(req.body))</code> </pre> <br><p>  Data access is performed via the <code>req.body</code> field.  Note that the data comes in a byte array format.  Therefore, to work with them as with a string, an explicit conversion to a string is performed.  The <code>JSON.parse</code> method is a <code>JSON.jl</code> package method that performs <code>JSON.jl</code> data and builds an object.  Since the object in this case is an associative array (Dict), we can easily add a new key to it.  Line </p><br><pre> <code class="julia hljs">message[<span class="hljs-string"><span class="hljs-string">"server_mark"</span></span>] = <span class="hljs-string"><span class="hljs-string">"confirmed"</span></span></code> </pre> <br><p>  adds the <code>server_mark</code> key with the <code>confirmed</code> value. </p><br><p>  The service <code>HTTP.serve(ROUTER, Sockets.localhost, 8080)</code> when the <code>HTTP.serve(ROUTER, Sockets.localhost, 8080)</code> line is <code>HTTP.serve(ROUTER, Sockets.localhost, 8080)</code> . </p><br><p>  Control response for the HTTP.jl-based service (obtained when launching client code with <code>verbose=1</code> ): </p><br><pre> <code class="plaintext hljs">GET / HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET / HTTP/1.1) Hello World GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1) Hello Jemand POST /resource/process HTTP/1.1 HTTP/1.1 200 OK &lt;= (POST /resource/process HTTP/1.1) {"body":"Test document with some content.","server_mark":"confirmed","title":"Some document"}</code> </pre> <br><p>  Against the background of debug information with <code>verbose=1</code> , the lines are clearly visible: <code>Hello World</code> , <code>Hello Jemand</code> , <code>"server_mark":"confirmed"</code> . </p><br><p>  After viewing the service code, a natural question arises - why do we need all the other packages, if everything is so simple in HTTP.  There is a very simple answer to this.  HTTP - allows you to register dynamic handlers, but even the elementary implementation of reading a static image file from a directory requires a separate implementation.  Therefore, we also consider packages that are focused on creating web applications. </p><br><h2 id="paket-muxjl">  Mux.jl package </h2><br><p>  This package is positioned as an intermediate layer for web applications implemented on Julia.  Its implementation is very lightweight.  The main purpose is to provide an easy way to describe handlers.  It cannot be said that the project is not developing, but it is developing slowly.  However, look at the code of our service, serving the same routes. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. using Mux using JSON @app test = ( Mux.defaults, page(respond("&lt;h1&gt;Hello World!&lt;/h1&gt;")), page("/user/:user", req -&gt; "&lt;h1&gt;Hello, $(req[:params][:user])!&lt;/h1&gt;"), route("/resource/process", req -&gt; begin message = JSON.parse(String(req[:data])) @info message message["server_mark"] = "confirmed" return Dict( :body =&gt; JSON.json(message), :headers =&gt; [("Content-Type" =&gt; "application/json")] ) end), Mux.notfound() ) serve(test, 8080) Base.JLOptions().isinteractive == 0 &amp;&amp; wait()</span></span></code> </pre> <br><p>  Routes are described here using the <code>page</code> method.  The web application is declared using the <code>@app</code> macro.  The arguments to the <code>page</code> method are the route and handler.  A handler can be defined as a function that accepts a request as an input, or it can be specified as a lambda function in place.  Of the additional useful functions, there is <code>Mux.notfound()</code> for sending the specified <code>Not found</code> response.  And the result that should be sent to the client does not need to be packaged in <code>HTTP.Response</code> , as we did in the previous example, since Mux will do it by itself.  However, parsing JSON still has to be done by yourself, as is the serialization of the object for the response - <code>JSON.json(message)</code> . </p><br><pre> <code class="julia hljs"> message = JSON.parse(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(req[:data])) message[<span class="hljs-string"><span class="hljs-string">"server_mark"</span></span>] = <span class="hljs-string"><span class="hljs-string">"confirmed"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>( :body =&gt; JSON.json(message), :headers =&gt; [(<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>)] )</code> </pre> <br><p>  The answer is sent as an associative array with fields <code>:body</code> <code>:headers</code> . </p><br><p>  Starting the server using the <code>serve(test, 8080)</code> method is asynchronous, so one of the options in Julia to organize waiting for completion is to call the code: </p><br><pre> <code class="julia hljs">Base.JLOptions().isinteractive == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; wait()</code> </pre> <br><p>  Otherwise, the service does the same as the previous version on <code>HTTP.jl</code> </p><br><p>  Service control response: </p><br><pre> <code class="plaintext hljs">GET / HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET / HTTP/1.1) &lt;h1&gt;Hello World!&lt;/h1&gt; GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1) &lt;h1&gt;Hello, Jemand!&lt;/h1&gt; POST /resource/process HTTP/1.1 HTTP/1.1 200 OK &lt;= (POST /resource/process HTTP/1.1) {"body":"Test document with some content.","server_mark":"confirmed","title":"Some document"}</code> </pre> <br><h2 id="paket-bukdujl">  Bukdu.jl package </h2><br><p>  The package was developed under the influence of the Phoenix framework, which, in turn, is implemented on Elixir and is the implementation of the ideas of web-building from the Ruby-community in projection on Elixir.  The project is developing quite actively and is positioned as a tool for creating RESTful API and lightweight web applications.  There are functions that simplify JSON serialization and deserialization.  This is missing from <code>HTTP.jl</code> and <code>Mux.jl</code>  Let's look at the implementation of our web service. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. using Bukdu using JSON #   struct WelcomeController &lt;: ApplicationController conn::Conn end #   index(c::WelcomeController) = render(JSON, "Hello World") welcome_user(c::WelcomeController) = render(JSON, "Hello " * c.params.user) function process_resource(c::WelcomeController) message = JSON.parse(String(c.conn.request.body)) @info message message["server_mark"] = "confirmed" render(JSON, message) end #   routes() do get("/", WelcomeController, index) get("/user/:user", WelcomeController, welcome_user, :user =&gt; String) post("/resource/process", WelcomeController, process_resource) end #   Bukdu.start(8080) Base.JLOptions().isinteractive == 0 &amp;&amp; wait()</span></span></code> </pre> <br><p>  The first thing you should pay attention to is the declaration of the structure for storing the state of the controller. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WelcomeController &lt;: ApplicationController conn::Conn <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  In this case, it is a concrete type created as a descendant of the abstract type <code>ApplicationController</code> . </p><br><p>  Methods for the controller are declared in a similar way with respect to previous implementations.  There is a slight difference in the handler of our JSON object. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> process_resource(c::WelcomeController) message = JSON.parse(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(c.conn.request.body)) <span class="hljs-meta"><span class="hljs-meta">@info</span></span> message message[<span class="hljs-string"><span class="hljs-string">"server_mark"</span></span>] = <span class="hljs-string"><span class="hljs-string">"confirmed"</span></span> render(JSON, message) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  As you can see, deserialization is also performed independently using the <code>JSON.parse</code> method, but to serialize the response, the <code>render(JSON, message)</code> method <code>render(JSON, message)</code> provided by Bukdu is used. </p><br><p>  The declaration of the routes is carried out in the traditional style for rubists, including the use of the <code>do...end</code> block. </p><br><pre> <code class="julia hljs">routes() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, WelcomeController, index) get(<span class="hljs-string"><span class="hljs-string">"/user/:user"</span></span>, WelcomeController, welcome_user, :user =&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) post(<span class="hljs-string"><span class="hljs-string">"/resource/process"</span></span>, WelcomeController, process_resource) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Also, in the traditional way for rubists, a segment is declared in the route string <code>/user/:user</code> .  In other words, the variable part of the expression, which can be accessed by the name specified in the template.  Syntactically designated as a representative of type <code>Symbol</code> .  By the way, for Julia, the <code>Symbol</code> type means, in essence, the same as for Ruby - it is an immutable string, represented in memory by a single instance. </p><br><p>  Accordingly, after we declared a route with a variable part, and also indicated the type of this variable part, we can refer to the already parsed data by the assigned name.  In the method that handles the request, we simply access the field through a dot in the form <code>c.params.user</code> . </p><br><pre> <code class="julia hljs">welcome_user(c::WelcomeController) = render(JSON, <span class="hljs-string"><span class="hljs-string">"Hello "</span></span> * c.params.user)</code> </pre> <br><p>  Service control response: </p><br><pre> <code class="plaintext hljs">GET / HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET / HTTP/1.1) "Hello World" GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1) "Hello Jemand" POST /resource/process HTTP/1.1 HTTP/1.1 200 OK &lt;= (POST /resource/process HTTP/1.1) {"body":"Test document with some content.","server_mark":"confirmed","title":"Some document"}</code> </pre> <br><p>  Conclusion of service in the console: </p><br><pre> <code class="plaintext hljs">&gt;./bukdu_json.jl INFO: Bukdu Listening on 127.0.0.1:8080 INFO: GET WelcomeController index 200 / INFO: GET WelcomeController welcome_user 200 /user/Jemand INFO: Dict{String,Any}("body"=&gt;"Test document with some content.","title"=&gt;"Some document") INFO: POST WelcomeController process_resource200 /resource/process</code> </pre> <br><h2 id="paket-geniejl">  Package Genie.jl </h2><br><p>  An ambitious project, positioned as MVC web framework.  In his approach, the Rails on Julia are quite clearly visible, including the directory structure created by the generator.  The project is developing, however, for unknown reasons, this package is not part of the Julia package repository.  That is, its installation is possible only from the git repository with the command: </p><br><pre> <code class="julia hljs">julia&gt;] <span class="hljs-comment"><span class="hljs-comment"># switch to pkg&gt; mode pkg&gt; add https://github.com/essenciary/Genie.jl</span></span></code> </pre> <br><p>  The code of our service in Genie is as follows (do not use generators): </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. #     import Genie import Genie.Router: route, @params, POST import Genie.Requests: jsonpayload, rawpayload import Genie.Renderer: json! #      route("/") do "Hello World!" end route("/user/:user") do "Hello " * @params(:user) end route("/resource/process", method = POST) do message = jsonpayload() # if message == nothing # dump(Genie.Requests.rawpayload()) # end message["server_mark"] = "confirmed" return message |&gt; json! end #   Genie.AppServer.startup(8080) Base.JLOptions().isinteractive == 0 &amp;&amp; wait()</span></span></code> </pre> <br><p>  Here you should pay attention to the format of the declaration. </p><br><pre> <code class="julia hljs">route(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  This code is very familiar to Ruby programmers.  Block <code>do...end</code> as a handler and route as an argument to the method.  Note that for Julia this code can be rewritten in the form: </p><br><pre> <code class="julia hljs">route(req -&gt; <span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span>, <span class="hljs-string"><span class="hljs-string">"/"</span></span>)</code> </pre> <br><p>  That is, the handler function is in the first place, the route is in the second.  But for our case, leave the Ruby-style. </p><br><p>  Genie automatically packs the execution result into an HTTP response.  In the minimal case, we only need to return the result of the correct type, for example, String.  Of the additional facilities, implemented an automatic check of the input format and its analysis.  For example, for JSON you just need to call the <code>jsonpayload()</code> method. </p><br><pre> <code class="julia hljs">route(<span class="hljs-string"><span class="hljs-string">"/resource/process"</span></span>, method = POST) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> message = jsonpayload() <span class="hljs-comment"><span class="hljs-comment"># if message == nothing # dump(Genie.Requests.rawpayload()) # end message["server_mark"] = "confirmed" return message |&gt; json! end</span></span></code> </pre> <br><p>  Notice the code snippet commented out here.  The <code>jsonpayload()</code> method returns <code>nothing</code> if, for some reason, the input format is not recognized as JSON.  Note that for this purpose, the header <code>[("Content-Type" =&gt; "application/json")]</code> added to our HTTP client, since otherwise Genie will not even begin to parse the data as JSON.  In case something incomprehensible has come, it is useful to look at <code>rawpayload()</code> for what it is.  However, since this is just a debug stage, you should not leave it in the code. </p><br><p>  Also, you should pay attention to the return result in the format <code>message |&gt; json!</code>  .  Method <code>json!(str)</code> here put the last in the pipeline.  It provides serialization of data in JSON format, and also ensures that Genie will add the correct <code>Content-Type</code> .  Also, note that the word <code>return</code> in most cases in the examples above is redundant.  Julia, like Ruby, for example, always returns the result of the last operation or the value of the last specified expression.  That is, the word <code>return</code> is optional. </p><br><p>  Genie's capabilities don't end there, but we don't need them to implement a web service. </p><br><p>  Service control response: </p><br><pre> <code class="plaintext hljs">GET / HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET / HTTP/1.1) Hello World! GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1) Hello Jemand POST /resource/process HTTP/1.1 HTTP/1.1 200 OK &lt;= (POST /resource/process HTTP/1.1) {"body":"Test document with some content.","server_mark":"confirmed","title":"Some document"}</code> </pre> <br><p>  Conclusion of service in the console: </p><br><pre> <code class="plaintext hljs">&gt;./genie_json.jl [ Info: Ready! 2019-04-24 17:18:51:DEBUG:Main: Web Server starting at http://127.0.0.1:8080 2019-04-24 17:18:51:DEBUG:Main: Web Server running at http://127.0.0.1:8080 2019-04-24 17:19:21:INFO:Main: / 200 2019-04-24 17:19:21:INFO:Main: /user/Jemand 200 2019-04-24 17:19:22:INFO:Main: /resource/process 200</code> </pre> <br><h2 id="paket-juliawebapijl">  JuliaWebAPI.jl package </h2><br><p>  This package was positioned as an intermediate layer for creating web applications at the time when HTTP.jl was just a library implementing the protocol.  The author of this package also implemented a server code generator based on the Swagger specification (OpenAPI and <a href="http://editor.swagger.io/">http://editor.swagger.io/</a> ) - see the project <a href="">https://github.com/JuliaComputing/Swagger.jl</a> , and this generator used JuliaWebAPI .jl.  However, the problem with JuliaWebAPI.jl is that the ability to process the request body (for example, JSON) sent to the server via a POST request is not implemented.  The author believed that the transfer of parameters in the key-value format is suitable for all occasions ... The future of this package is not clear.  All its functions are already implemented in many other packages, including HTTP.jl.  The Swagger.jl package also no longer uses it. </p><br><h2 id="websocketsjl">  WebSockets.jl </h2><br><p>  Early implementation of the WebSocket protocol.  The package has been used for a long time as the main implementation of this protocol, however, currently, its implementation is included in the HTTP.jl package.  The WebSockets.jl package itself uses HTTP.jl to establish a connection, but now you should not use it in new developments.  It should be considered as a package for compatibility. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  The following review demonstrates various ways to implement a web service on Julia.  The easiest and most universal way is to directly use the HTTP.jl package.  Also, the Bukdu.jl and Genie.jl packages are very useful.  At a minimum, their development should be monitored.  With regards to the Mux.jl package, its merits are now dissolving against the background of HTTP.jl.  Therefore, personal opinion is not to use it.  Genie.jl is a very promising framework.  However, before you start using it, you should at least understand why the author does not register it as an official package. </p><br><p>  Note that the JSON deserialization code in the examples was used without error handling.  In all cases, except Genie, it is necessary to handle parsing errors and inform the user about it.  An example of such a code for HTTP.jl: </p><br><pre> <code class="julia hljs"> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> message = <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> body = <span class="hljs-built_in"><span class="hljs-built_in">IOBuffer</span></span>(HTTP.payload(req)) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> message = JSON.parse(body) <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> err <span class="hljs-meta"><span class="hljs-meta">@error</span></span> err.msg <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HTTP.Response(<span class="hljs-number"><span class="hljs-number">400</span></span>, string(err.msg)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  In general, we can say that Julia already has enough tools for creating web services.  That is, "reinventing the wheel" for their writing is not necessary.  The next step is to assess how Julia can handle the current benchmarks, if someone is ready to take it.  However, for now let's stop on this review. </p><br><h2 id="ssylki">  Links </h2><br><ul><li>  <a href="">https://github.com/JuliaWeb/HTTP.jl</a> </li><li>  <a href="">https://github.com/JuliaWeb/Mux.jl</a> </li><li>  <a href="">https://github.com/wookay/Bukdu.jl</a> </li><li>  <a href="">https://github.com/essenciary/Genie.jl</a> </li><li>  <a href="">https://github.com/JuliaComputing/Swagger.jl</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/449338/">https://habr.com/ru/post/449338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449326/index.html">WebRTC and video surveillance: how we beat the delay in video from cameras</a></li>
<li><a href="../44933/index.html">Adobe Flash Player 10 on Android</a></li>
<li><a href="../449330/index.html">Coherent CFP WDM (100G / 200G) and their application in DWDM systems</a></li>
<li><a href="../449334/index.html">How technical translation turns into a mini-detective</a></li>
<li><a href="../449336/index.html">HIV - treatment methods from first drugs to today</a></li>
<li><a href="../449340/index.html">Random oracle based on digital signature in blockchain</a></li>
<li><a href="../449346/index.html">MODX Digest # 4 (April 8 - 22, 2019)</a></li>
<li><a href="../449348/index.html">Buildroot - part 2. Creating the configuration of your board; use external tree, rootfs-overlay, post-build scripts</a></li>
<li><a href="../44935/index.html">Weather Forecast: Self-Learning Interactive Service</a></li>
<li><a href="../449350/index.html">Keybase and real TOFU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>