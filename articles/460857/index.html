<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How Namecoin Blockchain Research Predicted RTM Cyber ‚Äã‚ÄãAttacks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Namecoin blockchain was created as an alternative to traditional DNS registrars, protected from censorship and forced domain seizure. In the past ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How Namecoin Blockchain Research Predicted RTM Cyber ‚Äã‚ÄãAttacks</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/yc/l5/bz/ycl5bz9rlakm74fw8zztbhesnbm.png"><br><br>  The Namecoin blockchain was created as an alternative to traditional DNS registrars, protected from censorship and forced domain seizure.  In the past few years, botnet operators such as Dimnie, Shifu, RTM, and Gandcrab have begun to use it to manage the addresses of C&amp;C servers. <br><br>  On the one hand, the decentralization and stability of the blockchain prevent researchers and providers from removing such domains or taking control of them.  On the other hand, the infrastructure based on the blockchain has an architectural feature: all changes in the network are publicly available and can be used to study and track the actions of attackers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This paper presents the approach used to map botnets in Namecoin and track them later to extract new IOCs.  Using the described approach, lists of assets (see the appendix) used by the botnets mentioned above were compiled. <br><a name="habracut"></a><br><h2>  Lyrical digression </h2><br>  Inventions that change the Internet often solve not only and not so much a technical problem as a social one.  It is such technologies and services that allow the community to take a look at some axioms that seemed unshakable, rethink them, recreate from scratch, leaving only an idea and dropping the load of legacy conventions and limitations accumulated over the years.  Blockchain and Bitcoin, Tor, Wikipedia - behind the success of each of them is a small group of enthusiasts with burning eyes, sincerely believing that they are making a better society. <br><br>  Alas, often after them others come - alien to the strange ideals of the pioneers of the Internet, but much more practical.  They find <i>an alternative</i> application for technology, which the creators did not think about (or did not want to think about).  Being on the border (and more often, to hide, openly abroad) of the permissible, this alternative application, often not without the help of the media, for the majority turns into an <i>implied default</i> , or even the <i>only one</i> . <br><br>  The equivalence of technology as an idea and the most discussed method of its use can lead to rejection by the society of the technology itself.  As a result of the criminalization of its use, an immature service can be reduced to the level of a marginal culture or completely destroyed.  So it happened a long time ago with <a href="https://en.wikipedia.org/wiki/A%2526M_Records,_Inc._v._Napster,_Inc.">Napster</a> , not so long ago - with <a href="https://torrentfreak.com/bittorrent-usage-doesnt-equal-piracy-cox-tells-court-151115/">BitTorrent</a> and Tor, right now this is happening with Bitcoin. <br><br>  This is not past the hero of this work - Namecoin.  Namecoin is a blockchain designed to store arbitrary key-value pairs, the most famous of which is a decentralized, censorship-resistant DNS name registration system - Dot-Bit. <br><br>  Our interest in Namecoin grew after the RTM botnet management group started using Dot-Bit to manage their C&amp;C servers.  At some point, we wondered - is it possible to detect new C &amp; C-servers immediately after they are registered in Dot-Bit?  And if there were no problems with the updates of well-known domains, the development of an approach that allows one to detect strong evidence of the connection of new domains with a person of interest suddenly turned out to be an exciting research task, the result of which was this work. <br><br>  In general, Namecoin research and the collection of indicators of compromise in Dot-Bit were carried out earlier.  The most detailed work can be considered <a href="https://data.hackinn.com/ppt/BlackHat-USA-2018/us-18-Perlow-Beating-the-Blockchain-by-Mapping-Out_Decentralized_Namecoin-and-Emercoin-Infrastructure-wp.pdf">an article by Kevin Perlow</a> .  He was the first to draw attention to the fundamental possibility of extracting data from Namecoin and described several heuristic techniques that allow an expert to find domains that are similar in characteristics to the well-known C&amp;C servers of a particular group. <br><br>  The approach presented in this study has several significant differences from the expert indexing and pivoting technique described by Kevin.  The heuristic rules we developed for determining domain owners are derived from the principles of the blockchain and the formation of transactions in it and, in addition to the general description, are presented in the form of strict logical formulations.  Together with a formal description of the workaround algorithm, this allows you to automate the search for IOC, which significantly increases the effectiveness of the investigation.  In addition, the developed algorithm helps not only to find other names that were once used by the study group, but also allows you to track the creation of new domains that are controlled by the same person. <br><br>  All work is divided into three chapters.  The first chapter describes the basics of Bitcoin, the code of which was used as a platform for creating Namecoin.  Many entities, relationships, and their implementations defined in Bitcoin have been inherited by Namecoin.  Their understanding is critical for further discussion. <br><br>  The second chapter is devoted directly to Namecoin and its main application - Dot-Bit. <br><br>  The third chapter describes the proposed approach for extracting data from Namecoin, and also gives a formal description of the blockchain bypass algorithm and heuristic rules used to establish relationships between domains. <br><br>  The appendices contain IOCs collected using the described method for some botnets, as well as a list of references and repositories that will help researchers who want to continue working on this topic. <br><br><h2>  Bitcoin 201 </h2><br>  Most of the information in this section is collected from the materials of the series of articles by Sergey <a href="https://habr.com/ru/users/pavlov_dog/" class="user_link">Pavlov_dog</a> Potekhin ‚Äú <a href="https://habr.com/ru/post/319860/">Bitcoin in a nutshell</a> ‚Äù.  For Russian-speaking readers, this source, in our opinion, is the most comprehensive and deepest publicly available, but it is surprisingly easy to read.  Researchers interested in the internal device of Bitcoin, we urge not to limit ourselves to the excerpts given in this section, but to familiarize themselves with the full text of the articles, available by reference in the application.  The rest of the information presented below will be enough to understand the description of the algorithm and heuristic rules for finding the relationship between addresses in Namecoin, given in the last chapter. <br><br>  Although it is customary to start the story about the blockchain with blocks and the cryptography that connects them, we will start with transactions. <br><br><h3>  Transaction </h3><br>  As you know, the closest analogue to Bitcoin is an account book in which all transactions with coins are recorded.  But, strangely enough, in Bitcoin there is no general table of the form <code>&lt;, &gt;</code> , just like there is no chief accountant who would edit this table. <br><br>  Instead, the same notorious blockchain is used, that is, all transactions are generally stored.  For simplicity, we can assume that these are messages of the form: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">address</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span><span class="hljs-tag">&gt;</span></span> sent <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">amount</span></span></span><span class="hljs-tag">&gt;</span></span> BTC to <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">address</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  So, if you go around the entire blockchain, you can calculate how many coins ‚Äúbelong‚Äù to a particular address. <br><br><h4>  Inputs and outputs </h4><br>  A real transaction on a Bitcoin network is a bit more complicated than the one described above.  This is a structure whose main components are inputs and outputs. <br><br>  Inputs are transactions to which you "refer".  Imagine that three transactions were sent to your address X once: <br><br><pre> <code class="json hljs">TXN_ID: <span class="hljs-number"><span class="hljs-number">123456</span></span>, VALUE: <span class="hljs-number"><span class="hljs-number">40</span></span> BTC TXN_ID: <span class="hljs-number"><span class="hljs-number">645379</span></span>, VALUE: <span class="hljs-number"><span class="hljs-number">10</span></span> BTC TXN_ID: <span class="hljs-number"><span class="hljs-number">888888</span></span>, VALUE: <span class="hljs-number"><span class="hljs-number">100</span></span> BTC</code> </pre> <br>  If you need to spend, for example, <code>45 BTC</code> , then you can refer to transaction <code>888888</code> or two transactions at once: <code>123456</code> and <code>645379</code> . <br><br>  Outputs - literally "outputs".  We can assume that these are ‚Äúaddresses‚Äù to which coins will be ‚Äúsent‚Äù as a result of the transaction.  There can also be several exits; each of them has its own amount. <br><br>  Outputs - literally "outputs".  We can assume that these are ‚Äúaddresses‚Äù to which coins will be ‚Äúsent‚Äù as a result of the transaction.  There can also be several exits; each of them has its own amount. <br><br>  In the picture below, a new transaction <code>C</code> , which refers to two outputs - <code>A</code> and <code>B</code>  As a result, the transaction receives <code>0.008 BTC</code> at the input, which are then divided into two outputs - <code>0.001 BTC</code> sent to the first address, and <code>0.006 BTC</code> to the second. <br><br><img src="https://habrastorage.org/webt/hc/jj/-v/hcjj-vgrvls-t0qv4alrdutq1mm.png" alt="image"><br><br>  The ability to specify multiple outputs at once is a very important feature, because <b>the transaction output can be used as an input only once and only in its entirety</b> .  If you have an incoming transaction at <code>10 BTC</code> , and you need to spend 8 of them, you simply create a transaction with one input and two outputs: <code>8 BTC</code> to the seller and <code>2 BTC</code> back to your address.  If you create a transaction in which the sum of the outputs is less than the sum of the inputs (as in the picture), then the difference is sent to the address of the miner who wrote your transaction in the block. <br><br><h2>  Fee </h2><br>  It is this difference between the sum of inputs and the sum of outputs that is called the ‚Äú <code>transaction fee</code> ‚Äù, <code>transaction fee</code> .  It is the second most important source of income for miners, and the time it takes for the transaction to be included in the blockchain depends on it.  This is due to the fact that each miner has a certain pool of unverified transactions that claim to be in the block, and, as a rule, the miner simply sorts them in descending order, thereby maximizing their profit.  Therefore, the higher the commission, the higher you will be in the queue and the faster your payment will go. <br><br>  The general view of the transaction is described in the <a href="https://en.bitcoin.it/wiki/Protocol_documentation">official specification of the protocol</a> , here one of the most common particular cases is given. <br><br><img src="https://habrastorage.org/webt/sy/s-/g1/sys-g1dafvutkmxwetsud1urhng.png"><br><br>  <code>previous output hash</code> - identifier (hash) of the transaction we are referring to.  <code>previous output index</code> - since we need to refer not to the transaction itself, but to one of its outputs, then in this parameter we indicate which particular output we are interested in.  Numbering starts from scratch.  <code>value</code> - the amount of satoshi ( <code>1/100000000</code> BTC) sent to the exit.  It is recorded in a little-endian form, i.e. <code>62 64 01 00 00 00 00 00</code> - it is <code>0x016462</code> or <code>0.00091234 BTC</code> . <br><br>  The <code>block lock time</code> and <code>sequence</code> parameters are rarely used in practice.  We are not interested in them, so we will omit the description of their purpose. <br><br>  But on the parameters with the word <code>script</code> in the title we dwell in more detail. <br><br><h4>  Script </h4><br>  The Bitcoin network has a mechanism based on cryptographic algorithms with a public key that allows you to create a system in which only the owner of the key can use the coins associated with the address obtained from this key.  We will figure out how this is implemented under the hood. <br><br>  To begin with, inside Bitcoin there is a simple stacked programming language called <code>Script</code> .  Here is the simplest Script program: <br><br><pre> <code class="xml hljs">2 3 OP_ADD 5 OP_EQUAL</code> </pre> <br>  Each instruction is called <code>opcode</code> , there are about 80 of them in total. The picture below shows the execution process of the above program. <br><br><img src="https://habrastorage.org/webt/du/p0/a9/dup0a971icbk3mhhz1k7vfsipg0.png"><br><br><img src="https://habrastorage.org/webt/pe/xz/6k/pexz6k4icaot60gal2hc7y_iijk.png"><br><br><img src="https://habrastorage.org/webt/ie/nr/sg/ienrsgzd8tb5ncdwaxvvpzzdfku.png"><br><br><img src="https://habrastorage.org/webt/n8/zy/ve/n8zyvevbelp1wm7za8aksy-kcpi.png"><br><br><img src="https://habrastorage.org/webt/gx/aw/v_/gxawv_arrvb86zydou0zm22qhi0.png"><br><br>  Bitcoin <code>Script</code> is used to set the condition under which it will be possible to spend the output, and to be able to confirm that the condition is met.  The condition ( <code>locking script</code> ) is stored in the transaction in the <code>scriptPubKey</code> field for each exit.  Confirmation that the condition is met ( <code>unlocking script</code> ) is written in the <code>scriptSig</code> field for each input. <br><br>  To check the right to use the output, you need to connect the <code>unlocking script</code> + <code>locking script</code> and run the resulting program as a whole.  If after execution, <code>TRUE</code> remains on top of the stack, then the transaction is valid. <br><br><a name="P2PKH"></a><br><h4>  Pay to Public Key Hash (P2PKH) </h4><br>  The <code>P2PKH</code> script <code>P2PKH</code> used in most transactions, so you should figure out how it works.  Here is its general view: <br><br><img src="https://habrastorage.org/webt/yc/l5/bz/ycl5bz9rlakm74fw8zztbhesnbm.png"><br><br>  This script has been known since the advent of Bitcoin, and it is he who performs the task that was mentioned at the beginning of the chapter - to make sure that only the owner of the key can use the coins associated with the address obtained from this key. <br><br>  The idea is this: let your friend <code>B</code> own a pair of keys - <code>P</code> (private) and <code>K</code> (public).  Using the hash function, he gets the address <code>A</code> from the public key and tells the address to you.  Then you send, for example, <code>1 BTC</code> to address <code>A</code> and write the following in the <code>locking script</code> field: <br><br><blockquote>  Only someone who owns the private key for address <code>A</code> can spend this transaction.  As proof, write in the <code>unlocking script</code> , firstly, the public key <code>K</code> , and secondly, the signature of the transaction with the private key <code>P</code> <br></blockquote><br>  When <code>B</code> decides to use your transaction as an input, he will create his, for example, <code>0.5 BTC</code> , and in the <code>unlocking script</code> field <code>unlocking script</code> put the signature of his transaction with the private key <code>P</code> - <code>sig</code> and the public key K - <code>PubK</code> . <br><br>  Here is the execution process of the combined program: <br><br><img src="https://habrastorage.org/webt/et/zx/tw/etzxtwxr3qihzwza6e43rrymdcs.png"><br><br><img src="https://habrastorage.org/webt/yj/bs/1n/yjbs1nuol2e6ut1rp_p9iifi9z4.png"><br><br><img src="https://habrastorage.org/webt/ia/eo/kb/iaeokbdrdznakoutfhiuu2m53xu.png"><br><br><img src="https://habrastorage.org/webt/ix/zh/v2/ixzhv2l0_qhjxgn55tjung8tyng.png"><br><br><img src="https://habrastorage.org/webt/3f/ah/zf/3fahzfikukod-rbz-29tufqlry8.png"><br><br><img src="https://habrastorage.org/webt/71/gf/2h/71gf2hcsfwo7eqtvmmmmdebz0pw.png"><br><br><img src="https://habrastorage.org/webt/yk/f_/b7/ykf_b7fyo6hplbhax7wolaukqrk.png"><br><br><h2>  Blocks and blockchain </h2><br>  If the entire blockchain is a book, then individual blocks can be represented as pages on which transactions are recorded.  Each block "refers" to the previous one, and so on until the very first block ( <code>genesis block</code> ).  This is what creates such a feature of the blockchain as immutability.  You can‚Äôt take and change block <code>#123</code> so that no one will notice: the blockchain is designed in such a way that it will entail a change in block <code>#124</code> , then <code>#125</code> and so on, to the very top. <br><br>  The block structure looks like this: <br><br><img src="https://habrastorage.org/webt/bs/kp/3d/bskp3dzxovwwy4zx-s-pxzromgu.png"><br><br>  The first six parameters (all except <code>txn_count</code> and <code>txns</code> ) form the header of the block.  The header hash is called the block hash;  Transactions themselves do not directly participate in hashing.  <code>merkle_root</code> is responsible for their immutability - if simplified, then this is a hash of all transactions in the block.  You can read more about the algorithm for constructing the Merkle tree here at this <a href="https://habr.com/ru/post/320176/">link</a> . <br><br>  Nonce and bits are directly related to the process of block appearance - mining. <br><br><h3>  Mining </h3><br>  Mining is a critical process for Bitcoin, consisting in creating new blocks and pursuing two goals at once.  The first is money supply production.  Each time a miner creates a new block, he is rewarded for this with the Nth number of coins that he then spends somewhere, thereby launching new funds into the network. <br><br>  The second, and much more important, goal is to control compliance with the rules on the network.  It is the miners who check the scripts and transaction inputs before including them in the block. <br><br>  Those who wish to learn more about the financial foundations of Bitcoin can advise <a href="https://habr.com/ru/post/320178/">this article</a> .  I will not pay much attention to the first aspect of mining and concentrate on the second - checking transactions and launching them on the network. <br><br><h3>  Proof-of-work </h3><br>  Let you be a miner.  You have 10 transactions that you want to include in the block.  You check these transactions for validity, form a block out of them, specify 0 in the <code>nonce</code> field and consider the block hash.  Then change <code>nonce</code> to 1, count the hash again. <br><br>  Your task is to find a <code>nonce</code> such that the block hash (256-bit number) is less than a predetermined number <code>N</code>  The search for such a hash is possible only through brute force <code>nonce</code> .  Therefore, the faster you want to find nonce, the more power you will need. <br><br>  The number <code>N</code> is exactly that parameter (it is also called <code>target</code> ), which the network adjusts depending on the total power of the miners.  If tomorrow blocks start to come out, relatively speaking, every three minutes, then <code>N</code> will be reduced, more time will be required to search for nonce and <code>block time</code> will again increase to 10 minutes.  And vice versa. <br><br>  This is how the Proof-of-Work algorithm underlying Bitcoin and many other blockchains looks like.  With apparent simplicity, it has a number of important characteristics: <br><br><ul><li>  Creating a new block is a computationally difficult task.  At the same time, checking the block for correctness is a simple and almost instantaneous operation. </li><li>  The entire network takes 10 minutes to calculate a new block (on average).  The specific time is different for each blockchain, but the bottom line is that the average time is pre-set.  Moreover, this time does not depend on the number of network participants.  Even if one day there will be a hundred times more miners, the algorithm will change its parameters so that it becomes more difficult to find the <code>block time</code> , and <code>block time</code> drops back to the vicinity of the specified time. <br><br>  As described above, the mining process comes down to finding a block hash less than a number called <code>target</code> .  In the block structure, this number is written in the bits field.  For example, for block <code>#277316 target</code> was <code>1903a30c</code> . </li></ul><br>  As described above, the mining process comes down to finding a block hash less than a number called <code>target</code> .  In the block structure, this number is written in the <code>bits</code> field.  For example, for block <code>#277316</code> <code>target</code> was <code>1903a30c</code> . <br><br><pre> <code class="json hljs">$ bitcoin-cli getblock <span class="hljs-number"><span class="hljs-number">0000000000000001</span></span>b<span class="hljs-number"><span class="hljs-number">6</span></span>b<span class="hljs-number"><span class="hljs-number">9</span></span>a<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">3</span></span>b<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">5</span></span>e<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">6</span></span>db<span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-number"><span class="hljs-number">1</span></span>c<span class="hljs-number"><span class="hljs-number">4</span></span>a<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">8</span></span>b<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">7</span></span>ef<span class="hljs-number"><span class="hljs-number">2</span></span>d<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-number"><span class="hljs-number">4</span></span>a<span class="hljs-number"><span class="hljs-number">9</span></span>b<span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-number"><span class="hljs-number">1</span></span>b<span class="hljs-number"><span class="hljs-number">2</span></span>cc<span class="hljs-number"><span class="hljs-number">7</span></span>bdc<span class="hljs-number"><span class="hljs-number">4</span></span> { <span class="hljs-attr"><span class="hljs-attr">"hash"</span></span> : <span class="hljs-string"><span class="hljs-string">"0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"confirmations"</span></span> : <span class="hljs-number"><span class="hljs-number">35561</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span> : <span class="hljs-number"><span class="hljs-number">218629</span></span>, <span class="hljs-attr"><span class="hljs-attr">"height"</span></span> : <span class="hljs-number"><span class="hljs-number">277316</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"merkleroot"</span></span> : <span class="hljs-string"><span class="hljs-string">"c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tx"</span></span> : [<span class="hljs-string"><span class="hljs-string">"d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f"</span></span>, ...], <span class="hljs-attr"><span class="hljs-attr">"time"</span></span> : <span class="hljs-number"><span class="hljs-number">1388185914</span></span>, <span class="hljs-attr"><span class="hljs-attr">"nonce"</span></span> : <span class="hljs-number"><span class="hljs-number">924591752</span></span>, <span class="hljs-attr"><span class="hljs-attr">"bits"</span></span> : <span class="hljs-string"><span class="hljs-string">"1903a30c"</span></span>, // &lt;--   <span class="hljs-attr"><span class="hljs-attr">"difficulty"</span></span> : <span class="hljs-number"><span class="hljs-number">1180923195.25802612</span></span>, <span class="hljs-attr"><span class="hljs-attr">"chainwork"</span></span> : <span class="hljs-string"><span class="hljs-string">"000000000000000000000000000000000000000000000934695e92aaf53afa1a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"previousblockhash"</span></span> : <span class="hljs-string"><span class="hljs-string">"0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"nextblockhash"</span></span> : <span class="hljs-string"><span class="hljs-string">"000000000000000010236c269dd6ed714dd5db39d36b33959079d78dfd431ba7"</span></span> }</code> </pre> <br>  In <code>bits</code> in fact, two numbers are written at once: the first byte <code>0x19</code> is the exponent, the remaining three bytes <code>0x03a30c</code> are the mantissa.  To get the <code>target</code> from <code>bits</code> , you need to use the following formula: <br><br><pre> <code class="python hljs">target = mantissa * <span class="hljs-number"><span class="hljs-number">2</span></span>^(<span class="hljs-number"><span class="hljs-number">8</span></span> * (exponent - <span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre> <br>  But it is <code>bits</code> , as a rule, that are indicated in all online block registries, such as, for example, <a href="https://namecha.in/">https://namecha.in/</a> - Namecoin block registry. <br><br>  And yes, enough theory.  Everything that we talked about above when applied to Bitcoin equally applies to Namecoin - except for the small differences, which we will talk about in the next section. <br><br><h2>  Namecoin </h2><br>  <i>Namecoin</i> is a blockchain based on the algorithms and source code of Bitcoin, the main idea of ‚Äã‚Äãwhich is to use a distributed transaction registry scheme to manage a domain name system, an analog of traditional DNS. <br><br>  Namecoin copies the basic Bitcoin approaches (Proof-of-Work, 10-minute block generation interval) and data formats, with the exception of small additions, which we will talk about later. <br><br>  Namecoin domains have the suffix .bit.  This zone was not allocated by IANA and was not assigned to the list of <a href="https://www.iana.org/assignments/special-use-domain-names/special-use-domain-names.xhtml">special purpose domains</a> .  Regular DNS servers typically respond to such NXDOMAIN requests.  But there are gateways from DNS to Namecoin (for example, <a href="https://www.opennic.org/">OpenNIC</a> ), public proxies with Namecoin support, browser <a href="https://peername.com/browser-extension/">plugins</a> , and <a href="https://github.com/namecoin/ncdns">an open source project</a> that allows you to start your own DNS server with Namecoin support. <br><br>  In order to manage a domain with the name, say, <code>facebook.bit</code> , it is enough to register the <code>d/facebook</code> key <code>d/facebook</code> prefix is ‚Äã‚Äãused in Namecoin for domains) and determine its value.  The JSON format is used to set the values.  The record setting the domain resolution to IP address <code>1.2.3.4</code> looks like this: <br><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"ip"</span></span>: [<span class="hljs-string"><span class="hljs-string">"1.2.3.4"</span></span>]}</code> </pre> <br>  Namecoin allocates names on a <i>first-come-first-served</i> basis.  Even for Mark Zuckerberg himself, it will be cryptographically impossible to take the <code>facebook.bit</code> domain from the owner. <br><br>  In fact, nothing restricts the use of Namecoin to just managing the DNS name bundles - IP address.  Namecoin can be used (and used) as a distributed table to map arbitrary keys to values.  But we will concentrate precisely on the scenario of its use in which it represents an alternative DNS over blockchain. <br><br><h2>  Domain management </h2><br>  Namecoin uses a transaction to store a domain record.  Namely, the <code>scriptPubKey</code> field containing the program is the condition for using the transaction output, which we devoted so much time to in the previous chapter.  To manage records, Namecoin introduced three new operators (more precisely, redefined existing ones): <br><br><ul><li>  NAME_NEW </li><li>  NAME_FIRSTUPDATE </li><li>  NAME_UPDATE </li></ul><br>  Their meaning is clear from the names, but nevertheless we will analyze the purpose and format of use of each of them. <br><br>  You may notice that the domain deletion or invalidation operator is missing.  To clean the registry of unused names, a mechanism is built into the network that automatically releases a name that has not been updated for 36,000 blocks (~ 250 days). <br><br><h3>  NAME_NEW </h3><br>  The first step is to announce the intention to register a new name on the network.  To do this, just create a special coin (output) weighing at least <code>0.01 NMC</code> , the <code>output script</code> which will look something like this: <br><br><pre> <code class="xml hljs">OP_NAMENEW <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">20</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">byte</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">hash</span></span></span><span class="hljs-tag">&gt;</span></span> OP_2DROP <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  To demonstrate, I will use the transactions that Stephen Morse made to <a href="https://stephentechblog.wordpress.com/2015/05/13/the-bits-and-bytes-of-namecoin/">illustrate his article</a> . <br><br>  So, if we want to announce the registration of the name <code>d/stephenmorse</code> , then we need to do the following: <br><br><img src="https://habrastorage.org/webt/q9/br/b8/q9brb8jrft9fyzc1vc2ph0ssade.png"><br><br>  Looking at the resulting transaction, you can notice two interesting facts.  Firstly, despite the fact that the <code>output script</code> written in Namecoin notation, it is still valid from the point of view of the original Bitcoin.  The creators of Namecoin have so successfully chosen codes for their operations that in Bitcoin they correspond to operations that are essentially equivalent to writing to a stack of constants.  <code>NAME_NEW (0x51)</code> code corresponds to <code>OP_1</code> , which pushes <code>OP_1</code> stack 1. A similar story with <code>NAME_FIRSTUPDATE</code> ( <code>0x52</code> or <code>OP_2</code> , puts 2) and with <code>NAME_UPDATE</code> ( <code>0x53</code> or <code>OP_3</code> , puts 3).  So the first two steps of the script only put two values ‚Äã‚Äãon the stack.  And the next operation <code>OP_2DROP</code> removes them from the stack, so that further <code>P2PKH</code> works ‚Äúfrom scratch‚Äù.  Therefore, all those script tricks that we covered in the chapter on Bitcoin are also applicable to Namecoin, despite the redefinition of some operations. <br><br>  Secondly, the keys that open a special coin and change are different.  Although technically nothing prevents you from using the same key repeatedly, it‚Äôs common practice to generate a new key for each receipt.  This is done in order to make it difficult to identify correlations between transactions and increase the level of anonymity in the network. <br><br>  At first glance it seems strange that, contrary to common sense, it is impossible to immediately take and register a name plus an IP address for it.  This is done so that no one can intercept the name as soon as they see that you want to register it (and then resell it to you). <br><br>  For example, miners, analyzing unconfirmed (not yet included in any of the blocks) transactions in the network, could create their own transaction for registration of the same domain and include it (and not yours) in their block.  To implement this attack, it is not even necessary to mine your block.  It will be enough to put your transaction on the network with a large fee.  Therefore, two separate operations <code>NAME_NEW</code> and <code>NAME_FIRSTUPDATE</code> , and the second can only be carried out by the one who carried out the first, and only after <code>NAME_NEW</code> gets into any block. <br><br>  In fact, this restriction is even a little stricter: <code>NAME_FIRSTUPDATE</code> is possible no earlier than 12 blocks after <code>NAME_NEW</code> (which is about 2 hours).  In order to understand why the blocks in this restriction are not 1, not 2, not 3, namely 12, we will have to step back a little from the main story and figure out what <code>fork</code> and <code>51% attack</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Fork</b> <div class="spoiler_text">  Imagine that miners are looking for block <code>#123456</code> .  And at about the same time, he was found independently by two miners, one of whom lives in Australia, and the other in the United States.  Each of them begins to scatter its version of the block over the network, and as a result it turns out that one half of the world has one blockchain, and the other has another. <br><br><img src="https://habrastorage.org/webt/ov/a1/yq/ova1yqiulayufd1o7z6vbmwpb0e.png"><br><br>  Is this possible?  Yes it is possible.  Moreover, this happens quite often.  In this case, each node continues to adhere to its version of the blockchain until someone finds the next block.  Suppose that the new block continues the green branch, as in the picture below.  In this case, those nodes that adhere to the red version automatically synchronize the green one, because in Bitcoin (and, accordingly, in Namecoin) the rule works: the longest version of the blockchain is true.  The red version of the blockchain will simply be forgotten, along with rewards for those who find it. <br><br><img src="https://habrastorage.org/webt/br/le/xq/brlexqeynpgyq5qjq6u0knjla5q.png"><br><br>  Of course, theoretically, in the second step, the situation could repeat itself and at the same time with purple they will find another one that will continue the red version of the blockchain.  And on the third, and so on.  But the probability of even the first fork is rather small, the second one is even less and so on.  The longest fork in the history of Bitcoin was only <a href="http://bitcoin.stackexchange.com/questions/3343/what-is-the-longest-blockchain-fork-that-has-been-orphaned-to-date">four blocks</a> .  So at some point, one of the branches will nevertheless break ahead, and the entire network will go to it. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">51% attack</b> <div class="spoiler_text">  The fact that the longest chain in the blockchain is dominant is based on an attack bearing the name 51%. <br><br>  Imagine that you are a scammer and buy goods at <code>1000 BTC</code> in a store.  You agree with the seller and send him the money.  The seller checks the blockchain, sees that such a transaction really was, passed all the checks and even got into some block, for example <code>#123</code> .  After that, the seller goes to the mail and sends you the goods. <br><br>  At this time, you turn on your mining farm and start mining, starting from block <code>#122</code> .  If you have enough power, then you can overtake the rest of the network and count the fastest to block <code>#124</code> , after which the whole world will switch to your version of the blockchain.      <code>1000 BTC</code> ,         ,      ,       .          . <br><br>         ,          .      .   11   <a href="https://bitcoin.org/bitcoin.pdf"></a>  , ,     6  ,      0,1%    ,    10% .        ,         . ,  Namecoin      ,     20%  . <br><br>       . ,        .    ,  <code>NAME_NEW</code> ,  12 ,       <code>NAME_FIRSTUPDATE</code> . <br></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NAME_FIRSTUPDATE </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The purpose of the operation </font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is to publish the name that I announced in </font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and indicate a value for it. </font><font style="vertical-align: inherit;">To do this, I need to start a transaction on the network, the input of which is the very special coin that I generated at the output </font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In order to confirm the right to use it, I present in the input script my public key and the signature of the transaction </font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">made by the private pair key, exactly according to the scheme that we examined in the chapter on </font></font><code>P2PKH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the outcomes of the transaction will be a new special coin weighing, like the previous one, no less </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Her output script should be like this:</font></font><br><br><pre> <code class="xml hljs">OP_NAME_FIRSTUPDATE <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Salt</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Value</span></span></span><span class="hljs-tag">&gt;</span></span> OP_2DROP OP_2DROP <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> <code>Salt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is the very random number </font></font><code>0xd5eeb22ee8117f57</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that we created in the first stage of preparing the script for </font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- it is </font></font><code>d/stephenmorse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in hexadecimal </font></font><code>0x642f7374657068656e6d6f727365</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The field </font></font><code>Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should contain an associative array representing the rules by which the name will be resolved. A complete list of possible keys and rules for filling them out </font></font><a href="https://wiki.namecoin.info/index.php%3Ftitle%3DDomain_Name_Specification"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In a first approximation, this is an analogue of the zone file; the link above shows the mapping of Namecoin entities to familiar DNS entities. The most popular of them are ip, an example with which was higher, and ns, which we use now. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To indicate what the NS server will be for the domain, we will </font></font><code>1.2.3.4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">put a value in Value </font></font><code>{‚Äúns‚Äù:[‚Äú1.2.3.4‚Äù]}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but, of course, in hexadecimal - </font></font><code>0x7b226e73223a5b22312e322e332e34225d7d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Like last time, close the coin with </font></font><code>P2PKH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In his example, Stephen deliberately created a coin at step NAME_NEW with a weight of not exactly </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but with a margin, so that in the next step this margin would be enough for the miner to commission. </font><font style="vertical-align: inherit;">In the general case, the transaction will have one more entrance to ensure the commission - and one more exit for delivery. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We collect everything into a transaction and </font></font><a href="https://namecha.in/tx/99f78900b5730ba03714e491d13722f6765db43968ca158796fd8214e93b8fa6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw it into the network</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/webt/nn/rt/cd/nnrtcdedqwwblvhs_wsdawyivpg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the transaction falls into the block, the hosts will update in their tables the value for the key </font></font><code>d/stephenmorse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on </font></font><code>{‚Äúns‚Äù:[‚Äú1.2.3.4‚Äù]}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">All browsers with Namecoin support will now resolve the domain </font></font><code>stephenmorse.bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and its subdomains to IP addresses through the DNS server located at </font></font><code>1.2.3.4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NAME_UPDATE </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ‚Äútable‚Äù with keys and their meanings, which I mentioned at the end of the last section, is actually called </font></font><code>UTXO set (unspent transaction output)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Since it is critical for the network to prevent repeated spending of funds, before adding a transaction to the block, the miner checks to see if the inputs previously specified in the transaction were used. To speed up this operation, all unused outputs are stored in a separate data structure. This structure does not exist at the network level, but is calculated and stored by each node locally. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After I completed the transaction </font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the output of my coin with a weight </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, to which the value for the key is attached </font></font><code>d/stephenmorse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, hit the table</font></font><code>UTXO</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If this output is not spent for 36,000 blocks (which is more than 8 months with 10 minutes per block on average), then it will be considered as invalid, and its corresponding name - as free. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This period of 36,000 blocks (as well as the minimum value of a special coin in </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) is clearly defined at the start of the network and is unchanged. To extend the registration of the name, as well as for any changes to the record or transfer it to another owner, a transaction is used </font></font><code>NAME_UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The rules for the formation of such a transaction practically do not differ from those described above. The input for the transaction should be the output of the coin obtained in the transaction</font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">An additional entrance is needed to ensure commission. </font><font style="vertical-align: inherit;">Of the two outputs of the transaction, one is a new coin with an updated value for the name, and the second is designed to transfer change from the commission. </font><font style="vertical-align: inherit;">The output script format for the coin is:</font></font><br><br><pre> <code class="xml hljs">OP_NAME_UPDATE <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Value</span></span></span><span class="hljs-tag">&gt;</span></span> OP_2DROP OP_DROP <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As in the previous case, </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is </font></font><code>d/stephenmorse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and </font></font><code>Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- JSON with a value, both in hexadecimal. </font><font style="vertical-align: inherit;">Close the exit using P2PKH and throw the transaction </font></font><a href="https://namecha.in/tx/ae2e6b82c4a7d9e092d49094615139ce730df2f1c3a88a56a8a5fef1c8a14cc1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">into the network</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/webt/ny/2t/vq/ny2tvqbgf2fhkaiebkx2b9_fdkc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, this is practically everything that I wanted to tell about name management in Namecoin. </font><font style="vertical-align: inherit;">All that remains is to say a few words about the costs of owning a domain.</font></font><br><br><h2>  Expenses </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's calculate how much the content of the name in </font></font><code>Dot-Bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(the name of the DNS zone .bit, operating on the basis of Namecoin) costs in cryptocurrency and, translating the numbers into fiat currency, is comparable to the cost of a ‚Äúnormal‚Äù DNS domain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, as can be seen from the previous section, for a transaction, the </font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">costs of the domain owner will be </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to create a coin to which the zone will be attached, plus the miner's commission. For a transaction, a </font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new coin is created at the expense of the old one, and in addition the owner pays only the commission. After about 8 months, the owner will have to complete the transaction </font></font><code>NAME_UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to retain the registered name. And this is where the required costs for the first year end. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most articles about Namecoin (including the previously cited </font></font><a href="https://stephentechblog.wordpress.com/2015/05/13/the-bits-and-bytes-of-namecoin/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article by Stephen Morse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) are based on data from the first years of the network‚Äôs existence and claim that the miner‚Äôs commission is 0.005 NMC. But since then, the median value of the commission has gradually decreased and at the beginning of 2019 </font></font><a href="https://bitinfocharts.com/comparison/namecoin-median_transaction_fee.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about 0.0003 NMC. The NMC exchange rate to the US dollar, on the contrary, having undergone several ups, returned to the level of 2015 and </font></font><a href="https://bitinfocharts.com/comparison/namecoin-price.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">amounts to</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about $ 0.7 for 1 NMC. It is easy to calculate that the domain in the .bit zone in the first year will cost the owner from 0.0109 NMC or $ 0.00763. Perhaps it will be easier for someone to remember an approximate analogue of this amount in Russian currency - 50 kopecks.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, this is the lower limit that matches the scenario for buying a name for future use or cybersquatting. What about the upper limit? Since the input from each transaction updating the zone should be a coin from one of the previous blocks, the theoretical maximum of the name update frequency is equal to the frequency of the appearance of new blocks. Recalling that the average value of this value was set at the start of the network and is about 10 minutes, it can be estimated that the upper limit of the cost of maintaining the domain will be 15.7744 NMC or a little more than $ 11.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, even such a fantastic scenario for using a name in Namecoin costs approximately the same as the first year of owning a regular domain in the most popular .com zone. If we compare the more realistic scenario with the update on average once a day, then the name in the .bit zone will cost about 8 cents a year, which is an order of magnitude cheaper than the most advantageous offers in the traditional DNS, which do not fall below $ 1. In the scenario of short-term use of the domain (from several hours to a month), the difference in favor of Namecoin will already be two orders of magnitude.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Taking into account the financial attractiveness of the service, as well as the anonymity of the domain owner, including the lack of a traditional ‚Äúmoney trail‚Äù for ordinary DNS, it becomes clear why Namecoin has become a popular network for service owners with an increased risk of disconnection or blocking, in particular botnets. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Botnets in Namecoin </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indeed, the fact that botnet operators have begun to use anonymity </font></font><code>Dot-Bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to protect their C&amp;C servers is not surprising. Another thing is more interesting - how long botnets in .bit remain active. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C&amp;C domains registered in ‚Äúnormal‚Äù DNS zones are sooner or later withdrawn from the owner, which forces the operator to pay for registering a new name and launch a new bot assembly on the network with a new management server. The fundamental impossibility of removing a domain in the .bit zone increased the botnet's lifetime by orders of magnitude. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Take, for example </font></font><code>pationare.bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the domain registered in December 2016. It was used to control a botnet </font></font><code>Chthronic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(distributing a banking trojan built on the basis of the famous ZeuS). Distribution campaign</font></font><code>Chthronic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was associated with the use of the exploit pack RIG and was described in detail by various researchers (for example, </font></font><a href="http://www.malware-traffic-analysis.net/2016/12/27/index.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malware-traffic-analysis.net</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) at the end of 2016 and the first half of 2017. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One could assume that this botnet was destroyed long ago. But no - more than two years after the launch, the botnet‚Äôs C &amp; C domain and its network are still active. As can be seen from the screenshot below, the last update was made in December 2018.</font></font><br><br><img src="https://habrastorage.org/webt/9k/o9/5w/9ko95wbszt4g7fqntkxm0cnh34u.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It looks tempting, right? Since the management server‚Äôs DNS name remains intact, there is no need to frequently update the bot code and restart the distribution campaign. There remains only the cost of changing the hosting after blocking the IP address, but these costs can also be reduced by using hacked web servers as proxies, the shells of which cost less than a dollar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the other hand, all transactions in the blockchain are publicly available to any participant. </font><font style="vertical-align: inherit;">As we discussed in detail in previous chapters, coins in Namecoin do not disappear without a trace, which means we can track their redistribution between addresses. </font><font style="vertical-align: inherit;">And knowing the rules and restrictions, taking into account which transactions are formed in Namecoin, we can find meaningful patterns in which the uniform management of some addresses that participated in the transaction will be obvious. </font><font style="vertical-align: inherit;">In this case, the domains paid with coins from these addresses will have a common owner - the group we are managing, which controls the botnet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will develop this idea further.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> General IOC Collection Scheme </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us describe the general search scheme using the example of a real botnet of the RTM group. We will build on this </font></font><a href="https://any.run/report/a8954f6a48614141afaf2b31cdd3962f4d5df544927d0f16e882bfc21383e1d9/1021e424-dbfd-4c6a-8680-136a504b426d"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sample</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which was identified as </font></font><code>Win32/Spy.RTM.N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/webt/9r/rx/tq/9rrxtqepv4ods_wcbibv-2hk9uk.png"><br><br><img src="https://habrastorage.org/webt/ps/by/dk/psbydk2cmnsifuf5cf8njpmnnvm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see from the screenshot above, after starting it tries to get the IP address for the name </font></font><code>stat-counter-4.bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. We get </font></font><a href="https://namecha.in/name/d/stat-counter-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">information</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about the transaction history for this name in Namecoin. </font></font><br><br><img src="https://habrastorage.org/webt/ok/jj/aj/okjjajszmlcuj_8enwzkosbze6k.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The identifier of the transaction that created this domain, we get by clicking on the link to the operation NAME_NEW. The input address of this transaction, with the help of which the domain was created, is obviously managed by the group of interest to us. He will be the initial set of data: </font></font><code>N3KPt8py24EAsAiKquyFgoKGyTYeR5Tmry</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><img src="https://habrastorage.org/webt/-k/si/6n/-ksi6n9mz69t-tscu-cpyilewpa.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having pushed off from the initial data set, we iteratively go around the blockchain, moving in the direction of its growth (upward movement, or upstream movement). At the beginning of each step, we get a transaction, a certain coin at the input of which belongs to the person we are interested in. In the first step, we check the transaction from the initial data set, the owner of the coins at the input of which we know a priori.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The transaction is checked for compliance with heuristic rules (we will formulate them below), which guarantee that a certain coin (or coins) at the exit of the transaction belongs to the same person as the input coin known to us. If the transaction in question satisfies one or more heuristics, then such guiding coins will indicate the direction of further movement. The transaction that spends the guiding coin will be the next step in the iteration. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At each step of the iteration, we replenish the list of domains that participated in the transactions and the list of IP addresses to which these domains were resolved. These are historical identifiers of compromise (IOC), which can be used for forensicists, as well as to identify tactics and grouping methods.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The movement stops if the transaction in question does not satisfy any of the heuristics. This means that we cannot say with certainty that any of the outputs of the transaction in question is controlled by the person we are interested in. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another situation that stops the movement is the lack of transactions from the output address. We will save such addresses in a separate list of unspent coins (UTXO). They represent the greatest value in the entire study. Since we are confident that these addresses are managed by the person we are interested in, any future transaction using these addresses will generate a new, previously unknown IOC ‚Äî the domain name or IP address ‚Äî that has not yet been used by the grouping. But with high probability it will be soon.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To bypass the blockchain, it is convenient to export it to the database. For this, you can use, for example, a modified </font></font><a href="https://github.com/b4bay/rusty-blockparser"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rusty-blockparser utility</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in which we improved Namecoin support by adding operations recognition </font></font><code>NAME_*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, data structures </font></font><code>Auxiliary Proof-of-Work</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and expanding the export format. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Python pseudo code for the upward movement is presented below. Hereinafter, it is assumed that the blockchain transaction data is stored in MongoDB.</font></font><br><br><pre> <code class="python hljs">start = <span class="hljs-string"><span class="hljs-string">"37d40bc2f3ca7415908dc9e276593b50d3120158cd540cb088246f2e2cf88b16"</span></span> tx = namecoin.transactions.find_one({<span class="hljs-string"><span class="hljs-string">"id"</span></span>: start}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upstream_movement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> names <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> IPs <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> utxo <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> known_addresses heuristic_result = upstream_heuristic_test(tx) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> heuristic_result <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> heuristic_result.guiding_outs: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx.has_name_op(): names.add(tx.name_op.name) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ip_address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.name_op.get_ip(): IPs.add(ip_address) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> guiding_out <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> heuristic_result.guiding_outs: known_addresses.add(guiding_out.address) tx = namecoin.transactions.find_one({<span class="hljs-string"><span class="hljs-string">"in.id"</span></span>: guiding_out.id}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx: upstream_movement(tx) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: utxo.add(guiding_out)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second part of the blockchain bypass is the movement against the growth of the blockchain (downward movement, or downstream movement). In general, the downward movement algorithm is no different from the upward algorithm. A movement begins with a transaction from the original data set. At each step, the transaction is checked for compliance with heuristic rules (generally different from the rules for upward movement). The only difference is that the coin, whose membership is known a priori, is at the exit of the transaction, and the heuristics guarantee that the same person has one or more coins at the entrance.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A downward movement also stops if the current transaction does not satisfy any of the heuristics. </font><font style="vertical-align: inherit;">Unlike the upward movement, we cannot meet unspent coins among the guides, and this option to exit recursion in the downward movement will not work. </font><font style="vertical-align: inherit;">But, as with the upward movement, we replenish both the list of names and the list of IP addresses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python pseudo code for the downward movement would look like this:</font></font><br><br><pre> <code class="python hljs">start = <span class="hljs-string"><span class="hljs-string">"37d40bc2f3ca7415908dc9e276593b50d3120158cd540cb088246f2e2cf88b16"</span></span> tx = namecoin.transactions.find_one({<span class="hljs-string"><span class="hljs-string">"id"</span></span>: start}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downstream_movement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> names <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> IPs <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> utxo <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> known_addresses heristic_result = downstream_heuristic_test(tx) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> heuristic_result <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> heuristic_result.guiding_ins: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx.has_name_op(): names.add(tx.name_op.name) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ip_address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.name_op.get_ip(): IPs.add(ip_address) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> guiding_in <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> heuristic_result.guiding_ins: known_addresses.add(guiding_in.address) tx = namecoin.transactions.find_one({<span class="hljs-string"><span class="hljs-string">"out.id"</span></span>: guiding_in.id}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx: downstream_movement(tx)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now consider the heuristic rules that we will use when moving along the blockchain. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Heuristic rules </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Common change </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look again at the transaction, a screenshot of which is given above. An address </font></font><code>N3KPt8py24EAsAiKquyFgoKGyTYeR5Tmry</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">containing money to create a new name </font><font style="vertical-align: inherit;">is sent to the transaction input </font><font style="vertical-align: inherit;">. There </font><font style="vertical-align: inherit;">will be two addresses </font><font style="vertical-align: inherit;">for transactions </font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>NAME_UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the entrance - a special coin with a zone from the previous transaction by domain and additional funds to cover the commission. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will immediately note that in the context of transactions, we will talk about both coins and addresses. Despite the fact that in some works these concepts are considered almost equivalent, it‚Äôs important for us to clearly indicate the difference between these terms, since in the course of the study we will draw conclusions about both coins and addresses.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saying "coin", we will mean a positive balance, formed as the output of a transaction. This coin is identified by the transaction number that generated it and the exit index. For example, a coin at the input of the transaction considered above has an identifier </font></font><code>5778be8e1901e9931e9b41a128a0b7f963e6e1ae72e461df2cba26e6279d433a:1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, since it was formed as the output (with index 1) of the transaction </font></font><code>5778be8e1901e9931e9b41a128a0b7f963e6e1ae72e461df2cba26e6279d433a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A special coin, as before, we will call a coin with a face value of b </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>locking script</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which contains the operation with a domain name. We examined in detail the mechanism for the formation of such coins in the Domain Management section. We will call a coin of arbitrary denomination an ordinary coin, to which the operation with the domain is not tied.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main property of coins is their immutability. Any coin can be spent only once and only in its entirety. Thus, any is mentioned in the Namecoin network a maximum of two times: once at creation, and a second time at expenditure. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saying "address", we will mean an identifier that uniquely identifies a key pair that can open a locking script in a format </font></font><code>P2PKH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that closes a coin located at the input or output of a transaction. Since only the key corresponding to the address can spend a coin, the closest analogy of the physical world to the address is the wallet in which the coins are stored (and from which they are spent).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despite the fact that in Namecoin an address is often also used only twice, it is not necessary to receive and consume a single coin. The facts of reusing addresses will help us a little in the future. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We talked more about inputs, outputs and addresses in the chapter of Bitcoin 201. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, two coins are formed at the exit of the transaction. The </font></font><code>N2hgZoWaTKoJ7FPmLuytTow3XrCCfEj2ca</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">same special coin, weighing 0.01 NMC, to which the domain is bound, went to the </font><font style="vertical-align: inherit;">address </font><font style="vertical-align: inherit;">. An </font></font><code>NKMMLwyMw4nwGuke6vd3AuDBMP18FWRaF1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordinary coin with change was sent to the </font><font style="vertical-align: inherit;">second address </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the most common transaction scheme. There are still options when there is more than one coin at the entrance, but their common property is that the coin with change is always exactly the same.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can guess that such a transaction corresponds to a simple update of domain information. Payment for updating is carried out using one (less often several) coins belonging to one person. Indeed, since a transaction always has only one author, it must manage all the input addresses. Without this, he will not be able to create an unlocking script, which is needed in order to use the coins from this wallet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, since all the change from this operation is collected in one coin, it is clear that this coin belongs to the same person as the coins at the entrance. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A similar scheme for Bitcoin is described in </font></font><a href="https://bitfury.com/content/downloads/clustering_whitepaper.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this work</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where it is called </font></font><code>one-time change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It reflects the method by which native Bitcoin applications conduct transactions - </font></font><code>bitcoind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>bitcoin-qt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It is called one-time because of another feature of these applications. By default, they generate new addresses for coins at the output of the created transaction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namecoin, along with the Bitcoin code base, has inherited the bulk of the code for these applications, which are called </font></font><code>namecoind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>namecoin-qt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Regarding ordinary coins, we can safely use this heuristic without any changes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The statistics of reuse of addresses for storing special coins shows that this rule is in most cases also observed for them. Reuse of such addresses is quite rare. Addresses used more than once, about 6% of the total; more than two times - about 1%. Based on the purpose of Namecoin, it seems reasonable to assume that most transactions with special coins on the network are simple creation and update operations, during which the domain owner does not change. Therefore, we can argue that such an operation corresponds to the withdrawal of a special coin to a new, previously unused address. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's look at an example of a transaction with a reused address for a special output coin. To do this, take another transaction of the RTM group -</font></font><code>b3c7ce9ca3a689c6236b9d6df3c257c5fab6c3985187669ccf731ac42a127a11</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/webt/em/d6/hx/emd6hxidz3xhgqny_f5e7ho5-04.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The address </font></font><code>NDpWDEx1mBkUYywqxDTAZZeGCfUV4GkVE8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to which the special coin went was already used in previous transactions. </font></font><br><br><img src="https://habrastorage.org/webt/ws/32/00/ws3200wv6hvjc1z63vt4p1hdivs.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As mentioned earlier, the default scripts in the native client applications for Namecoin do not result in address reuse. To send a special coin to an existing address, the owner will need to make separate, optional efforts, finding out and indicating the exit address explicitly at the stage of transaction formation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why might this be required? The only mention of the situation in which the exit address is specified manually, I met only in the </font></font><a href="https://www.meowbit.com/how-to-register-dot-bit-domains/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instructions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for transferring the domain to another owner.</font></font><br><br><img src="https://habrastorage.org/webt/zv/8q/pe/zv8qpeblzvm4jogj-axkgmcgili.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The conjecture is confirmed if we consider the further fate of the addresses at the exit of the transaction in question. In the diagram below, this transaction is marked by a bright green milestone. It can be seen that the next transaction </font></font><code>9e16f6be</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on the stat-counter-4 domain took place using a money address </font></font><code>NJ8xUePv</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that does not have an explicit connection with the address used in the "parent" transaction. Obviously, the domain was transferred to the management of another person.</font></font><br><br><img src="https://habrastorage.org/webt/ue/ho/ea/uehoea2yau72ydjns-ujsixawkw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the general case, this can be either the sale of a domain to another owner that is not related to the activities of the person in question, or the transfer of a domain between the accounts of one person. </font><font style="vertical-align: inherit;">The second option is the simplicity and low cost of registering a new domain, as well as the lack of visible interest of organizations and trademark owners in registering domains in the .bit zone. </font><font style="vertical-align: inherit;">We were not able to come up with at least a little justified motivation for buying a domain, noticed in malicious activity. </font><font style="vertical-align: inherit;">Therefore, we believe that despite the possibility of transferring the domain to another person, transactions with reusable addresses for withdrawing a special coin represent a regrouping of assets between several accounts controlled by one group.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We formulate the above arguments in the form of a heuristic rule, which we will call common change: </font></font><br><br><blockquote>         ,   ,       ,     . <br><br>          ,     ,    . <br><br>  ,    ,     . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The scheme for using this rule is shown in the figure. Gray streams - ordinary coins, green - a special coin. The guides will be all the coins from the end of the transaction opposite the coin through which we came to this transaction: all exits are for upward movement, and all entrances are for downward movement. </font></font><br><br><img src="https://habrastorage.org/webt/1a/bh/fo/1abhfo8tmu_v8xwuw_uk7j0mla4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We note several features of this heuristic. Firstly, bi-directional: it works both for the upward movement, when we know the owner of the entrance, and for the downward movement, when we know the owner of one of the coins at the exit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secondly, the optionality of having a special coin: despite the fact that in its absence the transaction is not related to updating the domain, the above logical reasoning regarding the owner of an ordinary coin at the output remains valid.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The pseudo code for testing a transaction for compliance with the common change rule would look like this: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">common_change</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> result = {<span class="hljs-string"><span class="hljs-string">"guiding_outs"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>: []} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(tx.outs.money) != <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {} addr = tx.outs.money[<span class="hljs-number"><span class="hljs-number">0</span></span>].address first_tx = namecoin.tx.find_one({<span class="hljs-string"><span class="hljs-string">"out.id"</span></span>: addr}, sort=[(<span class="hljs-string"><span class="hljs-string">"block"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first_tx.id != tx.id: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: result[<span class="hljs-string"><span class="hljs-string">"guiding_outs"</span></span>] = tx.outs.all result[<span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>] = tx.ins.all <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Common spending </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The heuristic considered above has another important property, in addition to bidirectionality. Common change - heuristic "without memory"; The verification result is determined only by the characteristics of the transaction in question and does not depend on the results of other heuristics and accumulated data. Such a heuristic is indispensable in the first iterations of a traversal, for the initial filling of a data set. On the other hand, it is easy to notice the limitations of its application. For example, it will focus on a transaction containing two or more cash outputs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As an example of such a transaction, consider </font></font><code>db4ff4082f39d0a501508706e627f26aa92712d27b4f633ded59917d201cfae5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This transaction relates to the activities of the group managing the Dimnie botnet. </font></font><br><br><img src="https://habrastorage.org/webt/td/61/-c/td61-cbmmd7enx-0olfyjxrpcva.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We went down this transaction through the address</font></font><code>My7Ap3nH5f4X6Us2KiUWisd77wRpMG1MDY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that was used in the previous CC transaction as the login address. Despite the fact that his attitude towards the person being studied is beyond doubt, we cannot say the same (as well as the opposite) about any of the other exits and entrances. This may be a redistribution of coins between group addresses, in which case all addresses are controlled by the person we are interested in. Or is it, perhaps, a recharge from the addresses of any of the exchanges selling Namecoin tokens. Or a transfer from another network member that is not related to the activity of the person being studied. It is impossible to make an unambiguous conclusion on the attributes of this transaction alone. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the address</font></font><code>N4XtLb7xpC4Zk72T8QcshKhTW17ZCyQ1j1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the input of this transaction. </font><font style="vertical-align: inherit;">This address has already been used previously (‚Äúearlier‚Äù for a downward movement means ‚Äúin the future‚Äù, ‚Äúin the direction of blockchain growth‚Äù) at the input of a CC transaction </font></font><code>6bffc741eb66de074c09a380fb5e6bd13d4bd5205c36a76e3682674dba08461e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which allows us to consider this address to be managed by the person of interest to us. </font><font style="vertical-align: inherit;">And since, as has already been shown, the keys to all the coins at the input of the transaction are controlled by one person (which cannot be said about the exits), we have reason to believe that all other inputs also belong to the group of interest to us. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The strict condition of the heuristic common spending looks very simple:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If it is known that at least one of the addresses at the input of the transaction is controlled by a certain person, then all other addresses at the inputs of this transaction are controlled by the same person. </font><font style="vertical-align: inherit;">Coins at these entrances belong to the same person.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, this heuristic makes sense only for the downward movement. When moving in the direction of blockchain growth, we come to the transaction under study through one of the inputs. In this case, the rule condition is satisfied automatically, but does not say anything about the outputs of the transaction and does not allow you to continue moving in the upstream direction. In other words, this is a unidirectional heuristic. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second feature of this heuristic, which is worth noting, is that here we first used the data accumulated as a result of checking previous transactions - a list of addresses managed by the person under investigation. For this reason, this secondary heuristic cannot be used for independent movement, without any primary heuristic that does not depend on the accumulated results (such as common change).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The pseudo code for testing a transaction for compliance with the common spending rule would look like this: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">common_spending</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> result = { <span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>: [] } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> input <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.get_ins(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input.address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> known_addresses: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>: tx.ins.all} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {}</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Known address </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last heuristic that we will consider in the framework of this section is the simplest of all. </font><font style="vertical-align: inherit;">This is a secondary bidirectional heuristic that (since it is bidirectional) can be used for both upward and downward movement. </font><font style="vertical-align: inherit;">The strict wording of the heuristic known address for the upward movement looks like this:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If it is known that the address at the input (output) of the transaction is controlled by a certain person, then the coins received at this address (spent from this address) belong to the same person. </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despite the fact that heuristic looks like a frank truism, this rule helps to find branches and intersections in coin flows and adds connectivity to the transaction tree. In addition, it allows you to not stop the movement on transactions that do not fall under other heuristics. An example is the transaction of the </font></font><code>7a35b9cb0a16b3eba92781be014555eaa4255bd17655bb00f2b3f42c3950ac69</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">already mentioned Dimnie botnet. </font></font><br><br><img src="https://habrastorage.org/webt/06/eg/as/06egasevdvty7quvjjvr0jrp6gy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having reached it in an upward movement, we will not be able to advance further with the help of common change, since the output is more than one ordinary coin. Looking at a transaction, we cannot say how many coins at the exit belong to the same person as the coin at the entrance - both, some one or none at all. The use of the known address heuristic allows you to move forward due to the fact that the address</font></font><code>MwMdTb8WQvoRW9jEW5dHn9SkkCJTRn31wQ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was involved in the CC transaction </font></font><code>cf7ac8986f9855246c6cf26df9a24aa5645cb9258bf787e034a33e75101ae1fc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that created the domain that was </font><font style="vertical-align: inherit;">previously seen in the upward movement </font></font><code>d/sectools</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the sake of completeness, we give the pseudocode of the heuristic known address:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">known_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> result = { <span class="hljs-string"><span class="hljs-string">"guiding_outs"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>: [] } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> output <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.get_outs(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> known_addresses: result[<span class="hljs-string"><span class="hljs-string">"guiding_outs"</span></span>].append(output) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> input <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.get_ins(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input.address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> known_addresses: result[<span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>].append(input) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So, now we have both the general bypass algorithm and the heuristics necessary for moving along the blockchain, so that we can put them together to get a little IOC from Namecoin. </font></font><br><br><h2>  Go! </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's go through the RTM transactions with the upward and downward movement, starting with </font></font><code>37d40bc2f3ca7415908dc9e276593b50d3120158cd540cb088246f2e2cf88b16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In the course of advancing on the blockchain, we will collect not only the IOC, but also the transactions themselves that satisfy the heuristics. We visualize coin flows between transactions using the Sankey chart. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The complete diagram is too large to be displayed in the format of this document, so I will give here only part of it that is necessary for the further story. </font></font><br><br><img src="https://habrastorage.org/webt/zj/jh/un/zjjhundsmnmtabrgw81hkty76nk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A stream of ordinary coins is highlighted in gray. The remaining colors correspond to the flows of special coins. A separate color is selected for each name. White milestones correspond to transactions that satisfy the heuristic conditions. The bright red milestones on the right are UTXO.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The chart element that I would like to draw attention to is highlighted by a blue milestone. This is a dangling entry - a coin that arose at the input of a transaction that the algorithm passed on the upward movement, but the transaction that created this coin did not meet him.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dangling inputs are signs that the structure under study has side branches that are not connected to the main trunk along which the algorithm moves. In the case shown, this is another independent account. It, as can be seen in the diagram, begins to be used to pay for changes in the domains we already know. From this fact, we can conclude that this account is also controlled by the person under investigation. To get the IOC associated with operations on this account until it appears on the chart, we will run a separate downward movement, starting in a transaction with a dangling entry. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Similarly, in a downward movement, dangling exits may occur. For each of them, we will launch a separate upward movement starting from the corresponding transaction.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to the transactions of the group that controls the RTM botnet, we also investigated the transactions of the groups that control the Shifu, Dimnie, and GandCrab botnets. As a result, 164 domains registered in the interests of these groups and 277 IP addresses associated with these names were found. At the time of this writing, of the collected UTXO belonging to these groups, 39 coins remained in effect. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The IOC lists, as well as the Namecoin addresses on which the unused coins of the groups remained, are given in Appendix A.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Real life testing is a challenge to almost any technology. By the mid-2000s, Wikipedia had become such a popular trusted source of information that, by changing the texts of articles, it became possible to control public opinion, spin, earn. This period in the history of the service is famous for its enormous revision wars - the aggressive use of the mechanism for correcting articles and the rollback of edits by several warring parties in order to win the dispute over the content of the article. Wikipedia pages turned into an international vanity fair, where everyone wanted to literally say the last word.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the one hand, they began to fight the war of corrections by setting up special rules that, in case of a dispute, allow temporarily excluding the possibility of editing the article - until the debaters in the section "Discussion" find a compromise wording. On the other hand, the war of revisions made Wikipedia launch a dynamic mechanism for managing administrators' resources, which allowed them to be quickly involved in resolving conflicts in the hottest areas. Moreover, the encyclopedia took advantage of the public attention that clashes around individual articles drew to it in order to attract more participants to the editing of these articles and achieve the most correct and complete coverage of a particular topic. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Can Namecoin, like Wikipedia, grow up and cope with its challenge?</font></font> Wait and see. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Tables with indicators of compromise </font></font><a href="https://github.com/b4bay/threat_mining_in_namecoin"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are available on GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posted by</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alexey Goncharov, PT Expert Security Center</font></font></div><p>Source: <a href="https://habr.com/ru/post/460857/">https://habr.com/ru/post/460857/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../46084/index.html">Zend Framework Tuning + Doctrine</a></li>
<li><a href="../460843/index.html">Introducing the New 3CX Call Flow Designer and 3CX CRM Template Generator</a></li>
<li><a href="../460845/index.html">Fernando Corbato, the father of your computer (and password), died at 93</a></li>
<li><a href="../460849/index.html">Part 4. A graph model for calculating logical functions for asynchronous parallel processes</a></li>
<li><a href="../460851/index.html">SamsPcbGuide Part 10: Technology, Lead-Free Soldering</a></li>
<li><a href="../460859/index.html">IThink # 3 Conference in Kharkov - based on WWDC 2019</a></li>
<li><a href="../46086/index.html">Non-working Enterprise 2.0 and Five Million for one comment</a></li>
<li><a href="../460861/index.html">JavaScript lexical scope and closure</a></li>
<li><a href="../460865/index.html">People on the moon. Sources</a></li>
<li><a href="../460867/index.html">Sourcery to automatically convert to Realm object structures</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>