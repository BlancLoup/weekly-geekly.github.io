<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Angular: event handling optimization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It was literally a couple of weeks, as I first started writing on Angular , and immediately ran into a number of specific problems. Because of the sma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Angular: event handling optimization</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/xk/ut/rl/xkutrleng4kfbj9d-dlbvywnqga.png"><br><br>  It was literally a couple of weeks, as I first started writing on <a href="https://angular.io/">Angular</a> , and immediately ran into a number of specific problems.  Because of the small experience with this framework, I am not sure that the applied optimization methods are not standard practice.  Some signs indicate that the developers suggest similar approaches, but they had to draw conclusions on the profiler and look for information in parts.  At the same time, it must be said that the solution was found very quickly, when the causes of the problems became clear. <br><br>  In the article I will explain how to optimize the handling of frequently triggered events: mousemove, scroll, dragover, and others.  Specifically, I ran into problems with the implementation of the drag-and-drop interface, so I‚Äôll go through the example of dragging and dropping elements. <br><a name="habracut"></a><br>  I want to present my train of thought on the example of several attempts at optimization, and I will briefly describe the basic principles of the work of Angular - <a href="https://ovcharik.github.io/ngx-optimization-demo">Demo application with optimization attempts</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Solvable problem </h2><br>  In the application, it was necessary to make an interface controlled by dragging and dropping items between table cells. <br><br>  The number of cells and the number of items that can be dragged reach several thousand. <br><br><h2>  The first solution </h2><br>  First of all, I went to look for ready-made solutions that implement drag-and-drop, the choice fell on <a href="https://github.com/akserg/ng2-dnd">ng2-dnd</a> , so this library has a clear and simple API, and there is some popularity in the form of asterisks on the githabe. <br><br>  It turned out to quickly distribute a solution that worked almost correctly, but even with a relatively small number of elements, problems appeared: <br><ul><li>  the calculations consumed all available power; </li><li>  the result was displayed with a big delay. </li></ul><br>  <a href="https://ovcharik.github.io/ngx-optimization-demo/">Here</a> you can see the result of this approach. <br><br>  <em>Note: below is the component code, with an example of solving the problem with the minimum expenditure of time to implement.</em>  <em>In the course of the article will be given some more code examples.</em>  <em>All components have a common part that forms the table.</em>  <em>This code is taken out of the components, since it has nothing to do with the optimization of event processing.</em>  <em>More information about the entire project code can be found in the <a href="https://github.com/ovcharik/ngx-optimization-demo">repository</a> .</em> <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text">  <a href="">repository</a> <a href="https://ovcharik.github.io/ngx-optimization-demo/">example</a> <br><pre><code class="javascript hljs">@Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'app-version-1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">` &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr *ngFor="let row of table"&gt; &lt;td *ngFor="let cell of row"&gt; &lt;div class="cell-content" dnd-droppable (onDropSuccess)="drop($event, cell)" (onDragEnter)="dragEnter($event, cell)" (onDragLeave)="dragLeave($event, cell)" &gt; &lt;span class="item" *ngFor="let item of cell" dnd-draggable [dragData]="{cell: cell, item: item}" &gt;{{item}}&lt;/span&gt; &lt;span class="entered" *ngIf="cell.entered"&gt;{{cell.entered}}&lt;/span&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; `</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Version1Component</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VersionBase</span></span></span><span class="hljs-class"> </span></span>{ public <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly title = <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-comment"><span class="hljs-comment">//        public dragEnter({ dragData }, cell: Cell) { cell.entered = dragData.item; } //      public dragLeave({ dragData }, cell: Cell) { delete cell.entered; } //     public drop({ dragData }, cell: Cell) { const index = dragData.cell.indexOf(dragData.item); dragData.cell.splice(index, 1); cell.push(dragData.item); delete cell.entered; } }</span></span></code> </pre> <br></div></div><br><h3>  Improvements </h3><br>  There was no point in bringing such an implementation to mind, since it is almost impossible to work in this mode. <br><br>  The first assumption arose that reducing the elements that are processed by the library can significantly improve the situation.  It is impossible to get rid of a large number of draggable elements within the framework of the task, but droppable cells can be removed and events traced by the table can be removed; by the events, the cell element and its data can be set. <br><br>  This approach involves interacting with HTML elements and native events, which is not good in the context of the framework, but I found it acceptable for optimization purposes. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text">  <a href="">repository</a> <a href="https://ovcharik.github.io/ngx-optimization-demo/">example</a> <br><br><pre> <code class="javascript hljs">@Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'app-version-2'</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">` &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;table&gt; &lt;tbody dnd-droppable (onDropSuccess)="drop($event)" (onDragEnter)="dragEnter($event)" (onDragLeave)="dragLeave($event)" &gt; &lt;tr *ngFor="let row of table"&gt; &lt;td *ngFor="let cell of row"&gt; &lt;div class="cell-content"&gt; &lt;span class="item" *ngFor="let item of cell" dnd-draggable [dragData]="{cell: cell, item: item}" (onDragEnd)="dragEnd($event)" &gt;{{item}}&lt;/span&gt; &lt;span class="entered" *ngIf="cell.entered"&gt;{{cell.entered}}&lt;/span&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; `</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Version2Component</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VersionBase</span></span></span><span class="hljs-class"> </span></span>{ public <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly title = <span class="hljs-string"><span class="hljs-string">' droppable '</span></span>; <span class="hljs-comment"><span class="hljs-comment">//        private enteredCell: Cell; //       private getTargetElement(target: EventTarget): Element { return (target instanceof Element) ? target : (target instanceof Text) ? target.parentElement : null; } //      private getCell(element: Element): Cell { if (!element) { return null; } const td = element.closest('td'); const tr = element.closest('tr'); const body = element.closest('tbody'); const row = body ? Array.from(body.children).indexOf(tr) : -1; const col = tr ? Array.from(tr.children).indexOf(td) : -1; return (row &gt;= 0 &amp;&amp; col &gt;= 0) ? this.table[row][col] : null; } //     private clearEnteredCell() { if (this.enteredCell) { delete this.enteredCell.entered; delete this.enteredCell; } } //         public dragEnter({ dragData, mouseEvent }: { dragData: any, mouseEvent: DragEvent }) { this.clearEnteredCell(); const element = this.getTargetElement(mouseEvent.target); const cell = this.getCell(element); if (cell) { cell.entered = dragData.item; this.enteredCell = cell; } } //       public dragLeave({ dragData, mouseEvent }: { dragData: any, mouseEvent: DragEvent }) { const element = this.getTargetElement(mouseEvent.target) if (!element || !element.closest('td')) { this.clearEnteredCell(); } } //      public drop({ dragData, mouseEvent }: { dragData: any, mouseEvent: DragEvent }) { if (this.enteredCell) { const index = dragData.cell.indexOf(dragData.item); dragData.cell.splice(index, 1); this.enteredCell.push(dragData.item); } this.clearEnteredCell(); } //   public dragEnd() { this.clearEnteredCell(); } }</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Profiler</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pe/au/mo/peaumog66pvyzylmygsh4npykpq.png"><br></div></div><br>  According to the subjective feelings and the profiler one can judge what has become better, but in general the situation has not changed.  The profiler shows that the framework runs a large number of event handlers to search for changes in the data, and at that time I did not quite understand the nature of these calls. <br><br>  Assumed that the library forces Angular to subscribe to all these events and process them in this way. <br><br><h2>  Second solution </h2><br>  It was clear from the profiler that the root of the problem is not in my handlers, and the call enableProdMode (), although it greatly reduces the time for searching and applying changes, but the profiler shows that the main amount of resources is spent on the execution of scripts.  After a number of attempts at micro-optimizations, I still decided to abandon the ng2-dnd library, and implement everything myself in order to improve control. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text">  <a href="">repository</a> <a href="https://ovcharik.github.io/ngx-optimization-demo/">example</a> <br><br><pre> <code class="javascript hljs">@Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'app-version-3'</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">` &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;table&gt; &lt;tbody (dragenter)="dragEnter($event)" (dragleave)="dragLeave($event)" (dragover)="dragOver($event)" (drop)="drop($event)" &gt; &lt;tr *ngFor="let row of table"&gt; &lt;td *ngFor="let cell of row"&gt; &lt;div class="cell-content"&gt; &lt;span class="item" *ngFor="let item of cell" draggable="true" (dragstart)="dragStart($event, {cell: cell, item: item})" (dragend)="dragEnd()" &gt;{{item}}&lt;/span&gt; &lt;span class="entered" *ngIf="cell.entered"&gt;{{cell.entered}}&lt;/span&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; `</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Version3Component</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VersionBase</span></span></span><span class="hljs-class"> </span></span>{ public <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly title = <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-comment"><span class="hljs-comment">//        private enteredCell: Cell; //   private dragData: { cell: Cell, item: string }; //  ,     private getTargetElement(target: EventTarget): Element { return (target instanceof Element) ? target : (target instanceof Text) ? target.parentElement : null; } //      private getCell(element: Element): Cell { if (!element) { return null; } const td = element.closest('td'); const tr = element.closest('tr'); const body = element.closest('tbody'); const row = body ? Array.from(body.children).indexOf(tr) : -1; const col = tr ? Array.from(tr.children).indexOf(td) : -1; return (row &gt;= 0 &amp;&amp; col &gt;= 0) ? this.table[row][col] : null; } //     private clearEnteredCell() { if (this.enteredCell) { delete this.enteredCell.entered; delete this.enteredCell; } } //   public dragStart(event: DragEvent, dragData) { this.dragData = dragData; event.dataTransfer.effectAllowed = 'all'; event.dataTransfer.setData('Text', dragData.item); } //         public dragEnter(event: DragEvent) { this.clearEnteredCell(); const element = this.getTargetElement(event.target); const cell = this.getCell(element); if (cell) { this.enteredCell = cell; this.enteredCell.entered = this.dragData.item; } } //       public dragLeave(event: DragEvent) { const element = this.getTargetElement(event.target); if (!element || !element.closest('td')) { this.clearEnteredCell(); } } //        public dragOver(event: DragEvent) { const element = this.getTargetElement(event.target); const cell = this.getCell(element); if (cell) { event.preventDefault(); event.dataTransfer.dropEffect = 'move'; return false; } } //      public drop(event: DragEvent) { const element = this.getTargetElement(event.target); event.stopPropagation(); if (this.dragData &amp;&amp; this.enteredCell) { const index = this.dragData.cell.indexOf(this.dragData.item); this.dragData.cell.splice(index, 1); this.enteredCell.push(this.dragData.item); } this.dragEnd(); return false; } //   public dragEnd() { delete this.dragData; this.clearEnteredCell(); } }</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Profiler</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/uy/0d/sn/uy0dsnpnfmb6y5tilk-8iqptp9y.png"><br></div></div><br>  The situation in terms of performance has improved significantly, and in production mode, the drag processing speed has become close to acceptable. <br><br>  As for the profiler, it was still clear that a lot of computing resources are being spent on executing scripts, and these calculations have nothing to do with my code. <br><br>  Then I began to realize that I am responsible for this Zone.js, which lies at the heart of Angular.  This is clearly indicated by the methods that can be observed in the profiler.  In the file polyfills.ts, I saw that there is an opportunity to disable the standard framework handler for some events.  And since the dragover event is most often caused by dragging and dropping it onto the blacklist, it gave a practically perfect result. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * By default, zone.js will patch all possible macroTask and DomEvents * user can disable parts of macroTask/DomEvents patch by setting following flags */</span></span> <span class="hljs-comment"><span class="hljs-comment">// (window as any).__Zone_disable_requestAnimationFrame = true; // disable patch requestAnimationFrame // (window as any).__Zone_disable_on_property = true; // disable patch onProperty such as onclick (window as any).__zone_symbol__BLACK_LISTED_EVENTS = ['dragover']; // disable patch specified eventNames</span></span></code> </pre><br>  It was possible to stop at this, but after a small search on the Internet, a solution was found that would not change the standard behavior. <br><br><h2>  The third solution </h2><br>  In my project, each cell was a separate component, in the previous examples I did not do this in order not to complicate the code. <br><br><h3>  Step 1 </h3><br>  When the solution was found, I first returned to the original logic, where each component of the cell was responsible only for its content, and the table in this version began to perform only the role of a container. <br><br>  Such decomposition allowed us to limit the amount of data in which the search for changes will occur, and significantly simplified the code, while giving more control. <br><br><div class="spoiler">  <b class="spoiler_title">Code after refactoring</b> <div class="spoiler_text">  <a href="">repository</a> <a href="https://ovcharik.github.io/ngx-optimization-demo/">example</a> <br><br><pre> <code class="javascript hljs">@Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'app-version-4-cell'</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">` &lt;span class="item" *ngFor="let item of cell" draggable="true" (dragstart)="dragStart($event, item)" (dragend)="dragEnd($event)" &gt;{{item}}&lt;/span&gt; &lt;span class="entered" *ngIf="cell.entered"&gt;{{cell.entered}}&lt;/span&gt; `</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Version4CellComponent</span></span></span><span class="hljs-class"> </span></span>{ @Input() public cell: Cell; private enteredElements: any = []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( private element: ElementRef, private dndStorage: DndStorageService, ) {} <span class="hljs-comment"><span class="hljs-comment">//   public dragStart(event: DragEvent, item: string) { this.dndStorage.set(this.cell, item); event.dataTransfer.effectAllowed = 'all'; event.dataTransfer.setData('Text', item); } //         @HostListener('dragenter', ['$event']) private dragEnter(event: DragEvent) { this.enteredElements.push(event.target); if (this.cell !== this.dndStorage.cell) { this.cell.entered = this.dndStorage.item; } } //       @HostListener('dragleave', ['$event']) private dragLeave(event: DragEvent) { this.enteredElements = this.enteredElements.filter(x =&gt; x != event.target); if (!this.enteredElements.length) { delete this.cell.entered; } } //        @HostListener('dragover', ['$event']) private dragOver(event: DragEvent) { event.preventDefault(); event.dataTransfer.dropEffect = this.cell.entered ? 'move' : 'none'; return false; } //      @HostListener('drop', ['$event']) private drop(event: DragEvent) { event.stopPropagation(); this.cell.push(this.dndStorage.item); this.dndStorage.dropped(); delete this.cell.entered; return false; } //   public dragEnd(event: DragEvent) { if (this.dndStorage.isDropped) { const index = this.cell.indexOf(this.dndStorage.item); this.cell.splice(index, 1); } this.dndStorage.reset(); } } @Component({ selector: 'app-version-4', template: ` &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr *ngFor="let row of table"&gt; &lt;td *ngFor="let cell of row"&gt; &lt;app-version-4-cell class="cell-content" [cell]="cell"&gt;&lt;/app-version-4-cell&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; `, }) export class Version4Component extends VersionBase { public static readonly title = ' '; }</span></span></code> </pre></div></div><br><h3>  Step 2 </h3><br>  From the comment in the polyfills.js file, it follows that, by default, Zone.js takes control of all DOM events and various tasks, such as handling setTimeout. <br><br>  <a href="https://habrahabr.ru/company/wrike/blog/310422/">This allows Angular</a> to launch the search engine for changes in a timely manner, and the framework users do not have to think about the context of code execution. <br><br>  On Stack Overflow, a <a href="https://stackoverflow.com/questions/43108155/angular-2-how-to-keep-event-from-triggering-digest-loop-detection-cycle">solution</a> was found, like using a standard <a href="https://angular.io/api/platform-browser/EventManager">EventManager override</a> , you can force events with a specific parameter to run outside the framework context.  This approach allows point to control the processing of events in specific locations. <br><br>  From the advantages it can be noted that explicitly indicating where events will run outside the context of the framework, there will be no surprises for developers who are not familiar with this code, unlike the approach to including events in the blacklist. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Injectable, Inject, NgZone } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { EVENT_MANAGER_PLUGINS, EventManager } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/platform-browser'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutZoneEventManager</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( @Inject(EVENT_MANAGER_PLUGINS) plugins: any[], private zone: NgZone ) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(plugins, zone); } addEventListener(element: HTMLElement, <span class="hljs-attr"><span class="hljs-attr">eventName</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">handler</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      if(eventName.endsWith('out-zone')) { eventName = eventName.split('.')[0]; //       Angular return this.zone.runOutsideAngular(() =&gt; { return super.addEventListener(element, eventName, handler); }); } //    return super.addEventListener(element, eventName, handler); } }</span></span></code> </pre><br><h3>  Step 3 </h3><br>  Another point is that making changes to the DOM will cause the browser to immediately display them. <br><br>  The render of one frame takes some time, the render of the next can only be started after the previous one is completed.  In order to find out when the browser will be ready for the rendering of the next frame, there is a <a href="https://developer.mozilla.org/ru/docs/DOM/window.requestAnimationFrame">requestAnimationFrame</a> . <br><br>  In our case, there is no need to make changes more often than the browser can display them, so I wrote a small service for synchronization. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { animationFrame } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/scheduler/animationFrame.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Injectable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeforeRenderService</span></span></span><span class="hljs-class"> </span></span>{ private tasks: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; = []; private running: boolean = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {} public addTask(task: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tasks.push(task); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.run(); } private run() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.running) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.running = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; animationFrame.schedule(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tasks.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tasks.length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.running = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }); } }</code> </pre><br><h3>  Step 4 </h3><br>  Now it remains only to prompt the framework where the changes occurred at the right moment. <br><br>  More information about the mechanism for detecting changes can be found in <a href="https://habrahabr.ru/post/327004/">this article</a> .  I can only say that you can explicitly manage the search for changes using the <a href="https://angular.io/api/core/ChangeDetectorRef">ChangeDetectorRef</a> .  Through DI, it connects to the required component, and as soon as it becomes aware of the changes that were made while executing code outside the Angular context, it is necessary to start a search for changes in a specific component. <br><br><h3>  Final option </h3><br>  We make a couple of changes to the component code: we replace the dragenter, dragleave, dragover events with the ones similar to .out-zone at the end of the name, and in the handlers for these events we explicitly indicate the framework for changes in the data. <br><br>  <a href="">repository</a> <a href="https://ovcharik.github.io/ngx-optimization-demo/">example</a> <br><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-export class Version4CellComponent { +export class Version5CellComponent { @Input() public cell: Cell; constructor( private element: ElementRef, private dndStorage: DndStorageService, + private changeDetector: ChangeDetectorRef, + private beforeRender: BeforeRenderService, ) {} // ... //         - @HostListener('dragenter', ['$event']) + @HostListener('dragenter.out-zone', ['$event']) private dragEnter(event: DragEvent) { this.enteredElements.push(event.target); if (this.cell !== this.dndStorage.cell) { this.cell.entered = this.dndStorage.item; + this.beforeRender.addTask(() =&gt; this.changeDetector.detectChanges()); } } //       - @HostListener('dragleave', ['$event']) + @HostListener('dragleave.out-zone', ['$event']) private dragLeave(event: DragEvent) { this.enteredElements = this.enteredElements.filter(x =&gt; x != event.target); if (!this.enteredElements.length) { delete this.cell.entered; + this.beforeRender.addTask(() =&gt; this.changeDetector.detectChanges()); } } //        - @HostListener('dragover', ['$event']) + @HostListener('dragover.out-zone', ['$event']) private dragOver(event: DragEvent) { event.preventDefault(); event.dataTransfer.dropEffect = this.cell.entered ? 'move' : 'none'; } // ... }</span></span></code> </pre><br><h2>  Conclusion </h2><br>  As a result, we get a clean and clear code, with precise control for changes. <br><br><img src="https://habrastorage.org/webt/4e/cv/pt/4ecvpt46bzvpop50zym98-qsrg4.png"><br><br>  According to profiler, it is clear that resources are practically not spent on script execution.  And also this approach does not change the standard behavior of the framework or component, except for specific cases that are explicitly indicated in the code. </div><p>Source: <a href="https://habr.com/ru/post/353354/">https://habr.com/ru/post/353354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353344/index.html">And we count you. Universal labeling of goods is coming in Russia</a></li>
<li><a href="../353346/index.html">Riot Games: the anatomy of technical duty</a></li>
<li><a href="../353348/index.html">Do not protect the site from scraping: resistance is useless</a></li>
<li><a href="../353350/index.html">In addition to cryptocurrency: what else is the blockchain used for?</a></li>
<li><a href="../353352/index.html">From Korutin to ARKit: everything you can find out on Mobius 2018 Piter</a></li>
<li><a href="../353356/index.html">What do Crossover, Space, and NASA have in common?</a></li>
<li><a href="../353358/index.html">I / O Extended 2018 Moscow: invitation</a></li>
<li><a href="../353360/index.html">How I went to CodeFest</a></li>
<li><a href="../353362/index.html">Running a freelance club</a></li>
<li><a href="../353366/index.html">GlobalSign digital signature service integrated into Adobe Document Cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>