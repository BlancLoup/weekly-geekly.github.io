<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Thermoweder running Arduino and LabVIEW</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 I work at the Institute of General Physics, RAS. The profile of our laboratory is laser remote sensing, specifically lidars. If you do no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Thermoweder running Arduino and LabVIEW</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  I work at the Institute of General Physics, RAS.  The profile of our laboratory is laser remote sensing, specifically lidars.  If you do not know what kind of animals, you can read, for example, <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D0%25B4%25D0%25B0%25D1%2580">on Wikipedia</a> .  Lidars are sometimes also called laser radars.  The principal difference and advantage of lidar is that with its help one can not only measure the distance to the sensing object by the delay of the return signal, but also obtain (by the signal spectrum) information on the composition and properties of the object.  For example, there are lidar methods for determining the temperature profile of water by depth in water bodies. <br><br>  Non-contact measurements are only useful to the extent that they are accurate, therefore, to calibrate the results of remote measurements with contact measurements, it was decided to make a thermowax - a train of several thermal sensors on one line. <br><a name="habracut"></a><br><h2>  Iron </h2><br>  The contactless method using lidar makes it possible to measure the water temperature to a depth of several meters (it depends on transparency, it is clear that in dirty water the laser beam quickly dissipates and does not go far), therefore the thermowell is small, consists of five thermal sensors placed on the cable with an interval 1 m, plus another 4 m of cable, counting from the ‚Äúupper‚Äù sensor. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I chose DS18B20 digital thermometers ( <a href="http://datasheets.maximintegrated.com/en/ds/DS18B20.pdf">datasheet</a> , 320 kb) in a sealed version as sensitive elements, such as: <br><br><img src="https://habrastorage.org/files/391/a54/fe4/391a54fe443843859641e7a6f209abe7.jpg"><img src="https://habrastorage.org/files/ff9/d99/ad1/ff9d99ad16f94f238e6242280fb9974e.jpg"><br><br>  Why precisely such?  Because they are sealed (smile), they are already delivered with a cable of 1 m length, they provide high accuracy and work using the <a href="https://ru.wikipedia.org/wiki/1-Wire">1-Wire</a> protocol, which greatly simplifies communication with them. <br><br>  A thoughtful study of the datasheet gave the following information.  Sensors can be connected in two ways: normal, via three wires (ground, ‚Äúplus‚Äù power and signal bus) and in ‚Äústray‚Äù mode, when the sensor is powered from the data line.  ‚ÄúSpurious‚Äù mode even more simplifies the connection (only two wires), but can sometimes distort the sensor readings.  Any deterioration in accuracy is bad for us, and from the Arduino board that controls the sensors, 5 volts are easily accessible, so I decided to power the sensors in the usual way. <br><br><img src="https://habrastorage.org/files/970/a1a/a59/970a1aa598eb4dc0a1b3572fd7c59c9c.jpg"><br>  <i>Thermal Mowers</i> <br><br>  Datashit recommends using a pull-up resistor of 4.7 kOhm, I only had two on the farm at 2.2, but this did not affect the performance of the device. <br><br>  Arduino Nano with the ATMega328P controller is responsible for controlling the sensors and for communicating with the outside world, that is, with a PC. <br><br>  Here is the scheme assembled on the breadboard: <br><br><img src="https://habrastorage.org/files/6e8/688/c3d/6e8688c3df7646c4833c4e0a4b339720.jpg"><br><br>  So - the final version after soldering and insulating: <br><br><img src="https://habrastorage.org/files/b7b/f56/8c0/b7bf568c08904928a885194522889d43.jpg"><img src="https://habrastorage.org/files/d78/182/b17/d78182b17c4d439481eeaaceb362278a.jpg"><br><br>  And this is the entire assembly of the mower (the control electronics is not isolated): <br><br><img src="https://habrastorage.org/files/625/53b/fa4/62553bfa419a4c0699875e89ccf91219.jpg"><br><br>  I chose the Arduino as the ‚Äúbrains‚Äù of the device, firstly, because this platform is easy to learn, and secondly, because it can be controlled from a PC from under LabVIEW (hereafter LabVIEW = LV for short), which is important since the software of most of our laboratory‚Äôs projects is written in this environment, and the possibility of embedding a simple automated temperature control system in other schemes is expensive. <br><br><h2>  Soft </h2><br>  The main feature of this task is to work with the device from the LV environment; therefore, it was decided to start programming with studying the interaction of Arduino and LV.  On Habr√© there is practically no information about this interaction, therefore, with your permission, I will describe everything in sufficient detail. <br><br><h4>  Start </h4><br>  So, what we need (information <a href="http://vishots.com/getting-started-with-the-labview-interface-for-arduino/">from here</a> ): <br><ol><li>  LV 2009 or newer. </li><li>  NI VISA (LV module for communicating virtual devices with real ones). </li><li>  <a href="https://www.arduino.cc/download_handler.php">Arduino IDE and drivers</a> . </li><li>  <a href="">OneWire library</a> for Arduino - put the contents of the ZIPa in / <i>[Arduino IDE installation directory]</i> / libraries /. </li><li>  LV developer offers an extension for working with Arduino boards - LabVIEW Interface for Arduino, or simply LIFA.  <i>Since recently, the development of LIFA has been officially discontinued; instead, NI suggests using the LINV toolkit from LabVIEW Hacker.</i>  <i>It supports a larger number of devices and contains more tools, however, I used LIFA, because LINX firmware controllers have the form of HEX files, which I didn‚Äôt have to do with disassembling and editing I had neither desire nor time.</i>  <i>And in LIFA, the sources are the usual sketches for Arduino.</i> <br>  LIFA can be installed directly from LV through the Package Manager VI interface (Tools -&gt; Package Manager VI).  After installation, the Arduino palette appears on the function palette: <br><br><img src="https://habrastorage.org/files/5e1/3b2/044/5e13b2044e4a4d70b29024d807662658.png"></li></ol><br><br>  To start working with Arduino in LV, you need to flash your controller with the <b>LIFA_Base.ino</b> sketch taken from the C: / Program Files / National Instruments / LabVIEW <i>[version]</i> /vi.lib/LabVIEW Interface for Arduino / Firmware / LIFA_Base / folder.  In this folder is a bunch of files - C-shnye libraries, sources and two sketches, <b>LabVIEWInterface.ino</b> and <b>LIFA_Base.ino</b> .  The first contains descriptions of all the functions for working with Arduino, the second is very short and gathers everything together for uploading to the controller. <br><br>  Voila, we now have access to most of the Arduino‚Äôs capabilities from the computer via LV.  As you can guess, the first thing I did when I figured out everything described above was blinking with a LED. <br><br>  Played, now for the cause. <br>  The 1-Wire protocol and DS18B20 thermal sensors have been around for a long time and are widely distributed, so I decided to look for information on the sharing of DS18B20 and Arduino.  And almost immediately I came across a suitable source, and not just anywhere, but on the official LabVIEW forum ( <a href="https://decibel.ni.com/content/message/23879">link</a> ).  Topikstarter had a similar task to me - to read the DS18B20 temperature sensor with Arduino from LabVIEW.  He began searching and in a <a href="http://www.youtube.com/watch%3Fv%3DSM_c0cN-Kgs%26feature%3Dplayer_embedded">video clip on YouTube he</a> saw the LV diagram with the OneWire Read VP present and asked the guru what kind of VP it was and where to get hold of it.  The author of the video responded to his request and provided the source code and detailed instructions on how and what to do. <br><br>  DS18B20 sensors are controlled as follows: the ‚Äúmaster‚Äù (controller, microprocessor) sends a two-digit hexadecimal command through the data line, depending on which the sensor measures the temperature, receives bytes from the master to write to its memory, or sends the current contents of the memory to the data line .  The author of the video modified the sketches that are uploaded to Arduino to work with LIFA: <br><ol><li>  In the file <b>LIFA_Base.ino</b> connected the library OneWire.h, </li><li>  In the <b>LabVIEWInterface.ino</b> file in the case structure responsible for processing commands coming from LV over the serial bus, he added a variant 0x1E that calls the temperature reading function written by him: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="hljs ruby"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x1E</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> OneWire Read OneWire_Read() <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> </div></div><br>  This function sends a 0x44 temperature measurement command (‚Äúconversion‚Äù) to the data line, waits for the conversion to finish, sends a 0xBE memory read command, reads, extracts the temperature reading from the received information and sends it to the serial bus: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> OneWire_Read() { OneWire ds(<span class="hljs-number"><span class="hljs-number">2</span></span>); // <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> a OneWire <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> "ds" <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> pin <span class="hljs-number"><span class="hljs-number">2.</span></span> Hard coding <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> now, because I can<span class="hljs-string"><span class="hljs-string">'t declare this in a case. byte OneWireData[9]; // Defining stuff for the added OneWire function because I'</span></span>m getting irritated <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> trying <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> make this fit <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>. <span class="hljs-type"><span class="hljs-type">int</span></span> Fract, Whole, Tc_100, SignBit, TReading; // <span class="hljs-keyword"><span class="hljs-keyword">Start</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">Conversion</span></span> ds.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>(); // <span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span> the OneWire bus <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> preparation <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> communication ds.skip(); // Skip addressing, since there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> one sensor ds.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-number"><span class="hljs-number">0x44</span></span>); // Send <span class="hljs-number"><span class="hljs-number">44</span></span>, the <span class="hljs-keyword"><span class="hljs-keyword">conversion</span></span> command // Wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">Conversion</span></span> delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); // Wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">conversion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> complete // <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> back the data ds.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>(); // <span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span> the OneWire bus <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> preparation <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> communication ds.skip(); // Skip addressing, since there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> one sensor ds.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-number"><span class="hljs-number">0xBE</span></span>); // Send the "Read Scratchpad" command <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( byte i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">9</span></span>; i++) { OneWireData[i] = ds.<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(); // <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> the <span class="hljs-number"><span class="hljs-number">9</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> data[] } // Scale the data TReading = (OneWireData[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + OneWireData[<span class="hljs-number"><span class="hljs-number">0</span></span>]; SignBit = TReading &amp; <span class="hljs-number"><span class="hljs-number">0x8000</span></span>; // Mask <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> but the MSB <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SignBit) // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the MSB <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> negative, take the Two<span class="hljs-string"><span class="hljs-string">'s Compliment to make the reading negative { TReading = (TReading ^ 0xffff) + 1; // 2'</span></span>s comp } Tc_100 = (<span class="hljs-number"><span class="hljs-number">6</span></span> * TReading) + TReading / <span class="hljs-number"><span class="hljs-number">4</span></span>; // Scale <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> the sensitivity (<span class="hljs-number"><span class="hljs-number">0.0625</span></span>¬∞C per <span class="hljs-type"><span class="hljs-type">bit</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> Whole = Tc_100 / <span class="hljs-number"><span class="hljs-number">100</span></span>; // Split <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> the whole number portion <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the reading Fract = Tc_100 % <span class="hljs-number"><span class="hljs-number">100</span></span>; // Split <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> the fractional portion <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the reading // <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span> the data serially <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SignBit) { // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the reading <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> negative, print a negative sign <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print("-"); } <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(Whole); // Print the whole number portion <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a <span class="hljs-type"><span class="hljs-type">decimal</span></span> <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print("."); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Fract &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the fraction portion <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> less than <span class="hljs-number"><span class="hljs-number">.1</span></span>, append a <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-type"><span class="hljs-type">decimal</span></span> <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print("0"); } <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(Fract); // Otherwise print the fractional portion }</code> </pre> </div></div></li></ol><br>  The proposed VP, in essence, merely sends the hexadecimal number 1E to the serial interface port indicated to it, waits for the answer and reads it: <br><br><img src="https://habrastorage.org/files/1f1/99f/e3b/1f199fe3b7a44bf7bb808b965d4df5e0.png"><br><br>  It's pretty simple. <br><br><h4>  We read one sensor manually </h4><br>  First I edited <b>LIFA_BASE.ino</b> and <b>LabVIEWInterface.ino</b> in accordance with the instructions and made the VP.  Checked, everything works, great.  Then I did something that I later regretted.  In the above topic on the LV forum, a couple of posts below one of the participants proposed his version of the VP, which reads the temperature sensor readings, consisting essentially of only one sub-device - Send Receive.vi from the Arduino subframe: <br><br><img src="https://habrastorage.org/files/d04/318/a64/d04318a6460d4a4884de7e625ee10954.png"><br><br>  Being tempted by simplicity and not having penetrated into the details, in my further experiments I used this simple version without any doubt.  No, no, everything is fine and good, it works correctly, however, there is a certain subtlety associated with the differences between my scenario of the sensor-Arduino-LabVIEW chain and the scenario for which the VP was made from the forum.  This subtlety gave me a certain amount of headache later, but more on that later. <br><br>  One of the features of the DS18B20 sensors is that each individual copy has its own unique 8-byte address (ROM code), wired into it during the production process.  This theoretically allows you to hang an unlimited number of sensors on a single 1-Wire line.  To implement this feature, an addressing command to a specific sensor is provided. <br><br>  To be addressed, you need to know the address.  I recognized the ROM codes of my sensors using the example of the <b>DS18x20_Temperature</b> from the OneWire library, and recorded them in five variables declared at the beginning of the program: <br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// DS18B20 temperature sensors' addresses: byte sensor_1[8] = {0x28,0xFF,0xBE,0xCE,0x14,0x14,0x00,0x8A}; byte sensor_2[8] = {0x28,0xFF,0x42,0x43,0x15,0x14,0x00,0xE2}; byte sensor_3[8] = {0x28,0xFF,0xED,0x55,0x15,0x14,0x00,0x8F}; byte sensor_4[8] = {0x28,0xFF,0x3D,0x6E,0x15,0x14,0x00,0x0D}; byte sensor_5[8] = {0x28,0xFF,0x5E,0x66,0x15,0x14,0x00,0x4E};</span></span></code> </pre> <br>  In the proposed version, OneWire_Read does not receive any values.  Add a parameter to it - the address of the sensor (byte array of 8 elements): <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OneWire_Read</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  Before each sending of a command, we address the sensor: <br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">Start</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">Conversion</span></span> ds.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>(); // <span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span> the OneWire bus <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> preparation <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> communication ds.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(addr); // Addressing ds.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-number"><span class="hljs-number">0x44</span></span>); // Send <span class="hljs-number"><span class="hljs-number">44</span></span>, the <span class="hljs-keyword"><span class="hljs-keyword">conversion</span></span> command</code> </pre> <br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> back the data ds.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>(); // <span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span> the OneWire bus <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> preparation <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> communication ds.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(addr); // Addressing ds.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-number"><span class="hljs-number">0xBE</span></span>); // Send the "Read Scratchpad" command</code> </pre> <br>  and add a variant to each sensor in the selection structure: <br><pre> <code class="hljs markdown"> /<span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-bullet"><span class="hljs-bullet">* *</span></span><span class="hljs-bullet"><span class="hljs-bullet">* OneWire temperature sensors reading *</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span>/ case 0x2E: // sensor 1 read OneWire<span class="hljs-emphasis"><span class="hljs-emphasis">_Read(sensor_</span></span>1); break; case 0x2F: // sensor 2 read OneWire<span class="hljs-emphasis"><span class="hljs-emphasis">_Read(sensor_</span></span>2); break; case 0x30: // sensor 3 read OneWire<span class="hljs-emphasis"><span class="hljs-emphasis">_Read(sensor_</span></span>3); break; case 0x31: // sensor 4 read OneWire<span class="hljs-emphasis"><span class="hljs-emphasis">_Read(sensor_</span></span>4); break; case 0x32: // sensor 5 read OneWire<span class="hljs-emphasis"><span class="hljs-emphasis">_Read(sensor_</span></span>5); break;</code> </pre> <br>  To test what happened, I made my small VI for a single poll of one sensor: <br><br><img src="https://habrastorage.org/files/0e0/ebf/1a3/0e0ebf1a35184ccdbc387c3f3512ffc2.png"><br><br>  As you can see, I implemented the choice of the sensor for the survey through the case-structure in the block diagram. <br><br>  For the convenience of future use, I made a small runway, as shown in the screenshot below, was <s>worn out and</s> painted a nyashny icon for it and called DS18B20 Read. <br><br><img src="https://habrastorage.org/files/612/81c/84a/61281c84aaf84ac3ab2fa8c87b5f7178.png"><br><br>  Apart from the Arduino resource clusters and errors, the runway receives the sensor number for polling and the output reads the temperature as a string. <br><br>  Hooray!  The tests were successful. <br><br><h4>  We read one sensor in automatic mode </h4><br>  Well, we now know how to manually poll one sensor.  The next step is a cyclical survey of one sensor in automatic mode.  For this, I made the following block diagram: <br><br><img src="https://habrastorage.org/files/cb5/d3e/a79/cb5d3ea798594d369e512abb1eda12ed.png"><br><br>  To begin with, the interval is fixed, the program polls the sensor once a second, and after the cycle is stopped, the user writes the collected data to the array.  For convenience, I added a time stamp to each temperature reading using the Get Date / Time String function. <br>  We turn on, wait for 20 seconds, stop ... And then the fun begins. <br>  An array scan shows that the temperature is read only the first 5 times after starting the program, then only the time stamps without temperature readings: <br><br><img src="https://habrastorage.org/files/0c8/00b/1cd/0c800b1cd0c74dce95e8be4ba3fcd93a.png"><br><br>  I could not understand for a long time what the matter was - on the LV side, it would seem that there could not be an error, the block diagram to the disgrace is simple, the code of the Arduino sketch is also correct, because  in the single manual polling mode works flawlessly.  What else could be?  Arduino board itself?  After watching her, I discovered the following.  We start the program, the LED L on pin 13 flashes twice, then the RX LED flashes (the controller has received the command for the temperature sensor sent by the PC), one second passes (the sensor converts the temperature into bytes in its memory, the PC waits for a response from it), blinks LED TX (the controller received bytes from the sensor and sent them to the PC), the RX diode flashes again, the second passes again, the TX flashes again, and so on in a circle until we stop the program.  So, in my scheme, this kaleidoscope of lights lasted the first ~ 5 seconds, and then the controller stopped responding, the RX diode blinked continuously, and the program could only be stopped by the execution stop button in the LabVIEW interface. <br>  All this confusion prompted me to think that somewhere there was something wrong with timing, and I began to dig in this direction, changed the waiting time in the VP, in the sketch, analyzed the code of the sketch literally along the line, the block diagram of the VP on Elementiku, but nothing helped.  In the end, despairing gutted Send Receive.vi, because there was nowhere else to take the problem.  Take a look at his block diagram: <br><br><img src="https://habrastorage.org/files/762/1f8/ae9/7621f8ae9a15448e98128f61ab788b7f.png"><br><br>  Send Receive, as it should, takes the data, sends it in the specified direction and takes a wait.  If no response is received within 100 milliseconds, waits another 5 milliseconds, clears the output buffer and resends the data, up to 10 such attempts.  Somewhere between the Send Receive, the microcontroller and the main VI in the process of work, an sync occurs and accumulates, and because of this, to the sixth iteration of the sensor polling, there is some discrepancy between the commands sent and the received, which hangs up the controller. <br><br>  As experience shows, a simple-looking solution is not always the best, so I redid my DS18B20 Read.vi: <br><br><img src="https://habrastorage.org/files/1f1/99f/e3b/1f199fe3b7a44bf7bb808b965d4df5e0.png"><br><br>  I admit honestly, I can not say exactly what was the matter, there is not enough depth of understanding of the interaction of the microcontroller with the PC.  But as a result of my attempts, the problem disappeared, and I did not go into it. <br><br><h4>  We read all sensors in automatic mode </h4><br>  Knowing how to read one sensor in auto mode, gash the reading of all five at once - a trick.  To do this, I wrote another function in <b>LabVIEWInterface.ino</b> - OneWire_Read_All (): <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> OneWire_Read_All() { OneWire ds(<span class="hljs-number"><span class="hljs-number">2</span></span>); byte Data[<span class="hljs-number"><span class="hljs-number">9</span></span>]; <span class="hljs-type"><span class="hljs-type">int</span></span> Fract, Whole, Tc_100, SignBit, TReading; ds.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>(); ds.skip(); // Addressing <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> sensors <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> the <span class="hljs-type"><span class="hljs-type">line</span></span> ds.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-number"><span class="hljs-number">0x44</span></span>); delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); // reading sensor <span class="hljs-number"><span class="hljs-number">1</span></span> ds.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>(); ds.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(sensor_1); // Addressing <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> sensor <span class="hljs-number"><span class="hljs-number">1</span></span> ds.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-number"><span class="hljs-number">0xBE</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( byte i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">9</span></span>; i++) { Data[i] = ds.<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(); } TReading = (Data[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + Data[<span class="hljs-number"><span class="hljs-number">0</span></span>]; SignBit = TReading &amp; <span class="hljs-number"><span class="hljs-number">0x8000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SignBit) { TReading = (TReading ^ <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } Tc_100 = (<span class="hljs-number"><span class="hljs-number">6</span></span> * TReading) + TReading / <span class="hljs-number"><span class="hljs-number">4</span></span>; Whole = Tc_100 / <span class="hljs-number"><span class="hljs-number">100</span></span>; Fract = Tc_100 % <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SignBit) { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print("-"); } <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(Whole); <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(","); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Fract &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print("0"); } <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(Fract); <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(" "); // reading sensor <span class="hljs-number"><span class="hljs-number">2</span></span> ds.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>(); ds.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(sensor_2); // Addressing <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> sensor <span class="hljs-number"><span class="hljs-number">2</span></span> ds.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-number"><span class="hljs-number">0xBE</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( byte i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">9</span></span>; i++) { Data[i] = ds.<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(); } TReading = (Data[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + Data[<span class="hljs-number"><span class="hljs-number">0</span></span>]; SignBit = TReading &amp; <span class="hljs-number"><span class="hljs-number">0x8000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SignBit) { TReading = (TReading ^ <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } Tc_100 = (<span class="hljs-number"><span class="hljs-number">6</span></span> * TReading) + TReading / <span class="hljs-number"><span class="hljs-number">4</span></span>; Whole = Tc_100 / <span class="hljs-number"><span class="hljs-number">100</span></span>; Fract = Tc_100 % <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SignBit) { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print("-"); } <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(Whole); <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(","); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Fract &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print("0"); } <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(Fract); <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(" "); // reading sensor <span class="hljs-number"><span class="hljs-number">3</span></span> ds.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>(); ds.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(sensor_3); // Addressing <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> sensor <span class="hljs-number"><span class="hljs-number">3</span></span> ds.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-number"><span class="hljs-number">0xBE</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( byte i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">9</span></span>; i++) { Data[i] = ds.<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(); } TReading = (Data[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + Data[<span class="hljs-number"><span class="hljs-number">0</span></span>]; SignBit = TReading &amp; <span class="hljs-number"><span class="hljs-number">0x8000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SignBit) { TReading = (TReading ^ <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } Tc_100 = (<span class="hljs-number"><span class="hljs-number">6</span></span> * TReading) + TReading / <span class="hljs-number"><span class="hljs-number">4</span></span>; Whole = Tc_100 / <span class="hljs-number"><span class="hljs-number">100</span></span>; Fract = Tc_100 % <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SignBit) { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print("-"); } <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(Whole); <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(","); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Fract &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print("0"); } <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(Fract); <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(" "); // reading sensor <span class="hljs-number"><span class="hljs-number">4</span></span> ds.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>(); ds.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(sensor_4); // Addressing <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> sensor <span class="hljs-number"><span class="hljs-number">4</span></span> ds.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-number"><span class="hljs-number">0xBE</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( byte i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">9</span></span>; i++) { Data[i] = ds.<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(); } TReading = (Data[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + Data[<span class="hljs-number"><span class="hljs-number">0</span></span>]; SignBit = TReading &amp; <span class="hljs-number"><span class="hljs-number">0x8000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SignBit) { TReading = (TReading ^ <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } Tc_100 = (<span class="hljs-number"><span class="hljs-number">6</span></span> * TReading) + TReading / <span class="hljs-number"><span class="hljs-number">4</span></span>; Whole = Tc_100 / <span class="hljs-number"><span class="hljs-number">100</span></span>; Fract = Tc_100 % <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SignBit) { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print("-"); } <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(Whole); <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(","); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Fract &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print("0"); } <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(Fract); <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(" "); // reading sensor <span class="hljs-number"><span class="hljs-number">5</span></span> ds.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>(); ds.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(sensor_5); // Addressing <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> sensor <span class="hljs-number"><span class="hljs-number">5</span></span> ds.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-number"><span class="hljs-number">0xBE</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( byte i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">9</span></span>; i++) { Data[i] = ds.<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(); } TReading = (Data[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + Data[<span class="hljs-number"><span class="hljs-number">0</span></span>]; SignBit = TReading &amp; <span class="hljs-number"><span class="hljs-number">0x8000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SignBit) { TReading = (TReading ^ <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } Tc_100 = (<span class="hljs-number"><span class="hljs-number">6</span></span> * TReading) + TReading / <span class="hljs-number"><span class="hljs-number">4</span></span>; Whole = Tc_100 / <span class="hljs-number"><span class="hljs-number">100</span></span>; Fract = Tc_100 % <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SignBit) { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print("-"); } <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(Whole); <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(","); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Fract &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print("0"); } <span class="hljs-type"><span class="hljs-type">Serial</span></span>.print(Fract); }</code> </pre> </div></div><br>  As you can see, it, with minor changes, is a function of reading one sensor repeated 5 times. <br><br>  We also had to slightly change the DS18B20 Read.vi - made it universal, both for polling individual sensors (it receives a number from 1 to 5) and for all at once (6 at the entrance).  I also changed the number of bytes read from the buffer, because  when polling all sensors immediately at the output of the VP, the line is almost 6 times longer, and increased the buffer polling interval: <br><br><img src="https://habrastorage.org/files/f62/08c/dd9/f6208cdd92834f199662b199bd6a3e71.png"><br><br>  Cheers, comrades!  Everything works exactly the way I wanted. <br><br><h2>  Calibration </h2><br>  It would seem that everything is ready, you can calm down, but with the tests all five sensors, being placed in the same conditions (a glass of water), gave slightly different readings.  Therefore, they needed to be calibrated. <br>  For this we needed: a mercury thermometer with a scale of 0.01 degrees Celsius, a laboratory stand with a pad, a glass, some ice from the freezer, an electric kettle and water.  The improvised installation looked like this: <br><br><img src="https://habrastorage.org/files/e98/eb1/53f/e98eb153fa6646078d97d8087e7814f4.jpg"><br><br>  I apologize for the quality of the photos and for the mess in the laboratory. <br><br>  For several temperatures, the readings of the mercury thermometer and sensors were recorded, and calibration curves for each sensor were plotted. <br><br>  As an example, the calibration curve for sensor No. 1. <br><br><img src="https://habrastorage.org/files/cad/7c3/249/cad7c3249aa348638894e5cb6e203ef2.PNG"><br><br>  According to the parameters of the curves obtained, I made calibration corrections to the data produced by the program. <br>  Also with the help of the same ‚Äúinstallation‚Äù in comparison of the readings of the sensors and the mercury thermometer, the error given by the thermowell was estimated.  For different sensors at different temperatures, it is slightly different and averages 0.08 degrees Celsius. <br><br><h2>  Finishing touches </h2><br>  The LIFA interface for working with Arduino provides a lot of possibilities - working with LCD displays, servo motors, IR control, etc., this is all useful, but in my case it is completely unnecessary, and therefore I rather radically cut <b>LabVIEWInterface</b> contents <b>. ino</b> , <b>LIFA_BASE.ino</b> , <b>LabVIEWInterface.h</b> and the <b>LIFA_Base</b> folders, removing all unnecessary from there.  I will not give here listings, if someone wants to have a look, please contact, I will provide all the source codes with pleasure. <br><br>  For the control program, I made this front panel: <br><br><img src="https://habrastorage.org/files/cac/705/359/cac7053591f24bc2ab8e7495cfa6806d.PNG"><br><br>  The Arduino shielding for environmental protection was packaged in a heat shrink tubing sealed from the ends: <br><br><img src="https://habrastorage.org/files/763/530/ab2/763530ab203042bfba8f80f0f8579669.jpg"><img src="https://habrastorage.org/files/298/615/d3d/298615d3d5de4e9c942fae926885b1a6.jpg"><br><br><img src="https://habrastorage.org/files/6a8/b4a/93c/6a8b4a93c9234ac39651edeb9ca5033e.jpg"><br><br>  The device is ready: <br><br><img src="https://habrastorage.org/files/8c4/c68/d5e/8c4c68d5ee3c48a4bfd00ada2728c681.jpg"><br><br><h2>  Results </h2><br>  Cost of components and materials: <br><ol><li>  Arduino Nano - 1900 rubles; </li><li>  5 DS18B20 thermal sensors - 1950 rubles; </li><li>  10 m cable - 150 rubles; </li><li>  Little things (shrinking, cable ties, ...) - 200 rubles; </li></ol><br>  <b>In total</b> - 4200 rubles. <br><br>  And now let's think.  There are factory thermocowers for sale, it‚Äôs easy to google, for example, the ‚ÄúTC-10/10 thermocooder‚Äù with an average price of 13,000 rubles.  You can ask: ‚ÄúAnd what for was it to steam, if there are analogues of industrial production of comparable cost, giving the same or negligible accuracy, obviously well-established, more reliable and high-quality?‚Äù I will answer for several reasons: <br><br><ol><li>  / * Speaking not about serious scientific equipment, but about devices like the one described above. * / When buying a ready-made solution, you have to believe the numbers of the characteristics that the manufacturer indicated.  This is normal when using the device in production or at home, but not for scientific purposes.  I‚Äôm not saying that the manufacturer deliberately gives false information, but, as a rule, you don‚Äôt know anything about the intricacies of the internal device, methods of estimating the parameters of the device used in its manufacture, and they may turn out to be inaccurate or contain inappropriate assumptions.  In general, you understand the main principle of the scientific worldview - "Do not take anything for granted."  Another thing is if you assemble the device yourself literally by the detail, you yourself set the logic of its work and evaluate its accuracy according to the methods chosen by you. </li><li>  From an educational point of view, making thermocouples brought valuable experience with a soldering iron, programming the Arduino, and understanding its connection to a computer through LabVIEW, especially in light of the fact that I continue to study the Arduino-LV-PC bundle in a project that I switched to when I finished. </li><li>  To a lesser extent, but the question of value also mattered. </li></ol><br><br>  Thank you all for your attention!  If you have any questions / suggestions / criticism, always happy to hear, the source codes of sketches and VI-shki provide with pleasure, as already mentioned above, please contact. <br><br>  PS My programming skills are not far from ‚ÄúHello world!‚Äù, So don‚Äôt judge strictly if I‚Äôve used some terms inaccurately or not at all. </div><p>Source: <a href="https://habr.com/ru/post/242377/">https://habr.com/ru/post/242377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242367/index.html">Alternative firmware OpenWRT BarrierBreaker 14.07</a></li>
<li><a href="../242369/index.html">How we did analytics for a high load site</a></li>
<li><a href="../242371/index.html">As I wrote a physical puzzle on Libgdx</a></li>
<li><a href="../242373/index.html">Pixel Perfect Precision: how good are your pixels?</a></li>
<li><a href="../242375/index.html">Notes self-taught art director: do not growl at the programmer</a></li>
<li><a href="../242379/index.html">Advanced Gulp and Browserify: interesting tricks</a></li>
<li><a href="../242381/index.html">Underwater cabling. How it's done</a></li>
<li><a href="../242383/index.html">RAD Studio XE7 World Tour in Minsk, Nizhny Novgorod and Krasnoyarsk</a></li>
<li><a href="../242385/index.html">Report from SQA Days - Test design: easier to read or easier to write</a></li>
<li><a href="../242387/index.html">How to make profitable design development sites (part 3)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>