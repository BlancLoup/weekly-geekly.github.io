<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ReactJS - my understanding of testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How could my boss say, all rock. Since I didn‚Äôt think anything smarter, we‚Äôll stop at that. 

 Actually this materialchik does not necessarily pretend...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ReactJS - my understanding of testing</h1><div class="post__text post__text-html js-mediator-article"> How could my boss say, all rock.  Since I didn‚Äôt think anything smarter, we‚Äôll stop at that. <br><br>  Actually this materialchik does not necessarily pretend to teach something to others.  Perhaps I will gather good enough in the comments to learn myself instead) The task will be described here, how I am presenting its solution now and why. <br><br>  I have been working with the reactor for a couple of months, basically, my background is backing, and here it‚Äôs like eliminating illiteracy.  Redux and other auxiliary concepts have not yet been introduced into the equation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There was a task to try to test a small application made.  Well, any services quite in the usual style, you can test some jasmine.  With components it is more difficult if you also want to stay within the framework of the concept of unit testing.  The idea is to test the accepted contracts, and not the implementation, that is, the tests should have the form "poked a button - the application tried to do something." <br><br>  All right, I'm tied up with the introduction. <br><a name="habracut"></a><br>  <b>one.</b> <br><br>  The component‚Äôs reaction to user actions (or timers, or something else) can be twofold: it can make some changes inside itself, and it can change something else (go to another page or another part of the SPA, download the file. ..).  In the case of ReactJS, ‚Äúwithin itself‚Äù is correctly implemented through either changing the state of the component or notifying the parent components of the occurrence of some event (so that the parent can re-render the component with other props).  And the changes "outside of yourself", too, we will assume that they are implemented by calling a certain function that the parent lets down to the component: in the classical sense, this can be an event handler, or it can be a "delegate" to perform an action (going to another page, for example).  I still have the impression that something like this is usually done under ReactJS. <br><br>  It turns out that testing of reactions is reduced to ‚Äúimitated the user‚Äôs action, checked which methods (from those injected into it) and with what parameters the component caused‚Äù.  There really is a moment here that we do not inject the setState into the component;  that is, you either need to figure out how to intercept setState (in general, it seems to me that the same jasmine will cope with this), or instead of setState, give the component some other way to change its state.  To this we will return a little lower - there it will become clear why. <br><br>  <b>2</b> <br><br>  The question still remains, and how, in fact, to imitate user actions.  I read the Internet a little and found 1) <a href="https://semaphoreci.com/community/tutorials/snapshot-testing-react-components-with-jest">here</a> they offer to show methods like increment to the public api component and call them via component.getInstance (), 2) <a href="http://www.hackingwithreact.com/read/1/35/using-jest-to-simulate-user-interaction-on-a-react-component">now</a> - and there they are looking for controls in a constructed tree by some criteria and they are pressed .  The second way is bad because the test is attached to the markup where it is generally not needed for the test logic (and creates an extra dependence on the markup in this way, and distracts from the essence of the test), and also because it is not quite correct (actually, a user is often triggered by several events at once, and even if only one component is interested in a component, it is somehow ugly to do an ‚Äúincomplete imitation‚Äù  The first one is bad because, firstly, there is no reason to output the increment into public api (the component generally does not have to have any api other than that which the reactor needs, including injection of the props), and secondly, if there is something in onClick something more complicated than {increment} - for example, {() =&gt; if (this.state.count&gt; 0) decrement ();} - then we will not test this additional binding. <br><br>  For the time being, it seems to me that in order to get a reasonable answer, one must choose the right point of view.  Nontrivial handlers inside the markup should be discarded;  they are tempting from the point of view of brevity, allowing on-site translation of the ‚Äúinternal‚Äù interpretation of the event (click on the + button) into interpretation in terms of the component's assignment (call to increase the counter), without dividing a separate method for this, but it hits testability.  In the example with increment, it is wrong to imitate user actions by calling increment, since increment is a user action already expressed in terms of the component‚Äôs purpose, and contracts for components (which we check) usually in terms of terms look like ‚Äúwhen you press such a button, that ";  therefore, part of the contract is precisely the event ‚Äúpressing the + button‚Äù, and not ‚Äúa command to increase the counter.‚Äù <br><br>  And since we recognize events as part of a contract, then suddenly they have the right to be public.  That is, in fact, the component is divided into markup and the controller, and we test them separately;  and therefore the controller has its own api, which must be visible from the markup and therefore public.  And if we consider a class (on the basis of which a component is created) precisely as a controller task, then it is this class that can publish it;  that is, it is quite reasonable to call these "control signals" of the controller via "getInstance (). onPlusButtonClick ()".  However, in the general case, then you need to create an event object (and from the perfectionism ideas, more or less correct), which will be submitted to the input.  But in many cases this can be avoided: let ‚Äútranslate‚Äù events directly in the markup should not be written, but such things as (event) =&gt; onTextChange (event.value) look, perhaps, innocuously enough not to test them, but then the signal can be fed to the event not just the text. <br><br>  But perhaps this is all heading up in the clouds, and if your components are small and simple, it's easier not to bathe and write anything you like directly in the label, and then find the buttons and poke them.  It seems that what I suggested above should not bring tangible discomfort, but in essence, except on tests, the decision made here will not affect anything, and the beauty of tests is probably not that important - you can go the way ‚Äúless restrictions freedom of developers. "  Let's see what the progressive public will write :) <br><br>  <b>3</b> <br><br>  But the generated markup is also part of the component contract =) But here again the question is - to what extent?  In part, markup is just an implementation.  It is still unclear to me how to separate the important from the unimportant in the markup (well, apart from making the specifics of the design in CSS).  In principle, if the whole markup is considered a contract, then jest offers regression testing by comparing with the standard;  but if we know which parts of the markup are important to us, we can check them by analyzing the generated DOM.  Here are just a very verbose analysis work.  So far, I still tend to compare with the standard, although it is not very clean. <br><br>  Developing a markup analysis method is not the only task that needs to be solved in order to test the markup.  After all, we are testing how the component looks at some moment of work - after some actions.  And the actions themselves are not very correct to launch during the same test (at least - even if it is clear how to do it).  It seems to me that since the markup is the product of the computation of the state function and the props, then you should simply give it a state and a props, which simulates the performance of these previous actions;  that is, the test is formulated as ‚Äúcheck how the markup looks in the state when the second tab is selected in the application and the table shows the second page of the reference data set‚Äù.  And here the question arises, how to describe such a state in a test: 1) where does the test know the structure of the component state, is it part of the implementation, not the contract, 2) how it should form the correct state (should this be an uncontrolled creation of an object by simple enumeration properties and values, or should be provided ‚Äî not even for tests, but for real life ‚Äî some kind of builder, with whom the component guarantees the correctness of the state being formed). <br><br>  As for privacy, the point of view again arises.  If the state of the component is a black box, then the parent really either doesn‚Äôt deal with the state of the child components at all, or it gives the children access to some function that allows reading or changing the state, but at the same time does not know about the composition of the state itself.  But another approach is possible, similar to the one used in the .VVM paradigm in .Net: the state in this case is a kind of ViewModel model describing the view, and the components of this view are tied to the parts of this model that interest them.  Then the ViewModel structure is self-valued: by controlling it, we manage the state of the components, reading it - read the state saved by the controls.  And then it becomes natural to make the ViewModel properties public - not in the sense that all child controls freely access the model and read from anywhere and write anywhere, but in the fact that at some top level where the ViewModel is stored, we know what it looks like (what properties it describes and in what format) the state of each component, and we can, including in the test, set a state in which we want to check how the component is rendered. <br><br>  Above, at the end of part 1, I wrote about the variant when instead of setState the component applies some other mechanism, and the model described here is just a good example of this approach.  Somewhere the ViewModel is stored, the child components are given parts of it in props, and so that the component can affect some X property from the ViewModel, it can be passed to the props called setX some f (x), which essentially makes viewModel.prop1 : = x.  Of course, in fact, f (x) should be more cunning - not just synchronously changing the state and everything, but acting somehow like setState.  As one of the options, you can probably have a real state at the top level of components, and children can lower accessors that will be implemented through the setState of this top component.  Another option is some well-known external storage mechanism like Redux. <br><br>  But how to create a guaranteed correct state - I have not thought it through yet.  If it was only about testing, God would be with him.  But since the ViewModel has a publicly known structure and allows changes to be made to it from outside the view (in our case, from tests), then from a formal point of view, it would be nice to provide some state manipulation methods such that they receive no more parameters than necessary, and guaranteed to put a consistent state.  Something like gotoFirstPage (), which itself understands that the current page number should be 1, and also knows that the ‚Äúprevious page number‚Äù should be set to null in this case (just an example invented). </div><p>Source: <a href="https://habr.com/ru/post/332090/">https://habr.com/ru/post/332090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332080/index.html">Hackers and exchanges: how to attack the sphere of finance</a></li>
<li><a href="../332082/index.html">Integration of 1C with DLL using Python</a></li>
<li><a href="../332084/index.html">Work with heterogeneous containers with C ++ 17</a></li>
<li><a href="../332086/index.html">Automatic application deployment with Maven and Wildfly</a></li>
<li><a href="../332088/index.html">Tasks with interviews. Three adequate tasks to "think"</a></li>
<li><a href="../332092/index.html">Nelder-Mead optimization method. Python implementation example</a></li>
<li><a href="../332094/index.html">Creating a blog engine with Phoenix and Elixir / Part 9. Channels</a></li>
<li><a href="../332098/index.html">How to protect corporate storage from encryption viruses with snapshots</a></li>
<li><a href="../332100/index.html">Tips for using FactoryGirl without ORM</a></li>
<li><a href="../332106/index.html">Quantum computer: a big boost game. Lecture in Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>