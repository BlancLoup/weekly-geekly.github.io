<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development and application of the PAM module for authentication in Astra Linux using Rutoken EDS and Rutoken S</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I would like to talk about how applications in Linux can use the Pluggable Authentication Modules system for transparent user authent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development and application of the PAM module for authentication in Astra Linux using Rutoken EDS and Rutoken S</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/750/d12/bd4/750d12bd43ec2b9d4122c46730f93133.png"><br><br>  In this article, I would like to talk about how applications in Linux can use the Pluggable Authentication Modules system for transparent user authentication.  We dig a little in the history of the development of authentication mechanisms in Linux, let's deal with the PAM settings system and analyze the source code of the authentication module pam_p11, which allows user authentication using smart cards. <br>  At the end of the article, we will consider in practice the configuration and operation of the authentication module in the certified for security class 3 CBT and Level 2 control of the absence of undeclared capabilities of the Astra Linux distribution for USB authentication tokens Rutoken EDS and Rutoken S. Given that Rutoken S has FSTEC certificates on NDV 3, and Rutoken e-signature on NDV 4, this solution can be used in information systems that process confidential information, up to information marked ‚ÄúC‚Äù. <br><a name="habracut"></a><br><h4>  A bit of history </h4><br>  In the good old days, if an application in Linux was required to request user authentication, then it had to access the / etc / passwd and / etc / shadow files.  This approach was as simple as a traffic jam, but at the same time, developers had to think not only about working with files, but also about security issues.  In this regard, it became necessary to develop a transparent user authentication mechanism, independent of the method of storing information about their accounts. <br>  The solution was the Linux-PAM project.  By the way, the PAM architecture itself was first proposed by Sun in October 1995, and in August 1996, the Linux-PAM infrastructure was included in the Red Hat Linux distribution.  There are currently three main implementations of PAM: <br><ol><li>  Linux-PAM is the main implementation of the PAM architecture, which we consider in this article. </li><li>  OpenPAM is an alternative implementation of PAM used in BSD systems and Mac OS X </li><li>  Java PAM - Java wrapper over Linux-PAM </li></ol><br><h4>  PAM structure </h4><br>  First, let's look at what PAM module is.  Modules are libraries in which handlers are written for operations that PAM itself can send to them.  For example, the standard pam_unix module can do the following: <br><ul><li>  Request a password from the user and verify the entered value stored in the system </li><li>  Check if the password meets security requirements and has not expired. </li></ul><br>  The following is a general overview of how PAM works. <br><img src="https://habrastorage.org/storage2/262/e96/414/262e96414cadfa1aa4ff3b5e60aae8b9.png"><br>  A heavily simplified authentication scheme in an application using PAM looks like this: <br><ol><li>  The application initializes the PAM library (libpam.so) </li><li>  PAM refers to the required modules according to the configuration file for the application. </li><li>  Modules perform the actions assigned to them. </li><li>  The application returns the result of the operation. </li></ol><br>  Of course, PAM allows for more than authentication.  PAM functions are classified by module type.  In parentheses are the designations of the modules in the configuration files: <br><ul><li>  Authentication (auth) </li><li>  Account Management (account) </li><li>  Session Management </li><li>  Password Management (passwd) </li></ul><br>  Now we are only interested in authentication, so we‚Äôll leave the remaining functions to the reader‚Äôs curiosity. <br><br><h4>  PAM configuration </h4><br>  If the application requires authentication, then it should create a file with its own name in the /etc/pam.d directory, in which the modules to be authenticated and other actions should be specified.  Let's see what is in the /etc/pam.d directory in Ubuntu 11.10 <br><pre><code class="bash hljs">$ ls /etc/pam.d/ atd common-account common-session-noninteractive lightdm other samba vmtoolsd chfn common-auth cron lightdm-autologin passwd sshd chpasswd common-password cups login polkit-1 su chsh common-session gnome-screensaver newusers ppp sudo</code> </pre> <br>  For example, look at the abstract configuration file for the login application. <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># PAM configuration for login auth requisite pam_securetty.so auth required pam_nologin.so auth required pam_env.so auth required pam_unix.so nullok account required pam_unix.so session required pam_unix.so session optional pam_lastlog.so password required pam_unix.so nullok obscure min=4 max=8</span></span></code> </pre><br>  Each line of the config is written as <br><pre> <code class="bash hljs">&lt; &gt; &lt; &gt; &lt;  &gt; &lt;&gt;</code> </pre><br><ul><li>  The type of module corresponds to the designations of the modules themselves (ie, auth / account / session / passwd) </li><li>  The control flag indicates the criticality of the module for successful operation.  The flag can have the following values: requisite (required), required (required), sufficient (sufficient) and optional (optional). </li><li>  The library path sets the path to the module file.  By default, they are searched in / lib / security / </li><li>  Parameters specify the list of arguments that will be passed to the module.  Arguments are passed in a manner similar to the argc / argv principle in the main () function, except that argv [0] contains not a module name, but a specific argument. </li></ul><br>  Thus, we get a stack of modules, each of which performs its own action.  PAM at the same time parses the stack as it should be - from top to bottom.  In accordance with the control flag, the following requirements are set for the success of the operation: <br><ul><li>  requisite (required): if the stack module returns a negative response, the request is immediately rejected.  Other modules will not be executed. </li><li>  required (required): if one or more stack modules return a negative response, all other modules will be executed, but the application request will be rejected. </li><li>  sufficient (sufficient): if the module is marked as sufficient and in front of it none of the necessary or sufficient modules returned a negative response, then all remaining modules in the stack are ignored, and a positive response is returned. </li><li>  optional (optional): if there are no required modules in the stack, and if none of the sufficient modules returned a positive response, then at least one of the additional modules of the application or service should return a positive response </li></ul><br>  Module configuration files are stored in / usr / share / pam-configs / &lt;module name&gt;.  Each file contains the full name of the module, whether it is enabled by default, module priority and authentication parameters. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Development of an authentication module for PAM </h4><br>  In this section, we will examine the source code of the pam_p11 module and consider the main points that should be paid attention to when writing your own module. <br><br><h5>  pam_p11 </h5><br>  This module allows two-factor user authentication using smart cards or USB tokens using asymmetric cryptography.  Consider the general scheme of his work: <br><ul><li>  The user certificate and its private key are stored on the token. </li><li>  The certificate is also stored in the user's home directory as trusted. </li></ul><br>  Authentication is as follows: <br><ol><li>  The token is searched for a user certificate. </li><li>  A PIN is requested to the token via PAM </li><li>  If authentication on the token is successful, then random data is signed using the private key from the token.  The signature itself is performed by hardware. </li><li>  The received EDS is verified using a user certificate. </li></ol><br>  If, as a result, the signature verification is carried out successfully, then the module says outside that everything is fine. <br>  In this scheme, the RSA key pair of length 2048 bits is used, generated by hardware on a token. <br><br><h5>  Actually the development of the module </h5><br>  Depending on the functionality of the module, PAM may require the following functions from it: <br><ul><li>  pam_sm_authenticate, pam_sm_setcred - authentication </li><li>  pam_sm_acct_mgmt - account management </li><li>  pam_sm_chauthtok - password management </li><li>  pam_sm_open_session, pam_sm_close_session - session management </li></ul><br>  In order for the module to perform authentication, we need to implement the functions pam_sm_authenticate and pam_sm_setcred in it.  In the remaining functions, it is enough just to add stubs so that our module cannot be used for other operations. <br>  To work with PAM, you need to define special constants, and only then connect the header files: <br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PAM_SM_AUTH #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PAM_SM_ACCOUNT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PAM_SM_SESSION #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PAM_SM_PASSWORD #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;security/pam_appl.h&gt; #include &lt;security/pam_modules.h&gt;</span></span></span></span></code> </pre><br>  These constants are necessary so that PAM knows that our module can perform all the functions described above.  Of course, if we implement only authentication, then the remaining functions can be discarded, but the developers of pam_p11 decided that it would be safer to put stubs instead of unused functions. <br>  Let's start writing the pam_sm_authenticate function.  It has the following signature: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">PAM_EXTERN </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pam_sm_authenticate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pam_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pamh, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv)</span></span></span></span>;</code> </pre><br>  Of the important parameters here it is worth noting: <br><ul><li>  pamh - the handle to PAM received by the application </li><li>  argc, argv - the arguments specified in the configuration file.  Our module takes one argument - the path to the PKCS # 11 library </li></ul><br>  The function should return one of the following values: <br><ul><li>  PAM_AUTH_ERR - authentication error </li><li>  PAM_CRED_INSUFFICIENT - the application does not have sufficient permissions to perform authentication </li><li>  PAM_AUTHINFO_UNAVAIL - the module could not get the information to perform authentication.  This may happen due to network problems or other equipment failure. </li><li>  PAM_SUCCESS - authentication was successful </li><li>  PAM_USER_UNKNOWN - the user with the transferred name does not exist </li><li>  PAM_MAXTRIES - one or more authentication modules exceeded the allowed retry limit. </li></ul><br>  Inside our module, we will use the libp11 library to work with the PKCS # 11 API and OpenSSL to work with certificates. <br>  First, we define the variables that we need: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, rv; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *user; <span class="hljs-comment"><span class="hljs-comment">//   char *password; //    char password_prompt[64]; //    ,   //  PAM struct pam_conv *conv; //   PAM struct pam_message msg; //   PAM struct pam_message *(msgp[1]); struct pam_response *resp; //  PAM //  lib_p11: PKCS11_CTX *ctx; //  PKCS#11 PKCS11_SLOT *slot, *slots; //  PKCS11_CERT *certs; //  unsigned int nslots, ncerts; PKCS11_KEY *authkey; //   PKCS11_CERT *authcert; //  EVP_PKEY *pubkey; //   OpenSSL    unsigned char rand_bytes[RANDOM_SIZE]; unsigned char signature[MAX_SIGSIZE]; int fd; unsigned siglen;</span></span></code> </pre><br>  Then check if the PKCS # 11 library path is passed to us. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argc != <span class="hljs-number"><span class="hljs-number">1</span></span>) { pam_syslog(pamh, LOG_ERR, <span class="hljs-string"><span class="hljs-string">"need pkcs11 module as argument"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PAM_ABORT; }</code> </pre><br>  After that, we initialize OpenSSL and the PKCS # 11 context. <br><pre> <code class="cpp hljs">OpenSSL_add_all_algorithms(); ERR_load_crypto_strings(); ctx = PKCS11_CTX_new();</code> </pre><br>  Ask PAM for a username. <br><pre> <code class="cpp hljs">rv = pam_get_user(pamh, &amp;user, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rv != PAM_SUCCESS) { pam_syslog(pamh, LOG_ERR, <span class="hljs-string"><span class="hljs-string">"pam_get_user() failed %s"</span></span>, pam_strerror(pamh, rv)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PAM_USER_UNKNOWN; }</code> </pre><br>  Now let's load the PKCS # 11 library, find the first available token and get certificates from it <br><pre> <code class="cpp hljs">rv = PKCS11_CTX_load(ctx, argv[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rv) { pam_syslog(pamh, LOG_ERR, <span class="hljs-string"><span class="hljs-string">"loading pkcs11 engine failed"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PAM_AUTHINFO_UNAVAIL; } <span class="hljs-comment"><span class="hljs-comment">//     PKCS#11 rv = PKCS11_enumerate_slots(ctx, &amp;slots, &amp;nslots); if (rv) { pam_syslog(pamh, LOG_ERR, "listing slots failed"); return PAM_AUTHINFO_UNAVAIL; } //      slot = PKCS11_find_token(ctx, slots, nslots); if (!slot || !slot-&gt;token) { pam_syslog(pamh, LOG_ERR, "no token available"); rv = PAM_AUTHINFO_UNAVAIL; goto out; } //     rv = PKCS11_enumerate_certs(slot-&gt;token, &amp;certs, &amp;ncerts); if (rv) { pam_syslog(pamh, LOG_ERR, "PKCS11_enumerate_certs failed"); rv = PAM_AUTHINFO_UNAVAIL; goto out; } if (ncerts &lt;= 0) { pam_syslog(pamh, LOG_ERR, "no certificates found"); rv = PAM_AUTHINFO_UNAVAIL; goto out; }</span></span></code> </pre><br>  Now, among the certificates on the token, we find the one we have in ~ / .eid / authorized_certificates: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ncerts; i++) { authcert = &amp;certs[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (authcert != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* ,        */</span></span> rv = match_user(authcert-&gt;x509, user); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rv &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { pam_syslog(pamh, LOG_ERR, <span class="hljs-string"><span class="hljs-string">"match_user() failed"</span></span>); rv = PAM_AUTHINFO_UNAVAIL; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rv == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* this is not the cert we are looking for */</span></span> authcert = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!authcert) { pam_syslog(pamh, LOG_ERR, <span class="hljs-string"><span class="hljs-string">"no matching certificates found"</span></span>); rv = PAM_AUTHINFO_UNAVAIL; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; }</code> </pre><br>  And now the most interesting thing is that we need to request a user password via PAM (which in our case will be a PIN to the token), and then authenticate to the token <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    PAM      rv = pam_get_item(pamh, PAM_AUTHTOK, (void *)&amp;password); if (rv == PAM_SUCCESS &amp;&amp; password) { password = strdup(password); } else { //    ,      sprintf(password_prompt, "Password for token %.32s: ", slot-&gt;token-&gt;label); //    PAM:     "" msg.msg_style = PAM_PROMPT_ECHO_OFF; msg.msg = password_prompt; //      PAM rv = pam_get_item(pamh, PAM_CONV, (const void **)&amp;conv); if (rv != PAM_SUCCESS) { rv = PAM_AUTHINFO_UNAVAIL; goto out; } if ((conv == NULL) || (conv-&gt;conv == NULL)) { rv = PAM_AUTHINFO_UNAVAIL; goto out; } //   ,      resp rv = conv-&gt;conv(1, (const struct pam_message **)msgp, &amp;resp, conv-&gt;appdata_ptr); if (rv != PAM_SUCCESS) { rv = PAM_AUTHINFO_UNAVAIL; goto out; } if ((resp == NULL) || (resp[0].resp == NULL)) { rv = PAM_AUTHINFO_UNAVAIL; goto out; } //       password = strdup(resp[0].resp); memset(resp[0].resp, 0, strlen(resp[0].resp)); free(&amp;resp[0]); }</span></span></code> </pre><br>  Now we can perform authentication on the token: <br><pre> <code class="cpp hljs">rv = PKCS11_login(slot, <span class="hljs-number"><span class="hljs-number">0</span></span>, password); <span class="hljs-comment"><span class="hljs-comment">//    ,    memset(password, 0, strlen(password)); free(password); if (rv != 0) { pam_syslog(pamh, LOG_ERR, "PKCS11_login failed"); rv = PAM_AUTHINFO_UNAVAIL; goto out; }</span></span></code> </pre><br>  This concludes the first stage of authentication.  Now we need to check if the owner of the token has a private key.  To do this, we calculate the EDS for an arbitrary data block and check it with the help of a trusted certificate. <br>  For starters, count 128 bytes from / dev / random <br><pre> <code class="cpp hljs">fd = open(RANDOM_SOURCE, O_RDONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { pam_syslog(pamh, LOG_ERR, <span class="hljs-string"><span class="hljs-string">"fatal: cannot open RANDOM_SOURCE: "</span></span>); rv = PAM_AUTHINFO_UNAVAIL; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; } rv = read(fd, rand_bytes, RANDOM_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rv &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { pam_syslog(pamh, LOG_ERR, <span class="hljs-string"><span class="hljs-string">"fatal: read from random source failed: "</span></span>); close(fd); rv = PAM_AUTHINFO_UNAVAIL; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rv &lt; RANDOM_SIZE) { pam_syslog(pamh, LOG_ERR, <span class="hljs-string"><span class="hljs-string">"fatal: read returned less than %d&lt;%d bytes\n"</span></span>, rv, RANDOM_SIZE); close(fd); rv = PAM_AUTHINFO_UNAVAIL; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; } close(fd);</code> </pre><br>  Then we will get the private key corresponding to the certificate and sign random data on it. <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      authkey = PKCS11_find_key(authcert); if (!authkey) { pam_syslog(pamh, LOG_ERR, "no key matching certificate available"); rv = PAM_AUTHINFO_UNAVAIL; goto out; } //    siglen = MAX_SIGSIZE; rv = PKCS11_sign(NID_sha1, rand_bytes, RANDOM_SIZE, signature, &amp;siglen, authkey); if (rv != 1) { pam_syslog(pamh, LOG_ERR, "fatal: pkcs11_sign failed\n"); rv = PAM_AUTHINFO_UNAVAIL; goto out; }</span></span></code> </pre><br>  Check the signature.  To do this, first, using OpenSSL, we will get the public key from the certificate, and then execute the verification of the EDS <br><pre> <code class="cpp hljs">pubkey = X509_get_pubkey(authcert-&gt;x509); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pubkey == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { pam_syslog(pamh, LOG_ERR, <span class="hljs-string"><span class="hljs-string">"could not extract public key"</span></span>); rv = PAM_AUTHINFO_UNAVAIL; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; } <span class="hljs-comment"><span class="hljs-comment">//      OpenSSL rv = RSA_verify(NID_sha1, rand_bytes, RANDOM_SIZE, signature, siglen, pubkey-&gt;pkey.rsa); if (rv != 1) { pam_syslog(pamh, LOG_ERR, "fatal: RSA_verify failed\n"); rv = PAM_AUTHINFO_UNAVAIL; goto out; }</span></span></code> </pre><br>  If the signature verification is successful, then we can exit the PKCS # 11 library and return PAM_SUCCESS. <br><pre> <code class="cpp hljs"> rv = PAM_SUCCESS; out: PKCS11_release_all_slots(ctx, slots, nslots); PKCS11_CTX_unload(ctx); PKCS11_CTX_free(ctx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv;</code> </pre><br>  Instead of the rest of the functions, we leave to no one interesting stubs, assemble a module and proceed to its configuration and use. <br><br><h4>  Practical use </h4><br>  As an experimental distribution, you could get a fresh Ubuntu, but considering that everything works too well at 12.04, we decided to use authentication for the common cause to authenticate the Astra Linux Special Edition operating system using USB-tokens Rutoken EDS in Smolensk release Rutoken S. <br><img src="http://habrastorage.org/storage2/619/6f0/3a7/6196f03a7fea532f1dcc3857649a1305.png"><br><h5>  Installing additional packages </h5><br>  To begin with, I had to install some packages.  For the work of Rutoken S, the old version of OpenSC is needed: 0.11.13, and for the work of Rutoken EDS, a newer version: 0.12.2.  OpenCT version 0.6.20 is used as middleware for both tokens. <br>  As a result, the packages delivered by the developers of the distribution were delivered: <br><ul><li>  libopenct1 (0.6.20-1.2): libopenct1_0.6.20-1.2_amd64.deb </li><li>  openct (0.6.20-1.2): openct_0.6.20-1.2_amd64.deb </li></ul><br><h6>  For Rutoken S </h6><br><ul><li>  libopensc2_0.11.13-1.1_amd64.deb </li><li>  opensc_0.11.13-1.1_amd64.deb </li><li>  mozilla-opensc_0.11.13-1.1_amd64.deb </li></ul><br><h6>  For Rutoken EDS </h6><br><ul><li>  opensc (0.12.2-2): opensc_0.12.2-2_amd64.deb </li></ul><br>  When installing the opensc version, it was necessary to satisfy the dependencies of the packages.  To do this, the following packages were taken from the Debian squeeze repository: <br><ul><li>  libltdl7 (&gt; = 2.2.6b): libltdl7_2.2.6b-2_amd64.deb </li><li>  libssl0.9.8 (&gt; = 0.9.8m-1): libssl0.9.8_0.9.8o-4squeeze11_amd64.deb </li></ul><br><h5>  PAM module and its dependencies </h5><br>  To implement authentication by token, the following packages were installed: <br><ul><li>  libp11-1 (0.2.7-2): libp11-1_0.2.7-2_amd64.deb </li><li>  libpam-p11 (0.1.5-1): libpam-p11_0.1.5-1 + b1_amd64.deb </li><li>  libengine-pkcs11-openssl (0.1.8-2): libengine-pkcs11-openssl_0.1.8-2_amd64.deb </li></ul><br><h5>  Configure pam_p11 </h5><br>  Fortunately, we almost never have to edit configs with our hands.  Just create the file / usr / share / pam-configs / p11 with the following content: <br><pre> <code class="bash hljs">Name: Pam_p11 Default: yes Priority: 800 Auth-Type: Primary Auth: sufficient pam_p11_opensc.so /usr/lib/opensc-pkcs11.so</code> </pre><br>  The interest is provided by the last line of the config, in which we indicate the type of the module, the name of the library and the parameters passed to the module.  Our module takes as a parameter the path to the PKCS # 11 library. <br>  Now we just have to execute the command. <br><pre> <code class="bash hljs">$ pam-auth-update</code> </pre><br>  In the dialog that appears, you must select pam_p11.  If you want to disable password authentication, you can disable Unix authentication.  Since it was stated in the profile configuration file that the module will be ‚Äúsufficient‚Äù, then upon receipt of the PAM_SUCCESS response from our module, the entire authentication process will be considered successful. <br><img src="http://habrastorage.org/storage2/511/153/d0a/511153d0ae12a71d8f10dc02e155b0e0.png"><br><h5>  Key and certificate creation </h5><br>  To begin with, we create a key pair RSA of length 2048 bits with ID ‚Äú45‚Äù (id should be remembered, you will need it when creating the certificate). <br><pre> <code class="bash hljs">$ pkcs15-init --generate-key rsa/2048 --auth-id 02 --id 45 &lt; PIN &gt;</code> </pre><br>  Check the generated key: <br><pre> <code class="bash hljs">$ pkcs15-tool --list-keys Using reader with a card: Aktiv Rutoken ECP 00 00 Private RSA Key [Private Key] Object Flags : [0x3], private, modifiable Usage : [0x4], sign Access Flags : [0x1D], sensitive, alwaysSensitive, neverExtract, <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> ModLength : 2048 Key ref : 1 (0x1) Native : yes Path : 3f001000100060020001 Auth ID : 02 ID : 45</code> </pre><br>  Now, using OpenSSL, we will create a self-signed certificate.  We start openssl and load the pkcs11 support module: <br><pre> <code class="bash hljs">$ openssl OpenSSL&gt; engine dynamic -pre SO_PATH:/usr/lib/engines/engine_pkcs11.so -pre ID:pkcs11 -pre LIST_ADD:1 -pre LOAD -pre MODULE_PATH:opensc-pkcs11.so (dynamic) Dynamic engine loading support [Success]: SO_PATH:/usr/lib/engines/engine_pkcs11.so [Success]: ID:pkcs11 [Success]: LIST_ADD:1 [Success]: LOAD Loaded: (pkcs11) pkcs11 engine</code> </pre><br>  Create a certificate in PEM format: <br><pre> <code class="bash hljs">OpenSSL&gt; req -engine pkcs11 -new -key 1:45 -keyform engine -x509 -out cert.pem ‚Äìtext</code> </pre><br>  In the last command, 1:45 is a pair: &lt;key id&gt;.  Thus, we created a certificate based on a key pair stored on a token.  In this case, a certificate file with the name cert.pem should be created in the current directory. <br>  Now save the certificate for the token: <br><pre> <code class="bash hljs">$ pkcs15-init --store-certificate cert.pem --auth-id 02 --id 45 --format pem &lt; PIN &gt;</code> </pre><br><br><h5>  Entering the certificate in the list of trusted </h5><br>  At this stage, all we need to do is read the certificate with the required ID from the token and write it to the trusted certificate file: <br><pre> <code class="bash hljs">$ mkdir ~/.eid $ chmod 0755 ~/.eid $ pkcs15-tool -r &lt;certificate_id&gt; &gt; ~/.eid/authorized_certificates $ chmod 0644 ~/.eid/authorized_certificates</code> </pre><br><br><h4>  Conclusion </h4><br>  In the article I tried to consider the mechanism of work of PAM, without particularly delving into the specifics of the work of its internal functions.  In this regard, such things as the PAM dialog mechanism, functions for working with PAM structures, and some subtleties of setting the entire system remained without special attention.  By themselves, they claim a separate article, so if there is interest, I can describe them in a new article. <br>  The described steps for setting up an authentication system can be used as an instruction in any modern Linux distribution. </div><p>Source: <a href="https://habr.com/ru/post/144700/">https://habr.com/ru/post/144700/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144688/index.html">Cradle review for HTC Sensation</a></li>
<li><a href="../144689/index.html">Erlang, Cassandra: First Steps</a></li>
<li><a href="../144692/index.html">Some search in cold water</a></li>
<li><a href="../144693/index.html">PHP founder, Rasmus Lerdorf will give a master class at DevConf 2012 June 10</a></li>
<li><a href="../144694/index.html">Sean Parker launches new project</a></li>
<li><a href="../144701/index.html">Using Windows Azure in a bootstrapping SaaS startup</a></li>
<li><a href="../144703/index.html">Smashing Magazine refused button Like</a></li>
<li><a href="../144705/index.html">Eric Schmidt: disconnect from computers for an hour every day</a></li>
<li><a href="../144706/index.html">Electronic door peephole</a></li>
<li><a href="../144707/index.html">Qt / Objective-C ++ 11 or building a Qt project using GCC-4.7 and Clang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>