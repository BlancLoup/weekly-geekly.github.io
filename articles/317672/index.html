<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Code optimization for the Elbrus platform using simple examples</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Usually a hacker does not write programs for the benefit of 
 but for your own pleasure. Such a program 
 may be useful or may remain 
 just a game o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Code optimization for the Elbrus platform using simple examples</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>"Usually a hacker does not write programs for the benefit of</em> <em><br></em>  <em>but for your own pleasure.</em>  <em>Such a program</em> <em><br></em>  <em>may be useful or may remain</em> <em><br></em>  <em>just a game of intelligence. "</em> <em><br></em>  <em>Henry S. Warren.</em>  <em>Algorithmic tricks for programmers [1]</em> </p><br><p>  Today we will continue our notes on Elbrus.  The first article dedicated to the launch and optimization of the passport recognition system can be found <a href="https://habrahabr.ru/company/smartengines/blog/304750/">here</a> . </p><br><p><img src="https://habrastorage.org/files/b40/23f/af1/b4023faf1bdc4e849f5b75c468e44e20.jpg" alt="image"></p><br><p>  Once, my colleagues and I became interested in how the simplest optimization methods work on Elbrus. </p><a name="habracut"></a><br><p>  The Elbrus processor has a VLIW (Very Long Instruction Word) architecture - that is, it operates with ‚Äúwide‚Äù command words.  This means that the lcc compiler analyzes the source code of the program during compilation, determines the dependencies between the commands, and generates broad command words.  In one such word, you can fit up to 23 actions that will be performed simultaneously.  If you use SIMD (Single Instruction Multiple Data), then this number can increase to 33 or more operations.  Commands in a broad word are executed in parallel, ensuring the loading of all 6 arithmetic logic devices on each processor.  Parallelization and loading of all calculators entirely falls on the shoulders of the optimizing compiler, which allows to significantly simplify the equipment for analysis and execution of commands and reduce energy consumption to 45 W for Elbrus-4C [2, 3]. </p><br><p>  We at Smart Engines have wondered how all the usual optimizations will work, such as, for example, loop deployment, on such an unusual platform with a ‚Äúsmart‚Äù compiler. </p><br><p>  We looked at simple C ++ examples and compared the results of work on Elbrus-4C and Intel Core i7-6700K.  On Elbrus, the lcc compiler version 1.20.17 was used, for the Core i7, the Microsoft Visual Studio Community 2015. For lcc we used the compilation flags -O3 and -ffast-math. </p><br><p>  To begin with, we give the characteristics of Elbrus-4C and Intel Core i7-6700K: </p><br><table><thead><tr><th></th><th>  Elbrus-4C </th><th>  Intel Core i7-6700K </th></tr></thead><tbody><tr><td>  Architecture </td><td>  Elbrus </td><td>  Skylake-s </td></tr><tr><td>  Frequency, GHz </td><td>  0.8 </td><td>  four </td></tr><tr><td>  Number of cores </td><td>  four </td><td>  4 (8 with Hyper-Threading) </td></tr><tr><td>  Technological process </td><td>  65 nm </td><td>  14 nm </td></tr><tr><td>  Cache L1 size, data </td><td>  64 Kb </td><td>  32 Kb </td></tr><tr><td>  Cache L1 size, instructions </td><td>  128 Kb </td><td>  32 Kb </td></tr><tr><td>  Cache l2 size </td><td>  8 Mb </td><td>  1 Mb </td></tr><tr><td>  Cache L3 size </td><td>  - </td><td>  8 Mb </td></tr><tr><td>  Type of RAM </td><td>  DDR3-1600 </td><td>  DDR4-2133 </td></tr><tr><td>  Power consumption, W </td><td>  45 </td><td>  91 </td></tr></tbody></table><br><p>  The clock speed of these processors is significantly different: 800 MHz for the Elbrus-4C and 4 GHz for the Intel Core i7.  Also note that Elbrus has a different cache structure: there is no L3 cache, but the L2 cache size is 8 Mb (2 Mb per core), while the considered Core i7 1 Mb (0.25 Mb per core).  The L1 cache on Elbrus is also larger, especially the instruction cache (128 Kb vs. 32 Kb). </p><br><p>  <strong>Example 1. Deploying loops</strong> </p><br><p>  This optimization is aimed at reducing the number of iterations of the cycle (and hence reducing the number of checks for the condition of exiting the cycle) by increasing the body of the cycle.  Such optimization is well suited for simple cycles that occur in virtually every program. </p><br><p>  Now consider an example: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N 64000 unsigned int x = 0; unsigned int a[N]; for (int i = 0; i &lt; N; ++i) a[i] = i; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  for (int k = 0; k &lt; N;) { x += a[k]; a[k++] = k; }</span></span></span></span></code> </pre> <br><p>  The last cycle we tried to deploy.  The results of measurements of time (for 10,000 iterations of the cycle) are given in Table 1. It is worth noting that Elbrus used a 32-bit addressing mode (the compiler flag -mpr32).  We also calculated the operating time at 1 GHz by multiplying the measured time by the processor clock frequency in GHz.  The dimensionless quantity obtained in this way makes it possible to compare the performance of the Elbrus and the Core i7, taking into account the difference in the clock frequency. </p><br><p>  Table 1. Running time as a function of N ‚Äî the number of deployed iterations. </p><br><table><thead><tr><th></th><th>  Elbrus-4C </th><th>  Elbrus-4C </th><th>  Intel Core i7 </th><th>  Intel Core i7 </th></tr></thead><tbody><tr><td>  N </td><td>  Time, ms </td><td>  Time in terms of 1 GHz </td><td>  Time, ms </td><td>  Time in terms of 1 GHz </td></tr><tr><td>  one </td><td>  401 </td><td>  320 </td><td>  255 </td><td>  1020 </td></tr><tr><td>  2 </td><td>  400 </td><td>  320 </td><td>  275 </td><td>  1100 </td></tr><tr><td>  four </td><td>  401 </td><td>  320 </td><td>  261 </td><td>  1044 </td></tr><tr><td>  eight </td><td>  401 </td><td>  320 </td><td>  247 </td><td>  988 </td></tr><tr><td>  sixteen </td><td>  401 </td><td>  320 </td><td>  361 </td><td>  1444 </td></tr><tr><td>  32 </td><td>  452 </td><td>  362 </td><td>  262 </td><td>  1048 </td></tr><tr><td>  64 </td><td>  451 </td><td>  362 </td><td>  262 </td><td>  1048 </td></tr></tbody></table><br><p>  You can see that the deployment of the cycle in this example does not give a gain in operating time on both the modern Core i7 and Elbrus-4C.  In the case of a very simple cycle, which we considered, Elbrus-4C works more efficiently than the Core i7 considering the frequency ratio. </p><br><p>  <strong>Example 2. Processing data of various lengths</strong> </p><br><p>  In this example, we process an array of 1, 4, or 8 bytes.  The original array <code></code> was aligned to 8 bytes. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK1 0xF1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK4 0xF1F2F3F4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK8 0xF1F2F3F4F5F6F7F8 for (k = 0; k &lt; n; ++k) { [k] &amp;= MASK1; }</span></span></code> </pre> <br><p>  The results of the time measurements are shown in table 2. </p><br><p>  Table 2. Operation time depending on N - the number of bytes processed. </p><br><table><thead><tr><th></th><th>  Elbrus-4C </th><th>  Elbrus-4C </th><th>  Intel Core i7 </th><th>  Intel Core i7 </th></tr></thead><tbody><tr><td>  N </td><td>  Time, ms </td><td>  Time in terms of 1 GHz </td><td>  Time, ms </td><td>  Time in terms of 1 GHz </td></tr><tr><td>  one </td><td>  2400 </td><td>  1920 </td><td>  811 </td><td>  3244 </td></tr><tr><td>  four </td><td>  600 </td><td>  480 </td><td>  201 </td><td>  804 </td></tr><tr><td>  eight </td><td>  300 </td><td>  240 </td><td>  102 </td><td>  408 </td></tr></tbody></table><br><p>  You can see that the processing of 4 and 8 bytes works faster on both the modern Core i7 and Elbrus-4C, and the times are reduced by a multiple of the number of bytes processed.  In addition, Elbrus works more efficiently than the Core i7 considering the frequency ratio. </p><br><p>  <strong>Example 3. Using SIMD</strong> </p><br><p>  In this example, we decided to test intrinsiki and examined the scalar product of <code>float</code> numbers with <code>n = 12800</code> . <br>  Non-optimized cycle: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> result = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i) { result += x[i] * y[i]; }</code> </pre> <br><p>  Using SSE: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pX = x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pY = y; __m128 Sum = _mm_setzero_ps(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = n / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; num; ++i, pX += <span class="hljs-number"><span class="hljs-number">4</span></span>, pY += <span class="hljs-number"><span class="hljs-number">4</span></span>) { Sum = _mm_add_ps(Sum, _mm_mul_ps(_mm_load_ps(pX), _mm_load_ps(pY))); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> result = _mm_extract_ps(Sum, <span class="hljs-number"><span class="hljs-number">0</span></span>) + _mm_extract_ps(Sum, <span class="hljs-number"><span class="hljs-number">1</span></span>) + _mm_extract_ps(Sum, <span class="hljs-number"><span class="hljs-number">2</span></span>) + _mm_extract_ps(Sum, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>  Using EML [4] (optimized library for Elbrus): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> result; eml_Vector_DotProd_32F(x, y, n, &amp;result);</code> </pre> <br><p>  The results of the time measurements are shown in Table 3. The size of the SIMD register on Elbrus-4C is 64 bits (instruction set version 3), which in general corresponds to the observed acceleration 2 times between the version without optimizations and the version with SIMD.  On Core i7, everything is also quite plausible, we operated on 128-bit registers, which fit 4 float numbers.  In addition, it is noticeable that Elbrus without intrinsics works more efficiently than the Core i7, taking into account the frequency, but with intrinsics the work times are almost the same. </p><br><p>  Table 3. Working hours counting scalar product. </p><br><table><thead><tr><th></th><th>  Elbrus-4C </th><th>  Elbrus-4C </th><th>  Intel Core i7 </th><th>  Intel Core i7 </th></tr></thead><tbody><tr><td></td><td>  Time, ms </td><td>  Time in terms of 1 GHz </td><td>  Time, ms </td><td>  Time in terms of 1 GHz </td></tr><tr><td>  No optimization </td><td>  263 </td><td>  210 </td><td>  99 </td><td>  396 </td></tr><tr><td>  With SIMD </td><td>  110 </td><td>  88 </td><td>  24 </td><td>  96 </td></tr></tbody></table><br><p>  <strong>Example 4. Counting Hamming distance between two arrays</strong> </p><br><p>  Here we calculated the Hamming distance between the binary representation of two arrays, i.e.  took Hamming distances between binary representations of the corresponding numbers in the arrays and found their sum.  For arrays with 8-bit data, we used a bitwise EXCLUSIVE OR and a pre-calculated distance table: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i) { result += popcnt_table[x[i] ^ y[i]]; }</code> </pre> <br><p>  For 32-bit and 64-bit data, we used bitwise logical EXCLUSIVE OR and <code>_mm_popcnt_u32, _mm_popcnt_u64</code> on Intel and <code>_mm_popcnt_u32, _mm_popcnt_u64</code> on <code>_mm_popcnt_u32, _mm_popcnt_u64</code> on Elbrus.  The total length of the x and y arrays in bytes remained unchanged and equal to n = 512. The results of the time measurements are shown in Table 4. </p><br><p>  Table 4. The counting time of the Hamming distance depending on the number of bytes N processed. </p><br><table><thead><tr><th></th><th>  Elbrus-4C </th><th>  Elbrus-4C </th><th>  Intel Core i7 </th><th>  Intel Core i7 </th></tr></thead><tbody><tr><td>  N </td><td>  Time, ms </td><td>  Time in terms of 1 GHz </td><td>  Time, ms </td><td>  Time in terms of 1 GHz </td></tr><tr><td>  one </td><td>  630 </td><td>  504 </td><td>  155 </td><td>  620 </td></tr><tr><td>  four </td><td>  110 </td><td>  88 </td><td>  47 </td><td>  188 </td></tr><tr><td>  eight </td><td>  76 </td><td>  61 </td><td>  15 </td><td>  60 </td></tr></tbody></table><br><p>  In this example, we see that intrinsiki for counting the number of units in the 64-bit and 32-bit registers on both Elbrus and Core i7 give significant acceleration relative to the version with a pre-calculated table.  In addition, the 32-bit popcnt command on Elbrus is faster than on Core i7, taking into account the frequency ratio.  But in the 64-bit case, the times of work on Core i7 and Elbrus became equal. </p><br><p>  <strong>Example 5. Eliminating data dependencies</strong> </p><br><p>  This example is borrowed from the book by Chris Kaspersky ‚ÄúSoftware Optimization Technique.  Efficient use of memory ‚Äù[5].  He demonstrates how eliminating data dependency helps improve performance.  The array <code>a</code> filled with zeros, <code>n = 2097152</code> . <br>  Data dependency example: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>; a &lt; BLOCK_SIZE; a += <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)) { x = *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)p1 + a + <span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); a += x; x = *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)p1 + a + <span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); a += x; x = *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)p1 + a + <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); a += x; x = *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)p1 + a + <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); a += x; x = *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)p1 + a + <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); a += x; x = *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)p1 + a + <span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); a += x; x = *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)p1 + a + <span class="hljs-number"><span class="hljs-number">6</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); a += x; x = *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)p1 + a + <span class="hljs-number"><span class="hljs-number">7</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); a += x; }</code> </pre> <br><p>  Each next element index depends on the value calculated by the previous command, therefore loading of elements from memory occurs sequentially, after the completion of the previous instruction. <br>  Now code without dependency: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>; a &lt; BLOCK_SIZE; a += <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)) { x += *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)p2 + a + <span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); x += *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)p2 + a + <span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); x += *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)p2 + a + <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); x += *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)p2 + a + <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); x += *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)p2 + a + <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); x += *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)p2 + a + <span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); x += *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)p2 + a + <span class="hljs-number"><span class="hljs-number">6</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); x += *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)p2 + a + <span class="hljs-number"><span class="hljs-number">7</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); }</code> </pre> <br><p>  The results of the time measurements are shown in Table 5. Eliminating data dependency works on both Elbrus and Core i7, with Core i7 working time varying about 11 times, and on Elbrus - almost 20 times!  The code with data dependency worked on Elbrus more slowly than on Core i7 in terms of 1 GHz, but without dependence Elbrus is only 4 times slower than Core i7 (with a frequency difference of 5 times).  Such results on Elbrus can be explained by the presence of an asynchronous array swap mechanism (array prefetch buffer), which works efficiently if the paged elements are arranged in series. </p><br><p>  Table 5. Time to read dependent and independent data. </p><br><table><thead><tr><th></th><th>  Elbrus-4C </th><th>  Elbrus-4C </th><th>  Intel Core i7 </th><th>  Intel Core i7 </th></tr></thead><tbody><tr><td></td><td>  Time, ms </td><td>  Time in terms of 1 GHz </td><td>  Time, ms </td><td>  Time in terms of 1 GHz </td></tr><tr><td>  Dependent data </td><td>  605 </td><td>  484 </td><td>  87 </td><td>  348 </td></tr><tr><td>  Independent data </td><td>  32 </td><td>  26 </td><td>  eight </td><td>  32 </td></tr></tbody></table><br><p>  <strong>Example 6. Multi-threaded calculations</strong> </p><br><p>  Of course, we could not but consider such an optimization method as parallelization.  For the purity of the experiment, we took completely independent tasks (calculating the scalar product of two arrays of type double).  Table 6 shows the sequential operation time of N tasks (T <sup>last</sup> ), the running time of N tasks in N threads (T <sup>pairs</sup> ) and acceleration E: </p><br><p>  Table 6. Time of sequential and parallel calculation of the scalar product depending on the number of tasks and threads N. </p><br><table><thead><tr><th></th><th>  Elbrus-4C </th><th>  Elbrus-4C </th><th>  Elbrus-4C </th><th>  Intel Core i7 </th><th>  Intel Core i7 </th><th>  Intel Core i7 </th></tr></thead><tbody><tr><td>  N </td><td>  T <sup>last</sup> ms </td><td>  T <sup>pairs</sup> , ms </td><td>  E = T <sup>last</sup> / T <sup>pairs</sup> </td><td>  T <sup>last</sup> ms </td><td>  T <sup>pairs</sup> , ms </td><td>  E = T <sup>last</sup> / T <sup>pairs</sup> </td></tr><tr><td>  2 </td><td>  2628 </td><td>  1316 </td><td>  2.00 </td><td>  1033 </td><td>  500 </td><td>  2.07 </td></tr><tr><td>  four </td><td>  5259 </td><td>  1318 </td><td>  3.99 </td><td>  1994 </td><td>  500 </td><td>  3.99 </td></tr><tr><td>  eight </td><td>  10513 </td><td>  2634 </td><td>  3.99 </td><td>  3987 </td><td>  503 </td><td>  7.93 </td></tr><tr><td>  sixteen </td><td>  21045 </td><td>  5268 </td><td>  4.00 </td><td>  7980 </td><td>  1009 </td><td>  7.91 </td></tr><tr><td>  20 </td><td>  26321 </td><td>  6583 </td><td>  4.00 </td><td>  9967 </td><td>  1263 </td><td>  7.89 </td></tr><tr><td>  32 </td><td>  42053 </td><td>  10535 </td><td>  3.99 </td><td>  15948 </td><td>  2014 </td><td>  7.92 </td></tr><tr><td>  40 </td><td>  52566 </td><td>  13170 </td><td>  3.99 </td><td>  19936 </td><td>  2528 </td><td>  7.89 </td></tr></tbody></table><br><p>  It is seen that on Core i7, the acceleration is almost 8 times achieved on 8 streams and then varies slightly.  On Elbrus, acceleration is 4 times achieved on 4 streams and also does not change with an increase in the number of streams.  The speed ratio between Elbrus and Core i7 turned out to be approximately 2.6, while the frequency ratio is 5. </p><br><p>  <strong>findings</strong> </p><br><p>  The usual methods of speeding up computations quite work on Elbrus, and in this regard, programming for it does not require specific knowledge and skills.  In the considered elementary examples for the optimization of the code, Elbrus proved to be just wonderful given the clock frequency of 800 MHz and two times less power consumption than Core i7. </p><br><p>  PS And we also launched our SPARC passport recognition system!  This means that we can now write articles about recognition on another computational architecture. </p><br><p>  <strong>Update</strong> .  An error crept into the results of Example 1, thanks to the <a href="https://habrahabr.ru/users/vlev/" class="user_link">VLev</a> comments <a href="https://habrahabr.ru/users/vlev/" class="user_link">,</a> we found and corrected it.  Results updated. </p><br><h4 id="ispolzovannye-istochniki">  Used sources </h4><br><p>  [1] Henry S. Warren, Jr.  Algorithmic tricks for programmers.  M .: Williams Publishing House, 2014. ISBN 978-5-8459-1838-3 - 512 C. <br>  [2] <a href="http://www.elbrus.ru/arhitektura_elbrus">http://www.elbrus.ru/arhitektura_elbrus</a> . <br>  [3] <a href="http://www.mcst.ru/mikroprocessor-elbrus4s">http://www.mcst.ru/mikroprocessor-elbrus4s</a> . <br>  [4] <a href="http://www.mcst.ru/vysokoproizvoditelnye_biblioteki">http://www.mcst.ru/vysokoproizvoditelnye_biblioteki</a> . <br>  [5] Chris Kaspersky.  ‚ÄúTechnology optimization programs.  Efficient use of memory. ‚Äù  Spb .: BHV-Petersburg, 2003. ISBN 5-94157-232-8 - 464 S. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/317672/">https://habr.com/ru/post/317672/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317662/index.html">Using Github as a user data store</a></li>
<li><a href="../317664/index.html">Briefly about the optimistic UI. Optimistic interface in pictures</a></li>
<li><a href="../317666/index.html">Limits Telegram bot API and work with them on Go</a></li>
<li><a href="../317668/index.html">Virtual keys to the real world</a></li>
<li><a href="../317670/index.html">Own traffic exchange point in the data center. Part 2. Tools for DataLine-IX participants</a></li>
<li><a href="../317674/index.html">Forecasts for 2017: less malware, but more effective attacks</a></li>
<li><a href="../317676/index.html">The final version of Vivaldi 1.6 - working with tabs</a></li>
<li><a href="../317678/index.html">[Peter] Dmitry Chuiko - JEP 295: Ahead-of-Time compilation for HotSpot</a></li>
<li><a href="../317680/index.html">How to make a different time zone in different databases on the same server</a></li>
<li><a href="../317682/index.html">Scaling ClickHouse, managing migrations and sending requests from PHP to the cluster</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>