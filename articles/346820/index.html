<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Deciphering the KeePass Database: A Step-by-Step Guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The other day I needed to implement the decryption of the KeePass database. I was struck by the fact that there is not a single document and not a sin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Deciphering the KeePass Database: A Step-by-Step Guide</h1><div class="post__text post__text-html js-mediator-article"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/files/caa/fc6/134/caafc61345054192a7c27db0e28eb4b4.jpg" alt="image"></div><br><br><p>  The other day I needed to implement the decryption of the KeePass database.  I was struck by the fact that there is not a single document and not a single article with comprehensive information about the decryption algorithm of the .kdb and .kdbx files, taking into account all the nuances.  This prompted me to write this article. </p><br><p>  At the moment there are 2 versions of KeePass: </p><br><ul><li>  KeePass 1.x (generates .kdb files); </li><li>  KeePass 2.x (generates .kdbx files). </li></ul><br><p>  The file structure of the KeePass database (.kdb, .kdbx) consists of 3 parts: </p><br><ul><li>  Signature (not encrypted); </li><li>  Title (not encrypted); </li><li>  Data (encrypted). </li></ul><br><p>  Next, I will discuss in detail how to decrypt the database KeePass 1.x and KeePass 2.x. </p><a name="habracut"></a><br><h4>  <b>KeePass Database Decryption</b> </h4><br><h6>  <u>Sequence of actions</u> : </h6><br><ol><li>  We read the database signature. </li><li>  We read the database header. </li><li>  We generate a master key. </li><li>  Decrypt the database. </li><li>  Check data integrity. </li><li>  If the file has been compressed, unpack it. </li><li>  We decrypt passwords. </li></ol><br><p>  <u>Items 5, 6 and 7 apply only to .kdbx files</u> ! </p><br><h5>  <b>Signature</b> </h5><br><h6>  <u>BaseSignature (4 bytes)</u> </h6><br><p>  The first signature is the same for .kdb and .kdbx files.  She says that this file is a KeePass database: </p><br><ul><li>  0x9AA2D903 </li></ul><br><h6>  <u>VersionSignature (4 bytes)</u> </h6><br><p>  The second signature points to the KeePass version and, therefore, is different for .kdb and .kdbx files: </p><br><ul><li>  0xB54BFB65 - KeePass 1.x (.kdb file). </li><li>  0xB54BFB66 - KeePass 2.x pre-release (.kdbx file). </li><li>  0xB54BFB67 - KeePass 2.x post-release (.kdbx file). </li></ul><br><h6>  <u>FileVersion (4 bytes)</u> </h6><br><p>  The third signature is only for .kdbx files and contains the version of the file.  For .kdb files, this information is contained in the database header. </p><br><p>  <u>Thus, in KeePass 1.x, the signature length is 8 bytes, and in KeePass 2.x - 12 bytes</u> . </p><br><h5>  <b>Headline</b> </h5><br><p>  After the database is signed, the header begins. </p><br><h6>  <u>Heading KeePass 1.x</u> </h6><br><p>  The header of the .kdb file consists of the following fields: </p><br><ol><li>  Flags (4 bytes): This field indicates which types of encryption were used to create the file: <ul><li>  0x01 - SHA256; </li><li>  0x02 - AES256; </li><li>  0x04 - ARC4; </li><li>  0x08 - Twofish. </li></ul></li><li>  Version (4 bytes): file version. </li><li>  Master Seed (16 bytes): used to create a master key. </li><li>  Encryption IV (16 bytes): used to decrypt data. </li><li>  Number of Groups (4 bytes): The total number of groups in the database. </li><li>  Number of Entries (4 bytes): The total number of entries in the database. </li><li>  Content Hash (32 bytes): hash of decrypted data. </li><li>  Transform Seed (32 bytes): used to create a master key. </li><li>  Transform Rounds (4 bytes): used to create a master key. </li></ol><br><h6>  <u>Heading KeePass 2.x</u> </h6><br><p>  In .kdbx files, each header field consists of 3 parts: </p><br><ol><li>  Field ID (1 byte): possible values ‚Äã‚Äãfrom 0 to 10. </li><li>  Data length (2 bytes). </li><li>  Data ([data length] bytes) </li></ol><br><p>  The header of the .kdbx file consists of the following fields: </p><br><ul><li>  ID = 0x01 Comment: this field can be represented in the header, but it was not in my database. </li><li>  ID = 0x02 Cipher ID: UUID indicating the encryption method used (for example, for AES 256 UUID = [0x31, 0xC1, 0xF2, 0xE6, 0xBF, 0x71, 0x43, 0x50, 0xBE, 0x58, 0x05, 0x21, 0x6A, 0xFC, 0x5A, 0xFF]). </li><li>  ID = 0x03 Compression Flags: ID algorithm used to compress the database: <ul><li>  0x00: None; </li><li>  0x01: GZip. </li></ul></li><li>  ID = 0x04 Master Seed: used to create a master key. </li><li>  ID = 0x05 Transform Seed: used to create a master key. </li><li>  ID = 0x06 Transform Rounds: used to create a master key. </li><li>  ID = 0x07 Encryption IV: used to decrypt data. </li><li>  ID = 0x08 Protected Stream Key: used to decrypt passwords. </li><li>  ID = 0x09 Stream Start Bytes: The first 32 bytes of the decrypted database.  They are used to verify the integrity of the decrypted data and the correctness of the master key.  These 32 bytes are randomly generated each time changes are saved in the file. </li><li>  ID = 0x0A Inner Random Stream ID: ID of the algorithm used for decrypting passwords: <ul><li>  0x00: None; </li><li>  0x01: ARC4; </li><li>  0x02: Salsa20. </li></ul></li><li>  ID = 0x00 End of Header: the last field in the database header, after which the database itself begins. </li></ul><br><h5>  <b>Master key generation</b> </h5><br><p>  Master key generation occurs in 2 stages: </p><br><ol><li>  Generate a composite key; </li><li>  Generate master key based on composite key. </li></ol><br><h6>  <u>1. Generate a composite key</u> </h6><br><p>  To generate the composite key, the SHA256 hash algorithm is used.  The tables below show the pseudo-code for generating the composite key, based on which version of KeePass is used, and what input data is needed to decrypt the database (only the password, only the key file or all together): </p><br><p>  <u>KeePass 1.x</u> </p><br><table><tbody><tr><td align="left">  <b>Password</b> </td><td align="left">  sha256 (password) </td></tr><tr><td align="left">  <b>Key file</b> </td><td align="left">  sha256 (keyfile) </td></tr><tr><td align="left">  <b>Password + Key File</b> </td><td align="left">  sha256 (concat (sha256 (password), sha256 (keyfile))) </td></tr></tbody></table><br><p>  <u>KeePass 2.x</u> </p><br><table><tbody><tr><td align="left">  <b>Password</b> </td><td align="left">  sha256 (sha256 (password)) </td></tr><tr><td align="left">  <b>Key file</b> </td><td align="left">  sha256 (sha256 (keyfile)) </td></tr><tr><td align="left">  <b>Password + Key File</b> </td><td align="left">  sha256 (concat (sha256 (password), sha256 (keyfile))) </td></tr><tr><td align="left">  <b>Windows User Account (WUA)</b> </td><td align="left">  sha256 (sha256 (WUA)) </td></tr><tr><td align="left">  <b>Password + Key + File (WUA)</b> </td><td align="left">  sha256 (concat (sha256 (password), sha256 (keyfile), sha256 (WUA))) </td></tr></tbody></table><br><p>  I draw attention to the fact that if several entities are needed to decrypt a database (for example, a password and a key file), you first need to get a hash from each entity, and then connect them together (concat) and take a hash from the combined sequence. </p><br><h6>  <u>2. Generate master key based on composite key</u> </h6><br><ol><li>  You need to <b>encrypt the</b> composite key obtained above using the AES-256-ECB algorithm. <ul><li>  As a key you need to use Transform Seed from the header. </li><li>  This encryption needs to be performed Transform Rounds (from the header) times. </li></ul></li><li>  Using SHA256, we get a hash from an encrypted composite key. </li><li>  We connect Master Seed from the header with the received hash. </li><li>  With SHA256, we get a hash from the combined sequence - <b>this is our master key!</b> </li></ol><br><div class="spoiler">  <b class="spoiler_title">Pseudocode</b> <div class="spoiler_text"><pre><code class="cpp hljs">&lt;p&gt;<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMasterKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   TransformRounds  for(int i = 0; i &lt; TransformRounds; i++) { result = encrypt_AES_ECB(TransformSeed, composite_key); composite_key = result; }&lt;/p&gt; &lt;source&gt;//      hash = sha256(composite_key); //     MasterSeed   key = concat(MasterSeed, hash); //      master_key = sha256(key);</span></span></code> </pre> <br><p>  } <br></p></div></div><br><h5>  <b>Decryption of KeePass 1.x data</b> </h5><br><p>  Immediately after the header, the encrypted database itself begins.  The decryption algorithm is as follows: </p><br><ol><li>  The entire remaining piece of the file is <b>decrypted</b> using the AES-256-CBC algorithm. <ul><li>  As a key, use the master key generated above. </li><li>  As initialization vector we use Encryption IV from the header. </li></ul></li><li>  The last few bytes of the decrypted database are redundant - they are several identical bytes at the end of the file (padding).  To eliminate their influence, you need to read the last byte of the decrypted database - this is the number of "extra" bytes, which should not be further taken into account. </li><li>  Using SHA256, we get the hash from the decrypted data (the <b>bytes from the previous paragraph are not taken into account</b> ). </li><li>  Check that the resulting hash matches the Content Hash field from the header: <ul><li>  If the hash matches, we have successfully decrypted our database!  You can save the decrypted data as an .xml file and make sure that all logins with passwords are decoded correctly, </li><li>  If the hash does not match, it means that either a wrong password or key file was provided, or the data was corrupted. </li></ul></li></ol><br><div class="spoiler">  <b class="spoiler_title">Pseudocode</b> <div class="spoiler_text"><pre> <code class="cpp hljs">&lt;p&gt;<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecryptKeePass1x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    //(  -   -  ) db_len = file_size - signature_size - header_size;&lt;/p&gt; &lt;source&gt;//  decrypted_data = decrypt_AES_256_CBC(master_key, EncryptionIV, encrypted_data); //  ""  extra = decrypted_data[db_len - 1]; //    (  extra !) content_hash = sha256(decrypted_data[:(db_len - extra)]); //,       ontentHash   if (ontentHash == content_hash) return true; else return false;</span></span></code> </pre> <br><p>  } <br></p></div></div><br><h5>  <b>Decryption of KeePass 2.x data</b> </h5><br><p>  Immediately after the End of Header header field, the encrypted database itself begins.  The decryption algorithm is as follows: </p><br><ol><li>  The entire remaining piece of the file is <b>decrypted</b> using the AES-256-CBC algorithm. <ul><li>  As a key, use the master key generated above. </li><li>  As initialization vector we use Encryption IV from the header. </li></ul></li><li>  The last few bytes of the decrypted database are redundant - they are several identical bytes at the end of the file (padding).  To eliminate their influence, you need to read the last byte of the decrypted database - this is the number of "extra" bytes, which should not be further taken into account. </li><li>  Check that the first 32 bytes of the decrypted database coincide with the Stream Start Bytes field of the header: <ul><li>  If the data matches, then we have generated the correct master key, </li><li>  If the data does not match, it means that either an incorrect password was provided, a key file or WUA, or the data was corrupted. </li></ul></li><li>  If the previous item is completed successfully, discard the first 32 bytes.  Check the Compression Flags field of the header.  If GZip file compression was used, then unpack the data. </li><li>  Getting to check the integrity of the data.  The data is divided into blocks, the maximum block size is 1024 * 1024.  Each data block begins with a header.  The header structure is as follows: <ul><li>  Block ID (4 bytes): block number starting from 0; </li><li>  Block data hash (32 bytes); </li><li>  Block size (4 bytes). </li></ul></li><li>  Therefore, the procedure is as follows: <ul><li>  Read the block header. </li><li>  Read block data. </li><li>  Using SHA256, we get a hash from the block data. </li><li>  We check that the hash matches the hash from the header. </li></ul></li><li>  We carry out the sequence of actions from the previous paragraph for each data block.  If the data in all blocks is saved, then we cut out all the block headers, and the resulting sequence is the decrypted database. </li><li>  <b>ATTENTION</b> : even in the decrypted .kdbx file passwords can be in encrypted form. </li><li>  We save the decrypted and decapitated data as an .xml file. </li><li>  We find in it all the nodes with the name "Value", the attribute "Protected", the value of this attribute "True" and take the values ‚Äã‚Äãof these nodes.  These are still encrypted passwords. </li><li>  We decode all encrypted passwords using the base64decode algorithm. </li><li>  In the Inner Random Stream ID header field, we look at which algorithm was used to encrypt passwords.  In my case it was Salsa20. </li><li>  We generate a pseudo-random 64-byte sequence using the Salsa20 algorithm: <ul><li>  As a key, we use the hash of the Protected Stream Key header field, obtained using SHA256. </li><li>  As the initialization vector we use the constant 8-byte sequence 0xE830094B97205D2A. </li></ul></li><li>  <b>IMPORTANT:</b> With this 64-byte sequence, you can decrypt exactly <b>64 characters in order of the combined decoded passwords</b> .  If this is not enough to decrypt all passwords, you need to generate the following pseudo-random sequence and continue to decrypt passwords, etc.  to end. </li><li>  To obtain the final password, it is necessary to make an XOR decoded using base64decode password with a pseudo-random sequence obtained in the previous paragraph (more clearly, the sequence of actions is presented in the pseudo-code below). </li><li>  <b>VERY IMPORTANT</b> : Passwords must be decrypted in order!  It is in the sequence in which they are presented in the xml file. </li><li>  We find in the xml file all the nodes with the name "Value", the attribute "Protected", the value of this attribute "True": <ul><li>  Replace attribute value with ‚ÄúFalse‚Äù. </li><li>  The value of the node is replaced by the decoded password. </li></ul></li><li>  And only now we have received the fully decrypted KeePass 2.x database!  Hooray! =) </li></ol><br><div class="spoiler">  <b class="spoiler_title">Pseudocode</b> <div class="spoiler_text"><pre> <code class="cpp hljs">&lt;p&gt;<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecryptKeePass2x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    //(  -   -  ) db_len = file_size - signature_size - header_size;&lt;/p&gt; &lt;source&gt;//  decrypted_data = decrypt_AES_256_CBC(master_key, EncryptionIV, encrypted_data); //  ""  extra = decrypted_data[db_len - 1]; db_len -= extra; //,   32    //   StreamStartBytes  if (StreamStartBytes != decrypted_data[0:32]) return false; //  32  db_len -= 32; decrypted_data += 32; //  CompressionFlag  //   ,   if (CompressionFlag == 1) unzip(decrypted_data); //   while (db_len &gt; (BlockHeaderSize)) { //    block_data = decrypted_data[0:BlockHeaderSize]; decrypted_data += BlockHeaderSize; db_len -= BlockHeaderSize; if (block_data.blockDataSize == 0) { break; } //    hash = sha256(decrypted_data[0:block_data.blockDataSize]); //,         if(block_data.blockDataHash == hash) { pure_data += decrypted_data[0:block_data.blockDataSize]; decrypted_data += block_data.blockDataSize; db_len -= block_data.blockDataSize; } else { return false; } } //      xml  xml = pure_data.ToXml(); //    ProtectedStreamKey  key = sha256(ProtectedStreamKey); //  Salsa20 IV_SALSA = 0xE830094B97205D2A; salsa.setKey(key); salsa.setIv(IV_SALSA); stream_pointer = 0; key_stream[64] = salsa.generateKeyStream(); //  while(true) { //      "Value", // "Protected",   "True" node = xml.FindNextElement("Value", "Protected", "True"); if (node == NULL) { break; } //        base64decode decoded_pass = base64decode(node.value); //      key_stream for (int i = 0; i &lt; len(decoded_pass); i++) { decoded_pass[i] = decoded_pass[i] ^ key_stream[stream_pointer]; stream_pointer++; // 64     , //    if (stream_pointer &gt;= 64) { key_stream[64] = salsa.generateKeyStream(); stream_pointer = 0; } } //   "Protected"  "False" node.attribute.value = "False"; //    node.value = decoded_pass; } return true;</span></span></code> </pre> <br><p>  } <br></p></div></div><br><p>  That's basically all that I wanted to tell.  I hope this manual will save someone from an extra headache and will be informative and informative =) </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/346820/">https://habr.com/ru/post/346820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346808/index.html">How to kill a techie in tmlide</a></li>
<li><a href="../346812/index.html">Frequency method of identification of linear dynamic systems: theory and practice</a></li>
<li><a href="../346814/index.html">Where the data flow: the consequences of the grand Equifax</a></li>
<li><a href="../346816/index.html">Alternative DBMS Architecture and Application Development Approach</a></li>
<li><a href="../346818/index.html">English words whose pronunciation is always confused</a></li>
<li><a href="../346822/index.html">Parallel STL. Fast way to speed up C ++ STL code</a></li>
<li><a href="../346824/index.html">Who is engaged in machine learning and what is now popular in Data Science? Kaggle user survey results</a></li>
<li><a href="../346826/index.html">How I returned the stolen domain of a popular site</a></li>
<li><a href="../346828/index.html">Creating the main authorization page (landing page) BigBlueButton 2.0b</a></li>
<li><a href="../346830/index.html">MageConf 2017 video and conference materials</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>